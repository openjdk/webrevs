{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+\n+include CopyFiles.gmk\n+include MakeIO.gmk\n","filename":"make\/Bundles.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/CompileDemos.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/CompileInterimLangtools.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    DISABLED_WARNINGS := fallthrough this-escape, \\\n+    DISABLED_WARNINGS := fallthrough, \\\n","filename":"make\/CompileModuleTools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/CompileToolsJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+include CopyFiles.gmk\n+\n","filename":"make\/CopyImportModules.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+include CopyFiles.gmk\n+\n","filename":"make\/CopyInterimTZDB.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/CreateJmods.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/Docs.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/GenerateLinkOptData.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+include CopyFiles.gmk\n+\n","filename":"make\/GraalBuilderImage.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/Images.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -539,0 +539,25 @@\n+  ##############################################################################\n+  # Functions for timers\n+  ##############################################################################\n+\n+  # Store the build times in this directory.\n+  BUILDTIMESDIR=$(OUTPUTDIR)\/make-support\/build-times\n+\n+  # Record starting time for build of a sub repository.\n+  define RecordStartTime\n+\t$(DATE) '+%Y %m %d %H %M %S' | $(AWK) '{ print $$1,$$2,$$3,$$4,$$5,$$6,($$4*3600+$$5*60+$$6) }' > $(BUILDTIMESDIR)\/build_time_start_$(strip $1) && \\\n+\t$(DATE) '+%Y-%m-%d %H:%M:%S' > $(BUILDTIMESDIR)\/build_time_start_$(strip $1)_human_readable\n+  endef\n+\n+  # Record ending time and calculate the difference and store it in a\n+  # easy to read format. Handles builds that cross midnight. Expects\n+  # that a build will never take 24 hours or more.\n+  define RecordEndTime\n+\t$(DATE) '+%Y %m %d %H %M %S' | $(AWK) '{ print $$1,$$2,$$3,$$4,$$5,$$6,($$4*3600+$$5*60+$$6) }' > $(BUILDTIMESDIR)\/build_time_end_$(strip $1)\n+\t$(DATE) '+%Y-%m-%d %H:%M:%S' > $(BUILDTIMESDIR)\/build_time_end_$(strip $1)_human_readable\n+\t$(ECHO) `$(CAT) $(BUILDTIMESDIR)\/build_time_start_$(strip $1)` `$(CAT) $(BUILDTIMESDIR)\/build_time_end_$(strip $1)` $1 | \\\n+\t    $(AWK) '{ F=$$7; T=$$14; if (F > T) { T+=3600*24 }; D=T-F; H=int(D\/3600); \\\n+\t    M=int((D-H*3600)\/60); S=D-H*3600-M*60; printf(\"%02d:%02d:%02d %s\\n\",H,M,S,$$15); }' \\\n+\t    > $(BUILDTIMESDIR)\/build_time_diff_$(strip $1)\n+  endef\n+\n","filename":"make\/InitSupport.gmk","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/JrtfsJar.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/MacBundles.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+include CopyFiles.gmk\n+\n","filename":"make\/ModuleWrapper.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,4 +179,0 @@\n-\n-################################################################################\n-# Simple macros from spec.gmk.in\n-SHARED_LIBRARY=$(LIBRARY_PREFIX)$1$(SHARED_LIBRARY_SUFFIX)\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,10 @@\n+# Locate all sourcecode repositories included in the forest, as absolute paths\n+FindAllReposAbs = \\\n+    $(strip $(sort $(dir $(filter-out $(TOPDIR)\/build\/%, $(wildcard \\\n+        $(addprefix $(TOPDIR)\/, .git *\/.git *\/*\/.git *\/*\/*\/.git *\/*\/*\/*\/.git) \\\n+    )))))\n+\n+# Locate all sourcecode repositories included in the forest, as relative paths\n+FindAllReposRel = \\\n+    $(strip $(subst $(TOPDIR)\/,.,$(patsubst $(TOPDIR)\/%\/, %, $(FindAllReposAbs))))\n+\n","filename":"make\/SourceRevision.gmk","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/StaticLibsImage.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#   Copyright 1992-2022 Free Software Foundation, Inc.\n+#   Copyright 1992-2024 Free Software Foundation, Inc.\n@@ -32,1 +32,1 @@\n-timestamp='2022-09-17'\n+timestamp='2024-01-01'\n@@ -75,1 +75,1 @@\n-Output the configuration name of the system \\`$me' is run on.\n+Output the configuration name of the system '$me' is run on.\n@@ -88,1 +88,1 @@\n-Copyright 1992-2022 Free Software Foundation, Inc.\n+Copyright 1992-2024 Free Software Foundation, Inc.\n@@ -94,1 +94,1 @@\n-Try \\`$me --help' for more information.\"\n+Try '$me --help' for more information.\"\n@@ -130,2 +130,2 @@\n-# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still\n-# use `HOST_CC' if defined, but it is deprecated.\n+# Historically, 'CC_FOR_BUILD' used to be named 'HOST_CC'. We still\n+# use 'HOST_CC' if defined, but it is deprecated.\n@@ -183,0 +183,3 @@\n+\t#if defined(__ANDROID__)\n+\tLIBC=android\n+\t#else\n@@ -190,0 +193,2 @@\n+\t#elif defined(__LLVM_LIBC__)\n+\tLIBC=llvm\n@@ -197,0 +202,1 @@\n+\t#endif\n@@ -487,1 +493,1 @@\n-\t# Japanese Language versions have a version number like `4.1.3-JL'.\n+\t# Japanese Language versions have a version number like '4.1.3-JL'.\n@@ -932,1 +938,1 @@\n-\tUNAME_PROCESSOR=`\/usr\/bin\/uname -p`\n+\tUNAME_PROCESSOR=`uname -p`\n@@ -1004,1 +1010,21 @@\n-\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n+\tset_cc_for_build\n+\tCPU=$UNAME_MACHINE\n+\tLIBCABI=$LIBC\n+\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n+\t    ABI=64\n+\t    sed 's\/^\t    \/\/' << EOF > \"$dummy.c\"\n+\t    #ifdef __ARM_EABI__\n+\t    #ifdef __ARM_PCS_VFP\n+\t    ABI=eabihf\n+\t    #else\n+\t    ABI=eabi\n+\t    #endif\n+\t    #endif\n+EOF\n+\t    cc_set_abi=`$CC_FOR_BUILD -E \"$dummy.c\" 2>\/dev\/null | grep '^ABI' | sed 's, ,,g'`\n+\t    eval \"$cc_set_abi\"\n+\t    case $ABI in\n+\t\teabi | eabihf) CPU=armv8l; LIBCABI=$LIBC$ABI ;;\n+\t    esac\n+\tfi\n+\tGUESS=$CPU-unknown-linux-$LIBCABI\n@@ -1070,0 +1096,9 @@\n+    kvx:Linux:*:*)\n+\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n+\t;;\n+    kvx:cos:*:*)\n+\tGUESS=$UNAME_MACHINE-unknown-cos\n+\t;;\n+    kvx:mbr:*:*)\n+\tGUESS=$UNAME_MACHINE-unknown-mbr\n+\t;;\n@@ -1225,1 +1260,1 @@\n-\t# If we were able to find `uname', then EMX Unix compatibility\n+\t# If we were able to find 'uname', then EMX Unix compatibility\n@@ -1366,1 +1401,1 @@\n-    PENTIUM:*:4.0*:*)\t# Unisys `ClearPath HMP IX 4000' SVR4\/MP effort\n+    PENTIUM:*:4.0*:*)\t# Unisys 'ClearPath HMP IX 4000' SVR4\/MP effort\n@@ -1588,0 +1623,3 @@\n+    *:Ironclad:*:*)\n+\tGUESS=$UNAME_MACHINE-unknown-ironclad\n+\t;;\n","filename":"make\/autoconf\/build-aux\/autoconf-config.guess","additions":51,"deletions":13,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-# Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#   Copyright 1992-2022 Free Software Foundation, Inc.\n+#   Copyright 1992-2024 Free Software Foundation, Inc.\n@@ -33,1 +33,1 @@\n-timestamp='2022-09-17'\n+timestamp='2024-01-01'\n@@ -105,1 +105,1 @@\n-Copyright 1992-2022 Free Software Foundation, Inc.\n+Copyright 1992-2024 Free Software Foundation, Inc.\n@@ -111,1 +111,1 @@\n-Try \\`$me --help' for more information.\"\n+Try '$me --help' for more information.\"\n@@ -159,1 +159,1 @@\n-\t\techo Invalid configuration \\`\"$1\"\\': more than four components >&2\n+\t\techo \"Invalid configuration '$1': more than four components\" >&2\n@@ -174,1 +174,2 @@\n-\t\t\t| storm-chaos* | os2-emx* | rtmk-nova* | managarm-*)\n+\t\t\t| storm-chaos* | os2-emx* | rtmk-nova* | managarm-* \\\n+\t\t\t| windows-* )\n@@ -972,1 +973,1 @@\n-\t# We use `pc' rather than `unknown'\n+\t# We use 'pc' rather than 'unknown'\n@@ -1104,1 +1105,1 @@\n-\tpentiumpro-* | p6-* | 6x86-* | athlon-* | athalon_*-*)\n+\tpentiumpro-* | p6-* | 6x86-* | athlon-* | athlon_*-*)\n@@ -1209,1 +1210,1 @@\n-\t\t\t| aarch64 | aarch64_be \\\n+\t\t\t| aarch64 | aarch64_be | aarch64c | arm64ec \\\n@@ -1228,0 +1229,1 @@\n+\t\t\t| javascript \\\n@@ -1234,0 +1236,1 @@\n+\t\t\t| kvx \\\n@@ -1242,25 +1245,1 @@\n-\t\t\t| mips | mipsbe | mipseb | mipsel | mipsle \\\n-\t\t\t| mips16 \\\n-\t\t\t| mips64 | mips64eb | mips64el \\\n-\t\t\t| mips64octeon | mips64octeonel \\\n-\t\t\t| mips64orion | mips64orionel \\\n-\t\t\t| mips64r5900 | mips64r5900el \\\n-\t\t\t| mips64vr | mips64vrel \\\n-\t\t\t| mips64vr4100 | mips64vr4100el \\\n-\t\t\t| mips64vr4300 | mips64vr4300el \\\n-\t\t\t| mips64vr5000 | mips64vr5000el \\\n-\t\t\t| mips64vr5900 | mips64vr5900el \\\n-\t\t\t| mipsisa32 | mipsisa32el \\\n-\t\t\t| mipsisa32r2 | mipsisa32r2el \\\n-\t\t\t| mipsisa32r3 | mipsisa32r3el \\\n-\t\t\t| mipsisa32r5 | mipsisa32r5el \\\n-\t\t\t| mipsisa32r6 | mipsisa32r6el \\\n-\t\t\t| mipsisa64 | mipsisa64el \\\n-\t\t\t| mipsisa64r2 | mipsisa64r2el \\\n-\t\t\t| mipsisa64r3 | mipsisa64r3el \\\n-\t\t\t| mipsisa64r5 | mipsisa64r5el \\\n-\t\t\t| mipsisa64r6 | mipsisa64r6el \\\n-\t\t\t| mipsisa64sb1 | mipsisa64sb1el \\\n-\t\t\t| mipsisa64sr71k | mipsisa64sr71kel \\\n-\t\t\t| mipsr5900 | mipsr5900el \\\n-\t\t\t| mipstx39 | mipstx39el \\\n+\t\t\t| mips* \\\n@@ -1272,0 +1251,1 @@\n+\t\t\t| nanomips* \\\n@@ -1303,0 +1283,1 @@\n+\t\t\t| vc4 \\\n@@ -1314,1 +1295,1 @@\n-\t\t\t\techo Invalid configuration \\`\"$1\"\\': machine \\`\"$cpu-$vendor\"\\' not recognized 1>&2\n+\t\t\t\techo \"Invalid configuration '$1': machine '$cpu-$vendor' not recognized\" 1>&2\n@@ -1335,1 +1316,1 @@\n-if test x$basic_os != x\n+if test x\"$basic_os\" != x\n@@ -1340,0 +1321,1 @@\n+obj=\n@@ -1539,1 +1521,2 @@\n-\t\t\tos=elf\n+\t\t\tos=\n+\t\t\tobj=elf\n@@ -1543,0 +1526,5 @@\n+\taout* | coff* | elf* | pe*)\n+\t\t# These are machine code file formats, not OSes\n+\t\tobj=$os\n+\t\tos=\n+\t\t;;\n@@ -1561,0 +1549,1 @@\n+obj=\n@@ -1563,1 +1552,2 @@\n-\t\tos=elf\n+\t\tos=\n+\t\tobj=elf\n@@ -1566,1 +1556,2 @@\n-\t\tos=elf\n+\t\tos=\n+\t\tobj=elf\n@@ -1576,1 +1567,2 @@\n-\t\tos=aout\n+\t\tos=\n+\t\tobj=aout\n@@ -1579,1 +1571,2 @@\n-\t\tos=coff\n+\t\tos=\n+\t\tobj=coff\n@@ -1582,1 +1575,2 @@\n-\t\tos=elf\n+\t\tos=\n+\t\tobj=elf\n@@ -1588,1 +1582,2 @@\n-\t\tos=elf\n+\t\tos=\n+\t\tobj=elf\n@@ -1591,1 +1586,2 @@\n-\t\tos=coff\n+\t\tos=\n+\t\tobj=coff\n@@ -1594,1 +1590,2 @@\n-\t\tos=coff\n+\t\tos=\n+\t\tobj=coff\n@@ -1597,1 +1594,2 @@\n-\t\tos=coff\n+\t\tos=\n+\t\tobj=coff\n@@ -1619,1 +1617,2 @@\n-\t\tos=aout\n+\t\tos=\n+\t\tobj=aout\n@@ -1622,1 +1621,2 @@\n-\t\tos=elf\n+\t\tos=\n+\t\tobj=elf\n@@ -1625,1 +1625,2 @@\n-\t\tos=elf\n+\t\tos=\n+\t\tobj=elf\n@@ -1627,2 +1628,3 @@\n-\tmips*-*)\n-\t\tos=elf\n+\tmips*-*|nanomips*-*)\n+\t\tos=\n+\t\tobj=elf\n@@ -1631,1 +1633,2 @@\n-\t\tos=coff\n+\t\tos=\n+\t\tobj=coff\n@@ -1640,1 +1643,2 @@\n-\t\tos=elf\n+\t\tos=\n+\t\tobj=elf\n@@ -1721,1 +1725,2 @@\n-\t\tos=coff\n+\t\tos=\n+\t\tobj=coff\n@@ -1724,1 +1729,2 @@\n-\t\tos=coff\n+\t\tos=\n+\t\tobj=coff\n@@ -1742,1 +1748,2 @@\n-# Now, validate our (potentially fixed-up) OS.\n+# Now, validate our (potentially fixed-up) individual pieces (OS, OBJ).\n+\n@@ -1745,1 +1752,1 @@\n-\tmusl* | newlib* | relibc* | uclibc*)\n+\tllvm* | musl* | newlib* | relibc* | uclibc*)\n@@ -1753,0 +1760,3 @@\n+\t# See `case $cpu-$os` validation below\n+\tghcjs)\n+\t\t;;\n@@ -1761,1 +1771,1 @@\n-\t     | os9* | macos* | osx* | ios* \\\n+\t     | os9* | macos* | osx* | ios* | tvos* | watchos* \\\n@@ -1770,2 +1780,2 @@\n-\t     | bosx* | nextstep* | cxux* | aout* | elf* | oabi* \\\n-\t     | ptx* | coff* | ecoff* | winnt* | domain* | vsta* \\\n+\t     | bosx* | nextstep* | cxux* | oabi* \\\n+\t     | ptx* | ecoff* | winnt* | domain* | vsta* \\\n@@ -1774,1 +1784,1 @@\n-\t     | cygwin* | msys* | pe* | moss* | proelf* | rtems* \\\n+\t     | cygwin* | msys* | moss* | proelf* | rtems* \\\n@@ -1787,1 +1797,1 @@\n-\t     | fiwix* | mlibc* )\n+\t     | fiwix* | mlibc* | cos* | mbr* | ironclad* )\n@@ -1793,0 +1803,7 @@\n+\t# This refers to builds using the UEFI calling convention\n+\t# (which depends on the architecture) and PE file format.\n+\t# Note that this is both a different calling convention and\n+\t# different file format than that of GNU-EFI\n+\t# (x86_64-w64-mingw32).\n+\tuefi)\n+\t\t;;\n@@ -1795,1 +1812,1 @@\n-\tkernel* )\n+\tkernel* | msvc* )\n@@ -1798,0 +1815,6 @@\n+\t'')\n+\t\tif test x\"$obj\" = x\n+\t\tthen\n+\t\t\techo \"Invalid configuration '$1': Blank OS only allowed with explicit machine code file format\" 1>&2\n+\t\tfi\n+\t\t;;\n@@ -1799,1 +1822,27 @@\n-\t\techo Invalid configuration \\`\"$1\"\\': OS \\`\"$os\"\\' not recognized 1>&2\n+\t\techo \"Invalid configuration '$1': OS '$os' not recognized\" 1>&2\n+\t\texit 1\n+\t\t;;\n+esac\n+\n+case $obj in\n+\taout* | coff* | elf* | pe*)\n+\t\t;;\n+\t'')\n+\t\t# empty is fine\n+\t\t;;\n+\t*)\n+\t\techo \"Invalid configuration '$1': Machine code format '$obj' not recognized\" 1>&2\n+\t\texit 1\n+\t\t;;\n+esac\n+\n+# Here we handle the constraint that a (synthetic) cpu and os are\n+# valid only in combination with each other and nowhere else.\n+case $cpu-$os in\n+\t# The \"javascript-unknown-ghcjs\" triple is used by GHC; we\n+\t# accept it here in order to tolerate that, but reject any\n+\t# variations.\n+\tjavascript-ghcjs)\n+\t\t;;\n+\tjavascript-* | *-ghcjs)\n+\t\techo \"Invalid configuration '$1': cpu '$cpu' is not valid with os '$os$obj'\" 1>&2\n@@ -1806,3 +1855,4 @@\n-case $kernel-$os in\n-\tlinux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* \\\n-\t\t   | linux-musl* | linux-relibc* | linux-uclibc* )\n+case $kernel-$os-$obj in\n+\tlinux-gnu*- | linux-android*- | linux-dietlibc*- | linux-llvm*- \\\n+\t\t    | linux-mlibc*- | linux-musl*- | linux-newlib*- \\\n+\t\t    | linux-relibc*- | linux-uclibc*- )\n@@ -1810,1 +1860,1 @@\n-\tuclinux-uclibc* )\n+\tuclinux-uclibc*- )\n@@ -1812,1 +1862,1 @@\n-\tmanagarm-mlibc* | managarm-kernel* )\n+\tmanagarm-mlibc*- | managarm-kernel*- )\n@@ -1814,1 +1864,4 @@\n-\t-dietlibc* | -newlib* | -musl* | -relibc* | -uclibc* | -mlibc* )\n+\twindows*-msvc*-)\n+\t\t;;\n+\t-dietlibc*- | -llvm*- | -mlibc*- | -musl*- | -newlib*- | -relibc*- \\\n+\t\t    | -uclibc*- )\n@@ -1817,1 +1870,1 @@\n-\t\techo \"Invalid configuration \\`$1': libc \\`$os' needs explicit kernel.\" 1>&2\n+\t\techo \"Invalid configuration '$1': libc '$os' needs explicit kernel.\" 1>&2\n@@ -1820,2 +1873,2 @@\n-\t-kernel* )\n-\t\techo \"Invalid configuration \\`$1': \\`$os' needs explicit kernel.\" 1>&2\n+\t-kernel*- )\n+\t\techo \"Invalid configuration '$1': '$os' needs explicit kernel.\" 1>&2\n@@ -1824,2 +1877,2 @@\n-\t*-kernel* )\n-\t\techo \"Invalid configuration \\`$1': \\`$kernel' does not support \\`$os'.\" 1>&2\n+\t*-kernel*- )\n+\t\techo \"Invalid configuration '$1': '$kernel' does not support '$os'.\" 1>&2\n@@ -1828,1 +1881,3 @@\n-\tkfreebsd*-gnu* | kopensolaris*-gnu*)\n+\t*-msvc*- )\n+\t\techo \"Invalid configuration '$1': '$os' needs 'windows'.\" 1>&2\n+\t\texit 1\n@@ -1830,1 +1885,1 @@\n-\tvxworks-simlinux | vxworks-simwindows | vxworks-spe)\n+\tkfreebsd*-gnu*- | kopensolaris*-gnu*-)\n@@ -1832,1 +1887,1 @@\n-\tnto-qnx*)\n+\tvxworks-simlinux- | vxworks-simwindows- | vxworks-spe-)\n@@ -1834,1 +1889,5 @@\n-\tos2-emx)\n+\tnto-qnx*-)\n+\t\t;;\n+\tos2-emx-)\n+\t\t;;\n+\t*-eabi*- | *-gnueabi*-)\n@@ -1836,1 +1895,3 @@\n-\t*-eabi* | *-gnueabi*)\n+\tnone--*)\n+\t\t# None (no kernel, i.e. freestanding \/ bare metal),\n+\t\t# can be paired with an machine code file format\n@@ -1838,1 +1899,1 @@\n-\t-*)\n+\t-*-)\n@@ -1841,2 +1902,5 @@\n-\t*-*)\n-\t\techo \"Invalid configuration \\`$1': Kernel \\`$kernel' not known to work with OS \\`$os'.\" 1>&2\n+\t--*)\n+\t\t# Blank kernel and OS with real machine code file format is always fine.\n+\t\t;;\n+\t*-*-*)\n+\t\techo \"Invalid configuration '$1': Kernel '$kernel' not known to work with OS '$os'.\" 1>&2\n@@ -1925,1 +1989,1 @@\n-echo \"$cpu-$vendor-${kernel:+$kernel-}$os\"\n+echo \"$cpu-$vendor${kernel:+-$kernel}${os:+-$os}${obj:+-$obj}\"\n","filename":"make\/autoconf\/build-aux\/autoconf-config.sub","additions":149,"deletions":85,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-    CFLAGS_OS_DEF_JVM=\"-DAIX -D_LARGE_FILES\"\n+    CFLAGS_OS_DEF_JVM=\"-DAIX -Dalloca'(size)'=__builtin_alloca'(size)' -D_LARGE_FILES\"\n@@ -479,9 +479,0 @@\n-  # Setup some hard coded includes\n-  ALWAYS_CFLAGS_JDK=\" \\\n-      -I\\$(SUPPORT_OUTPUTDIR)\/modules_include\/java.base \\\n-      -I\\$(SUPPORT_OUTPUTDIR)\/modules_include\/java.base\/\\$(OPENJDK_TARGET_OS_INCLUDE_SUBDIR) \\\n-      -I${TOPDIR}\/src\/java.base\/share\/native\/libjava \\\n-      -I${TOPDIR}\/src\/java.base\/$OPENJDK_TARGET_OS_TYPE\/native\/libjava \\\n-      -I${TOPDIR}\/src\/hotspot\/share\/include \\\n-      -I${TOPDIR}\/src\/hotspot\/os\/${HOTSPOT_TARGET_OS_TYPE}\/include\"\n-\n@@ -874,1 +865,1 @@\n-  CFLAGS_JDK_COMMON=\"$ALWAYS_CFLAGS_JDK $ALWAYS_DEFINES_JDK $TOOLCHAIN_CFLAGS_JDK \\\n+  CFLAGS_JDK_COMMON=\"$ALWAYS_DEFINES_JDK $TOOLCHAIN_CFLAGS_JDK \\\n","filename":"make\/autoconf\/flags-cflags.m4","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,5 +34,0 @@\n-\n-  # The target dir matches the name of VM variant\n-  TARGET_JVM_VARIANT_PATH=$JVM_VARIANT_MAIN\n-\n-  # On some platforms (mac) the linker warns about non existing -L dirs.\n@@ -42,4 +37,0 @@\n-\n-  # When building a buildjdk, it's always only the server variant\n-  BUILD_JVM_VARIANT_PATH=server\n-\n@@ -48,2 +39,0 @@\n-  LDFLAGS_TESTEXE=\"${TARGET_LDFLAGS_JDK_LIBPATH}\"\n-  AC_SUBST(LDFLAGS_TESTEXE)\n@@ -158,1 +147,1 @@\n-  LDFLAGS_CXX_JDK=\"$BASIC_LDFLAGS_ONLYCXX $BASIC_LDFLAGS_ONLYCXX_JDK_ONLY $DEBUGLEVEL_LDFLAGS_JDK_ONLY\"\n+  LDFLAGS_CXX_JDK=\"$DEBUGLEVEL_LDFLAGS_JDK_ONLY\"\n@@ -200,8 +189,0 @@\n-  # JVM_VARIANT_PATH depends on if this is build or target...\n-  if test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n-    $1_LDFLAGS_JDK_LIBPATH=\"-libpath:\\$(SUPPORT_OUTPUTDIR)\/modules_libs\/java.base\"\n-  else\n-    $1_LDFLAGS_JDK_LIBPATH=\"-L\\$(SUPPORT_OUTPUTDIR)\/modules_libs\/java.base \\\n-        -L\\$(SUPPORT_OUTPUTDIR)\/modules_libs\/java.base\/${$1_JVM_VARIANT_PATH}\"\n-  fi\n-\n@@ -212,2 +193,1 @@\n-      ${$1_LDFLAGS_JDK_LIBPATH} $SHARED_LIBRARY_FLAGS \\\n-      $REPRODUCIBLE_LDFLAGS $FILE_MACRO_LDFLAGS\"\n+      $SHARED_LIBRARY_FLAGS $REPRODUCIBLE_LDFLAGS $FILE_MACRO_LDFLAGS\"\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -852,1 +852,1 @@\n-  ENABLE_CODESIGN=false\n+  MACOSX_CODESIGN_MODE=disabled\n@@ -862,1 +862,0 @@\n-    MACOSX_CODESIGN_MODE=disabled\n@@ -905,2 +904,0 @@\n-    AC_SUBST(MACOSX_CODESIGN_IDENTITY)\n-    AC_SUBST(MACOSX_CODESIGN_MODE)\n@@ -908,0 +905,2 @@\n+  AC_SUBST(MACOSX_CODESIGN_IDENTITY)\n+  AC_SUBST(MACOSX_CODESIGN_MODE)\n","filename":"make\/autoconf\/jdk-options.m4","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -132,6 +132,0 @@\n-  BASIC_JDKLIB_LIBS=\"\"\n-  BASIC_JDKLIB_LIBS_TARGET=\"\"\n-  if test \"x$TOOLCHAIN_TYPE\" != xmicrosoft; then\n-    BASIC_JDKLIB_LIBS=\"-ljava -ljvm\"\n-  fi\n-\n@@ -173,1 +167,0 @@\n-  JDKLIB_LIBS=\"$BASIC_JDKLIB_LIBS\"\n@@ -175,1 +168,1 @@\n-  OPENJDK_BUILD_JDKLIB_LIBS=\"$BASIC_JDKLIB_LIBS\"\n+  OPENJDK_BUILD_JDKLIB_LIBS=\"\"\n@@ -178,1 +171,0 @@\n-  AC_SUBST(JDKLIB_LIBS)\n","filename":"make\/autoconf\/libraries.m4","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -558,1 +558,0 @@\n-JDKLIB_LIBS := @JDKLIB_LIBS@\n@@ -574,3 +573,0 @@\n-# Compiler and linker flags used when building native tests\n-LDFLAGS_TESTEXE := @LDFLAGS_TESTEXE@\n-\n@@ -632,7 +628,0 @@\n-# Different OS:es have different ways of naming shared libraries.\n-# The SHARED_LIBRARY and STATIC_LIBRARY macros takes \"verify\" as and argument and returns:\n-#    \"libverify.so\" or \"libverify.dylib\" or \"verify.dll\" depending on platform.\n-# (Note absence of := assignment, because we do not want to evaluate the macro body here)\n-SHARED_LIBRARY = @SHARED_LIBRARY@\n-STATIC_LIBRARY = @STATIC_LIBRARY@\n-\n@@ -684,0 +673,4 @@\n+# A file containing a way to uniquely identify the source code revision that\n+# the build was created from\n+SOURCE_REVISION_TRACKER := $(SUPPORT_OUTPUTDIR)\/src-rev\/source-revision-tracker\n+\n","filename":"make\/autoconf\/spec.gmk.template","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -177,2 +177,0 @@\n-    SHARED_LIBRARY='[$]1.dll'\n-    STATIC_LIBRARY='[$]1.lib'\n@@ -185,2 +183,0 @@\n-    SHARED_LIBRARY='lib[$]1.so'\n-    STATIC_LIBRARY='lib[$]1.a'\n@@ -190,2 +186,2 @@\n-      # For full static builds, we're overloading the SHARED_LIBRARY\n-      # variables in order to limit the amount of changes required.\n+      # For full static builds, we're overloading the shared library suffix\n+      # in order to limit the amount of changes required.\n@@ -197,1 +193,0 @@\n-        SHARED_LIBRARY='lib[$]1.a'\n@@ -200,1 +195,0 @@\n-        SHARED_LIBRARY='lib[$]1.dylib'\n@@ -209,2 +203,0 @@\n-  AC_SUBST(SHARED_LIBRARY)\n-  AC_SUBST(STATIC_LIBRARY)\n@@ -956,5 +948,1 @@\n-    if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n-      HOTSPOT_TOOLCHAIN_TYPE=xlc\n-    else\n-      HOTSPOT_TOOLCHAIN_TYPE=gcc\n-    fi\n+    HOTSPOT_TOOLCHAIN_TYPE=gcc\n","filename":"make\/autoconf\/toolchain.m4","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,303 @@\n+#\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+ifeq (,$(_MAKEBASE_GMK))\n+  $(error You must include MakeBase.gmk prior to including FileUtils.gmk)\n+endif\n+\n+################################################################################\n+#\n+# Common file utility functions\n+#\n+################################################################################\n+\n+################################################################################\n+# Replace question marks with space in string. This macro needs to be called on\n+# files from FindFiles in case any of them contains space in their file name,\n+# since FindFiles replaces space with ?.\n+# Param 1 - String to replace in\n+DecodeSpace = \\\n+    $(subst ?,$(SPACE),$(strip $1))\n+\n+EncodeSpace = \\\n+    $(subst $(SPACE),?,$(strip $1))\n+\n+################################################################################\n+# Take two paths and return the path of the last common directory.\n+# Ex: \/foo\/bar\/baz, \/foo\/bar\/banan -> \/foo\/bar\n+#     foo\/bar\/baz, \/foo\/bar -> <empty>\n+#\n+# The x prefix is used to preserve the presence of the initial slash\n+# On Windows paths are treated as case-insensitive\n+#\n+# $1 - Path to compare\n+# $2 - Other path to compare\n+FindCommonPathPrefix = \\\n+    $(call DecodeSpace,$(patsubst x%,%,$(subst $(SPACE),\/,$(strip \\\n+        $(call FindCommonPathPrefixHelper1, \\\n+            $(subst \/,$(SPACE),x$(call EncodeSpace,$(strip $1))), \\\n+            $(subst \/,$(SPACE),x$(call EncodeSpace,$(strip $2)))) \\\n+    ))))\n+\n+FindCommonPathPrefixHelper1 = \\\n+    $(if $(filter $(OPENJDK_TARGET_OS), windows), \\\n+        $(call FindCommonPathPrefixHelper2,$(call uppercase,$1),$(call uppercase,$2),$1), \\\n+        $(call FindCommonPathPrefixHelper2,$1,$2,$1))\n+\n+FindCommonPathPrefixHelper2 = \\\n+    $(if $(call equals, $(firstword $1), $(firstword $2)), \\\n+      $(if $(call equals, $(firstword $1),),, \\\n+        $(firstword $3) \\\n+        $(call FindCommonPathPrefixHelper2, \\\n+            $(wordlist 2, $(words $1), $1), \\\n+            $(wordlist 2, $(words $2), $2), \\\n+            $(wordlist 2, $(words $3), $3) \\\n+        ) \\\n+      ) \\\n+    )\n+\n+# Computes the relative path from a directory to a file\n+# $1 - File to compute the relative path to\n+# $2 - Directory to compute the relative path from\n+RelativePath = \\\n+    $(call DecodeSpace,$(strip $(call RelativePathHelper,$(call EncodeSpace \\\n+        ,$(strip $1)),$(call EncodeSpace \\\n+        ,$(strip $2)),$(call EncodeSpace \\\n+        ,$(call FindCommonPathPrefix,$1,$2)))))\n+\n+RelativePathHelper = \\\n+    $(eval $3_prefix_length := $(words $(subst \/,$(SPACE),$3))) \\\n+    $(eval $1_words := $(subst \/,$(SPACE),$1)) \\\n+    $(eval $2_words := $(subst \/,$(SPACE),$2)) \\\n+    $(if $(call equals,$($3_prefix_length),0),, \\\n+        $(eval $1_words := $(wordlist 2,$(words $($1_words)),$(wordlist \\\n+            $($3_prefix_length),$(words $($1_words)),$($1_words)))) \\\n+        $(eval $2_words := $(wordlist 2,$(words $($2_words)),$(wordlist \\\n+            $($3_prefix_length),$(words $($2_words)),$($2_words)))) \\\n+    ) \\\n+    $(eval $1_suffix := $(subst $(SPACE),\/,$($1_words))) \\\n+    $(eval $2_dotdots := $(subst $(SPACE),\/,$(foreach d,$($2_words),..))) \\\n+    $(if $($1_suffix), \\\n+        $(if $($2_dotdots), $($2_dotdots)\/$($1_suffix), $($1_suffix)), \\\n+        $(if $($2_dotdots), $($2_dotdots), .))\n+\n+# Make directory for target file. Should handle spaces in filenames. Just\n+# calling $(call MakeDir $(@D)) will not work if the directory contains a space\n+# and the target file already exists. In that case, the target file will have\n+# its wildcard ? resolved and the $(@D) will evaluate each space separated dir\n+# part on its own.\n+MakeTargetDir = \\\n+    $(call MakeDir, $(dir $(call EncodeSpace, $@)))\n+\n+################################################################################\n+# All install-file and related macros automatically call DecodeSpace when needed.\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  # On mac, extended attributes sometimes creep into the source files, which may later\n+  # cause the creation of ._* files which confuses testing. Clear these with xattr if\n+  # set. Some files get their write permissions removed after being copied to the\n+  # output dir. When these are copied again to images, xattr would fail. By only clearing\n+  # attributes when they are present, failing on this is avoided.\n+  #\n+  # If copying a soft link to a directory, need to delete the target first to avoid\n+  # weird errors.\n+  define install-file\n+\t$(call MakeTargetDir)\n+\t$(RM) '$(call DecodeSpace, $@)'\n+        # Work around a weirdness with cp on Macosx. When copying a symlink, if\n+        # the target of the link is write protected (e.g. 444), cp will add\n+        # write permission for the user on the target file (644). Avoid this by\n+        # using ln to create a new link instead.\n+\tif [ -h '$(call DecodeSpace, $<)' ]; then \\\n+\t  $(LN) -s \"`$(READLINK) '$(call DecodeSpace, $<)'`\" '$(call DecodeSpace, $@)'; \\\n+\telse \\\n+\t  $(CP) -fRP '$(call DecodeSpace, $<)' '$(call DecodeSpace, $@)'; \\\n+\tfi\n+\tif [ -n \"`$(XATTR) -ls '$(call DecodeSpace, $@)'`\" ]; then \\\n+\t  $(XATTR) -cs '$(call DecodeSpace, $@)'; \\\n+\tfi\n+  endef\n+else\n+  define install-file\n+\t$(call MakeTargetDir)\n+\t$(CP) -fP '$(call DecodeSpace, $<)' '$(call DecodeSpace, $@)'\n+  endef\n+endif\n+\n+# Variant of install file that does not preserve symlinks\n+define install-file-nolink\n+\t$(call MakeTargetDir)\n+\t$(CP) -f '$(call DecodeSpace, $<)' '$(call DecodeSpace, $@)'\n+endef\n+\n+################################################################################\n+# link-file-* works similarly to install-file but creates a symlink instead.\n+# There are two versions, either creating a relative or an absolute link. Be\n+# careful when using this on Windows since the symlink created is only valid in\n+# the unix emulation environment.\n+# In msys2 we use mklink \/J because its ln would perform a deep copy of the target.\n+# This inhibits performance and can lead to issues with long paths. With mklink \/J\n+# relative linking does not work, so we handle the link as absolute path.\n+ifeq ($(OPENJDK_BUILD_OS_ENV), windows.msys2)\n+  define link-file-relative\n+\t$(call MakeTargetDir)\n+\t$(RM) '$(call DecodeSpace, $@)'\n+\tcmd \/\/c \"mklink \/J $(call FixPath, $(call DecodeSpace, $@)) $(call FixPath, $(call DecodeSpace, $<))\"\n+  endef\n+else\n+  define link-file-relative\n+\t$(call MakeTargetDir)\n+\t$(RM) '$(call DecodeSpace, $@)'\n+\t$(LN) -s '$(call DecodeSpace, $(call RelativePath, $<, $(@D)))' '$(call DecodeSpace, $@)'\n+  endef\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS_ENV), windows.msys2)\n+  define link-file-absolute\n+\t$(call MakeTargetDir)\n+\t$(RM) '$(call DecodeSpace, $@)'\n+\tcmd \/\/c \"mklink \/J $(call FixPath, $(call DecodeSpace, $@)) $(call FixPath, $(call DecodeSpace, $<))\"\n+  endef\n+else\n+  define link-file-absolute\n+\t$(call MakeTargetDir)\n+\t$(RM) '$(call DecodeSpace, $@)'\n+\t$(LN) -s '$(call DecodeSpace, $<)' '$(call DecodeSpace, $@)'\n+  endef\n+endif\n+\n+################################################################################\n+\n+# Recursive wildcard function. Walks down directories recursively and matches\n+# files with the search patterns. Patterns use standard file wildcards (* and\n+# ?).\n+#\n+# $1 - Directories to start search in\n+# $2 - Search patterns\n+rwildcard = \\\n+    $(strip \\\n+        $(foreach d, \\\n+          $(patsubst %\/,%,$(sort $(dir $(wildcard $(addsuffix \/*\/*, $(strip $1)))))), \\\n+          $(call rwildcard,$d,$2) \\\n+        ) \\\n+        $(call DoubleDollar, $(wildcard $(foreach p, $2, $(addsuffix \/$(strip $p), $(strip $1))))) \\\n+    )\n+\n+# Find non directories using recursive wildcard function. This function may\n+# be used directly when a small amount of directories is expected to be\n+# searched and caching is not expected to be of use.\n+#\n+# $1 - Directory to start search in\n+# $2 - Optional search patterns, defaults to '*'.\n+WildcardFindFiles = \\\n+    $(sort $(strip \\\n+        $(eval WildcardFindFiles_result := $(call rwildcard,$(patsubst %\/,%,$1),$(if $(strip $2),$2,*))) \\\n+        $(filter-out $(patsubst %\/,%,$(sort $(dir $(WildcardFindFiles_result)))), \\\n+            $(WildcardFindFiles_result) \\\n+        ) \\\n+    ))\n+\n+# Find non directories using the find utility in the shell. Safe to call for\n+# non existing directories, or directories containing wildcards.\n+#\n+# Files containing space will get spaces replaced with ? because GNU Make\n+# cannot handle lists of files with space in them. By using ?, make will match\n+# the wildcard to space in many situations so we don't need to replace back\n+# to space on every use. While not a complete solution it does allow some uses\n+# of FindFiles to function with spaces in file names, including for\n+# SetupCopyFiles. Unfortunately this does not work for WildcardFindFiles so\n+# if files with spaces are anticipated, use ShellFindFiles directly.\n+#\n+# $1 - Directories to start search in.\n+# $2 - Optional search patterns, empty means find everything. Patterns use\n+#      standard file wildcards (* and ?) and should not be quoted.\n+# $3 - Optional options to find.\n+ShellFindFiles = \\\n+    $(if $(wildcard $1), \\\n+      $(sort \\\n+          $(shell $(FIND) $3 $(patsubst %\/,%,$(wildcard $1)) \\( -type f -o -type l \\) \\\n+              $(if $(strip $2), -a \\( -name \"$(firstword $2)\" \\\n+              $(foreach p, $(filter-out $(firstword $2), $2), -o -name \"$(p)\") \\)) \\\n+              | $(TR) ' ' '?' \\\n+          ) \\\n+      ) \\\n+    )\n+\n+# Find non directories using the method most likely to work best for the\n+# current build host\n+#\n+# $1 - Directory to start search in\n+# $2 - Optional search patterns, defaults to '*'.\n+ifeq ($(OPENJDK_BUILD_OS)-$(RWILDCARD_WORKS), windows-true)\n+  DirectFindFiles = $(WildcardFindFiles)\n+else\n+  DirectFindFiles = $(ShellFindFiles)\n+endif\n+\n+# Finds files using a cache that is populated by FillFindCache below. If any of\n+# the directories given have not been cached, DirectFindFiles is used for\n+# everything. Caching is especially useful in Cygwin, where file finds are very\n+# costly.\n+#\n+# $1 - Directories to start search in.\n+# $2 - Optional search patterns. If used, no caching is done.\n+CacheFindFiles_CACHED_DIRS :=\n+CacheFindFiles_CACHED_FILES :=\n+CacheFindFiles = \\\n+    $(if $2, \\\n+      $(call DirectFindFiles, $1, $2) \\\n+    , \\\n+      $(if $(filter-out $(addsuffix \/%, $(CacheFindFiles_CACHED_DIRS)) \\\n+          $(CacheFindFiles_CACHED_DIRS), $1), \\\n+        $(call DirectFindFiles, $1) \\\n+      , \\\n+        $(filter $(addsuffix \/%,$(patsubst %\/,%,$1)) $1,$(CacheFindFiles_CACHED_FILES)) \\\n+      ) \\\n+    )\n+\n+# Explicitly adds files to the find cache used by CacheFindFiles.\n+#\n+# $1 - Directories to start search in\n+FillFindCache = \\\n+    $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix \/%,\\\n+        $$(CacheFindFiles_CACHED_DIRS)) $$(CacheFindFiles_CACHED_DIRS), $1)) \\\n+    $(if $(CacheFindFiles_NEW_DIRS), \\\n+      $(eval CacheFindFiles_CACHED_DIRS += $$(patsubst %\/,%,$$(CacheFindFiles_NEW_DIRS))) \\\n+      $(eval CacheFindFiles_CACHED_FILES := $$(sort $$(CacheFindFiles_CACHED_FILES) \\\n+          $$(call DirectFindFiles, $$(CacheFindFiles_NEW_DIRS)))) \\\n+    )\n+\n+# Findfiles is the default macro that should be used to find files in the file\n+# system. This function does not always support files with spaces in the names.\n+# If files with spaces are anticipated, use ShellFindFiles directly.\n+#\n+# $1 - Directories to start search in.\n+# $2 - Optional search patterns, empty means find everything. Patterns use\n+#      standard file wildcards (* and ?) and should not be quoted.\n+ifeq ($(DISABLE_CACHE_FIND), true)\n+  FindFiles = $(DirectFindFiles)\n+else\n+  FindFiles = $(CacheFindFiles)\n+endif\n","filename":"make\/common\/FileUtils.gmk","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+include MakeIO.gmk\n+\n","filename":"make\/common\/JarArchive.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+include MakeIO.gmk\n+\n","filename":"make\/common\/JavaCompilation.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,9 @@\n-# Process a dir description such as \"java.base:headers\" into a set of proper absolute paths.\n-ProcessDir = \\\n+HOTSPOT_INCLUDE_DIR := $(TOPDIR)\/src\/hotspot\/share\/include \\\n+    $(TOPDIR)\/src\/hotspot\/os\/$(HOTSPOT_TARGET_OS_TYPE)\/include\n+\n+# Preprocess a source dir destination. Pass on absolute paths unchanged. Expand\n+# description such as \"java.base:headers\" into a set of proper absolute paths,\n+# by looking in $MODULE\/[shared|$OS|$OSTYPE]\/native.\n+# Treat *:libjvm as a special case, and replace it with the proper hotspot\n+# include directories.\n+ProcessSrcDir = \\\n@@ -82,1 +89,6 @@\n-    $(call FindSrcDirsForComponent, $(firstword $(subst :, , $1)), $(lastword $(subst :, , $1))) \\\n+    $(if $(filter %:libjvm, $1), \\\n+      $(HOTSPOT_INCLUDE_DIR) \\\n+    , \\\n+      $(call FindSrcDirsForComponent, $(firstword $(subst :, , $1)), \\\n+          $(lastword $(subst :, , $1))) \\\n+    ) \\\n@@ -87,1 +99,5 @@\n-      $(call FindSrcDirsForComponent, $(MODULE), $1) \\\n+      $(if $(filter libjvm, $1), \\\n+        $(HOTSPOT_INCLUDE_DIR) \\\n+      , \\\n+        $(call FindSrcDirsForComponent, $(MODULE), $1) \\\n+      ) \\\n@@ -91,0 +107,129 @@\n+# Create a proper LIBPATH for the given library. Sets result in $1_$2_LIBPATH.\n+# $1: The name of the rule (namespace)\n+# $2: The safe namespace of the library\n+define ResolveLibPath\n+  # Determine proper LIBPATH. This is quite messy due to historical reasons,\n+  # and because we need to have special treatment for \"gtest:\" and \":jvm\".\n+  ifneq ($$($1_$2_MODULE), gtest)\n+    ifneq ($$($1_$2_NAME), jvm)\n+      # This is the common case\n+      ifeq ($$(call isTargetOs, windows), true)\n+        $1_$2_LIBPATH := $$(SUPPORT_OUTPUTDIR)\/native\/$$($1_$2_MODULE)\/lib$$($1_$2_NAME)\n+      else\n+        ifeq ($(STATIC_LIBS), true)\n+          $1_$2_LIBPATH := $$(SUPPORT_OUTPUTDIR)\/native\/$$($1_$2_MODULE)\/lib$$($1_$2_NAME)\/static\n+        else ifeq ($$($1_$2_STATIC_LIBRARY), true)\n+          $1_$2_LIBPATH := $$(SUPPORT_OUTPUTDIR)\/native\/$$($1_$2_MODULE)\n+        else\n+          $1_$2_LIBPATH := $$(SUPPORT_OUTPUTDIR)\/modules_libs\/$$($1_$2_MODULE)\n+        endif\n+      endif\n+    else\n+      # Special treatment for hotspot\n+      ifeq ($(CREATING_BUILDJDK), true)\n+        # When building a buildjdk, it's always only the server variant\n+        $1_$2_JVM_VARIANT_PATH := server\n+      else\n+        $1_$2_JVM_VARIANT_PATH := $(JVM_VARIANT_MAIN)\n+      endif\n+      ifeq ($$(call isTargetOs, windows), true)\n+        ifeq ($(STATIC_LIBS), true)\n+          $1_$2_LIBPATH := $$(HOTSPOT_OUTPUTDIR)\/variant-$$($1_$2_JVM_VARIANT_PATH)\/libjvm\/objs\/static\n+        else\n+          $1_$2_LIBPATH := $$(SUPPORT_OUTPUTDIR)\/modules_libs\/$$($1_$2_MODULE)\n+        endif\n+      else\n+        ifeq ($(STATIC_LIBS), true)\n+          $1_$2_LIBPATH := $$(HOTSPOT_OUTPUTDIR)\/variant-$$($1_$2_JVM_VARIANT_PATH)\/libjvm\/objs\/static\n+        else\n+          $1_$2_LIBPATH := $$(SUPPORT_OUTPUTDIR)\/modules_libs\/$$($1_$2_MODULE)\/$$($1_$2_JVM_VARIANT_PATH)\n+        endif\n+      endif\n+    endif\n+  else\n+    # Special treatment for virtual module \"gtest\"\n+    ifeq ($$($1_$2_NAME), jvm)\n+      ifeq ($$(call isTargetOs, windows), true)\n+        ifeq ($(STATIC_LIBS), true)\n+          $1_$2_LIBPATH := $$(JVM_OUTPUTDIR)\/gtest\/objs\/static\n+        else\n+          $1_$2_LIBPATH := $$(JVM_OUTPUTDIR)\/gtest\/objs\n+        endif\n+      else\n+        ifeq ($(STATIC_LIBS), true)\n+          $1_$2_LIBPATH := $$(JVM_OUTPUTDIR)\/gtest\/objs\/static\n+        else\n+          $1_$2_LIBPATH := $$(JVM_OUTPUTDIR)\/gtest\n+        endif\n+      endif\n+    else ifeq ($$($1_$2_NAME), gtest)\n+      $1_$2_LIBPATH := $$(JVM_OUTPUTDIR)\/libgtest\n+      ifeq ($(STATIC_LIBS), true)\n+        $1_$2_LIBPATH := $$(JVM_OUTPUTDIR)\/libgtest\/objs\/static\n+      else\n+        $1_$2_LIBPATH := $$(JVM_OUTPUTDIR)\/libgtest\n+      endif\n+    endif\n+  endif\n+endef\n+\n+# Process a JDK library designation such as \"java.desktop:jawt\" into the needed\n+# additions to EXTRA_LINK_DEPS, LDFLAGS, LIBS and EXTRA_HEADER_DIRS.\n+# $1: The name of the rule (namespace)\n+# $2: The safe namespace of the library\n+# $3: The actual string given to represent the library\n+define AddJdkLibrary\n+  $1_$2_NAME := $$(strip $$(lastword $$(subst :, , $3)))\n+  $1_$2_MODULE := $$(strip $$(patsubst %$$($1_$2_NAME), %, $3))\n+\n+  ifeq ($$(filter lib%, $$($1_$2_NAME)),)\n+    $$(error Library name $$($1_$2_NAME) missing lib prefix in $1)\n+  endif\n+  $1_$2_NAME := $$(strip $$(patsubst lib%, %, $$($1_$2_NAME)))\n+\n+  ifeq ($$($1_$2_MODULE),)\n+    $1_$2_MODULE := $$(MODULE)\n+  else\n+    $1_$2_MODULE := $$(strip $$(patsubst %:, %, $$($1_$2_MODULE)))\n+  endif\n+\n+  # Determine if the library in question is static.\n+  ifeq ($(STATIC_BUILD), true)\n+     $1_$2_STATIC_LIBRARY := true\n+  endif\n+  # Ideally, we should not hardcode these\n+  ifeq ($(call isTargetOs, aix)+$$($1_$2_MODULE):$$($1_$2_NAME), true+java.base:jli)\n+     $1_$2_STATIC_LIBRARY := true\n+  endif\n+  ifeq ($$($1_$2_MODULE):$$($1_$2_NAME), gtest:gtest)\n+     $1_$2_STATIC_LIBRARY := true\n+  endif\n+\n+  # Setup $1_$2_LIBPATH.\n+  $$(eval $$(call ResolveLibPath,$1,$2))\n+\n+  $1_EXTRA_HEADER_DIRS += $$($1_$2_MODULE):lib$$($1_$2_NAME)\n+\n+  ifneq ($(STATIC_LIBS), true)\n+    ifeq ($$(call isTargetOs, windows), true)\n+      ifeq ($$(filter -libpath:$$($1_$2_LIBPATH), $$($1_LDFLAGS)), )\n+        $1_LDFLAGS += -libpath:$$($1_$2_LIBPATH)\n+      endif\n+      $1_LIBS += $$($1_$2_NAME)$(STATIC_LIBRARY_SUFFIX)\n+      $1_$2_LIBFILE := $(LIBRARY_PREFIX)$$($1_$2_NAME)$(STATIC_LIBRARY_SUFFIX)\n+    else\n+      ifeq ($$(filter -L$$($1_$2_LIBPATH), $$($1_LDFLAGS)), )\n+        $1_LDFLAGS += -L$$($1_$2_LIBPATH)\n+      endif\n+      $1_LIBS += -l$$($1_$2_NAME)\n+      ifeq ($$($1_$2_STATIC_LIBRARY), true)\n+        $1_$2_LIBFILE := $(LIBRARY_PREFIX)$$($1_$2_NAME)$(STATIC_LIBRARY_SUFFIX)\n+      else\n+        $1_$2_LIBFILE := $(LIBRARY_PREFIX)$$($1_$2_NAME)$(SHARED_LIBRARY_SUFFIX)\n+      endif\n+    endif\n+\n+    $1_EXTRA_LINK_DEPS += $$($1_$2_LIBPATH)\/$$($1_$2_LIBFILE)\n+  endif\n+endef\n+\n@@ -112,3 +257,5 @@\n-#   EXTRA_RCFLAGS -- additional RCFLAGS to append.\n-#   EXTRA_HEADER_DIRS -- additional directories to look for headers in\n-#   EXTRA_SRC -- additional directories to look for source in\n+#   SRC -- this is passed on after preprocessing. The preprocessing will pass on\n+#     absolute paths unchanged, but relative paths will be expanded to include\n+#     all directories with this name in $MODULE\/[shared|$OS|$OSTYPE]\/native.\n+#   EXTRA_SRC -- additional directories to look for source in. This is processed\n+#     like SRC.\n@@ -117,0 +264,6 @@\n+#   EXTRA_HEADER_DIRS -- additional directories to look for headers in. This can\n+#     be specified either as an absolute path, or relative directory names which\n+#     are preprocessed like SRC, or in the format <module>:<directory>, which\n+#     will be processed like SRC but for the given module. The names\n+#     \"java.base:libjvm\" and \"gtest:libjvm\" symbolise virtual libraries that\n+#     will be replaced with proper values for hotspot.\n@@ -119,4 +272,7 @@\n-#   SRC -- this is passed on, but preprocessed to accept source dir designations\n-#   RC_FILEDESC -- override the default FILEDESC for Windows version.rc\n-#     such as \"java.base:headers\".\n-#   JDK_LIBS -- libraries generated by the JDK build system to link against\n+#   JDK_LIBS -- libraries generated by the JDK build system to link against.\n+#     These take the form <module>:<basename>. For the current module, the\n+#     module name and colon can be omitted. The basename should be specified\n+#     as the source directory, e.g. \"libjava\". The gtest module is a virtual\n+#     module that will be replaced with correct values for gtest. When\n+#     specifying JDK_LIBS, suitable values for EXTRA_LINK_DEPS, LDFLAGS, LIBS\n+#     and EXTRA_HEADER_DIRS will be added.\n@@ -125,0 +281,2 @@\n+#   EXTRA_RCFLAGS -- additional RCFLAGS to append.\n+#   RC_FILEDESC -- override the default FILEDESC for Windows version.rc\n@@ -186,1 +344,1 @@\n-    $1_SRC := $$(foreach dir, $$($1_SRC), $$(call ProcessDir, $$(dir)))\n+    $1_SRC := $$(foreach dir, $$($1_SRC), $$(call ProcessSrcDir, $$(dir)))\n@@ -189,1 +347,1 @@\n-    $1_SRC += $$(foreach dir, $$($1_EXTRA_SRC), $$(call ProcessDir, $$(dir)))\n+    $1_SRC += $$(foreach dir, $$($1_EXTRA_SRC), $$(call ProcessSrcDir, $$(dir)))\n@@ -227,2 +385,3 @@\n-  # Prepend JDK libs before external libs\n-  $1_LIBS := $$($1_JDK_LIBS) $$($1_LIBS)\n+  $$(foreach lib, $$($1_JDK_LIBS), \\\n+    $$(eval $$(call AddJdkLibrary,$1,$$(subst :,_,$$(lib)),$$(lib))) \\\n+  )\n@@ -230,5 +389,9 @@\n-  ifneq ($$($1_EXTRA_HEADER_DIRS), )\n-    $1_PROCESSED_EXTRA_HEADER_DIRS := $$(foreach dir, $$($1_EXTRA_HEADER_DIRS), \\\n-        $$(call ProcessDir, $$(dir)))\n-    $1_EXTRA_HEADER_FLAGS := $$(addprefix -I, $$($1_PROCESSED_EXTRA_HEADER_DIRS))\n-  endif\n+  # Add the include path for jni.h to all native compilations\n+  $1_EXTRA_HEADER_DIRS += \\\n+      $(SUPPORT_OUTPUTDIR)\/modules_include\/java.base \\\n+      java.base:include \\\n+      #\n+\n+  $1_PROCESSED_EXTRA_HEADER_DIRS := $$(foreach dir, $$($1_EXTRA_HEADER_DIRS), \\\n+      $$(call ProcessSrcDir, $$(dir)))\n+  $1_EXTRA_HEADER_FLAGS := $$(addprefix -I, $$($1_PROCESSED_EXTRA_HEADER_DIRS))\n","filename":"make\/common\/JdkNativeCompilation.gmk","additions":183,"deletions":20,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -27,3 +27,4 @@\n-#\n-# Setup common utility functions.\n-#\n+# MakeBase provides the core functionality needed and used by all makefiles. It\n+# should be included by all makefiles. MakeBase provides essential\n+# functionality for named parameter functions, variable dependency, tool\n+# execution, logging and fixpath functionality.\n@@ -67,3 +68,0 @@\n-# Make sure we have a value (could be overridden on command line by caller)\n-CREATING_BUILDJDK ?= false\n-\n@@ -78,1 +76,0 @@\n-\n@@ -81,1 +78,2 @@\n-\n+# Utils.gmk must be included before FileUtils.gmk, since it uses some of the\n+# basic utility functions there.\n@@ -83,40 +81,1 @@\n-include $(TOPDIR)\/make\/common\/MakeIO.gmk\n-include $(TOPDIR)\/make\/common\/CopyFiles.gmk\n-\n-################################################################################\n-# Functions for timers\n-################################################################################\n-\n-# Store the build times in this directory.\n-BUILDTIMESDIR=$(OUTPUTDIR)\/make-support\/build-times\n-\n-# Record starting time for build of a sub repository.\n-define RecordStartTime\n-\t$(DATE) '+%Y %m %d %H %M %S' | $(AWK) '{ print $$1,$$2,$$3,$$4,$$5,$$6,($$4*3600+$$5*60+$$6) }' > $(BUILDTIMESDIR)\/build_time_start_$(strip $1) && \\\n-\t$(DATE) '+%Y-%m-%d %H:%M:%S' > $(BUILDTIMESDIR)\/build_time_start_$(strip $1)_human_readable\n-endef\n-\n-# Record ending time and calculate the difference and store it in a\n-# easy to read format. Handles builds that cross midnight. Expects\n-# that a build will never take 24 hours or more.\n-define RecordEndTime\n-\t$(DATE) '+%Y %m %d %H %M %S' | $(AWK) '{ print $$1,$$2,$$3,$$4,$$5,$$6,($$4*3600+$$5*60+$$6) }' > $(BUILDTIMESDIR)\/build_time_end_$(strip $1)\n-\t$(DATE) '+%Y-%m-%d %H:%M:%S' > $(BUILDTIMESDIR)\/build_time_end_$(strip $1)_human_readable\n-\t$(ECHO) `$(CAT) $(BUILDTIMESDIR)\/build_time_start_$(strip $1)` `$(CAT) $(BUILDTIMESDIR)\/build_time_end_$(strip $1)` $1 | \\\n-\t    $(AWK) '{ F=$$7; T=$$14; if (F > T) { T+=3600*24 }; D=T-F; H=int(D\/3600); \\\n-\t    M=int((D-H*3600)\/60); S=D-H*3600-M*60; printf(\"%02d:%02d:%02d %s\\n\",H,M,S,$$15); }' \\\n-\t    > $(BUILDTIMESDIR)\/build_time_diff_$(strip $1)\n-endef\n-\n-# Hook to be called when starting to execute a top-level target\n-define TargetEnter\n-\t$(PRINTF) \"## Starting $(patsubst %-only,%,$@)\\n\"\n-\t$(call RecordStartTime,$(patsubst %-only,%,$@))\n-endef\n-\n-# Hook to be called when finish executing a top-level target\n-define TargetExit\n-\t$(call RecordEndTime,$(patsubst %-only,%,$@))\n-\t$(PRINTF) \"## Finished $(patsubst %-only,%,$@) (build time %s)\\n\\n\" \\\n-\t    \"`$(CAT) $(BUILDTIMESDIR)\/build_time_diff_$(patsubst %-only,%,$@) | $(CUT) -f 1 -d ' '`\"\n-endef\n+include $(TOPDIR)\/make\/common\/FileUtils.gmk\n@@ -125,14 +84,2 @@\n-\n-# A file containing a way to uniquely identify the source code revision that\n-# the build was created from\n-SOURCE_REVISION_TRACKER := $(SUPPORT_OUTPUTDIR)\/src-rev\/source-revision-tracker\n-\n-# Locate all sourcecode repositories included in the forest, as absolute paths\n-FindAllReposAbs = \\\n-    $(strip $(sort $(dir $(filter-out $(TOPDIR)\/build\/%, $(wildcard \\\n-        $(addprefix $(TOPDIR)\/, .git *\/.git *\/*\/.git *\/*\/*\/.git *\/*\/*\/*\/.git) \\\n-    )))))\n-\n-# Locate all sourcecode repositories included in the forest, as relative paths\n-FindAllReposRel = \\\n-    $(strip $(subst $(TOPDIR)\/,.,$(patsubst $(TOPDIR)\/%\/, %, $(FindAllReposAbs))))\n+# Make sure we have a value (could be overridden on command line by caller)\n+CREATING_BUILDJDK ?= false\n@@ -240,218 +187,0 @@\n-################################################################################\n-# Make directory without forking mkdir if not needed.\n-#\n-# If a directory with an encoded space is provided, the wildcard function\n-# sometimes returns false answers (typically if the dir existed when the\n-# makefile was parsed, but was deleted by a previous rule). In that case, always\n-# call mkdir regardless of what wildcard says.\n-#\n-# 1: List of directories to create\n-MakeDir = \\\n-    $(strip \\\n-        $(eval MakeDir_dirs_to_make := $(strip $(foreach d, $1, \\\n-          $(if $(findstring ?, $d), '$(call DecodeSpace, $d)', \\\n-            $(if $(wildcard $d), , $d) \\\n-          ) \\\n-        ))) \\\n-        $(if $(MakeDir_dirs_to_make), $(shell $(MKDIR) -p $(MakeDir_dirs_to_make))) \\\n-    )\n-\n-# Make directory for target file. Should handle spaces in filenames. Just\n-# calling $(call MakeDir $(@D)) will not work if the directory contains a space\n-# and the target file already exists. In that case, the target file will have\n-# its wildcard ? resolved and the $(@D) will evaluate each space separated dir\n-# part on its own.\n-MakeTargetDir = \\\n-    $(call MakeDir, $(dir $(call EncodeSpace, $@)))\n-\n-################################################################################\n-# All install-file and related macros automatically call DecodeSpace when needed.\n-\n-ifeq ($(call isTargetOs, macosx), true)\n-  # On mac, extended attributes sometimes creep into the source files, which may later\n-  # cause the creation of ._* files which confuses testing. Clear these with xattr if\n-  # set. Some files get their write permissions removed after being copied to the\n-  # output dir. When these are copied again to images, xattr would fail. By only clearing\n-  # attributes when they are present, failing on this is avoided.\n-  #\n-  # If copying a soft link to a directory, need to delete the target first to avoid\n-  # weird errors.\n-  define install-file\n-\t$(call MakeTargetDir)\n-\t$(RM) '$(call DecodeSpace, $@)'\n-        # Work around a weirdness with cp on Macosx. When copying a symlink, if\n-        # the target of the link is write protected (e.g. 444), cp will add\n-        # write permission for the user on the target file (644). Avoid this by\n-        # using ln to create a new link instead.\n-\tif [ -h '$(call DecodeSpace, $<)' ]; then \\\n-\t  $(LN) -s \"`$(READLINK) '$(call DecodeSpace, $<)'`\" '$(call DecodeSpace, $@)'; \\\n-\telse \\\n-\t  $(CP) -fRP '$(call DecodeSpace, $<)' '$(call DecodeSpace, $@)'; \\\n-\tfi\n-\tif [ -n \"`$(XATTR) -ls '$(call DecodeSpace, $@)'`\" ]; then \\\n-\t  $(XATTR) -cs '$(call DecodeSpace, $@)'; \\\n-\tfi\n-  endef\n-else\n-  define install-file\n-\t$(call MakeTargetDir)\n-\t$(CP) -fP '$(call DecodeSpace, $<)' '$(call DecodeSpace, $@)'\n-  endef\n-endif\n-\n-# Variant of install file that does not preserve symlinks\n-define install-file-nolink\n-\t$(call MakeTargetDir)\n-\t$(CP) -f '$(call DecodeSpace, $<)' '$(call DecodeSpace, $@)'\n-endef\n-\n-################################################################################\n-# link-file-* works similarly to install-file but creates a symlink instead.\n-# There are two versions, either creating a relative or an absolute link. Be\n-# careful when using this on Windows since the symlink created is only valid in\n-# the unix emulation environment.\n-# In msys2 we use mklink \/J because its ln would perform a deep copy of the target.\n-# This inhibits performance and can lead to issues with long paths. With mklink \/J\n-# relative linking does not work, so we handle the link as absolute path.\n-ifeq ($(OPENJDK_BUILD_OS_ENV), windows.msys2)\n-  define link-file-relative\n-\t$(call MakeTargetDir)\n-\t$(RM) '$(call DecodeSpace, $@)'\n-\tcmd \/\/c \"mklink \/J $(call FixPath, $(call DecodeSpace, $@)) $(call FixPath, $(call DecodeSpace, $<))\"\n-  endef\n-else\n-  define link-file-relative\n-\t$(call MakeTargetDir)\n-\t$(RM) '$(call DecodeSpace, $@)'\n-\t$(LN) -s '$(call DecodeSpace, $(call RelativePath, $<, $(@D)))' '$(call DecodeSpace, $@)'\n-  endef\n-endif\n-\n-ifeq ($(OPENJDK_BUILD_OS_ENV), windows.msys2)\n-  define link-file-absolute\n-\t$(call MakeTargetDir)\n-\t$(RM) '$(call DecodeSpace, $@)'\n-\tcmd \/\/c \"mklink \/J $(call FixPath, $(call DecodeSpace, $@)) $(call FixPath, $(call DecodeSpace, $<))\"\n-  endef\n-else\n-  define link-file-absolute\n-\t$(call MakeTargetDir)\n-\t$(RM) '$(call DecodeSpace, $@)'\n-\t$(LN) -s '$(call DecodeSpace, $<)' '$(call DecodeSpace, $@)'\n-  endef\n-endif\n-\n-################################################################################\n-\n-# Recursive wildcard function. Walks down directories recursively and matches\n-# files with the search patterns. Patterns use standard file wildcards (* and\n-# ?).\n-#\n-# $1 - Directories to start search in\n-# $2 - Search patterns\n-rwildcard = \\\n-    $(strip \\\n-        $(foreach d, \\\n-          $(patsubst %\/,%,$(sort $(dir $(wildcard $(addsuffix \/*\/*, $(strip $1)))))), \\\n-          $(call rwildcard,$d,$2) \\\n-        ) \\\n-        $(call DoubleDollar, $(wildcard $(foreach p, $2, $(addsuffix \/$(strip $p), $(strip $1))))) \\\n-    )\n-\n-# Find non directories using recursive wildcard function. This function may\n-# be used directly when a small amount of directories is expected to be\n-# searched and caching is not expected to be of use.\n-#\n-# $1 - Directory to start search in\n-# $2 - Optional search patterns, defaults to '*'.\n-WildcardFindFiles = \\\n-    $(sort $(strip \\\n-        $(eval WildcardFindFiles_result := $(call rwildcard,$(patsubst %\/,%,$1),$(if $(strip $2),$2,*))) \\\n-        $(filter-out $(patsubst %\/,%,$(sort $(dir $(WildcardFindFiles_result)))), \\\n-            $(WildcardFindFiles_result) \\\n-        ) \\\n-    ))\n-\n-# Find non directories using the find utility in the shell. Safe to call for\n-# non existing directories, or directories containing wildcards.\n-#\n-# Files containing space will get spaces replaced with ? because GNU Make\n-# cannot handle lists of files with space in them. By using ?, make will match\n-# the wildcard to space in many situations so we don't need to replace back\n-# to space on every use. While not a complete solution it does allow some uses\n-# of FindFiles to function with spaces in file names, including for\n-# SetupCopyFiles. Unfortunately this does not work for WildcardFindFiles so\n-# if files with spaces are anticipated, use ShellFindFiles directly.\n-#\n-# $1 - Directories to start search in.\n-# $2 - Optional search patterns, empty means find everything. Patterns use\n-#      standard file wildcards (* and ?) and should not be quoted.\n-# $3 - Optional options to find.\n-ShellFindFiles = \\\n-    $(if $(wildcard $1), \\\n-      $(sort \\\n-          $(shell $(FIND) $3 $(patsubst %\/,%,$(wildcard $1)) \\( -type f -o -type l \\) \\\n-              $(if $(strip $2), -a \\( -name \"$(firstword $2)\" \\\n-              $(foreach p, $(filter-out $(firstword $2), $2), -o -name \"$(p)\") \\)) \\\n-              | $(TR) ' ' '?' \\\n-          ) \\\n-      ) \\\n-    )\n-\n-# Find non directories using the method most likely to work best for the\n-# current build host\n-#\n-# $1 - Directory to start search in\n-# $2 - Optional search patterns, defaults to '*'.\n-ifeq ($(OPENJDK_BUILD_OS)-$(RWILDCARD_WORKS), windows-true)\n-  DirectFindFiles = $(WildcardFindFiles)\n-else\n-  DirectFindFiles = $(ShellFindFiles)\n-endif\n-\n-# Finds files using a cache that is populated by FillFindCache below. If any of\n-# the directories given have not been cached, DirectFindFiles is used for\n-# everything. Caching is especially useful in Cygwin, where file finds are very\n-# costly.\n-#\n-# $1 - Directories to start search in.\n-# $2 - Optional search patterns. If used, no caching is done.\n-CacheFindFiles_CACHED_DIRS :=\n-CacheFindFiles_CACHED_FILES :=\n-CacheFindFiles = \\\n-    $(if $2, \\\n-      $(call DirectFindFiles, $1, $2) \\\n-    , \\\n-      $(if $(filter-out $(addsuffix \/%, $(CacheFindFiles_CACHED_DIRS)) \\\n-          $(CacheFindFiles_CACHED_DIRS), $1), \\\n-        $(call DirectFindFiles, $1) \\\n-      , \\\n-        $(filter $(addsuffix \/%,$(patsubst %\/,%,$1)) $1,$(CacheFindFiles_CACHED_FILES)) \\\n-      ) \\\n-    )\n-\n-# Explicitly adds files to the find cache used by CacheFindFiles.\n-#\n-# $1 - Directories to start search in\n-FillFindCache = \\\n-    $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix \/%,\\\n-        $$(CacheFindFiles_CACHED_DIRS)) $$(CacheFindFiles_CACHED_DIRS), $1)) \\\n-    $(if $(CacheFindFiles_NEW_DIRS), \\\n-      $(eval CacheFindFiles_CACHED_DIRS += $$(patsubst %\/,%,$$(CacheFindFiles_NEW_DIRS))) \\\n-      $(eval CacheFindFiles_CACHED_FILES := $$(sort $$(CacheFindFiles_CACHED_FILES) \\\n-          $$(call DirectFindFiles, $$(CacheFindFiles_NEW_DIRS)))) \\\n-    )\n-\n-# Findfiles is the default macro that should be used to find files in the file\n-# system. This function does not always support files with spaces in the names.\n-# If files with spaces are anticipated, use ShellFindFiles directly.\n-#\n-# $1 - Directories to start search in.\n-# $2 - Optional search patterns, empty means find everything. Patterns use\n-#      standard file wildcards (* and ?) and should not be quoted.\n-ifeq ($(DISABLE_CACHE_FIND), true)\n-  FindFiles = $(DirectFindFiles)\n-else\n-  FindFiles = $(CacheFindFiles)\n-endif\n-\n","filename":"make\/common\/MakeBase.gmk","additions":9,"deletions":280,"binary":false,"changes":289,"status":"modified"},{"patch":"@@ -244,29 +244,0 @@\n-\n-################################################################################\n-# Write to and read from file\n-\n-# Param 1 - File to read\n-ReadFile = \\\n-    $(shell $(CAT) $1)\n-\n-# Param 1 - Text to write\n-# Param 2 - File to write to\n-ifeq ($(HAS_FILE_FUNCTION), true)\n-  WriteFile = \\\n-      $(file >$2,$(strip $1))\n-else\n-  # Use printf to get consistent behavior on all platforms.\n-  WriteFile = \\\n-      $(shell $(PRINTF) \"%s\\n\" $(strip $(call ShellQuote, $1)) > $2)\n-endif\n-\n-# Param 1 - Text to write\n-# Param 2 - File to write to\n-ifeq ($(HAS_FILE_FUNCTION), true)\n-  AppendFile = \\\n-      $(file >>$2,$(strip $1))\n-else\n-  # Use printf to get consistent behavior on all platforms.\n-  AppendFile = \\\n-      $(shell $(PRINTF) \"%s\\n\" $(strip $(call ShellQuote, $1)) >> $2)\n-endif\n","filename":"make\/common\/MakeIO.gmk","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+include MakeIO.gmk\n@@ -87,0 +88,1 @@\n+#   EXTRA_LINK_DEPS List of extra dependencies to be added to the link stage\n@@ -230,0 +232,3 @@\n+  ifeq ($$($1_NAME), )\n+    $$(error NAME must not be empty in $1)\n+  endif\n","filename":"make\/common\/NativeCompilation.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-    $1_LDFLAGS := $(LDFLAGS_TESTEXE)\n@@ -106,0 +105,3 @@\n+        EXTRA_HEADER_DIRS := \\\n+            java.base:libjava \\\n+            java.base:libjvm, \\\n@@ -112,1 +114,1 @@\n-        LDFLAGS := $$($1_LDFLAGS) $$($1_LDFLAGS_$$(name)), \\\n+        LDFLAGS := $$($1_LDFLAGS_$$(name)), \\\n@@ -117,0 +119,1 @@\n+        JDK_LIBS := $$($1_JDK_LIBS_$$(name)), \\\n","filename":"make\/common\/TestFilesCompilation.gmk","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-# Common utility functions\n+# Basic utility functions available to MakeBase.gmk itself\n@@ -36,5 +36,7 @@\n-### Debug functions\n-\n-# Prints the name and value of a variable\n-PrintVar = \\\n-    $(info $(strip $1) >$($(strip $1))<)\n+# String equals\n+equals = \\\n+    $(if $(strip $1)$(strip $2),$(strip \\\n+      $(and $(findstring $(strip $1),$(strip $2)),\\\n+        $(findstring $(strip $2),$(strip $1)))), \\\n+      true \\\n+    )\n@@ -42,5 +44,4 @@\n-################################################################################\n-# This macro translates $ into \\$ to protect the $ from expansion in the shell.\n-# To make this macro resilient against already escaped strings, first remove\n-# any present escapes before escaping so that no double escapes are added.\n-EscapeDollar = $(subst $$,\\$$,$(subst \\$$,$$,$(strip $1)))\n+# Convert the string given to upper case, without any $(shell)\n+# Inspired by http:\/\/lists.gnu.org\/archive\/html\/help-make\/2013-09\/msg00009.html\n+uppercase_table := a,A b,B c,C d,D e,E f,F g,G h,H i,I j,J k,K l,L m,M n,N o,O \\\n+    p,P q,Q r,R s,S t,T u,U v,V w,W x,X y,Y z,Z\n@@ -48,3 +49,3 @@\n-################################################################################\n-# This macro works just like EscapeDollar above, but for #.\n-EscapeHash = $(subst \\#,\\\\\\#,$(subst \\\\\\#,\\#,$(strip $1)))\n+uppercase_internal = \\\n+  $(if $(strip $1), $$(subst $(firstword $1), $(call uppercase_internal, \\\n+      $(wordlist 2, $(words $1), $1), $2)), $2)\n@@ -52,3 +53,7 @@\n-################################################################################\n-# This macro translates $ into $$ to protect the string from make itself.\n-DoubleDollar = $(subst $$,$$$$,$(strip $1))\n+# Convert a string to upper case. Works only on a-z.\n+# $1 - The string to convert\n+uppercase = \\\n+  $(strip \\\n+    $(eval uppercase_result := $(call uppercase_internal, $(uppercase_table), $1)) \\\n+    $(uppercase_result) \\\n+  )\n@@ -72,4 +77,4 @@\n-# Strip both arguments. Append the first argument to the second argument. If the\n-# first argument is empty, return the empty string.\n-IfAppend = \\\n-    $(if $(strip $1),$(strip $1)$(strip $2),)\n+# This macro translates $ into \\$ to protect the $ from expansion in the shell.\n+# To make this macro resilient against already escaped strings, first remove\n+# any present escapes before escaping so that no double escapes are added.\n+EscapeDollar = $(subst $$,\\$$,$(subst \\$$,$$,$(strip $1)))\n@@ -78,6 +83,2 @@\n-# Replace question marks with space in string. This macro needs to be called on\n-# files from FindFiles in case any of them contains space in their file name,\n-# since FindFiles replaces space with ?.\n-# Param 1 - String to replace in\n-DecodeSpace = \\\n-    $(subst ?,$(SPACE),$(strip $1))\n+# This macro works just like EscapeDollar above, but for #.\n+EscapeHash = $(subst \\#,\\\\\\#,$(subst \\\\\\#,\\#,$(strip $1)))\n@@ -85,2 +86,3 @@\n-EncodeSpace = \\\n-    $(subst $(SPACE),?,$(strip $1))\n+################################################################################\n+# This macro translates $ into $$ to protect the string from make itself.\n+DoubleDollar = $(subst $$,$$$$,$(strip $1))\n@@ -89,5 +91,35 @@\n-# Assign a variable only if it is empty\n-# Param 1 - Variable to assign\n-# Param 2 - Value to assign\n-SetIfEmpty = \\\n-    $(if $($(strip $1)),,$(eval $(strip $1) := $2))\n+# ShellQuote\n+#\n+# Quotes a string with single quotes and replaces single quotes with '\\'' so\n+# that the contents survives being given to the shell.\n+ShellQuote = \\\n+    $(SQUOTE)$(subst $(SQUOTE),$(SQUOTE)\\$(SQUOTE)$(SQUOTE),$(strip $1))$(SQUOTE)\n+\n+################################################################################\n+# Write to and read from file\n+\n+# Param 1 - File to read\n+ReadFile = \\\n+    $(shell $(CAT) $1)\n+\n+# Param 1 - Text to write\n+# Param 2 - File to write to\n+ifeq ($(HAS_FILE_FUNCTION), true)\n+  WriteFile = \\\n+      $(file >$2,$(strip $1))\n+else\n+  # Use printf to get consistent behavior on all platforms.\n+  WriteFile = \\\n+      $(shell $(PRINTF) \"%s\\n\" $(strip $(call ShellQuote, $1)) > $2)\n+endif\n+\n+# Param 1 - Text to write\n+# Param 2 - File to write to\n+ifeq ($(HAS_FILE_FUNCTION), true)\n+  AppendFile = \\\n+      $(file >>$2,$(strip $1))\n+else\n+  # Use printf to get consistent behavior on all platforms.\n+  AppendFile = \\\n+      $(shell $(PRINTF) \"%s\\n\" $(strip $(call ShellQuote, $1)) >> $2)\n+endif\n@@ -96,3 +128,1 @@\n-# Take two paths and return the path of the last common directory.\n-# Ex: \/foo\/bar\/baz, \/foo\/bar\/banan -> \/foo\/bar\n-#     foo\/bar\/baz, \/foo\/bar -> <empty>\n+# Make directory without forking mkdir if not needed.\n@@ -100,2 +130,4 @@\n-# The x prefix is used to preserve the presence of the initial slash\n-# On Windows paths are treated as case-insensitive\n+# If a directory with an encoded space is provided, the wildcard function\n+# sometimes returns false answers (typically if the dir existed when the\n+# makefile was parsed, but was deleted by a previous rule). In that case, always\n+# call mkdir regardless of what wildcard says.\n@@ -103,24 +135,9 @@\n-# $1 - Path to compare\n-# $2 - Other path to compare\n-FindCommonPathPrefix = \\\n-    $(call DecodeSpace,$(patsubst x%,%,$(subst $(SPACE),\/,$(strip \\\n-        $(call FindCommonPathPrefixHelper1, \\\n-            $(subst \/,$(SPACE),x$(call EncodeSpace,$(strip $1))), \\\n-            $(subst \/,$(SPACE),x$(call EncodeSpace,$(strip $2)))) \\\n-    ))))\n-\n-FindCommonPathPrefixHelper1 = \\\n-    $(if $(filter $(OPENJDK_TARGET_OS), windows), \\\n-        $(call FindCommonPathPrefixHelper2,$(call uppercase,$1),$(call uppercase,$2),$1), \\\n-        $(call FindCommonPathPrefixHelper2,$1,$2,$1))\n-\n-FindCommonPathPrefixHelper2 = \\\n-    $(if $(call equals, $(firstword $1), $(firstword $2)), \\\n-      $(if $(call equals, $(firstword $1),),, \\\n-        $(firstword $3) \\\n-        $(call FindCommonPathPrefixHelper2, \\\n-            $(wordlist 2, $(words $1), $1), \\\n-            $(wordlist 2, $(words $2), $2), \\\n-            $(wordlist 2, $(words $3), $3) \\\n-        ) \\\n-      ) \\\n+# 1: List of directories to create\n+MakeDir = \\\n+    $(strip \\\n+        $(eval MakeDir_dirs_to_make := $(strip $(foreach d, $1, \\\n+          $(if $(findstring ?, $d), '$(call DecodeSpace, $d)', \\\n+            $(if $(wildcard $d), , $d) \\\n+          ) \\\n+        ))) \\\n+        $(if $(MakeDir_dirs_to_make), $(shell $(MKDIR) -p $(MakeDir_dirs_to_make))) \\\n@@ -129,24 +146,72 @@\n-# Computes the relative path from a directory to a file\n-# $1 - File to compute the relative path to\n-# $2 - Directory to compute the relative path from\n-RelativePath = \\\n-    $(call DecodeSpace,$(strip $(call RelativePathHelper,$(call EncodeSpace \\\n-        ,$(strip $1)),$(call EncodeSpace \\\n-        ,$(strip $2)),$(call EncodeSpace \\\n-        ,$(call FindCommonPathPrefix,$1,$2)))))\n-\n-RelativePathHelper = \\\n-    $(eval $3_prefix_length := $(words $(subst \/,$(SPACE),$3))) \\\n-    $(eval $1_words := $(subst \/,$(SPACE),$1)) \\\n-    $(eval $2_words := $(subst \/,$(SPACE),$2)) \\\n-    $(if $(call equals,$($3_prefix_length),0),, \\\n-        $(eval $1_words := $(wordlist 2,$(words $($1_words)),$(wordlist \\\n-            $($3_prefix_length),$(words $($1_words)),$($1_words)))) \\\n-        $(eval $2_words := $(wordlist 2,$(words $($2_words)),$(wordlist \\\n-            $($3_prefix_length),$(words $($2_words)),$($2_words)))) \\\n-    ) \\\n-    $(eval $1_suffix := $(subst $(SPACE),\/,$($1_words))) \\\n-    $(eval $2_dotdots := $(subst $(SPACE),\/,$(foreach d,$($2_words),..))) \\\n-    $(if $($1_suffix), \\\n-        $(if $($2_dotdots), $($2_dotdots)\/$($1_suffix), $($1_suffix)), \\\n-        $(if $($2_dotdots), $($2_dotdots), .))\n+################################################################################\n+# Check if our build or target conforms to certain restrictions. This set of\n+# functions all work in similar ways, testing the property that the name\n+# implies, so e.g. isTargetCpu test the CPU of the target system.\n+#\n+# $1 - A property, or a space separated list of properties to test for.\n+#\n+# Returns true if the actual property matches one of the properties in the list,\n+# and false otherwise.\n+#\n+# Examples: $(call isTargetOs, linux windows) will return true when executed\n+# on either linux or windows, and false otherwise.\n+# $(call isBuildCpuArch, x86) will return true iff the build CPU Arch is x86.\n+\n+isTargetOs = \\\n+  $(strip $(if $(filter $(OPENJDK_TARGET_OS), $1), true, false))\n+\n+isTargetOsType = \\\n+  $(strip $(if $(filter $(OPENJDK_TARGET_OS_TYPE), $1), true, false))\n+\n+isTargetCpu = \\\n+  $(strip $(if $(filter $(OPENJDK_TARGET_CPU), $1), true, false))\n+\n+isTargetCpuArch = \\\n+  $(strip $(if $(filter $(OPENJDK_TARGET_CPU_ARCH), $1), true, false))\n+\n+isTargetCpuBits = \\\n+  $(strip $(if $(filter $(OPENJDK_TARGET_CPU_BITS), $1), true, false))\n+\n+isBuildOs = \\\n+  $(strip $(if $(filter $(OPENJDK_BUILD_OS), $1), true, false))\n+\n+isBuildOsType = \\\n+  $(strip $(if $(filter $(OPENJDK_BUILD_OS_TYPE), $1), true, false))\n+\n+isBuildOsEnv = \\\n+  $(strip $(if $(filter $(OPENJDK_BUILD_OS_ENV), $1), true, false))\n+\n+isBuildCpu = \\\n+  $(strip $(if $(filter $(OPENJDK_BUILD_CPU), $1), true, false))\n+\n+isBuildCpuArch = \\\n+  $(strip $(if $(filter $(OPENJDK_BUILD_CPU_ARCH), $1), true, false))\n+\n+isCompiler = \\\n+  $(strip $(if $(filter $(TOOLCHAIN_TYPE), $1), true, false))\n+\n+################################################################################\n+#\n+# Common utility functions\n+#\n+################################################################################\n+\n+### Debug functions\n+\n+# Prints the name and value of a variable\n+PrintVar = \\\n+    $(info $(strip $1) >$($(strip $1))<)\n+\n+\n+################################################################################\n+# Strip both arguments. Append the first argument to the second argument. If the\n+# first argument is empty, return the empty string.\n+IfAppend = \\\n+    $(if $(strip $1),$(strip $1)$(strip $2),)\n+\n+################################################################################\n+# Assign a variable only if it is empty\n+# Param 1 - Variable to assign\n+# Param 2 - Value to assign\n+SetIfEmpty = \\\n+    $(if $($(strip $1)),,$(eval $(strip $1) := $2))\n@@ -176,8 +241,0 @@\n-# String equals\n-equals = \\\n-    $(if $(strip $1)$(strip $2),$(strip \\\n-      $(and $(findstring $(strip $1),$(strip $2)),\\\n-        $(findstring $(strip $2),$(strip $1)))), \\\n-      true \\\n-    )\n-\n@@ -191,17 +248,0 @@\n-# Convert the string given to upper case, without any $(shell)\n-# Inspired by http:\/\/lists.gnu.org\/archive\/html\/help-make\/2013-09\/msg00009.html\n-uppercase_table := a,A b,B c,C d,D e,E f,F g,G h,H i,I j,J k,K l,L m,M n,N o,O \\\n-    p,P q,Q r,R s,S t,T u,U v,V w,W x,X y,Y z,Z\n-\n-uppercase_internal = \\\n-  $(if $(strip $1), $$(subst $(firstword $1), $(call uppercase_internal, \\\n-      $(wordlist 2, $(words $1), $1), $2)), $2)\n-\n-# Convert a string to upper case. Works only on a-z.\n-# $1 - The string to convert\n-uppercase = \\\n-  $(strip \\\n-    $(eval uppercase_result := $(call uppercase_internal, $(uppercase_table), $1)) \\\n-    $(uppercase_result) \\\n-  )\n-\n@@ -293,8 +333,0 @@\n-################################################################################\n-# ShellQuote\n-#\n-# Quotes a string with single quotes and replaces single quotes with '\\'' so\n-# that the contents survives being given to the shell.\n-ShellQuote = \\\n-    $(SQUOTE)$(subst $(SQUOTE),$(SQUOTE)\\$(SQUOTE)$(SQUOTE),$(strip $1))$(SQUOTE)\n-\n@@ -332,47 +364,0 @@\n-################################################################################\n-# Check if our build or target conforms to certain restrictions. This set of\n-# functions all work in similar ways, testing the property that the name\n-# implies, so e.g. isTargetCpu test the CPU of the target system.\n-#\n-# $1 - A property, or a space separated list of properties to test for.\n-#\n-# Returns true if the actual property matches one of the properties in the list,\n-# and false otherwise.\n-#\n-# Examples: $(call isTargetOs, linux windows) will return true when executed\n-# on either linux or windows, and false otherwise.\n-# $(call isBuildCpuArch, x86) will return true iff the build CPU Arch is x86.\n-\n-isTargetOs = \\\n-  $(strip $(if $(filter $(OPENJDK_TARGET_OS), $1), true, false))\n-\n-isTargetOsType = \\\n-  $(strip $(if $(filter $(OPENJDK_TARGET_OS_TYPE), $1), true, false))\n-\n-isTargetCpu = \\\n-  $(strip $(if $(filter $(OPENJDK_TARGET_CPU), $1), true, false))\n-\n-isTargetCpuArch = \\\n-  $(strip $(if $(filter $(OPENJDK_TARGET_CPU_ARCH), $1), true, false))\n-\n-isTargetCpuBits = \\\n-  $(strip $(if $(filter $(OPENJDK_TARGET_CPU_BITS), $1), true, false))\n-\n-isBuildOs = \\\n-  $(strip $(if $(filter $(OPENJDK_BUILD_OS), $1), true, false))\n-\n-isBuildOsType = \\\n-  $(strip $(if $(filter $(OPENJDK_BUILD_OS_TYPE), $1), true, false))\n-\n-isBuildOsEnv = \\\n-  $(strip $(if $(filter $(OPENJDK_BUILD_OS_ENV), $1), true, false))\n-\n-isBuildCpu = \\\n-  $(strip $(if $(filter $(OPENJDK_BUILD_CPU), $1), true, false))\n-\n-isBuildCpuArch = \\\n-  $(strip $(if $(filter $(OPENJDK_BUILD_CPU_ARCH), $1), true, false))\n-\n-isCompiler = \\\n-  $(strip $(if $(filter $(TOOLCHAIN_TYPE), $1), true, false))\n-\n","filename":"make\/common\/Utils.gmk","additions":153,"deletions":168,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+include CopyFiles.gmk\n+\n","filename":"make\/common\/modules\/CopyCommon.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+include CopyFiles.gmk\n@@ -125,2 +126,0 @@\n-  $1_WINDOWS_JLI_LIB := $(call FindStaticLib, java.base, jli, \/libjli)\n-\n@@ -151,0 +150,1 @@\n+      EXTRA_HEADER_DIRS := java.base:libjvm, \\\n@@ -153,9 +153,4 @@\n-      LDFLAGS_linux := $$(call SET_EXECUTABLE_ORIGIN,\/..\/lib) \\\n-          -L$(call FindLibDirForModule, java.base), \\\n-      LDFLAGS_macosx := $$(call SET_EXECUTABLE_ORIGIN,\/..\/lib) \\\n-          -L$(call FindLibDirForModule, java.base), \\\n-      LDFLAGS_aix := -L$(SUPPORT_OUTPUTDIR)\/native\/java.base, \\\n-      JDK_LIBS_unix := -ljli, \\\n-      JDK_LIBS_windows := \\\n-          $(SUPPORT_OUTPUTDIR)\/native\/java.base\/libjava\/java.lib \\\n-          $$($1_WINDOWS_JLI_LIB), \\\n+      LDFLAGS_linux := $$(call SET_EXECUTABLE_ORIGIN,\/..\/lib), \\\n+      LDFLAGS_macosx := $$(call SET_EXECUTABLE_ORIGIN,\/..\/lib), \\\n+      JDK_LIBS := java.base:libjli, \\\n+      JDK_LIBS_windows := java.base:libjava, \\\n@@ -181,9 +176,0 @@\n-  ifeq ($(call isTargetOs, aix), true)\n-    $$(BUILD_LAUNCHER_$1): $(call FindStaticLib, java.base, jli)\n-  endif\n-\n-  ifeq ($(call isTargetOs, windows), true)\n-    $$(BUILD_LAUNCHER_$1): $(call FindStaticLib, java.base, java, \/libjava) \\\n-        $$($1_WINDOWS_JLI_LIB)\n-  endif\n-\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,11 +27,0 @@\n-\n-################################################################################\n-\n-# Absolute paths to lib files on windows for use in LIBS. Should figure out a more\n-# elegant solution to this.\n-WIN_JAVA_LIB := $(SUPPORT_OUTPUTDIR)\/native\/java.base\/libjava\/java.lib\n-\n-# Put the libraries here.\n-INSTALL_LIBRARIES_HERE := $(call FindLibDirForModule, $(MODULE))\n-\n-################################################################################\n","filename":"make\/common\/modules\/LibCommon.gmk","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  $1_CREATE_DEBUGINFO := false\n@@ -44,1 +45,3 @@\n-        # Generate debuginfo files.\n+        $1_CREATE_DEBUGINFO := true\n+\n+        # Setup where the platform specific debuginfo files end up\n@@ -46,5 +49,0 @@\n-          $1_EXTRA_LDFLAGS += -debug \"-pdb:$$($1_SYMBOLS_DIR)\/$$($1_BASENAME).pdb\" \\\n-              \"-map:$$($1_SYMBOLS_DIR)\/$$($1_BASENAME).map\"\n-          ifeq ($(SHIP_DEBUG_SYMBOLS), public)\n-            $1_EXTRA_LDFLAGS += \"-pdbstripped:$$($1_SYMBOLS_DIR)\/$$($1_BASENAME).stripped.pdb\"\n-          endif\n@@ -53,21 +51,1 @@\n-\n-        else ifeq ($(call isTargetOs, linux), true)\n-          $1_DEBUGINFO_FILES := $$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).debuginfo\n-          # Setup the command line creating debuginfo files, to be run after linking.\n-          # It cannot be run separately since it updates the original target file\n-          # Creating the debuglink is done in another command rather than all at once\n-          # so we can run it after strip is called, since strip can sometimes mangle the\n-          # embedded debuglink, which we want to avoid.\n-          $1_CREATE_DEBUGINFO_CMDS := \\\n-              $$($1_OBJCOPY) --only-keep-debug $$($1_TARGET) $$($1_DEBUGINFO_FILES) && \\\n-              $$(CHMOD) -x $$($1_DEBUGINFO_FILES)\n-          $1_CREATE_DEBUGLINK_CMDS := $(CD) $$($1_SYMBOLS_DIR) && \\\n-              $$($1_OBJCOPY) --add-gnu-debuglink=$$($1_DEBUGINFO_FILES) $$($1_TARGET)\n-\n-        else ifeq ($(call isTargetOs, aix), true)\n-          # AIX does not provide the equivalent of OBJCOPY to extract debug symbols,\n-          # so we copy the compiled object with symbols to the .debuginfo file, which\n-          # happens prior to the STRIP_CMD on the original target object file.\n-          $1_DEBUGINFO_FILES := $$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).debuginfo\n-          $1_CREATE_DEBUGINFO_CMDS := $(CP) $$($1_TARGET) $$($1_DEBUGINFO_FILES)\n-\n+          $1_DEBUGINFO_ZIP := $$($1_SYMBOLS_DIR)\/$$($1_BASENAME).diz\n@@ -78,2 +56,12 @@\n-          $1_CREATE_DEBUGINFO_CMDS := \\\n-              $(DSYMUTIL) --out $$($1_SYMBOLS_DIR)\/$$($1_BASENAME).dSYM $$($1_TARGET)\n+          $1_DEBUGINFO_ZIP := $$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).diz\n+        else ifeq ($(call isTargetOsType, unix), true)\n+          $1_DEBUGINFO_FILES := $$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).debuginfo\n+          $1_DEBUGINFO_ZIP := $$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).diz\n+        endif\n+\n+        ifeq ($(call isTargetOs, windows), true)\n+          $1_EXTRA_LDFLAGS += -debug \"-pdb:$$($1_SYMBOLS_DIR)\/$$($1_BASENAME).pdb\" \\\n+              \"-map:$$($1_SYMBOLS_DIR)\/$$($1_BASENAME).map\"\n+          ifeq ($(SHIP_DEBUG_SYMBOLS), public)\n+            $1_EXTRA_LDFLAGS += \"-pdbstripped:$$($1_SYMBOLS_DIR)\/$$($1_BASENAME).stripped.pdb\"\n+          endif\n@@ -101,7 +89,0 @@\n-          ifeq ($(call isTargetOs, windows), true)\n-            $1_DEBUGINFO_ZIP := $$($1_SYMBOLS_DIR)\/$$($1_BASENAME).diz\n-          else\n-            $1_DEBUGINFO_ZIP := $$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).diz\n-          endif\n-          $1 += $$($1_DEBUGINFO_ZIP)\n-\n@@ -114,0 +95,1 @@\n+          $1 += $$($1_DEBUGINFO_ZIP)\n","filename":"make\/common\/native\/DebugSymbols.gmk","additions":18,"deletions":36,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -55,6 +55,3 @@\n-  ifneq ($$($1_STRIP_SYMBOLS), false)\n-    # Default to using the global STRIPFLAGS. Allow for overriding with an\n-    # empty value\n-    $1_STRIPFLAGS ?= $(STRIPFLAGS)\n-    $1_STRIP_CMD := $$($1_STRIP) $$($1_STRIPFLAGS) $$($1_TARGET)\n-  endif\n+  # Default to using the global STRIPFLAGS. Allow for overriding with an\n+  # empty value\n+  $1_STRIPFLAGS ?= $(STRIPFLAGS)\n@@ -89,1 +86,1 @@\n-  $1_TARGET_DEPS := $$($1_ALL_OBJS) $$($1_VARDEPS_FILE)\n+  $1_TARGET_DEPS := $$($1_ALL_OBJS) $$($1_EXTRA_LINK_DEPS) $$($1_VARDEPS_FILE)\n@@ -112,1 +109,1 @@\n-\t    $(if $$($1_LINK_OBJS_RELATIVE), $$(CD) $$(OUTPUTDIR) ; ) \\\n+\t      $(if $$($1_LINK_OBJS_RELATIVE), $$(CD) $$(OUTPUTDIR) ; ) \\\n@@ -114,2 +111,1 @@\n-\t        -o $$($1_TARGET_RELOCATABLE) \\\n-\t        $$($1_LD_OBJ_ARG))\n+\t          -o $$($1_TARGET_RELOCATABLE) $$($1_LD_OBJ_ARG))\n@@ -117,2 +113,2 @@\n-\t$$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_link, \\\n-\t  $(if $$($1_LINK_OBJS_RELATIVE), $$(CD) $$(OUTPUTDIR) ; ) \\\n+\t$$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_run_ar, \\\n+\t    $(if $$($1_LINK_OBJS_RELATIVE), $$(CD) $$(OUTPUTDIR) ; ) \\\n@@ -138,0 +134,7 @@\n+  ifeq ($(MACOSX_CODESIGN_MODE), hardened)\n+    $1_CODESIGN_OPTS := \"$(MACOSX_CODESIGN_IDENTITY)\" --timestamp \\\n+        --options runtime\n+  else ifeq ($(MACOSX_CODESIGN_MODE), debug)\n+    $1_CODESIGN_OPTS := -\n+  endif\n+\n@@ -140,1 +143,1 @@\n-      $$($1_CREATE_DEBUGINFO_CMDS) $$($1_STRIP_CMD) $$($1_CREATE_DEBUGLINK_CMDS)\n+      $$($1_DEBUGINFO_FILES) $$($1_STRIPFLAGS)\n@@ -144,1 +147,1 @@\n-  $1_TARGET_DEPS := $$($1_ALL_OBJS) $$($1_VARDEPS_FILE)\n+  $1_TARGET_DEPS := $$($1_ALL_OBJS) $$($1_EXTRA_LINK_DEPS) $$($1_VARDEPS_FILE)\n@@ -156,1 +159,1 @@\n-\t$$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_link, \\\n+\t$$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_run_ld, \\\n@@ -161,15 +164,38 @@\n-\t$$($1_CREATE_DEBUGINFO_CMDS)\n-\t$$($1_STRIP_CMD)\n-\t$$($1_CREATE_DEBUGLINK_CMDS)\n-        # On macosx, optionally run codesign on every binary.\n-        # Remove signature explicitly first to avoid warnings if the linker\n-        # added a default adhoc signature.\n-        ifeq ($(MACOSX_CODESIGN_MODE), hardened)\n-\t  $(CODESIGN) --remove-signature $$@\n-\t  $(CODESIGN) -f -s \"$(MACOSX_CODESIGN_IDENTITY)\" --timestamp \\\n-\t      --options runtime --entitlements \\\n-\t      $$(call GetEntitlementsFile, $$@) $$@\n-        else ifeq ($(MACOSX_CODESIGN_MODE), debug)\n-\t  $(CODESIGN) --remove-signature $$@\n-\t  $(CODESIGN) -f -s - --entitlements \\\n-\t      $$(call GetEntitlementsFile, $$@) $$@\n+        ifeq ($$($1_CREATE_DEBUGINFO), true)\n+          ifeq ($(call isTargetOs, linux), true)\n+            # This cannot be run separately since it updates the original target\n+            # file.\n+\t    $$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_create_debuginfo, \\\n+\t        $$($1_OBJCOPY) --only-keep-debug $$($1_TARGET) $$($1_DEBUGINFO_FILES))\n+\t    $$(CHMOD) -x $$($1_DEBUGINFO_FILES)\n+          else ifeq ($(call isTargetOs, aix), true)\n+            # AIX does not provide the equivalent of objcopy to extract debug\n+            # symbols, so we copy unstripped library instead.\n+\t    $$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_create_debuginfo, \\\n+\t        $(CP) $$($1_TARGET) $$($1_DEBUGINFO_FILES))\n+          else ifeq ($(call isTargetOs, macosx), true)\n+\t    $$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_create_debuginfo, \\\n+\t        $(DSYMUTIL) --out $$($1_SYMBOLS_DIR)\/$$($1_BASENAME).dSYM $$($1_TARGET))\n+          endif\n+        endif\n+        ifneq ($$($1_STRIP_SYMBOLS), false)\n+\t  $$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_strip, \\\n+\t      $$($1_STRIP) $$($1_STRIPFLAGS) $$($1_TARGET))\n+        endif\n+        ifeq ($$($1_CREATE_DEBUGINFO), true)\n+          ifeq ($(call isTargetOs, linux), true)\n+            # Run this after strip is called, since strip can sometimes mangle\n+            # the embedded debuglink, which we want to avoid.\n+\t    $$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_add_debuginfo_link, \\\n+\t        $(CD) $$($1_SYMBOLS_DIR) && \\\n+\t            $$($1_OBJCOPY) --add-gnu-debuglink=$$($1_DEBUGINFO_FILES) $$($1_TARGET))\n+          endif\n+        endif\n+        ifneq ($(MACOSX_CODESIGN_MODE), disabled)\n+          # Remove signature explicitly first to avoid warnings if the linker\n+          # added a default adhoc signature.\n+\t  $$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_codesign_clear, \\\n+\t      $(CODESIGN) --remove-signature $$@)\n+\t  $$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_codesign_add, \\\n+\t      $(CODESIGN) -f -s $$($1_CODESIGN_OPTS) --entitlements \\\n+\t          $$(call GetEntitlementsFile, $$@) $$@)\n","filename":"make\/common\/native\/Link.gmk","additions":56,"deletions":30,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -46,1 +46,4 @@\n-  $$($1_TARGET): $$($1_ALL_OBJS) $$($1_RES) $$($1_VARDEPS_FILE)\n+  $1_TARGET_DEPS :=  $$($1_ALL_OBJS) $$($1_RES) $$($1_EXTRA_LINK_DEPS) \\\n+      $$($1_VARDEPS_FILE)\n+\n+  $$($1_TARGET): $$($1_TARGET_DEPS)\n@@ -52,1 +55,1 @@\n-\t$$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_link, \\\n+\t$$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_run_lib, \\\n@@ -90,1 +93,1 @@\n-      $$($1_VARDEPS_FILE)\n+      $$($1_EXTRA_LINK_DEPS) $$($1_VARDEPS_FILE)\n@@ -98,1 +101,1 @@\n-\t$$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_link, \\\n+\t$$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_run_ld, \\\n","filename":"make\/common\/native\/LinkMicrosoft.gmk","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+include CopyFiles.gmk\n+\n","filename":"make\/hotspot\/CopyToExplodedJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+include CopyFiles.gmk\n+\n","filename":"make\/hotspot\/gensrc\/GensrcJvmti.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,2 +92,1 @@\n-    EXTRA_OBJECT_FILES := $(filter-out %\/operator_new$(OBJ_SUFFIX), \\\n-        $(BUILD_LIBJVM_ALL_OBJS)), \\\n+    EXTRA_OBJECT_FILES := $(BUILD_LIBJVM_ALL_OBJS), \\\n@@ -113,3 +112,1 @@\n-    LDFLAGS_unix := -L$(JVM_OUTPUTDIR)\/libgtest, \\\n-    JDK_LIBS_unix := -lgtest, \\\n-    JDK_LIBS_windows := $(JVM_OUTPUTDIR)\/libgtest\/gtest.lib, \\\n+    JDK_LIBS := gtest:libgtest, \\\n@@ -154,3 +151,2 @@\n-    LDFLAGS_unix := -L$(JVM_OUTPUTDIR)\/gtest $(call SET_SHARED_LIBRARY_ORIGIN), \\\n-    JDK_LIBS_unix := -ljvm, \\\n-    JDK_LIBS_windows := $(JVM_OUTPUTDIR)\/gtest\/objs\/jvm.lib, \\\n+    LDFLAGS_unix := $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    JDK_LIBS := gtest:libjvm, \\\n@@ -161,2 +157,0 @@\n-$(BUILD_GTEST_LAUNCHER): $(BUILD_GTEST_LIBJVM)\n-\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+include CopyFiles.gmk\n+\n@@ -138,7 +140,0 @@\n-# The global operator new functions defined in operator_new.cpp are intended\n-# to detect and prevent the VM code from calling them. See more details in\n-# operator_new.cpp. Exclude operator_new.o when statically linking the VM\n-# code with JDK natives, as the JDK natives might need to call the global\n-# operator new.\n-LIBJVM_STATIC_EXCLUDE_OBJS := operator_new.o\n-\n@@ -218,1 +213,0 @@\n-    STATIC_LIB_EXCLUDE_OBJS := $(LIBJVM_STATIC_EXCLUDE_OBJS), \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+include CopyFiles.gmk\n+\n@@ -35,1 +37,1 @@\n-      FILES := $(call SHARED_LIBRARY,jvm) gtestLauncher$(EXECUTABLE_SUFFIX), \\\n+      FILES := $(LIBRARY_PREFIX)jvm$(SHARED_LIBRARY_SUFFIX) gtestLauncher$(EXECUTABLE_SUFFIX), \\\n","filename":"make\/hotspot\/test\/GtestImage.gmk","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,3 +53,3 @@\n-    private String filename;\n-    private File file;\n-    private File stopFile;\n+    private final String filename;\n+    private final File file;\n+    private final File stopFile;\n@@ -57,1 +57,0 @@\n-    private FileChannel channel;\n@@ -63,1 +62,1 @@\n-    private Semaphore lockSem = new Semaphore(1);\n+    private final Semaphore lockSem = new Semaphore(1);\n@@ -92,1 +91,0 @@\n-        channel = rwfile.getChannel();\n@@ -99,3 +97,0 @@\n-        if (channel == null) {\n-            initializeChannel();\n-        }\n@@ -103,0 +98,5 @@\n+        if (rwfile != null) {\n+            throw new IllegalStateException(\"rwfile not null\");\n+        }\n+        initializeChannel();\n+        FileChannel channel = rwfile.getChannel();\n@@ -113,2 +113,1 @@\n-            \/\/ Not locked, remain ignorant about port file contents.\n-            return;\n+            throw new IllegalStateException(\"Must lock before calling getValues\");\n@@ -159,0 +158,3 @@\n+        if (lock == null) {\n+            throw new IllegalStateException(\"Must lock before calling setValues\");\n+        }\n@@ -172,6 +174,4 @@\n-        \/\/ Access to file must be closed before deleting.\n-        rwfile.close();\n-\n-        file.delete();\n-\n-        \/\/ Wait until file has been deleted (deletes are asynchronous on Windows!) otherwise we\n+        if (!file.exists()) { \/\/ file deleted already\n+            return;\n+        }\n+        \/\/ Keep trying until file has been deleted, otherwise we\n@@ -179,1 +179,1 @@\n-        for (int i = 0; i < 10 && file.exists(); i++) {\n+        for (int i = 0; i < 10 && file.exists() && !file.delete(); i++) {\n@@ -185,0 +185,2 @@\n+        \/\/ allow some time for late clients to connect\n+        Thread.sleep(1000);\n@@ -213,1 +215,1 @@\n-            return;\n+            throw new IllegalStateException(\"Not locked\");\n@@ -217,0 +219,2 @@\n+        rwfile.close();\n+        rwfile = null;\n","filename":"make\/langtools\/tools\/javacserver\/shared\/PortFile.java","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+include CopyFiles.gmk\n@@ -56,2 +57,1 @@\n-    JDK_LIBS_unix := -ljava -ljvm, \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB) jvm.lib, \\\n+    JDK_LIBS := libjava libjvm, \\\n@@ -67,2 +67,0 @@\n-$(BUILD_LIBNET): $(BUILD_LIBJAVA)\n-\n@@ -81,4 +79,2 @@\n-        libnet, \\\n-    JDK_LIBS_unix := -ljava -lnet, \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB) jvm.lib \\\n-        $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libnet\/net.lib, \\\n+        libjvm, \\\n+    JDK_LIBS := libjava libnet, \\\n@@ -95,2 +91,0 @@\n-$(BUILD_LIBNIO): $(BUILD_LIBNET)\n-\n@@ -106,2 +100,1 @@\n-      LDFLAGS := -L$(SUPPORT_OUTPUTDIR)\/modules_libs\/java.base,\\\n-      JDK_LIBS := $(JDKLIB_LIBS), \\\n+      JDK_LIBS := libjava, \\\n@@ -114,2 +107,0 @@\n-  $(BUILD_LIBOSXSECURITY): $(BUILD_LIBJAVA)\n-\n@@ -138,0 +129,1 @@\n+    LIBJSIG_NAME := $(LIBRARY_PREFIX)jsig$(SHARED_LIBRARY_SUFFIX)\n@@ -142,2 +134,2 @@\n-      $(LIB_OUTPUTDIR)\/$1\/$(call SHARED_LIBRARY,jsig): \\\n-          $(LIB_OUTPUTDIR)\/$(call SHARED_LIBRARY,jsig)\n+      $(LIB_OUTPUTDIR)\/$1\/$(LIBJSIG_NAME): \\\n+          $(LIB_OUTPUTDIR)\/$(LIBJSIG_NAME)\n@@ -148,1 +140,1 @@\n-      TARGETS += $(LIB_OUTPUTDIR)\/$1\/$(call SHARED_LIBRARY,jsig)\n+      TARGETS += $(LIB_OUTPUTDIR)\/$1\/$(LIBJSIG_NAME)\n@@ -207,0 +199,1 @@\n+      EXTRA_HEADER_DIRS := java.base:libjava, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-    JDK_LIBS_unix := -ljvm, \\\n-    JDK_LIBS_windows := jvm.lib, \\\n+    EXTRA_HEADER_DIRS := libjava, \\\n+    JDK_LIBS := libjvm, \\\n@@ -61,3 +61,1 @@\n-    LDFLAGS_macosx := -L$(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/, \\\n-    JDK_LIBS_unix := -ljvm, \\\n-    JDK_LIBS_windows := jvm.lib, \\\n+    JDK_LIBS := libjvm, \\\n@@ -75,2 +73,0 @@\n-$(BUILD_LIBJAVA): $(BUILD_LIBVERIFY)\n-\n@@ -99,2 +95,1 @@\n-    JDK_LIBS_unix := -ljava -ljvm, \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB) jvm.lib, \\\n+    JDK_LIBS := libjava libjvm, \\\n@@ -104,2 +99,0 @@\n-$(BUILD_LIBZIP): $(BUILD_LIBJAVA)\n-\n@@ -116,0 +109,1 @@\n+    EXTRA_HEADER_DIRS := libjava, \\\n@@ -118,2 +112,1 @@\n-    JDK_LIBS_unix := -ljvm, \\\n-    JDK_LIBS_windows := jvm.lib, \\\n+    JDK_LIBS := libjvm, \\\n@@ -123,2 +116,0 @@\n-$(BUILD_LIBJIMAGE): $(BUILD_LIBJAVA)\n-\n@@ -176,0 +167,1 @@\n+    EXTRA_HEADER_DIRS := libjvm, \\\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-include lib\/Awt2dLibraries.gmk\n+include lib\/AwtLibraries.gmk\n+include lib\/ClientLibraries.gmk\n@@ -63,0 +64,1 @@\n+      EXTRA_HEADER_DIRS := java.base:libjava, \\\n@@ -67,2 +69,0 @@\n-      JDK_LIBS_unix := -ljava -ljvm, \\\n-      JDK_LIBS_windows := $(WIN_JAVA_LIB), \\\n@@ -80,2 +80,0 @@\n-  $(BUILD_LIBJSOUND): $(call FindLib, java.base, java)\n-\n@@ -97,1 +95,1 @@\n-      JDK_LIBS_macosx := -ljava, \\\n+      JDK_LIBS := java.base:libjava, \\\n@@ -112,2 +110,0 @@\n-  $(BUILD_LIBOSXAPP): $(call FindLib, java.base, java)\n-\n@@ -123,1 +119,1 @@\n-      EXTRA_HEADER_DIRS := libosxapp, \\\n+      EXTRA_HEADER_DIRS := java.base:libjava, \\\n@@ -125,2 +121,1 @@\n-      LDFLAGS := -L$(SUPPORT_OUTPUTDIR)\/modules_libs\/java.desktop, \\\n-      JDK_LIBS_macosx := $(JDKLIB_LIBS) -losxapp, \\\n+      JDK_LIBS := libosxapp, \\\n@@ -135,4 +130,0 @@\n-\n-  $(BUILD_LIBOSX): $(call FindLib, java.desktop, osxapp)\n-\n-  $(BUILD_LIBOSX): $(call FindLib, java.base, java)\n","filename":"make\/modules\/java.desktop\/Lib.gmk","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,921 +0,0 @@\n-#\n-# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-WIN_AWT_LIB := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libawt\/awt.lib\n-\n-LIBAWT_DEFAULT_HEADER_DIRS := \\\n-    common\/awt\/utility \\\n-    libawt\/awt\/image \\\n-    libawt\/awt\/image\/cvutils \\\n-    libawt\/java2d \\\n-    libawt\/java2d\/loops \\\n-    libawt\/java2d\/pipe \\\n-    #\n-\n-################################################################################\n-## Build libmlib_image\n-################################################################################\n-\n-ifeq ($(call isTargetCpuBits, 64), true)\n-  LIBMLIB_IMAGE_CFLAGS := -DMLIB_OS64BIT\n-endif\n-\n-$(eval $(call SetupJdkLibrary, BUILD_LIBMLIB_IMAGE, \\\n-    NAME := mlib_image, \\\n-    EXTRA_SRC := common\/awt\/medialib, \\\n-    EXCLUDE_FILES := mlib_c_ImageBlendTable.c, \\\n-    OPTIMIZATION := HIGHEST, \\\n-    CFLAGS := -D__USE_J2D_NAMES -D__MEDIALIB_OLD_NAMES -DMLIB_NO_LIBSUNMATH \\\n-        $(LIBMLIB_IMAGE_CFLAGS), \\\n-    DISABLED_WARNINGS_gcc := unused-function, \\\n-    JDK_LIBS := $(JDKLIB_LIBS), \\\n-    LIBS_unix := $(LIBDL) $(LIBM), \\\n-))\n-\n-$(BUILD_LIBMLIB_IMAGE): $(call FindLib, java.base, java)\n-\n-TARGETS += $(BUILD_LIBMLIB_IMAGE)\n-\n-################################################################################\n-## Build libawt\n-################################################################################\n-\n-LIBAWT_EXTRA_SRC := \\\n-    common\/awt\/debug \\\n-    $(TOPDIR)\/src\/$(MODULE)\/$(OPENJDK_TARGET_OS_TYPE)\/native\/common\/awt \\\n-    #\n-\n-ifeq ($(call isTargetOs, windows), true)\n-  LIBAWT_EXTRA_SRC += \\\n-      $(TOPDIR)\/src\/$(MODULE)\/share\/native\/common\/awt\/utility \\\n-      $(TOPDIR)\/src\/$(MODULE)\/share\/native\/common\/font \\\n-      $(TOPDIR)\/src\/$(MODULE)\/share\/native\/common\/java2d\/opengl \\\n-      $(TOPDIR)\/src\/$(MODULE)\/$(OPENJDK_TARGET_OS_TYPE)\/native\/common\/awt\/systemscale \\\n-      #\n-endif\n-\n-ifeq ($(call isTargetOs, linux macosx aix), true)\n-  LIBAWT_EXCLUDE_FILES += awt_Font.c CUPSfuncs.c fontpath.c X11Color.c\n-endif\n-\n-ifeq ($(call isTargetOs, macosx), true)\n-  LIBAWT_EXCLUDE_FILES += initIDs.c img_colors.c\n-endif\n-\n-ifeq ($(call isTargetOs, windows), true)\n-  LIBAWT_EXCLUDE_FILES += D3DShaderGen.c img_colors.c\n-endif\n-\n-LIBAWT_EXTRA_HEADER_DIRS := \\\n-    $(LIBAWT_DEFAULT_HEADER_DIRS) \\\n-    $(call GetJavaHeaderDir, java.base) \\\n-    libawt\/awt\/medialib \\\n-    libawt\/java2d\/d3d \\\n-    libawt\/java2d\/opengl \\\n-    libawt\/java2d\/windows \\\n-    libawt\/windows \\\n-    common\/awt\/medialib \\\n-    libmlib_image \\\n-    include \\\n-    java.base:libjava \\\n-    #\n-\n-LIBAWT_CFLAGS := -D__MEDIALIB_OLD_NAMES -D__USE_J2D_NAMES -DMLIB_NO_LIBSUNMATH\n-\n-ifeq ($(call isTargetOs, windows), true)\n-  LIBAWT_CFLAGS += -EHsc -DUNICODE -D_UNICODE\n-  ifeq ($(call isTargetCpuBits, 64), true)\n-    LIBAWT_CFLAGS += -DMLIB_OS64BIT\n-  endif\n-\n-  LIBAWT_RCFLAGS ?= -I$(TOPDIR)\/src\/java.base\/windows\/native\/launcher\/icons\n-  LIBAWT_VERSIONINFO_RESOURCE := \\\n-      $(TOPDIR)\/src\/$(MODULE)\/windows\/native\/libawt\/windows\/awt.rc\n-endif\n-\n-# -fgcse-after-reload improves performance of MaskFill in Java2D by 20% for\n-# some gcc\n-$(eval $(call SetupJdkLibrary, BUILD_LIBAWT, \\\n-    NAME := awt, \\\n-    EXTRA_SRC := $(LIBAWT_EXTRA_SRC), \\\n-    EXCLUDE_FILES := $(LIBAWT_EXCLUDE_FILES), \\\n-    OPTIMIZATION := HIGHEST, \\\n-    CFLAGS := $(LIBAWT_CFLAGS) $(X_CFLAGS), \\\n-    CXXFLAGS := $(LIBAWT_CFLAGS) $(X_CFLAGS), \\\n-    CFLAGS_gcc := -fgcse-after-reload, \\\n-    EXTRA_HEADER_DIRS := $(LIBAWT_EXTRA_HEADER_DIRS), \\\n-    DISABLED_WARNINGS_gcc_awt_LoadLibrary.c := unused-result, \\\n-    DISABLED_WARNINGS_gcc_debug_mem.c := format-nonliteral, \\\n-    DISABLED_WARNINGS_gcc_ProcessPath.c := maybe-uninitialized, \\\n-    DISABLED_WARNINGS_gcc_Region.c := maybe-uninitialized, \\\n-    DISABLED_WARNINGS_gcc_SurfaceData.c := unused-value, \\\n-    DISABLED_WARNINGS_gcc_TransformHelper.c := sign-compare, \\\n-    DISABLED_WARNINGS_clang_awt_ImagingLib.c := deprecated-non-prototype, \\\n-    DISABLED_WARNINGS_clang_debug_trace.c := format-nonliteral, \\\n-    DISABLED_WARNINGS_clang_Trace.c := format-nonliteral, \\\n-    DISABLED_WARNINGS_clang_TransformHelper.c := sign-compare, \\\n-    DISABLED_WARNINGS_microsoft := 4244 4996, \\\n-    DISABLED_WARNINGS_microsoft_awt_Toolkit.cpp := 4267, \\\n-    LDFLAGS_macosx := -L$(INSTALL_LIBRARIES_HERE), \\\n-    LDFLAGS_windows := -delayload:comctl32.dll -delayload:comdlg32.dll \\\n-        -delayload:gdi32.dll -delayload:imm32.dll -delayload:ole32.dll \\\n-        -delayload:shell32.dll -delayload:shlwapi.dll -delayload:user32.dll \\\n-        -delayload:winmm.dll -delayload:winspool.drv, \\\n-    JDK_LIBS_unix := -ljava -ljvm, \\\n-    JDK_LIBS_macosx := -lmlib_image, \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB) jvm.lib, \\\n-    LIBS_unix := $(LIBM), \\\n-    LIBS_linux := $(LIBDL), \\\n-    LIBS_aix := $(LIBDL),\\\n-    LIBS_macosx := \\\n-        -framework ApplicationServices \\\n-        -framework AudioToolbox \\\n-        -framework Cocoa \\\n-        -framework JavaRuntimeSupport \\\n-        -framework Metal \\\n-        -framework OpenGL, \\\n-    LIBS_windows := advapi32.lib comctl32.lib comdlg32.lib delayimp.lib \\\n-        gdi32.lib imm32.lib kernel32.lib ole32.lib shell32.lib shlwapi.lib \\\n-        user32.lib uuid.lib winmm.lib winspool.lib, \\\n-    VERSIONINFO_RESOURCE := $(LIBAWT_VERSIONINFO_RESOURCE), \\\n-    EXTRA_RCFLAGS := $(LIBAWT_RCFLAGS), \\\n-))\n-\n-$(BUILD_LIBAWT): $(call FindLib, java.base, java)\n-\n-ifeq ($(call isTargetOs, macosx), true)\n-  $(BUILD_LIBAWT): $(BUILD_LIBMLIB_IMAGE)\n-endif\n-\n-TARGETS += $(BUILD_LIBAWT)\n-\n-ifeq ($(call isTargetOs, windows macosx)+$(ENABLE_HEADLESS_ONLY), false+false)\n-  ##############################################################################\n-  ## Build libawt_xawt\n-  ##############################################################################\n-\n-  LIBAWT_XAWT_EXTRA_SRC := \\\n-      common\/awt \\\n-      common\/java2d \\\n-      common\/font \\\n-      #\n-\n-  LIBAWT_XAWT_EXTRA_HEADER_DIRS := \\\n-      $(LIBAWT_DEFAULT_HEADER_DIRS) \\\n-      libawt_xawt\/awt \\\n-      include \\\n-      common\/awt\/debug \\\n-      common\/awt\/systemscale \\\n-      common\/font \\\n-      common\/java2d\/opengl \\\n-      common\/java2d\/x11 \\\n-      libpipewire\/include \\\n-      #\n-\n-  ifeq ($(call isTargetOs, linux), true)\n-    ifeq ($(DISABLE_XRENDER), true)\n-      LIBAWT_XAWT_CFLAGS += -DDISABLE_XRENDER_BY_DEFAULT=true\n-    endif\n-  endif\n-\n-  # These are the object files provided by the awt native\n-  # library. Do not include these external (non-awt_xawt library)\n-  # objects in the static library. When statically linking the java\n-  # launcher with all JDK and VM static libraries, we use the\n-  # --whole-archive linker option. The duplicate objects in different\n-  # static libraries cause linking errors due to duplicate symbols.\n-  LIBAWT_XAWT_STATIC_EXCLUDE_OBJS := systemScale.o\n-\n-  $(eval $(call SetupJdkLibrary, BUILD_LIBAWT_XAWT, \\\n-      NAME := awt_xawt, \\\n-      EXTRA_SRC := $(LIBAWT_XAWT_EXTRA_SRC), \\\n-      EXTRA_HEADER_DIRS := $(LIBAWT_XAWT_EXTRA_HEADER_DIRS), \\\n-      EXCLUDES := medialib debug, \\\n-      OPTIMIZATION := LOW, \\\n-      CFLAGS := -DXAWT -DXAWT_HACK $(LIBAWT_XAWT_CFLAGS) \\\n-          $(FONTCONFIG_CFLAGS) $(CUPS_CFLAGS) $(X_CFLAGS), \\\n-      DISABLED_WARNINGS_gcc := int-to-pointer-cast, \\\n-      DISABLED_WARNINGS_gcc_awt_Taskbar.c := parentheses, \\\n-      DISABLED_WARNINGS_gcc_GLXSurfaceData.c := unused-function, \\\n-      DISABLED_WARNINGS_gcc_gtk2_interface.c := parentheses type-limits, \\\n-      DISABLED_WARNINGS_gcc_gtk3_interface.c := parentheses type-limits \\\n-          unused-function, \\\n-      DISABLED_WARNINGS_gcc_OGLBufImgOps.c := format-nonliteral, \\\n-      DISABLED_WARNINGS_gcc_OGLPaints.c := format-nonliteral, \\\n-      DISABLED_WARNINGS_gcc_screencast_pipewire.c := undef, \\\n-      DISABLED_WARNINGS_gcc_screencast_portal.c := undef, \\\n-      DISABLED_WARNINGS_gcc_sun_awt_X11_GtkFileDialogPeer.c := parentheses, \\\n-      DISABLED_WARNINGS_gcc_X11SurfaceData.c := implicit-fallthrough \\\n-          pointer-to-int-cast, \\\n-      DISABLED_WARNINGS_gcc_XlibWrapper.c := type-limits pointer-to-int-cast, \\\n-      DISABLED_WARNINGS_gcc_XRBackendNative.c := maybe-uninitialized, \\\n-      DISABLED_WARNINGS_gcc_XToolkit.c := unused-result, \\\n-      DISABLED_WARNINGS_gcc_XWindow.c := unused-function, \\\n-      DISABLED_WARNINGS_clang_awt_Taskbar.c := parentheses, \\\n-      DISABLED_WARNINGS_clang_gtk2_interface.c := parentheses, \\\n-      DISABLED_WARNINGS_clang_gtk3_interface.c := parentheses, \\\n-      DISABLED_WARNINGS_clang_OGLBufImgOps.c := format-nonliteral, \\\n-      DISABLED_WARNINGS_clang_OGLPaints.c := format-nonliteral, \\\n-      DISABLED_WARNINGS_clang_screencast_pipewire.c := format-nonliteral, \\\n-      DISABLED_WARNINGS_clang_sun_awt_X11_GtkFileDialogPeer.c := parentheses, \\\n-      DISABLED_WARNINGS_clang_aix := deprecated-non-prototype, \\\n-      DISABLED_WARNINGS_clang_aix_awt_Taskbar.c := parentheses, \\\n-      DISABLED_WARNINGS_clang_aix_OGLPaints.c := format-nonliteral, \\\n-      DISABLED_WARNINGS_clang_aix_OGLBufImgOps.c := format-nonliteral, \\\n-      DISABLED_WARNINGS_clang_aix_gtk2_interface.c := parentheses \\\n-          logical-op-parentheses, \\\n-      DISABLED_WARNINGS_clang_aix_gtk3_interface.c := parentheses \\\n-          logical-op-parentheses, \\\n-      DISABLED_WARNINGS_clang_aix_sun_awt_X11_GtkFileDialogPeer.c := \\\n-          parentheses, \\\n-      DISABLED_WARNINGS_clang_aix_awt_InputMethod.c := sign-compare, \\\n-      LDFLAGS := -L$(INSTALL_LIBRARIES_HERE), \\\n-      JDK_LIBS_unix := -lawt -ljava -ljvm, \\\n-      LIBS_unix := $(LIBDL) $(LIBM) $(X_LIBS) -lX11 -lXext -lXi -lXrender \\\n-          -lXtst, \\\n-      LIBS_linux := -lpthread, \\\n-      STATIC_LIB_EXCLUDE_OBJS := $(LIBAWT_XAWT_STATIC_EXCLUDE_OBJS), \\\n-  ))\n-\n-  $(BUILD_LIBAWT_XAWT): $(call FindLib, java.base, java)\n-\n-  $(BUILD_LIBAWT_XAWT): $(BUILD_LIBAWT)\n-\n-  TARGETS += $(BUILD_LIBAWT_XAWT)\n-endif\n-\n-################################################################################\n-## Build liblcms\n-################################################################################\n-\n-ifeq ($(USE_EXTERNAL_LCMS), true)\n-  # If we're using an external library, we'll just need the wrapper part.\n-  # By including it explicitly, all other files will be excluded.\n-  LIBLCMS_INCLUDE_FILES := LCMS.c\n-  # If we're using an external library, we can't include our own SRC path\n-  # as includes, instead the system headers should be used.\n-  LIBLCMS_HEADERS_FROM_SRC := false\n-  # FIXME: Keep old behavior and reset LCMS_CFLAGS. This is likely a bug.\n-  LCMS_CFLAGS :=\n-endif\n-\n-ifeq ($(TOOLCHAIN_TYPE)+$(TOOLCHAIN_VERSION), clang+10.1)\n-  # Work around an optimizer bug seen with Xcode 10.1, but fixed by 10.3\n-  BUILD_LIBLCMS_cmsopt.c_CFLAGS := -O0\n-endif\n-\n-# We use CMS_DONT_USE_FAST_FLOOR and CMS_NO_HALF_SUPPORT since the fast floor\n-# code loses precision.\n-$(eval $(call SetupJdkLibrary, BUILD_LIBLCMS, \\\n-    NAME := lcms, \\\n-    INCLUDE_FILES := $(LIBLCMS_INCLUDE_FILES), \\\n-    OPTIMIZATION := HIGHEST, \\\n-    CFLAGS := -DCMS_DONT_USE_FAST_FLOOR -DCMS_NO_HALF_SUPPORT $(LCMS_CFLAGS), \\\n-    CFLAGS_windows := -DCMS_IS_WINDOWS_, \\\n-    EXTRA_HEADER_DIRS := \\\n-        common\/awt\/debug \\\n-        libawt\/java2d, \\\n-    HEADERS_FROM_SRC := $(LIBLCMS_HEADERS_FROM_SRC), \\\n-    DISABLED_WARNINGS_gcc := format-nonliteral type-limits \\\n-        stringop-truncation, \\\n-    DISABLED_WARNINGS_clang := format-nonliteral, \\\n-    LDFLAGS_unix := -L$(INSTALL_LIBRARIES_HERE), \\\n-    JDK_LIBS_unix := -lawt -ljava -ljvm, \\\n-    JDK_LIBS_windows := $(WIN_AWT_LIB) $(WIN_JAVA_LIB), \\\n-    LIBS_unix := $(LCMS_LIBS) $(LIBM), \\\n-))\n-\n-TARGETS += $(BUILD_LIBLCMS)\n-\n-$(BUILD_LIBLCMS): $(BUILD_LIBAWT)\n-\n-################################################################################\n-## Build libjavajpeg\n-################################################################################\n-\n-ifeq ($(USE_EXTERNAL_LIBJPEG), true)\n-  LIBJAVAJPEG_INCLUDE_FILES := \\\n-      imageioJPEG.c \\\n-      jpegdecoder.c\n-  # If we're using an external library, we can't include our own SRC path\n-  # as includes, instead the system headers should be used.\n-  LIBJAVAJPEG_HEADERS_FROM_SRC := false\n-endif\n-\n-# \"DISABLED_WARNINGS_gcc := clobbered\" rationale:\n-# Suppress gcc warnings like \"variable might be clobbered by 'longjmp'\n-# or 'vfork'\": this warning indicates that some variable is placed to\n-# a register by optimized compiler and it's value might be lost on longjmp().\n-# Recommended way to avoid such warning is to declare the variable as\n-# volatile to prevent the optimization. However, this approach does not\n-# work because we have to declare all variables as volatile in result.\n-$(eval $(call SetupJdkLibrary, BUILD_LIBJAVAJPEG, \\\n-    NAME := javajpeg, \\\n-    INCLUDE_FILES := $(LIBJAVAJPEG_INCLUDE_FILES), \\\n-    OPTIMIZATION := HIGHEST, \\\n-    HEADERS_FROM_SRC := $(LIBJAVAJPEG_HEADERS_FROM_SRC), \\\n-    DISABLED_WARNINGS_gcc_imageioJPEG.c := clobbered array-bounds, \\\n-    DISABLED_WARNINGS_gcc_jcmaster.c := implicit-fallthrough, \\\n-    DISABLED_WARNINGS_gcc_jdphuff.c := shift-negative-value, \\\n-    JDK_LIBS := $(JDKLIB_LIBS), \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB) jvm.lib, \\\n-    LIBS := $(LIBJPEG_LIBS), \\\n-))\n-\n-$(BUILD_LIBJAVAJPEG): $(call FindLib, java.base, java)\n-\n-TARGETS += $(BUILD_LIBJAVAJPEG)\n-\n-\n-# Mac and Windows only use the native AWT lib, do not build libawt_headless\n-ifeq ($(call isTargetOs, windows macosx), false)\n-  ##############################################################################\n-  ## Build libawt_headless\n-  ##############################################################################\n-\n-  LIBAWT_HEADLESS_EXTRA_SRC := \\\n-      common\/font \\\n-      common\/java2d \\\n-      $(TOPDIR)\/src\/$(MODULE)\/$(OPENJDK_TARGET_OS_TYPE)\/native\/common\/awt \\\n-      #\n-\n-  LIBAWT_HEADLESS_EXTRA_HEADER_DIRS := \\\n-      $(LIBAWT_DEFAULT_HEADER_DIRS) \\\n-      common\/awt\/debug \\\n-      common\/font \\\n-      common\/java2d\/opengl \\\n-      #\n-\n-  # These are the object files provided by the awt native\n-  # library. Do not include these external (non-awt_headless library)\n-  # objects in the static library. When statically linking the java\n-  # launcher with all JDK and VM static libraries, we use the\n-  # --whole-archive linker option. The duplicate objects in different\n-  # static libraries cause linking errors due to duplicate symbols.\n-  LIBAWT_HEADLESS_STATIC_EXCLUDE_OBJS := systemScale.o\n-\n-  $(eval $(call SetupJdkLibrary, BUILD_LIBAWT_HEADLESS, \\\n-      NAME := awt_headless, \\\n-      EXTRA_SRC := $(LIBAWT_HEADLESS_EXTRA_SRC), \\\n-      EXCLUDES := medialib, \\\n-      OPTIMIZATION := LOW, \\\n-      CFLAGS := -DHEADLESS=true $(CUPS_CFLAGS) $(FONTCONFIG_CFLAGS) \\\n-          $(X_CFLAGS), \\\n-      EXTRA_HEADER_DIRS := $(LIBAWT_HEADLESS_EXTRA_HEADER_DIRS), \\\n-      DISABLED_WARNINGS_gcc_X11Renderer.c := unused-function, \\\n-      DISABLED_WARNINGS_gcc_X11SurfaceData.c := unused-function, \\\n-      LDFLAGS_unix := -L$(INSTALL_LIBRARIES_HERE), \\\n-      JDK_LIBS_unix := -lawt -ljava -ljvm, \\\n-      LIBS_linux := $(LIBDL) $(LIBM), \\\n-      STATIC_LIB_EXCLUDE_OBJS := $(LIBAWT_HEADLESS_STATIC_EXCLUDE_OBJS), \\\n-  ))\n-\n-  $(BUILD_LIBAWT_HEADLESS): $(BUILD_LIBAWT)\n-\n-  TARGETS += $(BUILD_LIBAWT_HEADLESS)\n-endif\n-\n-################################################################################\n-## Build libfreetype\n-################################################################################\n-\n-ifeq ($(FREETYPE_TO_USE), bundled)\n-  # freetype requires you to manually define DLL_EXPORT for windows (see ftconfig.h)\n-  $(eval $(call SetupJdkLibrary, BUILD_LIBFREETYPE, \\\n-      NAME := freetype, \\\n-      OPTIMIZATION := HIGHEST, \\\n-      CFLAGS := -DFT2_BUILD_LIBRARY, \\\n-      CFLAGS_windows := -DDLL_EXPORT, \\\n-      EXTRA_HEADER_DIRS := libfreetype\/include, \\\n-      DISABLED_WARNINGS_microsoft := 4267 4244 4996, \\\n-      DISABLED_WARNINGS_gcc := dangling-pointer stringop-overflow, \\\n-  ))\n-\n-  TARGETS += $(BUILD_LIBFREETYPE)\n-endif\n-\n-################################################################################\n-## Build libfontmanager\n-################################################################################\n-\n-ifeq ($(USE_EXTERNAL_HARFBUZZ), true)\n-   LIBFONTMANAGER_EXTRA_SRC =\n-   LIBFONTMANAGER_LIBS += $(HARFBUZZ_LIBS)\n-else\n-   LIBFONTMANAGER_EXTRA_SRC = libharfbuzz\n-\n-   ifeq ($(call isTargetOs, windows), false)\n-     HARFBUZZ_CFLAGS += -DGETPAGESIZE -DHAVE_MPROTECT -DHAVE_PTHREAD \\\n-        -DHAVE_SYSCONF -DHAVE_SYS_MMAN_H -DHAVE_UNISTD_H \\\n-        -DHB_NO_PRAGMA_GCC_DIAGNOSTIC\n-   endif\n-   ifeq ($(call isTargetOs, linux macosx), true)\n-     HARFBUZZ_CFLAGS += -DHAVE_INTEL_ATOMIC_PRIMITIVES -DHB_NO_VISIBILITY\n-   endif\n-\n-   # hb-ft.cc is not presently needed, and requires freetype 2.4.2 or later.\n-   # hb-subset and hb-style APIs are not needed, excluded to cut on compilation\n-   # time.\n-   LIBFONTMANAGER_EXCLUDE_FILES += gsubgpos-context.cc hb-ft.cc hb-style.cc \\\n-      hb-subset-cff-common.cc hb-subset-cff1.cc hb-subset-cff2.cc \\\n-      hb-subset-input.cc hb-subset-instancer-solver.cc hb-subset-plan.cc \\\n-      hb-subset.cc\n-\n-   # list of disabled warnings and the compilers for which it was specifically\n-   # added.\n-   # array-bounds         -> GCC 12 on Alpine Linux\n-   # parentheses          -> GCC 6\n-   # range-loop-analysis  -> clang on Xcode12\n-\n-   HARFBUZZ_DISABLED_WARNINGS_gcc := missing-field-initializers \\\n-       strict-aliasing unused-result array-bounds parentheses\n-   # noexcept-type required for GCC 7 builds. Not required for GCC 8+.\n-   # expansion-to-defined required for GCC 9 builds. Not required for GCC 10+.\n-   # maybe-uninitialized required for GCC 8 builds. Not required for GCC 9+.\n-   # calloc-transposed-args required for GCC 14 builds. (fixed upstream in\n-   #  Harfbuzz 032c931e1c0cfb20f18e5acb8ba005775242bd92)\n-   HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type \\\n-       expansion-to-defined dangling-reference maybe-uninitialized \\\n-       calloc-transposed-args\n-   HARFBUZZ_DISABLED_WARNINGS_clang := missing-field-initializers \\\n-      range-loop-analysis\n-   HARFBUZZ_DISABLED_WARNINGS_microsoft := 4267 4244\n-\n-   LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n-endif\n-\n-LIBFONTMANAGER_EXTRA_HEADER_DIRS := \\\n-    libharfbuzz \\\n-    common\/awt \\\n-    common\/awt\/utility \\\n-    common\/font \\\n-    libawt\/java2d \\\n-    libawt\/java2d\/pipe \\\n-    libawt\/java2d\/loops \\\n-    #\n-\n-ifeq ($(FREETYPE_TO_USE), system)\n-  LIBFONTMANAGER_CFLAGS += $(FREETYPE_CFLAGS)\n-  LIBFONTMANAGER_LIBS += $(FREETYPE_LIBS)\n-else\n-  LIBFONTMANAGER_EXTRA_HEADER_DIRS += libfreetype\/include\n-\n-  ifeq ($(call isTargetOs, windows), true)\n-    LIBFONTMANAGER_JDK_LIBS += \\\n-        $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libfreetype\/freetype.lib\n-  else\n-    LIBFONTMANAGER_JDK_LIBS += -lfreetype\n-  endif\n-endif\n-\n-LIBFONTMANAGER_OPTIMIZATION := HIGHEST\n-\n-ifneq ($(filter $(TOOLCHAIN_TYPE), gcc clang), )\n-  # gcc (and to an extent clang) is particularly bad at optimizing these files,\n-  # causing a massive spike in compile time. We don't care about these\n-  # particular files anyway, so lower optimization level.\n-  BUILD_LIBFONTMANAGER_hb-subset.cc_OPTIMIZATION := SIZE\n-  BUILD_LIBFONTMANAGER_hb-subset-plan.cc_OPTIMIZATION := SIZE\n-endif\n-\n-ifeq ($(call isTargetOs, windows), true)\n-  LIBFONTMANAGER_EXCLUDE_FILES += X11FontScaler.c X11TextRenderer.c\n-  LIBFONTMANAGER_OPTIMIZATION := HIGHEST\n-else ifeq ($(call isTargetOs, macosx), true)\n-  LIBFONTMANAGER_EXCLUDE_FILES += X11FontScaler.c X11TextRenderer.c \\\n-      fontpath.c lcdglyph.c\n-else\n-  LIBFONTMANAGER_EXCLUDE_FILES += fontpath.c lcdglyph.c\n-endif\n-\n-LIBFONTMANAGER_CFLAGS += $(X_CFLAGS) -DLE_STANDALONE -DHEADLESS\n-\n-# LDFLAGS clarification:\n-#   Filter relevant linker flags disallowing unresolved symbols as we cannot\n-#   build-time decide to which library to link against (libawt_headless or\n-#   libawt_xawt). See JDK-8196516 for details.\n-$(eval $(call SetupJdkLibrary, BUILD_LIBFONTMANAGER, \\\n-    NAME := fontmanager, \\\n-    LINK_TYPE := C++, \\\n-    EXCLUDE_FILES := $(LIBFONTMANAGER_EXCLUDE_FILES) \\\n-        AccelGlyphCache.c, \\\n-    CFLAGS := $(LIBFONTMANAGER_CFLAGS), \\\n-    CXXFLAGS := $(LIBFONTMANAGER_CFLAGS), \\\n-    OPTIMIZATION := $(LIBFONTMANAGER_OPTIMIZATION), \\\n-    CFLAGS_windows = -DCC_NOEX, \\\n-    EXTRA_HEADER_DIRS := $(LIBFONTMANAGER_EXTRA_HEADER_DIRS), \\\n-    EXTRA_SRC := $(LIBFONTMANAGER_EXTRA_SRC), \\\n-    DISABLED_WARNINGS_gcc := $(HARFBUZZ_DISABLED_WARNINGS_gcc), \\\n-    DISABLED_WARNINGS_CXX_gcc := $(HARFBUZZ_DISABLED_WARNINGS_CXX_gcc), \\\n-    DISABLED_WARNINGS_clang := $(HARFBUZZ_DISABLED_WARNINGS_clang), \\\n-    DISABLED_WARNINGS_microsoft := $(HARFBUZZ_DISABLED_WARNINGS_microsoft), \\\n-    LDFLAGS := $(LDFLAGS_CXX_JDK), \\\n-    LDFLAGS_FILTER_OUT :=-Wl$(COMMA)-z$(COMMA)defs, \\\n-    LDFLAGS_unix := -L$(INSTALL_LIBRARIES_HERE), \\\n-    LDFLAGS_aix := -Wl$(COMMA)-berok, \\\n-    JDK_LIBS := $(LIBFONTMANAGER_JDK_LIBS), \\\n-    JDK_LIBS_unix := -lawt -ljava -ljvm, \\\n-    JDK_LIBS_macosx := -lawt_lwawt, \\\n-    JDK_LIBS_windows := $(WIN_AWT_LIB) $(WIN_JAVA_LIB), \\\n-    LIBS := $(LIBFONTMANAGER_LIBS), \\\n-    LIBS_unix := $(LIBM), \\\n-    LIBS_macosx := \\\n-        -framework CoreFoundation \\\n-        -framework CoreGraphics \\\n-        -framework CoreText, \\\n-    LIBS_windows := advapi32.lib gdi32.lib user32.lib, \\\n-))\n-\n-$(BUILD_LIBFONTMANAGER): $(BUILD_LIBAWT)\n-\n-ifeq ($(call isTargetOs, macosx), true)\n-  $(BUILD_LIBFONTMANAGER): $(call FindLib, $(MODULE), awt_lwawt)\n-endif\n-\n-ifeq ($(FREETYPE_TO_USE), bundled)\n-  $(BUILD_LIBFONTMANAGER): $(BUILD_LIBFREETYPE)\n-endif\n-\n-TARGETS += $(BUILD_LIBFONTMANAGER)\n-\n-################################################################################\n-## Build libjawt\n-################################################################################\n-\n-LIBJAWT_EXTRA_HEADER_DIRS := \\\n-    include \\\n-    #\n-\n-ifeq ($(call isTargetOs, windows), true)\n-  LIBJAWT_EXTRA_HEADER_DIRS += \\\n-      common\/awt\/debug \\\n-      common\/awt\/utility \\\n-      libawt\/awt\/image\/cvutils \\\n-      libawt\/java2d \\\n-      libawt\/java2d\/windows \\\n-      libawt\/windows \\\n-      java.base:libjava \\\n-      #\n-else\n-  LIBJAWT_EXTRA_HEADER_DIRS += \\\n-      common\/awt \\\n-      #\n-endif\n-\n-ifeq ($(call isTargetOs, macosx), true)\n-  # libjawt on macosx does not use the unix code\n-  LIBJAWT_EXCLUDE_SRC_PATTERNS := \/unix\/\n-endif\n-\n-ifeq ($(call isTargetOs, linux)+$(ENABLE_HEADLESS_ONLY), true+true)\n-  LIBJAWT_CFLAGS += -DHEADLESS\n-endif\n-\n-ifeq ($(call isTargetOs, windows)+$(call isTargetCpu, x86), true+true)\n-  LIBJAWT_LIBS_windows := kernel32.lib\n-endif\n-\n-ifeq ($(call isTargetOsType, unix)+$(call isTargetOs, macosx), true+false)\n-  LIBJAWT_JDK_LIBS_unix := -lawt\n-  ifeq ($(ENABLE_HEADLESS_ONLY), false)\n-    LIBJAWT_JDK_LIBS_unix += -lawt_xawt\n-  else\n-    LIBJAWT_JDK_LIBS_unix += -lawt_headless\n-  endif\n-endif\n-\n-$(eval $(call SetupJdkLibrary, BUILD_LIBJAWT, \\\n-    NAME := jawt, \\\n-    EXCLUDE_SRC_PATTERNS := $(LIBJAWT_EXCLUDE_SRC_PATTERNS), \\\n-    OPTIMIZATION := LOW, \\\n-    CFLAGS := $(LIBJAWT_CFLAGS), \\\n-    CFLAGS_windows := -EHsc -DUNICODE -D_UNICODE, \\\n-    CXXFLAGS_windows := -EHsc -DUNICODE -D_UNICODE, \\\n-    DISABLED_WARNINGS_clang_jawt.m := sign-compare, \\\n-    EXTRA_HEADER_DIRS := $(LIBJAWT_EXTRA_HEADER_DIRS), \\\n-    LDFLAGS_windows := $(LDFLAGS_CXX_JDK), \\\n-    LDFLAGS_unix := -L$(INSTALL_LIBRARIES_HERE), \\\n-    LDFLAGS_macosx := -Wl$(COMMA)-rpath$(COMMA)@loader_path, \\\n-    JDK_LIBS_unix := $(LIBJAWT_JDK_LIBS_unix) $(JDKLIB_LIBS), \\\n-    JDK_LIBS_macosx := -lawt_lwawt, \\\n-    JDK_LIBS_windows := $(WIN_AWT_LIB), \\\n-    LIBS_macosx := -framework Cocoa, \\\n-    LIBS_windows := advapi32.lib $(LIBJAWT_LIBS_windows), \\\n-))\n-\n-ifeq ($(call isTargetOs, windows), true)\n-  $(BUILD_LIBJAWT): $(BUILD_LIBAWT)\n-else ifeq ($(call isTargetOs, macosx), true)\n-   $(BUILD_LIBJAWT): $(call FindLib, $(MODULE), awt_lwawt)\n-else\n-  ifeq ($(ENABLE_HEADLESS_ONLY), false)\n-    $(BUILD_LIBJAWT): $(BUILD_LIBAWT_XAWT)\n-  else\n-    $(BUILD_LIBJAWT): $(call FindLib, $(MODULE), awt_headless)\n-  endif\n-endif\n-\n-TARGETS += $(BUILD_LIBJAWT)\n-\n-ifeq ($(call isTargetOs, windows), true)\n-  $(eval $(call SetupCopyFiles, COPY_JAWT_LIB, \\\n-      FILES := $(BUILD_LIBJAWT_IMPORT_LIBRARY), \\\n-      DEST := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n-  ))\n-\n-  $(COPY_JAWT_LIB): $(BUILD_LIBJAWT)\n-\n-  TARGETS += $(COPY_JAWT_LIB)\n-endif\n-\n-################################################################################\n-## Build libsplashscreen\n-################################################################################\n-\n-ifeq ($(ENABLE_HEADLESS_ONLY), false)\n-  LIBSPLASHSCREEN_EXTRA_SRC := \\\n-      common\/awt\/systemscale \\\n-      #\n-\n-  LIBSPLASHSCREEN_HEADER_DIRS := \\\n-      common\/awt\/utility \\\n-      libosxapp \\\n-      java.base:libjava \\\n-      #\n-\n-  ifeq ($(USE_EXTERNAL_LIBGIF), false)\n-    LIBSPLASHSCREEN_HEADER_DIRS += libsplashscreen\/giflib\n-  else\n-    LIBSPLASHSCREEN_EXCLUDES += giflib\n-  endif\n-\n-  ifeq ($(USE_EXTERNAL_LIBJPEG), false)\n-    LIBSPLASHSCREEN_EXTRA_SRC += libjavajpeg\n-  endif\n-\n-  ifeq ($(USE_EXTERNAL_LIBPNG), false)\n-    LIBSPLASHSCREEN_HEADER_DIRS += libsplashscreen\/libpng\n-  else\n-    LIBSPLASHSCREEN_EXCLUDES += libpng\n-  endif\n-\n-  ifeq ($(USE_EXTERNAL_LIBZ), false)\n-    LIBSPLASHSCREEN_EXTRA_SRC += java.base:libzip\/zlib\n-  endif\n-\n-  LIBSPLASHSCREEN_CFLAGS += -DSPLASHSCREEN -DPNG_NO_MMX_CODE \\\n-      -DPNG_ARM_NEON_OPT=0 -DPNG_ARM_NEON_IMPLEMENTATION=0\n-\n-  ifeq ($(call isTargetOs, linux)+$(call isTargetCpuArch, ppc), true+true)\n-    LIBSPLASHSCREEN_CFLAGS += -DPNG_POWERPC_VSX_OPT=0\n-  endif\n-\n-  # The external libpng submitted in the jdk is a reduced version\n-  # which does not contain .png_init_filter_functions_vsx.\n-  # Therefore we need to disable PNG_POWERPC_VSX_OPT explicitly by setting\n-  # it to 0. If this define is not set, it would be automatically set to 2,\n-  # because\n-  #   \"#if defined(__PPC64__) && defined(__ALTIVEC__) && defined(__VSX__)\"\n-  # expands to true. This would results in the fact that\n-  # .png_init_filter_functions_vsx is needed in libpng.\n-  ifeq ($(call isTargetOs, aix), true)\n-    LIBSPLASHSCREEN_CFLAGS += -DPNG_POWERPC_VSX_OPT=0\n-  endif\n-\n-  ifeq ($(call isTargetOs, macosx), true)\n-    # libsplashscreen on macosx does not use the unix code\n-    LIBSPLASHSCREEN_EXCLUDE_SRC_PATTERNS := \/unix\/\n-\n-    BUILD_LIBSPLASHSCREEN_java_awt_SplashScreen.c_CFLAGS := -x objective-c -O0\n-    BUILD_LIBSPLASHSCREEN_splashscreen_gfx_impl.c_CFLAGS := -x objective-c -O0\n-    BUILD_LIBSPLASHSCREEN_splashscreen_gif.c_CFLAGS := -x objective-c -O0\n-    BUILD_LIBSPLASHSCREEN_splashscreen_impl.c_CFLAGS := -x objective-c -O0\n-    BUILD_LIBSPLASHSCREEN_splashscreen_jpeg.c_CFLAGS := -x objective-c -O0\n-    BUILD_LIBSPLASHSCREEN_splashscreen_png.c_CFLAGS := -x objective-c -O0\n-    BUILD_LIBSPLASHSCREEN_splashscreen_sys.m_CFLAGS := -O0\n-  endif\n-\n-  ifeq ($(call isTargetOs, macosx), true)\n-    LIBSPLASHSCREEN_CFLAGS += -DWITH_MACOSX\n-  else ifeq ($(call isTargetOs, windows), true)\n-    LIBSPLASHSCREEN_CFLAGS += -DWITH_WIN32\n-  else\n-    LIBSPLASHSCREEN_CFLAGS += -DWITH_X11 $(X_CFLAGS)\n-  endif\n-\n-  $(eval $(call SetupJdkLibrary, BUILD_LIBSPLASHSCREEN, \\\n-      NAME := splashscreen, \\\n-      EXTRA_SRC := $(LIBSPLASHSCREEN_EXTRA_SRC), \\\n-      EXCLUDE_SRC_PATTERNS := $(LIBSPLASHSCREEN_EXCLUDE_SRC_PATTERNS), \\\n-      EXCLUDE_FILES := imageioJPEG.c jpegdecoder.c pngtest.c, \\\n-      EXCLUDES := $(LIBSPLASHSCREEN_EXCLUDES), \\\n-      OPTIMIZATION := LOW, \\\n-      CFLAGS := $(LIBSPLASHSCREEN_CFLAGS) \\\n-          $(GIFLIB_CFLAGS) $(LIBJPEG_CFLAGS) $(PNG_CFLAGS) $(LIBZ_CFLAGS), \\\n-      CXXFLAGS := $(LIBSPLASHSCREEN_CFLAGS) \\\n-          $(GIFLIB_CFLAGS) $(LIBJPEG_CFLAGS) $(PNG_CFLAGS) $(LIBZ_CFLAGS), \\\n-      EXTRA_HEADER_DIRS := $(LIBSPLASHSCREEN_HEADER_DIRS), \\\n-      DISABLED_WARNINGS_gcc_dgif_lib.c := sign-compare, \\\n-      DISABLED_WARNINGS_gcc_jcmaster.c := implicit-fallthrough, \\\n-      DISABLED_WARNINGS_gcc_jdphuff.c := shift-negative-value, \\\n-      DISABLED_WARNINGS_gcc_png.c := maybe-uninitialized, \\\n-      DISABLED_WARNINGS_gcc_pngerror.c := maybe-uninitialized, \\\n-      DISABLED_WARNINGS_gcc_splashscreen_gfx_impl.c := implicit-fallthrough \\\n-          maybe-uninitialized, \\\n-      DISABLED_WARNINGS_gcc_splashscreen_impl.c := implicit-fallthrough \\\n-          sign-compare unused-function, \\\n-      DISABLED_WARNINGS_gcc_splashscreen_sys.c := type-limits unused-result, \\\n-      DISABLED_WARNINGS_clang := deprecated-non-prototype, \\\n-      DISABLED_WARNINGS_clang_dgif_lib.c := sign-compare, \\\n-      DISABLED_WARNINGS_clang_gzwrite.c := format-nonliteral, \\\n-      DISABLED_WARNINGS_clang_splashscreen_impl.c := sign-compare, \\\n-      DISABLED_WARNINGS_clang_splashscreen_png.c := \\\n-          incompatible-pointer-types, \\\n-      DISABLED_WARNINGS_clang_splashscreen_sys.m := deprecated-declarations, \\\n-      DISABLED_WARNINGS_microsoft_dgif_lib.c := 4018 4267, \\\n-      DISABLED_WARNINGS_microsoft_splashscreen_impl.c := 4018 4267 4244, \\\n-      DISABLED_WARNINGS_microsoft_splashscreen_png.c := 4267, \\\n-      DISABLED_WARNINGS_microsoft_splashscreen_sys.c := 4267 4244, \\\n-      LDFLAGS_macosx := -L$(INSTALL_LIBRARIES_HERE), \\\n-      LDFLAGS_windows := -delayload:user32.dll, \\\n-      JDK_LIBS := $(JDKLIB_LIBS), \\\n-      JDK_LIBS_macosx := -losxapp, \\\n-      JDK_LIBS_windows := $(WIN_JAVA_LIB) jvm.lib, \\\n-      LIBS := $(GIFLIB_LIBS) $(LIBJPEG_LIBS) $(LIBZ_LIBS) $(PNG_LIBS), \\\n-      LIBS_unix := $(LIBM) -lpthread, \\\n-      LIBS_linux := $(LIBDL) $(X_LIBS) -lX11 -lXext, \\\n-      LIBS_macosx := -liconv \\\n-          -framework ApplicationServices \\\n-          -framework Cocoa \\\n-          -framework Foundation \\\n-          -framework Metal \\\n-          -framework Security, \\\n-      LIBS_aix := $(LIBDL) -liconv $(X_LIBS) -lX11 -lXext, \\\n-      LIBS_windows := delayimp.lib gdi32.lib kernel32.lib user32.lib, \\\n-  ))\n-\n-  TARGETS += $(BUILD_LIBSPLASHSCREEN)\n-\n-  ifeq ($(call isTargetOs, macosx), true)\n-    $(BUILD_LIBSPLASHSCREEN): $(call FindLib, $(MODULE), osxapp)\n-  endif\n-endif\n-\n-ifeq ($(call isTargetOs, macosx), true)\n-  ##############################################################################\n-  ## Build libawt_lwawt\n-  ##############################################################################\n-\n-  LIBAWT_LWAWT_EXTRA_SRC := \\\n-      $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/common\/awt \\\n-      $(TOPDIR)\/src\/$(MODULE)\/share\/native\/common\/font \\\n-      $(TOPDIR)\/src\/$(MODULE)\/share\/native\/common\/java2d \\\n-      #\n-\n-  LIBAWT_LWAWT_EXTRA_HEADER_DIRS := \\\n-      $(LIBAWT_DEFAULT_HEADER_DIRS) \\\n-      libawt_lwawt\/awt \\\n-      libawt_lwawt\/font \\\n-      libawt_lwawt\/java2d\/opengl \\\n-      libawt_lwawt\/java2d\/metal \\\n-      include \\\n-      common\/awt\/debug \\\n-      common\/java2d\/opengl \\\n-      libosxapp \\\n-      #\n-\n-  LIBAWT_LWAWT_EXCLUDE_FILES := fontpath.c awt_Font.c X11Color.c\n-  LIBAWT_LWAWT_EXCLUDES := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/common\/awt\/medialib\n-\n-  $(eval $(call SetupJdkLibrary, BUILD_LIBAWT_LWAWT, \\\n-      NAME := awt_lwawt, \\\n-      EXTRA_SRC := $(LIBAWT_LWAWT_EXTRA_SRC), \\\n-      EXCLUDE_FILES := $(LIBAWT_LWAWT_EXCLUDE_FILES), \\\n-      EXCLUDES := $(LIBAWT_LWAWT_EXCLUDES), \\\n-      OPTIMIZATION := LOW, \\\n-      EXTRA_HEADER_DIRS := $(LIBAWT_LWAWT_EXTRA_HEADER_DIRS), \\\n-      DISABLED_WARNINGS_clang := incomplete-implementation \\\n-          deprecated-declarations objc-method-access \\\n-          incompatible-pointer-types extra-tokens sign-compare undef, \\\n-      DISABLED_WARNINGS_clang_AWTWindow.m := bitwise-op-parentheses, \\\n-      DISABLED_WARNINGS_clang_CFileDialog.m := semicolon-before-method-body, \\\n-      DISABLED_WARNINGS_clang_CGGlyphImages.m := pointer-arith, \\\n-      DISABLED_WARNINGS_clang_CGLLayer.m := semicolon-before-method-body, \\\n-      DISABLED_WARNINGS_clang_ImageSurfaceData.m := enum-conversion \\\n-          parentheses-equality, \\\n-      DISABLED_WARNINGS_clang_MTLBlitLoops.m := pointer-arith, \\\n-      DISABLED_WARNINGS_clang_MTLPipelineStatesStorage.m := \\\n-          semicolon-before-method-body, \\\n-      DISABLED_WARNINGS_clang_MTLRenderer.m := gnu-folding-constant, \\\n-      DISABLED_WARNINGS_clang_MTLVertexCache.m := pointer-arith, \\\n-      DISABLED_WARNINGS_clang_OGLBufImgOps.c := format-nonliteral, \\\n-      DISABLED_WARNINGS_clang_OGLPaints.c := format-nonliteral, \\\n-      DISABLED_WARNINGS_clang_PrinterView.m := enum-conversion, \\\n-      LDFLAGS := -L$(INSTALL_LIBRARIES_HERE), \\\n-      JDK_LIBS_macosx := -lawt -ljava -ljvm -lmlib_image -losxapp, \\\n-      LIBS_macosx := $(LIBM) \\\n-          -framework Accelerate \\\n-          -framework ApplicationServices \\\n-          -framework AudioToolbox \\\n-          -framework Carbon \\\n-          -framework Cocoa \\\n-          -framework ExceptionHandling \\\n-          -framework JavaRuntimeSupport \\\n-          -framework Metal \\\n-          -framework OpenGL \\\n-          -framework QuartzCore \\\n-          -framework Security, \\\n-  ))\n-\n-  TARGETS += $(BUILD_LIBAWT_LWAWT)\n-\n-  $(BUILD_LIBAWT_LWAWT): $(BUILD_LIBAWT)\n-\n-  $(BUILD_LIBAWT_LWAWT): $(BUILD_LIBMLIB_IMAGE)\n-\n-  $(BUILD_LIBAWT_LWAWT): $(call FindLib, $(MODULE), osxapp)\n-\n-  $(BUILD_LIBAWT_LWAWT): $(call FindLib, java.base, java)\n-\n-  ##############################################################################\n-  ## Build libosxui\n-  ##############################################################################\n-\n-  SHADERS_SRC := \\\n-      $(TOPDIR)\/src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/shaders.metal\n-  SHADERS_SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/java.desktop\/libosxui\n-  SHADERS_AIR := $(SHADERS_SUPPORT_DIR)\/shaders.air\n-  SHADERS_LIB := $(INSTALL_LIBRARIES_HERE)\/shaders.metallib\n-\n-  $(eval $(call SetupExecute, metal_shaders, \\\n-      INFO := Running metal on $(notdir $(SHADERS_SRC)) (for libosxui.dylib), \\\n-      DEPS := $(SHADERS_SRC), \\\n-      OUTPUT_FILE := $(SHADERS_AIR), \\\n-      SUPPORT_DIR := $(SHADERS_SUPPORT_DIR), \\\n-      COMMAND := $(METAL) -c -std=osx-metal2.0 \\\n-          -mmacosx-version-min=$(MACOSX_VERSION_MIN) \\\n-          -o $(SHADERS_AIR) $(SHADERS_SRC), \\\n-  ))\n-\n-  $(eval $(call SetupExecute, metallib_shaders, \\\n-      INFO := Running metallib on $(notdir $(SHADERS_AIR)) (for libosxui.dylib), \\\n-      DEPS := $(SHADERS_AIR), \\\n-      OUTPUT_FILE := $(SHADERS_LIB), \\\n-      SUPPORT_DIR := $(SHADERS_SUPPORT_DIR), \\\n-      COMMAND := $(METALLIB) -o $(SHADERS_LIB) $(SHADERS_AIR), \\\n-  ))\n-\n-  TARGETS += $(SHADERS_LIB)\n-\n-  $(eval $(call SetupJdkLibrary, BUILD_LIBOSXUI, \\\n-      NAME := osxui, \\\n-      OPTIMIZATION := LOW, \\\n-      EXTRA_HEADER_DIRS := \\\n-          libawt_lwawt\/awt \\\n-          libosxapp, \\\n-      DISABLED_WARNINGS_clang_AquaFileView.m := deprecated-declarations \\\n-          sign-compare, \\\n-      DISABLED_WARNINGS_clang_ScreenMenu.m := deprecated-declarations, \\\n-      APPEND_LDFLAGS := -Wl$(COMMA)-rpath$(COMMA)@loader_path, \\\n-      LDFLAGS := -L$(INSTALL_LIBRARIES_HERE), \\\n-      JDK_LIBS_macosx := -lawt -lawt_lwawt -ljava -ljvm -losxapp, \\\n-      LIBS_macosx := \\\n-          -framework ApplicationServices \\\n-          -framework Carbon \\\n-          -framework Cocoa \\\n-          -framework JavaRuntimeSupport \\\n-          -framework Metal, \\\n-  ))\n-\n-  TARGETS += $(BUILD_LIBOSXUI)\n-\n-  $(BUILD_LIBOSXUI): $(SHADERS_LIB)\n-\n-  $(BUILD_LIBOSXUI): $(BUILD_LIBAWT)\n-\n-  $(BUILD_LIBOSXUI): $(call FindLib, $(MODULE), osxapp)\n-\n-  $(BUILD_LIBOSXUI): $(BUILD_LIBAWT_LWAWT)\n-endif\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":0,"deletions":921,"binary":false,"changes":921,"status":"deleted"},{"patch":"@@ -0,0 +1,426 @@\n+#\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include CopyFiles.gmk\n+\n+################################################################################\n+# This file will build all AWT\/2D native libraries with \"awt\" in the name.\n+# Note that this does not imply that the code they bring in belong to AWT.\n+# This split is purely made to keep the size of the Makefiles reasonable.\n+\n+LIBAWT_DEFAULT_HEADER_DIRS := \\\n+    common\/awt\/utility \\\n+    libawt\/awt\/image \\\n+    libawt\/awt\/image\/cvutils \\\n+    libawt\/java2d \\\n+    libawt\/java2d\/loops \\\n+    libawt\/java2d\/pipe \\\n+    #\n+\n+################################################################################\n+## Build libawt\n+################################################################################\n+\n+LIBAWT_EXTRA_SRC := \\\n+    common\/awt\/debug \\\n+    $(TOPDIR)\/src\/$(MODULE)\/$(OPENJDK_TARGET_OS_TYPE)\/native\/common\/awt \\\n+    #\n+\n+ifeq ($(call isTargetOs, windows), true)\n+  LIBAWT_EXTRA_SRC += \\\n+      $(TOPDIR)\/src\/$(MODULE)\/share\/native\/common\/awt\/utility \\\n+      $(TOPDIR)\/src\/$(MODULE)\/share\/native\/common\/font \\\n+      $(TOPDIR)\/src\/$(MODULE)\/share\/native\/common\/java2d\/opengl \\\n+      $(TOPDIR)\/src\/$(MODULE)\/$(OPENJDK_TARGET_OS_TYPE)\/native\/common\/awt\/systemscale \\\n+      #\n+endif\n+\n+ifeq ($(call isTargetOs, linux macosx aix), true)\n+  LIBAWT_EXCLUDE_FILES += awt_Font.c CUPSfuncs.c fontpath.c X11Color.c\n+endif\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  LIBAWT_EXCLUDE_FILES += initIDs.c img_colors.c\n+endif\n+\n+ifeq ($(call isTargetOs, windows), true)\n+  LIBAWT_EXCLUDE_FILES += D3DShaderGen.c img_colors.c\n+endif\n+\n+LIBAWT_EXTRA_HEADER_DIRS := \\\n+    $(LIBAWT_DEFAULT_HEADER_DIRS) \\\n+    $(call GetJavaHeaderDir, java.base) \\\n+    libawt\/awt\/medialib \\\n+    libawt\/java2d\/d3d \\\n+    libawt\/java2d\/opengl \\\n+    libawt\/java2d\/windows \\\n+    libawt\/windows \\\n+    common\/awt\/medialib \\\n+    libmlib_image \\\n+    include \\\n+    #\n+\n+LIBAWT_CFLAGS := -D__MEDIALIB_OLD_NAMES -D__USE_J2D_NAMES -DMLIB_NO_LIBSUNMATH\n+\n+ifeq ($(call isTargetOs, windows), true)\n+  LIBAWT_CFLAGS += -EHsc -DUNICODE -D_UNICODE\n+  ifeq ($(call isTargetCpuBits, 64), true)\n+    LIBAWT_CFLAGS += -DMLIB_OS64BIT\n+  endif\n+\n+  LIBAWT_RCFLAGS ?= -I$(TOPDIR)\/src\/java.base\/windows\/native\/launcher\/icons\n+  LIBAWT_VERSIONINFO_RESOURCE := \\\n+      $(TOPDIR)\/src\/$(MODULE)\/windows\/native\/libawt\/windows\/awt.rc\n+endif\n+\n+# -fgcse-after-reload improves performance of MaskFill in Java2D by 20% for\n+# some gcc\n+$(eval $(call SetupJdkLibrary, BUILD_LIBAWT, \\\n+    NAME := awt, \\\n+    EXTRA_SRC := $(LIBAWT_EXTRA_SRC), \\\n+    EXCLUDE_FILES := $(LIBAWT_EXCLUDE_FILES), \\\n+    OPTIMIZATION := HIGHEST, \\\n+    CFLAGS := $(LIBAWT_CFLAGS) $(X_CFLAGS), \\\n+    CXXFLAGS := $(LIBAWT_CFLAGS) $(X_CFLAGS), \\\n+    CFLAGS_gcc := -fgcse-after-reload, \\\n+    EXTRA_HEADER_DIRS := $(LIBAWT_EXTRA_HEADER_DIRS), \\\n+    DISABLED_WARNINGS_gcc_awt_LoadLibrary.c := unused-result, \\\n+    DISABLED_WARNINGS_gcc_debug_mem.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_gcc_ProcessPath.c := maybe-uninitialized, \\\n+    DISABLED_WARNINGS_gcc_Region.c := maybe-uninitialized, \\\n+    DISABLED_WARNINGS_gcc_SurfaceData.c := unused-value, \\\n+    DISABLED_WARNINGS_gcc_TransformHelper.c := sign-compare, \\\n+    DISABLED_WARNINGS_clang_awt_ImagingLib.c := deprecated-non-prototype, \\\n+    DISABLED_WARNINGS_clang_debug_trace.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_clang_Trace.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_clang_TransformHelper.c := sign-compare, \\\n+    DISABLED_WARNINGS_microsoft := 4244 4996, \\\n+    DISABLED_WARNINGS_microsoft_awt_Toolkit.cpp := 4267, \\\n+    LDFLAGS_windows := -delayload:comctl32.dll -delayload:comdlg32.dll \\\n+        -delayload:gdi32.dll -delayload:imm32.dll -delayload:ole32.dll \\\n+        -delayload:shell32.dll -delayload:shlwapi.dll -delayload:user32.dll \\\n+        -delayload:winmm.dll -delayload:winspool.drv, \\\n+    JDK_LIBS := java.base:libjava java.base:libjvm, \\\n+    LIBS_unix := $(LIBM), \\\n+    LIBS_linux := $(LIBDL), \\\n+    LIBS_aix := $(LIBDL),\\\n+    LIBS_macosx := \\\n+        -framework ApplicationServices \\\n+        -framework AudioToolbox \\\n+        -framework Cocoa \\\n+        -framework JavaRuntimeSupport \\\n+        -framework Metal \\\n+        -framework OpenGL, \\\n+    LIBS_windows := advapi32.lib comctl32.lib comdlg32.lib delayimp.lib \\\n+        gdi32.lib imm32.lib kernel32.lib ole32.lib shell32.lib shlwapi.lib \\\n+        user32.lib uuid.lib winmm.lib winspool.lib, \\\n+    VERSIONINFO_RESOURCE := $(LIBAWT_VERSIONINFO_RESOURCE), \\\n+    EXTRA_RCFLAGS := $(LIBAWT_RCFLAGS), \\\n+))\n+\n+TARGETS += $(BUILD_LIBAWT)\n+\n+# Mac and Windows only use the native AWT lib, do not build libawt_headless\n+ifeq ($(call isTargetOs, windows macosx), false)\n+  ##############################################################################\n+  ## Build libawt_headless\n+  ##############################################################################\n+\n+  LIBAWT_HEADLESS_EXTRA_SRC := \\\n+      common\/font \\\n+      common\/java2d \\\n+      $(TOPDIR)\/src\/$(MODULE)\/$(OPENJDK_TARGET_OS_TYPE)\/native\/common\/awt \\\n+      #\n+\n+  LIBAWT_HEADLESS_EXTRA_HEADER_DIRS := \\\n+      $(LIBAWT_DEFAULT_HEADER_DIRS) \\\n+      common\/awt\/debug \\\n+      common\/font \\\n+      common\/java2d\/opengl \\\n+      java.base:libjvm \\\n+      #\n+\n+  # These are the object files provided by the awt native\n+  # library. Do not include these external (non-awt_headless library)\n+  # objects in the static library. When statically linking the java\n+  # launcher with all JDK and VM static libraries, we use the\n+  # --whole-archive linker option. The duplicate objects in different\n+  # static libraries cause linking errors due to duplicate symbols.\n+  LIBAWT_HEADLESS_STATIC_EXCLUDE_OBJS := systemScale.o\n+\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBAWT_HEADLESS, \\\n+      NAME := awt_headless, \\\n+      EXTRA_SRC := $(LIBAWT_HEADLESS_EXTRA_SRC), \\\n+      EXCLUDES := medialib, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := -DHEADLESS=true $(CUPS_CFLAGS) $(FONTCONFIG_CFLAGS) \\\n+          $(X_CFLAGS), \\\n+      EXTRA_HEADER_DIRS := $(LIBAWT_HEADLESS_EXTRA_HEADER_DIRS), \\\n+      DISABLED_WARNINGS_gcc_X11Renderer.c := unused-function, \\\n+      DISABLED_WARNINGS_gcc_X11SurfaceData.c := unused-function, \\\n+      JDK_LIBS := libawt java.base:libjava, \\\n+      LIBS_linux := $(LIBDL) $(LIBM), \\\n+      STATIC_LIB_EXCLUDE_OBJS := $(LIBAWT_HEADLESS_STATIC_EXCLUDE_OBJS), \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBAWT_HEADLESS)\n+endif\n+\n+ifeq ($(call isTargetOs, windows macosx)+$(ENABLE_HEADLESS_ONLY), false+false)\n+  ##############################################################################\n+  ## Build libawt_xawt\n+  ##############################################################################\n+\n+  LIBAWT_XAWT_EXTRA_SRC := \\\n+      common\/awt \\\n+      common\/java2d \\\n+      common\/font \\\n+      #\n+\n+  LIBAWT_XAWT_EXTRA_HEADER_DIRS := \\\n+      $(LIBAWT_DEFAULT_HEADER_DIRS) \\\n+      libawt_xawt\/awt \\\n+      include \\\n+      common\/awt\/debug \\\n+      common\/awt\/systemscale \\\n+      common\/font \\\n+      common\/java2d\/opengl \\\n+      common\/java2d\/x11 \\\n+      libpipewire\/include \\\n+      java.base:libjvm \\\n+      #\n+\n+  ifeq ($(call isTargetOs, linux), true)\n+    ifeq ($(DISABLE_XRENDER), true)\n+      LIBAWT_XAWT_CFLAGS += -DDISABLE_XRENDER_BY_DEFAULT=true\n+    endif\n+  endif\n+\n+  # These are the object files provided by the awt native\n+  # library. Do not include these external (non-awt_xawt library)\n+  # objects in the static library. When statically linking the java\n+  # launcher with all JDK and VM static libraries, we use the\n+  # --whole-archive linker option. The duplicate objects in different\n+  # static libraries cause linking errors due to duplicate symbols.\n+  LIBAWT_XAWT_STATIC_EXCLUDE_OBJS := systemScale.o\n+\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBAWT_XAWT, \\\n+      NAME := awt_xawt, \\\n+      EXTRA_SRC := $(LIBAWT_XAWT_EXTRA_SRC), \\\n+      EXTRA_HEADER_DIRS := $(LIBAWT_XAWT_EXTRA_HEADER_DIRS), \\\n+      EXCLUDES := medialib debug, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := -DXAWT -DXAWT_HACK $(LIBAWT_XAWT_CFLAGS) \\\n+          $(FONTCONFIG_CFLAGS) $(CUPS_CFLAGS) $(X_CFLAGS), \\\n+      DISABLED_WARNINGS_gcc := int-to-pointer-cast, \\\n+      DISABLED_WARNINGS_gcc_awt_Taskbar.c := parentheses, \\\n+      DISABLED_WARNINGS_gcc_GLXSurfaceData.c := unused-function, \\\n+      DISABLED_WARNINGS_gcc_gtk2_interface.c := parentheses type-limits, \\\n+      DISABLED_WARNINGS_gcc_gtk3_interface.c := parentheses type-limits \\\n+          unused-function, \\\n+      DISABLED_WARNINGS_gcc_OGLBufImgOps.c := format-nonliteral, \\\n+      DISABLED_WARNINGS_gcc_OGLPaints.c := format-nonliteral, \\\n+      DISABLED_WARNINGS_gcc_screencast_pipewire.c := undef, \\\n+      DISABLED_WARNINGS_gcc_screencast_portal.c := undef, \\\n+      DISABLED_WARNINGS_gcc_sun_awt_X11_GtkFileDialogPeer.c := parentheses, \\\n+      DISABLED_WARNINGS_gcc_X11SurfaceData.c := implicit-fallthrough \\\n+          pointer-to-int-cast, \\\n+      DISABLED_WARNINGS_gcc_XlibWrapper.c := type-limits pointer-to-int-cast, \\\n+      DISABLED_WARNINGS_gcc_XRBackendNative.c := maybe-uninitialized, \\\n+      DISABLED_WARNINGS_gcc_XToolkit.c := unused-result, \\\n+      DISABLED_WARNINGS_gcc_XWindow.c := unused-function, \\\n+      DISABLED_WARNINGS_clang_awt_Taskbar.c := parentheses, \\\n+      DISABLED_WARNINGS_clang_gtk2_interface.c := parentheses, \\\n+      DISABLED_WARNINGS_clang_gtk3_interface.c := parentheses, \\\n+      DISABLED_WARNINGS_clang_OGLBufImgOps.c := format-nonliteral, \\\n+      DISABLED_WARNINGS_clang_OGLPaints.c := format-nonliteral, \\\n+      DISABLED_WARNINGS_clang_screencast_pipewire.c := format-nonliteral, \\\n+      DISABLED_WARNINGS_clang_sun_awt_X11_GtkFileDialogPeer.c := parentheses, \\\n+      DISABLED_WARNINGS_clang_aix := deprecated-non-prototype, \\\n+      DISABLED_WARNINGS_clang_aix_awt_Taskbar.c := parentheses, \\\n+      DISABLED_WARNINGS_clang_aix_OGLPaints.c := format-nonliteral, \\\n+      DISABLED_WARNINGS_clang_aix_OGLBufImgOps.c := format-nonliteral, \\\n+      DISABLED_WARNINGS_clang_aix_gtk2_interface.c := parentheses \\\n+          logical-op-parentheses, \\\n+      DISABLED_WARNINGS_clang_aix_gtk3_interface.c := parentheses \\\n+          logical-op-parentheses, \\\n+      DISABLED_WARNINGS_clang_aix_sun_awt_X11_GtkFileDialogPeer.c := \\\n+          parentheses, \\\n+      DISABLED_WARNINGS_clang_aix_awt_InputMethod.c := sign-compare, \\\n+      JDK_LIBS := libawt java.base:libjava, \\\n+      LIBS_unix := $(LIBDL) $(LIBM) $(X_LIBS) -lX11 -lXext -lXi -lXrender \\\n+          -lXtst, \\\n+      LIBS_linux := -lpthread, \\\n+      STATIC_LIB_EXCLUDE_OBJS := $(LIBAWT_XAWT_STATIC_EXCLUDE_OBJS), \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBAWT_XAWT)\n+endif\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  ##############################################################################\n+  ## Build libawt_lwawt\n+  ##############################################################################\n+\n+  LIBAWT_LWAWT_EXTRA_SRC := \\\n+      $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/common\/awt \\\n+      $(TOPDIR)\/src\/$(MODULE)\/share\/native\/common\/font \\\n+      $(TOPDIR)\/src\/$(MODULE)\/share\/native\/common\/java2d \\\n+      #\n+\n+  LIBAWT_LWAWT_EXTRA_HEADER_DIRS := \\\n+      $(LIBAWT_DEFAULT_HEADER_DIRS) \\\n+      libawt_lwawt\/awt \\\n+      libawt_lwawt\/font \\\n+      libawt_lwawt\/java2d\/opengl \\\n+      libawt_lwawt\/java2d\/metal \\\n+      include \\\n+      common\/awt\/debug \\\n+      common\/java2d\/opengl \\\n+      java.base:libjvm \\\n+      #\n+\n+  LIBAWT_LWAWT_EXCLUDE_FILES := fontpath.c awt_Font.c X11Color.c\n+  LIBAWT_LWAWT_EXCLUDES := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/common\/awt\/medialib\n+\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBAWT_LWAWT, \\\n+      NAME := awt_lwawt, \\\n+      EXTRA_SRC := $(LIBAWT_LWAWT_EXTRA_SRC), \\\n+      EXCLUDE_FILES := $(LIBAWT_LWAWT_EXCLUDE_FILES), \\\n+      EXCLUDES := $(LIBAWT_LWAWT_EXCLUDES), \\\n+      OPTIMIZATION := LOW, \\\n+      EXTRA_HEADER_DIRS := $(LIBAWT_LWAWT_EXTRA_HEADER_DIRS), \\\n+      DISABLED_WARNINGS_clang := incomplete-implementation \\\n+          deprecated-declarations objc-method-access \\\n+          incompatible-pointer-types extra-tokens sign-compare undef, \\\n+      DISABLED_WARNINGS_clang_AWTWindow.m := bitwise-op-parentheses, \\\n+      DISABLED_WARNINGS_clang_CFileDialog.m := semicolon-before-method-body, \\\n+      DISABLED_WARNINGS_clang_CGGlyphImages.m := pointer-arith, \\\n+      DISABLED_WARNINGS_clang_CGLLayer.m := semicolon-before-method-body, \\\n+      DISABLED_WARNINGS_clang_ImageSurfaceData.m := enum-conversion \\\n+          parentheses-equality, \\\n+      DISABLED_WARNINGS_clang_MTLBlitLoops.m := pointer-arith, \\\n+      DISABLED_WARNINGS_clang_MTLPipelineStatesStorage.m := \\\n+          semicolon-before-method-body, \\\n+      DISABLED_WARNINGS_clang_MTLRenderer.m := gnu-folding-constant, \\\n+      DISABLED_WARNINGS_clang_MTLVertexCache.m := pointer-arith, \\\n+      DISABLED_WARNINGS_clang_OGLBufImgOps.c := format-nonliteral, \\\n+      DISABLED_WARNINGS_clang_OGLPaints.c := format-nonliteral, \\\n+      DISABLED_WARNINGS_clang_PrinterView.m := enum-conversion, \\\n+      JDK_LIBS := libawt java.base:libjava libosxapp, \\\n+      LIBS_macosx := $(LIBM) \\\n+          -framework Accelerate \\\n+          -framework ApplicationServices \\\n+          -framework AudioToolbox \\\n+          -framework Carbon \\\n+          -framework Cocoa \\\n+          -framework ExceptionHandling \\\n+          -framework JavaRuntimeSupport \\\n+          -framework Metal \\\n+          -framework OpenGL \\\n+          -framework QuartzCore \\\n+          -framework Security, \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBAWT_LWAWT)\n+endif\n+\n+################################################################################\n+## Build libjawt\n+################################################################################\n+\n+LIBJAWT_EXTRA_HEADER_DIRS := \\\n+    include \\\n+    java.base:libjava \\\n+    #\n+\n+ifeq ($(call isTargetOs, windows), true)\n+  LIBJAWT_EXTRA_HEADER_DIRS += \\\n+      common\/awt\/debug \\\n+      common\/awt\/utility \\\n+      libawt\/awt\/image\/cvutils \\\n+      libawt\/java2d \\\n+      libawt\/java2d\/windows \\\n+      libawt\/windows \\\n+      java.base:libjvm \\\n+      #\n+else\n+  LIBJAWT_EXTRA_HEADER_DIRS += \\\n+      common\/awt \\\n+      #\n+endif\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  # libjawt on macosx does not use the unix code\n+  LIBJAWT_EXCLUDE_SRC_PATTERNS := \/unix\/\n+endif\n+\n+ifeq ($(call isTargetOs, linux)+$(ENABLE_HEADLESS_ONLY), true+true)\n+  LIBJAWT_CFLAGS += -DHEADLESS\n+endif\n+\n+ifeq ($(call isTargetOs, windows)+$(call isTargetCpu, x86), true+true)\n+  LIBJAWT_LIBS_windows := kernel32.lib\n+endif\n+\n+ifeq ($(call isTargetOsType, unix)+$(call isTargetOs, macosx), true+false)\n+  LIBJAWT_JDK_LIBS_unix := libawt\n+  ifeq ($(ENABLE_HEADLESS_ONLY), false)\n+    LIBJAWT_JDK_LIBS_unix += libawt_xawt\n+  else\n+    LIBJAWT_JDK_LIBS_unix += libawt_headless\n+  endif\n+endif\n+\n+$(eval $(call SetupJdkLibrary, BUILD_LIBJAWT, \\\n+    NAME := jawt, \\\n+    EXCLUDE_SRC_PATTERNS := $(LIBJAWT_EXCLUDE_SRC_PATTERNS), \\\n+    OPTIMIZATION := LOW, \\\n+    CFLAGS := $(LIBJAWT_CFLAGS), \\\n+    CFLAGS_windows := -EHsc -DUNICODE -D_UNICODE, \\\n+    CXXFLAGS_windows := -EHsc -DUNICODE -D_UNICODE, \\\n+    DISABLED_WARNINGS_clang_jawt.m := sign-compare, \\\n+    EXTRA_HEADER_DIRS := $(LIBJAWT_EXTRA_HEADER_DIRS), \\\n+    LDFLAGS_windows := $(LDFLAGS_CXX_JDK), \\\n+    LDFLAGS_macosx := -Wl$(COMMA)-rpath$(COMMA)@loader_path, \\\n+    JDK_LIBS_unix := $(LIBJAWT_JDK_LIBS_unix), \\\n+    JDK_LIBS_windows := libawt, \\\n+    JDK_LIBS_macosx := libawt_lwawt, \\\n+    LIBS_macosx := -framework Cocoa, \\\n+    LIBS_windows := advapi32.lib $(LIBJAWT_LIBS_windows), \\\n+))\n+\n+TARGETS += $(BUILD_LIBJAWT)\n+\n+ifeq ($(call isTargetOs, windows), true)\n+  $(eval $(call SetupCopyFiles, COPY_JAWT_LIB, \\\n+      FILES := $(BUILD_LIBJAWT_IMPORT_LIBRARY), \\\n+      DEST := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+\n+  $(COPY_JAWT_LIB): $(BUILD_LIBJAWT)\n+\n+  TARGETS += $(COPY_JAWT_LIB)\n+endif\n","filename":"make\/modules\/java.desktop\/lib\/AwtLibraries.gmk","additions":426,"deletions":0,"binary":false,"changes":426,"status":"added"},{"patch":"@@ -0,0 +1,453 @@\n+#\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+# This file will build all AWT\/2D native libraries that does not have \"awt\" in\n+# the name. Note that this does not imply anything about the logical ownership\n+# of the code they compile.\n+# This split is purely made to keep the size of the Makefiles reasonable.\n+\n+################################################################################\n+## Build libmlib_image\n+################################################################################\n+\n+ifeq ($(call isTargetCpuBits, 64), true)\n+  LIBMLIB_IMAGE_CFLAGS := -DMLIB_OS64BIT\n+endif\n+\n+$(eval $(call SetupJdkLibrary, BUILD_LIBMLIB_IMAGE, \\\n+    NAME := mlib_image, \\\n+    EXTRA_SRC := common\/awt\/medialib, \\\n+    EXTRA_HEADER_DIRS := java.base:libjava, \\\n+    EXCLUDE_FILES := mlib_c_ImageBlendTable.c, \\\n+    OPTIMIZATION := HIGHEST, \\\n+    CFLAGS := -D__USE_J2D_NAMES -D__MEDIALIB_OLD_NAMES -DMLIB_NO_LIBSUNMATH \\\n+        $(LIBMLIB_IMAGE_CFLAGS), \\\n+    DISABLED_WARNINGS_gcc := unused-function, \\\n+    LIBS_unix := $(LIBDL) $(LIBM), \\\n+))\n+\n+TARGETS += $(BUILD_LIBMLIB_IMAGE)\n+\n+################################################################################\n+## Build liblcms\n+################################################################################\n+\n+ifeq ($(USE_EXTERNAL_LCMS), true)\n+  # If we're using an external library, we'll just need the wrapper part.\n+  # By including it explicitly, all other files will be excluded.\n+  LIBLCMS_INCLUDE_FILES := LCMS.c\n+  # If we're using an external library, we can't include our own SRC path\n+  # as includes, instead the system headers should be used.\n+  LIBLCMS_HEADERS_FROM_SRC := false\n+  # FIXME: Keep old behavior and reset LCMS_CFLAGS. This is likely a bug.\n+  LCMS_CFLAGS :=\n+endif\n+\n+ifeq ($(TOOLCHAIN_TYPE)+$(TOOLCHAIN_VERSION), clang+10.1)\n+  # Work around an optimizer bug seen with Xcode 10.1, but fixed by 10.3\n+  BUILD_LIBLCMS_cmsopt.c_CFLAGS := -O0\n+endif\n+\n+# We use CMS_DONT_USE_FAST_FLOOR and CMS_NO_HALF_SUPPORT since the fast floor\n+# code loses precision.\n+$(eval $(call SetupJdkLibrary, BUILD_LIBLCMS, \\\n+    NAME := lcms, \\\n+    INCLUDE_FILES := $(LIBLCMS_INCLUDE_FILES), \\\n+    OPTIMIZATION := HIGHEST, \\\n+    CFLAGS := -DCMS_DONT_USE_FAST_FLOOR -DCMS_NO_HALF_SUPPORT $(LCMS_CFLAGS), \\\n+    CFLAGS_windows := -DCMS_IS_WINDOWS_, \\\n+    EXTRA_HEADER_DIRS := \\\n+        common\/awt\/debug \\\n+        libawt\/java2d \\\n+        java.base:libjvm, \\\n+    HEADERS_FROM_SRC := $(LIBLCMS_HEADERS_FROM_SRC), \\\n+    DISABLED_WARNINGS_gcc := format-nonliteral type-limits \\\n+        stringop-truncation, \\\n+    DISABLED_WARNINGS_clang := format-nonliteral, \\\n+    JDK_LIBS := libawt java.base:libjava, \\\n+    LIBS_unix := $(LCMS_LIBS) $(LIBM), \\\n+))\n+\n+TARGETS += $(BUILD_LIBLCMS)\n+\n+################################################################################\n+## Build libjavajpeg\n+################################################################################\n+\n+ifeq ($(USE_EXTERNAL_LIBJPEG), true)\n+  LIBJAVAJPEG_INCLUDE_FILES := \\\n+      imageioJPEG.c \\\n+      jpegdecoder.c\n+  # If we're using an external library, we can't include our own SRC path\n+  # as includes, instead the system headers should be used.\n+  LIBJAVAJPEG_HEADERS_FROM_SRC := false\n+endif\n+\n+# \"DISABLED_WARNINGS_gcc := clobbered\" rationale:\n+# Suppress gcc warnings like \"variable might be clobbered by 'longjmp'\n+# or 'vfork'\": this warning indicates that some variable is placed to\n+# a register by optimized compiler and it's value might be lost on longjmp().\n+# Recommended way to avoid such warning is to declare the variable as\n+# volatile to prevent the optimization. However, this approach does not\n+# work because we have to declare all variables as volatile in result.\n+$(eval $(call SetupJdkLibrary, BUILD_LIBJAVAJPEG, \\\n+    NAME := javajpeg, \\\n+    INCLUDE_FILES := $(LIBJAVAJPEG_INCLUDE_FILES), \\\n+    OPTIMIZATION := HIGHEST, \\\n+    HEADERS_FROM_SRC := $(LIBJAVAJPEG_HEADERS_FROM_SRC), \\\n+    DISABLED_WARNINGS_gcc_imageioJPEG.c := clobbered array-bounds, \\\n+    DISABLED_WARNINGS_gcc_jcmaster.c := implicit-fallthrough, \\\n+    DISABLED_WARNINGS_gcc_jdphuff.c := shift-negative-value, \\\n+    JDK_LIBS := java.base:libjava, \\\n+    LIBS := $(LIBJPEG_LIBS), \\\n+))\n+\n+TARGETS += $(BUILD_LIBJAVAJPEG)\n+\n+################################################################################\n+## Build libsplashscreen\n+################################################################################\n+\n+ifeq ($(ENABLE_HEADLESS_ONLY), false)\n+  LIBSPLASHSCREEN_EXTRA_SRC := \\\n+      common\/awt\/systemscale \\\n+      #\n+\n+  LIBSPLASHSCREEN_HEADER_DIRS := \\\n+      common\/awt\/utility \\\n+      libosxapp \\\n+      java.base:libjava \\\n+      java.base:libjvm \\\n+      #\n+\n+  ifeq ($(USE_EXTERNAL_LIBGIF), false)\n+    LIBSPLASHSCREEN_HEADER_DIRS += libsplashscreen\/giflib\n+  else\n+    LIBSPLASHSCREEN_EXCLUDES += giflib\n+  endif\n+\n+  ifeq ($(USE_EXTERNAL_LIBJPEG), false)\n+    LIBSPLASHSCREEN_EXTRA_SRC += libjavajpeg\n+  endif\n+\n+  ifeq ($(USE_EXTERNAL_LIBPNG), false)\n+    LIBSPLASHSCREEN_HEADER_DIRS += libsplashscreen\/libpng\n+  else\n+    LIBSPLASHSCREEN_EXCLUDES += libpng\n+  endif\n+\n+  ifeq ($(USE_EXTERNAL_LIBZ), false)\n+    LIBSPLASHSCREEN_EXTRA_SRC += java.base:libzip\/zlib\n+  endif\n+\n+  LIBSPLASHSCREEN_CFLAGS += -DSPLASHSCREEN -DPNG_NO_MMX_CODE \\\n+      -DPNG_ARM_NEON_OPT=0 -DPNG_ARM_NEON_IMPLEMENTATION=0\n+\n+  ifeq ($(call isTargetOs, linux)+$(call isTargetCpuArch, ppc), true+true)\n+    LIBSPLASHSCREEN_CFLAGS += -DPNG_POWERPC_VSX_OPT=0\n+  endif\n+\n+  # The external libpng submitted in the jdk is a reduced version\n+  # which does not contain .png_init_filter_functions_vsx.\n+  # Therefore we need to disable PNG_POWERPC_VSX_OPT explicitly by setting\n+  # it to 0. If this define is not set, it would be automatically set to 2,\n+  # because\n+  #   \"#if defined(__PPC64__) && defined(__ALTIVEC__) && defined(__VSX__)\"\n+  # expands to true. This would results in the fact that\n+  # .png_init_filter_functions_vsx is needed in libpng.\n+  ifeq ($(call isTargetOs, aix), true)\n+    LIBSPLASHSCREEN_CFLAGS += -DPNG_POWERPC_VSX_OPT=0\n+  endif\n+\n+  ifeq ($(call isTargetOs, macosx), true)\n+    # libsplashscreen on macosx does not use the unix code\n+    LIBSPLASHSCREEN_EXCLUDE_SRC_PATTERNS := \/unix\/\n+\n+    BUILD_LIBSPLASHSCREEN_java_awt_SplashScreen.c_CFLAGS := -x objective-c -O0\n+    BUILD_LIBSPLASHSCREEN_splashscreen_gfx_impl.c_CFLAGS := -x objective-c -O0\n+    BUILD_LIBSPLASHSCREEN_splashscreen_gif.c_CFLAGS := -x objective-c -O0\n+    BUILD_LIBSPLASHSCREEN_splashscreen_impl.c_CFLAGS := -x objective-c -O0\n+    BUILD_LIBSPLASHSCREEN_splashscreen_jpeg.c_CFLAGS := -x objective-c -O0\n+    BUILD_LIBSPLASHSCREEN_splashscreen_png.c_CFLAGS := -x objective-c -O0\n+    BUILD_LIBSPLASHSCREEN_splashscreen_sys.m_CFLAGS := -O0\n+  endif\n+\n+  ifeq ($(call isTargetOs, macosx), true)\n+    LIBSPLASHSCREEN_CFLAGS += -DWITH_MACOSX\n+  else ifeq ($(call isTargetOs, windows), true)\n+    LIBSPLASHSCREEN_CFLAGS += -DWITH_WIN32\n+  else\n+    LIBSPLASHSCREEN_CFLAGS += -DWITH_X11 $(X_CFLAGS)\n+  endif\n+\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBSPLASHSCREEN, \\\n+      NAME := splashscreen, \\\n+      EXTRA_SRC := $(LIBSPLASHSCREEN_EXTRA_SRC), \\\n+      EXCLUDE_SRC_PATTERNS := $(LIBSPLASHSCREEN_EXCLUDE_SRC_PATTERNS), \\\n+      EXCLUDE_FILES := imageioJPEG.c jpegdecoder.c pngtest.c, \\\n+      EXCLUDES := $(LIBSPLASHSCREEN_EXCLUDES), \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(LIBSPLASHSCREEN_CFLAGS) \\\n+          $(GIFLIB_CFLAGS) $(LIBJPEG_CFLAGS) $(PNG_CFLAGS) $(LIBZ_CFLAGS), \\\n+      CXXFLAGS := $(LIBSPLASHSCREEN_CFLAGS) \\\n+          $(GIFLIB_CFLAGS) $(LIBJPEG_CFLAGS) $(PNG_CFLAGS) $(LIBZ_CFLAGS), \\\n+      EXTRA_HEADER_DIRS := $(LIBSPLASHSCREEN_HEADER_DIRS), \\\n+      DISABLED_WARNINGS_gcc_dgif_lib.c := sign-compare, \\\n+      DISABLED_WARNINGS_gcc_jcmaster.c := implicit-fallthrough, \\\n+      DISABLED_WARNINGS_gcc_jdphuff.c := shift-negative-value, \\\n+      DISABLED_WARNINGS_gcc_png.c := maybe-uninitialized, \\\n+      DISABLED_WARNINGS_gcc_pngerror.c := maybe-uninitialized, \\\n+      DISABLED_WARNINGS_gcc_splashscreen_gfx_impl.c := implicit-fallthrough \\\n+          maybe-uninitialized, \\\n+      DISABLED_WARNINGS_gcc_splashscreen_impl.c := implicit-fallthrough \\\n+          sign-compare unused-function, \\\n+      DISABLED_WARNINGS_gcc_splashscreen_sys.c := type-limits unused-result, \\\n+      DISABLED_WARNINGS_clang := deprecated-non-prototype, \\\n+      DISABLED_WARNINGS_clang_dgif_lib.c := sign-compare, \\\n+      DISABLED_WARNINGS_clang_gzwrite.c := format-nonliteral, \\\n+      DISABLED_WARNINGS_clang_splashscreen_impl.c := sign-compare, \\\n+      DISABLED_WARNINGS_clang_splashscreen_png.c := \\\n+          incompatible-pointer-types, \\\n+      DISABLED_WARNINGS_clang_splashscreen_sys.m := deprecated-declarations, \\\n+      DISABLED_WARNINGS_microsoft_dgif_lib.c := 4018 4267, \\\n+      DISABLED_WARNINGS_microsoft_splashscreen_impl.c := 4018 4267 4244, \\\n+      DISABLED_WARNINGS_microsoft_splashscreen_png.c := 4267, \\\n+      DISABLED_WARNINGS_microsoft_splashscreen_sys.c := 4267 4244, \\\n+      LDFLAGS_windows := -delayload:user32.dll, \\\n+      JDK_LIBS_windows := java.base:libjava, \\\n+      JDK_LIBS_macosx := libosxapp, \\\n+      LIBS := $(GIFLIB_LIBS) $(LIBJPEG_LIBS) $(LIBZ_LIBS) $(PNG_LIBS), \\\n+      LIBS_unix := $(LIBM) -lpthread, \\\n+      LIBS_linux := $(LIBDL) $(X_LIBS) -lX11 -lXext, \\\n+      LIBS_macosx := -liconv \\\n+          -framework ApplicationServices \\\n+          -framework Cocoa \\\n+          -framework Foundation \\\n+          -framework Metal \\\n+          -framework Security, \\\n+      LIBS_aix := $(LIBDL) -liconv $(X_LIBS) -lX11 -lXext, \\\n+      LIBS_windows := delayimp.lib gdi32.lib kernel32.lib user32.lib, \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBSPLASHSCREEN)\n+endif\n+\n+################################################################################\n+## Build libfreetype\n+################################################################################\n+\n+ifeq ($(FREETYPE_TO_USE), bundled)\n+  # freetype requires you to manually define DLL_EXPORT for windows (see ftconfig.h)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBFREETYPE, \\\n+      NAME := freetype, \\\n+      OPTIMIZATION := HIGHEST, \\\n+      CFLAGS := -DFT2_BUILD_LIBRARY, \\\n+      CFLAGS_windows := -DDLL_EXPORT, \\\n+      EXTRA_HEADER_DIRS := libfreetype\/include, \\\n+      DISABLED_WARNINGS_microsoft := 4267 4244 4996, \\\n+      DISABLED_WARNINGS_gcc := dangling-pointer stringop-overflow, \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBFREETYPE)\n+endif\n+\n+################################################################################\n+## Build libfontmanager\n+################################################################################\n+\n+ifeq ($(USE_EXTERNAL_HARFBUZZ), true)\n+   LIBFONTMANAGER_EXTRA_SRC =\n+   LIBFONTMANAGER_LIBS += $(HARFBUZZ_LIBS)\n+else\n+   LIBFONTMANAGER_EXTRA_SRC = libharfbuzz\n+\n+   ifeq ($(call isTargetOs, windows), false)\n+     HARFBUZZ_CFLAGS += -DGETPAGESIZE -DHAVE_MPROTECT -DHAVE_PTHREAD \\\n+        -DHAVE_SYSCONF -DHAVE_SYS_MMAN_H -DHAVE_UNISTD_H \\\n+        -DHB_NO_PRAGMA_GCC_DIAGNOSTIC\n+   endif\n+   ifeq ($(call isTargetOs, linux macosx), true)\n+     HARFBUZZ_CFLAGS += -DHAVE_INTEL_ATOMIC_PRIMITIVES -DHB_NO_VISIBILITY\n+   endif\n+\n+   # hb-ft.cc is not presently needed, and requires freetype 2.4.2 or later.\n+   # hb-subset and hb-style APIs are not needed, excluded to cut on compilation\n+   # time.\n+   LIBFONTMANAGER_EXCLUDE_FILES += gsubgpos-context.cc hb-ft.cc hb-style.cc \\\n+      hb-subset-cff-common.cc hb-subset-cff1.cc hb-subset-cff2.cc \\\n+      hb-subset-input.cc hb-subset-instancer-solver.cc hb-subset-plan.cc \\\n+      hb-subset.cc\n+\n+   # list of disabled warnings and the compilers for which it was specifically\n+   # added.\n+   # array-bounds         -> GCC 12 on Alpine Linux\n+   # parentheses          -> GCC 6\n+   # range-loop-analysis  -> clang on Xcode12\n+\n+   HARFBUZZ_DISABLED_WARNINGS_gcc := missing-field-initializers \\\n+       strict-aliasing unused-result array-bounds parentheses\n+   # noexcept-type required for GCC 7 builds. Not required for GCC 8+.\n+   # expansion-to-defined required for GCC 9 builds. Not required for GCC 10+.\n+   # maybe-uninitialized required for GCC 8 builds. Not required for GCC 9+.\n+   # calloc-transposed-args required for GCC 14 builds. (fixed upstream in\n+   #  Harfbuzz 032c931e1c0cfb20f18e5acb8ba005775242bd92)\n+   HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type \\\n+       expansion-to-defined dangling-reference maybe-uninitialized \\\n+       calloc-transposed-args\n+   HARFBUZZ_DISABLED_WARNINGS_clang := missing-field-initializers \\\n+      range-loop-analysis\n+   HARFBUZZ_DISABLED_WARNINGS_microsoft := 4267 4244\n+\n+   LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n+endif\n+\n+LIBFONTMANAGER_EXTRA_HEADER_DIRS := \\\n+    common\/awt \\\n+    common\/awt\/utility \\\n+    common\/font \\\n+    libawt\/java2d \\\n+    libawt\/java2d\/pipe \\\n+    libawt\/java2d\/loops \\\n+    #\n+\n+ifeq ($(FREETYPE_TO_USE), system)\n+  LIBFONTMANAGER_CFLAGS += $(FREETYPE_CFLAGS)\n+  LIBFONTMANAGER_LIBS += $(FREETYPE_LIBS)\n+else\n+  LIBFONTMANAGER_EXTRA_HEADER_DIRS += libfreetype\/include\n+  LIBFONTMANAGER_JDK_LIBS += libfreetype\n+endif\n+\n+LIBFONTMANAGER_OPTIMIZATION := HIGHEST\n+\n+ifneq ($(filter $(TOOLCHAIN_TYPE), gcc clang), )\n+  # gcc (and to an extent clang) is particularly bad at optimizing these files,\n+  # causing a massive spike in compile time. We don't care about these\n+  # particular files anyway, so lower optimization level.\n+  BUILD_LIBFONTMANAGER_hb-subset.cc_OPTIMIZATION := SIZE\n+  BUILD_LIBFONTMANAGER_hb-subset-plan.cc_OPTIMIZATION := SIZE\n+endif\n+\n+ifeq ($(call isTargetOs, windows), true)\n+  LIBFONTMANAGER_EXCLUDE_FILES += X11FontScaler.c X11TextRenderer.c\n+  LIBFONTMANAGER_OPTIMIZATION := HIGHEST\n+else ifeq ($(call isTargetOs, macosx), true)\n+  LIBFONTMANAGER_EXCLUDE_FILES += X11FontScaler.c X11TextRenderer.c \\\n+      fontpath.c lcdglyph.c\n+else\n+  LIBFONTMANAGER_EXCLUDE_FILES += fontpath.c lcdglyph.c\n+endif\n+\n+LIBFONTMANAGER_CFLAGS += $(X_CFLAGS) -DLE_STANDALONE -DHEADLESS\n+\n+# LDFLAGS clarification:\n+#   Filter relevant linker flags disallowing unresolved symbols as we cannot\n+#   build-time decide to which library to link against (libawt_headless or\n+#   libawt_xawt). See JDK-8196516 for details.\n+$(eval $(call SetupJdkLibrary, BUILD_LIBFONTMANAGER, \\\n+    NAME := fontmanager, \\\n+    LINK_TYPE := C++, \\\n+    EXCLUDE_FILES := $(LIBFONTMANAGER_EXCLUDE_FILES) \\\n+        AccelGlyphCache.c, \\\n+    CFLAGS := $(LIBFONTMANAGER_CFLAGS), \\\n+    CXXFLAGS := $(LIBFONTMANAGER_CFLAGS), \\\n+    OPTIMIZATION := $(LIBFONTMANAGER_OPTIMIZATION), \\\n+    CFLAGS_windows = -DCC_NOEX, \\\n+    EXTRA_HEADER_DIRS := $(LIBFONTMANAGER_EXTRA_HEADER_DIRS), \\\n+    EXTRA_SRC := $(LIBFONTMANAGER_EXTRA_SRC), \\\n+    DISABLED_WARNINGS_gcc := $(HARFBUZZ_DISABLED_WARNINGS_gcc), \\\n+    DISABLED_WARNINGS_CXX_gcc := $(HARFBUZZ_DISABLED_WARNINGS_CXX_gcc), \\\n+    DISABLED_WARNINGS_clang := $(HARFBUZZ_DISABLED_WARNINGS_clang), \\\n+    DISABLED_WARNINGS_microsoft := $(HARFBUZZ_DISABLED_WARNINGS_microsoft), \\\n+    LDFLAGS := $(LDFLAGS_CXX_JDK), \\\n+    LDFLAGS_FILTER_OUT :=-Wl$(COMMA)-z$(COMMA)defs, \\\n+    LDFLAGS_aix := -Wl$(COMMA)-berok, \\\n+    JDK_LIBS := libawt java.base:libjava $(LIBFONTMANAGER_JDK_LIBS), \\\n+    JDK_LIBS_macosx := libawt_lwawt, \\\n+    LIBS := $(LIBFONTMANAGER_LIBS), \\\n+    LIBS_unix := $(LIBM), \\\n+    LIBS_macosx := \\\n+        -framework CoreFoundation \\\n+        -framework CoreGraphics \\\n+        -framework CoreText, \\\n+    LIBS_windows := advapi32.lib gdi32.lib user32.lib, \\\n+))\n+\n+TARGETS += $(BUILD_LIBFONTMANAGER)\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  ##############################################################################\n+  ## Build libosxui\n+  ##############################################################################\n+\n+  SHADERS_SRC := \\\n+      $(TOPDIR)\/src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/shaders.metal\n+  SHADERS_SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/java.desktop\/libosxui\n+  SHADERS_AIR := $(SHADERS_SUPPORT_DIR)\/shaders.air\n+  SHADERS_LIB := $(call FindLibDirForModule, $(MODULE))\/shaders.metallib\n+\n+  $(eval $(call SetupExecute, metal_shaders, \\\n+      INFO := Running metal on $(notdir $(SHADERS_SRC)) (for libosxui.dylib), \\\n+      DEPS := $(SHADERS_SRC), \\\n+      OUTPUT_FILE := $(SHADERS_AIR), \\\n+      SUPPORT_DIR := $(SHADERS_SUPPORT_DIR), \\\n+      COMMAND := $(METAL) -c -std=osx-metal2.0 \\\n+          -mmacosx-version-min=$(MACOSX_VERSION_MIN) \\\n+          -o $(SHADERS_AIR) $(SHADERS_SRC), \\\n+  ))\n+\n+  $(eval $(call SetupExecute, metallib_shaders, \\\n+      INFO := Running metallib on $(notdir $(SHADERS_AIR)) (for libosxui.dylib), \\\n+      DEPS := $(SHADERS_AIR), \\\n+      OUTPUT_FILE := $(SHADERS_LIB), \\\n+      SUPPORT_DIR := $(SHADERS_SUPPORT_DIR), \\\n+      COMMAND := $(METALLIB) -o $(SHADERS_LIB) $(SHADERS_AIR), \\\n+  ))\n+\n+  TARGETS += $(SHADERS_LIB)\n+\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBOSXUI, \\\n+      NAME := osxui, \\\n+      OPTIMIZATION := LOW, \\\n+      EXTRA_HEADER_DIRS := \\\n+          libawt_lwawt\/awt, \\\n+      DISABLED_WARNINGS_clang_AquaFileView.m := deprecated-declarations \\\n+          sign-compare, \\\n+      DISABLED_WARNINGS_clang_ScreenMenu.m := deprecated-declarations, \\\n+      APPEND_LDFLAGS := -Wl$(COMMA)-rpath$(COMMA)@loader_path, \\\n+      JDK_LIBS := java.base:libjava libosxapp, \\\n+      LIBS_macosx := \\\n+          -framework ApplicationServices \\\n+          -framework Carbon \\\n+          -framework Cocoa \\\n+          -framework JavaRuntimeSupport \\\n+          -framework Metal, \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBOSXUI)\n+\n+  $(BUILD_LIBOSXUI): $(SHADERS_LIB)\n+endif\n","filename":"make\/modules\/java.desktop\/lib\/ClientLibraries.gmk","additions":453,"deletions":0,"binary":false,"changes":453,"status":"added"},{"patch":"@@ -39,8 +39,1 @@\n-    EXTRA_HEADER_DIRS := java.base:libjli, \\\n-    LDFLAGS_linux := -L$(call FindLibDirForModule, java.base), \\\n-    LDFLAGS_macosx := -L$(call FindLibDirForModule, java.base), \\\n-    LDFLAGS_aix := -L$(SUPPORT_OUTPUTDIR)\/native\/java.base, \\\n-    JDK_LIBS := $(JDKLIB_LIBS), \\\n-    JDK_LIBS_unix := -ljli, \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB) \\\n-        $(SUPPORT_OUTPUTDIR)\/native\/java.base\/libjli\/jli.lib jvm.lib, \\\n+    JDK_LIBS := java.base:libjava java.base:libjli java.base:libjvm, \\\n@@ -57,7 +50,0 @@\n-ifeq ($(call isTargetOs, aix), true)\n-  $(BUILD_LIBINSTRUMENT): $(call FindStaticLib, java.base, jli)\n-else\n-  $(BUILD_LIBINSTRUMENT): $(call FindLib, java.base, jli)\n-endif\n-$(BUILD_LIBINSTRUMENT): $(call FindLib, java.base, java)\n-\n","filename":"make\/modules\/java.instrument\/Lib.gmk","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-    JDK_LIBS := $(JDKLIB_LIBS), \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB) jvm.lib, \\\n+    JDK_LIBS := java.base:libjava java.base:libjvm, \\\n@@ -46,2 +45,0 @@\n-$(BUILD_LIBMANAGEMENT): $(call FindLib, java.base, java)\n-\n","filename":"make\/modules\/java.management\/Lib.gmk","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,26 +0,0 @@\n-#\n-# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/java.net.http\/Java.gmk","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -41,4 +41,1 @@\n-    JDK_LIBS_unix := -ljvm, \\\n-    JDK_LIBS_linux := -ljava, \\\n-    JDK_LIBS_aix := -ljava, \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB) jvm.lib, \\\n+    JDK_LIBS := java.base:libjava java.base:libjvm, \\\n@@ -51,2 +48,0 @@\n-$(BUILD_LIBPREFS): $(call FindLib, java.base, java)\n-\n","filename":"make\/modules\/java.prefs\/Lib.gmk","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+    EXTRA_HEADER_DIRS := java.base:libjava, \\\n@@ -35,2 +36,1 @@\n-    JDK_LIBS_unix := -ljvm, \\\n-    JDK_LIBS_windows := jvm.lib, \\\n+    JDK_LIBS := java.base:libjvm, \\\n@@ -39,2 +39,0 @@\n-$(BUILD_LIBRMI): $(call FindLib, java.base, java)\n-\n","filename":"make\/modules\/java.rmi\/Lib.gmk","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+    EXTRA_HEADER_DIRS := java.base:libjava, \\\n@@ -50,1 +51,3 @@\n-      EXTRA_HEADER_DIRS := libj2gss, \\\n+      EXTRA_HEADER_DIRS := \\\n+          libj2gss \\\n+          java.base:libjava, \\\n@@ -66,0 +69,1 @@\n+        EXTRA_HEADER_DIRS := java.base:libjava, \\\n@@ -82,0 +86,1 @@\n+        EXTRA_HEADER_DIRS := java.base:libjava, \\\n","filename":"make\/modules\/java.security.jgss\/Lib.gmk","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,1 +35,3 @@\n-    EXTRA_HEADER_DIRS := libj2pcsc\/MUSCLE, \\\n+    EXTRA_HEADER_DIRS := \\\n+        libj2pcsc\/MUSCLE \\\n+        java.base:libjava, \\\n","filename":"make\/modules\/java.smartcardio\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/java.sql.rowset\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        JDK_LIBS_windows := $(SUPPORT_OUTPUTDIR)\/native\/java.desktop\/libjawt\/jawt.lib, \\\n+        JDK_LIBS := java.desktop:libjawt, \\\n@@ -59,2 +59,0 @@\n-    $$(BUILD_LIBJAVAACCESSBRIDGE$1): $(call FindStaticLib, java.desktop, jawt, \/libjawt)\n-\n","filename":"make\/modules\/jdk.accessibility\/Lib.gmk","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-    JDK_LIBS := $(JDKLIB_LIBS), \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB), \\\n+    JDK_LIBS := java.base:libjava, \\\n@@ -49,2 +48,0 @@\n-$(BUILD_LIBATTACH): $(call FindLib, java.base, java)\n-\n","filename":"make\/modules\/jdk.attach\/Lib.gmk","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.charsets\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+include CopyFiles.gmk\n@@ -68,1 +69,1 @@\n-    DISABLED_WARNINGS := options this-escape, \\\n+    DISABLED_WARNINGS := options, \\\n","filename":"make\/modules\/jdk.compiler\/Gendata.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+    EXTRA_HEADER_DIRS := java.base:libjava, \\\n","filename":"make\/modules\/jdk.crypto.cryptoki\/Lib.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,26 +0,0 @@\n-#\n-# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.crypto.ec\/Java.gmk","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -36,0 +36,1 @@\n+      EXTRA_HEADER_DIRS := java.base:libjava, \\\n","filename":"make\/modules\/jdk.crypto.mscapi\/Lib.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    EXTRA_HEADER_DIRS := java.base:libjvm, \\\n@@ -69,2 +70,1 @@\n-    JDK_LIBS_unix := -ljava, \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB), \\\n+    JDK_LIBS := java.base:libjava, \\\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+      EXTRA_HEADER_DIRS := \\\n+          java.base:libjava \\\n+          java.base:libjvm, \\\n@@ -38,1 +41,0 @@\n-      JDK_LIBS := $(JDKLIB_LIBS), \\\n","filename":"make\/modules\/jdk.internal.le\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    DISABLED_WARNINGS := options this-escape, \\\n+    DISABLED_WARNINGS := options, \\\n","filename":"make\/modules\/jdk.javadoc\/Gendata.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jcmd\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jconsole\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jdeps\/Gensrc.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jdeps\/Launcher.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jdi\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-      JDK_LIBS := $(JDKLIB_LIBS), \\\n","filename":"make\/modules\/jdk.jdi\/Lib.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-$(BUILD_LIBDT_SOCKET): $(call FindLib, java.base, java)\n-\n@@ -64,2 +62,3 @@\n-        libjdwp\/export, \\\n-    JDK_LIBS := $(JDKLIB_LIBS), \\\n+        libjdwp\/export \\\n+        java.base:libjava \\\n+        java.base:libjvm, \\\n@@ -71,2 +70,0 @@\n-$(BUILD_LIBJDWP): $(call FindLib, java.base, java)\n-\n","filename":"make\/modules\/jdk.jdwp.agent\/Lib.gmk","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jpackage\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.localedata\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-    JDK_LIBS := $(JDKLIB_LIBS), \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB), \\\n+    JDK_LIBS := java.base:libjava, \\\n@@ -40,2 +39,0 @@\n-$(BUILD_LIBMANAGEMENT_AGENT): $(call FindLib, java.base, java)\n-\n","filename":"make\/modules\/jdk.management.agent\/Lib.gmk","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-    JDK_LIBS := $(JDKLIB_LIBS), \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB) jvm.lib, \\\n+    JDK_LIBS := java.base:libjava java.base:libjvm, \\\n@@ -55,2 +54,0 @@\n-$(BUILD_LIBMANAGEMENT_EXT): $(call FindLib, java.base, java)\n-\n","filename":"make\/modules\/jdk.management\/Lib.gmk","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,3 +35,2 @@\n-    JDK_LIBS_unix := -ljava, \\\n-    JDK_LIBS_linux := -ljvm, \\\n-    JDK_LIBS_windows := $(WIN_JAVA_LIB) jvm.lib, \\\n+    EXTRA_HEADER_DIRS := java.base:libjvm, \\\n+    JDK_LIBS := java.base:libjava, \\\n@@ -41,2 +40,0 @@\n-$(BUILD_LIBEXTNET): $(call FindLib, java.base, java)\n-\n","filename":"make\/modules\/jdk.net\/Lib.gmk","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.sctp\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-          java.base:libnet \\\n+          java.base:libjvm \\\n+          java.base:libnio \\\n@@ -40,1 +41,1 @@\n-      JDK_LIBS_unix := -ljava -ljvm -lnet -lnio, \\\n+      JDK_LIBS := java.base:libjava java.base:libnet, \\\n@@ -45,2 +46,0 @@\n-\n-  $(BUILD_LIBSCTP): $(call FindLib, java.base, nio)\n","filename":"make\/modules\/jdk.sctp\/Lib.gmk","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+    EXTRA_HEADER_DIRS := java.base:libjava, \\\n@@ -38,2 +39,0 @@\n-$(BUILD_LIBJAAS): $(call FindLib, java.base, java)\n-\n","filename":"make\/modules\/jdk.security.auth\/Lib.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/test\/BuildFailureHandler.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/test\/BuildJtregTestThreadFactory.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+\n+include CopyFiles.gmk\n@@ -104,0 +106,1 @@\n+        --add-exports java.base\/jdk.internal.util=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/test\/BuildTestLib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/test\/BuildTestLibNative.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+include CopyFiles.gmk\n@@ -845,3 +847,5 @@\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeinvoke := -ljvm -lpthread\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-gap := -ljvm -lpthread\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-tls := -ljvm\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exeinvoke := java.base:libjvm\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exestack-gap := java.base:libjvm\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exestack-tls := java.base:libjvm\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeinvoke := -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-gap := -lpthread\n@@ -862,1 +866,3 @@\n-BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exesigtest := -ljvm\n+BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exesigtest := java.base:libjvm\n+BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libatExit := java.base:libjvm\n+BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exedaemonDestroy := java.base:libjvm\n@@ -867,3 +873,1 @@\n-  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit := jvm.lib\n-  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativeStack := jvm.lib\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exedaemonDestroy := jvm.lib\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libnativeStack := java.base:libjvm\n@@ -871,1 +875,0 @@\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exedaemonDestroy := -ljvm\n@@ -1506,1 +1509,0 @@\n-  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit += -ljvm\n@@ -1510,1 +1512,2 @@\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeGetCreatedJavaVMs := -ljvm -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeGetCreatedJavaVMs := -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exeGetCreatedJavaVMs := java.base:libjvm\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+include CopyFiles.gmk\n@@ -56,0 +58,9 @@\n+BUILD_JDK_JTREG_EXECUTABLES_JDK_LIBS_exeJliLaunchTest := java.base:libjli\n+BUILD_JDK_JTREG_EXECUTABLES_JDK_LIBS_exeCallerAccessTest := java.base:libjvm\n+BUILD_JDK_JTREG_EXECUTABLES_JDK_LIBS_exeNullCallerTest := java.base:libjvm\n+\n+BUILD_JDK_JTREG_LIBRARIES_JDK_LIBS_libstringPlatformChars := java.base:libjava\n+BUILD_JDK_JTREG_LIBRARIES_JDK_LIBS_libTracePinnedThreads := java.base:libjvm\n+BUILD_JDK_JTREG_LIBRARIES_JDK_LIBS_libNewDirectByteBuffer := java.base:libjava\n+BUILD_JDK_JTREG_LIBRARIES_JDK_LIBS_libGetXSpace := java.base:libjava\n+\n@@ -62,6 +73,1 @@\n-  WIN_LIB_JAVA := $(SUPPORT_OUTPUTDIR)\/native\/java.base\/libjava\/java.lib\n-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libstringPlatformChars := $(WIN_LIB_JAVA)\n-  WIN_LIB_JLI := $(SUPPORT_OUTPUTDIR)\/native\/java.base\/libjli\/jli.lib\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeJliLaunchTest := $(WIN_LIB_JLI)\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeCallerAccessTest := jvm.lib\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerTest := $(LIBCXX) jvm.lib\n+  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerTest := $(LIBCXX)\n@@ -70,3 +76,0 @@\n-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libTracePinnedThreads := jvm.lib\n-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libNewDirectByteBuffer := $(WIN_LIB_JAVA)\n-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libGetXSpace := $(WIN_LIB_JAVA)\n@@ -74,4 +77,1 @@\n-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libstringPlatformChars := -ljava\n-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libDirectIO := -ljava\n-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libNewDirectByteBuffer := -ljava\n-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libGetXSpace := -ljava\n+  BUILD_JDK_JTREG_LIBRARIES_JDK_LIBS_libDirectIO := java.base:libjava\n@@ -87,1 +87,1 @@\n-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libExplicitAttach := -ljvm\n+  BUILD_JDK_JTREG_LIBRARIES_JDK_LIBS_libExplicitAttach := java.base:libjvm\n@@ -90,1 +90,0 @@\n-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libTracePinnedThreads := -ljvm\n@@ -93,1 +92,1 @@\n-    BUILD_JDK_JTREG_LIBRARIES_LIBS_libInheritedChannel := -ljava\n+    BUILD_JDK_JTREG_LIBRARIES_JDK_LIBS_libInheritedChannel := java.base:libjava\n@@ -96,6 +95,1 @@\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeJliLaunchTest := -ljli\n-  ifeq ($(call isTargetOs, aix), true)\n-    BUILD_JDK_JTREG_EXECUTABLES_LDFLAGS_exeJliLaunchTest := -L$(SUPPORT_OUTPUTDIR)\/native\/java.base\n-  endif\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeCallerAccessTest := -ljvm\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerTest := $(LIBCXX) -ljvm\n+  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerTest := $(LIBCXX)\n@@ -108,1 +102,1 @@\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeJniInvocationTest := -ljli\n+  BUILD_JDK_JTREG_EXECUTABLES_JDK_LIBS_exeJniInvocationTest := java.base:libjli\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":17,"deletions":23,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+include CopyFiles.gmk\n@@ -51,5 +53,1 @@\n-ifeq ($(call isTargetOs, windows), true)\n-    BUILD_LIBTEST_JTREG_EXECUTABLES_LIBS_exejvm-test-launcher := jvm.lib\n-else\n-    BUILD_LIBTEST_JTREG_EXECUTABLES_LIBS_exejvm-test-launcher := -ljvm\n-endif\n+BUILD_LIBTEST_JTREG_EXECUTABLES_JDK_LIBS_exejvm-test-launcher := java.base:libjvm\n","filename":"make\/test\/JtregNativeLibTest.gmk","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2014, 2021, Red Hat, Inc. All rights reserved.\n+\/\/ Copyright (c) 2014, 2024, Red Hat, Inc. All rights reserved.\n@@ -1129,0 +1129,4 @@\n+\/\/ Figure out which register class each belongs in: rc_int, rc_float or\n+\/\/ rc_stack.\n+enum RC { rc_bad, rc_int, rc_float, rc_predicate, rc_stack };\n+\n@@ -1151,2 +1155,2 @@\n-  static int emit_exception_handler(CodeBuffer &cbuf);\n-  static int emit_deopt_handler(CodeBuffer& cbuf);\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n+  static int emit_deopt_handler(C2_MacroAssembler* masm);\n@@ -1605,1 +1609,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -1660,2 +1664,1 @@\n-void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n+void MachBreakpointNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1677,2 +1680,1 @@\n-  void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc*) const {\n-    C2_MacroAssembler _masm(&cbuf);\n+  void MachNopNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc*) const {\n@@ -1700,1 +1702,1 @@\n-void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n@@ -1754,1 +1756,1 @@\n-void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1756,1 +1758,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1805,1 +1806,1 @@\n-      bs->nmethod_entry_barrier(&_masm, slow_path, continuation, guard);\n+      bs->nmethod_entry_barrier(masm, slow_path, continuation, guard);\n@@ -1813,1 +1814,1 @@\n-  C->output()->set_frame_complete(cbuf.insts_size());\n+  C->output()->set_frame_complete(__ offset());\n@@ -1867,1 +1868,1 @@\n-void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachEpilogNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1869,1 +1870,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1907,4 +1907,0 @@\n-\/\/ Figure out which register class each belongs in: rc_int, rc_float or\n-\/\/ rc_stack.\n-enum RC { rc_bad, rc_int, rc_float, rc_predicate, rc_stack };\n-\n@@ -1941,1 +1937,1 @@\n-uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {\n+uint MachSpillCopyNode::implementation(C2_MacroAssembler *masm, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {\n@@ -1974,2 +1970,1 @@\n-    if (ireg == Op_VecA && cbuf) {\n-      C2_MacroAssembler _masm(cbuf);\n+    if (ireg == Op_VecA && masm) {\n@@ -1994,1 +1989,1 @@\n-    } else if (cbuf) {\n+    } else if (masm) {\n@@ -1996,1 +1991,0 @@\n-      C2_MacroAssembler _masm(cbuf);\n@@ -2023,2 +2017,1 @@\n-  } else if (cbuf) {\n-    C2_MacroAssembler _masm(cbuf);\n+  } else if (masm) {\n@@ -2032,1 +2025,0 @@\n-            C2_MacroAssembler _masm(cbuf);\n@@ -2160,2 +2152,2 @@\n-void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  implementation(&cbuf, ra_, false, nullptr);\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation(masm, ra_, false, nullptr);\n@@ -2179,3 +2171,1 @@\n-void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n-\n+void BoxLockNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -2220,1 +2210,1 @@\n-void MachUEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void MachUEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n@@ -2222,2 +2212,0 @@\n-  \/\/ This is the unverified entry point.\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -2237,1 +2225,1 @@\n-int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf)\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n@@ -2243,1 +2231,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -2257,1 +2244,1 @@\n-int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf)\n+int HandlerImpl::emit_deopt_handler(C2_MacroAssembler* masm)\n@@ -2261,1 +2248,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -2680,1 +2666,0 @@\n-  C2_MacroAssembler _masm(&cbuf);                                       \\\n@@ -2725,1 +2710,1 @@\n-  static void loadStore(C2_MacroAssembler masm, mem_insn insn,\n+  static void loadStore(C2_MacroAssembler* masm, mem_insn insn,\n@@ -2735,1 +2720,1 @@\n-      addr = masm.legitimize_address(addr, size_in_memory, rscratch1);\n+      addr = __ legitimize_address(addr, size_in_memory, rscratch1);\n@@ -2737,1 +2722,1 @@\n-    (masm.*insn)(reg, addr);\n+    (masm->*insn)(reg, addr);\n@@ -2740,1 +2725,1 @@\n-  static void loadStore(C2_MacroAssembler masm, mem_float_insn insn,\n+  static void loadStore(C2_MacroAssembler* masm, mem_float_insn insn,\n@@ -2763,2 +2748,2 @@\n-      addr = masm.legitimize_address(addr, size_in_memory, rscratch1);\n-      (masm.*insn)(reg, addr);\n+      addr = __ legitimize_address(addr, size_in_memory, rscratch1);\n+      (masm->*insn)(reg, addr);\n@@ -2767,1 +2752,1 @@\n-      (masm.*insn)(reg, Address(base, as_Register(index), scale));\n+      (masm->*insn)(reg, Address(base, as_Register(index), scale));\n@@ -2771,1 +2756,1 @@\n-  static void loadStore(C2_MacroAssembler masm, mem_vector_insn insn,\n+  static void loadStore(C2_MacroAssembler* masm, mem_vector_insn insn,\n@@ -2776,1 +2761,1 @@\n-      (masm.*insn)(reg, T, Address(base, disp));\n+      (masm->*insn)(reg, T, Address(base, disp));\n@@ -2779,1 +2764,1 @@\n-      (masm.*insn)(reg, T, Address(base, as_Register(index), Address::lsl(size)));\n+      (masm->*insn)(reg, T, Address(base, as_Register(index), Address::lsl(size)));\n@@ -2824,1 +2809,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2834,1 +2818,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsbw, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrsbw, dst_reg, $mem->opcode(),\n@@ -2842,1 +2826,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsb, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrsb, dst_reg, $mem->opcode(),\n@@ -2850,1 +2834,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrb, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrb, dst_reg, $mem->opcode(),\n@@ -2858,1 +2842,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrb, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrb, dst_reg, $mem->opcode(),\n@@ -2866,1 +2850,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrshw, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrshw, dst_reg, $mem->opcode(),\n@@ -2874,1 +2858,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsh, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrsh, dst_reg, $mem->opcode(),\n@@ -2882,1 +2866,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrh, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrh, dst_reg, $mem->opcode(),\n@@ -2890,1 +2874,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrh, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrh, dst_reg, $mem->opcode(),\n@@ -2898,1 +2882,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrw, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrw, dst_reg, $mem->opcode(),\n@@ -2906,1 +2890,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrw, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrw, dst_reg, $mem->opcode(),\n@@ -2914,1 +2898,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsw, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrsw, dst_reg, $mem->opcode(),\n@@ -2922,1 +2906,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldr, dst_reg, $mem->opcode(),\n@@ -2930,1 +2914,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrs, dst_reg, $mem->opcode(),\n@@ -2938,1 +2922,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrd, dst_reg, $mem->opcode(),\n@@ -2946,1 +2930,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strb, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strb, src_reg, $mem->opcode(),\n@@ -2953,2 +2937,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    loadStore(_masm, &MacroAssembler::strb, zr, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strb, zr, $mem->opcode(),\n@@ -2962,1 +2945,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strh, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strh, src_reg, $mem->opcode(),\n@@ -2969,2 +2952,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    loadStore(_masm, &MacroAssembler::strh, zr, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strh, zr, $mem->opcode(),\n@@ -2978,1 +2960,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strw, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strw, src_reg, $mem->opcode(),\n@@ -2985,2 +2967,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    loadStore(_masm, &MacroAssembler::strw, zr, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strw, zr, $mem->opcode(),\n@@ -2997,1 +2978,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -3002,1 +2982,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::str, src_reg, $mem->opcode(),\n@@ -3009,2 +2989,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    loadStore(_masm, &MacroAssembler::str, zr, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::str, zr, $mem->opcode(),\n@@ -3018,1 +2997,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strs, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strs, src_reg, $mem->opcode(),\n@@ -3026,1 +3005,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strd, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strd, src_reg, $mem->opcode(),\n@@ -3033,1 +3012,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -3035,1 +3013,1 @@\n-      loadStore(_masm, &MacroAssembler::strb, zr, $mem->opcode(),\n+      loadStore(masm, &MacroAssembler::strb, zr, $mem->opcode(),\n@@ -3044,1 +3022,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::H,\n+    loadStore(masm, &MacroAssembler::ldr, dst_reg, MacroAssembler::H,\n@@ -3050,1 +3028,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::S,\n+    loadStore(masm, &MacroAssembler::ldr, dst_reg, MacroAssembler::S,\n@@ -3056,1 +3034,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::D,\n+    loadStore(masm, &MacroAssembler::ldr, dst_reg, MacroAssembler::D,\n@@ -3062,1 +3040,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::Q,\n+    loadStore(masm, &MacroAssembler::ldr, dst_reg, MacroAssembler::Q,\n@@ -3068,1 +3046,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::H,\n+    loadStore(masm, &MacroAssembler::str, src_reg, MacroAssembler::H,\n@@ -3074,1 +3052,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::S,\n+    loadStore(masm, &MacroAssembler::str, src_reg, MacroAssembler::S,\n@@ -3080,1 +3058,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::D,\n+    loadStore(masm, &MacroAssembler::str, src_reg, MacroAssembler::D,\n@@ -3086,1 +3064,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::Q,\n+    loadStore(masm, &MacroAssembler::str, src_reg, MacroAssembler::Q,\n@@ -3202,1 +3180,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -3218,1 +3195,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -3228,1 +3204,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -3239,1 +3214,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3268,1 +3242,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3298,1 +3271,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3306,1 +3278,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3314,1 +3285,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3322,1 +3292,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3335,1 +3304,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3343,1 +3311,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3351,1 +3318,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3359,1 +3325,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3368,1 +3333,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3376,1 +3340,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3397,1 +3360,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3408,1 +3370,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3419,1 +3380,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3445,1 +3405,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3451,1 +3410,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3457,1 +3415,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3462,1 +3419,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3475,1 +3431,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3481,1 +3436,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3496,1 +3450,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3510,1 +3463,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3524,1 +3476,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3532,1 +3483,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3540,1 +3490,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3548,1 +3497,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3558,1 +3506,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3565,1 +3512,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3576,1 +3522,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3584,1 +3529,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3591,1 +3535,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3606,1 +3549,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3614,1 +3556,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3621,1 +3562,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3628,1 +3568,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3634,1 +3573,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3640,1 +3578,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3646,1 +3583,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3652,1 +3588,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3665,1 +3600,0 @@\n-     C2_MacroAssembler _masm(&cbuf);\n@@ -3676,2 +3610,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-\n@@ -3693,1 +3625,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -3704,1 +3636,1 @@\n-        cbuf.shared_stub_to_interp_for(_method, call - cbuf.insts_begin());\n+        __ code()->shared_stub_to_interp_for(_method, call - __ begin());\n@@ -3707,1 +3639,1 @@\n-        address stub = CompiledDirectCall::emit_to_interp_stub(cbuf, call);\n+        address stub = CompiledDirectCall::emit_to_interp_stub(masm, call);\n@@ -3724,2 +3656,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    int method_index = resolved_method_index(cbuf);\n+    int method_index = resolved_method_index(masm);\n@@ -3738,1 +3669,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3746,2 +3676,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-\n@@ -3778,1 +3706,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3783,1 +3710,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3793,1 +3719,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3799,1 +3724,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -4568,1 +4492,1 @@\n-\/\/ Null Pointer Immediate\n+\/\/ nullptr Pointer Immediate\n@@ -4676,1 +4600,1 @@\n-\/\/ Narrow Null Pointer Immediate\n+\/\/ Narrow nullptr Pointer Immediate\n@@ -6771,1 +6695,1 @@\n-  format %{ \"mov  $dst, $con\\t# null pointer\" %}\n+  format %{ \"mov  $dst, $con\\t# nullptr ptr\" %}\n@@ -6785,1 +6709,1 @@\n-  format %{ \"mov  $dst, $con\\t# null pointer\" %}\n+  format %{ \"mov  $dst, $con\\t# nullptr ptr\" %}\n@@ -6827,1 +6751,1 @@\n-  format %{ \"mov  $dst, $con\\t# compressed null pointer\" %}\n+  format %{ \"mov  $dst, $con\\t# compressed nullptr ptr\" %}\n@@ -7738,1 +7662,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, tmp_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrs, tmp_reg, $mem->opcode(),\n@@ -7779,1 +7703,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, tmp_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrd, tmp_reg, $mem->opcode(),\n@@ -16280,0 +16204,33 @@\n+instruct partialSubtypeCheckConstSuper(iRegP_R4 sub, iRegP_R0 super_reg, immP super_con, vRegD_V0 vtemp, iRegP_R5 result,\n+                                       iRegP_R1 tempR1, iRegP_R2 tempR2, iRegP_R3 tempR3,\n+                                       rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP tempR1, TEMP tempR2, TEMP tempR3, TEMP vtemp);\n+\n+  ins_cost(700);  \/\/ smaller than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, super\" %}\n+\n+  ins_encode %{\n+    bool success = false;\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      success = __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register,\n+                                                 $tempR1$$Register, $tempR2$$Register, $tempR3$$Register,\n+                                                 $vtemp$$FloatRegister,\n+                                                 $result$$Register,\n+                                                 super_klass_slot);\n+    } else {\n+      address call = __ trampoline_call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n+      success = (call != nullptr);\n+    }\n+    if (!success) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n+    }\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -16873,1 +16830,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, $tsrc$$FloatRegister, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrs, $tsrc$$FloatRegister, $mem->opcode(),\n@@ -16910,1 +16867,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, $tsrc$$FloatRegister, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrd, $tsrc$$FloatRegister, $mem->opcode(),\n@@ -16947,1 +16904,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, $tsrc$$FloatRegister, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrs, $tsrc$$FloatRegister, $mem->opcode(),\n@@ -16985,1 +16942,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, $tsrc$$FloatRegister, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrd, $tsrc$$FloatRegister, $mem->opcode(),\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":116,"deletions":159,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n+  static void loadStoreA_predicated(C2_MacroAssembler* masm, bool is_store, FloatRegister reg,\n@@ -122,1 +122,1 @@\n-      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n+      (masm->*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n@@ -172,1 +172,0 @@\n-      case Op_LoadVectorGather:\n@@ -174,1 +173,0 @@\n-      case Op_LoadVectorGatherMasked:\n@@ -183,0 +181,6 @@\n+      case Op_LoadVectorGather:\n+      case Op_LoadVectorGatherMasked:\n+        if (UseSVE == 0 || is_subword_type(bt)) {\n+          return false;\n+        }\n+        break;\n@@ -425,1 +429,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false,\n+    loadStoreA_predicated(masm, \/* is_store *\/ false,\n@@ -442,1 +446,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true,\n+    loadStoreA_predicated(masm, \/* is_store *\/ true,\n@@ -457,1 +461,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false, $dst$$FloatRegister,\n+    loadStoreA_predicated(masm, \/* is_store *\/ false, $dst$$FloatRegister,\n@@ -470,1 +474,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true, $src$$FloatRegister,\n+    loadStoreA_predicated(masm, \/* is_store *\/ true, $src$$FloatRegister,\n@@ -4932,1 +4936,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, false, $tmp$$FloatRegister,\n@@ -4953,1 +4957,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, false, $tmp$$FloatRegister,\n@@ -4980,1 +4984,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, false, $tmp$$FloatRegister,\n@@ -5008,1 +5012,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, false, $tmp$$FloatRegister,\n@@ -5033,1 +5037,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, true, $tmp$$FloatRegister,\n@@ -5055,1 +5059,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, true, $tmp$$FloatRegister,\n@@ -5081,1 +5085,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, true, $tmp$$FloatRegister,\n@@ -5108,1 +5112,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, true, $tmp$$FloatRegister,\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n+  static void loadStoreA_predicated(C2_MacroAssembler* masm, bool is_store, FloatRegister reg,\n@@ -112,1 +112,1 @@\n-      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n+      (masm->*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n@@ -364,1 +364,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false,\n+    loadStoreA_predicated(masm, \/* is_store *\/ false,\n@@ -381,1 +381,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true,\n+    loadStoreA_predicated(masm, \/* is_store *\/ true,\n@@ -396,1 +396,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false, $dst$$FloatRegister,\n+    loadStoreA_predicated(masm, \/* is_store *\/ false, $dst$$FloatRegister,\n@@ -409,1 +409,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true, $src$$FloatRegister,\n+    loadStoreA_predicated(masm, \/* is_store *\/ true, $src$$FloatRegister,\n@@ -3324,1 +3324,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, false, $tmp$$FloatRegister,\n@@ -3345,1 +3345,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, false, $tmp$$FloatRegister,\n@@ -3372,1 +3372,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, false, $tmp$$FloatRegister,\n@@ -3400,1 +3400,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, false, $tmp$$FloatRegister,\n@@ -3425,1 +3425,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, true, $tmp$$FloatRegister,\n@@ -3447,1 +3447,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, true, $tmp$$FloatRegister,\n@@ -3473,1 +3473,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, true, $tmp$$FloatRegister,\n@@ -3500,1 +3500,1 @@\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+    loadStoreA_predicated(masm, true, $tmp$$FloatRegister,\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-    $4choose(C2_MacroAssembler(&cbuf), $1_reg,$2,$mem->opcode(),\n+    $4choose(masm, $1_reg,$2,$mem->opcode(),\n@@ -62,2 +62,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    choose(_masm,zr,$2,$mem->opcode(),\n+    choose(masm,zr,$2,$mem->opcode(),\n@@ -75,1 +74,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -88,1 +86,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -90,1 +87,1 @@\n-      loadStore(_masm, &MacroAssembler::strb, zr, $mem->opcode(),\n+      loadStore(masm, &MacroAssembler::strb, zr, $mem->opcode(),\n","filename":"src\/hotspot\/cpu\/aarch64\/ad_encode.m4","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -2598,0 +2598,1 @@\n+  \/\/ Advanced SIMD across lanes\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -171,2 +171,4 @@\n-      LIR_Opr tmp = new_pointer_register();\n-      __ shift_left(index, shift, tmp);\n+      \/\/ Use long register to avoid overflow when shifting large index values left.\n+      LIR_Opr tmp = new_register(T_LONG);\n+      __ convert(Bytecodes::_i2l, index, tmp);\n+      __ shift_left(tmp, shift, tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,4 +37,4 @@\n-#define __ _masm.\n-address CompiledDirectCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark) {\n-  precond(cbuf.stubs()->start() != badAddress);\n-  precond(cbuf.stubs()->end() != badAddress);\n+#define __ masm->\n+address CompiledDirectCall::emit_to_interp_stub(MacroAssembler *masm, address mark) {\n+  precond(__ code()->stubs()->start() != badAddress);\n+  precond(__ code()->stubs()->end() != badAddress);\n@@ -48,1 +48,1 @@\n-    mark = cbuf.insts_mark();  \/\/ Get mark within main instrs section.\n+    mark = __ inst_mark();  \/\/ Get mark within main instrs section.\n@@ -51,4 +51,0 @@\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a stub.\n-  MacroAssembler _masm(&cbuf);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  return (cb()->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -36,1 +35,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -41,1 +40,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -45,1 +43,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -80,1 +78,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register, \/*acquire*\/ false, \/*release*\/ true, \/*is_cae*\/ false, $res$$Register);\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register, \/*acquire*\/ false, \/*release*\/ true, \/*is_cae*\/ false, $res$$Register);\n@@ -118,1 +116,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register, \/*acquire*\/ true, \/*release*\/ true, \/*is_cae*\/ false, $res$$Register);\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register, \/*acquire*\/ true, \/*release*\/ true, \/*is_cae*\/ false, $res$$Register);\n@@ -134,1 +132,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -150,1 +148,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -167,1 +165,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -184,1 +182,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -202,1 +200,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -219,1 +217,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -238,1 +236,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -257,1 +255,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoah_aarch64.ad","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-static void x_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) {\n+static void x_load_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) {\n@@ -45,1 +45,1 @@\n-static void x_load_barrier_slow_path(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {\n+static void x_load_barrier_slow_path(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {\n@@ -67,1 +67,1 @@\n-    x_load_barrier(_masm, this, ref_addr, $dst$$Register, rscratch2 \/* tmp *\/, barrier_data());\n+    x_load_barrier(masm, this, ref_addr, $dst$$Register, rscratch2 \/* tmp *\/, barrier_data());\n@@ -86,1 +86,1 @@\n-    x_load_barrier(_masm, this, Address($mem$$Register), $dst$$Register, rscratch2 \/* tmp *\/, barrier_data());\n+    x_load_barrier(masm, this, Address($mem$$Register), $dst$$Register, rscratch2 \/* tmp *\/, barrier_data());\n@@ -113,1 +113,1 @@\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), rscratch2 \/* ref *\/, rscratch1 \/* tmp *\/);\n+      x_load_barrier_slow_path(masm, this, Address($mem$$Register), rscratch2 \/* ref *\/, rscratch1 \/* tmp *\/);\n@@ -145,1 +145,1 @@\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), rscratch2 \/* ref *\/, rscratch1 \/* tmp *\/ );\n+      x_load_barrier_slow_path(masm, this, Address($mem$$Register), rscratch2 \/* ref *\/, rscratch1 \/* tmp *\/ );\n@@ -174,1 +174,1 @@\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, rscratch1 \/* tmp *\/);\n+      x_load_barrier_slow_path(masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, rscratch1 \/* tmp *\/);\n@@ -202,1 +202,1 @@\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, rscratch1 \/* tmp *\/);\n+      x_load_barrier_slow_path(masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, rscratch1 \/* tmp *\/);\n@@ -223,1 +223,1 @@\n-    x_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, rscratch2 \/* tmp *\/, barrier_data());\n+    x_load_barrier(masm, this, Address(noreg, 0), $prev$$Register, rscratch2 \/* tmp *\/, barrier_data());\n@@ -240,1 +240,1 @@\n-    x_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, rscratch2 \/* tmp *\/, barrier_data());\n+    x_load_barrier(masm, this, Address(noreg, 0), $prev$$Register, rscratch2 \/* tmp *\/, barrier_data());\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/x\/x_aarch64.ad","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1084,0 +1084,29 @@\n+OptoReg::Name ZBarrierSetAssembler::encode_float_vector_register_size(const Node* node, OptoReg::Name opto_reg) {\n+  switch (node->ideal_reg()) {\n+    case Op_RegF:\n+      \/\/ No need to refine. The original encoding is already fine to distinguish.\n+      assert(opto_reg % 4 == 0, \"Float register should only occupy a single slot\");\n+      break;\n+    \/\/ Use different encoding values of the same fp\/vector register to help distinguish different sizes.\n+    \/\/ Such as V16. The OptoReg::name and its corresponding slot value are\n+    \/\/ \"V16\": 64, \"V16_H\": 65, \"V16_J\": 66, \"V16_K\": 67.\n+    case Op_RegD:\n+    case Op_VecD:\n+      opto_reg &= ~3;\n+      opto_reg |= 1;\n+      break;\n+    case Op_VecX:\n+      opto_reg &= ~3;\n+      opto_reg |= 2;\n+      break;\n+    case Op_VecA:\n+      opto_reg &= ~3;\n+      opto_reg |= 3;\n+      break;\n+    default:\n+      assert(false, \"unexpected ideal register\");\n+      ShouldNotReachHere();\n+  }\n+  return opto_reg;\n+}\n+\n@@ -1091,1 +1120,1 @@\n-    return opto_reg & ~1;\n+    opto_reg = encode_float_vector_register_size(node, opto_reg);\n@@ -1102,0 +1131,10 @@\n+  struct RegisterData {\n+    VMReg _reg;\n+    int   _slots; \/\/ slots occupied once pushed into stack\n+\n+    \/\/ Used by GrowableArray::find()\n+    bool operator == (const RegisterData& other) {\n+      return _reg == other._reg;\n+    }\n+  };\n+\n@@ -1105,0 +1144,2 @@\n+  FloatRegSet           _neon_regs;\n+  FloatRegSet           _sve_regs;\n@@ -1109,1 +1150,4 @@\n-    \/\/ Record registers that needs to be saved\/restored\n+    int index = -1;\n+    GrowableArray<RegisterData> registers;\n+    VMReg prev_vm_reg = VMRegImpl::Bad();\n+\n@@ -1112,6 +1156,41 @@\n-      const OptoReg::Name opto_reg = rmi.next();\n-      if (OptoReg::is_reg(opto_reg)) {\n-        const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n-        if (vm_reg->is_Register()) {\n-          _gp_regs += RegSet::of(vm_reg->as_Register());\n-        } else if (vm_reg->is_FloatRegister()) {\n+      OptoReg::Name opto_reg = rmi.next();\n+      VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+\n+      if (vm_reg->is_Register()) {\n+        \/\/ GPR may have one or two slots in regmask\n+        \/\/ Determine whether the current vm_reg is the same physical register as the previous one\n+        if (is_same_register(vm_reg, prev_vm_reg)) {\n+          registers.at(index)._slots++;\n+        } else {\n+          RegisterData reg_data = { vm_reg, 1 };\n+          index = registers.append(reg_data);\n+        }\n+      } else if (vm_reg->is_FloatRegister()) {\n+        \/\/ We have size encoding in OptoReg of stub->live()\n+        \/\/ After encoding, float\/neon\/sve register has only one slot in regmask\n+        \/\/ Decode it to get the actual size\n+        VMReg vm_reg_base = vm_reg->as_FloatRegister()->as_VMReg();\n+        int slots = decode_float_vector_register_size(opto_reg);\n+        RegisterData reg_data = { vm_reg_base, slots };\n+        index = registers.append(reg_data);\n+      } else if (vm_reg->is_PRegister()) {\n+        \/\/ PRegister has only one slot in regmask\n+        RegisterData reg_data = { vm_reg, 1 };\n+        index = registers.append(reg_data);\n+      } else {\n+        assert(false, \"Unknown register type\");\n+        ShouldNotReachHere();\n+      }\n+      prev_vm_reg = vm_reg;\n+    }\n+\n+    \/\/ Record registers that needs to be saved\/restored\n+    for (GrowableArrayIterator<RegisterData> it = registers.begin(); it != registers.end(); ++it) {\n+      RegisterData reg_data = *it;\n+      VMReg vm_reg = reg_data._reg;\n+      int slots = reg_data._slots;\n+      if (vm_reg->is_Register()) {\n+        assert(slots == 1 || slots == 2, \"Unexpected register save size\");\n+        _gp_regs += RegSet::of(vm_reg->as_Register());\n+      } else if (vm_reg->is_FloatRegister()) {\n+        if (slots == 1 || slots == 2) {\n@@ -1119,2 +1198,2 @@\n-        } else if (vm_reg->is_PRegister()) {\n-          _p_regs += PRegSet::of(vm_reg->as_PRegister());\n+        } else if (slots == 4) {\n+          _neon_regs += FloatRegSet::of(vm_reg->as_FloatRegister());\n@@ -1122,1 +1201,2 @@\n-          fatal(\"Unknown register type\");\n+          assert(slots == Matcher::scalable_vector_reg_size(T_FLOAT), \"Unexpected register save size\");\n+          _sve_regs += FloatRegSet::of(vm_reg->as_FloatRegister());\n@@ -1124,0 +1204,3 @@\n+      } else {\n+        assert(vm_reg->is_PRegister() && slots == 1, \"Unknown register type\");\n+        _p_regs += PRegSet::of(vm_reg->as_PRegister());\n@@ -1133,0 +1216,51 @@\n+\n+    \/\/ Remove C-ABI SOE fp registers\n+    _fp_regs -= FloatRegSet::range(v8, v15);\n+  }\n+\n+  static enum RC rc_class(VMReg reg) {\n+    if (reg->is_reg()) {\n+      if (reg->is_Register()) {\n+        return rc_int;\n+      } else if (reg->is_FloatRegister()) {\n+        return rc_float;\n+      } else if (reg->is_PRegister()) {\n+        return rc_predicate;\n+      }\n+    }\n+    if (reg->is_stack()) {\n+      return rc_stack;\n+    }\n+    return rc_bad;\n+  }\n+\n+  static bool is_same_register(VMReg reg1, VMReg reg2) {\n+    if (reg1 == reg2) {\n+      return true;\n+    }\n+    if (rc_class(reg1) == rc_class(reg2)) {\n+      if (reg1->is_Register()) {\n+        return reg1->as_Register() == reg2->as_Register();\n+      } else if (reg1->is_FloatRegister()) {\n+        return reg1->as_FloatRegister() == reg2->as_FloatRegister();\n+      } else if (reg1->is_PRegister()) {\n+        return reg1->as_PRegister() == reg2->as_PRegister();\n+      }\n+    }\n+    return false;\n+  }\n+\n+  static int decode_float_vector_register_size(OptoReg::Name opto_reg) {\n+    switch (opto_reg & 3) {\n+      case 0:\n+        return 1;\n+      case 1:\n+        return 2;\n+      case 2:\n+        return 4;\n+      case 3:\n+        return Matcher::scalable_vector_reg_size(T_FLOAT);\n+      default:\n+        ShouldNotReachHere();\n+        return 0;\n+    }\n@@ -1139,0 +1273,2 @@\n+      _neon_regs(),\n+      _sve_regs(),\n@@ -1146,1 +1282,3 @@\n-    __ push_fp(_fp_regs, sp);\n+    __ push_fp(_fp_regs, sp, MacroAssembler::PushPopFp);\n+    __ push_fp(_neon_regs, sp, MacroAssembler::PushPopNeon);\n+    __ push_fp(_sve_regs, sp, MacroAssembler::PushPopSVE);\n@@ -1153,1 +1291,3 @@\n-    __ pop_fp(_fp_regs, sp);\n+    __ pop_fp(_sve_regs, sp, MacroAssembler::PushPopSVE);\n+    __ pop_fp(_neon_regs, sp, MacroAssembler::PushPopNeon);\n+    __ pop_fp(_fp_regs, sp, MacroAssembler::PushPopFp);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":154,"deletions":14,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,0 +190,3 @@\n+  OptoReg::Name encode_float_vector_register_size(const Node* node,\n+                                                  OptoReg::Name opto_reg);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-static void z_color(MacroAssembler& _masm, const MachNode* node, Register dst, Register src) {\n+static void z_color(MacroAssembler* masm, const MachNode* node, Register dst, Register src) {\n@@ -43,1 +43,1 @@\n-static void z_uncolor(MacroAssembler& _masm, const MachNode* node, Register ref) {\n+static void z_uncolor(MacroAssembler* masm, const MachNode* node, Register ref) {\n@@ -47,1 +47,1 @@\n-static void z_keep_alive_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {\n+static void z_keep_alive_load_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {\n@@ -53,1 +53,1 @@\n-  z_uncolor(_masm, node, ref);\n+  z_uncolor(masm, node, ref);\n@@ -57,2 +57,2 @@\n-static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(&_masm);\n+static void z_load_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {\n+  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -64,1 +64,1 @@\n-    z_keep_alive_load_barrier(_masm, node, ref_addr, ref, tmp);\n+    z_keep_alive_load_barrier(masm, node, ref_addr, ref, tmp);\n@@ -69,1 +69,1 @@\n-    z_uncolor(_masm, node, ref);\n+    z_uncolor(masm, node, ref);\n@@ -84,1 +84,1 @@\n-  z_uncolor(_masm, node, ref);\n+  z_uncolor(masm, node, ref);\n@@ -88,2 +88,2 @@\n-static void z_store_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register rnew_zaddress, Register rnew_zpointer, Register tmp, bool is_atomic) {\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(&_masm);\n+static void z_store_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register rnew_zaddress, Register rnew_zpointer, Register tmp, bool is_atomic) {\n+  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -91,1 +91,1 @@\n-    z_color(_masm, node, rnew_zpointer, rnew_zaddress);\n+    z_color(masm, node, rnew_zpointer, rnew_zaddress);\n@@ -96,1 +96,1 @@\n-    bs_asm->store_barrier_fast(&_masm, ref_addr, rnew_zaddress, rnew_zpointer, tmp, true \/* in_nmethod *\/, is_atomic, *stub->entry(), *stub->continuation());\n+    bs_asm->store_barrier_fast(masm, ref_addr, rnew_zaddress, rnew_zpointer, tmp, true \/* in_nmethod *\/, is_atomic, *stub->entry(), *stub->continuation());\n@@ -116,1 +116,1 @@\n-    z_load_barrier(_masm, this, ref_addr, $dst$$Register, rscratch1);\n+    z_load_barrier(masm, this, ref_addr, $dst$$Register, rscratch1);\n@@ -136,1 +136,1 @@\n-    z_load_barrier(_masm, this, ref_addr, $dst$$Register, rscratch1);\n+    z_load_barrier(masm, this, ref_addr, $dst$$Register, rscratch1);\n@@ -153,1 +153,1 @@\n-    z_store_barrier(_masm, this, ref_addr, $src$$Register, $tmp$$Register, rscratch2, false \/* is_atomic *\/);\n+    z_store_barrier(masm, this, ref_addr, $src$$Register, $tmp$$Register, rscratch2, false \/* is_atomic *\/);\n@@ -170,1 +170,1 @@\n-    z_store_barrier(_masm, this, ref_addr, $src$$Register, $tmp$$Register, rscratch2, false \/* is_atomic *\/);\n+    z_store_barrier(masm, this, ref_addr, $src$$Register, $tmp$$Register, rscratch2, false \/* is_atomic *\/);\n@@ -190,2 +190,2 @@\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, rscratch2, true \/* is_atomic *\/);\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register);\n+    z_store_barrier(masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, rscratch2, true \/* is_atomic *\/);\n+    z_color(masm, this, $oldval_tmp$$Register, $oldval$$Register);\n@@ -214,2 +214,2 @@\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, rscratch2, true \/* is_atomic *\/);\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register);\n+    z_store_barrier(masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, rscratch2, true \/* is_atomic *\/);\n+    z_color(masm, this, $oldval_tmp$$Register, $oldval$$Register);\n@@ -238,2 +238,2 @@\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, rscratch2, true \/* is_atomic *\/);\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register);\n+    z_store_barrier(masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, rscratch2, true \/* is_atomic *\/);\n+    z_color(masm, this, $oldval_tmp$$Register, $oldval$$Register);\n@@ -242,1 +242,1 @@\n-    z_uncolor(_masm, this, $res$$Register);\n+    z_uncolor(masm, this, $res$$Register);\n@@ -261,2 +261,2 @@\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, rscratch2, true \/* is_atomic *\/);\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register);\n+    z_store_barrier(masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, rscratch2, true \/* is_atomic *\/);\n+    z_color(masm, this, $oldval_tmp$$Register, $oldval$$Register);\n@@ -265,1 +265,1 @@\n-    z_uncolor(_masm, this, $res$$Register);\n+    z_uncolor(masm, this, $res$$Register);\n@@ -281,1 +281,1 @@\n-    z_store_barrier(_masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, rscratch2, true \/* is_atomic *\/);\n+    z_store_barrier(masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, rscratch2, true \/* is_atomic *\/);\n@@ -283,1 +283,1 @@\n-    z_uncolor(_masm, this, $prev$$Register);\n+    z_uncolor(masm, this, $prev$$Register);\n@@ -299,1 +299,1 @@\n-    z_store_barrier(_masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, rscratch2, true \/* is_atomic *\/);\n+    z_store_barrier(masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, rscratch2, true \/* is_atomic *\/);\n@@ -301,1 +301,1 @@\n-    z_uncolor(_masm, this, $prev$$Register);\n+    z_uncolor(masm, this, $prev$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -193,5 +193,0 @@\n-    \/\/ Check if the secondary index definition is still ~x, otherwise\n-    \/\/ we have to change the following assembler code to calculate the\n-    \/\/ plain index.\n-    assert(ConstantPool::decode_invokedynamic_index(~123) == 123, \"else change next line\");\n-    eonw(index, index, zr);  \/\/ convert to plain index\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -1517,0 +1517,3 @@\n+  \/\/ NB! Callers may assume that, when temp2_reg is a valid register,\n+  \/\/ this code sets it to a nonzero value.\n+\n@@ -1596,0 +1599,235 @@\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS                    \\\n+do {                                                               \\\n+  assert(r_super_klass  == r0                                   && \\\n+         r_array_base   == r1                                   && \\\n+         r_array_length == r2                                   && \\\n+         (r_array_index == r3        || r_array_index == noreg) && \\\n+         (r_sub_klass   == r4        || r_sub_klass   == noreg) && \\\n+         (r_bitmap      == rscratch2 || r_bitmap      == noreg) && \\\n+         (result        == r5        || result        == noreg), \"registers must match aarch64.ad\"); \\\n+} while(0)\n+\n+\/\/ Return true: we succeeded in generating this code\n+bool MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   FloatRegister vtemp,\n+                                                   Register result,\n+                                                   u1 super_klass_slot,\n+                                                   bool stub_is_near) {\n+  assert_different_registers(r_sub_klass, temp1, temp2, temp3, result, rscratch1, rscratch2);\n+\n+  Label L_fallthrough;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_base   = temp1, \/\/ r1\n+    r_array_length = temp2, \/\/ r2\n+    r_array_index  = temp3, \/\/ r3\n+    r_bitmap       = rscratch2;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  u1 bit = super_klass_slot;\n+\n+  \/\/ Make sure that result is nonzero if the TBZ below misses.\n+  mov(result, 1);\n+\n+  \/\/ We're going to need the bitmap in a vector reg and in a core reg,\n+  \/\/ so load both now.\n+  ldr(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  if (bit != 0) {\n+    ldrd(vtemp, Address(r_sub_klass, Klass::bitmap_offset()));\n+  }\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  tbz(r_bitmap, bit, L_fallthrough);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    shld(vtemp, vtemp, Klass::SECONDARY_SUPERS_TABLE_MASK - bit);\n+    cnt(vtemp, T8B, vtemp);\n+    addv(vtemp, T8B, vtemp);\n+    fmovd(r_array_index, vtemp);\n+  } else {\n+    mov(r_array_index, (u1)1);\n+  }\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  \/\/ We will consult the secondary-super array.\n+  ldr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the\n+  \/\/ data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  ldr(result, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+  eor(result, result, r_super_klass);\n+  cbz(result, L_fallthrough); \/\/ Found a match\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  tbz(r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK, L_fallthrough);\n+\n+  \/\/ Linear probe.\n+  if (bit != 0) {\n+    ror(r_bitmap, r_bitmap, bit);\n+  }\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the stub we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  Address stub = RuntimeAddress(StubRoutines::lookup_secondary_supers_table_slow_path_stub());\n+  if (stub_is_near) {\n+    bl(stub);\n+  } else {\n+    address call = trampoline_call(stub);\n+    if (call == nullptr) {\n+      return false; \/\/ trampoline allocation failed\n+    }\n+  }\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  bind(L_fallthrough);\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, \/\/ r4, r0\n+                                  temp1, temp2, result);      \/\/ r1, r2, r5\n+  }\n+  return true;\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register temp1,\n+                                                             Register result) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, temp1, result, rscratch1);\n+\n+  const Register\n+    r_array_length = temp1,\n+    r_sub_klass    = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  Label L_fallthrough, L_huge;\n+\n+  \/\/ Load the array length.\n+  ldrw(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB! Effectively increments current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  add(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ The bitmap is full to bursting.\n+  \/\/ Implicit invariant: BITMAP_FULL implies (length > 0)\n+  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n+  cmn(r_bitmap, (u1)1);\n+  br(EQ, L_huge);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+    Label L_loop;\n+    bind(L_loop);\n+\n+    \/\/ Check for wraparound.\n+    cmp(r_array_index, r_array_length);\n+    csel(r_array_index, zr, r_array_index, GE);\n+\n+    ldr(rscratch1, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+    eor(result, rscratch1, r_super_klass);\n+    cbz(result, L_fallthrough);\n+\n+    tbz(r_bitmap, 2, L_fallthrough); \/\/ look-ahead check (Bit 2); result is non-zero\n+\n+    ror(r_bitmap, r_bitmap, 1);\n+    add(r_array_index, r_array_index, 1);\n+    b(L_loop);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    bind(L_huge);\n+    cmp(sp, zr); \/\/ Clear Z flag; SP is never zero\n+    repne_scan(r_array_base, r_super_klass, r_array_length, rscratch1);\n+    cset(result, NE); \/\/ result == 0 iff we got a match.\n+  }\n+\n+  bind(L_fallthrough);\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register result) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, result, rscratch1);\n+\n+  const Register\n+    r_array_base   = temp1,\n+    r_array_length = temp2,\n+    r_array_index  = noreg, \/\/ unused\n+    r_bitmap       = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  \/\/ We will consult the secondary-super array.\n+  ldr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ Load the array length.\n+  ldrw(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  add(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  cmp(sp, zr); \/\/ Clear Z flag; SP is never zero\n+  \/\/ Scan R2 words at [R5] for an occurrence of R0.\n+  \/\/ Set NZ\/Z based on last compare.\n+  repne_scan(\/*addr*\/r_array_base, \/*value*\/r_super_klass, \/*count*\/r_array_length, rscratch2);\n+  \/\/ rscratch1 == 0 iff we got a match.\n+  cset(rscratch1, NE);\n+\n+  Label passed;\n+  cmp(result, zr);\n+  cset(result, NE); \/\/ normalize result to 0\/1 for comparison\n+\n+  cmp(rscratch1, result);\n+  br(EQ, passed);\n+  {\n+    mov(r0, r_super_klass);         \/\/ r0 <- r0\n+    mov(r1, r_sub_klass);           \/\/ r1 <- r4\n+    mov(r2, \/*expected*\/rscratch1); \/\/ r2 <- r8\n+    mov(r3, result);                \/\/ r3 <- r5\n+    mov(r4, (address)(\"mismatch\")); \/\/ r4 <- const\n+    rt_call(CAST_FROM_FN_PTR(address, Klass::on_secondary_supers_verification_failure), rscratch2);\n+    should_not_reach_here();\n+  }\n+  bind(passed);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n@@ -2406,1 +2644,1 @@\n-int MacroAssembler::push_fp(unsigned int bitset, Register stack) {\n+int MacroAssembler::push_fp(unsigned int bitset, Register stack, FpPushPopMode mode) {\n@@ -2429,2 +2667,23 @@\n-  \/\/ SVE\n-  if (use_sve && sve_vector_size_in_bytes > 16) {\n+  if (mode == PushPopFull) {\n+    if (use_sve && sve_vector_size_in_bytes > 16) {\n+      mode = PushPopSVE;\n+    } else {\n+      mode = PushPopNeon;\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  {\n+    char buffer[48];\n+    if (mode == PushPopSVE) {\n+      snprintf(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n+    } else if (mode == PushPopNeon) {\n+      snprintf(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n+    } else {\n+      snprintf(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n+    }\n+    block_comment(buffer);\n+  }\n+#endif\n+\n+  if (mode == PushPopSVE) {\n@@ -2438,4 +2697,25 @@\n-  \/\/ NEON\n-  if (count == 1) {\n-    strq(as_FloatRegister(regs[0]), Address(pre(stack, -wordSize * 2)));\n-    return 2;\n+  if (mode == PushPopNeon) {\n+    if (count == 1) {\n+      strq(as_FloatRegister(regs[0]), Address(pre(stack, -wordSize * 2)));\n+      return 2;\n+    }\n+\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n+\n+    \/\/ Always pushing full 128 bit registers.\n+    stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -push_slots * wordSize * 2)));\n+    words_pushed += 2;\n+\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+      words_pushed += 2;\n+    }\n+\n+    if (odd) {\n+      strq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n+      words_pushed++;\n+    }\n+\n+    assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n+    return count * 2;\n@@ -2444,2 +2724,3 @@\n-  bool odd = (count & 1) == 1;\n-  int push_slots = count + (odd ? 1 : 0);\n+  if (mode == PushPopFp) {\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n@@ -2447,3 +2728,5 @@\n-  \/\/ Always pushing full 128 bit registers.\n-  stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -push_slots * wordSize * 2)));\n-  words_pushed += 2;\n+    if (count == 1) {\n+      \/\/ Stack pointer must be 16 bytes aligned\n+      strd(as_FloatRegister(regs[0]), Address(pre(stack, -push_slots * wordSize)));\n+      return 1;\n+    }\n@@ -2451,2 +2734,1 @@\n-  for (int i = 2; i + 1 < count; i += 2) {\n-    stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+    stpd(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -push_slots * wordSize)));\n@@ -2454,1 +2736,0 @@\n-  }\n@@ -2456,3 +2737,14 @@\n-  if (odd) {\n-    strq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n-    words_pushed++;\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      stpd(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize));\n+      words_pushed += 2;\n+    }\n+\n+    if (odd) {\n+      \/\/ Stack pointer must be 16 bytes aligned\n+      strd(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize));\n+      words_pushed++;\n+    }\n+\n+    assert(words_pushed == count, \"oops, pushed != count\");\n+\n+    return count;\n@@ -2461,2 +2753,1 @@\n-  assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n-  return count * 2;\n+  return 0;\n@@ -2466,1 +2757,1 @@\n-int MacroAssembler::pop_fp(unsigned int bitset, Register stack) {\n+int MacroAssembler::pop_fp(unsigned int bitset, Register stack, FpPushPopMode mode) {\n@@ -2488,2 +2779,23 @@\n-  \/\/ SVE\n-  if (use_sve && sve_vector_size_in_bytes > 16) {\n+  if (mode == PushPopFull) {\n+    if (use_sve && sve_vector_size_in_bytes > 16) {\n+      mode = PushPopSVE;\n+    } else {\n+      mode = PushPopNeon;\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  {\n+    char buffer[48];\n+    if (mode == PushPopSVE) {\n+      snprintf(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n+    } else if (mode == PushPopNeon) {\n+      snprintf(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n+    } else {\n+      snprintf(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n+    }\n+    block_comment(buffer);\n+  }\n+#endif\n+\n+  if (mode == PushPopSVE) {\n@@ -2497,5 +2809,5 @@\n-  \/\/ NEON\n-  if (count == 1) {\n-    ldrq(as_FloatRegister(regs[0]), Address(post(stack, wordSize * 2)));\n-    return 2;\n-  }\n+  if (mode == PushPopNeon) {\n+    if (count == 1) {\n+      ldrq(as_FloatRegister(regs[0]), Address(post(stack, wordSize * 2)));\n+      return 2;\n+    }\n@@ -2503,2 +2815,2 @@\n-  bool odd = (count & 1) == 1;\n-  int push_slots = count + (odd ? 1 : 0);\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n@@ -2506,4 +2818,9 @@\n-  if (odd) {\n-    ldrq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n-    words_pushed++;\n-  }\n+    if (odd) {\n+      ldrq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n+      words_pushed++;\n+    }\n+\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+      words_pushed += 2;\n+    }\n@@ -2511,2 +2828,1 @@\n-  for (int i = 2; i + 1 < count; i += 2) {\n-    ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+    ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, push_slots * wordSize * 2)));\n@@ -2514,0 +2830,4 @@\n+\n+    assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n+\n+    return count * 2;\n@@ -2516,2 +2836,8 @@\n-  ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, push_slots * wordSize * 2)));\n-  words_pushed += 2;\n+  if (mode == PushPopFp) {\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n+\n+    if (count == 1) {\n+      ldrd(as_FloatRegister(regs[0]), Address(post(stack, push_slots * wordSize)));\n+      return 1;\n+    }\n@@ -2519,1 +2845,17 @@\n-  assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n+    if (odd) {\n+      ldrd(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize));\n+      words_pushed++;\n+    }\n+\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      ldpd(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize));\n+      words_pushed += 2;\n+    }\n+\n+    ldpd(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, push_slots * wordSize)));\n+    words_pushed += 2;\n+\n+    assert(words_pushed == count, \"oops, pushed != count\");\n+\n+    return count;\n+  }\n@@ -2521,1 +2863,1 @@\n-  return count * 2;\n+  return 0;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":383,"deletions":41,"binary":false,"changes":424,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -447,0 +447,9 @@\n+public:\n+\n+  enum FpPushPopMode {\n+    PushPopFull,\n+    PushPopSVE,\n+    PushPopNeon,\n+    PushPopFp\n+  };\n+\n@@ -456,2 +465,2 @@\n-  int push_fp(unsigned int bitset, Register stack);\n-  int pop_fp(unsigned int bitset, Register stack);\n+  int push_fp(unsigned int bitset, Register stack, FpPushPopMode mode);\n+  int pop_fp(unsigned int bitset, Register stack, FpPushPopMode mode);\n@@ -465,0 +474,1 @@\n+\n@@ -468,2 +478,2 @@\n-  void push_fp(FloatRegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }\n-  void pop_fp(FloatRegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }\n+  void push_fp(FloatRegSet regs, Register stack, FpPushPopMode mode = PushPopFull) { if (regs.bits()) push_fp(regs.bits(), stack, mode); }\n+  void pop_fp(FloatRegSet regs, Register stack, FpPushPopMode mode = PushPopFull) { if (regs.bits()) pop_fp(regs.bits(), stack, mode); }\n@@ -1002,0 +1012,25 @@\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  bool lookup_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     FloatRegister vtemp,\n+                                     Register result,\n+                                     u1 super_klass_slot,\n+                                     bool stub_is_near = false);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register result);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register temp1,\n+                                               Register result);\n+\n@@ -1216,0 +1251,1 @@\n+  \/\/ Clobbers: rscratch1\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -136,0 +136,5 @@\n+  \/\/ Does target support predicated operation emulation.\n+  static bool supports_vector_predicate_op_emulation(int vopc, int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1041,1 +1041,0 @@\n-\n@@ -1044,0 +1043,41 @@\n+\n+  if (CheckJNICalls) {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n+    __ cbzw(rscratch1, L_skip_vthread_code);\n+\n+    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n+    \/\/ it failed to release a JNI monitor. So we issue the same log message\n+    \/\/ that JavaThread::exit does.\n+    __ ldr(rscratch1, Address(rthread, JavaThread::jni_monitor_count_offset()));\n+    __ cbz(rscratch1, L_skip_vthread_code);\n+\n+    \/\/ Save return value potentially containing the exception oop in callee-saved R19.\n+    __ mov(r19, r0);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n+    \/\/ Restore potential return value.\n+    __ mov(r0, r19);\n+\n+    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n+    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n+    \/\/ the parent held count (which has to be zero).\n+    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n+    __ cbzw(rscratch1, L_skip_vthread_code);\n+\n+    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n+    \/\/ needed for assertion checking.\n+    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#endif\n+\n@@ -1111,2 +1151,1 @@\n-    CodeBuffer* cbuf = masm->code_section()->outer();\n-    address stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, tr_call);\n+    address stub = CompiledDirectCall::emit_to_interp_stub(masm, tr_call);\n@@ -1176,2 +1215,1 @@\n-  CodeBuffer* cbuf = masm->code_section()->outer();\n-  address stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, tr_call);\n+  address stub = CompiledDirectCall::emit_to_interp_stub(masm, tr_call);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  int argsize = is_compiled() ? (_cb->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n+  int argsize = is_compiled() ? (_cb->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2022, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -1522,1 +1522,1 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n@@ -1524,1 +1524,1 @@\n-      UnsafeCopyMemoryMark ucmm(this, add_entry, true);\n+      UnsafeMemoryAccessMark umam(this, add_entry, true);\n@@ -1593,1 +1593,1 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n@@ -1595,1 +1595,1 @@\n-      UnsafeCopyMemoryMark ucmm(this, add_entry, true);\n+      UnsafeMemoryAccessMark umam(this, add_entry, true);\n@@ -6775,0 +6775,46 @@\n+  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = r0,\n+      r_array_base   = r1,\n+      r_array_length = r2,\n+      r_array_index  = r3,\n+      r_sub_klass    = r4,\n+      r_bitmap       = rscratch2,\n+      result         = r5;\n+    const FloatRegister\n+      vtemp          = v0;\n+\n+    Label L_success;\n+    __ enter();\n+    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                     r_array_base, r_array_length, r_array_index,\n+                                     vtemp, result, super_klass_index,\n+                                     \/*stub_is_near*\/true);\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = r0,        \/\/ argument\n+      r_array_base   = r1,        \/\/ argument\n+      temp1          = r2,        \/\/ temp\n+      r_array_index  = r3,        \/\/ argument\n+      r_bitmap       = rscratch2, \/\/ argument\n+      result         = r5;        \/\/ argument\n+\n+    __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index, r_bitmap, temp1, result);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -8335,2 +8381,2 @@\n-    if (UnsafeCopyMemory::_table == nullptr) {\n-      UnsafeCopyMemory::create_table(8);\n+    if (UnsafeMemoryAccess::_table == nullptr) {\n+      UnsafeMemoryAccess::create_table(8 + 4); \/\/ 8 for copyMemory; 4 for setMemory\n@@ -8425,0 +8471,10 @@\n+    if (UseSecondarySupersTable) {\n+      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+      if (! InlineSecondarySupersTest) {\n+        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n+            = generate_lookup_secondary_supers_table_stub(slot);\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":63,"deletions":7,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -3614,1 +3614,1 @@\n-  \/\/ test to see if it has a finalizer or is malformed in some way\n+  \/\/ test to see if it is malformed in some way\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,0 +174,2 @@\n+  constexpr static bool supports_secondary_supers_table() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-  assert( is_FloatRegister() && is_even(value()), \"must be\" );\n+  assert( is_FloatRegister(), \"must be\" );\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,2 +108,2 @@\n-  static int emit_exception_handler(CodeBuffer &cbuf);\n-  static int emit_deopt_handler(CodeBuffer& cbuf);\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n+  static int emit_deopt_handler(C2_MacroAssembler* masm);\n@@ -141,1 +141,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -162,2 +162,1 @@\n-void emit_break(CodeBuffer &cbuf) {\n-  C2_MacroAssembler _masm(&cbuf);\n+void emit_break(C2_MacroAssembler *masm) {\n@@ -173,2 +172,2 @@\n-void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  emit_break(cbuf);\n+void MachBreakpointNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  emit_break(masm);\n@@ -182,2 +181,1 @@\n-void emit_nop(CodeBuffer &cbuf) {\n-  C2_MacroAssembler _masm(&cbuf);\n+void emit_nop(C2_MacroAssembler *masm) {\n@@ -188,1 +186,1 @@\n-void emit_call_reloc(CodeBuffer &cbuf, const MachCallNode *n, MachOper *m, RelocationHolder const& rspec) {\n+void emit_call_reloc(C2_MacroAssembler *masm, const MachCallNode *n, MachOper *m, RelocationHolder const& rspec) {\n@@ -190,2 +188,1 @@\n-  int call_site_offset = cbuf.insts()->mark_off();\n-  C2_MacroAssembler _masm(&cbuf);\n+  int call_site_offset = __ code()->insts()->mark_off();\n@@ -213,2 +210,2 @@\n-void emit_lo(CodeBuffer &cbuf, int val) {  }\n-void emit_hi(CodeBuffer &cbuf, int val) {  }\n+void emit_lo(C2_MacroAssembler *masm, int val) {  }\n+void emit_hi(C2_MacroAssembler *masm, int val) {  }\n@@ -235,1 +232,1 @@\n-void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n@@ -238,1 +235,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -306,1 +302,1 @@\n-void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -308,1 +304,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -337,1 +332,1 @@\n-    bs->nmethod_entry_barrier(&_masm);\n+    bs->nmethod_entry_barrier(masm);\n@@ -341,1 +336,1 @@\n-  if (strcmp(cbuf.name(), \"Compile::Fill_buffer\") == 0) {\n+  if (strcmp(__ code()->name(), \"Compile::Fill_buffer\") == 0) {\n@@ -382,2 +377,1 @@\n-void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n+void MachEpilogNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -433,1 +427,1 @@\n-uint MachSpillCopyNode::implementation( CodeBuffer *cbuf,\n+uint MachSpillCopyNode::implementation( C2_MacroAssembler *masm,\n@@ -466,2 +460,0 @@\n-  C2_MacroAssembler _masm(cbuf);\n-\n@@ -473,1 +465,1 @@\n-    if (cbuf && !is_memoryfp(offset)) {\n+    if (masm && !is_memoryfp(offset)) {\n@@ -483,1 +475,1 @@\n-        if (cbuf) {\n+        if (masm) {\n@@ -491,1 +483,1 @@\n-        if (cbuf) {\n+        if (masm) {\n@@ -510,1 +502,1 @@\n-    if (cbuf) {\n+    if (masm) {\n@@ -525,1 +517,1 @@\n-    if (cbuf && !is_memoryI(offset)) {\n+    if (masm && !is_memoryI(offset)) {\n@@ -531,1 +523,1 @@\n-        if (cbuf) {\n+        if (masm) {\n@@ -541,1 +533,1 @@\n-        if (cbuf) {\n+        if (masm) {\n@@ -557,1 +549,1 @@\n-    if (cbuf && !is_memoryI(offset)) {\n+    if (masm && !is_memoryI(offset)) {\n@@ -563,1 +555,1 @@\n-        if (cbuf) {\n+        if (masm) {\n@@ -573,1 +565,1 @@\n-        if (cbuf) {\n+        if (masm) {\n@@ -590,1 +582,1 @@\n-      if (cbuf) {\n+      if (masm) {\n@@ -601,1 +593,1 @@\n-    if (cbuf) {\n+    if (masm) {\n@@ -616,1 +608,1 @@\n-    if (cbuf && !is_memoryfp(offset)) {\n+    if (masm && !is_memoryfp(offset)) {\n@@ -623,1 +615,1 @@\n-        if (cbuf) {\n+        if (masm) {\n@@ -633,1 +625,1 @@\n-        if (cbuf) {\n+        if (masm) {\n@@ -649,1 +641,1 @@\n-    if (cbuf && !is_memoryfp(offset)) {\n+    if (masm && !is_memoryfp(offset)) {\n@@ -656,1 +648,1 @@\n-        if (cbuf) {\n+        if (masm) {\n@@ -666,1 +658,1 @@\n-        if (cbuf) {\n+        if (masm) {\n@@ -686,1 +678,1 @@\n-      if (cbuf) {\n+      if (masm) {\n@@ -696,1 +688,1 @@\n-      if (cbuf) {\n+      if (masm) {\n@@ -715,1 +707,1 @@\n-      if (cbuf) {\n+      if (masm) {\n@@ -725,1 +717,1 @@\n-      if (cbuf) {\n+      if (masm) {\n@@ -749,1 +741,1 @@\n-    if (cbuf) {\n+    if (masm) {\n@@ -766,1 +758,1 @@\n-    if (cbuf && !is_memoryP(offset)) {\n+    if (masm && !is_memoryP(offset)) {\n@@ -770,1 +762,1 @@\n-      if (cbuf) {\n+      if (masm) {\n@@ -785,1 +777,1 @@\n-    if (cbuf && !is_memoryP(offset)) {\n+    if (masm && !is_memoryP(offset)) {\n@@ -789,1 +781,1 @@\n-      if (cbuf) {\n+      if (masm) {\n@@ -807,1 +799,1 @@\n-  implementation(nullptr, ra_, false, st );\n+  implementation( nullptr, ra_, false, st );\n@@ -811,2 +803,2 @@\n-void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  implementation( &cbuf, ra_, false, nullptr );\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation( masm, ra_, false, nullptr );\n@@ -826,2 +818,1 @@\n-void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc * ) const {\n-  C2_MacroAssembler _masm(&cbuf);\n+void MachNopNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc * ) const {\n@@ -847,2 +838,1 @@\n-void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n+void BoxLockNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -878,2 +868,1 @@\n-void MachUEPNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n+void MachUEPNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -891,3 +880,1 @@\n-int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf) {\n-  C2_MacroAssembler _masm(&cbuf);\n-\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n@@ -912,1 +899,1 @@\n-int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf) {\n+int HandlerImpl::emit_deopt_handler(C2_MacroAssembler* masm) {\n@@ -915,2 +902,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n-\n@@ -1211,0 +1196,12 @@\n+  \/\/ Set instruction mark in MacroAssembler. This is used only in\n+  \/\/ instructions that emit bytes directly to the CodeBuffer wraped\n+  \/\/ in the MacroAssembler. Should go away once all \"instruct\" are\n+  \/\/ patched to emit bytes only using methods in MacroAssembler.\n+  enc_class SetInstMark %{\n+    __ set_inst_mark();\n+  %}\n+\n+  enc_class ClearInstMark %{\n+    __ clear_inst_mark();\n+  %}\n+\n@@ -1217,1 +1214,1 @@\n-    emit_call_reloc(cbuf, as_MachCall(), $meth, runtime_call_Relocation::spec());\n+    emit_call_reloc(masm, as_MachCall(), $meth, runtime_call_Relocation::spec());\n@@ -1225,1 +1222,1 @@\n-      emit_call_reloc(cbuf, as_MachCall(), $meth, runtime_call_Relocation::spec());\n+      emit_call_reloc(masm, as_MachCall(), $meth, runtime_call_Relocation::spec());\n@@ -1227,1 +1224,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -1230,1 +1227,1 @@\n-      emit_call_reloc(cbuf, as_MachCall(), $meth, rspec);\n+      emit_call_reloc(masm, as_MachCall(), $meth, rspec);\n@@ -1233,1 +1230,1 @@\n-      address stub = CompiledDirectCall::emit_to_interp_stub(cbuf);\n+      address stub = CompiledDirectCall::emit_to_interp_stub(masm);\n@@ -1243,3 +1240,2 @@\n-    address mark = cbuf.insts()->mark();\n-    debug_only(int off0 = cbuf.insts_size());\n-    C2_MacroAssembler _masm(&cbuf);\n+    address mark = __ inst_mark();\n+    debug_only(int off0 = __ offset());\n@@ -1249,1 +1245,1 @@\n-    debug_only(int off1 = cbuf.insts_size());\n+    debug_only(int off1 = __ offset());\n@@ -1252,1 +1248,1 @@\n-    cbuf.insts()->set_mark(mark);\n+    __ set_inst_mark(mark);\n@@ -1257,3 +1253,2 @@\n-    address mark = cbuf.insts()->mark();\n-    debug_only(int off0 = cbuf.insts_size());\n-    C2_MacroAssembler _masm(&cbuf);\n+    address mark = __ inst_mark();\n+    debug_only(int off0 = __ offset());\n@@ -1263,1 +1258,1 @@\n-    debug_only(int off1 = cbuf.insts_size());\n+    debug_only(int off1 = __ offset());\n@@ -1266,1 +1261,1 @@\n-    cbuf.insts()->set_mark(mark);\n+    __ set_inst_mark(mark);\n@@ -1270,1 +1265,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1275,1 +1269,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1284,1 +1277,1 @@\n-    int method_index = resolved_method_index(cbuf);\n+    int method_index = resolved_method_index(masm);\n@@ -1286,1 +1279,1 @@\n-    emit_call_reloc(cbuf, as_MachCall(), $meth, RelocationHolder::none);\n+    emit_call_reloc(masm, as_MachCall(), $meth, RelocationHolder::none);\n@@ -1303,1 +1296,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1320,1 +1312,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1335,1 +1326,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1427,1 +1417,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1489,1 +1478,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -8850,1 +8838,1 @@\n-  ins_encode( Java_Static_Call( meth ), call_epilog );\n+  ins_encode( SetInstMark, Java_Static_Call( meth ), call_epilog, ClearInstMark );\n@@ -8864,1 +8852,1 @@\n-  ins_encode( preserve_SP, Java_Static_Call( meth ), restore_SP, call_epilog );\n+  ins_encode( SetInstMark, preserve_SP, Java_Static_Call( meth ), restore_SP, call_epilog, ClearInstMark );\n@@ -8876,1 +8864,1 @@\n-  ins_encode( Java_Dynamic_Call( meth ), call_epilog );\n+  ins_encode( SetInstMark, Java_Dynamic_Call( meth ), call_epilog, ClearInstMark );\n@@ -8886,2 +8874,2 @@\n-  ins_encode( Java_To_Runtime( meth ),\n-              call_epilog );\n+  ins_encode( SetInstMark, Java_To_Runtime( meth ),\n+              call_epilog, ClearInstMark );\n@@ -8898,2 +8886,2 @@\n-  ins_encode( Java_To_Runtime( meth ),\n-              call_epilog );\n+  ins_encode( SetInstMark, Java_To_Runtime( meth ),\n+              call_epilog, ClearInstMark );\n@@ -8910,2 +8898,2 @@\n-  ins_encode( Java_To_Runtime( meth ),\n-              call_epilog );\n+  ins_encode( SetInstMark, Java_To_Runtime( meth ),\n+              call_epilog, ClearInstMark );\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":88,"deletions":100,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-                                       int header_size, int element_size,\n+                                       int header_size_in_bytes, int element_size,\n@@ -159,1 +159,0 @@\n-  const int header_size_in_bytes = header_size * BytesPerWord;\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -39,1 +39,1 @@\n-address CompiledDirectCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark) {\n+address CompiledDirectCall::emit_to_interp_stub(MacroAssembler *masm, address mark) {\n@@ -46,1 +46,1 @@\n-    mark = cbuf.insts_mark();  \/\/ get mark within main instrs section\n+    mark = __ inst_mark();  \/\/ get mark within main instrs section\n@@ -49,2 +49,0 @@\n-  MacroAssembler _masm(&cbuf);\n-\n","filename":"src\/hotspot\/cpu\/arm\/compiledIC_arm.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -214,5 +214,0 @@\n-    \/\/ Check if the secondary index definition is still ~x, otherwise\n-    \/\/ we have to change the following assembler code to calculate the\n-    \/\/ plain index.\n-    assert(ConstantPool::decode_invokedynamic_index(~123) == 123, \"else change next line\");\n-    mvn_32(index, index);  \/\/ convert to plain index\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -129,0 +129,5 @@\n+  \/\/ Does target support predicated operation emulation.\n+  static bool supports_vector_predicate_op_emulation(int vopc, int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -959,2 +959,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n-      UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+      UnsafeMemoryAccessMark umam(this, unsafe_copy, true);\n@@ -1108,2 +1108,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n-      UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+      UnsafeMemoryAccessMark umam(this, unsafe_copy, true);\n@@ -1764,2 +1764,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n-      UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+      UnsafeMemoryAccessMark umam(this, unsafe_copy, true);\n@@ -1903,2 +1903,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n-      UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+      UnsafeMemoryAccessMark umam(this, unsafe_copy, true);\n@@ -2061,2 +2061,2 @@\n-      \/\/ UnsafeCopyMemoryMark page error: continue at UnsafeCopyMemory common_error_exit\n-      UnsafeCopyMemoryMark ucmm(this, !aligned, false);\n+      \/\/ UnsafeMemoryAccessMark page error: continue at UnsafeMemoryAccess common_error_exit\n+      UnsafeMemoryAccessMark umam(this, !aligned, false);\n@@ -2095,1 +2095,1 @@\n-      min_copy = generate_forward_aligned_copy_loop(from, to, count, bytes_per_count, !aligned \/*add UnsafeCopyMemory entry*\/);\n+      min_copy = generate_forward_aligned_copy_loop(from, to, count, bytes_per_count, !aligned \/*add UnsafeMemoryAccess entry*\/);\n@@ -2097,1 +2097,1 @@\n-      min_copy = generate_backward_aligned_copy_loop(from, to, count, bytes_per_count, !aligned \/*add UnsafeCopyMemory entry*\/);\n+      min_copy = generate_backward_aligned_copy_loop(from, to, count, bytes_per_count, !aligned \/*add UnsafeMemoryAccess entry*\/);\n@@ -2108,1 +2108,1 @@\n-      copy_small_array(from, to, count, tmp1, tmp2, bytes_per_count, forward, L_small_array \/* entry *\/, !aligned \/*add UnsafeCopyMemory entry*\/);\n+      copy_small_array(from, to, count, tmp1, tmp2, bytes_per_count, forward, L_small_array \/* entry *\/, !aligned \/*add UnsafeMemoryAccess entry*\/);\n@@ -2119,1 +2119,1 @@\n-      int min_copy_shifted = align_dst_and_generate_shifted_copy_loop(from, to, count, bytes_per_count, forward, !aligned \/*add UnsafeCopyMemory entry*\/);\n+      int min_copy_shifted = align_dst_and_generate_shifted_copy_loop(from, to, count, bytes_per_count, forward, !aligned \/*add UnsafeMemoryAccess entry*\/);\n@@ -2865,1 +2865,1 @@\n-    UnsafeCopyMemory::set_common_exit_stub_pc(ucm_common_error_exit);\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n@@ -3137,2 +3137,2 @@\n-    if (UnsafeCopyMemory::_table == nullptr) {\n-      UnsafeCopyMemory::create_table(32);\n+    if (UnsafeMemoryAccess::_table == nullptr) {\n+      UnsafeMemoryAccess::create_table(32 + 4); \/\/ 32 for copyMemory; 4 for setMemory\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3974,1 +3974,1 @@\n-  \/\/ make sure klass is initialized & doesn't have finalizer\n+  \/\/ make sure klass is initialized\n@@ -3983,1 +3983,1 @@\n-  \/\/ test to see if it has a finalizer or is malformed in some way\n+  \/\/ test to see if it is malformed in some way\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,2 +168,4 @@\n-      LIR_Opr tmp = new_pointer_register();\n-      __ shift_left(index, shift, tmp);\n+      \/\/ Use long register to avoid overflow when shifting large index values left.\n+      LIR_Opr tmp = new_register(T_LONG);\n+      __ convert(Bytecodes::_i2l, index, tmp);\n+      __ shift_left(tmp, shift, tmp);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,2 +80,2 @@\n-#define __ _masm.\n-address CompiledDirectCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark\/* = nullptr*\/) {\n+#define __ masm->\n+address CompiledDirectCall::emit_to_interp_stub(MacroAssembler *masm, address mark\/* = nullptr*\/) {\n@@ -85,1 +85,1 @@\n-    mark = cbuf.insts_mark();\n+    mark = __ inst_mark();\n@@ -88,4 +88,0 @@\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a stub.\n-  MacroAssembler _masm(&cbuf);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/compiledIC_ppc.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  return (cb()->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        &_masm,\n+        masm,\n@@ -68,1 +68,1 @@\n-        &_masm,\n+        masm,\n@@ -89,1 +89,1 @@\n-        &_masm,\n+        masm,\n@@ -115,1 +115,1 @@\n-        &_masm,\n+        masm,\n@@ -140,1 +140,1 @@\n-        &_masm,\n+        masm,\n@@ -160,1 +160,1 @@\n-        &_masm,\n+        masm,\n@@ -180,1 +180,1 @@\n-        &_masm,\n+        masm,\n@@ -205,1 +205,1 @@\n-        &_masm,\n+        masm,\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoah_ppc.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static void x_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref,\n+static void x_load_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref,\n@@ -48,1 +48,1 @@\n-static void x_load_barrier_slow_path(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref,\n+static void x_load_barrier_slow_path(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref,\n@@ -55,1 +55,1 @@\n-static void x_compare_and_swap(MacroAssembler& _masm, const MachNode* node,\n+static void x_compare_and_swap(MacroAssembler* masm, const MachNode* node,\n@@ -73,1 +73,1 @@\n-    x_load_barrier_slow_path(_masm, node, Address(mem), tmp_xchg, res \/* used as tmp *\/);\n+    x_load_barrier_slow_path(masm, node, Address(mem), tmp_xchg, res \/* used as tmp *\/);\n@@ -92,1 +92,1 @@\n-static void x_compare_and_exchange(MacroAssembler& _masm, const MachNode* node,\n+static void x_compare_and_exchange(MacroAssembler* masm, const MachNode* node,\n@@ -107,1 +107,1 @@\n-    x_load_barrier_slow_path(_masm, node, Address(mem), res, tmp);\n+    x_load_barrier_slow_path(masm, node, Address(mem), res, tmp);\n@@ -141,1 +141,1 @@\n-    x_load_barrier(_masm, this, Address($mem$$base$$Register, $mem$$disp), $dst$$Register, $tmp$$Register, barrier_data());\n+    x_load_barrier(masm, this, Address($mem$$base$$Register, $mem$$disp), $dst$$Register, $tmp$$Register, barrier_data());\n@@ -159,1 +159,1 @@\n-    x_load_barrier(_masm, this, Address($mem$$base$$Register, $mem$$disp), $dst$$Register, $tmp$$Register, barrier_data());\n+    x_load_barrier(masm, this, Address($mem$$base$$Register, $mem$$disp), $dst$$Register, $tmp$$Register, barrier_data());\n@@ -178,1 +178,1 @@\n-    x_compare_and_swap(_masm, this,\n+    x_compare_and_swap(masm, this,\n@@ -196,1 +196,1 @@\n-    x_compare_and_swap(_masm, this,\n+    x_compare_and_swap(masm, this,\n@@ -214,1 +214,1 @@\n-    x_compare_and_swap(_masm, this,\n+    x_compare_and_swap(masm, this,\n@@ -232,1 +232,1 @@\n-    x_compare_and_swap(_masm, this,\n+    x_compare_and_swap(masm, this,\n@@ -253,1 +253,1 @@\n-    x_compare_and_exchange(_masm, this,\n+    x_compare_and_exchange(masm, this,\n@@ -273,1 +273,1 @@\n-    x_compare_and_exchange(_masm, this,\n+    x_compare_and_exchange(masm, this,\n@@ -289,1 +289,1 @@\n-    x_load_barrier(_masm, this, Address(noreg, (intptr_t) 0), $res$$Register, $tmp$$Register, barrier_data());\n+    x_load_barrier(masm, this, Address(noreg, (intptr_t) 0), $res$$Register, $tmp$$Register, barrier_data());\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/x\/x_ppc.ad","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-static void z_color(MacroAssembler& _masm, Register dst, Register src) {\n+static void z_color(MacroAssembler* masm, Register dst, Register src) {\n@@ -50,1 +50,1 @@\n-static void z_uncolor(MacroAssembler& _masm, Register ref) {\n+static void z_uncolor(MacroAssembler* masm, Register ref) {\n@@ -54,1 +54,1 @@\n-static void check_color(MacroAssembler& _masm, Register ref, bool on_non_strong) {\n+static void check_color(MacroAssembler* masm, Register ref, bool on_non_strong) {\n@@ -61,2 +61,2 @@\n-static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref) {\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(&_masm);\n+static void z_load_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref) {\n+  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -64,1 +64,1 @@\n-    z_uncolor(_masm, ref);\n+    z_uncolor(masm, ref);\n@@ -70,1 +70,1 @@\n-    check_color(_masm, ref, on_non_strong);\n+    check_color(masm, ref, on_non_strong);\n@@ -75,1 +75,1 @@\n-    z_uncolor(_masm, ref);\n+    z_uncolor(masm, ref);\n@@ -80,2 +80,2 @@\n-static void z_store_barrier(MacroAssembler& _masm, const MachNode* node, Register ref_base, intptr_t disp, Register rnew_zaddress, Register rnew_zpointer, bool is_atomic) {\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(&_masm);\n+static void z_store_barrier(MacroAssembler* masm, const MachNode* node, Register ref_base, intptr_t disp, Register rnew_zaddress, Register rnew_zpointer, bool is_atomic) {\n+  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -83,1 +83,1 @@\n-    z_color(_masm, rnew_zpointer, rnew_zaddress);\n+    z_color(masm, rnew_zpointer, rnew_zaddress);\n@@ -88,1 +88,1 @@\n-    bs_asm->store_barrier_fast(&_masm, ref_base, disp, rnew_zaddress, rnew_zpointer, true \/* in_nmethod *\/, is_atomic, *stub->entry(), *stub->continuation());\n+    bs_asm->store_barrier_fast(masm, ref_base, disp, rnew_zaddress, rnew_zpointer, true \/* in_nmethod *\/, is_atomic, *stub->entry(), *stub->continuation());\n@@ -92,1 +92,1 @@\n-static void z_compare_and_swap(MacroAssembler& _masm, const MachNode* node,\n+static void z_compare_and_swap(MacroAssembler* masm, const MachNode* node,\n@@ -97,2 +97,2 @@\n-  z_store_barrier(_masm, node, mem, 0, newval, rnew_zpointer, true \/* is_atomic *\/);\n-  z_color(_masm, rold_zpointer, oldval);\n+  z_store_barrier(masm, node, mem, 0, newval, rnew_zpointer, true \/* is_atomic *\/);\n+  z_color(masm, rold_zpointer, oldval);\n@@ -114,1 +114,1 @@\n-static void z_compare_and_exchange(MacroAssembler& _masm, const MachNode* node,\n+static void z_compare_and_exchange(MacroAssembler* masm, const MachNode* node,\n@@ -119,2 +119,2 @@\n-  z_store_barrier(_masm, node, mem, 0, newval, rnew_zpointer, true \/* is_atomic *\/);\n-  z_color(_masm, rold_zpointer, oldval);\n+  z_store_barrier(masm, node, mem, 0, newval, rnew_zpointer, true \/* is_atomic *\/);\n+  z_color(masm, rold_zpointer, oldval);\n@@ -124,1 +124,1 @@\n-  z_uncolor(_masm, res);\n+  z_uncolor(masm, res);\n@@ -152,1 +152,1 @@\n-    z_load_barrier(_masm, this, Address($mem$$base$$Register, $mem$$disp), $dst$$Register);\n+    z_load_barrier(masm, this, Address($mem$$base$$Register, $mem$$disp), $dst$$Register);\n@@ -170,1 +170,1 @@\n-    z_load_barrier(_masm, this, Address($mem$$base$$Register, $mem$$disp), $dst$$Register);\n+    z_load_barrier(masm, this, Address($mem$$base$$Register, $mem$$disp), $dst$$Register);\n@@ -189,1 +189,1 @@\n-    z_store_barrier(_masm, this, $mem$$base$$Register, $mem$$disp, $src$$Register, $tmp$$Register, false \/* is_atomic *\/);\n+    z_store_barrier(masm, this, $mem$$base$$Register, $mem$$disp, $src$$Register, $tmp$$Register, false \/* is_atomic *\/);\n@@ -203,1 +203,1 @@\n-    z_store_barrier(_masm, this, $mem$$base$$Register, $mem$$disp, noreg, $tmp$$Register, false \/* is_atomic *\/);\n+    z_store_barrier(masm, this, $mem$$base$$Register, $mem$$disp, noreg, $tmp$$Register, false \/* is_atomic *\/);\n@@ -220,1 +220,1 @@\n-    z_compare_and_swap(_masm, this,\n+    z_compare_and_swap(masm, this,\n@@ -239,1 +239,1 @@\n-    z_compare_and_swap(_masm, this,\n+    z_compare_and_swap(masm, this,\n@@ -260,1 +260,1 @@\n-    z_compare_and_exchange(_masm, this,\n+    z_compare_and_exchange(masm, this,\n@@ -280,1 +280,1 @@\n-    z_compare_and_exchange(_masm, this,\n+    z_compare_and_exchange(masm, this,\n@@ -296,1 +296,1 @@\n-    z_store_barrier(_masm, this, $mem$$Register, 0, $newval$$Register, rnew_zpointer, true \/* is_atomic *\/);\n+    z_store_barrier(masm, this, $mem$$Register, 0, $newval$$Register, rnew_zpointer, true \/* is_atomic *\/);\n@@ -298,1 +298,1 @@\n-    z_uncolor(_masm, result);\n+    z_uncolor(masm, result);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/z_ppc.ad","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -447,2 +447,0 @@\n-    assert(ConstantPool::decode_invokedynamic_index(~123) == 123, \"else change next line\");\n-    nand(Rdst, Rdst, Rdst); \/\/ convert to plain index\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,0 +136,5 @@\n+  \/\/ Does target support predicated operation emulation.\n+  static bool supports_vector_predicate_op_emulation(int vopc, int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1082,1 +1082,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -1192,2 +1192,1 @@\n-void emit_break(CodeBuffer &cbuf) {\n-  C2_MacroAssembler _masm(&cbuf);\n+void emit_break(C2_MacroAssembler *masm) {\n@@ -1203,2 +1202,2 @@\n-void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  emit_break(cbuf);\n+void MachBreakpointNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  emit_break(masm);\n@@ -1213,2 +1212,1 @@\n-void emit_nop(CodeBuffer &cbuf) {\n-  C2_MacroAssembler _masm(&cbuf);\n+void emit_nop(C2_MacroAssembler *masm) {\n@@ -1218,3 +1216,3 @@\n-static inline void emit_long(CodeBuffer &cbuf, int value) {\n-  *((int*)(cbuf.insts_end())) = value;\n-  cbuf.set_insts_end(cbuf.insts_end() + BytesPerInstWord);\n+static inline void emit_long(C2_MacroAssembler *masm, int value) {\n+  *((int*)(__ pc())) = value;\n+  __ set_inst_end(__ pc() + BytesPerInstWord);\n@@ -1240,1 +1238,1 @@\n-  static void emit_trampoline_stub(C2_MacroAssembler &_masm, int destination_toc_offset, int insts_call_instruction_offset);\n+  static void emit_trampoline_stub(C2_MacroAssembler *masm, int destination_toc_offset, int insts_call_instruction_offset);\n@@ -1271,1 +1269,1 @@\n-void CallStubImpl::emit_trampoline_stub(C2_MacroAssembler &_masm, int destination_toc_offset, int insts_call_instruction_offset) {\n+void CallStubImpl::emit_trampoline_stub(C2_MacroAssembler *masm, int destination_toc_offset, int insts_call_instruction_offset) {\n@@ -1302,1 +1300,1 @@\n-EmitCallOffsets emit_call_with_trampoline_stub(C2_MacroAssembler &_masm, address entry_point, relocInfo::relocType rtype) {\n+EmitCallOffsets emit_call_with_trampoline_stub(C2_MacroAssembler *masm, address entry_point, relocInfo::relocType rtype) {\n@@ -1319,1 +1317,1 @@\n-  CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, offsets.insts_call_instruction_offset);\n+  CallStubImpl::emit_trampoline_stub(masm, entry_point_toc_offset, offsets.insts_call_instruction_offset);\n@@ -1369,1 +1367,1 @@\n-void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n@@ -1407,1 +1405,1 @@\n-void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1409,1 +1407,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1559,1 +1556,1 @@\n-    bs->nmethod_entry_barrier(&_masm, push_frame_temp);\n+    bs->nmethod_entry_barrier(masm, push_frame_temp);\n@@ -1562,1 +1559,1 @@\n-  C->output()->set_frame_complete(cbuf.insts_size());\n+  C->output()->set_frame_complete(__ offset());\n@@ -1591,1 +1588,1 @@\n-void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachEpilogNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1593,1 +1590,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1671,1 +1667,1 @@\n-static int ld_st_helper(CodeBuffer *cbuf, const char *op_str, uint opcode, int reg, int offset,\n+static int ld_st_helper(C2_MacroAssembler *masm, const char *op_str, uint opcode, int reg, int offset,\n@@ -1684,1 +1680,1 @@\n-  if (cbuf) {\n+  if (masm) {\n@@ -1689,1 +1685,1 @@\n-    emit_long(*cbuf, opcode | Assembler::rt(Matcher::_regEncode[reg]) | d | Assembler::ra(R1_SP));\n+    emit_long(masm, opcode | Assembler::rt(Matcher::_regEncode[reg]) | d | Assembler::ra(R1_SP));\n@@ -1702,1 +1698,1 @@\n-uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {\n+uint MachSpillCopyNode::implementation(C2_MacroAssembler *masm, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {\n@@ -1732,2 +1728,1 @@\n-      if (cbuf) {\n-        C2_MacroAssembler _masm(cbuf);\n+      if (masm) {\n@@ -1745,2 +1740,1 @@\n-      if (cbuf) {\n-        C2_MacroAssembler _masm(cbuf);\n+      if (masm) {\n@@ -1756,2 +1750,1 @@\n-      if (cbuf) {\n-        C2_MacroAssembler _masm(cbuf);\n+      if (masm) {\n@@ -1767,2 +1760,1 @@\n-      if (cbuf) {\n-        C2_MacroAssembler _masm(cbuf);\n+      if (masm) {\n@@ -1787,3 +1779,3 @@\n-      size += ld_st_helper(cbuf, \"LD  \", Assembler::LD_OPCODE,  R0_num, src_offset, !do_size, C, st);\n-      if (!cbuf && !do_size) st->print(\"\\n\\t\");\n-      size += ld_st_helper(cbuf, \"STD \", Assembler::STD_OPCODE, R0_num, dst_offset, !do_size, C, st);\n+      size += ld_st_helper(masm, \"LD  \", Assembler::LD_OPCODE,  R0_num, src_offset, !do_size, C, st);\n+      if (!masm && !do_size) st->print(\"\\n\\t\");\n+      size += ld_st_helper(masm, \"STD \", Assembler::STD_OPCODE, R0_num, dst_offset, !do_size, C, st);\n@@ -1791,3 +1783,3 @@\n-      size += ld_st_helper(cbuf, \"LWZ \", Assembler::LWZ_OPCODE, R0_num, src_offset, !do_size, C, st);\n-      if (!cbuf && !do_size) st->print(\"\\n\\t\");\n-      size += ld_st_helper(cbuf, \"STW \", Assembler::STW_OPCODE, R0_num, dst_offset, !do_size, C, st);\n+      size += ld_st_helper(masm, \"LWZ \", Assembler::LWZ_OPCODE, R0_num, src_offset, !do_size, C, st);\n+      if (!masm && !do_size) st->print(\"\\n\\t\");\n+      size += ld_st_helper(masm, \"STW \", Assembler::STW_OPCODE, R0_num, dst_offset, !do_size, C, st);\n@@ -1811,2 +1803,1 @@\n-      if (cbuf) {\n-        C2_MacroAssembler _masm(cbuf);\n+      if (masm) {\n@@ -1835,1 +1826,1 @@\n-      size += ld_st_helper(cbuf, \"STD \", Assembler::STD_OPCODE, src_lo, dst_offset, !do_size, C, st);\n+      size += ld_st_helper(masm, \"STD \", Assembler::STD_OPCODE, src_lo, dst_offset, !do_size, C, st);\n@@ -1837,1 +1828,1 @@\n-      size += ld_st_helper(cbuf, \"STW \", Assembler::STW_OPCODE, src_lo, dst_offset, !do_size, C, st);\n+      size += ld_st_helper(masm, \"STW \", Assembler::STW_OPCODE, src_lo, dst_offset, !do_size, C, st);\n@@ -1848,1 +1839,1 @@\n-      size += ld_st_helper(cbuf, \"LD  \", Assembler::LD_OPCODE, dst_lo, src_offset, !do_size, C, st);\n+      size += ld_st_helper(masm, \"LD  \", Assembler::LD_OPCODE, dst_lo, src_offset, !do_size, C, st);\n@@ -1850,1 +1841,1 @@\n-      size += ld_st_helper(cbuf, \"LWZ \", Assembler::LWZ_OPCODE, dst_lo, src_offset, !do_size, C, st);\n+      size += ld_st_helper(masm, \"LWZ \", Assembler::LWZ_OPCODE, dst_lo, src_offset, !do_size, C, st);\n@@ -1857,2 +1848,1 @@\n-    if (cbuf) {\n-      C2_MacroAssembler _masm(cbuf);\n+    if (masm) {\n@@ -1877,1 +1867,1 @@\n-      size += ld_st_helper(cbuf, \"STFD\", Assembler::STFD_OPCODE, src_lo, dst_offset, !do_size, C, st);\n+      size += ld_st_helper(masm, \"STFD\", Assembler::STFD_OPCODE, src_lo, dst_offset, !do_size, C, st);\n@@ -1879,1 +1869,1 @@\n-      size += ld_st_helper(cbuf, \"STFS\", Assembler::STFS_OPCODE, src_lo, dst_offset, !do_size, C, st);\n+      size += ld_st_helper(masm, \"STFS\", Assembler::STFS_OPCODE, src_lo, dst_offset, !do_size, C, st);\n@@ -1890,1 +1880,1 @@\n-      size += ld_st_helper(cbuf, \"LFD \", Assembler::LFD_OPCODE, dst_lo, src_offset, !do_size, C, st);\n+      size += ld_st_helper(masm, \"LFD \", Assembler::LFD_OPCODE, dst_lo, src_offset, !do_size, C, st);\n@@ -1892,1 +1882,1 @@\n-      size += ld_st_helper(cbuf, \"LFS \", Assembler::LFS_OPCODE, dst_lo, src_offset, !do_size, C, st);\n+      size += ld_st_helper(masm, \"LFS \", Assembler::LFS_OPCODE, dst_lo, src_offset, !do_size, C, st);\n@@ -1917,2 +1907,2 @@\n-void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  implementation(&cbuf, ra_, false, nullptr);\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation(masm, ra_, false, nullptr);\n@@ -1931,2 +1921,1 @@\n-void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *) const {\n-  C2_MacroAssembler _masm(&cbuf);\n+void MachNopNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *) const {\n@@ -1952,3 +1941,1 @@\n-void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n-\n+void BoxLockNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1977,1 +1964,1 @@\n-void MachUEPNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachUEPNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1979,2 +1966,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n-\n@@ -2000,2 +1985,2 @@\n-  static int emit_exception_handler(CodeBuffer &cbuf);\n-  static int emit_deopt_handler(CodeBuffer& cbuf);\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n+  static int emit_deopt_handler(C2_MacroAssembler* masm);\n@@ -2026,3 +2011,1 @@\n-int HandlerImpl::emit_exception_handler(CodeBuffer &cbuf) {\n-  C2_MacroAssembler _masm(&cbuf);\n-\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n@@ -2046,3 +2029,1 @@\n-int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf) {\n-  C2_MacroAssembler _masm(&cbuf);\n-\n+int HandlerImpl::emit_deopt_handler(C2_MacroAssembler* masm) {\n@@ -2424,1 +2405,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2430,1 +2410,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2437,1 +2416,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2444,1 +2422,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2452,2 +2429,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2460,2 +2435,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2469,2 +2442,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2477,2 +2448,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2486,1 +2455,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2495,1 +2463,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2505,1 +2472,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2511,2 +2477,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2534,3 +2498,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n-\n@@ -2768,2 +2729,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2802,2 +2761,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2938,1 +2895,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2944,1 +2900,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2952,1 +2907,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2958,1 +2912,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3157,2 +3110,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3170,2 +3121,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3183,1 +3132,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3188,3 +3136,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n-\n@@ -3200,3 +3145,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n-\n@@ -3212,2 +3154,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3222,2 +3162,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3231,2 +3169,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3260,2 +3196,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3336,1 +3270,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3390,2 +3323,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3396,1 +3327,1 @@\n-      emit_call_with_trampoline_stub(_masm, entry_point, relocInfo::runtime_call_type);\n+      emit_call_with_trampoline_stub(masm, entry_point, relocInfo::runtime_call_type);\n@@ -3416,1 +3347,1 @@\n-      CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, start_offset);\n+      CallStubImpl::emit_trampoline_stub(masm, entry_point_toc_offset, start_offset);\n@@ -3418,1 +3349,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -3426,1 +3357,1 @@\n-      cbuf.set_insts_mark();\n+      __ set_inst_mark();\n@@ -3430,1 +3361,2 @@\n-      address stub = CompiledDirectCall::emit_to_interp_stub(cbuf);\n+      address stub = CompiledDirectCall::emit_to_interp_stub(masm);\n+      __ clear_inst_mark();\n@@ -3441,3 +3373,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n-\n@@ -3453,1 +3382,1 @@\n-      CallStubImpl::emit_trampoline_stub(_masm, entry_point_const_toc_offset, __ offset());\n+      CallStubImpl::emit_trampoline_stub(masm, entry_point_const_toc_offset, __ offset());\n@@ -3469,1 +3398,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -3544,1 +3473,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3567,1 +3495,1 @@\n-      emit_call_with_trampoline_stub(_masm, (address)$meth$$method, relocInfo::none);\n+      emit_call_with_trampoline_stub(masm, (address)$meth$$method, relocInfo::none);\n@@ -3598,2 +3526,0 @@\n-\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3633,1 +3559,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -4088,1 +4013,1 @@\n-\/\/ Null Pointer Immediate\n+\/\/ nullptr Pointer Immediate\n@@ -14584,1 +14509,1 @@\n-    cbuf.set_insts_mark();\n+    __ set_inst_mark();\n@@ -14586,0 +14511,1 @@\n+    __ clear_inst_mark();\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":62,"deletions":136,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -1640,1 +1640,1 @@\n-\/\/   R8_ARG6, R9_ARG7, R10_ARG8\n+\/\/   R8_ARG6, R9_ARG7, R10_ARG8, R15_esp\n@@ -1655,0 +1655,48 @@\n+  __ st_ptr(tmp1, JavaThread::cont_fastpath_offset(), R16_thread);\n+\n+  if (CheckJNICalls) {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ lwz(R0, in_bytes(ContinuationEntry::flags_offset()), R1_SP);\n+    __ cmpwi(CCR0, R0, 0);\n+    __ beq(CCR0, L_skip_vthread_code);\n+\n+    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n+    \/\/ it failed to release a JNI monitor. So we issue the same log message\n+    \/\/ that JavaThread::exit does.\n+    __ ld(R0, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n+    __ cmpdi(CCR0, R0, 0);\n+    __ beq(CCR0, L_skip_vthread_code);\n+\n+    \/\/ Save return value potentially containing the exception oop\n+    Register ex_oop = R15_esp;   \/\/ nonvolatile register\n+    __ mr(ex_oop, R3_RET);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n+    \/\/ Restore potental return value\n+    __ mr(R3_RET, ex_oop);\n+\n+    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n+    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n+    \/\/ the parent held count (which has to be zero).\n+    __ li(tmp1, 0);\n+    __ std(tmp1, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ lwz(R0, in_bytes(ContinuationEntry::flags_offset()), R1_SP);\n+    __ cmpwi(CCR0, R0, 0);\n+    __ beq(CCR0, L_skip_vthread_code);\n+\n+    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n+    \/\/ needed for assertion checking.\n+    __ li(tmp1, 0);\n+    __ std(tmp1, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#endif\n+\n@@ -1657,1 +1705,0 @@\n-  __ st_ptr(tmp1, JavaThread::cont_fastpath_offset(), R16_thread);\n@@ -1763,2 +1810,1 @@\n-    CodeBuffer* cbuf = masm->code_section()->outer();\n-    stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, c2i_call_pc);\n+    stub = CompiledDirectCall::emit_to_interp_stub(masm, c2i_call_pc);\n@@ -1856,2 +1902,1 @@\n-  CodeBuffer* cbuf = masm->code_section()->outer();\n-  stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, call_pc);\n+  stub = CompiledDirectCall::emit_to_interp_stub(masm, call_pc);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":53,"deletions":8,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  int argsize = (_cb->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  int argsize = (_cb->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkFrameStream_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -964,1 +964,1 @@\n-  \/\/ This is common errorexit stub for UnsafeCopyMemory.\n+  \/\/ This is common errorexit stub for UnsafeMemoryAccess.\n@@ -1016,2 +1016,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit\n-      UnsafeCopyMemoryMark ucmm(this, !aligned, false);\n+      \/\/ UnsafeMemoryAccess page error: continue at UnsafeMemoryAccess common_error_exit\n+      UnsafeMemoryAccessMark umam(this, !aligned, false);\n@@ -1198,2 +1198,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit\n-      UnsafeCopyMemoryMark ucmm(this, !aligned, false);\n+      \/\/ UnsafeMemoryAccess page error: continue at UnsafeMemoryAccess common_error_exit\n+      UnsafeMemoryAccessMark umam(this, !aligned, false);\n@@ -1285,2 +1285,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit\n-      UnsafeCopyMemoryMark ucmm(this, !aligned, false);\n+      \/\/ UnsafeMemoryAccess page error: continue at UnsafeMemoryAccess common_error_exit\n+      UnsafeMemoryAccessMark umam(this, !aligned, false);\n@@ -1469,2 +1469,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit\n-      UnsafeCopyMemoryMark ucmm(this, !aligned, false);\n+      \/\/ UnsafeMemoryAccess page error: continue at UnsafeMemoryAccess common_error_exit\n+      UnsafeMemoryAccessMark umam(this, !aligned, false);\n@@ -1628,2 +1628,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit\n-      UnsafeCopyMemoryMark ucmm(this, !aligned, false);\n+      \/\/ UnsafeMemoryAccess page error: continue at UnsafeMemoryAccess common_error_exit\n+      UnsafeMemoryAccessMark umam(this, !aligned, false);\n@@ -1780,2 +1780,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit\n-      UnsafeCopyMemoryMark ucmm(this, !aligned, false);\n+      \/\/ UnsafeMemoryAccess page error: continue at UnsafeMemoryAccess common_error_exit\n+      UnsafeMemoryAccessMark umam(this, !aligned, false);\n@@ -1906,2 +1906,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit\n-      UnsafeCopyMemoryMark ucmm(this, !aligned, false);\n+      \/\/ UnsafeMemoryAccess page error: continue at UnsafeMemoryAccess common_error_exit\n+      UnsafeMemoryAccessMark umam(this, !aligned, false);\n@@ -2037,2 +2037,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit\n-      UnsafeCopyMemoryMark ucmm(this, !aligned, false);\n+      \/\/ UnsafeMemoryAccess page error: continue at UnsafeMemoryAccess common_error_exit\n+      UnsafeMemoryAccessMark umam(this, !aligned, false);\n@@ -3132,1 +3132,1 @@\n-    UnsafeCopyMemory::set_common_exit_stub_pc(ucm_common_error_exit);\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n@@ -4748,2 +4748,2 @@\n-    if (UnsafeCopyMemory::_table == nullptr) {\n-      UnsafeCopyMemory::create_table(8);\n+    if (UnsafeMemoryAccess::_table == nullptr) {\n+      UnsafeMemoryAccess::create_table(8 + 4); \/\/ 8 for copyMemory; 4 for setMemory\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3812,1 +3812,1 @@\n-    \/\/ Make sure klass does not have has_finalizer, or is abstract, or interface or java\/lang\/Class.\n+    \/\/ Make sure klass is not abstract, or interface or java\/lang\/Class.\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1873,1 +1873,0 @@\n-  INSN(vandn_vi,   0b1010111, 0b011, 0b000001);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,4 +38,4 @@\n-#define __ _masm.\n-address CompiledDirectCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark) {\n-  precond(cbuf.stubs()->start() != badAddress);\n-  precond(cbuf.stubs()->end() != badAddress);\n+#define __ masm->\n+address CompiledDirectCall::emit_to_interp_stub(MacroAssembler *masm, address mark) {\n+  precond(__ code()->stubs()->start() != badAddress);\n+  precond(__ code()->stubs()->end() != badAddress);\n@@ -48,1 +48,1 @@\n-    mark = cbuf.insts_mark();  \/\/ Get mark within main instrs section.\n+    mark = __ inst_mark();  \/\/ Get mark within main instrs section.\n@@ -51,4 +51,0 @@\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a stub.\n-  MacroAssembler _masm(&cbuf);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/compiledIC_riscv.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -281,0 +281,3 @@\n+    \/\/ Restore cpu control state after JNI call\n+    __ restore_cpu_control_state_after_jni(t0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    entry_frame_after_call_words                     =  34,\n+    entry_frame_after_call_words                     =  35,\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  return (cb()->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -65,1 +65,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -87,1 +87,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -109,1 +109,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -129,1 +129,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -149,1 +149,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -171,1 +171,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -192,1 +192,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -213,1 +213,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -233,1 +233,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -256,1 +256,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n@@ -279,1 +279,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm, $mem$$Register, tmp, $newval$$Register,\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoah_riscv.ad","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static void x_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data) {\n+static void x_load_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data) {\n@@ -46,1 +46,1 @@\n-static void x_load_barrier_slow_path(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {\n+static void x_load_barrier_slow_path(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {\n@@ -68,1 +68,1 @@\n-    x_load_barrier(_masm, this, ref_addr, $dst$$Register, $tmp$$Register \/* tmp *\/, barrier_data());\n+    x_load_barrier(masm, this, ref_addr, $dst$$Register, $tmp$$Register \/* tmp *\/, barrier_data());\n@@ -97,1 +97,1 @@\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $tmp$$Register \/* ref *\/, $res$$Register \/* tmp *\/);\n+      x_load_barrier_slow_path(masm, this, Address($mem$$Register), $tmp$$Register \/* ref *\/, $res$$Register \/* tmp *\/);\n@@ -131,1 +131,1 @@\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $tmp$$Register \/* ref *\/, $res$$Register \/* tmp *\/);\n+      x_load_barrier_slow_path(masm, this, Address($mem$$Register), $tmp$$Register \/* ref *\/, $res$$Register \/* tmp *\/);\n@@ -160,1 +160,1 @@\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, $tmp$$Register \/* tmp *\/);\n+      x_load_barrier_slow_path(masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, $tmp$$Register \/* tmp *\/);\n@@ -188,1 +188,1 @@\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, $tmp$$Register \/* tmp *\/);\n+      x_load_barrier_slow_path(masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, $tmp$$Register \/* tmp *\/);\n@@ -209,1 +209,1 @@\n-    x_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, $tmp$$Register \/* tmp *\/, barrier_data());\n+    x_load_barrier(masm, this, Address(noreg, 0), $prev$$Register, $tmp$$Register \/* tmp *\/, barrier_data());\n@@ -226,1 +226,1 @@\n-    x_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, $tmp$$Register \/* tmp *\/, barrier_data());\n+    x_load_barrier(masm, this, Address(noreg, 0), $prev$$Register, $tmp$$Register \/* tmp *\/, barrier_data());\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/x\/x_riscv.ad","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-static void z_color(MacroAssembler& _masm, const MachNode* node, Register dst, Register src, Register tmp) {\n+static void z_color(MacroAssembler* masm, const MachNode* node, Register dst, Register src, Register tmp) {\n@@ -46,1 +46,1 @@\n-static void z_uncolor(MacroAssembler& _masm, const MachNode* node, Register ref) {\n+static void z_uncolor(MacroAssembler* masm, const MachNode* node, Register ref) {\n@@ -50,1 +50,1 @@\n-static void check_color(MacroAssembler& _masm, Register ref, bool on_non_strong, Register result) {\n+static void check_color(MacroAssembler* masm, Register ref, bool on_non_strong, Register result) {\n@@ -59,1 +59,1 @@\n-static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {\n+static void z_load_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {\n@@ -65,1 +65,1 @@\n-    z_uncolor(_masm, node, ref);\n+    z_uncolor(masm, node, ref);\n@@ -71,1 +71,1 @@\n-  check_color(_masm, ref, on_non_strong, tmp);\n+  check_color(masm, ref, on_non_strong, tmp);\n@@ -76,1 +76,1 @@\n-  z_uncolor(_masm, node, ref);\n+  z_uncolor(masm, node, ref);\n@@ -80,1 +80,1 @@\n-static void z_store_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register rnew_zaddress, Register rnew_zpointer, Register tmp, bool is_atomic) {\n+static void z_store_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register rnew_zaddress, Register rnew_zpointer, Register tmp, bool is_atomic) {\n@@ -82,1 +82,1 @@\n-    z_color(_masm, node, rnew_zpointer, rnew_zaddress, tmp);\n+    z_color(masm, node, rnew_zpointer, rnew_zaddress, tmp);\n@@ -87,1 +87,1 @@\n-    bs_asm->store_barrier_fast(&_masm, ref_addr, rnew_zaddress, rnew_zpointer, tmp, true \/* in_nmethod *\/, is_atomic, *stub->entry(), *stub->continuation());\n+    bs_asm->store_barrier_fast(masm, ref_addr, rnew_zaddress, rnew_zpointer, tmp, true \/* in_nmethod *\/, is_atomic, *stub->entry(), *stub->continuation());\n@@ -106,1 +106,1 @@\n-    z_load_barrier(_masm, this, ref_addr, $dst$$Register, $tmp$$Register);\n+    z_load_barrier(masm, this, ref_addr, $dst$$Register, $tmp$$Register);\n@@ -123,1 +123,1 @@\n-    z_store_barrier(_masm, this, ref_addr, $src$$Register, $tmp1$$Register, $tmp2$$Register, false \/* is_atomic *\/);\n+    z_store_barrier(masm, this, ref_addr, $src$$Register, $tmp1$$Register, $tmp2$$Register, false \/* is_atomic *\/);\n@@ -144,2 +144,2 @@\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n+    z_color(masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n+    z_store_barrier(masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n@@ -167,2 +167,2 @@\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n+    z_color(masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n+    z_store_barrier(masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n@@ -188,2 +188,2 @@\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n+    z_color(masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n+    z_store_barrier(masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n@@ -191,1 +191,1 @@\n-    z_uncolor(_masm, this, $res$$Register);\n+    z_uncolor(masm, this, $res$$Register);\n@@ -210,2 +210,2 @@\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n+    z_color(masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n+    z_store_barrier(masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n@@ -213,1 +213,1 @@\n-    z_uncolor(_masm, this, $res$$Register);\n+    z_uncolor(masm, this, $res$$Register);\n@@ -229,1 +229,1 @@\n-    z_store_barrier(_masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, $tmp$$Register, true \/* is_atomic *\/);\n+    z_store_barrier(masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, $tmp$$Register, true \/* is_atomic *\/);\n@@ -231,1 +231,1 @@\n-    z_uncolor(_masm, this, $prev$$Register);\n+    z_uncolor(masm, this, $prev$$Register);\n@@ -247,1 +247,1 @@\n-    z_store_barrier(_masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, $tmp$$Register, true \/* is_atomic *\/);\n+    z_store_barrier(masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, $tmp$$Register, true \/* is_atomic *\/);\n@@ -249,1 +249,1 @@\n-    z_uncolor(_masm, this, $prev$$Register);\n+    z_uncolor(masm, this, $prev$$Register);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/z_riscv.ad","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -219,7 +219,0 @@\n-\n-    \/\/ Check if the secondary index definition is still ~x, otherwise\n-    \/\/ we have to change the following assembler code to calculate the\n-    \/\/ plain index.\n-    assert(ConstantPool::decode_invokedynamic_index(~123) == 123, \"else change next line\");\n-    xori(index, index, -1);\n-    sign_extend(index, index, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -231,2 +231,1 @@\n-                                         Register last_java_pc,\n-                                         Register tmp) {\n+                                         Register last_java_pc) {\n@@ -235,3 +234,3 @@\n-      sd(last_java_pc, Address(xthread,\n-                               JavaThread::frame_anchor_offset() +\n-                               JavaFrameAnchor::last_Java_pc_offset()));\n+    sd(last_java_pc, Address(xthread,\n+                             JavaThread::frame_anchor_offset() +\n+                             JavaFrameAnchor::last_Java_pc_offset()));\n@@ -241,4 +240,1 @@\n-  if (last_java_sp == sp) {\n-    mv(tmp, sp);\n-    last_java_sp = tmp;\n-  } else if (!last_java_sp->is_valid()) {\n+  if (!last_java_sp->is_valid()) {\n@@ -265,1 +261,1 @@\n-  set_last_Java_frame(last_java_sp, last_java_fp, noreg, tmp);\n+  set_last_Java_frame(last_java_sp, last_java_fp, noreg);\n@@ -724,1 +720,1 @@\n-  if (is_simm32(offset)) {\n+  if (is_valid_32bit_offset(offset)) {\n@@ -1170,0 +1166,13 @@\n+void MacroAssembler::restore_cpu_control_state_after_jni(Register tmp) {\n+  if (RestoreMXCSROnJNICalls) {\n+    Label skip_fsrmi;\n+    frrm(tmp);\n+    \/\/ Set FRM to the state we need. We do want Round to Nearest.\n+    \/\/ We don't want non-IEEE rounding modes.\n+    guarantee(RoundingMode::rne == 0, \"must be\");\n+    beqz(tmp, skip_fsrmi);        \/\/ Only reset FRM if it's wrong\n+    fsrmi(RoundingMode::rne);\n+    bind(skip_fsrmi);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  void set_last_Java_frame(Register last_java_sp, Register last_java_fp, Register last_java_pc, Register tmp);\n+  void set_last_Java_frame(Register last_java_sp, Register last_java_fp, Register last_java_pc);\n@@ -584,0 +584,3 @@\n+  \/\/ Restore cpu control state after JNI call\n+  void restore_cpu_control_state_after_jni(Register tmp);\n+\n@@ -681,0 +684,8 @@\n+  \/\/ The signed 20-bit upper imm can materialize at most negative 0xF...F80000000, two G.\n+  \/\/ The following signed 12-bit imm can at max subtract 0x800, two K, from that previously loaded two G.\n+  bool is_valid_32bit_offset(int64_t x) {\n+    constexpr int64_t twoG = (2 * G);\n+    constexpr int64_t twoK = (2 * K);\n+    return x < (twoG - twoK) && x >= (-twoG - twoK);\n+  }\n+\n@@ -836,1 +847,1 @@\n-    if (is_simm32(distance)) {                                                                     \\\n+    if (is_valid_32bit_offset(distance)) {                                                         \\\n@@ -893,1 +904,1 @@\n-    if (is_simm32(distance)) {                                                                     \\\n+    if (is_valid_32bit_offset(distance)) {                                                         \\\n@@ -954,1 +965,1 @@\n-    if (is_simm32(distance)) {                                                                     \\\n+    if (is_valid_32bit_offset(distance)) {                                                         \\\n@@ -999,1 +1010,1 @@\n-    if (is_simm32(distance)) {                                                                     \\\n+    if (is_valid_32bit_offset(distance)) {                                                         \\\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -133,0 +133,5 @@\n+  }\n+\n+  \/\/ Does target support predicated operation emulation.\n+  static bool supports_vector_predicate_op_emulation(int vopc, int vlen, BasicType bt) {\n+    return false;\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1063,2 +1063,2 @@\n-  static int emit_exception_handler(CodeBuffer &cbuf);\n-  static int emit_deopt_handler(CodeBuffer& cbuf);\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n+  static int emit_deopt_handler(C2_MacroAssembler* masm);\n@@ -1210,1 +1210,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -1294,2 +1294,1 @@\n-void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n+void MachBreakpointNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1311,3 +1310,2 @@\n-  void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc*) const {\n-    C2_MacroAssembler _masm(&cbuf);\n-    Assembler::CompressibleRegion cr(&_masm); \/\/ nops shall be 2-byte under RVC for alignment purposes.\n+  void MachNopNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc*) const {\n+    Assembler::CompressibleRegion cr(masm); \/\/ nops shall be 2-byte under RVC for alignment purposes.\n@@ -1335,1 +1333,1 @@\n-void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n@@ -1379,1 +1377,1 @@\n-void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1382,1 +1380,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1390,1 +1387,1 @@\n-    Assembler::IncompressibleRegion ir(&_masm);  \/\/ keep the nop as 4 bytes for patching.\n+    Assembler::IncompressibleRegion ir(masm);  \/\/ keep the nop as 4 bytes for patching.\n@@ -1434,1 +1431,1 @@\n-      bs->nmethod_entry_barrier(&_masm, slow_path, continuation, guard);\n+      bs->nmethod_entry_barrier(masm, slow_path, continuation, guard);\n@@ -1442,1 +1439,1 @@\n-  C->output()->set_frame_complete(cbuf.insts_size());\n+  C->output()->set_frame_complete(__ offset());\n@@ -1493,1 +1490,1 @@\n-void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachEpilogNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1496,1 +1493,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1570,1 +1566,1 @@\n-uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {\n+uint MachSpillCopyNode::implementation(C2_MacroAssembler *masm, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {\n@@ -1604,2 +1600,1 @@\n-    if (ireg == Op_VecA && cbuf) {\n-      C2_MacroAssembler _masm(cbuf);\n+    if (ireg == Op_VecA && masm) {\n@@ -1623,2 +1618,1 @@\n-    } else if (bottom_type()->isa_vectmask() && cbuf) {\n-      C2_MacroAssembler _masm(cbuf);\n+    } else if (bottom_type()->isa_vectmask() && masm) {\n@@ -1643,2 +1637,1 @@\n-  } else if (cbuf != nullptr) {\n-    C2_MacroAssembler _masm(cbuf);\n+  } else if (masm != nullptr) {\n@@ -1756,2 +1749,2 @@\n-void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  implementation(&cbuf, ra_, false, nullptr);\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation(masm, ra_, false, nullptr);\n@@ -1776,3 +1769,2 @@\n-void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n-  Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see BoxLockNode::size()\n+void BoxLockNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see BoxLockNode::size()\n@@ -1823,1 +1815,1 @@\n-void MachUEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void MachUEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n@@ -1826,1 +1818,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1845,1 +1836,1 @@\n-int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf)\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n@@ -1851,1 +1842,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1865,1 +1855,1 @@\n-int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf)\n+int HandlerImpl::emit_deopt_handler(C2_MacroAssembler* masm)\n@@ -1867,3 +1857,0 @@\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -2204,1 +2191,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2211,1 +2197,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2230,1 +2215,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2236,1 +2220,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2241,1 +2224,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2254,1 +2236,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2260,1 +2241,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2273,1 +2253,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2280,1 +2259,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2287,1 +2265,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2294,1 +2271,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2301,1 +2277,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2308,1 +2283,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2317,1 +2291,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2323,1 +2296,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2347,1 +2319,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2366,2 +2337,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see ret_addr_offset\n+    Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see ret_addr_offset\n@@ -2385,1 +2355,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -2397,1 +2367,1 @@\n-        cbuf.shared_stub_to_interp_for(_method, call - cbuf.insts_begin());\n+        __ code()->shared_stub_to_interp_for(_method, call - (__ begin()));\n@@ -2400,1 +2370,1 @@\n-        address stub = CompiledDirectCall::emit_to_interp_stub(cbuf, call);\n+        address stub = CompiledDirectCall::emit_to_interp_stub(masm, call);\n@@ -2412,3 +2382,2 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see ret_addr_offset\n-    int method_index = resolved_method_index(cbuf);\n+    Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see ret_addr_offset\n+    int method_index = resolved_method_index(masm);\n@@ -2425,1 +2394,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2433,2 +2401,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see ret_addr_offset\n+    Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see ret_addr_offset\n@@ -2466,1 +2433,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2474,1 +2440,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2482,1 +2447,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2490,1 +2454,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2498,1 +2461,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2506,1 +2468,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2514,1 +2475,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2522,1 +2482,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2530,1 +2489,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2536,1 +2494,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2546,1 +2503,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2551,1 +2507,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -9834,0 +9789,34 @@\n+instruct cmovI_cmpN(iRegINoSp dst, iRegI src, iRegN op1, iRegN op2, cmpOpU cop) %{\n+  match(Set dst (CMoveI (Binary cop (CmpN op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpN\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovI_cmpP(iRegINoSp dst, iRegI src, iRegP op1, iRegP op2, cmpOpU cop) %{\n+  match(Set dst (CMoveI (Binary cop (CmpP op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpP\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n@@ -9902,0 +9891,34 @@\n+instruct cmovL_cmpN(iRegLNoSp dst, iRegL src, iRegN op1, iRegN op2, cmpOpU cop) %{\n+  match(Set dst (CMoveL (Binary cop (CmpN op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpN\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovL_cmpP(iRegLNoSp dst, iRegL src, iRegP op1, iRegP op2, cmpOpU cop) %{\n+  match(Set dst (CMoveL (Binary cop (CmpP op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpP\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":98,"deletions":75,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  static void loadStore(C2_MacroAssembler masm, bool is_store,\n+  static void loadStore(C2_MacroAssembler* masm, bool is_store,\n@@ -37,1 +37,1 @@\n-    masm.vsetvli_helper(bt, vector_length);\n+    __ vsetvli_helper(bt, vector_length);\n@@ -40,1 +40,1 @@\n-      masm.vsex_v(reg, base, sew, vm);\n+      __ vsex_v(reg, base, sew, vm);\n@@ -43,1 +43,1 @@\n-        masm.vxor_vv(reg, reg, reg);\n+        __ vxor_vv(reg, reg, reg);\n@@ -45,1 +45,1 @@\n-      masm.vlex_v(reg, base, sew, vm);\n+      __ vlex_v(reg, base, sew, vm);\n@@ -76,0 +76,5 @@\n+      case Op_LoadVectorGatherMasked:\n+        if (is_subword_type(bt)) {\n+          return false;\n+        }\n+        break;\n@@ -111,1 +116,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), false, dst_reg,\n+    loadStore(masm, false, dst_reg,\n@@ -123,1 +128,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), true, src_reg,\n+    loadStore(masm, true, src_reg,\n@@ -2989,1 +2994,0 @@\n-      __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n@@ -3157,1 +3161,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), false, dst_reg,\n+    loadStore(masm, false, dst_reg,\n@@ -3169,1 +3173,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), true, src_reg,\n+    loadStore(masm, true, src_reg,\n@@ -3204,1 +3208,0 @@\n-      __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n@@ -3270,1 +3273,0 @@\n-    __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n@@ -3338,1 +3340,0 @@\n-    __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n@@ -3351,1 +3352,0 @@\n-    __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n@@ -3379,1 +3379,0 @@\n-    __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n@@ -3391,1 +3390,0 @@\n-    __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n@@ -3449,1 +3447,0 @@\n-    __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n@@ -3497,1 +3494,0 @@\n-    __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -908,0 +908,41 @@\n+\n+  if (CheckJNICalls) {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ lwu(t0, Address(sp, ContinuationEntry::flags_offset()));\n+    __ beqz(t0, L_skip_vthread_code);\n+\n+    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n+    \/\/ it failed to release a JNI monitor. So we issue the same log message\n+    \/\/ that JavaThread::exit does.\n+    __ ld(t0, Address(xthread, JavaThread::jni_monitor_count_offset()));\n+    __ beqz(t0, L_skip_vthread_code);\n+\n+    \/\/ Save return value potentially containing the exception oop in callee-saved x9\n+    __ mv(x9, x10);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n+    \/\/ Restore potential return value\n+    __ mv(x10, x9);\n+\n+    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n+    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n+    \/\/ the parent held count (which has to be zero).\n+    __ sd(zr, Address(xthread, JavaThread::jni_monitor_count_offset()));\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ lwu(t0, Address(sp, ContinuationEntry::flags_offset()));\n+    __ beqz(t0, L_skip_vthread_code);\n+\n+    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n+    \/\/ needed for assertion checking.\n+    __ sd(zr, Address(xthread, JavaThread::jni_monitor_count_offset()));\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#endif\n+\n@@ -977,2 +1018,1 @@\n-    CodeBuffer* cbuf = masm->code_section()->outer();\n-    address stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, tr_call);\n+    address stub = CompiledDirectCall::emit_to_interp_stub(masm, tr_call);\n@@ -1043,2 +1083,1 @@\n-  CodeBuffer* cbuf = masm->code_section()->outer();\n-  address stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, tr_call);\n+  address stub = CompiledDirectCall::emit_to_interp_stub(masm, tr_call);\n@@ -1712,0 +1751,3 @@\n+  \/\/ Verify or restore cpu control state after JNI call\n+  __ restore_cpu_control_state_after_jni(t0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":47,"deletions":5,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  int argsize = is_compiled() ? (_cb->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n+  int argsize = is_compiled() ? (_cb->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,2 +130,3 @@\n-  \/\/ -34 [ argument word 1      ]\n-  \/\/ -33 [ saved f27            ] <--- sp_after_call\n+  \/\/ -35 [ argument word 1      ]\n+  \/\/ -34 [ saved FRM in Floating-point Control and Status Register ] <--- sp_after_call\n+  \/\/ -33 [ saved f27            ]\n@@ -168,1 +169,1 @@\n-    sp_after_call_off  = -33,\n+    sp_after_call_off  = -34,\n@@ -170,0 +171,1 @@\n+    frm_off            = sp_after_call_off,\n@@ -217,0 +219,1 @@\n+    const Address frm_save      (fp, frm_off           * wordSize);\n@@ -299,0 +302,10 @@\n+    __ frrm(t0);\n+    __ sd(t0, frm_save);\n+    \/\/ Set frm to the state we need. We do want Round to Nearest. We\n+    \/\/ don't want non-IEEE rounding modes.\n+    Label skip_fsrmi;\n+    guarantee(__ RoundingMode::rne == 0, \"must be\");\n+    __ beqz(t0, skip_fsrmi);\n+    __ fsrmi(__ RoundingMode::rne);\n+    __ bind(skip_fsrmi);\n+\n@@ -418,0 +431,8 @@\n+    \/\/ restore frm\n+    Label skip_fsrm;\n+    __ ld(t0, frm_save);\n+    __ frrm(t1);\n+    __ beq(t0, t1, skip_fsrm);\n+    __ fsrm(t0);\n+    __ bind(skip_fsrm);\n+\n@@ -1118,1 +1139,1 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n@@ -1120,1 +1141,1 @@\n-      UnsafeCopyMemoryMark ucmm(this, add_entry, true);\n+      UnsafeMemoryAccessMark umam(this, add_entry, true);\n@@ -1194,1 +1215,1 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n@@ -1196,1 +1217,1 @@\n-      UnsafeCopyMemoryMark ucmm(this, add_entry, true);\n+      UnsafeMemoryAccessMark umam(this, add_entry, true);\n@@ -2416,1 +2437,1 @@\n-    __ set_last_Java_frame(sp, fp, ra, t0);\n+    __ set_last_Java_frame(sp, fp, ra);\n@@ -5482,2 +5503,2 @@\n-    if (UnsafeCopyMemory::_table == nullptr) {\n-      UnsafeCopyMemory::create_table(8);\n+    if (UnsafeMemoryAccess::_table == nullptr) {\n+      UnsafeMemoryAccess::create_table(8 + 4); \/\/ 8 for copyMemory; 4 for setMemory\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1160,0 +1160,3 @@\n+  \/\/ Restore cpu control state after JNI call\n+  __ restore_cpu_control_state_after_jni(t0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3557,1 +3557,1 @@\n-  \/\/ test to see if it has a finalizer or is malformed in some way\n+  \/\/ test to see if is malformed in some way\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,2 +160,4 @@\n-      LIR_Opr tmp = new_pointer_register();\n-      __ shift_left(index, shift, tmp);\n+      \/\/ Use long register to avoid overflow when shifting large index values left.\n+      LIR_Opr tmp = new_register(T_LONG);\n+      __ convert(Bytecodes::_i2l, index, tmp);\n+      __ shift_left(tmp, shift, tmp);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -42,1 +42,1 @@\n-address CompiledDirectCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark\/* = nullptr*\/) {\n+address CompiledDirectCall::emit_to_interp_stub(MacroAssembler *masm, address mark\/* = nullptr*\/) {\n@@ -48,1 +48,1 @@\n-    mark = cbuf.insts_mark();\n+    mark = __ inst_mark();\n@@ -52,4 +52,0 @@\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a stub.\n-  MacroAssembler _masm(&cbuf);\n-\n","filename":"src\/hotspot\/cpu\/s390\/compiledIC_s390.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-    __ block_comment(\"{ _captured_state_mask is set\");\n+    __ block_comment(\"_captured_state_mask_is_set {\");\n@@ -144,1 +144,1 @@\n-    __ block_comment(\"} _captured_state_mask is set\");\n+    __ block_comment(\"} _captured_state_mask_is_set\");\n@@ -179,1 +179,1 @@\n-    __ block_comment(\"{ thread java2native\");\n+    __ block_comment(\"thread_java2native {\");\n@@ -189,1 +189,1 @@\n-    __ block_comment(\"} thread java2native\");\n+    __ block_comment(\"} thread_java2native\");\n@@ -194,1 +194,1 @@\n-  __ block_comment(\"{ argument shuffle\");\n+  __ block_comment(\"argument shuffle {\");\n@@ -196,1 +196,1 @@\n-  __ block_comment(\"} argument shuffle\");\n+  __ block_comment(\"} argument_shuffle\");\n@@ -203,1 +203,1 @@\n-    __ block_comment(\"{ save thread local\");\n+    __ block_comment(\"save_thread_local {\");\n@@ -214,1 +214,1 @@\n-    __ block_comment(\"} save thread local\");\n+    __ block_comment(\"} save_thread_local\");\n@@ -225,1 +225,1 @@\n-    __ block_comment(\"{ thread native2java\");\n+    __ block_comment(\"thread_native2java {\");\n@@ -242,3 +242,4 @@\n-    __ block_comment(\"reguard stack check\");\n-    __ z_cli(Address(Z_thread, JavaThread::stack_guard_state_offset() + in_ByteSize(sizeof(StackOverflow::StackGuardState) - 1)),\n-        StackOverflow::stack_guard_yellow_reserved_disabled);\n+    __ block_comment(\"reguard_stack_check {\");\n+    __ z_cli(Address(Z_thread,\n+                     JavaThread::stack_guard_state_offset() + in_ByteSize(sizeof(StackOverflow::StackGuardState) - 1)),\n+                     StackOverflow::stack_guard_yellow_reserved_disabled);\n@@ -246,0 +247,1 @@\n+    __ block_comment(\"} reguard_stack_check\");\n@@ -259,1 +261,1 @@\n-    __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+    __ block_comment(\"L_safepoint_poll_slow_path {\");\n@@ -275,1 +277,1 @@\n-    __ block_comment(\"{ L_reguard\");\n+    __ block_comment(\"L_reguard {\");\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -327,6 +327,0 @@\n-\n-    \/\/ Check if the secondary index definition is still ~x, otherwise\n-    \/\/ we have to change the following assembler code to calculate the\n-    \/\/ plain index.\n-    assert(ConstantPool::decode_invokedynamic_index(~123) == 123, \"else change next line\");\n-    not_(index);  \/\/ Convert to plain index.\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3210,4 +3210,2 @@\n-    z_l(temp, Address(temp, Klass::access_flags_offset()));\n-    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n-    z_nilh(temp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n-    z_brne(done);\n+    testbit(Address(temp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    z_btrue(done);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -127,0 +127,5 @@\n+  \/\/ Does target support predicated operation emulation.\n+  static bool supports_vector_predicate_op_emulation(int vopc, int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -669,2 +669,1 @@\n-void emit_nop(CodeBuffer &cbuf) {\n-  C2_MacroAssembler _masm(&cbuf);\n+void emit_nop(C2_MacroAssembler *masm) {\n@@ -675,2 +674,1 @@\n-void emit_break(CodeBuffer &cbuf) {\n-  C2_MacroAssembler _masm(&cbuf);\n+void emit_break(C2_MacroAssembler *masm) {\n@@ -686,2 +684,2 @@\n-void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  emit_break(cbuf);\n+void MachBreakpointNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  emit_break(masm);\n@@ -694,2 +692,1 @@\n-static inline void z_emit16(CodeBuffer &cbuf, long value) {\n-  C2_MacroAssembler _masm(&cbuf);\n+static inline void z_emit16(C2_MacroAssembler *masm, long value) {\n@@ -699,2 +696,1 @@\n-static inline void z_emit32(CodeBuffer &cbuf, long value) {\n-  C2_MacroAssembler _masm(&cbuf);\n+static inline void z_emit32(C2_MacroAssembler *masm, long value) {\n@@ -704,2 +700,1 @@\n-static inline void z_emit48(CodeBuffer &cbuf, long value) {\n-  C2_MacroAssembler _masm(&cbuf);\n+static inline void z_emit48(C2_MacroAssembler *masm, long value) {\n@@ -709,1 +704,1 @@\n-static inline unsigned int z_emit_inst(CodeBuffer &cbuf, long value) {\n+static inline unsigned int z_emit_inst(C2_MacroAssembler *masm, long value) {\n@@ -715,1 +710,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -721,3 +715,1 @@\n-static inline void z_assert_aligned(CodeBuffer &cbuf, int disp, Register index, Register base, int alignment) {\n-  C2_MacroAssembler _masm(&cbuf);\n-\n+static inline void z_assert_aligned(C2_MacroAssembler *masm, int disp, Register index, Register base, int alignment) {\n@@ -730,1 +722,1 @@\n-int emit_call_reloc(C2_MacroAssembler &_masm, intptr_t entry_point, relocInfo::relocType rtype,\n+int emit_call_reloc(C2_MacroAssembler *masm, intptr_t entry_point, relocInfo::relocType rtype,\n@@ -761,1 +753,1 @@\n-static int emit_call_reloc(C2_MacroAssembler &_masm, intptr_t entry_point, RelocationHolder const& rspec) {\n+static int emit_call_reloc(C2_MacroAssembler *masm, intptr_t entry_point, RelocationHolder const& rspec) {\n@@ -793,2 +785,1 @@\n-void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n@@ -844,1 +835,1 @@\n-void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -846,1 +837,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -895,1 +885,1 @@\n-    bs->nmethod_entry_barrier(&_masm);\n+    bs->nmethod_entry_barrier(masm);\n@@ -898,1 +888,1 @@\n-  C->output()->set_frame_complete(cbuf.insts_size());\n+  C->output()->set_frame_complete(__ offset());\n@@ -924,2 +914,1 @@\n-void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n+void MachEpilogNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -993,1 +982,1 @@\n-static unsigned int z_ld_st_helper(CodeBuffer *cbuf, const char *op_str, unsigned long opcode,\n+static unsigned int z_ld_st_helper(C2_MacroAssembler *masm, const char *op_str, unsigned long opcode,\n@@ -996,1 +985,1 @@\n-  if (cbuf) {\n+  if (masm) {\n@@ -998,1 +987,1 @@\n-      return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |\n+      return z_emit_inst(masm, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |\n@@ -1001,1 +990,1 @@\n-      return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |\n+      return z_emit_inst(masm, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |\n@@ -1014,3 +1003,2 @@\n-static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {\n-  if (cbuf) {\n-    C2_MacroAssembler _masm(cbuf);\n+static unsigned int z_mvc_helper(C2_MacroAssembler *masm, int len, int dst_off, int src_off, bool do_print, outputStream *os) {\n+  if (masm) {\n@@ -1029,1 +1017,1 @@\n-uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {\n+uint MachSpillCopyNode::implementation(C2_MacroAssembler *masm, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {\n@@ -1069,1 +1057,1 @@\n-      return z_mvc_helper(cbuf, is64 ? 8 : 4, dst_offset, src_offset, print, os);\n+      return z_mvc_helper(masm, is64 ? 8 : 4, dst_offset, src_offset, print, os);\n@@ -1074,2 +1062,2 @@\n-      return z_ld_st_helper(cbuf, \"LG  \", LG_ZOPC, r0, src_offset, print, os) +\n-             z_ld_st_helper(cbuf, \"STG \", STG_ZOPC, r0, dst_offset, print, os);\n+      return z_ld_st_helper(masm, \"LG  \", LG_ZOPC, r0, src_offset, print, os) +\n+             z_ld_st_helper(masm, \"STG \", STG_ZOPC, r0, dst_offset, print, os);\n@@ -1078,2 +1066,2 @@\n-    return z_ld_st_helper(cbuf, \"LY   \", LY_ZOPC, r0, src_offset, print, os) +\n-           z_ld_st_helper(cbuf, \"STY  \", STY_ZOPC, r0, dst_offset, print, os);\n+    return z_ld_st_helper(masm, \"LY   \", LY_ZOPC, r0, src_offset, print, os) +\n+           z_ld_st_helper(masm, \"STY  \", STY_ZOPC, r0, dst_offset, print, os);\n@@ -1089,2 +1077,1 @@\n-    if (cbuf) {\n-      C2_MacroAssembler _masm(cbuf);\n+    if (masm) {\n@@ -1111,1 +1098,1 @@\n-      return z_ld_st_helper(cbuf, \"STG \", STG_ZOPC, src_lo, dst_offset, print, os);\n+      return z_ld_st_helper(masm, \"STG \", STG_ZOPC, src_lo, dst_offset, print, os);\n@@ -1118,1 +1105,1 @@\n-    return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);\n+    return z_ld_st_helper(masm, mnemo, opc, src_lo, dst_offset, print, os);\n@@ -1131,1 +1118,1 @@\n-    return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);\n+    return z_ld_st_helper(masm, mnemo, opc, dst_lo, src_offset, print, os);\n@@ -1136,2 +1123,1 @@\n-    if (cbuf) {\n-      C2_MacroAssembler _masm(cbuf);\n+    if (masm) {\n@@ -1160,1 +1146,1 @@\n-      return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);\n+      return z_ld_st_helper(masm, mnemo, opc, src_lo, dst_offset, print, os);\n@@ -1166,1 +1152,1 @@\n-    return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);\n+    return z_ld_st_helper(masm, mnemo, opc, src_lo, dst_offset, print, os);\n@@ -1177,1 +1163,1 @@\n-      return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);\n+      return z_ld_st_helper(masm, mnemo, opc, dst_lo, src_offset, print, os);\n@@ -1183,1 +1169,1 @@\n-    return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);\n+    return z_ld_st_helper(masm, mnemo, opc, dst_lo, src_offset, print, os);\n@@ -1219,2 +1205,2 @@\n-void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  implementation(&cbuf, ra_, false, nullptr);\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation(masm, ra_, false, nullptr);\n@@ -1235,3 +1221,1 @@\n-void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc * ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n-\n+void MachNopNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc * ra_) const {\n@@ -1240,1 +1224,1 @@\n-    rem_space = cbuf.insts()->remaining();\n+    rem_space = __ code()->insts()->remaining();\n@@ -1252,1 +1236,1 @@\n-      int rem_space2 = cbuf.insts()->remaining();\n+      int rem_space2 = __ code()->insts()->remaining();\n@@ -1275,3 +1259,1 @@\n-void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n-\n+void BoxLockNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1343,1 +1325,1 @@\n-void MachUEPNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachUEPNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1345,1 +1327,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1363,2 +1344,2 @@\n-  static int emit_exception_handler(CodeBuffer &cbuf);\n-  static int emit_deopt_handler(CodeBuffer& cbuf);\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n+  static int emit_deopt_handler(C2_MacroAssembler* masm);\n@@ -1402,1 +1383,1 @@\n-int HandlerImpl::emit_exception_handler(CodeBuffer &cbuf) {\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n@@ -1404,1 +1385,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1425,2 +1405,1 @@\n-int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf) {\n-  C2_MacroAssembler _masm(&cbuf);\n+int HandlerImpl::emit_deopt_handler(C2_MacroAssembler* masm) {\n@@ -1704,1 +1683,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1710,1 +1688,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1718,1 +1695,1 @@\n-    z_emit16(cbuf, $primary |\n+    z_emit16(masm, $primary |\n@@ -1725,1 +1702,1 @@\n-    z_emit32(cbuf, $primary |\n+    z_emit32(masm, $primary |\n@@ -1732,1 +1709,1 @@\n-    z_emit32(cbuf, $primary |\n+    z_emit32(masm, $primary |\n@@ -1740,1 +1717,1 @@\n-    z_emit32(cbuf, $primary |\n+    z_emit32(masm, $primary |\n@@ -1747,1 +1724,1 @@\n-    z_emit32(cbuf, $primary |\n+    z_emit32(masm, $primary |\n@@ -1754,1 +1731,1 @@\n-    z_emit48(cbuf, $primary |\n+    z_emit48(masm, $primary |\n@@ -1762,1 +1739,1 @@\n-    z_emit48(cbuf, $primary |\n+    z_emit48(masm, $primary |\n@@ -1769,1 +1746,1 @@\n-    z_emit48(cbuf, $primary |\n+    z_emit48(masm, $primary |\n@@ -1775,1 +1752,1 @@\n-    z_emit48(cbuf, $primary |\n+    z_emit48(masm, $primary |\n@@ -1782,1 +1759,1 @@\n-    z_emit48(cbuf, $primary |\n+    z_emit48(masm, $primary |\n@@ -1791,1 +1768,1 @@\n-    z_emit32(cbuf, $primary |\n+    z_emit32(masm, $primary |\n@@ -1800,1 +1777,1 @@\n-    z_emit32(cbuf, $primary |\n+    z_emit32(masm, $primary |\n@@ -1807,1 +1784,1 @@\n-    z_emit48(cbuf, $primary |\n+    z_emit48(masm, $primary |\n@@ -1815,1 +1792,1 @@\n-    z_emit48(cbuf, $primary |\n+    z_emit48(masm, $primary |\n@@ -1828,1 +1805,1 @@\n-    z_emit_inst(cbuf, $primary |\n+    z_emit_inst(masm, $primary |\n@@ -1835,1 +1812,1 @@\n-    z_emit_inst(cbuf, $primary |\n+    z_emit_inst(masm, $primary |\n@@ -1846,1 +1823,1 @@\n-      z_emit_inst(cbuf, $primary |\n+      z_emit_inst(masm, $primary |\n@@ -1852,1 +1829,1 @@\n-      z_emit_inst(cbuf, $primary |\n+      z_emit_inst(masm, $primary |\n@@ -1864,1 +1841,1 @@\n-      z_emit_inst(cbuf, $primary |\n+      z_emit_inst(masm, $primary |\n@@ -1870,1 +1847,1 @@\n-      z_emit_inst(cbuf, $primary |\n+      z_emit_inst(masm, $primary |\n@@ -1884,1 +1861,1 @@\n-      z_emit_inst(cbuf, $secondary |\n+      z_emit_inst(masm, $secondary |\n@@ -1890,1 +1867,1 @@\n-      z_emit_inst(cbuf, $primary |\n+      z_emit_inst(masm, $primary |\n@@ -1896,1 +1873,0 @@\n-        C2_MacroAssembler _masm(&cbuf);\n@@ -1899,1 +1875,1 @@\n-        z_emit_inst(cbuf, $secondary |\n+        z_emit_inst(masm, $secondary |\n@@ -1908,1 +1884,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1921,1 +1896,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1934,1 +1908,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1947,1 +1920,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1960,1 +1932,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -1984,1 +1955,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2010,1 +1980,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2035,1 +2004,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2062,2 +2030,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-\n@@ -2090,1 +2056,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2094,1 +2059,1 @@\n-      ret_offset = emit_call_reloc(_masm, $meth$$method,\n+      ret_offset = emit_call_reloc(masm, $meth$$method,\n@@ -2097,1 +2062,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -2099,1 +2064,1 @@\n-        ret_offset = emit_call_reloc(_masm, $meth$$method,\n+        ret_offset = emit_call_reloc(masm, $meth$$method,\n@@ -2102,1 +2067,1 @@\n-        ret_offset = emit_call_reloc(_masm, $meth$$method,\n+        ret_offset = emit_call_reloc(masm, $meth$$method,\n@@ -2109,1 +2074,1 @@\n-      address stub = CompiledDirectCall::emit_to_interp_stub(cbuf);\n+      address stub = CompiledDirectCall::emit_to_interp_stub(masm);\n@@ -2111,0 +2076,1 @@\n+        __ clear_inst_mark();\n@@ -2115,0 +2081,2 @@\n+\n+    __ clear_inst_mark();\n@@ -2119,1 +2087,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2137,1 +2104,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -2141,1 +2108,2 @@\n-      ret_off += emit_call_reloc(_masm, $meth$$method, relocInfo::none, ra_);\n+      ret_off += emit_call_reloc(masm, $meth$$method, relocInfo::none, ra_);\n+      __ clear_inst_mark();\n@@ -2174,1 +2142,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2195,1 +2162,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2212,1 +2178,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2229,1 +2194,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2238,1 +2202,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2247,1 +2210,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2263,1 +2225,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -9561,1 +9522,1 @@\n-    cbuf.set_insts_mark();\n+    __ set_inst_mark();\n@@ -9564,0 +9525,1 @@\n+    __ clear_inst_mark();\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":85,"deletions":123,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -1715,2 +1715,0 @@\n-    \/\/ in case of DiagnoseSyncOnValueBasedClasses content for Z_R1_scratch\n-    \/\/ will be destroyed, So avoid using Z_R1 as temp here.\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  __ block_comment(\"{ preserve_callee_saved_regs \");\n+  __ block_comment(\"preserve_callee_saved_regs {\");\n@@ -85,1 +85,1 @@\n-  __ block_comment(\"} preserve_callee_saved_regs \");\n+  __ block_comment(\"} preserve_callee_saved_regs\");\n@@ -95,1 +95,1 @@\n-  __ block_comment(\"{ restore_callee_saved_regs \");\n+  __ block_comment(\"restore_callee_saved_regs {\");\n@@ -114,1 +114,1 @@\n-  __ block_comment(\"} restore_callee_saved_regs \");\n+  __ block_comment(\"} restore_callee_saved_regs\");\n@@ -206,1 +206,1 @@\n-  __ block_comment(\"{ on_entry\");\n+  __ block_comment(\"on_entry {\");\n@@ -215,1 +215,1 @@\n-  __ block_comment(\"{ argument shuffle\");\n+  __ block_comment(\"argument_shuffle {\");\n@@ -217,1 +217,1 @@\n-  __ block_comment(\"} argument shuffle\");\n+  __ block_comment(\"} argument_shuffle\");\n@@ -219,1 +219,1 @@\n-  __ block_comment(\"{ receiver \");\n+  __ block_comment(\"receiver {\");\n@@ -221,1 +221,1 @@\n-  __ block_comment(\"} receiver \");\n+  __ block_comment(\"} receiver\");\n@@ -257,1 +257,1 @@\n-  __ block_comment(\"{ on_exit\");\n+  __ block_comment(\"on_exit {\");\n","filename":"src\/hotspot\/cpu\/s390\/upcallLinker_s390.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -937,0 +937,1 @@\n+    case 0xD6: \/\/ movq\n@@ -1760,0 +1761,16 @@\n+void Assembler::cmpb(Address dst, Register reg) {\n+  assert(reg->has_byte_register(), \"must have byte register\");\n+  InstructionMark im(this);\n+  prefix(dst, reg, true);\n+  emit_int8((unsigned char)0x38);\n+  emit_operand(reg, dst, 0);\n+}\n+\n+void Assembler::cmpb(Register reg, Address dst) {\n+  assert(reg->has_byte_register(), \"must have byte register\");\n+  InstructionMark im(this);\n+  prefix(dst, reg, true);\n+  emit_int8((unsigned char)0x3a);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -1791,0 +1808,7 @@\n+void Assembler::cmpl(Address dst,  Register reg) {\n+  InstructionMark im(this);\n+  prefix(dst, reg);\n+  emit_int8(0x39);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -1806,0 +1830,8 @@\n+void Assembler::cmpw(Address dst, Register reg) {\n+  InstructionMark im(this);\n+  emit_int8(0x66);\n+  prefix(dst, reg);\n+  emit_int8((unsigned char)0x39);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -4263,0 +4295,1 @@\n+  InstructionMark im(this);\n@@ -4426,0 +4459,10 @@\n+void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() : VM_Version::supports_avx2(), \"\");\n+  assert(vector_len <= AVX_256bit, \"evex encoding is different - has k register as dest\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x74);\n+  emit_operand(dst, src2, 0);\n+}\n+\n@@ -4532,0 +4575,11 @@\n+\/\/ In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst\n+void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() : VM_Version::supports_avx2(), \"\");\n+  assert(vector_len <= AVX_256bit, \"evex encoding is different - has k register as dest\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x75);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -4698,0 +4752,1 @@\n+  InstructionMark im(this);\n@@ -4715,0 +4770,1 @@\n+  InstructionMark im(this);\n@@ -4732,0 +4788,1 @@\n+  InstructionMark im(this);\n@@ -4749,0 +4806,1 @@\n+  InstructionMark im(this);\n@@ -4766,0 +4824,1 @@\n+  InstructionMark im(this);\n@@ -4790,0 +4849,1 @@\n+  InstructionMark im(this);\n@@ -4814,0 +4874,1 @@\n+  InstructionMark im(this);\n@@ -4831,0 +4892,1 @@\n+  InstructionMark im(this);\n@@ -6591,0 +6653,8 @@\n+void Assembler::xorw(Register dst, Address src) {\n+  InstructionMark im(this);\n+  emit_int8(0x66);\n+  prefix(src, dst);\n+  emit_int8(0x33);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -7641,0 +7711,8 @@\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0xDA, (0xC0 | encode));\n+}\n+\n@@ -12266,0 +12344,7 @@\n+void Assembler::bzhil(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n@@ -13160,0 +13245,4 @@\n+void Assembler::cdqe() {\n+  emit_int16(REX_W, (unsigned char)0x98);\n+}\n+\n@@ -13321,0 +13410,1 @@\n+  InstructionMark im(this);\n@@ -13326,0 +13416,1 @@\n+  InstructionMark im(this);\n@@ -13331,0 +13422,1 @@\n+  InstructionMark im(this);\n@@ -13336,0 +13428,1 @@\n+  InstructionMark im(this);\n@@ -13642,0 +13735,13 @@\n+void Assembler::btq(Register dst, Register src) {\n+  int encode = prefixq_and_encode(src->encoding(), dst->encoding());\n+  emit_int24(0x0F, (unsigned char)0xA3, (encode | 0xC0));\n+}\n+\n+void Assembler::btq(Register src, int imm8) {\n+  assert(isByte(imm8), \"not a byte\");\n+  int encode = prefixq_and_encode(src->encoding());\n+  emit_int16(0x0f, 0xba);\n+  emit_int8(0xe0|encode);\n+  emit_int8(imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -1097,0 +1097,1 @@\n+  void cdqe();\n@@ -1112,0 +1113,2 @@\n+  void cmpb(Address dst, Register reg);\n+  void cmpb(Register reg, Address dst);\n@@ -1118,0 +1121,1 @@\n+  void cmpl(Address dst,  Register reg);\n@@ -1126,0 +1130,1 @@\n+  void cmpw(Address dst, Register reg);\n@@ -1737,0 +1742,1 @@\n+  void btq(Register src, int imm8);\n@@ -1738,0 +1744,1 @@\n+  void btq(Register dst, Register src);\n@@ -1803,0 +1810,1 @@\n+  void vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -1817,0 +1825,1 @@\n+  void vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n@@ -2256,0 +2265,1 @@\n+  void xorw(Register dst, Address src);\n@@ -2307,0 +2317,1 @@\n+  void bzhil(Register dst, Register src1, Register src2);\n@@ -2582,0 +2593,1 @@\n+  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1799,0 +1799,124 @@\n+#ifdef _LP64\n+void C2_MacroAssembler::vgather8b_masked_offset(BasicType elem_bt,\n+                                                XMMRegister dst, Register base,\n+                                                Register idx_base,\n+                                                Register offset, Register mask,\n+                                                Register mask_idx, Register rtmp,\n+                                                int vlen_enc) {\n+  vpxor(dst, dst, dst, vlen_enc);\n+  if (elem_bt == T_SHORT) {\n+    for (int i = 0; i < 4; i++) {\n+      \/\/ dst[i] = mask[i] ? src[offset + idx_base[i]] : 0\n+      Label skip_load;\n+      btq(mask, mask_idx);\n+      jccb(Assembler::carryClear, skip_load);\n+      movl(rtmp, Address(idx_base, i * 4));\n+      if (offset != noreg) {\n+        addl(rtmp, offset);\n+      }\n+      pinsrw(dst, Address(base, rtmp, Address::times_2), i);\n+      bind(skip_load);\n+      incq(mask_idx);\n+    }\n+  } else {\n+    assert(elem_bt == T_BYTE, \"\");\n+    for (int i = 0; i < 8; i++) {\n+      \/\/ dst[i] = mask[i] ? src[offset + idx_base[i]] : 0\n+      Label skip_load;\n+      btq(mask, mask_idx);\n+      jccb(Assembler::carryClear, skip_load);\n+      movl(rtmp, Address(idx_base, i * 4));\n+      if (offset != noreg) {\n+        addl(rtmp, offset);\n+      }\n+      pinsrb(dst, Address(base, rtmp), i);\n+      bind(skip_load);\n+      incq(mask_idx);\n+    }\n+  }\n+}\n+#endif \/\/ _LP64\n+\n+void C2_MacroAssembler::vgather8b_offset(BasicType elem_bt, XMMRegister dst,\n+                                         Register base, Register idx_base,\n+                                         Register offset, Register rtmp,\n+                                         int vlen_enc) {\n+  vpxor(dst, dst, dst, vlen_enc);\n+  if (elem_bt == T_SHORT) {\n+    for (int i = 0; i < 4; i++) {\n+      \/\/ dst[i] = src[offset + idx_base[i]]\n+      movl(rtmp, Address(idx_base, i * 4));\n+      if (offset != noreg) {\n+        addl(rtmp, offset);\n+      }\n+      pinsrw(dst, Address(base, rtmp, Address::times_2), i);\n+    }\n+  } else {\n+    assert(elem_bt == T_BYTE, \"\");\n+    for (int i = 0; i < 8; i++) {\n+      \/\/ dst[i] = src[offset + idx_base[i]]\n+      movl(rtmp, Address(idx_base, i * 4));\n+      if (offset != noreg) {\n+        addl(rtmp, offset);\n+      }\n+      pinsrb(dst, Address(base, rtmp), i);\n+    }\n+  }\n+}\n+\n+\/*\n+ * Gather using hybrid algorithm, first partially unroll scalar loop\n+ * to accumulate values from gather indices into a quad-word(64bit) slice.\n+ * A slice may hold 8 bytes or 4 short values. This is followed by a vector\n+ * permutation to place the slice into appropriate vector lane\n+ * locations in destination vector. Following pseudo code describes the\n+ * algorithm in detail:\n+ *\n+ * DST_VEC = ZERO_VEC\n+ * PERM_INDEX = {0, 1, 2, 3, 4, 5, 6, 7, 8..}\n+ * TWO_VEC    = {2, 2, 2, 2, 2, 2, 2, 2, 2..}\n+ * FOREACH_ITER:\n+ *     TMP_VEC_64 = PICK_SUB_WORDS_FROM_GATHER_INDICES\n+ *     TEMP_PERM_VEC = PERMUTE TMP_VEC_64 PERM_INDEX\n+ *     DST_VEC = DST_VEC OR TEMP_PERM_VEC\n+ *     PERM_INDEX = PERM_INDEX - TWO_VEC\n+ *\n+ * With each iteration, doubleword permute indices (0,1) corresponding\n+ * to gathered quadword gets right shifted by two lane positions.\n+ *\n+ *\/\n+void C2_MacroAssembler::vgather_subword(BasicType elem_ty, XMMRegister dst,\n+                                        Register base, Register idx_base,\n+                                        Register offset, Register mask,\n+                                        XMMRegister xtmp1, XMMRegister xtmp2,\n+                                        XMMRegister temp_dst, Register rtmp,\n+                                        Register mask_idx, Register length,\n+                                        int vector_len, int vlen_enc) {\n+  Label GATHER8_LOOP;\n+  assert(is_subword_type(elem_ty), \"\");\n+  movl(length, vector_len);\n+  vpxor(xtmp1, xtmp1, xtmp1, vlen_enc); \/\/ xtmp1 = {0, ...}\n+  vpxor(dst, dst, dst, vlen_enc); \/\/ dst = {0, ...}\n+  vallones(xtmp2, vlen_enc);\n+  vpsubd(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  vpslld(xtmp2, xtmp2, 1, vlen_enc); \/\/ xtmp2 = {2, 2, ...}\n+  load_iota_indices(xtmp1, vector_len * type2aelembytes(elem_ty), T_INT); \/\/ xtmp1 = {0, 1, 2, ...}\n+\n+  bind(GATHER8_LOOP);\n+    \/\/ TMP_VEC_64(temp_dst) = PICK_SUB_WORDS_FROM_GATHER_INDICES\n+    if (mask == noreg) {\n+      vgather8b_offset(elem_ty, temp_dst, base, idx_base, offset, rtmp, vlen_enc);\n+    } else {\n+      LP64_ONLY(vgather8b_masked_offset(elem_ty, temp_dst, base, idx_base, offset, mask, mask_idx, rtmp, vlen_enc));\n+    }\n+    \/\/ TEMP_PERM_VEC(temp_dst) = PERMUTE TMP_VEC_64(temp_dst) PERM_INDEX(xtmp1)\n+    vpermd(temp_dst, xtmp1, temp_dst, vlen_enc == Assembler::AVX_512bit ? vlen_enc : Assembler::AVX_256bit);\n+    \/\/ PERM_INDEX(xtmp1) = PERM_INDEX(xtmp1) - TWO_VEC(xtmp2)\n+    vpsubd(xtmp1, xtmp1, xtmp2, vlen_enc);\n+    \/\/ DST_VEC = DST_VEC OR TEMP_PERM_VEC\n+    vpor(dst, dst, temp_dst, vlen_enc);\n+    addptr(idx_base,  32 >> (type2aelembytes(elem_ty) - 1));\n+    subl(length, 8 >> (type2aelembytes(elem_ty) - 1));\n+    jcc(Assembler::notEqual, GATHER8_LOOP);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -503,0 +503,12 @@\n+\n+  void vgather_subword(BasicType elem_ty, XMMRegister dst,  Register base, Register idx_base, Register offset,\n+                       Register mask, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n+                       Register midx, Register length, int vector_len, int vlen_enc);\n+\n+#ifdef _LP64\n+  void vgather8b_masked_offset(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n+                               Register offset, Register mask, Register midx, Register rtmp, int vlen_enc);\n+#endif\n+  void vgather8b_offset(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n+                              Register offset, Register rtmp, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-#define __ _masm.\n+#define __ _masm->\n@@ -123,1 +123,1 @@\n-IntelJccErratumAlignment::IntelJccErratumAlignment(MacroAssembler& masm, int jcc_size) :\n+IntelJccErratumAlignment::IntelJccErratumAlignment(MacroAssembler* masm, int jcc_size) :\n","filename":"src\/hotspot\/cpu\/x86\/c2_intelJccErratum_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  MacroAssembler& _masm;\n+  MacroAssembler* _masm;\n@@ -63,1 +63,1 @@\n-  IntelJccErratumAlignment(MacroAssembler& masm, int jcc_size);\n+  IntelJccErratumAlignment(MacroAssembler* masm, int jcc_size);\n","filename":"src\/hotspot\/cpu\/x86\/c2_intelJccErratum_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-#define __ _masm.\n-address CompiledDirectCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark) {\n+#define __ masm->\n+address CompiledDirectCall::emit_to_interp_stub(MacroAssembler *masm, address mark) {\n@@ -45,1 +45,1 @@\n-    mark = cbuf.insts_mark();  \/\/ Get mark within main instrs section.\n+    mark = __ inst_mark();  \/\/ Get mark within main instrs section.\n@@ -48,4 +48,0 @@\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a stub.\n-  MacroAssembler _masm(&cbuf);\n-\n","filename":"src\/hotspot\/cpu\/x86\/compiledIC_x86.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  return (cb()->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm,\n@@ -64,1 +64,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm,\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoah_x86_32.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm,\n@@ -64,1 +64,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm,\n@@ -83,1 +83,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm,\n@@ -104,1 +104,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm,\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm,\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoah_x86_64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-extern void vec_spill_helper(CodeBuffer *cbuf, bool is_load,\n+extern void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n@@ -440,1 +440,2 @@\n-    vec_spill_helper(__ code(), false \/* is_load *\/, _spill_offset, opto_reg, ideal_reg, tty);\n+    C2_MacroAssembler c2_masm(__ code());\n+    vec_spill_helper(&c2_masm, false \/* is_load *\/, _spill_offset, opto_reg, ideal_reg, tty);\n@@ -446,1 +447,2 @@\n-    vec_spill_helper(__ code(), true \/* is_load *\/, _spill_offset, opto_reg, ideal_reg, tty);\n+    C2_MacroAssembler c2_masm(__ code());\n+    vec_spill_helper(&c2_masm, true \/* is_load *\/, _spill_offset, opto_reg, ideal_reg, tty);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/x\/xBarrierSetAssembler_x86.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static void x_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) {\n+static void x_load_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) {\n@@ -42,1 +42,1 @@\n-    IntelJccErratumAlignment intel_alignment(_masm, 10 \/* jcc_size *\/);\n+    IntelJccErratumAlignment intel_alignment(masm, 10 \/* jcc_size *\/);\n@@ -49,1 +49,1 @@\n-static void x_load_barrier_cmpxchg(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, Label& good) {\n+static void x_load_barrier_cmpxchg(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, Label& good) {\n@@ -52,1 +52,1 @@\n-    IntelJccErratumAlignment intel_alignment(_masm, 10 \/* jcc_size *\/);\n+    IntelJccErratumAlignment intel_alignment(masm, 10 \/* jcc_size *\/);\n@@ -57,1 +57,1 @@\n-    IntelJccErratumAlignment intel_alignment(_masm, 5 \/* jcc_size *\/);\n+    IntelJccErratumAlignment intel_alignment(masm, 5 \/* jcc_size *\/);\n@@ -63,1 +63,1 @@\n-static void x_cmpxchg_common(MacroAssembler& _masm, const MachNode* node, Register mem_reg, Register newval, Register tmp) {\n+static void x_cmpxchg_common(MacroAssembler* masm, const MachNode* node, Register mem_reg, Register newval, Register tmp) {\n@@ -76,1 +76,1 @@\n-    x_load_barrier_cmpxchg(_masm, node, mem, rax, tmp, good);\n+    x_load_barrier_cmpxchg(masm, node, mem, rax, tmp, good);\n@@ -99,1 +99,1 @@\n-    x_load_barrier(_masm, this, $mem$$Address, $dst$$Register, noreg \/* tmp *\/, barrier_data());\n+    x_load_barrier(masm, this, $mem$$Address, $dst$$Register, noreg \/* tmp *\/, barrier_data());\n@@ -115,1 +115,1 @@\n-    x_cmpxchg_common(_masm, this, $mem$$Register, $newval$$Register, $tmp$$Register);\n+    x_cmpxchg_common(masm, this, $mem$$Register, $newval$$Register, $tmp$$Register);\n@@ -134,1 +134,1 @@\n-    x_cmpxchg_common(_masm, this, $mem$$Register, $newval$$Register, $tmp$$Register);\n+    x_cmpxchg_common(masm, this, $mem$$Register, $newval$$Register, $tmp$$Register);\n@@ -154,1 +154,1 @@\n-    x_load_barrier(_masm, this, Address(noreg, 0), $newval$$Register, noreg \/* tmp *\/, barrier_data());\n+    x_load_barrier(masm, this, Address(noreg, 0), $newval$$Register, noreg \/* tmp *\/, barrier_data());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/x\/x_x86_64.ad","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-  IntelJccErratumAlignment intel_alignment(*masm, size);\n+  IntelJccErratumAlignment intel_alignment(masm, size);\n@@ -1187,1 +1187,1 @@\n-extern void vec_spill_helper(CodeBuffer *cbuf, bool is_load,\n+extern void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n@@ -1249,1 +1249,2 @@\n-    vec_spill_helper(__ code(), false \/* is_load *\/, _spill_offset, opto_reg, ideal_reg, tty);\n+    C2_MacroAssembler c2_masm(__ code());\n+    vec_spill_helper(&c2_masm, false \/* is_load *\/, _spill_offset, opto_reg, ideal_reg, tty);\n@@ -1255,1 +1256,2 @@\n-    vec_spill_helper(__ code(), true \/* is_load *\/, _spill_offset, opto_reg, ideal_reg, tty);\n+    C2_MacroAssembler c2_masm(__ code());\n+    vec_spill_helper(&c2_masm, true \/* is_load *\/, _spill_offset, opto_reg, ideal_reg, tty);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-static void z_color(MacroAssembler& _masm, const MachNode* node, Register ref) {\n+static void z_color(MacroAssembler* masm, const MachNode* node, Register ref) {\n@@ -44,1 +44,1 @@\n-static void z_uncolor(MacroAssembler& _masm, const MachNode* node, Register ref) {\n+static void z_uncolor(MacroAssembler* masm, const MachNode* node, Register ref) {\n@@ -49,1 +49,1 @@\n-static void z_keep_alive_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref) {\n+static void z_keep_alive_load_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref) {\n@@ -56,1 +56,1 @@\n-  z_uncolor(_masm, node, ref);\n+  z_uncolor(masm, node, ref);\n@@ -61,2 +61,2 @@\n-static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref) {\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(&_masm);\n+static void z_load_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register ref) {\n+  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -68,1 +68,1 @@\n-    z_keep_alive_load_barrier(_masm, node, ref_addr, ref);\n+    z_keep_alive_load_barrier(masm, node, ref_addr, ref);\n@@ -72,1 +72,1 @@\n-  z_uncolor(_masm, node, ref);\n+  z_uncolor(masm, node, ref);\n@@ -78,1 +78,1 @@\n-    IntelJccErratumAlignment intel_alignment(_masm, 6);\n+    IntelJccErratumAlignment intel_alignment(masm, 6);\n@@ -84,2 +84,2 @@\n-static void z_store_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register rnew_zaddress, Register rnew_zpointer, bool is_atomic) {\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(&_masm);\n+static void z_store_barrier(MacroAssembler* masm, const MachNode* node, Address ref_addr, Register rnew_zaddress, Register rnew_zpointer, bool is_atomic) {\n+  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -90,1 +90,1 @@\n-      z_color(_masm, node, rnew_zpointer);\n+      z_color(masm, node, rnew_zpointer);\n@@ -96,1 +96,1 @@\n-    bs_asm->store_barrier_fast(&_masm, ref_addr, rnew_zaddress, rnew_zpointer, true \/* in_nmethod *\/, is_atomic, *stub->entry(), *stub->continuation());\n+    bs_asm->store_barrier_fast(masm, ref_addr, rnew_zaddress, rnew_zpointer, true \/* in_nmethod *\/, is_atomic, *stub->entry(), *stub->continuation());\n@@ -127,1 +127,1 @@\n-    z_load_barrier(_masm, this, $mem$$Address, $dst$$Register);\n+    z_load_barrier(masm, this, $mem$$Address, $dst$$Register);\n@@ -159,1 +159,1 @@\n-    z_store_barrier(_masm, this, $mem$$Address, $src$$Register, $tmp$$Register, false \/* is_atomic *\/);\n+    z_store_barrier(masm, this, $mem$$Address, $src$$Register, $tmp$$Register, false \/* is_atomic *\/);\n@@ -175,1 +175,1 @@\n-    z_store_barrier(_masm, this, $mem$$Address, noreg, $tmp$$Register, false \/* is_atomic *\/);\n+    z_store_barrier(masm, this, $mem$$Address, noreg, $tmp$$Register, false \/* is_atomic *\/);\n@@ -197,2 +197,2 @@\n-    z_store_barrier(_masm, this, mem_addr, $newval$$Register, $tmp$$Register, true \/* is_atomic *\/);\n-    z_color(_masm, this, $oldval$$Register);\n+    z_store_barrier(masm, this, mem_addr, $newval$$Register, $tmp$$Register, true \/* is_atomic *\/);\n+    z_color(masm, this, $oldval$$Register);\n@@ -201,1 +201,1 @@\n-    z_uncolor(_masm, this, $oldval$$Register);\n+    z_uncolor(masm, this, $oldval$$Register);\n@@ -221,2 +221,2 @@\n-    z_store_barrier(_masm, this, mem_addr, $newval$$Register, $tmp$$Register, true \/* is_atomic *\/);\n-    z_color(_masm, this, $oldval$$Register);\n+    z_store_barrier(masm, this, mem_addr, $newval$$Register, $tmp$$Register, true \/* is_atomic *\/);\n+    z_color(masm, this, $oldval$$Register);\n@@ -242,1 +242,1 @@\n-    z_store_barrier(_masm, this, mem_addr, $newval$$Register, $tmp$$Register, true \/* is_atomic *\/);\n+    z_store_barrier(masm, this, mem_addr, $newval$$Register, $tmp$$Register, true \/* is_atomic *\/);\n@@ -245,1 +245,1 @@\n-    z_uncolor(_masm, this, $newval$$Register);\n+    z_uncolor(masm, this, $newval$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/z_x86_64.ad","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -466,5 +466,0 @@\n-    \/\/ Check if the secondary index definition is still ~x, otherwise\n-    \/\/ we have to change the following assembler code to calculate the\n-    \/\/ plain index.\n-    assert(ConstantPool::decode_invokedynamic_index(~123) == 123, \"else change next line\");\n-    notl(index);  \/\/ convert to plain index\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3573,0 +3573,5 @@\n+void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  assert(((dst->encoding() < 16 && src1->encoding() < 16) || VM_Version::supports_avx512vlbw()),\"XMM register should be 0-15\");\n+  Assembler::vpcmpeqb(dst, src1, src2, vector_len);\n+}\n+\n@@ -3578,0 +3583,5 @@\n+void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(((dst->encoding() < 16 && nds->encoding() < 16) || VM_Version::supports_avx512vlbw()),\"XMM register should be 0-15\");\n+  Assembler::vpcmpeqw(dst, nds, src, vector_len);\n+}\n+\n@@ -4729,0 +4739,334 @@\n+#ifdef _LP64\n+\n+\/\/ population_count variant for running without the POPCNT\n+\/\/ instruction, which was introduced with SSE4.2 in 2008.\n+void MacroAssembler::population_count(Register dst, Register src,\n+                                      Register scratch1, Register scratch2) {\n+  assert_different_registers(src, scratch1, scratch2);\n+  if (UsePopCountInstruction) {\n+    Assembler::popcntq(dst, src);\n+  } else {\n+    assert_different_registers(src, scratch1, scratch2);\n+    assert_different_registers(dst, scratch1, scratch2);\n+    Label loop, done;\n+\n+    mov(scratch1, src);\n+    \/\/ dst = 0;\n+    \/\/ while(scratch1 != 0) {\n+    \/\/   dst++;\n+    \/\/   scratch1 &= (scratch1 - 1);\n+    \/\/ }\n+    xorl(dst, dst);\n+    testq(scratch1, scratch1);\n+    jccb(Assembler::equal, done);\n+    {\n+      bind(loop);\n+      incq(dst);\n+      movq(scratch2, scratch1);\n+      decq(scratch2);\n+      andq(scratch1, scratch2);\n+      jccb(Assembler::notEqual, loop);\n+    }\n+    bind(done);\n+  }\n+}\n+\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS                      \\\n+do {                                                                 \\\n+  assert(r_super_klass  == rax, \"mismatch\");                         \\\n+  assert(r_array_base   == rbx, \"mismatch\");                         \\\n+  assert(r_array_length == rcx, \"mismatch\");                         \\\n+  assert(r_array_index  == rdx, \"mismatch\");                         \\\n+  assert(r_sub_klass    == rsi || r_sub_klass == noreg, \"mismatch\"); \\\n+  assert(r_bitmap       == r11 || r_bitmap    == noreg, \"mismatch\"); \\\n+  assert(result         == rdi || result      == noreg, \"mismatch\"); \\\n+} while(0)\n+\n+void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   Register temp4,\n+                                                   Register result,\n+                                                   u1 super_klass_slot) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, temp3, temp4, result);\n+\n+  Label L_fallthrough, L_success, L_failure;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_index  = temp1,\n+    r_array_length = temp2,\n+    r_array_base   = temp3,\n+    r_bitmap       = temp4;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  xorq(result, result); \/\/ = 0\n+\n+  movq(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  movq(r_array_index, r_bitmap);\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  u1 bit = super_klass_slot;\n+  {\n+    \/\/ NB: If the count in a x86 shift instruction is 0, the flags are\n+    \/\/ not affected, so we do a testq instead.\n+    int shift_count = Klass::SECONDARY_SUPERS_TABLE_MASK - bit;\n+    if (shift_count != 0) {\n+      salq(r_array_index, shift_count);\n+    } else {\n+      testq(r_array_index, r_array_index);\n+    }\n+  }\n+  \/\/ We test the MSB of r_array_index, i.e. its sign bit\n+  jcc(Assembler::positive, L_failure);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    population_count(r_array_index, r_array_index, temp2, temp3);\n+  } else {\n+    movl(r_array_index, 1);\n+  }\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  \/\/ We will consult the secondary-super array.\n+  movptr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ We're asserting that the first word in an Array<Klass*> is the\n+  \/\/ length, and the second word is the first word of the data. If\n+  \/\/ that ever changes, r_array_base will have to be adjusted here.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+  jccb(Assembler::equal, L_success);\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  btq(r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+  jccb(Assembler::carryClear, L_failure);\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 1.\n+  if (bit != 0) {\n+    rorq(r_bitmap, bit);\n+  }\n+\n+  \/\/ Calls into the stub generated by lookup_secondary_supers_table_slow_path.\n+  \/\/ Arguments: r_super_klass, r_array_base, r_array_index, r_bitmap.\n+  \/\/ Kills: r_array_length.\n+  \/\/ Returns: result.\n+  call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_slow_path_stub()));\n+  \/\/ Result (0\/1) is in rdi\n+  jmpb(L_fallthrough);\n+\n+  bind(L_failure);\n+  incq(result); \/\/ 0 => 1\n+\n+  bind(L_success);\n+  \/\/ result = 0;\n+\n+  bind(L_fallthrough);\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                  temp1, temp2, temp3);\n+  }\n+}\n+\n+void MacroAssembler::repne_scanq(Register addr, Register value, Register count, Register limit,\n+                                 Label* L_success, Label* L_failure) {\n+  Label L_loop, L_fallthrough;\n+  {\n+    int label_nulls = 0;\n+    if (L_success == nullptr) { L_success = &L_fallthrough; label_nulls++; }\n+    if (L_failure == nullptr) { L_failure = &L_fallthrough; label_nulls++; }\n+    assert(label_nulls <= 1, \"at most one null in the batch\");\n+  }\n+  bind(L_loop);\n+  cmpq(value, Address(addr, count, Address::times_8));\n+  jcc(Assembler::equal, *L_success);\n+  addl(count, 1);\n+  cmpl(count, limit);\n+  jcc(Assembler::less, L_loop);\n+\n+  if (&L_fallthrough != L_failure) {\n+    jmp(*L_failure);\n+  }\n+  bind(L_fallthrough);\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register temp1,\n+                                                             Register temp2,\n+                                                             Label* L_success,\n+                                                             Label* L_failure) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, temp1, temp2);\n+\n+  const Register\n+    r_array_length = temp1,\n+    r_sub_klass    = noreg,\n+    result         = noreg;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  Label L_fallthrough;\n+  int label_nulls = 0;\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n+\n+  \/\/ Load the array length.\n+  movl(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB! Effectively increments current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  addptr(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ Linear probe\n+  Label L_huge;\n+\n+  \/\/ The bitmap is full to bursting.\n+  \/\/ Implicit invariant: BITMAP_FULL implies (length > 0)\n+  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n+  cmpq(r_bitmap, (int32_t)-1); \/\/ sign-extends immediate to 64-bit value\n+  jcc(Assembler::equal, L_huge);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+\n+    xorl(temp2, temp2); \/\/ = 0;\n+\n+    Label L_again;\n+    bind(L_again);\n+\n+    \/\/ Check for array wraparound.\n+    cmpl(r_array_index, r_array_length);\n+    cmovl(Assembler::greaterEqual, r_array_index, temp2);\n+\n+    cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+    jcc(Assembler::equal, *L_success);\n+\n+    \/\/ If the next bit in bitmap is zero, we're done.\n+    btq(r_bitmap, 2); \/\/ look-ahead check (Bit 2); Bits 0 and 1 are tested by now\n+    jcc(Assembler::carryClear, *L_failure);\n+\n+    rorq(r_bitmap, 1); \/\/ Bits 1\/2 => 0\/1\n+    addl(r_array_index, 1);\n+\n+    jmp(L_again);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    bind(L_huge);\n+    xorl(r_array_index, r_array_index); \/\/ = 0\n+    repne_scanq(r_array_base, r_super_klass, r_array_index, r_array_length,\n+                L_success,\n+                (&L_fallthrough != L_failure ? L_failure : nullptr));\n+\n+    bind(L_fallthrough);\n+  }\n+}\n+\n+struct VerifyHelperArguments {\n+  Klass* _super;\n+  Klass* _sub;\n+  intptr_t _linear_result;\n+  intptr_t _table_result;\n+};\n+\n+static void verify_secondary_supers_table_helper(const char* msg, VerifyHelperArguments* args) {\n+  Klass::on_secondary_supers_verification_failure(args->_super,\n+                                                  args->_sub,\n+                                                  args->_linear_result,\n+                                                  args->_table_result,\n+                                                  msg);\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register result,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3) {\n+  const Register\n+      r_array_index  = temp1,\n+      r_array_length = temp2,\n+      r_array_base   = temp3,\n+      r_bitmap       = noreg;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  Label L_success, L_failure, L_check, L_done;\n+\n+  movptr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+  movl(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  addptr(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  testl(r_array_length, r_array_length); \/\/ array_length == 0?\n+  jcc(Assembler::zero, L_failure);\n+\n+  movl(r_array_index, 0);\n+  repne_scanq(r_array_base, r_super_klass, r_array_index, r_array_length, &L_success);\n+  \/\/ fall through to L_failure\n+\n+  const Register linear_result = r_array_index; \/\/ reuse temp1\n+\n+  bind(L_failure); \/\/ not present\n+  movl(linear_result, 1);\n+  jmp(L_check);\n+\n+  bind(L_success); \/\/ present\n+  movl(linear_result, 0);\n+\n+  bind(L_check);\n+  cmpl(linear_result, result);\n+  jcc(Assembler::equal, L_done);\n+\n+  { \/\/ To avoid calling convention issues, build a record on the stack\n+    \/\/ and pass the pointer to that instead.\n+    push(result);\n+    push(linear_result);\n+    push(r_sub_klass);\n+    push(r_super_klass);\n+    movptr(c_rarg1, rsp);\n+    movptr(c_rarg0, (uintptr_t) \"mismatch\");\n+    call(RuntimeAddress(CAST_FROM_FN_PTR(address, verify_secondary_supers_table_helper)));\n+    should_not_reach_here();\n+  }\n+  bind(L_done);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n+#undef LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS\n+\n+#endif \/\/ LP64\n+\n@@ -5968,1 +6312,1 @@\n-  cmpl(count, 2<<shift); \/\/ Short arrays (< 8 bytes) fill by element\n+  cmpptr(count, 2<<shift); \/\/ Short arrays (< 8 bytes) fill by element\n@@ -5988,1 +6332,1 @@\n-    subl(count, 1<<(shift-1));\n+    subptr(count, 1<<(shift-1));\n@@ -5994,1 +6338,1 @@\n-    subl(count, 8 << shift);\n+    subptr(count, 8 << shift);\n@@ -6005,1 +6349,1 @@\n-    subl(count, 8 << shift);\n+    subptr(count, 8 << shift);\n@@ -6008,1 +6352,1 @@\n-    addl(count, 8 << shift);\n+    addptr(count, 8 << shift);\n@@ -6020,1 +6364,1 @@\n-    subl(count, 1 << (shift + 1));\n+    subptr(count, 1 << (shift + 1));\n@@ -6031,1 +6375,1 @@\n-      subl(count, 1<<shift);\n+      subptr(count, 1<<shift);\n@@ -6045,1 +6389,1 @@\n-          cmpl(count, VM_Version::avx3_threshold());\n+          cmpptr(count, VM_Version::avx3_threshold());\n@@ -6050,1 +6394,1 @@\n-          subl(count, 16 << shift);\n+          subptr(count, 16 << shift);\n@@ -6057,1 +6401,1 @@\n-          subl(count, 16 << shift);\n+          subptr(count, 16 << shift);\n@@ -6067,1 +6411,1 @@\n-        subl(count, 16 << shift);\n+        subptr(count, 16 << shift);\n@@ -6075,1 +6419,1 @@\n-        subl(count, 16 << shift);\n+        subptr(count, 16 << shift);\n@@ -6079,1 +6423,1 @@\n-        addl(count, 8 << shift);\n+        addptr(count, 8 << shift);\n@@ -6083,1 +6427,1 @@\n-        subl(count, 8 << shift);\n+        subptr(count, 8 << shift);\n@@ -6093,1 +6437,1 @@\n-        subl(count, 8 << shift);\n+        subptr(count, 8 << shift);\n@@ -6110,1 +6454,1 @@\n-        subl(count, 8 << shift);\n+        subptr(count, 8 << shift);\n@@ -6115,1 +6459,1 @@\n-      addl(count, 8 << shift);\n+      addptr(count, 8 << shift);\n@@ -6126,1 +6470,1 @@\n-      subl(count, 1 << (shift + 1));\n+      subptr(count, 1 << (shift + 1));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":362,"deletions":18,"binary":false,"changes":380,"status":"modified"},{"patch":"@@ -598,0 +598,2 @@\n+  void population_count(Register dst, Register src, Register scratch1, Register scratch2);\n+\n@@ -648,0 +650,7 @@\n+  void hashed_check_klass_subtype_slow_path(Register sub_klass,\n+                                     Register super_klass,\n+                                     Register temp_reg,\n+                                     Register temp2_reg,\n+                                     Label* L_success,\n+                                     Label* L_failure,\n+                                     bool set_cond_codes = false);\n@@ -649,1 +658,32 @@\n-  \/\/ Simplified, combined version, good for typical uses.\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  void lookup_secondary_supers_table(Register sub_klass,\n+                                     Register super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     Register temp4,\n+                                     Register result,\n+                                     u1 super_klass_slot);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register temp1,\n+                                               Register temp2,\n+                                               Label* L_success,\n+                                               Label* L_failure = nullptr);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register expected,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3);\n+\n+  void repne_scanq(Register addr, Register value, Register count, Register limit,\n+                   Label* L_success,\n+                   Label* L_failure = nullptr);\n+\n+    \/\/ Simplified, combined version, good for typical uses.\n@@ -918,0 +958,68 @@\n+  \/\/ Adding more natural conditional jump instructions\n+  void ALWAYSINLINE jo(Label& L, bool maybe_short = true) { jcc(Assembler::overflow, L, maybe_short); }\n+  void ALWAYSINLINE jno(Label& L, bool maybe_short = true) { jcc(Assembler::noOverflow, L, maybe_short); }\n+  void ALWAYSINLINE js(Label& L, bool maybe_short = true) { jcc(Assembler::negative, L, maybe_short); }\n+  void ALWAYSINLINE jns(Label& L, bool maybe_short = true) { jcc(Assembler::positive, L, maybe_short); }\n+  void ALWAYSINLINE je(Label& L, bool maybe_short = true) { jcc(Assembler::equal, L, maybe_short); }\n+  void ALWAYSINLINE jz(Label& L, bool maybe_short = true) { jcc(Assembler::zero, L, maybe_short); }\n+  void ALWAYSINLINE jne(Label& L, bool maybe_short = true) { jcc(Assembler::notEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnz(Label& L, bool maybe_short = true) { jcc(Assembler::notZero, L, maybe_short); }\n+  void ALWAYSINLINE jb(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n+  void ALWAYSINLINE jnae(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n+  void ALWAYSINLINE jc(Label& L, bool maybe_short = true) { jcc(Assembler::carrySet, L, maybe_short); }\n+  void ALWAYSINLINE jnb(Label& L, bool maybe_short = true) { jcc(Assembler::aboveEqual, L, maybe_short); }\n+  void ALWAYSINLINE jae(Label& L, bool maybe_short = true) { jcc(Assembler::aboveEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnc(Label& L, bool maybe_short = true) { jcc(Assembler::carryClear, L, maybe_short); }\n+  void ALWAYSINLINE jbe(Label& L, bool maybe_short = true) { jcc(Assembler::belowEqual, L, maybe_short); }\n+  void ALWAYSINLINE jna(Label& L, bool maybe_short = true) { jcc(Assembler::belowEqual, L, maybe_short); }\n+  void ALWAYSINLINE ja(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n+  void ALWAYSINLINE jnbe(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n+  void ALWAYSINLINE jl(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n+  void ALWAYSINLINE jnge(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n+  void ALWAYSINLINE jge(Label& L, bool maybe_short = true) { jcc(Assembler::greaterEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnl(Label& L, bool maybe_short = true) { jcc(Assembler::greaterEqual, L, maybe_short); }\n+  void ALWAYSINLINE jle(Label& L, bool maybe_short = true) { jcc(Assembler::lessEqual, L, maybe_short); }\n+  void ALWAYSINLINE jng(Label& L, bool maybe_short = true) { jcc(Assembler::lessEqual, L, maybe_short); }\n+  void ALWAYSINLINE jg(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n+  void ALWAYSINLINE jnle(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n+  void ALWAYSINLINE jp(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n+  void ALWAYSINLINE jpe(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n+  void ALWAYSINLINE jnp(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n+  void ALWAYSINLINE jpo(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n+  \/\/ * No condition for this *  void ALWAYSINLINE jcxz(Label& L, bool maybe_short = true) { jcc(Assembler::cxz, L, maybe_short); }\n+  \/\/ * No condition for this *  void ALWAYSINLINE jecxz(Label& L, bool maybe_short = true) { jcc(Assembler::cxz, L, maybe_short); }\n+\n+  \/\/ Short versions of the above\n+  void ALWAYSINLINE jo_b(Label& L) { jccb(Assembler::overflow, L); }\n+  void ALWAYSINLINE jno_b(Label& L) { jccb(Assembler::noOverflow, L); }\n+  void ALWAYSINLINE js_b(Label& L) { jccb(Assembler::negative, L); }\n+  void ALWAYSINLINE jns_b(Label& L) { jccb(Assembler::positive, L); }\n+  void ALWAYSINLINE je_b(Label& L) { jccb(Assembler::equal, L); }\n+  void ALWAYSINLINE jz_b(Label& L) { jccb(Assembler::zero, L); }\n+  void ALWAYSINLINE jne_b(Label& L) { jccb(Assembler::notEqual, L); }\n+  void ALWAYSINLINE jnz_b(Label& L) { jccb(Assembler::notZero, L); }\n+  void ALWAYSINLINE jb_b(Label& L) { jccb(Assembler::below, L); }\n+  void ALWAYSINLINE jnae_b(Label& L) { jccb(Assembler::below, L); }\n+  void ALWAYSINLINE jc_b(Label& L) { jccb(Assembler::carrySet, L); }\n+  void ALWAYSINLINE jnb_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n+  void ALWAYSINLINE jae_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n+  void ALWAYSINLINE jnc_b(Label& L) { jccb(Assembler::carryClear, L); }\n+  void ALWAYSINLINE jbe_b(Label& L) { jccb(Assembler::belowEqual, L); }\n+  void ALWAYSINLINE jna_b(Label& L) { jccb(Assembler::belowEqual, L); }\n+  void ALWAYSINLINE ja_b(Label& L) { jccb(Assembler::above, L); }\n+  void ALWAYSINLINE jnbe_b(Label& L) { jccb(Assembler::above, L); }\n+  void ALWAYSINLINE jl_b(Label& L) { jccb(Assembler::less, L); }\n+  void ALWAYSINLINE jnge_b(Label& L) { jccb(Assembler::less, L); }\n+  void ALWAYSINLINE jge_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n+  void ALWAYSINLINE jnl_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n+  void ALWAYSINLINE jle_b(Label& L) { jccb(Assembler::lessEqual, L); }\n+  void ALWAYSINLINE jng_b(Label& L) { jccb(Assembler::lessEqual, L); }\n+  void ALWAYSINLINE jg_b(Label& L) { jccb(Assembler::greater, L); }\n+  void ALWAYSINLINE jnle_b(Label& L) { jccb(Assembler::greater, L); }\n+  void ALWAYSINLINE jp_b(Label& L) { jccb(Assembler::parity, L); }\n+  void ALWAYSINLINE jpe_b(Label& L) { jccb(Assembler::parity, L); }\n+  void ALWAYSINLINE jnp_b(Label& L) { jccb(Assembler::noParity, L); }\n+  void ALWAYSINLINE jpo_b(Label& L) { jccb(Assembler::noParity, L); }\n+  \/\/ * No condition for this *  void ALWAYSINLINE jcxz_b(Label& L) { jccb(Assembler::cxz, L); }\n+  \/\/ * No condition for this *  void ALWAYSINLINE jecxz_b(Label& L) { jccb(Assembler::cxz, L); }\n+\n@@ -1352,0 +1460,1 @@\n+  void vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -1353,0 +1462,1 @@\n+  void vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":111,"deletions":1,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -157,0 +157,10 @@\n+  \/\/ Does target support predicated operation emulation.\n+  static bool supports_vector_predicate_op_emulation(int vopc, int vlen, BasicType bt) {\n+    switch(vopc) {\n+      case Op_LoadVectorGatherMasked:\n+        return is_subword_type(bt) && VM_Version::supports_avx2();\n+      default:\n+        return false;\n+    }\n+  }\n+\n@@ -217,0 +227,3 @@\n+      case Op_LoadVectorGather:\n+      case Op_LoadVectorGatherMasked:\n+        return is_subword_type(ety) ? 50 : 0;\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1357,1 +1357,0 @@\n-\n@@ -1360,0 +1359,40 @@\n+\n+  if (CheckJNICalls) {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n+    __ jcc(Assembler::equal, L_skip_vthread_code);\n+\n+    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n+    \/\/ it failed to release a JNI monitor. So we issue the same log message\n+    \/\/ that JavaThread::exit does.\n+    __ cmpptr(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n+    __ jcc(Assembler::equal, L_skip_vthread_code);\n+\n+    \/\/ rax may hold an exception oop, save it before the call\n+    __ push(rax);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n+    __ pop(rax);\n+\n+    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n+    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n+    \/\/ the parent held count (which has to be zero).\n+    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n+    __ jcc(Assembler::equal, L_skip_vthread_code);\n+\n+    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n+    \/\/ needed for assertion checking.\n+    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#endif\n+\n@@ -1444,2 +1483,1 @@\n-    CodeBuffer* cbuf = masm->code_section()->outer();\n-    address stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, __ pc());\n+    address stub = CompiledDirectCall::emit_to_interp_stub(masm, __ pc());\n@@ -1481,2 +1519,1 @@\n-  CodeBuffer* cbuf = masm->code_section()->outer();\n-  address stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, __ pc());\n+  address stub = CompiledDirectCall::emit_to_interp_stub(masm, __ pc());\n@@ -3701,1 +3738,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":42,"deletions":6,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  int argsize = is_compiled() ? (_cb->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n+  int argsize = is_compiled() ? (_cb->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n","filename":"src\/hotspot\/cpu\/x86\/stackChunkFrameStream_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1134,2 +1134,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n-      UnsafeCopyMemoryMark ucmm(this, add_entry, true);\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+      UnsafeMemoryAccessMark umam(this, add_entry, true);\n@@ -1324,2 +1324,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n-      UnsafeCopyMemoryMark ucmm(this, add_entry, true);\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+      UnsafeMemoryAccessMark umam(this, add_entry, true);\n@@ -1453,2 +1453,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n-      UnsafeCopyMemoryMark ucmm(this, true, true);\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+      UnsafeMemoryAccessMark umam(this, true, true);\n@@ -1508,2 +1508,2 @@\n-      \/\/ UnsafeCopyMemory page error: continue after ucm\n-      UnsafeCopyMemoryMark ucmm(this, true, true);\n+      \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+      UnsafeMemoryAccessMark umam(this, true, true);\n@@ -4124,2 +4124,2 @@\n-    if (UnsafeCopyMemory::_table == nullptr) {\n-      UnsafeCopyMemory::create_table(16);\n+    if (UnsafeMemoryAccess::_table == nullptr) {\n+      UnsafeMemoryAccess::create_table(16 + 4); \/\/ 16 for copyMemory; 4 for setMemory\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3997,0 +3997,48 @@\n+address StubGenerator::generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+  StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+  address start = __ pc();\n+\n+  const Register\n+      r_super_klass = rax,\n+      r_sub_klass   = rsi,\n+      result        = rdi;\n+\n+  __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                   rdx, rcx, rbx, r11, \/\/ temps\n+                                   result,\n+                                   super_klass_index);\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/\/ Slow path implementation for UseSecondarySupersTable.\n+address StubGenerator::generate_lookup_secondary_supers_table_slow_path_stub() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+  address start = __ pc();\n+\n+  const Register\n+      r_super_klass  = rax,\n+      r_array_base   = rbx,\n+      r_array_index  = rdx,\n+      r_sub_klass    = rsi,\n+      r_bitmap       = r11,\n+      result         = rdi;\n+\n+  Label L_success;\n+  __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index, r_bitmap,\n+                                             rcx, rdi, \/\/ temps\n+                                             &L_success);\n+  \/\/ bind(L_failure);\n+  __ movl(result, 1);\n+  __ ret(0);\n+\n+  __ bind(L_success);\n+  __ movl(result, 0);\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n@@ -4012,2 +4060,2 @@\n-  if (UnsafeCopyMemory::_table == nullptr) {\n-    UnsafeCopyMemory::create_table(16);\n+  if (UnsafeMemoryAccess::_table == nullptr) {\n+    UnsafeMemoryAccess::create_table(16 + 4); \/\/ 16 for copyMemory; 4 for setMemory\n@@ -4282,0 +4330,8 @@\n+  if (UseSecondarySupersTable) {\n+    StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+    if (! InlineSecondarySupersTest) {\n+      for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+        StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n+      }\n+    }\n+  }\n@@ -4375,0 +4431,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":59,"deletions":2,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -271,0 +271,8 @@\n+  \/\/ Generate 'unsafe' set memory stub\n+  \/\/ Though just as safe as the other stubs, it takes an unscaled\n+  \/\/ size_t argument instead of an element count.\n+  \/\/\n+  \/\/ Examines the alignment of the operands and dispatches\n+  \/\/ to an int, short, or byte copy loop.\n+  address generate_unsafe_setmemory(const char *name, address byte_copy_entry);\n+\n@@ -608,0 +616,6 @@\n+  \/\/ Specialized stub implementations for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index);\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2184,0 +2184,1 @@\n+  const Register tail = r15;\n@@ -2618,1 +2619,0 @@\n-  __ evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0), Assembler::AVX_128bit);\n@@ -2622,1 +2622,3 @@\n-  __ pextrq(Address(dest_addr, pos), xmm0, 0);\n+  __ pextrq(tail, xmm0, 0);\n+  __ xorq(tail, Address(src_addr, pos, Address::times_1, 0));\n+  __ movq(Address(dest_addr, pos), tail);\n@@ -2628,1 +2630,3 @@\n-  __ pextrd(Address(dest_addr, pos), xmm0, 0);\n+  __ pextrd(tail, xmm0, 0);\n+  __ xorl(tail, Address(src_addr, pos, Address::times_1, 0));\n+  __ movl(Address(dest_addr, pos), tail);\n@@ -2634,1 +2638,3 @@\n-  __ pextrw(Address(dest_addr, pos), xmm0, 0);\n+  __ pextrw(tail, xmm0, 0);\n+  __ xorw(tail, Address(src_addr, pos, Address::times_1, 0));\n+  __ movw(Address(dest_addr, pos), tail);\n@@ -2640,1 +2646,3 @@\n-  __ pextrb(Address(dest_addr, pos), xmm0, 0);\n+  __ pextrb(tail, xmm0, 0);\n+  __ xorb(tail, Address(src_addr, pos, Address::times_1, 0));\n+  __ movb(Address(dest_addr, pos), tail);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,0 +155,2 @@\n+  StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory(\"unsafe_setmemory\", StubRoutines::_jbyte_fill);\n+\n@@ -561,2 +563,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n@@ -731,1 +733,2 @@\n-    arraycopy_avx3_large(to, from, temp1, temp2, temp3, temp4, count, xmm1, xmm2, xmm3, xmm4, shift);\n+      UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, false, ucme_exit_pc);\n+      arraycopy_avx3_large(to, from, temp1, temp2, temp3, temp4, count, xmm1, xmm2, xmm3, xmm4, shift);\n@@ -859,2 +862,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n@@ -1318,2 +1321,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !aligned, true);\n@@ -1374,1 +1377,1 @@\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, false, ucme_exit_pc);\n+    UnsafeMemoryAccessMark umam(this, !aligned, false, ucme_exit_pc);\n@@ -1432,2 +1435,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !aligned, true);\n@@ -1477,2 +1480,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !aligned, true);\n@@ -1549,2 +1552,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !aligned, true);\n@@ -1598,1 +1601,1 @@\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, false, ucme_exit_pc);\n+    UnsafeMemoryAccessMark umam(this, !aligned, false, ucme_exit_pc);\n@@ -1622,1 +1625,5 @@\n-  __ generate_fill(t, aligned, to, value, r11, rax, xmm0);\n+  {\n+    \/\/ Add set memory mark to protect against unsafe accesses faulting\n+    UnsafeMemoryAccessMark umam(this, ((t == T_BYTE) && !aligned), true);\n+    __ generate_fill(t, aligned, to, value, r11, rax, xmm0);\n+  }\n@@ -1681,2 +1688,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !aligned, true);\n@@ -1718,2 +1725,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !aligned, true);\n@@ -1802,2 +1809,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n@@ -1839,1 +1846,1 @@\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, false, ucme_exit_pc);\n+    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, false, ucme_exit_pc);\n@@ -1912,2 +1919,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n@@ -1945,2 +1952,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n@@ -2027,2 +2034,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n@@ -2059,2 +2066,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n@@ -2136,2 +2143,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n@@ -2163,2 +2170,2 @@\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ UnsafeMemoryAccess page error: continue after unsafe access\n+    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n@@ -2479,0 +2486,196 @@\n+\/\/ Static enum for helper\n+enum USM_TYPE {USM_SHORT, USM_DWORD, USM_QUADWORD};\n+\/\/ Helper for generate_unsafe_setmemory\n+\/\/\n+\/\/ Atomically fill an array of memory using 2-, 4-, or 8-byte chunks\n+static void do_setmemory_atomic_loop(USM_TYPE type, Register dest,\n+                                     Register size, Register wide_value,\n+                                     Register tmp, Label& L_exit,\n+                                     MacroAssembler *_masm) {\n+  Label L_Loop, L_Tail, L_TailLoop;\n+\n+  int shiftval = 0;\n+  int incr = 0;\n+\n+  switch (type) {\n+    case USM_SHORT:\n+      shiftval = 1;\n+      incr = 16;\n+      break;\n+    case USM_DWORD:\n+      shiftval = 2;\n+      incr = 32;\n+      break;\n+    case USM_QUADWORD:\n+      shiftval = 3;\n+      incr = 64;\n+      break;\n+  }\n+\n+  \/\/ At this point, we know the lower bits of size are zero\n+  __ shrq(size, shiftval);\n+  \/\/ size now has number of X-byte chunks (2, 4 or 8)\n+\n+  \/\/ Number of (8*X)-byte chunks into tmp\n+  __ movq(tmp, size);\n+  __ shrq(tmp, 3);\n+  __ jccb(Assembler::zero, L_Tail);\n+\n+  __ BIND(L_Loop);\n+\n+  \/\/ Unroll 8 stores\n+  for (int i = 0; i < 8; i++) {\n+    switch (type) {\n+      case USM_SHORT:\n+        __ movw(Address(dest, (2 * i)), wide_value);\n+        break;\n+      case USM_DWORD:\n+        __ movl(Address(dest, (4 * i)), wide_value);\n+        break;\n+      case USM_QUADWORD:\n+        __ movq(Address(dest, (8 * i)), wide_value);\n+        break;\n+    }\n+  }\n+  __ addq(dest, incr);\n+  __ decrementq(tmp);\n+  __ jccb(Assembler::notZero, L_Loop);\n+\n+  __ BIND(L_Tail);\n+\n+  \/\/ Find number of remaining X-byte chunks\n+  __ andq(size, 0x7);\n+\n+  \/\/ If zero, then we're done\n+  __ jccb(Assembler::zero, L_exit);\n+\n+  __ BIND(L_TailLoop);\n+\n+    switch (type) {\n+      case USM_SHORT:\n+        __ movw(Address(dest, 0), wide_value);\n+        break;\n+      case USM_DWORD:\n+        __ movl(Address(dest, 0), wide_value);\n+        break;\n+      case USM_QUADWORD:\n+        __ movq(Address(dest, 0), wide_value);\n+        break;\n+    }\n+  __ addq(dest, incr >> 3);\n+  __ decrementq(size);\n+  __ jccb(Assembler::notZero, L_TailLoop);\n+}\n+\n+\/\/  Generate 'unsafe' set memory stub\n+\/\/  Though just as safe as the other stubs, it takes an unscaled\n+\/\/  size_t (# bytes) argument instead of an element count.\n+\/\/\n+\/\/  Input:\n+\/\/    c_rarg0   - destination array address\n+\/\/    c_rarg1   - byte count (size_t)\n+\/\/    c_rarg2   - byte value\n+\/\/\n+\/\/ Examines the alignment of the operands and dispatches\n+\/\/ to an int, short, or byte fill loop.\n+\/\/\n+address StubGenerator::generate_unsafe_setmemory(const char *name,\n+                                                 address unsafe_byte_fill) {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+  __ enter();   \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  assert(unsafe_byte_fill != nullptr, \"Invalid call\");\n+\n+  \/\/ bump this on entry, not on exit:\n+  INC_COUNTER_NP(SharedRuntime::_unsafe_set_memory_ctr, rscratch1);\n+\n+  {\n+    Label L_exit, L_fillQuadwords, L_fillDwords, L_fillBytes;\n+\n+    const Register dest = c_rarg0;\n+    const Register size = c_rarg1;\n+    const Register byteVal = c_rarg2;\n+    const Register wide_value = rax;\n+    const Register rScratch1 = r10;\n+\n+    assert_different_registers(dest, size, byteVal, wide_value, rScratch1);\n+\n+    \/\/     fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n+\n+    __ testq(size, size);\n+    __ jcc(Assembler::zero, L_exit);\n+\n+    \/\/ Propagate byte to full Register\n+    __ movzbl(rScratch1, byteVal);\n+    __ mov64(wide_value, 0x0101010101010101ULL);\n+    __ imulq(wide_value, rScratch1);\n+\n+    \/\/ Check for pointer & size alignment\n+    __ movq(rScratch1, dest);\n+    __ orq(rScratch1, size);\n+\n+    __ testb(rScratch1, 7);\n+    __ jcc(Assembler::equal, L_fillQuadwords);\n+\n+    __ testb(rScratch1, 3);\n+    __ jcc(Assembler::equal, L_fillDwords);\n+\n+    __ testb(rScratch1, 1);\n+    __ jcc(Assembler::notEqual, L_fillBytes);\n+\n+    \/\/ Fill words\n+    {\n+      Label L_wordsTail, L_wordsLoop, L_wordsTailLoop;\n+      UnsafeMemoryAccessMark umam(this, true, true);\n+\n+      \/\/ At this point, we know the lower bit of size is zero and a\n+      \/\/ multiple of 2\n+      do_setmemory_atomic_loop(USM_SHORT, dest, size, wide_value, rScratch1,\n+                               L_exit, _masm);\n+    }\n+    __ jmpb(L_exit);\n+\n+    __ BIND(L_fillQuadwords);\n+\n+    \/\/ Fill QUADWORDs\n+    {\n+      Label L_qwordLoop, L_qwordsTail, L_qwordsTailLoop;\n+      UnsafeMemoryAccessMark umam(this, true, true);\n+\n+      \/\/ At this point, we know the lower 3 bits of size are zero and a\n+      \/\/ multiple of 8\n+      do_setmemory_atomic_loop(USM_QUADWORD, dest, size, wide_value, rScratch1,\n+                               L_exit, _masm);\n+    }\n+    __ BIND(L_exit);\n+\n+    __ leave();   \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret(0);\n+\n+    __ BIND(L_fillDwords);\n+\n+    \/\/ Fill DWORDs\n+    {\n+      Label L_dwordLoop, L_dwordsTail, L_dwordsTailLoop;\n+      UnsafeMemoryAccessMark umam(this, true, true);\n+\n+      \/\/ At this point, we know the lower 2 bits of size are zero and a\n+      \/\/ multiple of 4\n+      do_setmemory_atomic_loop(USM_DWORD, dest, size, wide_value, rScratch1,\n+                               L_exit, _masm);\n+    }\n+    __ jmpb(L_exit);\n+\n+    __ BIND(L_fillBytes);\n+    \/\/ Set up for tail call to previously generated byte fill routine\n+    \/\/ Parameter order is (ptr, byteVal, size)\n+    __ xchgq(c_rarg1, c_rarg2);\n+    __ leave();    \/\/ Clear effect of enter()\n+    __ jump(RuntimeAddress(unsafe_byte_fill));\n+  }\n+\n+  return start;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":239,"deletions":36,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -4060,1 +4060,0 @@\n-  \/\/ make sure klass doesn't have finalizer\n@@ -4063,1 +4062,1 @@\n-  \/\/ test to see if it has a finalizer or is malformed in some way\n+  \/\/ test to see if it is malformed in some way\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -791,0 +791,5 @@\n+  \/\/ x86_64 supports secondary supers table\n+  constexpr static bool supports_secondary_supers_table() {\n+    return LP64_ONLY(true) NOT_LP64(false); \/\/ not implemented on x86_32\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1190,2 +1190,2 @@\n-  static int emit_exception_handler(CodeBuffer &cbuf);\n-  static int emit_deopt_handler(CodeBuffer& cbuf);\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n+  static int emit_deopt_handler(C2_MacroAssembler* masm);\n@@ -1309,1 +1309,1 @@\n-int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf) {\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n@@ -1313,1 +1313,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1327,1 +1326,1 @@\n-int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf) {\n+int HandlerImpl::emit_deopt_handler(C2_MacroAssembler* masm) {\n@@ -1331,1 +1330,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1574,0 +1572,1 @@\n+    case Op_LoadVectorGatherMasked:\n@@ -1911,0 +1910,11 @@\n+      if (!is_subword_type(bt) && size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      if (is_subword_type(bt) &&\n+         (!is_LP64                                                ||\n+         (size_in_bits > 256 && !VM_Version::supports_avx512bw()) ||\n+         (size_in_bits < 64)                                      ||\n+         (bt == T_SHORT && !VM_Version::supports_bmi2()))) {\n+        return false;\n+      }\n+      break;\n@@ -1920,1 +1930,4 @@\n-      if (size_in_bits == 64 ) {\n+      if (!is_subword_type(bt) && size_in_bits == 64) {\n+        return false;\n+      }\n+      if (is_subword_type(bt) && size_in_bits < 64) {\n@@ -2526,1 +2539,1 @@\n-static void vec_mov_helper(CodeBuffer *cbuf, int src_lo, int dst_lo,\n+static void vec_mov_helper(C2_MacroAssembler *masm, int src_lo, int dst_lo,\n@@ -2532,2 +2545,1 @@\n-  if (cbuf) {\n-    C2_MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -2584,1 +2596,1 @@\n-void vec_spill_helper(CodeBuffer *cbuf, bool is_load,\n+void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n@@ -2586,2 +2598,1 @@\n-  if (cbuf) {\n-    C2_MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -2745,2 +2756,1 @@\n-  void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc*) const {\n-    C2_MacroAssembler _masm(&cbuf);\n+  void MachNopNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc*) const {\n@@ -2760,2 +2770,1 @@\n-  void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc* ra_) const {\n-    C2_MacroAssembler _masm(&cbuf);\n+  void MachBreakpointNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc* ra_) const {\n@@ -2774,1 +2783,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -4034,1 +4042,1 @@\n-\/\/ Gather INT, LONG, FLOAT, DOUBLE\n+\/\/ Gather BYTE, SHORT, INT, LONG, FLOAT, DOUBLE\n@@ -4037,1 +4045,2 @@\n-  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n) <= 32);\n+  predicate(!VM_Version::supports_avx512vl() && !is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            Matcher::vector_length_in_bytes(n) <= 32);\n@@ -4054,1 +4063,2 @@\n-  predicate(VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64);\n+  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64) &&\n+            !is_subword_type(Matcher::vector_element_basic_type(n)));\n@@ -4069,1 +4079,2 @@\n-  predicate(VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64);\n+  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64) &&\n+            !is_subword_type(Matcher::vector_element_basic_type(n)));\n@@ -4087,0 +4098,232 @@\n+\n+instruct vgather_subwordLE8B(vec dst, memory mem, rRegP idx_base, immI_0 offset, rRegP tmp, rRegI rtmp) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n+  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  effect(TEMP tmp, TEMP rtmp);\n+  format %{ \"vector_gatherLE8 $dst, $mem, $idx_base\\t! using $tmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ vgather8b_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vgather_subwordGT8B(vec dst, memory mem, rRegP idx_base, immI_0 offset, rRegP tmp, rRegP idx_base_temp,\n+                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI length, rFlagsReg cr) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n+  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP length, KILL cr);\n+  format %{ \"vector_gatherGT8 $dst, $mem, $idx_base\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp and $length as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int vector_len = Matcher::vector_length(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, noreg, $xtmp1$$XMMRegister,\n+                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, noreg, $length$$Register, vector_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vgather_subwordLE8B_off(vec dst, memory mem, rRegP idx_base, rRegI offset, rRegP tmp, rRegI rtmp, rFlagsReg cr) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n+  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  effect(TEMP tmp, TEMP rtmp, KILL cr);\n+  format %{ \"vector_gatherLE8_off $dst, $mem, $idx_base, $offset\\t! using $tmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ vgather8b_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+instruct vgather_subwordGT8B_off(vec dst, memory mem, rRegP idx_base, rRegI offset, rRegP tmp, rRegP idx_base_temp,\n+                                 vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI length, rFlagsReg cr) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n+  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP length, KILL cr);\n+  format %{ \"vector_gatherGT8_off $dst, $mem, $idx_base, $offset\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp and $length as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int vector_len = Matcher::vector_length(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, noreg, $xtmp1$$XMMRegister,\n+                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, noreg, $length$$Register, vector_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+#ifdef _LP64\n+instruct vgather_masked_subwordLE8B_avx3(vec dst, memory mem, rRegP idx_base, immI_0 offset, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n+  format %{ \"vector_masked_gatherLE8 $dst, $mem, $idx_base, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n+    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vgather_masked_subwordGT8B_avx3(vec dst, memory mem, rRegP idx_base, immI_0 offset, kReg mask, rRegP tmp, rRegP idx_base_temp,\n+                                         vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegL rtmp2, rRegL mask_idx, rRegI length, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n+  format %{ \"vector_gatherGT8_masked $dst, $mem, $idx_base, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int vector_len = Matcher::vector_length(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n+    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vgather_masked_subwordLE8B_off_avx3(vec dst, memory mem, rRegP idx_base, rRegI offset, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n+  format %{ \"vector_masked_gatherLE8_off $dst, $mem, $idx_base, $offset, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n+    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register,\n+                                $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vgather_masked_subwordGT8B_off_avx3(vec dst, memory mem, rRegP idx_base, rRegI offset, kReg mask, rRegP tmp, rRegP idx_base_temp,\n+                                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegL rtmp2, rRegL mask_idx, rRegI length, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n+  format %{ \"vector_gatherGT8_masked_off $dst, $mem, $idx_base, $offset, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int vector_len = Matcher::vector_length(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n+    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vgather_masked_subwordLE8B_avx2(vec dst, memory mem, rRegP idx_base, immI_0 offset, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n+  format %{ \"vector_masked_gatherLE8 $dst, $mem, $idx_base, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n+    if (elem_bt == T_SHORT) {\n+      __ movl($mask_idx$$Register, 0x55555555);\n+      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n+    }\n+    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n+    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vgather_masked_subwordGT8B_avx2(vec dst, memory mem, rRegP idx_base, immI_0 offset, vec mask, rRegP tmp, rRegP idx_base_temp,\n+                                         vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI rtmp2, rRegI mask_idx, rRegI length, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n+  format %{ \"vector_gatherGT8_masked $dst, $mem, $idx_base, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int vector_len = Matcher::vector_length(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n+    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n+    if (elem_bt == T_SHORT) {\n+      __ movl($mask_idx$$Register, 0x55555555);\n+      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n+    }\n+    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vgather_masked_subwordLE8B_off_avx2(vec dst, memory mem, rRegP idx_base, rRegI offset, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n+  format %{ \"vector_masked_gatherLE8_off $dst, $mem, $idx_base, $offset, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n+    if (elem_bt == T_SHORT) {\n+      __ movl($mask_idx$$Register, 0x55555555);\n+      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n+    }\n+    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n+    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register,\n+                                $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vgather_masked_subwordGT8B_off_avx2(vec dst, memory mem, rRegP idx_base, rRegI offset, vec mask, rRegP tmp, rRegP idx_base_temp,\n+                                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI rtmp2, rRegI mask_idx, rRegI length, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n+  format %{ \"vector_gatherGT8_masked_off $dst, $mem, $idx_base, $offset, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int vector_len = Matcher::vector_length(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n+    __ lea($tmp$$Register, $mem$$Address);\n+    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n+    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n+    if (elem_bt == T_SHORT) {\n+      __ movl($mask_idx$$Register, 0x55555555);\n+      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n+    }\n+    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":265,"deletions":22,"binary":false,"changes":287,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -340,1 +340,1 @@\n-void emit_rm(CodeBuffer &cbuf, int f1, int f2, int f3) {\n+void emit_rm(C2_MacroAssembler *masm, int f1, int f2, int f3) {\n@@ -342,1 +342,1 @@\n-  cbuf.insts()->emit_int8(c);\n+  __ emit_int8(c);\n@@ -346,1 +346,1 @@\n-void emit_cc(CodeBuffer &cbuf, int f1, int f2) {\n+void emit_cc(C2_MacroAssembler *masm, int f1, int f2) {\n@@ -348,1 +348,1 @@\n-  cbuf.insts()->emit_int8(c);\n+  __ emit_int8(c);\n@@ -352,2 +352,2 @@\n-void emit_opcode(CodeBuffer &cbuf, int code) {\n-  cbuf.insts()->emit_int8((unsigned char) code);\n+void emit_opcode(C2_MacroAssembler *masm, int code) {\n+  __ emit_int8((unsigned char) code);\n@@ -357,3 +357,3 @@\n-void emit_opcode(CodeBuffer &cbuf, int code, relocInfo::relocType reloc, int offset = 0) {\n-  cbuf.relocate(cbuf.insts_mark() + offset, reloc);\n-  emit_opcode(cbuf, code);\n+void emit_opcode(C2_MacroAssembler *masm, int code, relocInfo::relocType reloc, int offset = 0) {\n+  __ relocate(__ inst_mark() + offset, reloc);\n+  emit_opcode(masm, code);\n@@ -363,2 +363,2 @@\n-void emit_d8(CodeBuffer &cbuf, int d8) {\n-  cbuf.insts()->emit_int8((unsigned char) d8);\n+void emit_d8(C2_MacroAssembler *masm, int d8) {\n+  __ emit_int8((unsigned char) d8);\n@@ -368,2 +368,2 @@\n-void emit_d16(CodeBuffer &cbuf, int d16) {\n-  cbuf.insts()->emit_int16(d16);\n+void emit_d16(C2_MacroAssembler *masm, int d16) {\n+  __ emit_int16(d16);\n@@ -373,2 +373,2 @@\n-void emit_d32(CodeBuffer &cbuf, int d32) {\n-  cbuf.insts()->emit_int32(d32);\n+void emit_d32(C2_MacroAssembler *masm, int d32) {\n+  __ emit_int32(d32);\n@@ -378,1 +378,1 @@\n-void emit_d32_reloc(CodeBuffer &cbuf, int d32, relocInfo::relocType reloc,\n+void emit_d32_reloc(C2_MacroAssembler *masm, int d32, relocInfo::relocType reloc,\n@@ -380,2 +380,2 @@\n-  cbuf.relocate(cbuf.insts_mark(), reloc, format);\n-  cbuf.insts()->emit_int32(d32);\n+  __ relocate(__ inst_mark(), reloc, format);\n+  __ emit_int32(d32);\n@@ -385,1 +385,1 @@\n-void emit_d32_reloc(CodeBuffer &cbuf, int d32, RelocationHolder const& rspec,\n+void emit_d32_reloc(C2_MacroAssembler *masm, int d32, RelocationHolder const& rspec,\n@@ -392,2 +392,2 @@\n-  cbuf.relocate(cbuf.insts_mark(), rspec, format);\n-  cbuf.insts()->emit_int32(d32);\n+  __ relocate(__ inst_mark(), rspec, format);\n+  __ emit_int32(d32);\n@@ -397,2 +397,2 @@\n-void store_to_stackslot(CodeBuffer &cbuf, int opcode, int rm_field, int disp) {\n-  emit_opcode( cbuf, opcode );               \/\/ (e.g., FILD   [ESP+src])\n+void store_to_stackslot(C2_MacroAssembler *masm, int opcode, int rm_field, int disp) {\n+  emit_opcode( masm, opcode );               \/\/ (e.g., FILD   [ESP+src])\n@@ -400,3 +400,3 @@\n-    emit_rm( cbuf, 0x01, rm_field, ESP_enc );  \/\/ R\/M byte\n-    emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    \/\/ SIB byte\n-    emit_d8 (cbuf, disp);     \/\/ Displacement  \/\/ R\/M byte\n+    emit_rm( masm, 0x01, rm_field, ESP_enc );  \/\/ R\/M byte\n+    emit_rm( masm, 0x00, ESP_enc, ESP_enc);    \/\/ SIB byte\n+    emit_d8 (masm, disp);     \/\/ Displacement  \/\/ R\/M byte\n@@ -404,3 +404,3 @@\n-    emit_rm( cbuf, 0x02, rm_field, ESP_enc );  \/\/ R\/M byte\n-    emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    \/\/ SIB byte\n-    emit_d32(cbuf, disp);     \/\/ Displacement  \/\/ R\/M byte\n+    emit_rm( masm, 0x02, rm_field, ESP_enc );  \/\/ R\/M byte\n+    emit_rm( masm, 0x00, ESP_enc, ESP_enc);    \/\/ SIB byte\n+    emit_d32(masm, disp);     \/\/ Displacement  \/\/ R\/M byte\n@@ -411,1 +411,1 @@\n-void encode_RegMem( CodeBuffer &cbuf, int reg_encoding, int base, int index, int scale, int displace, relocInfo::relocType disp_reloc ) {\n+void encode_RegMem( C2_MacroAssembler *masm, int reg_encoding, int base, int index, int scale, int displace, relocInfo::relocType disp_reloc ) {\n@@ -417,1 +417,1 @@\n-      emit_rm(cbuf, 0x0, reg_encoding, base);\n+      emit_rm(masm, 0x0, reg_encoding, base);\n@@ -422,2 +422,2 @@\n-        emit_rm(cbuf, 0x1, reg_encoding, base);\n-        emit_d8(cbuf, displace);\n+        emit_rm(masm, 0x1, reg_encoding, base);\n+        emit_d8(masm, displace);\n@@ -427,1 +427,1 @@\n-          emit_rm(cbuf, 0x0, reg_encoding, 0x5);\n+          emit_rm(masm, 0x0, reg_encoding, 0x5);\n@@ -430,1 +430,1 @@\n-            emit_d32_reloc(cbuf, displace, disp_reloc, 1);\n+            emit_d32_reloc(masm, displace, disp_reloc, 1);\n@@ -432,1 +432,1 @@\n-            emit_d32      (cbuf, displace);\n+            emit_d32      (masm, displace);\n@@ -436,1 +436,1 @@\n-          emit_rm(cbuf, 0x2, reg_encoding, base);\n+          emit_rm(masm, 0x2, reg_encoding, base);\n@@ -438,1 +438,1 @@\n-            emit_d32_reloc(cbuf, displace, disp_reloc, 1);\n+            emit_d32_reloc(masm, displace, disp_reloc, 1);\n@@ -440,1 +440,1 @@\n-            emit_d32      (cbuf, displace);\n+            emit_d32      (masm, displace);\n@@ -449,2 +449,2 @@\n-      emit_rm(cbuf, 0x0, reg_encoding, 0x4);\n-      emit_rm(cbuf, scale, index, base);\n+      emit_rm(masm, 0x0, reg_encoding, 0x4);\n+      emit_rm(masm, scale, index, base);\n@@ -455,3 +455,3 @@\n-        emit_rm(cbuf, 0x1, reg_encoding, 0x4);\n-        emit_rm(cbuf, scale, index, base);\n-        emit_d8(cbuf, displace);\n+        emit_rm(masm, 0x1, reg_encoding, 0x4);\n+        emit_rm(masm, scale, index, base);\n+        emit_d8(masm, displace);\n@@ -461,2 +461,2 @@\n-          emit_rm(cbuf, 0x2, reg_encoding, 0x4);\n-          emit_rm(cbuf, scale, index, 0x04);\n+          emit_rm(masm, 0x2, reg_encoding, 0x4);\n+          emit_rm(masm, scale, index, 0x04);\n@@ -464,2 +464,2 @@\n-          emit_rm(cbuf, 0x2, reg_encoding, 0x4);\n-          emit_rm(cbuf, scale, index, base);\n+          emit_rm(masm, 0x2, reg_encoding, 0x4);\n+          emit_rm(masm, scale, index, base);\n@@ -468,1 +468,1 @@\n-          emit_d32_reloc(cbuf, displace, disp_reloc, 1);\n+          emit_d32_reloc(masm, displace, disp_reloc, 1);\n@@ -470,1 +470,1 @@\n-          emit_d32      (cbuf, displace);\n+          emit_d32      (masm, displace);\n@@ -478,1 +478,1 @@\n-void encode_Copy( CodeBuffer &cbuf, int dst_encoding, int src_encoding ) {\n+void encode_Copy( C2_MacroAssembler *masm, int dst_encoding, int src_encoding ) {\n@@ -482,2 +482,2 @@\n-    emit_opcode( cbuf, 0x8B );\n-    emit_rm(cbuf, 0x3, dst_encoding, src_encoding );\n+    emit_opcode( masm, 0x8B );\n+    emit_rm(masm, 0x3, dst_encoding, src_encoding );\n@@ -487,1 +487,1 @@\n-void emit_cmpfp_fixup(MacroAssembler& _masm) {\n+void emit_cmpfp_fixup(MacroAssembler* masm) {\n@@ -507,1 +507,1 @@\n-static void emit_cmpfp3(MacroAssembler& _masm, Register dst) {\n+static void emit_cmpfp3(MacroAssembler* masm, Register dst) {\n@@ -530,1 +530,1 @@\n-void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n@@ -610,1 +610,1 @@\n-void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -612,1 +612,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -619,1 +618,1 @@\n-  C->output()->set_frame_complete(cbuf.insts_size());\n+  C->output()->set_frame_complete(__ offset());\n@@ -667,1 +666,1 @@\n-void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachEpilogNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -669,1 +668,0 @@\n-  MacroAssembler _masm(&cbuf);\n@@ -674,1 +672,1 @@\n-    _masm.vzeroupper();\n+    __ vzeroupper();\n@@ -678,1 +676,1 @@\n-    _masm.fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n+    __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n@@ -689,3 +687,3 @@\n-    emit_opcode(cbuf, 0x81); \/\/ add  SP, #framesize\n-    emit_rm(cbuf, 0x3, 0x00, ESP_enc);\n-    emit_d32(cbuf, framesize);\n+    emit_opcode(masm, 0x81); \/\/ add  SP, #framesize\n+    emit_rm(masm, 0x3, 0x00, ESP_enc);\n+    emit_d32(masm, framesize);\n@@ -693,3 +691,3 @@\n-    emit_opcode(cbuf, 0x83); \/\/ add  SP, #framesize\n-    emit_rm(cbuf, 0x3, 0x00, ESP_enc);\n-    emit_d8(cbuf, framesize);\n+    emit_opcode(masm, 0x83); \/\/ add  SP, #framesize\n+    emit_rm(masm, 0x3, 0x00, ESP_enc);\n+    emit_d8(masm, framesize);\n@@ -698,1 +696,1 @@\n-  emit_opcode(cbuf, 0x58 | EBP_enc);\n+  emit_opcode(masm, 0x58 | EBP_enc);\n@@ -706,1 +704,0 @@\n-    MacroAssembler masm(&cbuf);\n@@ -715,0 +712,1 @@\n+    __ set_inst_mark();\n@@ -716,0 +714,1 @@\n+    __ clear_inst_mark();\n@@ -752,1 +751,1 @@\n-static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,\n+static int impl_helper( C2_MacroAssembler *masm, bool do_size, bool is_load, int offset, int reg,\n@@ -754,3 +753,5 @@\n-  if( cbuf ) {\n-    emit_opcode  (*cbuf, opcode );\n-    encode_RegMem(*cbuf, Matcher::_regEncode[reg], ESP_enc, 0x4, 0, offset, relocInfo::none);\n+  if( masm ) {\n+    masm->set_inst_mark();\n+    emit_opcode  (masm, opcode );\n+    encode_RegMem(masm, Matcher::_regEncode[reg], ESP_enc, 0x4, 0, offset, relocInfo::none);\n+    masm->clear_inst_mark();\n@@ -773,1 +774,1 @@\n-static int impl_x_helper( CodeBuffer *cbuf, bool do_size, bool is_load,\n+static int impl_x_helper( C2_MacroAssembler *masm, bool do_size, bool is_load,\n@@ -781,2 +782,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -785,1 +785,1 @@\n-    _masm.set_managed();\n+    __ set_managed();\n@@ -832,1 +832,1 @@\n-static int impl_movx_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,\n+static int impl_movx_helper( C2_MacroAssembler *masm, bool do_size, int src_lo, int dst_lo,\n@@ -834,2 +834,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -837,1 +836,1 @@\n-    _masm.set_managed();\n+    __ set_managed();\n@@ -871,1 +870,1 @@\n-static int impl_movgpr2x_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,\n+static int impl_movgpr2x_helper( C2_MacroAssembler *masm, bool do_size, int src_lo, int dst_lo,\n@@ -874,2 +873,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -877,1 +875,1 @@\n-    _masm.set_managed();\n+    __ set_managed();\n@@ -889,1 +887,1 @@\n-static int impl_movx2gpr_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,\n+static int impl_movx2gpr_helper( C2_MacroAssembler *masm, bool do_size, int src_lo, int dst_lo,\n@@ -892,2 +890,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -895,1 +892,1 @@\n-    _masm.set_managed();\n+    __ set_managed();\n@@ -906,4 +903,4 @@\n-static int impl_mov_helper( CodeBuffer *cbuf, bool do_size, int src, int dst, int size, outputStream* st ) {\n-  if( cbuf ) {\n-    emit_opcode(*cbuf, 0x8B );\n-    emit_rm    (*cbuf, 0x3, Matcher::_regEncode[dst], Matcher::_regEncode[src] );\n+static int impl_mov_helper( C2_MacroAssembler *masm, bool do_size, int src, int dst, int size, outputStream* st ) {\n+  if( masm ) {\n+    emit_opcode(masm, 0x8B );\n+    emit_rm    (masm, 0x3, Matcher::_regEncode[dst], Matcher::_regEncode[src] );\n@@ -919,1 +916,1 @@\n-static int impl_fp_store_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int src_hi, int dst_lo, int dst_hi,\n+static int impl_fp_store_helper( C2_MacroAssembler *masm, bool do_size, int src_lo, int src_hi, int dst_lo, int dst_hi,\n@@ -922,3 +919,3 @@\n-    if( cbuf ) {\n-      emit_opcode( *cbuf, 0xD9 );  \/\/ FLD (i.e., push it)\n-      emit_d8( *cbuf, 0xC0-1+Matcher::_regEncode[src_lo] );\n+    if( masm ) {\n+      emit_opcode( masm, 0xD9 );  \/\/ FLD (i.e., push it)\n+      emit_d8( masm, 0xC0-1+Matcher::_regEncode[src_lo] );\n@@ -946,1 +943,1 @@\n-  return impl_helper(cbuf,do_size,false,offset,st_op,op,op_str,size, st);\n+  return impl_helper(masm,do_size,false,offset,st_op,op,op_str,size, st);\n@@ -950,1 +947,1 @@\n-static void vec_mov_helper(CodeBuffer *cbuf, int src_lo, int dst_lo,\n+static void vec_mov_helper(C2_MacroAssembler *masm, int src_lo, int dst_lo,\n@@ -953,1 +950,1 @@\n-void vec_spill_helper(CodeBuffer *cbuf, bool is_load,\n+void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n@@ -956,1 +953,1 @@\n-static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,\n+static void vec_stack_to_stack_helper(C2_MacroAssembler *masm, int src_offset,\n@@ -958,2 +955,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -1035,1 +1031,1 @@\n-uint MachSpillCopyNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {\n+uint MachSpillCopyNode::implementation( C2_MacroAssembler *masm, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {\n@@ -1064,1 +1060,1 @@\n-      vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);\n+      vec_stack_to_stack_helper(masm, src_offset, dst_offset, ireg, st);\n@@ -1066,1 +1062,1 @@\n-      vec_mov_helper(cbuf, src_first, dst_first, src_second, dst_second, ireg, st);\n+      vec_mov_helper(masm, src_first, dst_first, src_second, dst_second, ireg, st);\n@@ -1069,1 +1065,1 @@\n-      vec_spill_helper(cbuf, false, stack_offset, src_first, ireg, st);\n+      vec_spill_helper(masm, false, stack_offset, src_first, ireg, st);\n@@ -1072,1 +1068,1 @@\n-      vec_spill_helper(cbuf, true,  stack_offset, dst_first, ireg, st);\n+      vec_spill_helper(masm, true,  stack_offset, dst_first, ireg, st);\n@@ -1084,2 +1080,2 @@\n-      size = impl_helper(cbuf,do_size,true ,ra_->reg2offset(src_second),ESI_num,0xFF,\"PUSH  \",size, st);\n-      size = impl_helper(cbuf,do_size,false,ra_->reg2offset(dst_second),EAX_num,0x8F,\"POP   \",size, st);\n+      size = impl_helper(masm,do_size,true ,ra_->reg2offset(src_second),ESI_num,0xFF,\"PUSH  \",size, st);\n+      size = impl_helper(masm,do_size,false,ra_->reg2offset(dst_second),EAX_num,0x8F,\"POP   \",size, st);\n@@ -1089,2 +1085,2 @@\n-    size = impl_helper(cbuf,do_size,true ,ra_->reg2offset(src_first),ESI_num,0xFF,\"PUSH  \",size, st);\n-    size = impl_helper(cbuf,do_size,false,ra_->reg2offset(dst_first),EAX_num,0x8F,\"POP   \",size, st);\n+    size = impl_helper(masm,do_size,true ,ra_->reg2offset(src_first),ESI_num,0xFF,\"PUSH  \",size, st);\n+    size = impl_helper(masm,do_size,false,ra_->reg2offset(dst_first),EAX_num,0x8F,\"POP   \",size, st);\n@@ -1092,2 +1088,2 @@\n-      size = impl_helper(cbuf,do_size,true ,ra_->reg2offset(src_second),ESI_num,0xFF,\"PUSH  \",size, st);\n-      size = impl_helper(cbuf,do_size,false,ra_->reg2offset(dst_second),EAX_num,0x8F,\"POP   \",size, st);\n+      size = impl_helper(masm,do_size,true ,ra_->reg2offset(src_second),ESI_num,0xFF,\"PUSH  \",size, st);\n+      size = impl_helper(masm,do_size,false,ra_->reg2offset(dst_second),EAX_num,0x8F,\"POP   \",size, st);\n@@ -1101,1 +1097,1 @@\n-    size = impl_mov_helper(cbuf,do_size,src_first,dst_first,size, st);\n+    size = impl_mov_helper(masm,do_size,src_first,dst_first,size, st);\n@@ -1105,1 +1101,1 @@\n-    size = impl_helper(cbuf,do_size,false,ra_->reg2offset(dst_first),src_first,0x89,\"MOV \",size, st);\n+    size = impl_helper(masm,do_size,false,ra_->reg2offset(dst_first),src_first,0x89,\"MOV \",size, st);\n@@ -1109,1 +1105,1 @@\n-    size = impl_helper(cbuf,do_size,true ,ra_->reg2offset(src_first),dst_first,0x8B,\"MOV \",size, st);\n+    size = impl_helper(masm,do_size,true ,ra_->reg2offset(src_first),dst_first,0x8B,\"MOV \",size, st);\n@@ -1115,1 +1111,1 @@\n-    return impl_movgpr2x_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);\n+    return impl_movgpr2x_helper(masm,do_size,src_first,dst_first,src_second, dst_second, size, st);\n@@ -1122,1 +1118,1 @@\n-    if( cbuf ) {\n+    if( masm ) {\n@@ -1129,4 +1125,4 @@\n-        emit_opcode  (*cbuf, 0xD9 );           \/\/ FLD    ST(i)\n-        emit_d8      (*cbuf, 0xC0+Matcher::_regEncode[src_first]-1 );\n-        emit_opcode  (*cbuf, 0xDD );           \/\/ FSTP   ST(i)\n-        emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );\n+        emit_opcode  (masm, 0xD9 );           \/\/ FLD    ST(i)\n+        emit_d8      (masm, 0xC0+Matcher::_regEncode[src_first]-1 );\n+        emit_opcode  (masm, 0xDD );           \/\/ FSTP   ST(i)\n+        emit_d8      (masm, 0xD8+Matcher::_regEncode[dst_first] );\n@@ -1134,2 +1130,2 @@\n-        emit_opcode  (*cbuf, 0xDD );           \/\/ FST    ST(i)\n-        emit_d8      (*cbuf, 0xD0+Matcher::_regEncode[dst_first]-1 );\n+        emit_opcode  (masm, 0xDD );           \/\/ FST    ST(i)\n+        emit_d8      (masm, 0xD0+Matcher::_regEncode[dst_first]-1 );\n@@ -1149,1 +1145,1 @@\n-    return impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,ra_->reg2offset(dst_first),size, st);\n+    return impl_fp_store_helper(masm,do_size,src_first,src_second,dst_first,dst_second,ra_->reg2offset(dst_first),size, st);\n@@ -1165,5 +1161,7 @@\n-    if( cbuf ) {\n-      emit_opcode  (*cbuf, op );\n-      encode_RegMem(*cbuf, 0x0, ESP_enc, 0x4, 0, offset, relocInfo::none);\n-      emit_opcode  (*cbuf, 0xDD );           \/\/ FSTP   ST(i)\n-      emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );\n+    if( masm ) {\n+      masm->set_inst_mark();\n+      emit_opcode  (masm, op );\n+      encode_RegMem(masm, 0x0, ESP_enc, 0x4, 0, offset, relocInfo::none);\n+      emit_opcode  (masm, 0xDD );           \/\/ FSTP   ST(i)\n+      emit_d8      (masm, 0xD8+Matcher::_regEncode[dst_first] );\n+      masm->clear_inst_mark();\n@@ -1185,1 +1183,1 @@\n-    return impl_movx_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);\n+    return impl_movx_helper(masm,do_size,src_first,dst_first,src_second, dst_second, size, st);\n@@ -1192,1 +1190,1 @@\n-    return impl_movx2gpr_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);\n+    return impl_movx2gpr_helper(masm,do_size,src_first,dst_first,src_second, dst_second, size, st);\n@@ -1197,1 +1195,1 @@\n-    return impl_x_helper(cbuf,do_size,false,ra_->reg2offset(dst_first), src_first, src_second, size, st);\n+    return impl_x_helper(masm,do_size,false,ra_->reg2offset(dst_first), src_first, src_second, size, st);\n@@ -1202,1 +1200,1 @@\n-    return impl_x_helper(cbuf,do_size,true ,ra_->reg2offset(src_first),dst_first, dst_second, size, st);\n+    return impl_x_helper(masm,do_size,true ,ra_->reg2offset(src_first),dst_first, dst_second, size, st);\n@@ -1209,5 +1207,5 @@\n-    if( cbuf ) {\n-      emit_opcode(*cbuf,0x8D);  \/\/ LEA  ESP,[ESP-8]\n-      emit_rm(*cbuf, 0x1, ESP_enc, 0x04);\n-      emit_rm(*cbuf, 0x0, 0x04, ESP_enc);\n-      emit_d8(*cbuf,0xF8);\n+    if( masm ) {\n+      emit_opcode(masm,0x8D);  \/\/ LEA  ESP,[ESP-8]\n+      emit_rm(masm, 0x1, ESP_enc, 0x04);\n+      emit_rm(masm, 0x0, 0x04, ESP_enc);\n+      emit_d8(masm,0xF8);\n@@ -1222,1 +1220,1 @@\n-    size = impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,0,size, st);\n+    size = impl_fp_store_helper(masm,do_size,src_first,src_second,dst_first,dst_second,0,size, st);\n@@ -1225,1 +1223,1 @@\n-    size = impl_x_helper(cbuf,do_size,true ,0,dst_first, dst_second, size, st);\n+    size = impl_x_helper(masm,do_size,true ,0,dst_first, dst_second, size, st);\n@@ -1227,5 +1225,5 @@\n-    if( cbuf ) {\n-      emit_opcode(*cbuf,0x8D);  \/\/ LEA  ESP,[ESP+8]\n-      emit_rm(*cbuf, 0x1, ESP_enc, 0x04);\n-      emit_rm(*cbuf, 0x0, 0x04, ESP_enc);\n-      emit_d8(*cbuf,0x08);\n+    if( masm ) {\n+      emit_opcode(masm,0x8D);  \/\/ LEA  ESP,[ESP+8]\n+      emit_rm(masm, 0x1, ESP_enc, 0x04);\n+      emit_rm(masm, 0x0, 0x04, ESP_enc);\n+      emit_d8(masm,0x08);\n@@ -1247,2 +1245,1 @@\n-    if (cbuf != nullptr) {\n-      MacroAssembler _masm(cbuf);\n+    if (masm != nullptr) {\n@@ -1262,2 +1259,1 @@\n-    if (cbuf != nullptr) {\n-      MacroAssembler _masm(cbuf);\n+    if (masm != nullptr) {\n@@ -1286,2 +1282,1 @@\n-    if (cbuf != nullptr) {\n-      MacroAssembler _masm(cbuf);\n+    if (masm != nullptr) {\n@@ -1307,1 +1302,1 @@\n-    return impl_mov_helper(cbuf,do_size,src_second,dst_second,size, st);\n+    return impl_mov_helper(masm,do_size,src_second,dst_second,size, st);\n@@ -1311,1 +1306,1 @@\n-    return impl_helper(cbuf,do_size,false,ra_->reg2offset(dst_second),src_second,0x89,\"MOV \",size, st);\n+    return impl_helper(masm,do_size,false,ra_->reg2offset(dst_second),src_second,0x89,\"MOV \",size, st);\n@@ -1315,1 +1310,1 @@\n-    return impl_helper(cbuf,do_size,true ,ra_->reg2offset(src_second),dst_second,0x8B,\"MOV \",size, st);\n+    return impl_helper(masm,do_size,true ,ra_->reg2offset(src_second),dst_second,0x8B,\"MOV \",size, st);\n@@ -1327,2 +1322,2 @@\n-void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  implementation( &cbuf, ra_, false, nullptr );\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation( masm, ra_, false, nullptr );\n@@ -1345,1 +1340,1 @@\n-void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void BoxLockNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1349,4 +1344,4 @@\n-    emit_opcode(cbuf, 0x8D);      \/\/ LEA  reg,[SP+offset]\n-    emit_rm(cbuf, 0x2, reg, 0x04);\n-    emit_rm(cbuf, 0x0, 0x04, ESP_enc);\n-    emit_d32(cbuf, offset);\n+    emit_opcode(masm, 0x8D);      \/\/ LEA  reg,[SP+offset]\n+    emit_rm(masm, 0x2, reg, 0x04);\n+    emit_rm(masm, 0x0, 0x04, ESP_enc);\n+    emit_d32(masm, offset);\n@@ -1355,4 +1350,4 @@\n-    emit_opcode(cbuf, 0x8D);      \/\/ LEA  reg,[SP+offset]\n-    emit_rm(cbuf, 0x1, reg, 0x04);\n-    emit_rm(cbuf, 0x0, 0x04, ESP_enc);\n-    emit_d8(cbuf, offset);\n+    emit_opcode(masm, 0x8D);      \/\/ LEA  reg,[SP+offset]\n+    emit_rm(masm, 0x1, reg, 0x04);\n+    emit_rm(masm, 0x0, 0x04, ESP_enc);\n+    emit_d8(masm, offset);\n@@ -1384,3 +1379,2 @@\n-void MachUEPNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  MacroAssembler masm(&cbuf);\n-  masm.ic_check(CodeEntryAlignment);\n+void MachUEPNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  __ ic_check(CodeEntryAlignment);\n@@ -1531,0 +1525,12 @@\n+  \/\/ Set instruction mark in MacroAssembler. This is used only in\n+  \/\/ instructions that emit bytes directly to the CodeBuffer wraped\n+  \/\/ in the MacroAssembler. Should go away once all \"instruct\" are\n+  \/\/ patched to emit bytes only using methods in MacroAssembler.\n+  enc_class SetInstMark %{\n+    __ set_inst_mark();\n+  %}\n+\n+  enc_class ClearInstMark %{\n+    __ clear_inst_mark();\n+  %}\n+\n@@ -1533,1 +1539,1 @@\n-    emit_opcode(cbuf, $primary);\n+    emit_opcode(masm, $primary);\n@@ -1538,1 +1544,1 @@\n-    emit_opcode(cbuf, $secondary);\n+    emit_opcode(masm, $secondary);\n@@ -1543,1 +1549,1 @@\n-    emit_opcode(cbuf, $d8$$constant);\n+    emit_opcode(masm, $d8$$constant);\n@@ -1547,1 +1553,1 @@\n-    emit_opcode(cbuf,0x66);\n+    emit_opcode(masm,0x66);\n@@ -1551,1 +1557,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -1555,2 +1561,2 @@\n-    emit_opcode(cbuf,$opcode$$constant);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_opcode(masm,$opcode$$constant);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -1560,2 +1566,2 @@\n-    emit_opcode( cbuf, 0xB8 + $dst$$reg ); \/\/ 0xB8+ rd   -- MOV r32  ,imm32\n-    emit_d32   ( cbuf, 0x0  );             \/\/                         imm32==0x0\n+    emit_opcode( masm, 0xB8 + $dst$$reg ); \/\/ 0xB8+ rd   -- MOV r32  ,imm32\n+    emit_d32   ( masm, 0x0  );             \/\/                         imm32==0x0\n@@ -1588,11 +1594,11 @@\n-    emit_opcode(cbuf,0x81); emit_d8(cbuf,0xF8);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x80);                     \/\/ cmp rax,80000000h\n-    emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x85);\n-    emit_opcode(cbuf,0x0B); emit_d8(cbuf,0x00);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     \/\/ jne normal_case\n-    emit_opcode(cbuf,0x33); emit_d8(cbuf,0xD2);                     \/\/ xor rdx,edx\n-    emit_opcode(cbuf,0x83); emit_d8(cbuf,0xF9); emit_d8(cbuf,0xFF); \/\/ cmp rcx,0FFh\n-    emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x84);\n-    emit_opcode(cbuf,0x03); emit_d8(cbuf,0x00);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     \/\/ je done\n+    emit_opcode(masm,0x81); emit_d8(masm,0xF8);\n+    emit_opcode(masm,0x00); emit_d8(masm,0x00);\n+    emit_opcode(masm,0x00); emit_d8(masm,0x80);                     \/\/ cmp rax,80000000h\n+    emit_opcode(masm,0x0F); emit_d8(masm,0x85);\n+    emit_opcode(masm,0x0B); emit_d8(masm,0x00);\n+    emit_opcode(masm,0x00); emit_d8(masm,0x00);                     \/\/ jne normal_case\n+    emit_opcode(masm,0x33); emit_d8(masm,0xD2);                     \/\/ xor rdx,edx\n+    emit_opcode(masm,0x83); emit_d8(masm,0xF9); emit_d8(masm,0xFF); \/\/ cmp rcx,0FFh\n+    emit_opcode(masm,0x0F); emit_d8(masm,0x84);\n+    emit_opcode(masm,0x03); emit_d8(masm,0x00);\n+    emit_opcode(masm,0x00); emit_d8(masm,0x00);                     \/\/ je done\n@@ -1600,1 +1606,1 @@\n-    emit_opcode(cbuf,0x99);                                         \/\/ cdq\n+    emit_opcode(masm,0x99);                                         \/\/ cdq\n@@ -1607,1 +1613,1 @@\n-    emit_opcode(cbuf, $opcode$$constant + $reg$$reg);\n+    emit_opcode(masm, $opcode$$constant + $reg$$reg);\n@@ -1615,1 +1621,1 @@\n-      emit_opcode(cbuf, $primary | 0x02);\n+      emit_opcode(masm, $primary | 0x02);\n@@ -1618,1 +1624,1 @@\n-      emit_opcode(cbuf, $primary);\n+      emit_opcode(masm, $primary);\n@@ -1626,1 +1632,1 @@\n-      emit_opcode(cbuf, $primary | 0x02);    }\n+      emit_opcode(masm, $primary | 0x02);    }\n@@ -1628,1 +1634,1 @@\n-      emit_opcode(cbuf, $primary);\n+      emit_opcode(masm, $primary);\n@@ -1631,1 +1637,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, $dst$$reg);\n+    emit_rm(masm, 0x3, $secondary, $dst$$reg);\n@@ -1649,1 +1655,1 @@\n-    emit_opcode(cbuf, ((con >= -128) && (con <= 127)) ? ($primary | 0x02) : $primary);\n+    emit_opcode(masm, ((con >= -128) && (con <= 127)) ? ($primary | 0x02) : $primary);\n@@ -1651,3 +1657,3 @@\n-    emit_rm(cbuf, 0x3, $secondary, $dst$$reg);\n-    if ((con >= -128) && (con <= 127)) emit_d8 (cbuf,con);\n-    else                               emit_d32(cbuf,con);\n+    emit_rm(masm, 0x3, $secondary, $dst$$reg);\n+    if ((con >= -128) && (con <= 127)) emit_d8 (masm,con);\n+    else                               emit_d32(masm,con);\n@@ -1660,1 +1666,1 @@\n-    emit_opcode(cbuf, ((con >= -128) && (con <= 127)) ? ($primary | 0x02) : $primary);\n+    emit_opcode(masm, ((con >= -128) && (con <= 127)) ? ($primary | 0x02) : $primary);\n@@ -1662,3 +1668,3 @@\n-    emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW_ENC($dst$$reg));\n-    if ((con >= -128) && (con <= 127)) emit_d8 (cbuf,con);\n-    else                               emit_d32(cbuf,con);\n+    emit_rm(masm, 0x3, $tertiary, HIGH_FROM_LOW_ENC($dst$$reg));\n+    if ((con >= -128) && (con <= 127)) emit_d8 (masm,con);\n+    else                               emit_d32(masm,con);\n@@ -1668,1 +1674,1 @@\n-    emit_cc(cbuf, $secondary, $dst$$reg );\n+    emit_cc(masm, $secondary, $dst$$reg );\n@@ -1675,2 +1681,2 @@\n-    emit_opcode(cbuf, 0x0F);\n-    emit_cc(cbuf, 0xC8, destlo);\n+    emit_opcode(masm, 0x0F);\n+    emit_cc(masm, 0xC8, destlo);\n@@ -1678,2 +1684,2 @@\n-    emit_opcode(cbuf, 0x0F);\n-    emit_cc(cbuf, 0xC8, desthi);\n+    emit_opcode(masm, 0x0F);\n+    emit_cc(masm, 0xC8, desthi);\n@@ -1681,2 +1687,2 @@\n-    emit_opcode(cbuf, 0x87);\n-    emit_rm(cbuf, 0x3, destlo, desthi);\n+    emit_opcode(masm, 0x87);\n+    emit_rm(masm, 0x3, destlo, desthi);\n@@ -1686,1 +1692,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, $div$$reg );\n+    emit_rm(masm, 0x3, $secondary, $div$$reg );\n@@ -1691,1 +1697,1 @@\n-    emit_cc(cbuf, $secondary, $cop$$cmpcode);\n+    emit_cc(masm, $secondary, $cop$$cmpcode);\n@@ -1696,2 +1702,2 @@\n-    emit_d8(cbuf, op >> 8 );\n-    emit_d8(cbuf, op & 255);\n+    emit_d8(masm, op >> 8 );\n+    emit_d8(masm, op & 255);\n@@ -1703,2 +1709,2 @@\n-    emit_cc( cbuf, 0x70, ($cop$$cmpcode^1) );\n-    emit_d8( cbuf, $brOffs$$constant );\n+    emit_cc( masm, 0x70, ($cop$$cmpcode^1) );\n+    emit_d8( masm, $brOffs$$constant );\n@@ -1714,1 +1720,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1725,2 +1730,1 @@\n-    MacroAssembler masm(&cbuf);\n-    int start = masm.offset();\n+    int start = __ offset();\n@@ -1729,1 +1733,1 @@\n-        masm.verify_FPU(0, \"must be empty in SSE2+ mode\");\n+        __ verify_FPU(0, \"must be empty in SSE2+ mode\");\n@@ -1734,1 +1738,1 @@\n-      masm.empty_FPU_stack();\n+      __ empty_FPU_stack();\n@@ -1737,1 +1741,1 @@\n-      sizeof_FFree_Float_Stack_All = masm.offset() - start;\n+      sizeof_FFree_Float_Stack_All = __ offset() - start;\n@@ -1739,1 +1743,1 @@\n-      assert(masm.offset() - start == sizeof_FFree_Float_Stack_All, \"wrong size\");\n+      assert(__ offset() - start == sizeof_FFree_Float_Stack_All, \"wrong size\");\n@@ -1745,2 +1749,1 @@\n-      MacroAssembler masm(&cbuf);\n-      masm.verify_FPU( -3, \"Returning from Runtime Leaf call\");\n+      __ verify_FPU( -3, \"Returning from Runtime Leaf call\");\n@@ -1752,2 +1755,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n+    __ set_inst_mark();\n@@ -1756,1 +1758,1 @@\n-    emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),\n+    emit_d32_reloc(masm, ($meth$$method - (int)(__ pc()) - 4),\n@@ -1758,0 +1760,1 @@\n+    __ clear_inst_mark();\n@@ -1761,1 +1764,0 @@\n-      MacroAssembler _masm(&cbuf);\n@@ -1786,1 +1788,1 @@\n-    debug_only(int off0 = cbuf.insts_size());\n+    debug_only(int off0 = __ offset());\n@@ -1788,1 +1790,0 @@\n-      MacroAssembler _masm(&cbuf);\n@@ -1793,1 +1794,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1795,1 +1795,1 @@\n-    debug_only(int off1 = cbuf.insts_size());\n+    debug_only(int off1 = __ offset());\n@@ -1802,2 +1802,1 @@\n-      MacroAssembler masm(&cbuf);\n-      masm.fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n+      __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n@@ -1810,2 +1809,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n+    __ set_inst_mark();\n@@ -1815,1 +1813,1 @@\n-      emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),\n+      emit_d32_reloc(masm, ($meth$$method - (int)(__ pc()) - 4),\n@@ -1818,0 +1816,1 @@\n+      __ clear_inst_mark();\n@@ -1820,1 +1819,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -1823,1 +1822,1 @@\n-      emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),\n+      emit_d32_reloc(masm, ($meth$$method - (int)(__ pc()) - 4),\n@@ -1826,1 +1825,1 @@\n-      address mark = cbuf.insts_mark();\n+      address mark = __ inst_mark();\n@@ -1830,1 +1829,2 @@\n-        cbuf.shared_stub_to_interp_for(_method, cbuf.insts()->mark_off());\n+        __ code()->shared_stub_to_interp_for(_method, __ code()->insts()->mark_off());\n+        __ clear_inst_mark();\n@@ -1833,1 +1833,2 @@\n-        address stub = CompiledDirectCall::emit_to_interp_stub(cbuf, mark);\n+        address stub = CompiledDirectCall::emit_to_interp_stub(masm, mark);\n+        __ clear_inst_mark();\n@@ -1843,2 +1844,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    __ ic_call((address)$meth$$method, resolved_method_index(cbuf));\n+    __ ic_call((address)$meth$$method, resolved_method_index(masm));\n@@ -1853,2 +1853,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n+    __ set_inst_mark();\n@@ -1856,2 +1855,3 @@\n-    emit_rm(cbuf, 0x01, $secondary, EAX_enc );  \/\/ R\/M byte\n-    emit_d8(cbuf, disp);             \/\/ Displacement\n+    emit_rm(masm, 0x01, $secondary, EAX_enc );  \/\/ R\/M byte\n+    emit_d8(masm, disp);             \/\/ Displacement\n+    __ clear_inst_mark();\n@@ -1861,26 +1861,0 @@\n-\/\/   Following encoding is no longer used, but may be restored if calling\n-\/\/   convention changes significantly.\n-\/\/   Became: Xor_Reg(EBP), Java_To_Runtime( labl )\n-\/\/\n-\/\/   enc_class Java_Interpreter_Call (label labl) %{    \/\/ JAVA INTERPRETER CALL\n-\/\/     \/\/ int ic_reg     = Matcher::inline_cache_reg();\n-\/\/     \/\/ int ic_encode  = Matcher::_regEncode[ic_reg];\n-\/\/     \/\/ int imo_reg    = Matcher::interpreter_method_reg();\n-\/\/     \/\/ int imo_encode = Matcher::_regEncode[imo_reg];\n-\/\/\n-\/\/     \/\/ \/\/ Interpreter expects method_ptr in EBX, currently a callee-saved register,\n-\/\/     \/\/ \/\/ so we load it immediately before the call\n-\/\/     \/\/ emit_opcode(cbuf, 0x8B);                     \/\/ MOV    imo_reg,ic_reg  # method_ptr\n-\/\/     \/\/ emit_rm(cbuf, 0x03, imo_encode, ic_encode ); \/\/ R\/M byte\n-\/\/\n-\/\/     \/\/ xor rbp,ebp\n-\/\/     emit_opcode(cbuf, 0x33);\n-\/\/     emit_rm(cbuf, 0x3, EBP_enc, EBP_enc);\n-\/\/\n-\/\/     \/\/ CALL to interpreter.\n-\/\/     cbuf.set_insts_mark();\n-\/\/     $$$emit8$primary;\n-\/\/     emit_d32_reloc(cbuf, ($labl$$label - (int)(cbuf.insts_end()) - 4),\n-\/\/                 runtime_call_Relocation::spec(), RELOC_IMM32 );\n-\/\/   %}\n-\n@@ -1889,1 +1863,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, $dst$$reg);\n+    emit_rm(masm, 0x3, $secondary, $dst$$reg);\n@@ -1896,1 +1870,1 @@\n-    emit_opcode(cbuf, 0xB8 + $dst$$reg);\n+    emit_opcode(masm, 0xB8 + $dst$$reg);\n@@ -1903,1 +1877,1 @@\n-    emit_opcode(cbuf, $primary + $dst$$reg);\n+    emit_opcode(masm, $primary + $dst$$reg);\n@@ -1914,2 +1888,2 @@\n-      emit_opcode(cbuf, 0x33);\n-      emit_rm(cbuf, 0x3, dst_enc, dst_enc);\n+      emit_opcode(masm, 0x33);\n+      emit_rm(masm, 0x3, dst_enc, dst_enc);\n@@ -1917,2 +1891,2 @@\n-      emit_opcode(cbuf, $primary + dst_enc);\n-      emit_d32(cbuf, src_con);\n+      emit_opcode(masm, $primary + dst_enc);\n+      emit_d32(masm, src_con);\n@@ -1929,2 +1903,2 @@\n-      emit_opcode(cbuf, 0x33);\n-      emit_rm(cbuf, 0x3, dst_enc, dst_enc);\n+      emit_opcode(masm, 0x33);\n+      emit_rm(masm, 0x3, dst_enc, dst_enc);\n@@ -1932,2 +1906,2 @@\n-      emit_opcode(cbuf, $primary + dst_enc);\n-      emit_d32(cbuf, src_con);\n+      emit_opcode(masm, $primary + dst_enc);\n+      emit_d32(masm, src_con);\n@@ -1940,1 +1914,1 @@\n-    encode_Copy( cbuf, $dst$$reg, $src$$reg );\n+    encode_Copy( masm, $dst$$reg, $src$$reg );\n@@ -1944,1 +1918,1 @@\n-    encode_Copy( cbuf, $dst$$reg, $src$$reg );\n+    encode_Copy( masm, $dst$$reg, $src$$reg );\n@@ -1948,1 +1922,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -1953,1 +1927,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -1958,1 +1932,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1962,1 +1936,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -1966,1 +1940,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1970,1 +1944,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_rm(masm, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1982,1 +1956,1 @@\n-    emit_d32(cbuf, jf_as_bits);\n+    emit_d32(masm, jf_as_bits);\n@@ -1989,1 +1963,1 @@\n-    emit_d32(cbuf, jf_as_bits);\n+    emit_d32(masm, jf_as_bits);\n@@ -1998,1 +1972,1 @@\n-    emit_d32(cbuf,$src$$constant);\n+    emit_d32(masm,$src$$constant);\n@@ -2003,2 +1977,2 @@\n-    emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );\n-    emit_d32(cbuf, 0x00);\n+    emit_rm(masm, 0x00, $t1$$reg, 0x05 );\n+    emit_d32(masm, 0x00);\n@@ -2008,1 +1982,1 @@\n-    emit_opcode(cbuf,0xF0);         \/\/ [Lock]\n+    emit_opcode(masm,0xF0);         \/\/ [Lock]\n@@ -2019,2 +1993,2 @@\n-    emit_opcode(cbuf,0x87);\n-    emit_opcode(cbuf,0xD9);\n+    emit_opcode(masm,0x87);\n+    emit_opcode(masm,0xD9);\n@@ -2022,1 +1996,1 @@\n-    emit_opcode(cbuf,0xF0);\n+    emit_opcode(masm,0xF0);\n@@ -2024,3 +1998,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xC7);\n-    emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xC7);\n+    emit_rm( masm, 0x0, 1, $mem_ptr$$reg );\n@@ -2028,2 +2002,2 @@\n-    emit_opcode(cbuf,0x87);\n-    emit_opcode(cbuf,0xD9);\n+    emit_opcode(masm,0x87);\n+    emit_opcode(masm,0xD9);\n@@ -2034,1 +2008,1 @@\n-    emit_opcode(cbuf,0xF0);\n+    emit_opcode(masm,0xF0);\n@@ -2037,3 +2011,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xB1);\n-    emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xB1);\n+    emit_rm( masm, 0x0, 1, $mem_ptr$$reg );\n@@ -2044,1 +2018,1 @@\n-    emit_opcode(cbuf,0xF0);\n+    emit_opcode(masm,0xF0);\n@@ -2047,3 +2021,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xB0);\n-    emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xB0);\n+    emit_rm( masm, 0x0, 1, $mem_ptr$$reg );\n@@ -2054,1 +2028,1 @@\n-    emit_opcode(cbuf,0xF0);\n+    emit_opcode(masm,0xF0);\n@@ -2057,1 +2031,1 @@\n-    emit_opcode(cbuf, 0x66);\n+    emit_opcode(masm, 0x66);\n@@ -2060,3 +2034,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xB1);\n-    emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xB1);\n+    emit_rm( masm, 0x0, 1, $mem_ptr$$reg );\n@@ -2069,2 +2043,2 @@\n-    emit_opcode( cbuf, 0xB8 + res_encoding);\n-    emit_d32( cbuf, 0 );\n+    emit_opcode( masm, 0xB8 + res_encoding);\n+    emit_d32( masm, 0 );\n@@ -2072,2 +2046,2 @@\n-    emit_opcode(cbuf,0x75);\n-    emit_d8(cbuf, 5 );\n+    emit_opcode(masm,0x75);\n+    emit_d8(masm, 5 );\n@@ -2075,2 +2049,2 @@\n-    emit_opcode( cbuf, 0xB8 + res_encoding);\n-    emit_d32( cbuf, 1 );\n+    emit_opcode( masm, 0xB8 + res_encoding);\n+    emit_d32( masm, 1 );\n@@ -2080,4 +2054,0 @@\n-  enc_class set_instruction_start( ) %{\n-    cbuf.set_insts_mark();            \/\/ Mark start of opcode for reloc info in mem operand\n-  %}\n-\n@@ -2091,1 +2061,1 @@\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);\n+    encode_RegMem(masm, reg_encoding, base, index, scale, displace, disp_reloc);\n@@ -2101,1 +2071,1 @@\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, relocInfo::none);\n+    encode_RegMem(masm, reg_encoding, base, index, scale, displace, relocInfo::none);\n@@ -2108,7 +2078,7 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,$tertiary);\n-    emit_rm(cbuf, 0x3, r1, r2);\n-    emit_d8(cbuf,$cnt$$constant);\n-    emit_d8(cbuf,$primary);\n-    emit_rm(cbuf, 0x3, $secondary, r1);\n-    emit_d8(cbuf,$cnt$$constant);\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,$tertiary);\n+    emit_rm(masm, 0x3, r1, r2);\n+    emit_d8(masm,$cnt$$constant);\n+    emit_d8(masm,$primary);\n+    emit_rm(masm, 0x3, $secondary, r1);\n+    emit_d8(masm,$cnt$$constant);\n@@ -2118,2 +2088,2 @@\n-    emit_opcode( cbuf, 0x8B ); \/\/ Move\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_opcode( masm, 0x8B ); \/\/ Move\n+    emit_rm(masm, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2121,3 +2091,3 @@\n-      emit_d8(cbuf,$primary);\n-      emit_rm(cbuf, 0x3, $secondary, $dst$$reg);\n-      emit_d8(cbuf,$cnt$$constant-32);\n+      emit_d8(masm,$primary);\n+      emit_rm(masm, 0x3, $secondary, $dst$$reg);\n+      emit_d8(masm,$cnt$$constant-32);\n@@ -2125,3 +2095,3 @@\n-    emit_d8(cbuf,$primary);\n-    emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW_ENC($dst$$reg));\n-    emit_d8(cbuf,31);\n+    emit_d8(masm,$primary);\n+    emit_rm(masm, 0x3, $secondary, HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_d8(masm,31);\n@@ -2135,2 +2105,2 @@\n-    emit_opcode( cbuf, 0x8B ); \/\/ Move r1,r2\n-    emit_rm(cbuf, 0x3, r1, r2);\n+    emit_opcode( masm, 0x8B ); \/\/ Move r1,r2\n+    emit_rm(masm, 0x3, r1, r2);\n@@ -2138,3 +2108,3 @@\n-      emit_opcode(cbuf,$primary);\n-      emit_rm(cbuf, 0x3, $secondary, r1);\n-      emit_d8(cbuf,$cnt$$constant-32);\n+      emit_opcode(masm,$primary);\n+      emit_rm(masm, 0x3, $secondary, r1);\n+      emit_d8(masm,$cnt$$constant-32);\n@@ -2142,2 +2112,2 @@\n-    emit_opcode(cbuf,0x33);  \/\/ XOR r2,r2\n-    emit_rm(cbuf, 0x3, r2, r2);\n+    emit_opcode(masm,0x33);  \/\/ XOR r2,r2\n+    emit_rm(masm, 0x3, r2, r2);\n@@ -2149,1 +2119,1 @@\n-    emit_opcode(cbuf,$opcode$$constant);\n+    emit_opcode(masm,$opcode$$constant);\n@@ -2156,1 +2126,1 @@\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);\n+    encode_RegMem(masm, reg_encoding, base, index, scale, displace, disp_reloc);\n@@ -2171,1 +2141,1 @@\n-    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, relocInfo::none);\n+    encode_RegMem(masm, rm_byte_opcode, base, index, scale, displace, relocInfo::none);\n@@ -2181,1 +2151,1 @@\n-    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n+    encode_RegMem(masm, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n@@ -2191,1 +2161,1 @@\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);\n+    encode_RegMem(masm, reg_encoding, base, index, scale, displace, disp_reloc);\n@@ -2196,2 +2166,2 @@\n-    emit_opcode(cbuf,0x3B);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_opcode(masm,0x3B);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -2199,2 +2169,2 @@\n-    emit_opcode(cbuf,0x7C);\n-    emit_d8(cbuf,2);\n+    emit_opcode(masm,0x7C);\n+    emit_d8(masm,2);\n@@ -2202,2 +2172,2 @@\n-    emit_opcode(cbuf,0x8B);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_opcode(masm,0x8B);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -2208,2 +2178,2 @@\n-    emit_opcode(cbuf,0x3B);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_opcode(masm,0x3B);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -2211,2 +2181,2 @@\n-    emit_opcode(cbuf,0x7F);\n-    emit_d8(cbuf,2);\n+    emit_opcode(masm,0x7F);\n+    emit_d8(masm,2);\n@@ -2214,2 +2184,2 @@\n-    emit_opcode(cbuf,0x8B);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_opcode(masm,0x8B);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -2229,2 +2199,2 @@\n-      emit_opcode( cbuf, 0xD9 ); \/\/ FLD (i.e., push it)\n-      emit_d8( cbuf, 0xC0-1+$src$$reg );\n+      emit_opcode( masm, 0xD9 ); \/\/ FLD (i.e., push it)\n+      emit_d8( masm, 0xC0-1+$src$$reg );\n@@ -2232,3 +2202,4 @@\n-    cbuf.set_insts_mark();       \/\/ Mark start of opcode for reloc info in mem operand\n-    emit_opcode(cbuf,$primary);\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);\n+    __ set_inst_mark();       \/\/ Mark start of opcode for reloc info in mem operand\n+    emit_opcode(masm,$primary);\n+    encode_RegMem(masm, reg_encoding, base, index, scale, displace, disp_reloc);\n+    __ clear_inst_mark();\n@@ -2239,2 +2210,2 @@\n-    emit_opcode(cbuf,0xF7);\n-    emit_rm(cbuf, 0x3, 0x03, $dst$$reg );\n+    emit_opcode(masm,0xF7);\n+    emit_rm(masm, 0x3, 0x03, $dst$$reg );\n@@ -2245,3 +2216,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0x9C);\n-    emit_rm( cbuf, 0x3, 0x4, $dst$$reg );\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0x9C);\n+    emit_rm( masm, 0x3, 0x4, $dst$$reg );\n@@ -2254,2 +2225,2 @@\n-    emit_opcode(cbuf,0x2B);\n-    emit_rm(cbuf, 0x3, $p$$reg, $q$$reg);\n+    emit_opcode(masm,0x2B);\n+    emit_rm(masm, 0x3, $p$$reg, $q$$reg);\n@@ -2257,2 +2228,2 @@\n-    emit_opcode(cbuf,0x1B);\n-    emit_rm(cbuf, 0x3, tmpReg, tmpReg);\n+    emit_opcode(masm,0x1B);\n+    emit_rm(masm, 0x3, tmpReg, tmpReg);\n@@ -2260,2 +2231,2 @@\n-    emit_opcode(cbuf,0x23);\n-    emit_rm(cbuf, 0x3, tmpReg, $y$$reg);\n+    emit_opcode(masm,0x23);\n+    emit_rm(masm, 0x3, tmpReg, $y$$reg);\n@@ -2263,2 +2234,2 @@\n-    emit_opcode(cbuf,0x03);\n-    emit_rm(cbuf, 0x3, $p$$reg, tmpReg);\n+    emit_opcode(masm,0x03);\n+    emit_rm(masm, 0x3, $p$$reg, tmpReg);\n@@ -2269,3 +2240,3 @@\n-    emit_opcode(cbuf,0xF7);\n-    emit_rm(cbuf, 0x3, 0, ECX_enc);\n-    emit_d32(cbuf,0x20);\n+    emit_opcode(masm,0xF7);\n+    emit_rm(masm, 0x3, 0, ECX_enc);\n+    emit_d32(masm,0x20);\n@@ -2273,2 +2244,2 @@\n-    emit_opcode(cbuf, 0x74);\n-    emit_d8(cbuf, 0x04);\n+    emit_opcode(masm, 0x74);\n+    emit_d8(masm, 0x04);\n@@ -2276,2 +2247,2 @@\n-    emit_opcode( cbuf, 0x8B );\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n+    emit_opcode( masm, 0x8B );\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2279,2 +2250,2 @@\n-    emit_opcode(cbuf, 0x33);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $dst$$reg);\n+    emit_opcode(masm, 0x33);\n+    emit_rm(masm, 0x3, $dst$$reg, $dst$$reg);\n@@ -2283,3 +2254,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xA5);\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xA5);\n+    emit_rm(masm, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2287,2 +2258,2 @@\n-    emit_opcode(cbuf,0xD3);\n-    emit_rm(cbuf, 0x3, 0x4, $dst$$reg );\n+    emit_opcode(masm,0xD3);\n+    emit_rm(masm, 0x3, 0x4, $dst$$reg );\n@@ -2293,3 +2264,3 @@\n-    emit_opcode(cbuf,0xF7);\n-    emit_rm(cbuf, 0x3, 0, ECX_enc);\n-    emit_d32(cbuf,0x20);\n+    emit_opcode(masm,0xF7);\n+    emit_rm(masm, 0x3, 0, ECX_enc);\n+    emit_d32(masm,0x20);\n@@ -2297,2 +2268,2 @@\n-    emit_opcode(cbuf, 0x74);\n-    emit_d8(cbuf, 0x04);\n+    emit_opcode(masm, 0x74);\n+    emit_d8(masm, 0x04);\n@@ -2300,2 +2271,2 @@\n-    emit_opcode( cbuf, 0x8B );\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode( masm, 0x8B );\n+    emit_rm(masm, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2303,2 +2274,2 @@\n-    emit_opcode(cbuf, 0x33);\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_opcode(masm, 0x33);\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2307,3 +2278,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xAD);\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xAD);\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2311,2 +2282,2 @@\n-    emit_opcode(cbuf,0xD3);\n-    emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode(masm,0xD3);\n+    emit_rm(masm, 0x3, 0x5, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2317,3 +2288,3 @@\n-    emit_opcode(cbuf,0xF7);\n-    emit_rm(cbuf, 0x3, 0, ECX_enc);\n-    emit_d32(cbuf,0x20);\n+    emit_opcode(masm,0xF7);\n+    emit_rm(masm, 0x3, 0, ECX_enc);\n+    emit_d32(masm,0x20);\n@@ -2321,2 +2292,2 @@\n-    emit_opcode(cbuf, 0x74);\n-    emit_d8(cbuf, 0x05);\n+    emit_opcode(masm, 0x74);\n+    emit_d8(masm, 0x05);\n@@ -2324,2 +2295,2 @@\n-    emit_opcode( cbuf, 0x8B );\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode( masm, 0x8B );\n+    emit_rm(masm, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2327,3 +2298,3 @@\n-    emit_opcode(cbuf, 0xC1);\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC($dst$$reg) );\n-    emit_d8(cbuf, 0x1F );\n+    emit_opcode(masm, 0xC1);\n+    emit_rm(masm, 0x3, 7, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_d8(masm, 0x1F );\n@@ -2332,3 +2303,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xAD);\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xAD);\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2336,2 +2307,2 @@\n-    emit_opcode(cbuf,0xD3);\n-    emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode(masm,0xD3);\n+    emit_rm(masm, 0x3, 0x7, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2345,1 +2316,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, $src$$reg );\n+    emit_rm(masm, 0x3, $secondary, $src$$reg );\n@@ -2350,2 +2321,2 @@\n-    emit_opcode( cbuf, 0xDD );\n-    emit_d8( cbuf, 0xD8 );\n+    emit_opcode( masm, 0xDD );\n+    emit_d8( masm, 0xD8 );\n@@ -2356,2 +2327,2 @@\n-    emit_opcode( cbuf, 0xDD );           \/\/ FSTP   ST(i)\n-    emit_d8( cbuf, 0xD8+$dst$$reg );\n+    emit_opcode( masm, 0xDD );           \/\/ FSTP   ST(i)\n+    emit_d8( masm, 0xD8+$dst$$reg );\n@@ -2361,2 +2332,2 @@\n-    emit_opcode( cbuf, 0xD9 );\n-    emit_d8( cbuf, 0xC0-1+$dst$$reg );   \/\/ FLD ST(i-1)\n+    emit_opcode( masm, 0xD9 );\n+    emit_d8( masm, 0xC0-1+$dst$$reg );   \/\/ FLD ST(i-1)\n@@ -2366,5 +2337,5 @@\n-    emit_opcode( cbuf, 0xDB );           \/\/ FLD m80real\n-    emit_opcode( cbuf, 0x2D );\n-    emit_d32( cbuf, (int)StubRoutines::x86::addr_fpu_subnormal_bias1() );\n-    emit_opcode( cbuf, 0xDE );           \/\/ FMULP ST(dst), ST0\n-    emit_opcode( cbuf, 0xC8+$dst$$reg );\n+    emit_opcode( masm, 0xDB );           \/\/ FLD m80real\n+    emit_opcode( masm, 0x2D );\n+    emit_d32( masm, (int)StubRoutines::x86::addr_fpu_subnormal_bias1() );\n+    emit_opcode( masm, 0xDE );           \/\/ FMULP ST(dst), ST0\n+    emit_opcode( masm, 0xC8+$dst$$reg );\n@@ -2374,5 +2345,5 @@\n-    emit_opcode( cbuf, 0xDB );           \/\/ FLD m80real\n-    emit_opcode( cbuf, 0x2D );\n-    emit_d32( cbuf, (int)StubRoutines::x86::addr_fpu_subnormal_bias2() );\n-    emit_opcode( cbuf, 0xDE );           \/\/ FMULP ST(dst), ST0\n-    emit_opcode( cbuf, 0xC8+$dst$$reg );\n+    emit_opcode( masm, 0xDB );           \/\/ FLD m80real\n+    emit_opcode( masm, 0x2D );\n+    emit_d32( masm, (int)StubRoutines::x86::addr_fpu_subnormal_bias2() );\n+    emit_opcode( masm, 0xDE );           \/\/ FMULP ST(dst), ST0\n+    emit_opcode( masm, 0xC8+$dst$$reg );\n@@ -2383,1 +2354,1 @@\n-    store_to_stackslot( cbuf, $primary, $src$$reg, $dst$$disp );\n+    store_to_stackslot( masm, $primary, $src$$reg, $dst$$disp );\n@@ -2389,3 +2360,3 @@\n-    emit_rm( cbuf, 0x02, $src$$reg, ESP_enc );   \/\/ R\/M byte\n-    emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);          \/\/ SIB byte\n-    emit_d32(cbuf, $dst$$disp);   \/\/ Displacement\n+    emit_rm( masm, 0x02, $src$$reg, ESP_enc );   \/\/ R\/M byte\n+    emit_rm( masm, 0x00, ESP_enc, ESP_enc);          \/\/ SIB byte\n+    emit_d32(masm, $dst$$disp);   \/\/ Displacement\n@@ -2396,1 +2367,1 @@\n-    store_to_stackslot( cbuf, $primary, $secondary, $src$$disp );\n+    store_to_stackslot( masm, $primary, $secondary, $src$$disp );\n@@ -2401,1 +2372,1 @@\n-    store_to_stackslot( cbuf, 0xD9, 0x03, $dst$$disp );\n+    store_to_stackslot( masm, 0xD9, 0x03, $dst$$disp );\n@@ -2407,1 +2378,1 @@\n-    store_to_stackslot( cbuf, 0xDD, 0x03, $dst$$disp );\n+    store_to_stackslot( masm, 0xDD, 0x03, $dst$$disp );\n@@ -2411,2 +2382,2 @@\n-    emit_opcode( cbuf, 0xDD );           \/\/ FSTP   ST(i)\n-    emit_d8( cbuf, 0xD8+$dst$$reg );\n+    emit_opcode( masm, 0xDD );           \/\/ FSTP   ST(i)\n+    emit_d8( masm, 0xD8+$dst$$reg );\n@@ -2416,2 +2387,2 @@\n-    emit_opcode( cbuf, 0xD9 );           \/\/ FLD    ST(i-1)\n-    emit_d8( cbuf, 0xC0-1+$dst$$reg );\n+    emit_opcode( masm, 0xD9 );           \/\/ FLD    ST(i-1)\n+    emit_d8( masm, 0xC0-1+$dst$$reg );\n@@ -2424,2 +2395,2 @@\n-      emit_opcode( cbuf, 0xD9 );         \/\/ FLD    ST(i-1)\n-      emit_d8( cbuf, 0xC0-1+$src$$reg );\n+      emit_opcode( masm, 0xD9 );         \/\/ FLD    ST(i-1)\n+      emit_d8( masm, 0xC0-1+$src$$reg );\n@@ -2428,1 +2399,1 @@\n-    store_to_stackslot( cbuf, 0xD9, pop, $dst$$disp ); \/\/ FST<P>_S  [ESP+dst]\n+    store_to_stackslot( masm, 0xD9, pop, $dst$$disp ); \/\/ FST<P>_S  [ESP+dst]\n@@ -2435,2 +2406,2 @@\n-      emit_opcode( cbuf, 0xD9 );         \/\/ FLD    ST(i-1)\n-      emit_d8( cbuf, 0xC0-1+$src$$reg );\n+      emit_opcode( masm, 0xD9 );         \/\/ FLD    ST(i-1)\n+      emit_d8( masm, 0xC0-1+$src$$reg );\n@@ -2439,1 +2410,1 @@\n-    store_to_stackslot( cbuf, 0xDD, pop, $dst$$disp ); \/\/ FST<P>_D  [ESP+dst]\n+    store_to_stackslot( masm, 0xDD, pop, $dst$$disp ); \/\/ FST<P>_D  [ESP+dst]\n@@ -2446,2 +2417,2 @@\n-      emit_opcode( cbuf, 0xD9 );         \/\/ FLD    ST(src-1)\n-      emit_d8( cbuf, 0xC0-1+$src$$reg );\n+      emit_opcode( masm, 0xD9 );         \/\/ FLD    ST(src-1)\n+      emit_d8( masm, 0xC0-1+$src$$reg );\n@@ -2450,2 +2421,2 @@\n-    emit_opcode( cbuf, 0xDD );\n-    emit_d8( cbuf, pop+$dst$$reg );      \/\/ FST<P> ST(i)\n+    emit_opcode( masm, 0xDD );\n+    emit_d8( masm, pop+$dst$$reg );      \/\/ FST<P> ST(i)\n@@ -2457,2 +2428,2 @@\n-    emit_opcode( cbuf, 0xD9 );\n-    emit_d8( cbuf, 0xC0-1+$dst$$reg );\n+    emit_opcode( masm, 0xD9 );\n+    emit_d8( masm, 0xC0-1+$dst$$reg );\n@@ -2461,2 +2432,2 @@\n-      emit_opcode (cbuf, 0xD9);\n-      emit_opcode (cbuf, 0xF7);\n+      emit_opcode (masm, 0xD9);\n+      emit_opcode (masm, 0xF7);\n@@ -2465,2 +2436,2 @@\n-      emit_opcode(cbuf, 0xD9);\n-      emit_d8(cbuf, 0xC8-1+$src$$reg );\n+      emit_opcode(masm, 0xD9);\n+      emit_d8(masm, 0xC8-1+$src$$reg );\n@@ -2468,2 +2439,2 @@\n-      emit_opcode (cbuf, 0xD9);\n-      emit_opcode (cbuf, 0xF6);\n+      emit_opcode (masm, 0xD9);\n+      emit_opcode (masm, 0xF6);\n@@ -2474,1 +2445,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2483,1 +2453,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2492,1 +2461,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2499,1 +2467,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2506,1 +2473,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2513,1 +2479,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2518,1 +2483,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2523,1 +2487,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2531,2 +2494,2 @@\n-      emit_opcode (cbuf, 0xD9);\n-      emit_opcode (cbuf, 0xF7);\n+      emit_opcode (masm, 0xD9);\n+      emit_opcode (masm, 0xF7);\n@@ -2534,2 +2497,2 @@\n-      emit_opcode(cbuf, 0xD9);\n-      emit_d8(cbuf, 0xC8-1+$src$$reg );\n+      emit_opcode(masm, 0xD9);\n+      emit_d8(masm, 0xC8-1+$src$$reg );\n@@ -2537,2 +2500,2 @@\n-      emit_opcode (cbuf, 0xD9);\n-      emit_opcode (cbuf, 0xF6);\n+      emit_opcode (masm, 0xD9);\n+      emit_opcode (masm, 0xF6);\n@@ -2540,4 +2503,0 @@\n-    \/\/ \/\/ following asm replaced with Pop_Reg_F or Pop_Mem_F\n-    \/\/ \/\/ FSTP   FPR$dst$$reg\n-    \/\/ emit_opcode( cbuf, 0xDD );\n-    \/\/ emit_d8( cbuf, 0xD8+$dst$$reg );\n@@ -2548,2 +2507,2 @@\n-    emit_opcode( cbuf, 0xDF );\n-    emit_opcode( cbuf, 0xE0 );\n+    emit_opcode( masm, 0xDF );\n+    emit_opcode( masm, 0xE0 );\n@@ -2551,1 +2510,1 @@\n-    emit_opcode( cbuf, 0x9E );\n+    emit_opcode( masm, 0x9E );\n@@ -2553,2 +2512,2 @@\n-    emit_opcode( cbuf, 0x7B );\n-    emit_opcode( cbuf, 0x05 );\n+    emit_opcode( masm, 0x7B );\n+    emit_opcode( masm, 0x05 );\n@@ -2561,2 +2520,2 @@\n-    emit_opcode( cbuf, 0xD9 );\n-    emit_opcode( cbuf, 0xF8 );\n+    emit_opcode( masm, 0xD9 );\n+    emit_opcode( masm, 0xF8 );\n@@ -2564,1 +2523,1 @@\n-    emit_opcode( cbuf, 0x9b );\n+    emit_opcode( masm, 0x9b );\n@@ -2566,2 +2525,2 @@\n-    emit_opcode( cbuf, 0xDF );\n-    emit_opcode( cbuf, 0xE0 );\n+    emit_opcode( masm, 0xDF );\n+    emit_opcode( masm, 0xE0 );\n@@ -2569,1 +2528,1 @@\n-    emit_opcode( cbuf, 0x9E );\n+    emit_opcode( masm, 0x9E );\n@@ -2571,6 +2530,6 @@\n-    emit_opcode( cbuf, 0x0F );\n-    emit_opcode( cbuf, 0x8A );\n-    emit_opcode( cbuf, 0xF4 );\n-    emit_opcode( cbuf, 0xFF );\n-    emit_opcode( cbuf, 0xFF );\n-    emit_opcode( cbuf, 0xFF );\n+    emit_opcode( masm, 0x0F );\n+    emit_opcode( masm, 0x8A );\n+    emit_opcode( masm, 0xF4 );\n+    emit_opcode( masm, 0xFF );\n+    emit_opcode( masm, 0xFF );\n+    emit_opcode( masm, 0xFF );\n@@ -2581,2 +2540,2 @@\n-    emit_opcode( cbuf, 0xDF);\n-    emit_opcode( cbuf, 0xE0);\n+    emit_opcode( masm, 0xDF);\n+    emit_opcode( masm, 0xE0);\n@@ -2584,3 +2543,3 @@\n-    emit_opcode( cbuf, 0x66 );   \/\/ operand-size prefix for 16-bit immediate\n-    emit_opcode( cbuf, 0xA9 );\n-    emit_d16   ( cbuf, 0x0400 );\n+    emit_opcode( masm, 0x66 );   \/\/ operand-size prefix for 16-bit immediate\n+    emit_opcode( masm, 0xA9 );\n+    emit_d16   ( masm, 0x0400 );\n@@ -2589,2 +2548,2 @@\n-    \/\/ emit_opcode( cbuf, 0xA9 );\n-    \/\/ emit_d32   ( cbuf, 0x00000400 );\n+    \/\/ emit_opcode( masm, 0xA9 );\n+    \/\/ emit_d32   ( masm, 0x00000400 );\n@@ -2593,2 +2552,2 @@\n-    emit_opcode( cbuf, 0x74 );\n-    emit_d8    ( cbuf, 0x02 );\n+    emit_opcode( masm, 0x74 );\n+    emit_d8    ( masm, 0x02 );\n@@ -2596,2 +2555,2 @@\n-    emit_opcode( cbuf, 0xB4 );\n-    emit_d8    ( cbuf, 0x01 );\n+    emit_opcode( masm, 0xB4 );\n+    emit_d8    ( masm, 0x01 );\n@@ -2599,1 +2558,1 @@\n-    emit_opcode( cbuf, 0x9E);\n+    emit_opcode( masm, 0x9E);\n@@ -2606,2 +2565,2 @@\n-    emit_opcode( cbuf, 0x7B );\n-    emit_d8    ( cbuf, 0x03 );\n+    emit_opcode( masm, 0x7B );\n+    emit_d8    ( masm, 0x03 );\n@@ -2609,2 +2568,2 @@\n-    emit_opcode( cbuf, 0xB4 );\n-    emit_d8    ( cbuf, 0x01 );\n+    emit_opcode( masm, 0xB4 );\n+    emit_d8    ( masm, 0x01 );\n@@ -2612,1 +2571,1 @@\n-    emit_opcode( cbuf, 0x9E);\n+    emit_opcode( masm, 0x9E);\n@@ -2614,1 +2573,1 @@\n-    emit_opcode( cbuf, 0x90);\n+    emit_opcode( masm, 0x90);\n@@ -2634,2 +2593,2 @@\n-    emit_opcode( cbuf, 0xDF);\n-    emit_opcode( cbuf, 0xE0);\n+    emit_opcode( masm, 0xDF);\n+    emit_opcode( masm, 0xE0);\n@@ -2637,1 +2596,1 @@\n-    emit_opcode( cbuf, 0x9E);\n+    emit_opcode( masm, 0x9E);\n@@ -2639,2 +2598,2 @@\n-    emit_opcode( cbuf, 0xB8 + $dst$$reg);\n-    emit_d32( cbuf, -1 );\n+    emit_opcode( masm, 0xB8 + $dst$$reg);\n+    emit_d32( masm, -1 );\n@@ -2642,2 +2601,2 @@\n-    emit_opcode( cbuf, 0x7A );\n-    emit_d8    ( cbuf, 0x13 );\n+    emit_opcode( masm, 0x7A );\n+    emit_d8    ( masm, 0x13 );\n@@ -2645,2 +2604,2 @@\n-    emit_opcode( cbuf, 0xB8 + $dst$$reg);\n-    emit_d32( cbuf, -1 );\n+    emit_opcode( masm, 0xB8 + $dst$$reg);\n+    emit_d32( masm, -1 );\n@@ -2648,2 +2607,2 @@\n-    emit_opcode( cbuf, 0x72 );\n-    emit_d8    ( cbuf, 0x0C );\n+    emit_opcode( masm, 0x72 );\n+    emit_d8    ( masm, 0x0C );\n@@ -2651,2 +2610,2 @@\n-    emit_opcode( cbuf, 0xB8 + $dst$$reg);\n-    emit_d32( cbuf, 0 );\n+    emit_opcode( masm, 0xB8 + $dst$$reg);\n+    emit_d32( masm, 0 );\n@@ -2654,2 +2613,2 @@\n-    emit_opcode( cbuf, 0x74 );\n-    emit_d8    ( cbuf, 0x05 );\n+    emit_opcode( masm, 0x74 );\n+    emit_d8    ( masm, 0x05 );\n@@ -2657,2 +2616,2 @@\n-    emit_opcode( cbuf, 0xB8 + $dst$$reg);\n-    emit_d32( cbuf, 1 );\n+    emit_opcode( masm, 0xB8 + $dst$$reg);\n+    emit_d32( masm, 1 );\n@@ -2666,2 +2625,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2669,2 +2628,2 @@\n-    emit_opcode(cbuf,0x75);\n-    emit_d8(cbuf, 2 );\n+    emit_opcode(masm,0x75);\n+    emit_d8(masm, 2 );\n@@ -2672,2 +2631,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, $src1$$reg, $src2$$reg );\n@@ -2681,1 +2640,1 @@\n-    encode_Copy( cbuf, dst_encoding  , src_encoding );\n+    encode_Copy( masm, dst_encoding  , src_encoding );\n@@ -2683,1 +2642,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW_ENC(dst_encoding), src_encoding );\n+    encode_Copy( masm, HIGH_FROM_LOW_ENC(dst_encoding), src_encoding );\n@@ -2685,3 +2644,3 @@\n-    emit_opcode( cbuf, 0xC1 );\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC(dst_encoding) );\n-    emit_d8(cbuf, 0x1F );\n+    emit_opcode( masm, 0xC1 );\n+    emit_rm(masm, 0x3, 7, HIGH_FROM_LOW_ENC(dst_encoding) );\n+    emit_d8(masm, 0x1F );\n@@ -2692,1 +2651,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_opcode(masm, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2694,1 +2653,1 @@\n-    emit_opcode(cbuf, 0x50+$src$$reg  );\n+    emit_opcode(masm, 0x50+$src$$reg  );\n@@ -2696,4 +2655,4 @@\n-    emit_opcode(cbuf,0xdf);\n-    emit_d8(cbuf, 0x6C);\n-    emit_d8(cbuf, 0x24);\n-    emit_d8(cbuf, 0x00);\n+    emit_opcode(masm,0xdf);\n+    emit_d8(masm, 0x6C);\n+    emit_d8(masm, 0x24);\n+    emit_d8(masm, 0x00);\n@@ -2701,3 +2660,3 @@\n-    emit_opcode(cbuf, 0x83); \/\/ add  SP, #8\n-    emit_rm(cbuf, 0x3, 0x00, ESP_enc);\n-    emit_d8(cbuf, 0x8);\n+    emit_opcode(masm, 0x83); \/\/ add  SP, #8\n+    emit_rm(masm, 0x3, 0x00, ESP_enc);\n+    emit_d8(masm, 0x8);\n@@ -2708,2 +2667,2 @@\n-    emit_opcode( cbuf, 0xF7 );\n-    emit_rm( cbuf, 0x3, 0x5, $src1$$reg );\n+    emit_opcode( masm, 0xF7 );\n+    emit_rm( masm, 0x3, 0x5, $src1$$reg );\n@@ -2713,3 +2672,3 @@\n-      emit_opcode(cbuf, 0xC1);\n-      emit_rm(cbuf, 0x3, 7, $dst$$reg );\n-      emit_d8(cbuf, shift_count);\n+      emit_opcode(masm, 0xC1);\n+      emit_rm(masm, 0x3, 7, $dst$$reg );\n+      emit_d8(masm, shift_count);\n@@ -2722,1 +2681,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_opcode(masm, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2724,1 +2683,1 @@\n-    emit_opcode(cbuf, 0x50+$src$$reg  );\n+    emit_opcode(masm, 0x50+$src$$reg  );\n@@ -2726,4 +2685,4 @@\n-    emit_opcode(cbuf,0xdf);\n-    emit_d8(cbuf, 0x6C);\n-    emit_d8(cbuf, 0x24);\n-    emit_d8(cbuf, 0x00);\n+    emit_opcode(masm,0xdf);\n+    emit_d8(masm, 0x6C);\n+    emit_d8(masm, 0x24);\n+    emit_d8(masm, 0x00);\n@@ -2735,2 +2694,2 @@\n-    emit_opcode( cbuf, 0xF7 );\n-    emit_rm( cbuf, 0x3, 0x5, $src$$reg);\n+    emit_opcode( masm, 0xF7 );\n+    emit_rm( masm, 0x3, 0x5, $src$$reg);\n@@ -2742,2 +2701,2 @@\n-    emit_opcode( cbuf, 0xF7 );\n-    emit_rm( cbuf, 0x3, 0x4, $src$$reg);\n+    emit_opcode( masm, 0xF7 );\n+    emit_rm( masm, 0x3, 0x4, $src$$reg);\n@@ -2750,1 +2709,1 @@\n-    encode_Copy( cbuf, $tmp$$reg, $src$$reg );\n+    encode_Copy( masm, $tmp$$reg, $src$$reg );\n@@ -2752,3 +2711,3 @@\n-    emit_opcode( cbuf, 0x0F );\n-    emit_opcode( cbuf, 0xAF );\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode( masm, 0x0F );\n+    emit_opcode( masm, 0xAF );\n+    emit_rm( masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2756,1 +2715,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg) );\n+    encode_Copy( masm, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2758,3 +2717,3 @@\n-    emit_opcode( cbuf, 0x0F );\n-    emit_opcode( cbuf, 0xAF );\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n+    emit_opcode( masm, 0x0F );\n+    emit_opcode( masm, 0xAF );\n+    emit_rm( masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2762,2 +2721,2 @@\n-    emit_opcode( cbuf, 0x03 );\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode( masm, 0x03 );\n+    emit_rm( masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2765,2 +2724,2 @@\n-    emit_opcode( cbuf, 0xF7 );\n-    emit_rm( cbuf, 0x3, 0x4, $src$$reg );\n+    emit_opcode( masm, 0xF7 );\n+    emit_rm( masm, 0x3, 0x4, $src$$reg );\n@@ -2768,2 +2727,2 @@\n-    emit_opcode( cbuf, 0x03 );\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $tmp$$reg );\n+    emit_opcode( masm, 0x03 );\n+    emit_rm( masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $tmp$$reg );\n@@ -2776,3 +2735,3 @@\n-    emit_opcode( cbuf, 0x6B );\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n-    emit_d8( cbuf, (int)$src$$constant );\n+    emit_opcode( masm, 0x6B );\n+    emit_rm( masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_d8( masm, (int)$src$$constant );\n@@ -2780,2 +2739,2 @@\n-    emit_opcode(cbuf, 0xB8 + EDX_enc);\n-    emit_d32( cbuf, (int)$src$$constant );\n+    emit_opcode(masm, 0xB8 + EDX_enc);\n+    emit_d32( masm, (int)$src$$constant );\n@@ -2783,2 +2742,2 @@\n-    emit_opcode( cbuf, 0xF7 );\n-    emit_rm( cbuf, 0x3, 0x4, EDX_enc );\n+    emit_opcode( masm, 0xF7 );\n+    emit_rm( masm, 0x3, 0x4, EDX_enc );\n@@ -2786,2 +2745,2 @@\n-    emit_opcode( cbuf, 0x03 );\n-    emit_rm( cbuf, 0x3, EDX_enc, $tmp$$reg );\n+    emit_opcode( masm, 0x03 );\n+    emit_rm( masm, 0x3, EDX_enc, $tmp$$reg );\n@@ -2792,1 +2751,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n+    emit_opcode(masm, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2794,1 +2753,1 @@\n-    emit_opcode(cbuf,               0x50+$src1$$reg  );\n+    emit_opcode(masm,               0x50+$src1$$reg  );\n@@ -2796,1 +2755,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n+    emit_opcode(masm, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2798,1 +2757,1 @@\n-    emit_opcode(cbuf,               0x50+$src2$$reg  );\n+    emit_opcode(masm,               0x50+$src2$$reg  );\n@@ -2800,4 +2759,4 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf,0xE8);       \/\/ Call into runtime\n-    emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::ldiv) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ set_inst_mark();\n+    emit_opcode(masm,0xE8);       \/\/ Call into runtime\n+    emit_d32_reloc(masm, (CAST_FROM_FN_PTR(address, SharedRuntime::ldiv) - __ pc()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ clear_inst_mark();\n@@ -2806,3 +2765,3 @@\n-    emit_opcode(cbuf, 0x83); \/\/ add  SP, #framesize\n-    emit_rm(cbuf, 0x3, 0x00, ESP_enc);\n-    emit_d8(cbuf, 4*4);\n+    emit_opcode(masm, 0x83); \/\/ add  SP, #framesize\n+    emit_rm(masm, 0x3, 0x00, ESP_enc);\n+    emit_d8(masm, 4*4);\n@@ -2813,1 +2772,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n+    emit_opcode(masm, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2815,1 +2774,1 @@\n-    emit_opcode(cbuf,               0x50+$src1$$reg  );\n+    emit_opcode(masm,               0x50+$src1$$reg  );\n@@ -2817,1 +2776,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n+    emit_opcode(masm, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2819,1 +2778,1 @@\n-    emit_opcode(cbuf,               0x50+$src2$$reg  );\n+    emit_opcode(masm,               0x50+$src2$$reg  );\n@@ -2821,4 +2780,4 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf,0xE8);       \/\/ Call into runtime\n-    emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::lrem ) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ set_inst_mark();\n+    emit_opcode(masm,0xE8);       \/\/ Call into runtime\n+    emit_d32_reloc(masm, (CAST_FROM_FN_PTR(address, SharedRuntime::lrem ) - __ pc()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ clear_inst_mark();\n@@ -2827,3 +2786,3 @@\n-    emit_opcode(cbuf, 0x83); \/\/ add  SP, #framesize\n-    emit_rm(cbuf, 0x3, 0x00, ESP_enc);\n-    emit_d8(cbuf, 4*4);\n+    emit_opcode(masm, 0x83); \/\/ add  SP, #framesize\n+    emit_rm(masm, 0x3, 0x00, ESP_enc);\n+    emit_d8(masm, 4*4);\n@@ -2834,2 +2793,2 @@\n-    emit_opcode(cbuf, 0x8B);\n-    emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg);\n+    emit_opcode(masm, 0x8B);\n+    emit_rm(masm, 0x3, $tmp$$reg, $src$$reg);\n@@ -2837,2 +2796,2 @@\n-    emit_opcode(cbuf, 0x0B);\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_opcode(masm, 0x0B);\n+    emit_rm(masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2843,2 +2802,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, $src1$$reg, $src2$$reg );\n@@ -2846,2 +2805,2 @@\n-    emit_cc(cbuf, 0x70, 0x5);\n-    emit_d8(cbuf,2);\n+    emit_cc(masm, 0x70, 0x5);\n+    emit_d8(masm,2);\n@@ -2849,2 +2808,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2855,2 +2814,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, $src1$$reg, $src2$$reg );\n@@ -2858,2 +2817,2 @@\n-    emit_opcode( cbuf, 0x8B );\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src1$$reg) );\n+    emit_opcode( masm, 0x8B );\n+    emit_rm(masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src1$$reg) );\n@@ -2861,2 +2820,2 @@\n-    emit_opcode( cbuf, 0x1B );\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src2$$reg) );\n+    emit_opcode( masm, 0x1B );\n+    emit_rm(masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2867,2 +2826,2 @@\n-    emit_opcode(cbuf,0x33);  \/\/ XOR\n-    emit_rm(cbuf,0x3, $tmp$$reg, $tmp$$reg);\n+    emit_opcode(masm,0x33);  \/\/ XOR\n+    emit_rm(masm,0x3, $tmp$$reg, $tmp$$reg);\n@@ -2870,2 +2829,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, $tmp$$reg, $src$$reg );\n@@ -2873,2 +2832,2 @@\n-    emit_opcode( cbuf, 0x1B );\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg) );\n+    emit_opcode( masm, 0x1B );\n+    emit_rm(masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2879,7 +2838,7 @@\n-    emit_opcode(cbuf,0xF7);    \/\/ NEG hi\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n-    emit_opcode(cbuf,0xF7);    \/\/ NEG lo\n-    emit_rm    (cbuf,0x3, 0x3,               $dst$$reg );\n-    emit_opcode(cbuf,0x83);    \/\/ SBB hi,0\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n-    emit_d8    (cbuf,0 );\n+    emit_opcode(masm,0xF7);    \/\/ NEG hi\n+    emit_rm    (masm,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_opcode(masm,0xF7);    \/\/ NEG lo\n+    emit_rm    (masm,0x3, 0x3,               $dst$$reg );\n+    emit_opcode(masm,0x83);    \/\/ SBB hi,0\n+    emit_rm    (masm,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_d8    (masm,0 );\n@@ -2889,1 +2848,1 @@\n-    emit_opcode(cbuf,0x5A);\n+    emit_opcode(masm,0x5A);\n@@ -2893,4 +2852,3 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf, 0xE9);        \/\/ jmp    entry\n-    emit_d32_reloc(cbuf, (int)OptoRuntime::rethrow_stub() - ((int)cbuf.insts_end())-4,\n+    __ set_inst_mark();\n+    emit_opcode(masm, 0xE9);        \/\/ jmp    entry\n+    emit_d32_reloc(masm, (int)OptoRuntime::rethrow_stub() - ((int)__ pc())-4,\n@@ -2898,0 +2856,1 @@\n+    __ clear_inst_mark();\n@@ -2915,3 +2874,3 @@\n-    emit_opcode(cbuf,0xD9);            \/\/ FLDCW  trunc\n-    emit_opcode(cbuf,0x2D);\n-    emit_d32(cbuf,(int)StubRoutines::x86::addr_fpu_cntrl_wrd_trunc());\n+    emit_opcode(masm,0xD9);            \/\/ FLDCW  trunc\n+    emit_opcode(masm,0x2D);\n+    emit_d32(masm,(int)StubRoutines::x86::addr_fpu_cntrl_wrd_trunc());\n@@ -2919,3 +2878,3 @@\n-    emit_opcode(cbuf,0x83);            \/\/ SUB ESP,4\n-    emit_opcode(cbuf,0xEC);\n-    emit_d8(cbuf,0x04);\n+    emit_opcode(masm,0x83);            \/\/ SUB ESP,4\n+    emit_opcode(masm,0xEC);\n+    emit_d8(masm,0x04);\n@@ -2924,3 +2883,3 @@\n-    emit_opcode(cbuf,0xDB);            \/\/ FISTP [ESP]\n-    emit_opcode(cbuf,0x1C);\n-    emit_d8(cbuf,0x24);\n+    emit_opcode(masm,0xDB);            \/\/ FISTP [ESP]\n+    emit_opcode(masm,0x1C);\n+    emit_d8(masm,0x24);\n@@ -2928,3 +2887,3 @@\n-    emit_opcode(cbuf,0xD9);            \/\/ FLDCW   std\/24-bit mode\n-    emit_opcode(cbuf,0x2D);\n-    emit_d32( cbuf, Compile::current()->in_24_bit_fp_mode()\n+    emit_opcode(masm,0xD9);            \/\/ FLDCW   std\/24-bit mode\n+    emit_opcode(masm,0x2D);\n+    emit_d32( masm, Compile::current()->in_24_bit_fp_mode()\n@@ -2935,5 +2894,5 @@\n-    emit_opcode(cbuf,0x58);       \/\/ POP EAX\n-    emit_opcode(cbuf,0x3D);       \/\/ CMP EAX,imm\n-    emit_d32   (cbuf,0x80000000); \/\/         0x80000000\n-    emit_opcode(cbuf,0x75);       \/\/ JNE around_slow_call\n-    emit_d8    (cbuf,0x07);       \/\/ Size of slow_call\n+    emit_opcode(masm,0x58);       \/\/ POP EAX\n+    emit_opcode(masm,0x3D);       \/\/ CMP EAX,imm\n+    emit_d32   (masm,0x80000000); \/\/         0x80000000\n+    emit_opcode(masm,0x75);       \/\/ JNE around_slow_call\n+    emit_d8    (masm,0x07);       \/\/ Size of slow_call\n@@ -2941,2 +2900,2 @@\n-    emit_opcode(cbuf,0xD9 );      \/\/ FLD     ST(i)\n-    emit_d8    (cbuf,0xC0-1+$src$$reg );\n+    emit_opcode(masm,0xD9 );      \/\/ FLD     ST(i)\n+    emit_d8    (masm,0xC0-1+$src$$reg );\n@@ -2944,4 +2903,4 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf,0xE8);       \/\/ Call into runtime\n-    emit_d32_reloc(cbuf, (StubRoutines::x86::d2i_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ set_inst_mark();\n+    emit_opcode(masm,0xE8);       \/\/ Call into runtime\n+    emit_d32_reloc(masm, (StubRoutines::x86::d2i_wrapper() - __ pc()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ clear_inst_mark();\n@@ -2953,3 +2912,3 @@\n-    emit_opcode(cbuf,0xD9);            \/\/ FLDCW  trunc\n-    emit_opcode(cbuf,0x2D);\n-    emit_d32(cbuf,(int)StubRoutines::x86::addr_fpu_cntrl_wrd_trunc());\n+    emit_opcode(masm,0xD9);            \/\/ FLDCW  trunc\n+    emit_opcode(masm,0x2D);\n+    emit_d32(masm,(int)StubRoutines::x86::addr_fpu_cntrl_wrd_trunc());\n@@ -2957,3 +2916,3 @@\n-    emit_opcode(cbuf,0x83);            \/\/ SUB ESP,8\n-    emit_opcode(cbuf,0xEC);\n-    emit_d8(cbuf,0x08);\n+    emit_opcode(masm,0x83);            \/\/ SUB ESP,8\n+    emit_opcode(masm,0xEC);\n+    emit_d8(masm,0x08);\n@@ -2962,3 +2921,3 @@\n-    emit_opcode(cbuf,0xDF);            \/\/ FISTP [ESP]\n-    emit_opcode(cbuf,0x3C);\n-    emit_d8(cbuf,0x24);\n+    emit_opcode(masm,0xDF);            \/\/ FISTP [ESP]\n+    emit_opcode(masm,0x3C);\n+    emit_d8(masm,0x24);\n@@ -2966,3 +2925,3 @@\n-    emit_opcode(cbuf,0xD9);            \/\/ FLDCW   std\/24-bit mode\n-    emit_opcode(cbuf,0x2D);\n-    emit_d32( cbuf, Compile::current()->in_24_bit_fp_mode()\n+    emit_opcode(masm,0xD9);            \/\/ FLDCW   std\/24-bit mode\n+    emit_opcode(masm,0x2D);\n+    emit_d32( masm, Compile::current()->in_24_bit_fp_mode()\n@@ -2973,11 +2932,11 @@\n-    emit_opcode(cbuf,0x58);       \/\/ POP EAX\n-    emit_opcode(cbuf,0x5A);       \/\/ POP EDX\n-    emit_opcode(cbuf,0x81);       \/\/ CMP EDX,imm\n-    emit_d8    (cbuf,0xFA);       \/\/ rdx\n-    emit_d32   (cbuf,0x80000000); \/\/         0x80000000\n-    emit_opcode(cbuf,0x75);       \/\/ JNE around_slow_call\n-    emit_d8    (cbuf,0x07+4);     \/\/ Size of slow_call\n-    emit_opcode(cbuf,0x85);       \/\/ TEST EAX,EAX\n-    emit_opcode(cbuf,0xC0);       \/\/ 2\/rax,\/rax,\n-    emit_opcode(cbuf,0x75);       \/\/ JNE around_slow_call\n-    emit_d8    (cbuf,0x07);       \/\/ Size of slow_call\n+    emit_opcode(masm,0x58);       \/\/ POP EAX\n+    emit_opcode(masm,0x5A);       \/\/ POP EDX\n+    emit_opcode(masm,0x81);       \/\/ CMP EDX,imm\n+    emit_d8    (masm,0xFA);       \/\/ rdx\n+    emit_d32   (masm,0x80000000); \/\/         0x80000000\n+    emit_opcode(masm,0x75);       \/\/ JNE around_slow_call\n+    emit_d8    (masm,0x07+4);     \/\/ Size of slow_call\n+    emit_opcode(masm,0x85);       \/\/ TEST EAX,EAX\n+    emit_opcode(masm,0xC0);       \/\/ 2\/rax,\/rax,\n+    emit_opcode(masm,0x75);       \/\/ JNE around_slow_call\n+    emit_d8    (masm,0x07);       \/\/ Size of slow_call\n@@ -2985,2 +2944,2 @@\n-    emit_opcode(cbuf,0xD9 );      \/\/ FLD     ST(i)\n-    emit_d8    (cbuf,0xC0-1+$src$$reg );\n+    emit_opcode(masm,0xD9 );      \/\/ FLD     ST(i)\n+    emit_d8    (masm,0xC0-1+$src$$reg );\n@@ -2988,4 +2947,4 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf,0xE8);       \/\/ Call into runtime\n-    emit_d32_reloc(cbuf, (StubRoutines::x86::d2l_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ set_inst_mark();\n+    emit_opcode(masm,0xE8);       \/\/ Call into runtime\n+    emit_d32_reloc(masm, (StubRoutines::x86::d2l_wrapper() - __ pc()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ clear_inst_mark();\n@@ -2999,2 +2958,2 @@\n-    emit_opcode(cbuf, 0xD8);\n-    emit_opcode(cbuf, 0xC8 + $src1$$reg);\n+    emit_opcode(masm, 0xD8);\n+    emit_opcode(masm, 0xC8 + $src1$$reg);\n@@ -3005,2 +2964,2 @@\n-    emit_opcode(cbuf, 0xD8);\n-    emit_opcode(cbuf, 0xC0 + $src2$$reg);\n+    emit_opcode(masm, 0xD8);\n+    emit_opcode(masm, 0xC0 + $src2$$reg);\n@@ -3012,2 +2971,2 @@\n-    emit_opcode(cbuf, 0xDE);\n-    emit_opcode(cbuf, 0xC0 + $src2$$reg);\n+    emit_opcode(masm, 0xDE);\n+    emit_opcode(masm, 0xC0 + $src2$$reg);\n@@ -3019,2 +2978,2 @@\n-      emit_opcode(cbuf, 0xD8);\n-      emit_opcode(cbuf, 0xE0 + $src1$$reg);\n+      emit_opcode(masm, 0xD8);\n+      emit_opcode(masm, 0xE0 + $src1$$reg);\n@@ -3023,2 +2982,2 @@\n-      emit_opcode(cbuf, 0xD8);\n-      emit_opcode(cbuf, 0xF0 + $src2$$reg);\n+      emit_opcode(masm, 0xD8);\n+      emit_opcode(masm, 0xF0 + $src2$$reg);\n@@ -3030,2 +2989,2 @@\n-    emit_opcode(cbuf, 0xD8);\n-    emit_opcode(cbuf, 0xC0 + $src1$$reg);\n+    emit_opcode(masm, 0xD8);\n+    emit_opcode(masm, 0xC0 + $src1$$reg);\n@@ -3034,2 +2993,2 @@\n-    emit_opcode(cbuf, 0xD8);\n-    emit_opcode(cbuf, 0xC8 + $src2$$reg);\n+    emit_opcode(masm, 0xD8);\n+    emit_opcode(masm, 0xC8 + $src2$$reg);\n@@ -3042,2 +3001,2 @@\n-    emit_opcode(cbuf, 0xD8);\n-    emit_opcode(cbuf, 0xC0 + $src1$$reg);\n+    emit_opcode(masm, 0xD8);\n+    emit_opcode(masm, 0xC0 + $src1$$reg);\n@@ -3046,2 +3005,2 @@\n-    emit_opcode(cbuf, 0xDE);\n-    emit_opcode(cbuf, 0xC8 + $src2$$reg);\n+    emit_opcode(masm, 0xDE);\n+    emit_opcode(masm, 0xC8 + $src2$$reg);\n@@ -3052,1 +3011,1 @@\n-    emit_opcode(cbuf,0xDF);\n+    emit_opcode(masm,0xDF);\n@@ -3059,2 +3018,2 @@\n-    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n-    store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );\n+    encode_RegMem(masm, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n+    store_to_stackslot( masm, 0x0DF, 0x07, $dst$$disp );\n@@ -3068,3 +3027,3 @@\n-    store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );\n-    cbuf.set_insts_mark();            \/\/ Mark start of FIST in case $mem has an oop\n-    emit_opcode(cbuf,0xDF);\n+    store_to_stackslot( masm, 0x0DF, 0x05, $src$$disp );\n+    __ set_inst_mark();            \/\/ Mark start of FIST in case $mem has an oop\n+    emit_opcode(masm,0xDF);\n@@ -3077,1 +3036,2 @@\n-    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n+    encode_RegMem(masm, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n+    __ clear_inst_mark();\n@@ -5757,1 +5717,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5769,1 +5729,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5780,1 +5740,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5793,2 +5753,2 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),\n-              Pop_Reg_DPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),\n+              Pop_Reg_DPR(dst), ClearInstMark );\n@@ -5843,2 +5803,2 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),\n-              Pop_Reg_FPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -5855,1 +5815,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5865,1 +5825,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5875,1 +5835,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5885,1 +5845,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5895,1 +5855,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5904,1 +5864,1 @@\n-  ins_encode( LdImmI(dst, src) );\n+  ins_encode( SetInstMark, LdImmI(dst, src), ClearInstMark );\n@@ -5925,1 +5885,1 @@\n-  ins_encode( LdImmP(dst, src) );\n+  ins_encode( SetInstMark, LdImmP(dst, src), ClearInstMark );\n@@ -6083,1 +6043,1 @@\n-  ins_encode( OpcP, RegMem(dst,src));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,src), ClearInstMark);\n@@ -6094,1 +6054,1 @@\n-  ins_encode( OpcP, RegMem( dst, src ), OpcS, RegMem_Hi( dst, src ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, src ), OpcS, RegMem_Hi( dst, src ), ClearInstMark );\n@@ -6105,1 +6065,1 @@\n-  ins_encode( OpcP, RegMem(dst,src));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,src), ClearInstMark);\n@@ -6117,2 +6077,2 @@\n-  ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),\n-              Pop_Reg_FPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem_no_oop(0x00,src),\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -6130,2 +6090,2 @@\n-  ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),\n-              Pop_Reg_DPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem_no_oop(0x00,src),\n+              Pop_Reg_DPR(dst), ClearInstMark );\n@@ -6205,1 +6165,1 @@\n-  ins_encode( OpcP, RegMem( src, mem ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, mem ), ClearInstMark );\n@@ -6216,1 +6176,1 @@\n-  ins_encode( OpcS, OpcP, RegMem( src, mem ) );\n+  ins_encode( SetInstMark, OpcS, OpcP, RegMem( src, mem ), ClearInstMark );\n@@ -6227,1 +6187,1 @@\n-  ins_encode( OpcP, RegMem( src, mem ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, mem ), ClearInstMark );\n@@ -6240,1 +6200,1 @@\n-  ins_encode( OpcP, RegMem( src, mem ), OpcS, RegMem_Hi( src, mem ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, mem ), OpcS, RegMem_Hi( src, mem ), ClearInstMark );\n@@ -6268,1 +6228,1 @@\n-  ins_encode( OpcP, RegMem( EAX, mem ), enc_storeL_volatile(mem,src));\n+  ins_encode( SetInstMark, OpcP, RegMem( EAX, mem ), enc_storeL_volatile(mem,src), ClearInstMark);\n@@ -6315,1 +6275,1 @@\n-  ins_encode( OpcP, RegMem( src, mem ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, mem ), ClearInstMark );\n@@ -6326,1 +6286,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con32(src), ClearInstMark);\n@@ -6338,1 +6298,1 @@\n-  ins_encode( SizePrefix, OpcP, RMopc_Mem(0x00,mem),  Con16( src ));\n+  ins_encode( SetInstMark, SizePrefix, OpcP, RMopc_Mem(0x00,mem), Con16(src), ClearInstMark);\n@@ -6350,1 +6310,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con32( src ), ClearInstMark);\n@@ -6361,1 +6321,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con8or32(src), ClearInstMark);\n@@ -6372,1 +6332,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con8or32(src), ClearInstMark);\n@@ -6471,1 +6431,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32FPR_as_bits( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),  Con32FPR_as_bits(src), ClearInstMark);\n@@ -6483,1 +6443,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32F_as_bits( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),  Con32F_as_bits(src), ClearInstMark);\n@@ -6517,1 +6477,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ), ClearInstMark );\n@@ -6692,1 +6652,1 @@\n-  ins_encode( enc_cmov(cop), RegMem( dst, src ) );\n+  ins_encode( SetInstMark, enc_cmov(cop), RegMem( dst, src ), ClearInstMark );\n@@ -6703,1 +6663,1 @@\n-  ins_encode( enc_cmov(cop), RegMem( dst, src ) );\n+  ins_encode( SetInstMark, enc_cmov(cop), RegMem( dst, src ), ClearInstMark );\n@@ -7001,1 +6961,1 @@\n-  ins_encode( OpcP, RegLea( dst, src0, src1 ) );\n+  ins_encode( SetInstMark, OpcP, RegLea( dst, src0, src1 ), ClearInstMark );\n@@ -7011,1 +6971,1 @@\n-  ins_encode( OpcP, RegLea( dst, src0, src1 ) );\n+  ins_encode( SetInstMark, OpcP, RegLea( dst, src0, src1 ), ClearInstMark );\n@@ -7056,1 +7016,1 @@\n-  ins_encode( OpcP, RegMem( dst, src) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, src), ClearInstMark );\n@@ -7067,1 +7027,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), ClearInstMark );\n@@ -7079,1 +7039,1 @@\n-  ins_encode( OpcSE( src ), RMopc_Mem(0x00,dst), Con8or32( src ) );\n+  ins_encode( SetInstMark, OpcSE( src ), RMopc_Mem(0x00,dst), Con8or32(src), ClearInstMark );\n@@ -7090,1 +7050,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,dst));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,dst), ClearInstMark);\n@@ -7101,1 +7061,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x01,dst));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x01,dst), ClearInstMark);\n@@ -7423,1 +7383,1 @@\n-  ins_encode( OpcP, RegMem( dst, src) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, src), ClearInstMark );\n@@ -7434,1 +7394,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), ClearInstMark );\n@@ -7540,1 +7500,1 @@\n-  ins_encode( OpcSE(imm), RegMem( dst, src ), Con8or32( imm ) );\n+  ins_encode( SetInstMark, OpcSE(imm), RegMem( dst, src ), Con8or32( imm ), ClearInstMark );\n@@ -7552,1 +7512,1 @@\n-  ins_encode( OpcS, OpcP, RegMem( dst, src) );\n+  ins_encode( SetInstMark, OpcS, OpcP, RegMem( dst, src), ClearInstMark );\n@@ -7957,1 +7917,1 @@\n-  ins_encode( OpcP, RMopc_Mem(secondary,dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(secondary,dst), ClearInstMark );\n@@ -7980,1 +7940,1 @@\n-  ins_encode( OpcP, RMopc_Mem(secondary, dst ), Con8or32( shift ) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(secondary, dst ), Con8or32(shift), ClearInstMark );\n@@ -8096,1 +8056,1 @@\n-  ins_encode( OpcP, RegMem( dst, src) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, src), ClearInstMark );\n@@ -8108,1 +8068,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), ClearInstMark );\n@@ -8121,1 +8081,1 @@\n-  ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );\n+  ins_encode( SetInstMark, OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32(src), ClearInstMark );\n@@ -8287,1 +8247,1 @@\n-  ins_encode( OpcP, RegMem( dst, src) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, src), ClearInstMark );\n@@ -8299,1 +8259,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), ClearInstMark );\n@@ -8312,1 +8272,1 @@\n-  ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );\n+  ins_encode( SetInstMark, OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32(src), ClearInstMark );\n@@ -8494,1 +8454,1 @@\n-  ins_encode( OpcP, RegMem(dst, src) );\n+  ins_encode( SetInstMark, OpcP, RegMem(dst, src), ClearInstMark );\n@@ -8506,1 +8466,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), ClearInstMark );\n@@ -8518,1 +8478,1 @@\n-  ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );\n+  ins_encode( SetInstMark, OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32(src), ClearInstMark );\n@@ -8804,1 +8764,1 @@\n-  ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem), ClearInstMark );\n@@ -8839,1 +8799,1 @@\n-  ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem), ClearInstMark );\n@@ -8882,1 +8842,1 @@\n-  ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem), ClearInstMark );\n@@ -9120,1 +9080,1 @@\n-  ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem), ClearInstMark );\n@@ -9166,1 +9126,1 @@\n-  ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem), ClearInstMark );\n@@ -9448,1 +9408,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -9477,1 +9437,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -9508,1 +9468,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9528,1 +9488,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9570,2 +9530,2 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),\n-              OpcP, RegOpc(dst) );\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src),\n+              OpcP, RegOpc(dst), ClearInstMark );\n@@ -9632,2 +9592,2 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),\n-              OpcP, RegOpc(dst) );\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src),\n+              OpcP, RegOpc(dst), ClearInstMark );\n@@ -9647,4 +9607,5 @@\n-  ins_encode( Opcode(0xDD), RMopc_Mem(0x00,dst),\n-              Opcode(0xD8), RegOpc(src),\n-              set_instruction_start,\n-              Opcode(0xDD), RMopc_Mem(0x03,dst) );\n+  ins_encode( SetInstMark, Opcode(0xDD), RMopc_Mem(0x00,dst),\n+              Opcode(0xD8), RegOpc(src), ClearInstMark,\n+              SetInstMark,\n+              Opcode(0xDD), RMopc_Mem(0x03,dst),\n+              ClearInstMark);\n@@ -9755,2 +9716,2 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),\n-              OpcP, RegOpc(dst) );\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src),\n+              OpcP, RegOpc(dst), ClearInstMark );\n@@ -9770,1 +9731,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,mem),\n@@ -9772,1 +9733,1 @@\n-              Pop_Reg_DPR(dst) );\n+              Pop_Reg_DPR(dst), ClearInstMark );\n@@ -10031,1 +9992,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -10060,1 +10021,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -10091,1 +10052,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -10111,1 +10072,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -10197,1 +10158,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10199,1 +10160,1 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst), ClearInstMark );\n@@ -10211,2 +10172,2 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),\n-              OpcP, RegOpc(dst) );\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src),\n+              OpcP, RegOpc(dst), ClearInstMark );\n@@ -10224,1 +10185,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src1),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src1),\n@@ -10226,1 +10187,1 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst), ClearInstMark );\n@@ -10238,2 +10199,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n-              set_instruction_start,\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10241,1 +10201,2 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst),\n+              ClearInstMark);\n@@ -10252,2 +10213,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n-              set_instruction_start,\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10255,1 +10215,2 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst),\n+              ClearInstMark);\n@@ -10331,1 +10292,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10333,1 +10294,1 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst), ClearInstMark );\n@@ -10345,1 +10306,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10347,1 +10308,1 @@\n-              Pop_Reg_FPR(dst) );\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -10358,2 +10319,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n-              set_instruction_start,\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10361,1 +10321,2 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst),\n+              ClearInstMark );\n@@ -10409,1 +10370,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem1),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,mem1),\n@@ -10411,1 +10372,1 @@\n-              Pop_Reg_FPR(dst) );\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -10427,1 +10388,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem1),\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem1),\n@@ -10430,1 +10391,1 @@\n-              Pop_Reg_FPR(dst) );\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -10969,2 +10930,2 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),\n-              Pop_Reg_DPR(dst));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),\n+              Pop_Reg_DPR(dst), ClearInstMark);\n@@ -11007,2 +10968,2 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),\n-              Pop_Mem_FPR(dst));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),\n+              Pop_Mem_FPR(dst), ClearInstMark);\n@@ -11031,2 +10992,2 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),\n-              Pop_Reg_FPR(dst));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),\n+              Pop_Reg_FPR(dst), ClearInstMark);\n@@ -11230,2 +11191,2 @@\n-  ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),\n-              Pop_Reg_FPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem_no_oop(0x00,src),\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -11269,1 +11230,1 @@\n-  ins_encode( OpcP, RegMem(dst,src), OpcS, RegMem_Hi(dst,src));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,src), OpcS, RegMem_Hi(dst,src), ClearInstMark);\n@@ -11320,1 +11281,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ), ClearInstMark );\n@@ -11334,2 +11295,2 @@\n-  ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),\n-              Pop_Reg_DPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem_no_oop(0x00,src),\n+              Pop_Reg_DPR(dst), ClearInstMark );\n@@ -12248,1 +12209,1 @@\n-  ins_encode( OpcP, RegMem( op1, op2) );\n+  ins_encode( SetInstMark, OpcP, RegMem( op1, op2), ClearInstMark );\n@@ -12276,1 +12237,1 @@\n-  ins_encode( OpcP, RegMem( src, mem ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, mem ), ClearInstMark );\n@@ -12307,1 +12268,1 @@\n-  ins_encode( OpcP, RegMem( op1, op2) );\n+  ins_encode( SetInstMark, OpcP, RegMem( op1, op2), ClearInstMark );\n@@ -12345,1 +12306,1 @@\n-  ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );\n+  ins_encode( SetInstMark, OpcSErm( op1, op2 ), Con8or32( op2 ), ClearInstMark );\n@@ -12356,1 +12317,1 @@\n-  ins_encode( OpcP, RegMem( op1, op2) );\n+  ins_encode( SetInstMark, OpcP, RegMem( op1, op2), ClearInstMark );\n@@ -12379,1 +12340,1 @@\n-  ins_encode( OpcP, RegMem( op1, op2) );\n+  ins_encode( SetInstMark, OpcP, RegMem( op1, op2), ClearInstMark );\n@@ -12404,1 +12365,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,op), Con_d32(0xFFFFFFFF) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,op), Con_d32(0xFFFFFFFF), ClearInstMark );\n@@ -12972,1 +12933,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src), ClearInstMark );\n@@ -13011,1 +12972,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem( dst, src ) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem( dst, src ), ClearInstMark );\n@@ -13181,1 +13142,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src), ClearInstMark );\n@@ -13202,1 +13163,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem( dst, src ) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem( dst, src ), ClearInstMark );\n@@ -13382,1 +13343,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src), ClearInstMark );\n@@ -13421,1 +13382,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem( dst, src ) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem( dst, src ), ClearInstMark );\n@@ -13768,0 +13729,1 @@\n+    __ set_inst_mark();\n@@ -13769,0 +13731,1 @@\n+    __ clear_inst_mark();\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":840,"deletions":877,"binary":false,"changes":1717,"status":"modified"},{"patch":"@@ -299,0 +299,3 @@\n+\/\/ Singleton class for R11 long register\n+reg_class long_r11_reg(R11, R11_H);\n+\n@@ -361,1 +364,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -522,1 +525,1 @@\n-static void emit_cmpfp_fixup(MacroAssembler& _masm) {\n+static void emit_cmpfp_fixup(MacroAssembler* masm) {\n@@ -542,1 +545,1 @@\n-static void emit_cmpfp3(MacroAssembler& _masm, Register dst) {\n+static void emit_cmpfp3(MacroAssembler* masm, Register dst) {\n@@ -561,1 +564,1 @@\n-static void emit_fp_min_max(MacroAssembler& _masm, XMMRegister dst,\n+static void emit_fp_min_max(MacroAssembler* masm, XMMRegister dst,\n@@ -646,1 +649,1 @@\n-void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n@@ -722,1 +725,1 @@\n-void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -724,1 +727,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -746,1 +748,1 @@\n-  C->output()->set_frame_complete(cbuf.insts_size());\n+  C->output()->set_frame_complete(__ offset());\n@@ -798,1 +800,1 @@\n-void MachEpilogNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void MachEpilogNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n@@ -801,1 +803,0 @@\n-  MacroAssembler _masm(&cbuf);\n@@ -828,1 +829,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -884,1 +884,1 @@\n-static void vec_mov_helper(CodeBuffer *cbuf, int src_lo, int dst_lo,\n+static void vec_mov_helper(C2_MacroAssembler *masm, int src_lo, int dst_lo,\n@@ -887,1 +887,1 @@\n-void vec_spill_helper(CodeBuffer *cbuf, bool is_load,\n+void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n@@ -890,1 +890,1 @@\n-static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,\n+static void vec_stack_to_stack_helper(C2_MacroAssembler *masm, int src_offset,\n@@ -892,2 +892,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -969,1 +968,1 @@\n-uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,\n+uint MachSpillCopyNode::implementation(C2_MacroAssembler* masm,\n@@ -973,1 +972,1 @@\n-  assert(cbuf != nullptr || st  != nullptr, \"sanity\");\n+  assert(masm != nullptr || st  != nullptr, \"sanity\");\n@@ -1000,1 +999,1 @@\n-      vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);\n+      vec_stack_to_stack_helper(masm, src_offset, dst_offset, ireg, st);\n@@ -1002,1 +1001,1 @@\n-      vec_mov_helper(cbuf, src_first, dst_first, src_second, dst_second, ireg, st);\n+      vec_mov_helper(masm, src_first, dst_first, src_second, dst_second, ireg, st);\n@@ -1005,1 +1004,1 @@\n-      vec_spill_helper(cbuf, false, stack_offset, src_first, ireg, st);\n+      vec_spill_helper(masm, false, stack_offset, src_first, ireg, st);\n@@ -1008,1 +1007,1 @@\n-      vec_spill_helper(cbuf, true,  stack_offset, dst_first, ireg, st);\n+      vec_spill_helper(masm, true,  stack_offset, dst_first, ireg, st);\n@@ -1024,2 +1023,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1042,2 +1040,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1065,2 +1062,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1080,2 +1076,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1098,2 +1093,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1114,2 +1108,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1132,2 +1125,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1153,2 +1145,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1168,2 +1159,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1185,2 +1175,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1201,2 +1190,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1219,2 +1207,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1233,2 +1220,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1249,2 +1235,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1271,2 +1256,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1286,2 +1270,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1303,2 +1286,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1317,2 +1299,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1334,2 +1315,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1349,2 +1329,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1373,2 +1352,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1389,2 +1367,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1406,2 +1383,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1435,2 +1411,2 @@\n-void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  implementation(&cbuf, ra_, false, nullptr);\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation(masm, ra_, false, nullptr);\n@@ -1454,1 +1430,1 @@\n-void BoxLockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void BoxLockNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n@@ -1459,2 +1435,1 @@\n-  MacroAssembler masm(&cbuf);\n-  masm.lea(as_Register(reg), Address(rsp, offset));\n+  __ lea(as_Register(reg), Address(rsp, offset));\n@@ -1484,1 +1459,1 @@\n-void MachUEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void MachUEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n@@ -1486,2 +1461,1 @@\n-  MacroAssembler masm(&cbuf);\n-  masm.ic_check(InteriorEntryAlignment);\n+  __ ic_check(InteriorEntryAlignment);\n@@ -1666,1 +1640,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1722,1 +1695,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1764,1 +1736,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1775,1 +1746,1 @@\n-    debug_only(int off0 = cbuf.insts_size());\n+    debug_only(int off0 = __ offset());\n@@ -1780,1 +1751,0 @@\n-      MacroAssembler _masm(&cbuf);\n@@ -1783,1 +1753,1 @@\n-    debug_only(int off1 = cbuf.insts_size());\n+    debug_only(int off1 = __ offset());\n@@ -1789,1 +1759,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1800,2 +1769,0 @@\n-    MacroAssembler _masm(&cbuf);\n-\n@@ -1810,1 +1777,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -1819,1 +1786,1 @@\n-        cbuf.shared_stub_to_interp_for(_method, call_offset);\n+        __ code()->shared_stub_to_interp_for(_method, call_offset);\n@@ -1822,1 +1789,2 @@\n-        address stub = CompiledDirectCall::emit_to_interp_stub(cbuf, mark);\n+        address stub = CompiledDirectCall::emit_to_interp_stub(masm, mark);\n+        __ clear_inst_mark();\n@@ -1833,2 +1801,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    __ ic_call((address)$meth$$method, resolved_method_index(cbuf));\n+    __ ic_call((address)$meth$$method, resolved_method_index(masm));\n@@ -2706,0 +2673,10 @@\n+operand r11_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_r11_reg));\n+  match(RegL);\n+  match(rRegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -4354,1 +4331,1 @@\n-    emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n@@ -4379,1 +4356,1 @@\n-    emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n@@ -4404,1 +4381,1 @@\n-    emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n@@ -4429,1 +4406,1 @@\n-    emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n@@ -9735,1 +9712,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -9786,1 +9763,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -9839,1 +9816,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9860,1 +9837,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9880,1 +9857,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9901,1 +9878,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9922,1 +9899,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9942,1 +9919,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -12111,0 +12088,25 @@\n+instruct partialSubtypeCheckConstSuper(rsi_RegP sub, rax_RegP super_reg, immP super_con, rdi_RegP result,\n+                                       rdx_RegL temp1, rcx_RegL temp2, rbx_RegP temp3, r11_RegL temp4,\n+                                       rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n+\n+  ins_cost(700);  \/\/ smaller than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, super\" %}\n+\n+  ins_encode %{\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register, $temp1$$Register, $temp2$$Register,\n+                                       $temp3$$Register, $temp4$$Register, $result$$Register,\n+                                       super_klass_slot);\n+    } else {\n+      __ call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n+    }\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":104,"deletions":102,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_C2_MACROASSEMBLER_ZERO_HPP\n+#define CPU_ZERO_C2_MACROASSEMBLER_ZERO_HPP\n+\n+\/\/ C2_MacroAssembler contains high-level macros for C2\n+\n+#endif \/\/ CPU_ZERO_C2_MACROASSEMBLER_ZERO_HPP\n","filename":"src\/hotspot\/cpu\/zero\/c2_MacroAssembler_zero.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -45,1 +45,1 @@\n-address CompiledDirectCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark) {\n+address CompiledDirectCall::emit_to_interp_stub(MacroAssembler *masm, address mark) {\n","filename":"src\/hotspot\/cpu\/zero\/compiledIC_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,0 +151,3 @@\n+    \/\/ Shared code tests for \"null\" to discover the stub is not generated.\n+    StubRoutines::_unsafe_setmemory          = nullptr;\n+\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-      lm->text, (uintptr_t)lm->text + lm->text_len,\n-      lm->data, (uintptr_t)lm->data + lm->data_len,\n+      p2i(lm->text), (uintptr_t)lm->text + lm->text_len,\n+      p2i(lm->data), (uintptr_t)lm->data + lm->data_len,\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-\/\/ According to the AIX OS doc #pragma alloca must be used\n-\/\/ with C++ compiler before referencing the function alloca()\n-#pragma alloca\n-\n@@ -294,40 +290,0 @@\n-\/\/ Helper function, emulates disclaim64 using multiple 32bit disclaims\n-\/\/ because we cannot use disclaim64() on old AIX releases.\n-static bool my_disclaim64(char* addr, size_t size) {\n-\n-  if (size == 0) {\n-    return true;\n-  }\n-\n-  \/\/ Maximum size 32bit disclaim() accepts. (Theoretically 4GB, but I just do not trust that.)\n-  const unsigned int maxDisclaimSize = 0x40000000;\n-\n-  const unsigned int numFullDisclaimsNeeded = (size \/ maxDisclaimSize);\n-  const unsigned int lastDisclaimSize = (size % maxDisclaimSize);\n-\n-  char* p = addr;\n-\n-  for (unsigned int i = 0; i < numFullDisclaimsNeeded; i ++) {\n-    if (::disclaim(p, maxDisclaimSize, DISCLAIM_ZEROMEM) != 0) {\n-      ErrnoPreserver ep;\n-      log_trace(os, map)(\"disclaim failed: \" RANGEFMT \" errno=(%s)\",\n-                         RANGEFMTARGS(p, maxDisclaimSize),\n-                         os::strerror(ep.saved_errno()));\n-      return false;\n-    }\n-    p += maxDisclaimSize;\n-  }\n-\n-  if (lastDisclaimSize > 0) {\n-    if (::disclaim(p, lastDisclaimSize, DISCLAIM_ZEROMEM) != 0) {\n-      ErrnoPreserver ep;\n-      log_trace(os, map)(\"disclaim failed: \" RANGEFMT \" errno=(%s)\",\n-                         RANGEFMTARGS(p, lastDisclaimSize),\n-                         os::strerror(ep.saved_errno()));\n-      return false;\n-    }\n-  }\n-\n-  return true;\n-}\n-\n@@ -649,2 +605,2 @@\n-             \", stack [\" PTR_FORMAT \" - \" PTR_FORMAT \" (\" SIZE_FORMAT \"k using %uk pages)).\",\n-             os::current_thread_id(), (uintx) kernel_thread_id, low_address, high_address,\n+             \", stack [\" PTR_FORMAT \" - \" PTR_FORMAT \" (\" SIZE_FORMAT \"k using %luk pages)).\",\n+             os::current_thread_id(), (uintx) kernel_thread_id, p2i(low_address), p2i(high_address),\n@@ -1397,2 +1353,2 @@\n-      \" bytes, %d %s pages), %s\",\n-      addr, addr + size - 1, size, size \/ pagesize, describe_pagesize(pagesize),\n+      \" bytes, %ld %s pages), %s\",\n+      p2i(addr), p2i(addr) + size - 1, size, size \/ pagesize, describe_pagesize(pagesize),\n@@ -1600,1 +1556,1 @@\n-  const bool rc = my_disclaim64(addr, size);\n+  const int rc = disclaim64(addr, size, DISCLAIM_ZEROMEM);\n@@ -1602,2 +1558,3 @@\n-  if (!rc) {\n-    log_warning(os)(\"my_disclaim64(\" PTR_FORMAT \", \" UINTX_FORMAT \") failed.\\n\", p2i(addr), size);\n+  if (rc != 0) {\n+    ErrnoPreserver ep;\n+    log_warning(os)(\"disclaim64(\" PTR_FORMAT \", \" UINTX_FORMAT \") failed, %s\\n\", p2i(addr), size, os::strerror(ep.saved_errno()));\n@@ -1976,1 +1933,1 @@\n-  Events::log(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(addr), p2i(addr+size), prot);\n+  Events::log_memprotect(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(addr), p2i(addr+size), prot);\n@@ -1981,1 +1938,1 @@\n-    warning(\"mprotect(\" PTR_FORMAT \"-\" PTR_FORMAT \", 0x%X) failed (%s).\", addr, addr + size, prot, s_errno);\n+    warning(\"mprotect(\" PTR_FORMAT \"-\" PTR_FORMAT \", 0x%X) failed (%s).\", p2i(addr), p2i(addr) + size, prot, s_errno);\n@@ -2398,1 +2355,1 @@\n-  st->print(PTR_FORMAT \": \", addr);\n+  st->print(PTR_FORMAT \": \", p2i(addr));\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":11,"deletions":54,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    unsigned long long virt_total;\n+    size_t virt_total;\n@@ -126,1 +126,1 @@\n-    unsigned long long real_total;\n+    size_t real_total;\n@@ -129,1 +129,1 @@\n-    unsigned long long real_free;\n+    size_t real_free;\n@@ -132,1 +132,1 @@\n-    unsigned long long pgsp_total;\n+    size_t pgsp_total;\n@@ -135,1 +135,1 @@\n-    unsigned long long pgsp_free;\n+    size_t pgsp_free;\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -744,1 +744,1 @@\n-    st->print(\"(base - 0x%X) \", PTRDIFF_BYTES(stack_base, cur_sp));\n+    st->print(\"(base - 0x%lX) \", PTRDIFF_BYTES(stack_base, cur_sp));\n@@ -800,1 +800,1 @@\n-        st->print_cr(\"found something which looks like a backchain at \" PTR_FORMAT \", after 0x%x bytes... \",\n+        st->print_cr(\"found something which looks like a backchain at \" PTR_FORMAT \", after 0x%lx bytes... \",\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,548 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"os_posix.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"services\/attachListener.hpp\"\n-#include \"utilities\/checkedCast.hpp\"\n-\n-#include <unistd.h>\n-#include <signal.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <sys\/un.h>\n-#include <sys\/stat.h>\n-\n-#ifndef UNIX_PATH_MAX\n-#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n-#endif\n-\n-\/\/ The attach mechanism on Bsd uses a UNIX domain socket. An attach listener\n-\/\/ thread is created at startup or is created on-demand via a signal from\n-\/\/ the client tool. The attach listener creates a socket and binds it to a file\n-\/\/ in the filesystem. The attach listener then acts as a simple (single-\n-\/\/ threaded) server - it waits for a client to connect, reads the request,\n-\/\/ executes it, and returns the response to the client via the socket\n-\/\/ connection.\n-\/\/\n-\/\/ As the socket is a UNIX domain socket it means that only clients on the\n-\/\/ local machine can connect. In addition there are two other aspects to\n-\/\/ the security:\n-\/\/ 1. The well known file that the socket is bound to has permission 400\n-\/\/ 2. When a client connect, the SO_PEERCRED socket option is used to\n-\/\/    obtain the credentials of client. We check that the effective uid\n-\/\/    of the client matches this process.\n-\n-\/\/ forward reference\n-class BsdAttachOperation;\n-\n-class BsdAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n-  \/\/ reads a request from the given connected socket\n-  static BsdAttachOperation* read_request(int s);\n-\n- public:\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n-  static void set_path(char* path) {\n-    if (path == nullptr) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, size_t len);\n-\n-  static BsdAttachOperation* dequeue();\n-};\n-\n-class BsdAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  int _socket;\n-\n- public:\n-  void complete(jint res, bufferedStream* st);\n-\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n-\n-  BsdAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n-  }\n-};\n-\n-\/\/ statics\n-char BsdAttachListener::_path[UNIX_PATH_MAX];\n-bool BsdAttachListener::_has_path;\n-volatile int BsdAttachListener::_listener = -1;\n-bool BsdAttachListener::_atexit_registered = false;\n-\n-\/\/ Supporting class to help split a buffer into individual components\n-class ArgumentIterator : public StackObj {\n- private:\n-  char* _pos;\n-  char* _end;\n- public:\n-  ArgumentIterator(char* arg_buffer, size_t arg_size) {\n-    _pos = arg_buffer;\n-    _end = _pos + arg_size - 1;\n-  }\n-  char* next() {\n-    if (*_pos == '\\0') {\n-      \/\/ advance the iterator if possible (null arguments)\n-      if (_pos < _end) {\n-        _pos += 1;\n-      }\n-      return nullptr;\n-    }\n-    char* res = _pos;\n-    char* next_pos = strchr(_pos, '\\0');\n-    if (next_pos < _end)  {\n-      next_pos++;\n-    }\n-    _pos = next_pos;\n-    return res;\n-  }\n-};\n-\n-\n-\/\/ atexit hook to stop listener and unlink the file that it is\n-\/\/ bound too.\n-extern \"C\" {\n-  static void listener_cleanup() {\n-    int s = BsdAttachListener::listener();\n-    if (s != -1) {\n-      BsdAttachListener::set_listener(-1);\n-      ::shutdown(s, SHUT_RDWR);\n-      ::close(s);\n-    }\n-    if (BsdAttachListener::has_path()) {\n-      ::unlink(BsdAttachListener::path());\n-      BsdAttachListener::set_path(nullptr);\n-    }\n-  }\n-}\n-\n-\/\/ Initialization - create a listener socket and bind it to a file\n-\n-int BsdAttachListener::init() {\n-  char path[UNIX_PATH_MAX];          \/\/ socket file\n-  char initial_path[UNIX_PATH_MAX];  \/\/ socket file during setup\n-  int listener;                      \/\/ listener socket (file descriptor)\n-\n-  \/\/ register function to cleanup\n-  if (!_atexit_registered) {\n-    _atexit_registered = true;\n-    ::atexit(listener_cleanup);\n-  }\n-\n-  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-                   os::get_temp_directory(), os::current_process_id());\n-  if (n < (int)UNIX_PATH_MAX) {\n-    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n-  }\n-  if (n >= (int)UNIX_PATH_MAX) {\n-    return -1;\n-  }\n-\n-  \/\/ create the listener socket\n-  listener = ::socket(PF_UNIX, SOCK_STREAM, 0);\n-  if (listener == -1) {\n-    return -1;\n-  }\n-\n-  \/\/ bind socket\n-  struct sockaddr_un addr;\n-  memset((void *)&addr, 0, sizeof(addr));\n-  addr.sun_family = AF_UNIX;\n-  strcpy(addr.sun_path, initial_path);\n-  ::unlink(initial_path);\n-  int res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));\n-  if (res == -1) {\n-    ::close(listener);\n-    return -1;\n-  }\n-\n-  \/\/ put in listen mode, set permissions, and rename into place\n-  res = ::listen(listener, 5);\n-  if (res == 0) {\n-    RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);\n-    if (res == 0) {\n-      \/\/ make sure the file is owned by the effective user and effective group\n-      \/\/ e.g. default behavior on mac is that new files inherit the group of\n-      \/\/ the directory that they are created in\n-      RESTARTABLE(::chown(initial_path, geteuid(), getegid()), res);\n-      if (res == 0) {\n-        res = ::rename(initial_path, path);\n-      }\n-    }\n-  }\n-  if (res == -1) {\n-    ::close(listener);\n-    ::unlink(initial_path);\n-    return -1;\n-  }\n-  set_path(path);\n-  set_listener(listener);\n-\n-  return 0;\n-}\n-\n-\/\/ Given a socket that is connected to a peer we read the request and\n-\/\/ create an AttachOperation. As the socket is blocking there is potential\n-\/\/ for a denial-of-service if the peer does not response. However this happens\n-\/\/ after the peer credentials have been checked and in the worst case it just\n-\/\/ means that the attach listener thread is blocked.\n-\/\/\n-BsdAttachOperation* BsdAttachListener::read_request(int s) {\n-  char ver_str[8];\n-  size_t ver_str_len = os::snprintf_checked(ver_str, sizeof(ver_str), \"%d\", ATTACH_PROTOCOL_VER);\n-\n-  \/\/ The request is a sequence of strings so we first figure out the\n-  \/\/ expected count and the maximum possible length of the request.\n-  \/\/ The request is:\n-  \/\/   <ver>0<cmd>0<arg>0<arg>0<arg>0\n-  \/\/ where <ver> is the protocol version (1), <cmd> is the command\n-  \/\/ name (\"load\", \"datadump\", ...), and <arg> is an argument\n-  int expected_str_count = 2 + AttachOperation::arg_count_max;\n-  const size_t max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n-    AttachOperation::arg_count_max*(AttachOperation::arg_length_max + 1);\n-\n-  char buf[max_len];\n-  int str_count = 0;\n-\n-  \/\/ Read until all (expected) strings have been read, the buffer is\n-  \/\/ full, or EOF.\n-\n-  size_t off = 0;\n-  size_t left = max_len;\n-\n-  do {\n-    ssize_t n;\n-    RESTARTABLE(read(s, buf+off, left), n);\n-    assert(n <= checked_cast<ssize_t>(left), \"buffer was too small, impossible!\");\n-    buf[max_len - 1] = '\\0';\n-    if (n == -1) {\n-      return nullptr;      \/\/ reset by peer or other error\n-    }\n-    if (n == 0) {\n-      break;\n-    }\n-    for (ssize_t i=0; i<n; i++) {\n-      if (buf[off+i] == 0) {\n-        \/\/ EOS found\n-        str_count++;\n-\n-        \/\/ The first string is <ver> so check it now to\n-        \/\/ check for protocol mismatch\n-        if (str_count == 1) {\n-          if ((strlen(buf) != ver_str_len) ||\n-              (atoi(buf) != ATTACH_PROTOCOL_VER)) {\n-            char msg[32];\n-            int msg_len = os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", ATTACH_ERROR_BADVERSION);\n-            write_fully(s, msg, msg_len);\n-            return nullptr;\n-          }\n-        }\n-      }\n-    }\n-    off += n;\n-    left -= n;\n-  } while (left > 0 && str_count < expected_str_count);\n-\n-  if (str_count != expected_str_count) {\n-    return nullptr;        \/\/ incomplete request\n-  }\n-\n-  \/\/ parse request\n-\n-  ArgumentIterator args(buf, (max_len)-left);\n-\n-  \/\/ version already checked\n-  char* v = args.next();\n-\n-  char* name = args.next();\n-  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n-    return nullptr;\n-  }\n-\n-  BsdAttachOperation* op = new BsdAttachOperation(name);\n-\n-  for (int i=0; i<AttachOperation::arg_count_max; i++) {\n-    char* arg = args.next();\n-    if (arg == nullptr) {\n-      op->set_arg(i, nullptr);\n-    } else {\n-      if (strlen(arg) > AttachOperation::arg_length_max) {\n-        delete op;\n-        return nullptr;\n-      }\n-      op->set_arg(i, arg);\n-    }\n-  }\n-\n-  op->set_socket(s);\n-  return op;\n-}\n-\n-\n-\/\/ Dequeue an operation\n-\/\/\n-\/\/ In the Bsd implementation there is only a single operation and clients\n-\/\/ cannot queue commands (except at the socket level).\n-\/\/\n-BsdAttachOperation* BsdAttachListener::dequeue() {\n-  for (;;) {\n-    int s;\n-\n-    \/\/ wait for client to connect\n-    struct sockaddr addr;\n-    socklen_t len = sizeof(addr);\n-    RESTARTABLE(::accept(listener(), &addr, &len), s);\n-    if (s == -1) {\n-      return nullptr;      \/\/ log a warning?\n-    }\n-\n-    \/\/ get the credentials of the peer and check the effective uid\/guid\n-    uid_t puid;\n-    gid_t pgid;\n-    if (::getpeereid(s, &puid, &pgid) != 0) {\n-      log_debug(attach)(\"Failed to get peer id\");\n-      ::close(s);\n-      continue;\n-    }\n-\n-    if (!os::Posix::matches_effective_uid_and_gid_or_root(puid, pgid)) {\n-      log_debug(attach)(\"euid\/egid check failed (%d\/%d vs %d\/%d)\", puid, pgid,\n-              geteuid(), getegid());\n-      ::close(s);\n-      continue;\n-    }\n-\n-    \/\/ peer credential look okay so we read the request\n-    BsdAttachOperation* op = read_request(s);\n-    if (op == nullptr) {\n-      ::close(s);\n-      continue;\n-    } else {\n-      return op;\n-    }\n-  }\n-}\n-\n-\/\/ write the given buffer to the socket\n-int BsdAttachListener::write_fully(int s, char* buf, size_t len) {\n-  do {\n-    ssize_t n = ::write(s, buf, len);\n-    if (n == -1) {\n-      if (errno != EINTR) return -1;\n-    } else {\n-      buf += n;\n-      len -= n;\n-    }\n-  }\n-  while (len > 0);\n-  return 0;\n-}\n-\n-\/\/ Complete an operation by sending the operation result and any result\n-\/\/ output to the client. At this time the socket is in blocking mode so\n-\/\/ potentially we can block if there is a lot of data and the client is\n-\/\/ non-responsive. For most operations this is a non-issue because the\n-\/\/ default send buffer is sufficient to buffer everything. In the future\n-\/\/ if there are operations that involves a very big reply then it the\n-\/\/ socket could be made non-blocking and a timeout could be used.\n-\n-void BsdAttachOperation::complete(jint result, bufferedStream* st) {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  \/\/ write operation result\n-  char msg[32];\n-  int msg_len = os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n-  int rc = BsdAttachListener::write_fully(this->socket(), msg, msg_len);\n-\n-  \/\/ write any result data\n-  if (rc == 0) {\n-    BsdAttachListener::write_fully(this->socket(), (char*) st->base(), st->size());\n-    ::shutdown(this->socket(), 2);\n-  }\n-\n-  \/\/ done\n-  ::close(this->socket());\n-\n-  delete this;\n-}\n-\n-\n-\/\/ AttachListener functions\n-\n-AttachOperation* AttachListener::dequeue() {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  AttachOperation* op = BsdAttachListener::dequeue();\n-\n-  return op;\n-}\n-\n-\/\/ Performs initialization at vm startup\n-\/\/ For BSD we remove any stale .java_pid file which could cause\n-\/\/ an attaching process to think we are ready to receive on the\n-\/\/ domain socket before we are properly initialized\n-\n-void AttachListener::vm_start() {\n-  char fn[UNIX_PATH_MAX];\n-  struct stat st;\n-  int ret;\n-\n-  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n-\n-  RESTARTABLE(::stat(fn, &st), ret);\n-  if (ret == 0) {\n-    ret = ::unlink(fn);\n-    if (ret == -1) {\n-      log_debug(attach)(\"Failed to remove stale attach pid file at %s\", fn);\n-    }\n-  }\n-}\n-\n-int AttachListener::pd_init() {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  int ret_code = BsdAttachListener::init();\n-\n-  return ret_code;\n-}\n-\n-bool AttachListener::check_socket_file() {\n-  int ret;\n-  struct stat st;\n-  ret = stat(BsdAttachListener::path(), &st);\n-  if (ret == -1) { \/\/ need to restart attach listener.\n-    log_debug(attach)(\"Socket file %s does not exist - Restart Attach Listener\",\n-                      BsdAttachListener::path());\n-\n-    listener_cleanup();\n-\n-    \/\/ wait to terminate current attach listener instance...\n-    {\n-      \/\/ avoid deadlock if AttachListener thread is blocked at safepoint\n-      ThreadBlockInVM tbivm(JavaThread::current());\n-      while (AttachListener::transit_state(AL_INITIALIZING,\n-                                           AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n-        os::naked_yield();\n-      }\n-    }\n-    return is_init_trigger();\n-  }\n-  return false;\n-}\n-\n-\/\/ Attach Listener is started lazily except in the case when\n-\/\/ +ReduseSignalUsage is used\n-bool AttachListener::init_at_startup() {\n-  if (ReduceSignalUsage) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ If the file .attach_pid<pid> exists in the working directory\n-\/\/ or \/tmp then this is the trigger to start the attach mechanism\n-bool AttachListener::is_init_trigger() {\n-  if (init_at_startup() || is_initialized()) {\n-    return false;               \/\/ initialized at startup or already initialized\n-  }\n-  char fn[PATH_MAX + 1];\n-  int ret;\n-  struct stat st;\n-  snprintf(fn, PATH_MAX + 1, \"%s\/.attach_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  RESTARTABLE(::stat(fn, &st), ret);\n-  if (ret == -1) {\n-    log_debug(attach)(\"Failed to find attach file: %s\", fn);\n-  }\n-  if (ret == 0) {\n-    \/\/ simple check to avoid starting the attach mechanism when\n-    \/\/ a bogus non-root user creates the file\n-    if (os::Posix::matches_effective_uid_or_root(st.st_uid)) {\n-      init();\n-      log_trace(attach)(\"Attach triggered by %s\", fn);\n-      return true;\n-    } else {\n-      log_debug(attach)(\"File %s has wrong user id %d (vs %d). Attach is not triggered\", fn, st.st_uid, geteuid());\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ if VM aborts then remove listener\n-void AttachListener::abort() {\n-  listener_cleanup();\n-}\n-\n-void AttachListener::pd_data_dump() {\n-  os::signal_notify(SIGQUIT);\n-}\n-\n-void AttachListener::pd_detachall() {\n-  \/\/ do nothing for now\n-}\n","filename":"src\/hotspot\/os\/bsd\/attachListener_bsd.cpp","additions":0,"deletions":548,"binary":false,"changes":548,"status":"deleted"},{"patch":"@@ -1593,1 +1593,1 @@\n-  Events::log(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(addr), p2i(addr+size), prot);\n+  Events::log_memprotect(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(addr), p2i(addr+size), prot);\n@@ -1714,1 +1714,1 @@\n-  Events::log(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with PROT_NONE\", p2i(addr), p2i(addr+size));\n+  Events::log_memprotect(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with PROT_NONE\", p2i(addr), p2i(addr+size));\n@@ -1832,1 +1832,1 @@\n-  Events::log(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(bottom), p2i(bottom+size), prot);\n+  Events::log_memprotect(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(bottom), p2i(bottom+size), prot);\n@@ -2143,8 +2143,11 @@\n-      nbr_files.rlim_cur = nbr_files.rlim_max;\n-\n-#ifdef __APPLE__\n-      \/\/ Darwin returns RLIM_INFINITY for rlim_max, but fails with EINVAL if\n-      \/\/ you attempt to use RLIM_INFINITY. As per setrlimit(2), OPEN_MAX must\n-      \/\/ be used instead\n-      nbr_files.rlim_cur = MIN(OPEN_MAX, nbr_files.rlim_cur);\n-#endif\n+      rlim_t rlim_original = nbr_files.rlim_cur;\n+\n+      \/\/ On macOS according to setrlimit(2), OPEN_MAX must be used instead\n+      \/\/ of RLIM_INFINITY, but testing on macOS >= 10.6, reveals that\n+      \/\/ we can, in fact, use even RLIM_INFINITY, so try the max value\n+      \/\/ that the system claims can be used first, same as other BSD OSes.\n+      \/\/ However, some terminals (ksh) will internally use \"int\" type\n+      \/\/ to store this value and since RLIM_INFINITY overflows an \"int\"\n+      \/\/ we might end up with a negative value, so cap the system limit max\n+      \/\/ at INT_MAX instead, just in case, for everyone.\n+      nbr_files.rlim_cur = MIN(INT_MAX, nbr_files.rlim_max);\n@@ -2153,0 +2156,6 @@\n+      if (status != 0) {\n+        \/\/ If that fails then try lowering the limit to either OPEN_MAX\n+        \/\/ (which is safe) or the original limit, whichever was greater.\n+        nbr_files.rlim_cur = MAX(OPEN_MAX, rlim_original);\n+        status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n+      }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,555 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"os_posix.hpp\"\n-#include \"services\/attachListener.hpp\"\n-#include \"utilities\/checkedCast.hpp\"\n-\n-#include <unistd.h>\n-#include <signal.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <sys\/un.h>\n-#include <sys\/stat.h>\n-\n-#ifndef UNIX_PATH_MAX\n-#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n-#endif\n-\n-\/\/ The attach mechanism on Linux uses a UNIX domain socket. An attach listener\n-\/\/ thread is created at startup or is created on-demand via a signal from\n-\/\/ the client tool. The attach listener creates a socket and binds it to a file\n-\/\/ in the filesystem. The attach listener then acts as a simple (single-\n-\/\/ threaded) server - it waits for a client to connect, reads the request,\n-\/\/ executes it, and returns the response to the client via the socket\n-\/\/ connection.\n-\/\/\n-\/\/ As the socket is a UNIX domain socket it means that only clients on the\n-\/\/ local machine can connect. In addition there are two other aspects to\n-\/\/ the security:\n-\/\/ 1. The well known file that the socket is bound to has permission 400\n-\/\/ 2. When a client connect, the SO_PEERCRED socket option is used to\n-\/\/    obtain the credentials of client. We check that the effective uid\n-\/\/    of the client matches this process.\n-\n-\/\/ forward reference\n-class LinuxAttachOperation;\n-\n-class LinuxAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n-  \/\/ reads a request from the given connected socket\n-  static LinuxAttachOperation* read_request(int s);\n-\n- public:\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n-  static void set_path(char* path) {\n-    if (path == nullptr) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, size_t len);\n-\n-  static LinuxAttachOperation* dequeue();\n-};\n-\n-class LinuxAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  int _socket;\n-\n- public:\n-  void complete(jint res, bufferedStream* st);\n-\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n-\n-  LinuxAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n-  }\n-};\n-\n-\/\/ statics\n-char LinuxAttachListener::_path[UNIX_PATH_MAX];\n-bool LinuxAttachListener::_has_path;\n-volatile int LinuxAttachListener::_listener = -1;\n-bool LinuxAttachListener::_atexit_registered = false;\n-\n-\/\/ Supporting class to help split a buffer into individual components\n-class ArgumentIterator : public StackObj {\n- private:\n-  char* _pos;\n-  char* _end;\n- public:\n-  ArgumentIterator(char* arg_buffer, size_t arg_size) {\n-    _pos = arg_buffer;\n-    _end = _pos + arg_size - 1;\n-  }\n-  char* next() {\n-    if (*_pos == '\\0') {\n-      \/\/ advance the iterator if possible (null arguments)\n-      if (_pos < _end) {\n-        _pos += 1;\n-      }\n-      return nullptr;\n-    }\n-    char* res = _pos;\n-    char* next_pos = strchr(_pos, '\\0');\n-    if (next_pos < _end)  {\n-      next_pos++;\n-    }\n-    _pos = next_pos;\n-    return res;\n-  }\n-};\n-\n-\n-\/\/ atexit hook to stop listener and unlink the file that it is\n-\/\/ bound too.\n-extern \"C\" {\n-  static void listener_cleanup() {\n-    int s = LinuxAttachListener::listener();\n-    if (s != -1) {\n-      LinuxAttachListener::set_listener(-1);\n-      ::shutdown(s, SHUT_RDWR);\n-      ::close(s);\n-    }\n-    if (LinuxAttachListener::has_path()) {\n-      ::unlink(LinuxAttachListener::path());\n-      LinuxAttachListener::set_path(nullptr);\n-    }\n-  }\n-}\n-\n-\/\/ Initialization - create a listener socket and bind it to a file\n-\n-int LinuxAttachListener::init() {\n-  char path[UNIX_PATH_MAX];          \/\/ socket file\n-  char initial_path[UNIX_PATH_MAX];  \/\/ socket file during setup\n-  int listener;                      \/\/ listener socket (file descriptor)\n-\n-  static_assert(sizeof(off_t) == 8, \"Expected Large File Support in this file\");\n-\n-  \/\/ register function to cleanup\n-  if (!_atexit_registered) {\n-    _atexit_registered = true;\n-    ::atexit(listener_cleanup);\n-  }\n-\n-  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-                   os::get_temp_directory(), os::current_process_id());\n-  if (n < (int)UNIX_PATH_MAX) {\n-    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n-  }\n-  if (n >= (int)UNIX_PATH_MAX) {\n-    return -1;\n-  }\n-\n-  \/\/ create the listener socket\n-  listener = ::socket(PF_UNIX, SOCK_STREAM, 0);\n-  if (listener == -1) {\n-    return -1;\n-  }\n-\n-  \/\/ bind socket\n-  struct sockaddr_un addr;\n-  memset((void *)&addr, 0, sizeof(addr));\n-  addr.sun_family = AF_UNIX;\n-  strcpy(addr.sun_path, initial_path);\n-  ::unlink(initial_path);\n-  int res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));\n-  if (res == -1) {\n-    ::close(listener);\n-    return -1;\n-  }\n-\n-  \/\/ put in listen mode, set permissions, and rename into place\n-  res = ::listen(listener, 5);\n-  if (res == 0) {\n-    RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);\n-    if (res == 0) {\n-      \/\/ make sure the file is owned by the effective user and effective group\n-      \/\/ e.g. the group could be inherited from the directory in case the s bit is set\n-      RESTARTABLE(::chown(initial_path, geteuid(), getegid()), res);\n-      if (res == 0) {\n-        res = ::rename(initial_path, path);\n-      }\n-    }\n-  }\n-  if (res == -1) {\n-    ::close(listener);\n-    ::unlink(initial_path);\n-    return -1;\n-  }\n-  set_path(path);\n-  set_listener(listener);\n-\n-  return 0;\n-}\n-\n-\/\/ Given a socket that is connected to a peer we read the request and\n-\/\/ create an AttachOperation. As the socket is blocking there is potential\n-\/\/ for a denial-of-service if the peer does not response. However this happens\n-\/\/ after the peer credentials have been checked and in the worst case it just\n-\/\/ means that the attach listener thread is blocked.\n-\/\/\n-LinuxAttachOperation* LinuxAttachListener::read_request(int s) {\n-  char ver_str[8];\n-  os::snprintf_checked(ver_str, sizeof(ver_str), \"%d\", ATTACH_PROTOCOL_VER);\n-\n-  \/\/ The request is a sequence of strings so we first figure out the\n-  \/\/ expected count and the maximum possible length of the request.\n-  \/\/ The request is:\n-  \/\/   <ver>0<cmd>0<arg>0<arg>0<arg>0\n-  \/\/ where <ver> is the protocol version (1), <cmd> is the command\n-  \/\/ name (\"load\", \"datadump\", ...), and <arg> is an argument\n-  int expected_str_count = 2 + AttachOperation::arg_count_max;\n-  const size_t max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n-    AttachOperation::arg_count_max*(AttachOperation::arg_length_max + 1);\n-\n-  char buf[max_len];\n-  int str_count = 0;\n-\n-  \/\/ Read until all (expected) strings have been read, the buffer is\n-  \/\/ full, or EOF.\n-\n-  size_t off = 0;\n-  size_t left = max_len;\n-\n-  do {\n-    ssize_t n;\n-    RESTARTABLE(read(s, buf+off, left), n);\n-    assert(n <= checked_cast<ssize_t>(left), \"buffer was too small, impossible!\");\n-    buf[max_len - 1] = '\\0';\n-    if (n == -1) {\n-      return nullptr;      \/\/ reset by peer or other error\n-    }\n-    if (n == 0) {\n-      break;\n-    }\n-    for (ssize_t i=0; i<n; i++) {\n-      if (buf[off+i] == 0) {\n-        \/\/ EOS found\n-        str_count++;\n-\n-        \/\/ The first string is <ver> so check it now to\n-        \/\/ check for protocol mismatch\n-        if (str_count == 1) {\n-          if ((strlen(buf) != strlen(ver_str)) ||\n-              (atoi(buf) != ATTACH_PROTOCOL_VER)) {\n-            char msg[32];\n-            os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", ATTACH_ERROR_BADVERSION);\n-            write_fully(s, msg, strlen(msg));\n-            return nullptr;\n-          }\n-        }\n-      }\n-    }\n-    off += n;\n-    left -= n;\n-  } while (left > 0 && str_count < expected_str_count);\n-\n-  if (str_count != expected_str_count) {\n-    return nullptr;        \/\/ incomplete request\n-  }\n-\n-  \/\/ parse request\n-\n-  ArgumentIterator args(buf, (max_len)-left);\n-\n-  \/\/ version already checked\n-  char* v = args.next();\n-\n-  char* name = args.next();\n-  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n-    return nullptr;\n-  }\n-\n-  LinuxAttachOperation* op = new LinuxAttachOperation(name);\n-\n-  for (int i=0; i<AttachOperation::arg_count_max; i++) {\n-    char* arg = args.next();\n-    if (arg == nullptr) {\n-      op->set_arg(i, nullptr);\n-    } else {\n-      if (strlen(arg) > AttachOperation::arg_length_max) {\n-        delete op;\n-        return nullptr;\n-      }\n-      op->set_arg(i, arg);\n-    }\n-  }\n-\n-  op->set_socket(s);\n-  return op;\n-}\n-\n-\n-\/\/ Dequeue an operation\n-\/\/\n-\/\/ In the Linux implementation there is only a single operation and clients\n-\/\/ cannot queue commands (except at the socket level).\n-\/\/\n-LinuxAttachOperation* LinuxAttachListener::dequeue() {\n-  for (;;) {\n-    int s;\n-\n-    \/\/ wait for client to connect\n-    struct sockaddr addr;\n-    socklen_t len = sizeof(addr);\n-    RESTARTABLE(::accept(listener(), &addr, &len), s);\n-    if (s == -1) {\n-      return nullptr;      \/\/ log a warning?\n-    }\n-\n-    \/\/ get the credentials of the peer and check the effective uid\/guid\n-    struct ucred cred_info;\n-    socklen_t optlen = sizeof(cred_info);\n-    if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info, &optlen) == -1) {\n-      log_debug(attach)(\"Failed to get socket option SO_PEERCRED\");\n-      ::close(s);\n-      continue;\n-    }\n-\n-    if (!os::Posix::matches_effective_uid_and_gid_or_root(cred_info.uid, cred_info.gid)) {\n-      log_debug(attach)(\"euid\/egid check failed (%d\/%d vs %d\/%d)\",\n-              cred_info.uid, cred_info.gid, geteuid(), getegid());\n-      ::close(s);\n-      continue;\n-    }\n-\n-    \/\/ peer credential look okay so we read the request\n-    LinuxAttachOperation* op = read_request(s);\n-    if (op == nullptr) {\n-      ::close(s);\n-      continue;\n-    } else {\n-      return op;\n-    }\n-  }\n-}\n-\n-\/\/ write the given buffer to the socket\n-int LinuxAttachListener::write_fully(int s, char* buf, size_t len) {\n-  do {\n-    ssize_t n = ::write(s, buf, len);\n-    if (n == -1) {\n-      if (errno != EINTR) return -1;\n-    } else {\n-      buf += n;\n-      len -= n;\n-    }\n-  }\n-  while (len > 0);\n-  return 0;\n-}\n-\n-\/\/ Complete an operation by sending the operation result and any result\n-\/\/ output to the client. At this time the socket is in blocking mode so\n-\/\/ potentially we can block if there is a lot of data and the client is\n-\/\/ non-responsive. For most operations this is a non-issue because the\n-\/\/ default send buffer is sufficient to buffer everything. In the future\n-\/\/ if there are operations that involves a very big reply then it the\n-\/\/ socket could be made non-blocking and a timeout could be used.\n-\n-void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  \/\/ write operation result\n-  char msg[32];\n-  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n-  int rc = LinuxAttachListener::write_fully(this->socket(), msg, strlen(msg));\n-\n-  \/\/ write any result data\n-  if (rc == 0) {\n-    LinuxAttachListener::write_fully(this->socket(), (char*) st->base(), st->size());\n-    ::shutdown(this->socket(), 2);\n-  }\n-\n-  \/\/ done\n-  ::close(this->socket());\n-\n-  delete this;\n-}\n-\n-\n-\/\/ AttachListener functions\n-\n-AttachOperation* AttachListener::dequeue() {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  AttachOperation* op = LinuxAttachListener::dequeue();\n-\n-  return op;\n-}\n-\n-\/\/ Performs initialization at vm startup\n-\/\/ For Linux we remove any stale .java_pid file which could cause\n-\/\/ an attaching process to think we are ready to receive on the\n-\/\/ domain socket before we are properly initialized\n-\n-void AttachListener::vm_start() {\n-  char fn[UNIX_PATH_MAX];\n-  struct stat st;\n-  int ret;\n-\n-  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n-\n-  RESTARTABLE(::stat(fn, &st), ret);\n-  if (ret == 0) {\n-    ret = ::unlink(fn);\n-    if (ret == -1) {\n-      log_debug(attach)(\"Failed to remove stale attach pid file at %s\", fn);\n-    }\n-  }\n-}\n-\n-int AttachListener::pd_init() {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  int ret_code = LinuxAttachListener::init();\n-\n-  return ret_code;\n-}\n-\n-bool AttachListener::check_socket_file() {\n-  int ret;\n-  struct stat st;\n-  ret = stat(LinuxAttachListener::path(), &st);\n-  if (ret == -1) { \/\/ need to restart attach listener.\n-    log_debug(attach)(\"Socket file %s does not exist - Restart Attach Listener\",\n-                      LinuxAttachListener::path());\n-\n-    listener_cleanup();\n-\n-    \/\/ wait to terminate current attach listener instance...\n-    {\n-      \/\/ avoid deadlock if AttachListener thread is blocked at safepoint\n-      ThreadBlockInVM tbivm(JavaThread::current());\n-      while (AttachListener::transit_state(AL_INITIALIZING,\n-                                           AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n-        os::naked_yield();\n-      }\n-    }\n-    return is_init_trigger();\n-  }\n-  return false;\n-}\n-\n-\/\/ Attach Listener is started lazily except in the case when\n-\/\/ +ReduseSignalUsage is used\n-bool AttachListener::init_at_startup() {\n-  if (ReduceSignalUsage) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ If the file .attach_pid<pid> exists in the working directory\n-\/\/ or \/tmp then this is the trigger to start the attach mechanism\n-bool AttachListener::is_init_trigger() {\n-  if (init_at_startup() || is_initialized()) {\n-    return false;               \/\/ initialized at startup or already initialized\n-  }\n-  char fn[PATH_MAX + 1];\n-  int ret;\n-  struct stat st;\n-  os::snprintf_checked(fn, sizeof(fn), \".attach_pid%d\", os::current_process_id());\n-  RESTARTABLE(::stat(fn, &st), ret);\n-  if (ret == -1) {\n-    log_trace(attach)(\"Failed to find attach file: %s, trying alternate\", fn);\n-    snprintf(fn, sizeof(fn), \"%s\/.attach_pid%d\",\n-             os::get_temp_directory(), os::current_process_id());\n-    RESTARTABLE(::stat(fn, &st), ret);\n-    if (ret == -1) {\n-      log_debug(attach)(\"Failed to find attach file: %s\", fn);\n-    }\n-  }\n-  if (ret == 0) {\n-    \/\/ simple check to avoid starting the attach mechanism when\n-    \/\/ a bogus non-root user creates the file\n-    if (os::Posix::matches_effective_uid_or_root(st.st_uid)) {\n-      init();\n-      log_trace(attach)(\"Attach triggered by %s\", fn);\n-      return true;\n-    } else {\n-      log_debug(attach)(\"File %s has wrong user id %d (vs %d). Attach is not triggered\", fn, st.st_uid, geteuid());\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ if VM aborts then remove listener\n-void AttachListener::abort() {\n-  listener_cleanup();\n-}\n-\n-void AttachListener::pd_data_dump() {\n-  os::signal_notify(SIGQUIT);\n-}\n-\n-void AttachListener::pd_detachall() {\n-  \/\/ do nothing for now\n-}\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":0,"deletions":555,"binary":false,"changes":555,"status":"deleted"},{"patch":"@@ -2975,1 +2975,1 @@\n-  static_assert(MADV_POPULATE_WRITE == MADV_POPULATE_WRITE_value);\n+  STATIC_ASSERT(MADV_POPULATE_WRITE == MADV_POPULATE_WRITE_value);\n@@ -2985,1 +2985,1 @@\n-  static_assert(MAP_FIXED_NOREPLACE == MAP_FIXED_NOREPLACE_value, \"MAP_FIXED_NOREPLACE != MAP_FIXED_NOREPLACE_value\");\n+  STATIC_ASSERT(MAP_FIXED_NOREPLACE == MAP_FIXED_NOREPLACE_value);\n@@ -3789,1 +3789,1 @@\n-  Events::log(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(bottom), p2i(bottom+size), prot);\n+  Events::log_memprotect(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(bottom), p2i(bottom+size), prot);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -850,1 +850,1 @@\n-  _valid = true;\n+  _valid = _dir != nullptr; \/\/ May be null if \/proc is not accessible.\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,585 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"os_posix.hpp\"\n+#include \"services\/attachListener.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <unistd.h>\n+#include <signal.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <sys\/un.h>\n+#include <sys\/stat.h>\n+\n+#if INCLUDE_SERVICES\n+#ifndef AIX\n+\n+#ifndef UNIX_PATH_MAX\n+#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n+#endif\n+\n+\/\/ The attach mechanism on Linux and BSD uses a UNIX domain socket. An attach\n+\/\/ listener thread is created at startup or is created on-demand via a signal\n+\/\/ from the client tool. The attach listener creates a socket and binds it to a\n+\/\/ file in the filesystem. The attach listener then acts as a simple (single-\n+\/\/ threaded) server - it waits for a client to connect, reads the request,\n+\/\/ executes it, and returns the response to the client via the socket\n+\/\/ connection.\n+\/\/\n+\/\/ As the socket is a UNIX domain socket it means that only clients on the\n+\/\/ local machine can connect. In addition there are two other aspects to\n+\/\/ the security:\n+\/\/ 1. The well known file that the socket is bound to has permission 400\n+\/\/ 2. When a client connect, the SO_PEERCRED socket option is used to\n+\/\/    obtain the credentials of client. We check that the effective uid\n+\/\/    of the client matches this process.\n+\n+\/\/ forward reference\n+class PosixAttachOperation;\n+\n+class PosixAttachListener: AllStatic {\n+ private:\n+  \/\/ the path to which we bind the UNIX domain socket\n+  static char _path[UNIX_PATH_MAX];\n+  static bool _has_path;\n+\n+  \/\/ the file descriptor for the listening socket\n+  static volatile int _listener;\n+\n+  static bool _atexit_registered;\n+\n+  \/\/ reads a request from the given connected socket\n+  static PosixAttachOperation* read_request(int s);\n+\n+ public:\n+  enum {\n+    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n+  };\n+  enum {\n+    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n+  };\n+\n+  static void set_path(char* path) {\n+    if (path == nullptr) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n+  \/\/ initialize the listener, returns 0 if okay\n+  static int init();\n+\n+  static char* path()                   { return _path; }\n+  static bool has_path()                { return _has_path; }\n+  static int listener()                 { return _listener; }\n+\n+  \/\/ write the given buffer to a socket\n+  static int write_fully(int s, char* buf, size_t len);\n+\n+  static PosixAttachOperation* dequeue();\n+};\n+\n+class PosixAttachOperation: public AttachOperation {\n+ private:\n+  \/\/ the connection to the client\n+  int _socket;\n+\n+ public:\n+  void complete(jint res, bufferedStream* st);\n+\n+  void set_socket(int s)                                { _socket = s; }\n+  int socket() const                                    { return _socket; }\n+\n+  PosixAttachOperation(char* name) : AttachOperation(name) {\n+    set_socket(-1);\n+  }\n+};\n+\n+\/\/ statics\n+char PosixAttachListener::_path[UNIX_PATH_MAX];\n+bool PosixAttachListener::_has_path;\n+volatile int PosixAttachListener::_listener = -1;\n+bool PosixAttachListener::_atexit_registered = false;\n+\n+\/\/ Supporting class to help split a buffer into individual components\n+class ArgumentIterator : public StackObj {\n+ private:\n+  char* _pos;\n+  char* _end;\n+ public:\n+  ArgumentIterator(char* arg_buffer, size_t arg_size) {\n+    _pos = arg_buffer;\n+    _end = _pos + arg_size - 1;\n+  }\n+  char* next() {\n+    if (*_pos == '\\0') {\n+      \/\/ advance the iterator if possible (null arguments)\n+      if (_pos < _end) {\n+        _pos += 1;\n+      }\n+      return nullptr;\n+    }\n+    char* res = _pos;\n+    char* next_pos = strchr(_pos, '\\0');\n+    if (next_pos < _end)  {\n+      next_pos++;\n+    }\n+    _pos = next_pos;\n+    return res;\n+  }\n+};\n+\n+\n+\/\/ atexit hook to stop listener and unlink the file that it is\n+\/\/ bound too.\n+extern \"C\" {\n+  static void listener_cleanup() {\n+    int s = PosixAttachListener::listener();\n+    if (s != -1) {\n+      PosixAttachListener::set_listener(-1);\n+      ::shutdown(s, SHUT_RDWR);\n+      ::close(s);\n+    }\n+    if (PosixAttachListener::has_path()) {\n+      ::unlink(PosixAttachListener::path());\n+      PosixAttachListener::set_path(nullptr);\n+    }\n+  }\n+}\n+\n+\/\/ Initialization - create a listener socket and bind it to a file\n+\n+int PosixAttachListener::init() {\n+  char path[UNIX_PATH_MAX];          \/\/ socket file\n+  char initial_path[UNIX_PATH_MAX];  \/\/ socket file during setup\n+  int listener;                      \/\/ listener socket (file descriptor)\n+\n+  static_assert(sizeof(off_t) == 8, \"Expected Large File Support in this file\");\n+\n+  \/\/ register function to cleanup\n+  if (!_atexit_registered) {\n+    _atexit_registered = true;\n+    ::atexit(listener_cleanup);\n+  }\n+\n+  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                   os::get_temp_directory(), os::current_process_id());\n+  if (n < (int)UNIX_PATH_MAX) {\n+    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n+  }\n+  if (n >= (int)UNIX_PATH_MAX) {\n+    return -1;\n+  }\n+\n+  \/\/ create the listener socket\n+  listener = ::socket(PF_UNIX, SOCK_STREAM, 0);\n+  if (listener == -1) {\n+    return -1;\n+  }\n+\n+  \/\/ bind socket\n+  struct sockaddr_un addr;\n+  memset((void *)&addr, 0, sizeof(addr));\n+  addr.sun_family = AF_UNIX;\n+  strcpy(addr.sun_path, initial_path);\n+  ::unlink(initial_path);\n+  int res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));\n+  if (res == -1) {\n+    ::close(listener);\n+    return -1;\n+  }\n+\n+  \/\/ put in listen mode, set permissions, and rename into place\n+  res = ::listen(listener, 5);\n+  if (res == 0) {\n+    RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);\n+    if (res == 0) {\n+      \/\/ make sure the file is owned by the effective user and effective group\n+      \/\/ e.g. the group could be inherited from the directory in case the s bit\n+      \/\/ is set. The default behavior on mac is that new files inherit the group\n+      \/\/ of the directory that they are created in.\n+      RESTARTABLE(::chown(initial_path, geteuid(), getegid()), res);\n+      if (res == 0) {\n+        res = ::rename(initial_path, path);\n+      }\n+    }\n+  }\n+  if (res == -1) {\n+    ::close(listener);\n+    ::unlink(initial_path);\n+    return -1;\n+  }\n+  set_path(path);\n+  set_listener(listener);\n+\n+  return 0;\n+}\n+\n+\/\/ Given a socket that is connected to a peer we read the request and\n+\/\/ create an AttachOperation. As the socket is blocking there is potential\n+\/\/ for a denial-of-service if the peer does not response. However this happens\n+\/\/ after the peer credentials have been checked and in the worst case it just\n+\/\/ means that the attach listener thread is blocked.\n+\/\/\n+PosixAttachOperation* PosixAttachListener::read_request(int s) {\n+  char ver_str[8];\n+  os::snprintf_checked(ver_str, sizeof(ver_str), \"%d\", ATTACH_PROTOCOL_VER);\n+\n+  \/\/ The request is a sequence of strings so we first figure out the\n+  \/\/ expected count and the maximum possible length of the request.\n+  \/\/ The request is:\n+  \/\/   <ver>0<cmd>0<arg>0<arg>0<arg>0\n+  \/\/ where <ver> is the protocol version (1), <cmd> is the command\n+  \/\/ name (\"load\", \"datadump\", ...), and <arg> is an argument\n+  int expected_str_count = 2 + AttachOperation::arg_count_max;\n+  const size_t max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n+    AttachOperation::arg_count_max*(AttachOperation::arg_length_max + 1);\n+\n+  char buf[max_len];\n+  int str_count = 0;\n+\n+  \/\/ Read until all (expected) strings have been read, the buffer is\n+  \/\/ full, or EOF.\n+\n+  size_t off = 0;\n+  size_t left = max_len;\n+\n+  do {\n+    ssize_t n;\n+    RESTARTABLE(read(s, buf+off, left), n);\n+    assert(n <= checked_cast<ssize_t>(left), \"buffer was too small, impossible!\");\n+    buf[max_len - 1] = '\\0';\n+    if (n == -1) {\n+      return nullptr;      \/\/ reset by peer or other error\n+    }\n+    if (n == 0) {\n+      break;\n+    }\n+    for (ssize_t i=0; i<n; i++) {\n+      if (buf[off+i] == 0) {\n+        \/\/ EOS found\n+        str_count++;\n+\n+        \/\/ The first string is <ver> so check it now to\n+        \/\/ check for protocol mismatch\n+        if (str_count == 1) {\n+          if ((strlen(buf) != strlen(ver_str)) ||\n+              (atoi(buf) != ATTACH_PROTOCOL_VER)) {\n+            char msg[32];\n+            os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", ATTACH_ERROR_BADVERSION);\n+            write_fully(s, msg, strlen(msg));\n+            return nullptr;\n+          }\n+        }\n+      }\n+    }\n+    off += n;\n+    left -= n;\n+  } while (left > 0 && str_count < expected_str_count);\n+\n+  if (str_count != expected_str_count) {\n+    return nullptr;        \/\/ incomplete request\n+  }\n+\n+  \/\/ parse request\n+\n+  ArgumentIterator args(buf, (max_len)-left);\n+\n+  \/\/ version already checked\n+  char* v = args.next();\n+\n+  char* name = args.next();\n+  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n+    return nullptr;\n+  }\n+\n+  PosixAttachOperation* op = new PosixAttachOperation(name);\n+\n+  for (int i=0; i<AttachOperation::arg_count_max; i++) {\n+    char* arg = args.next();\n+    if (arg == nullptr) {\n+      op->set_arg(i, nullptr);\n+    } else {\n+      if (strlen(arg) > AttachOperation::arg_length_max) {\n+        delete op;\n+        return nullptr;\n+      }\n+      op->set_arg(i, arg);\n+    }\n+  }\n+\n+  op->set_socket(s);\n+  return op;\n+}\n+\n+\/\/ Dequeue an operation\n+\/\/\n+\/\/ In the Linux and BSD implementations, there is only a single operation and\n+\/\/ clients cannot queue commands (except at the socket level).\n+\/\/\n+PosixAttachOperation* PosixAttachListener::dequeue() {\n+  for (;;) {\n+    int s;\n+\n+    \/\/ wait for client to connect\n+    struct sockaddr addr;\n+    socklen_t len = sizeof(addr);\n+    RESTARTABLE(::accept(listener(), &addr, &len), s);\n+    if (s == -1) {\n+      return nullptr;      \/\/ log a warning?\n+    }\n+\n+    \/\/ get the credentials of the peer and check the effective uid\/guid\n+#ifdef LINUX\n+    struct ucred cred_info;\n+    socklen_t optlen = sizeof(cred_info);\n+    if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void *)&cred_info, &optlen) ==\n+        -1) {\n+      log_debug(attach)(\"Failed to get socket option SO_PEERCRED\");\n+      ::close(s);\n+      continue;\n+    }\n+\n+    if (!os::Posix::matches_effective_uid_and_gid_or_root(cred_info.uid,\n+                                                          cred_info.gid)) {\n+      log_debug(attach)(\"euid\/egid check failed (%d\/%d vs %d\/%d)\",\n+                        cred_info.uid, cred_info.gid, geteuid(), getegid());\n+      ::close(s);\n+      continue;\n+    }\n+#endif\n+#ifdef BSD\n+    uid_t puid;\n+    gid_t pgid;\n+    if (::getpeereid(s, &puid, &pgid) != 0) {\n+      log_debug(attach)(\"Failed to get peer id\");\n+      ::close(s);\n+      continue;\n+    }\n+\n+    if (!os::Posix::matches_effective_uid_and_gid_or_root(puid, pgid)) {\n+      log_debug(attach)(\"euid\/egid check failed (%d\/%d vs %d\/%d)\", puid, pgid,\n+                        geteuid(), getegid());\n+      ::close(s);\n+      continue;\n+    }\n+#endif\n+\n+    \/\/ peer credential look okay so we read the request\n+    PosixAttachOperation* op = read_request(s);\n+    if (op == nullptr) {\n+      ::close(s);\n+      continue;\n+    } else {\n+      return op;\n+    }\n+  }\n+}\n+\n+\/\/ write the given buffer to the socket\n+int PosixAttachListener::write_fully(int s, char* buf, size_t len) {\n+  do {\n+    ssize_t n = ::write(s, buf, len);\n+    if (n == -1) {\n+      if (errno != EINTR) return -1;\n+    } else {\n+      buf += n;\n+      len -= n;\n+    }\n+  }\n+  while (len > 0);\n+  return 0;\n+}\n+\n+\/\/ Complete an operation by sending the operation result and any result\n+\/\/ output to the client. At this time the socket is in blocking mode so\n+\/\/ potentially we can block if there is a lot of data and the client is\n+\/\/ non-responsive. For most operations this is a non-issue because the\n+\/\/ default send buffer is sufficient to buffer everything. In the future\n+\/\/ if there are operations that involves a very big reply then it the\n+\/\/ socket could be made non-blocking and a timeout could be used.\n+\n+void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n+  JavaThread* thread = JavaThread::current();\n+  ThreadBlockInVM tbivm(thread);\n+\n+  \/\/ write operation result\n+  char msg[32];\n+  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n+  int rc = PosixAttachListener::write_fully(this->socket(), msg, strlen(msg));\n+\n+  \/\/ write any result data\n+  if (rc == 0) {\n+    PosixAttachListener::write_fully(this->socket(), (char*) st->base(), st->size());\n+    ::shutdown(this->socket(), 2);\n+  }\n+\n+  \/\/ done\n+  ::close(this->socket());\n+\n+  delete this;\n+}\n+\n+\n+\/\/ AttachListener functions\n+\n+AttachOperation* AttachListener::dequeue() {\n+  JavaThread* thread = JavaThread::current();\n+  ThreadBlockInVM tbivm(thread);\n+\n+  AttachOperation* op = PosixAttachListener::dequeue();\n+\n+  return op;\n+}\n+\n+\/\/ Performs initialization at vm startup\n+\/\/ For Linux and BSD we remove any stale .java_pid file which could cause\n+\/\/ an attaching process to think we are ready to receive on the\n+\/\/ domain socket before we are properly initialized\n+\n+void AttachListener::vm_start() {\n+  char fn[UNIX_PATH_MAX];\n+  struct stat st;\n+  int ret;\n+\n+  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+           os::get_temp_directory(), os::current_process_id());\n+  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n+\n+  RESTARTABLE(::stat(fn, &st), ret);\n+  if (ret == 0) {\n+    ret = ::unlink(fn);\n+    if (ret == -1) {\n+      log_debug(attach)(\"Failed to remove stale attach pid file at %s\", fn);\n+    }\n+  }\n+}\n+\n+int AttachListener::pd_init() {\n+  JavaThread* thread = JavaThread::current();\n+  ThreadBlockInVM tbivm(thread);\n+\n+  int ret_code = PosixAttachListener::init();\n+\n+  return ret_code;\n+}\n+\n+bool AttachListener::check_socket_file() {\n+  int ret;\n+  struct stat st;\n+  ret = stat(PosixAttachListener::path(), &st);\n+  if (ret == -1) { \/\/ need to restart attach listener.\n+    log_debug(attach)(\"Socket file %s does not exist - Restart Attach Listener\",\n+                      PosixAttachListener::path());\n+\n+    listener_cleanup();\n+\n+    \/\/ wait to terminate current attach listener instance...\n+    {\n+      \/\/ avoid deadlock if AttachListener thread is blocked at safepoint\n+      ThreadBlockInVM tbivm(JavaThread::current());\n+      while (AttachListener::transit_state(AL_INITIALIZING,\n+                                           AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n+        os::naked_yield();\n+      }\n+    }\n+    return is_init_trigger();\n+  }\n+  return false;\n+}\n+\n+\/\/ Attach Listener is started lazily except in the case when\n+\/\/ +ReduseSignalUsage is used\n+bool AttachListener::init_at_startup() {\n+  if (ReduceSignalUsage) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ If the file .attach_pid<pid> exists in the working directory\n+\/\/ or \/tmp then this is the trigger to start the attach mechanism\n+bool AttachListener::is_init_trigger() {\n+  if (init_at_startup() || is_initialized()) {\n+    return false;               \/\/ initialized at startup or already initialized\n+  }\n+  char fn[PATH_MAX + 1];\n+  int ret;\n+  struct stat st;\n+  os::snprintf_checked(fn, sizeof(fn), \".attach_pid%d\",\n+                       os::current_process_id());\n+  RESTARTABLE(::stat(fn, &st), ret);\n+  if (ret == -1) {\n+    log_trace(attach)(\"Failed to find attach file: %s, trying alternate\", fn);\n+    snprintf(fn, sizeof(fn), \"%s\/.attach_pid%d\", os::get_temp_directory(),\n+             os::current_process_id());\n+    RESTARTABLE(::stat(fn, &st), ret);\n+    if (ret == -1) {\n+      log_debug(attach)(\"Failed to find attach file: %s\", fn);\n+    }\n+  }\n+  if (ret == 0) {\n+    \/\/ simple check to avoid starting the attach mechanism when\n+    \/\/ a bogus non-root user creates the file\n+    if (os::Posix::matches_effective_uid_or_root(st.st_uid)) {\n+      init();\n+      log_trace(attach)(\"Attach triggered by %s\", fn);\n+      return true;\n+    } else {\n+      log_debug(attach)(\"File %s has wrong user id %d (vs %d). Attach is not triggered\", fn, st.st_uid, geteuid());\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ if VM aborts then remove listener\n+void AttachListener::abort() {\n+  listener_cleanup();\n+}\n+\n+void AttachListener::pd_data_dump() {\n+  os::signal_notify(SIGQUIT);\n+}\n+\n+void AttachListener::pd_detachall() {\n+  \/\/ do nothing for now\n+}\n+\n+#endif \/\/ !AIX\n+\n+#endif \/\/ INCLUDE_SERVICES\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":585,"deletions":0,"binary":false,"changes":585,"status":"added"},{"patch":"@@ -511,1 +511,1 @@\n-  st->print(\"%d\", sysconf(_SC_CHILD_MAX));\n+  st->print(\"%ld\", sysconf(_SC_CHILD_MAX));\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,5 @@\n+\/\/\n+\/\/ When a memory area is free (kept by the virtual memory manager) a\n+\/\/ single placeholder is covering that memory area. When memory is\n+\/\/ allocated from the manager the placeholder is split into granule\n+\/\/ sized placeholders to allow mapping operations on that granularity.\n@@ -55,3 +60,11 @@\n-    static void split_into_placeholder_granules(zoffset start, size_t size) {\n-      for (uintptr_t addr = untype(start); addr < untype(start) + size; addr += ZGranuleSize) {\n-        split_placeholder(to_zoffset(addr), ZGranuleSize);\n+    \/\/ Turn the single placeholder covering the memory area into granule\n+    \/\/ sized placeholders.\n+    static void split_into_granule_sized_placeholders(zoffset start, size_t size) {\n+      assert(size >= ZGranuleSize, \"Must be at least one granule\");\n+      assert(is_aligned(size, ZGranuleSize), \"Must be granule aligned\");\n+\n+      \/\/ Don't call split_placeholder on the last granule, since it is already\n+      \/\/ a placeholder and the system call would therefore fail.\n+      const size_t limit = size - ZGranuleSize;\n+      for (size_t offset = 0; offset < limit; offset += ZGranuleSize) {\n+        split_placeholder(start + offset, ZGranuleSize);\n@@ -64,0 +77,1 @@\n+      \/\/ Granule sized areas are already covered by a single placeholder\n@@ -69,0 +83,3 @@\n+    \/\/ Called when a memory area is returned to the memory manager but can't\n+    \/\/ be merged with an already existing area. Make sure this area is covered\n+    \/\/ by a single placeholder.\n@@ -71,0 +88,1 @@\n+\n@@ -74,0 +92,2 @@\n+    \/\/ Called when a complete memory area in the memory manager is allocated.\n+    \/\/ Create granule sized placeholders for the entire area.\n@@ -76,2 +96,2 @@\n-      \/\/ Don't try split the last granule - VirtualFree will fail\n-      split_into_placeholder_granules(area->start(), area->size() - ZGranuleSize);\n+\n+      split_into_granule_sized_placeholders(area->start(), area->size());\n@@ -80,0 +100,2 @@\n+    \/\/ Called when a memory area is allocated at the front of an exising memory area.\n+    \/\/ Turn the first part of the memory area into granule sized placeholders.\n@@ -81,0 +103,1 @@\n+      assert(area->size() > size, \"Must be larger than what we try to split out\");\n@@ -82,1 +105,6 @@\n-      split_into_placeholder_granules(area->start(), size);\n+\n+      \/\/ Split the area into two placeholders\n+      split_placeholder(area->start(), size);\n+\n+      \/\/ Split the first part into granule sized placeholders\n+      split_into_granule_sized_placeholders(area->start(), size);\n@@ -85,0 +113,2 @@\n+    \/\/ Called when a memory area is allocated at the end of an existing memory area.\n+    \/\/ Turn the second part of the memory area into granule sized placeholders.\n@@ -86,0 +116,1 @@\n+      assert(area->size() > size, \"Must be larger than what we try to split out\");\n@@ -87,2 +118,7 @@\n-      \/\/ Don't try split the last granule - VirtualFree will fail\n-      split_into_placeholder_granules(to_zoffset(untype(area->end()) - size), size - ZGranuleSize);\n+\n+      \/\/ Split the area into two placeholders\n+      const zoffset start = to_zoffset(area->end() - size);\n+      split_placeholder(start, size);\n+\n+      \/\/ Split the second part into granule sized placeholders\n+      split_into_granule_sized_placeholders(start, size);\n@@ -91,0 +127,2 @@\n+    \/\/ Called when freeing a memory area and it can be merged at the start of an\n+    \/\/ existing area. Coalesce the underlying placeholders into one.\n@@ -93,1 +131,3 @@\n-      coalesce_into_one_placeholder(to_zoffset(untype(area->start()) - size), area->size() + size);\n+\n+      const zoffset start = area->start() - size;\n+      coalesce_into_one_placeholder(start, area->size() + size);\n@@ -96,0 +136,2 @@\n+    \/\/ Called when freeing a memory area and it can be merged at the end of an\n+    \/\/ existing area. Coalesce the underlying placeholders into one.\n@@ -98,0 +140,1 @@\n+\n","filename":"src\/hotspot\/os\/windows\/gc\/z\/zVirtualMemory_windows.cpp","additions":52,"deletions":9,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2798,2 +2798,2 @@\n-      bool is_unsafe_arraycopy = (in_native || in_java) && UnsafeCopyMemory::contains_pc(pc);\n-      if (((in_vm || in_native || is_unsafe_arraycopy) && thread->doing_unsafe_access()) ||\n+      bool is_unsafe_memory_access = (in_native || in_java) && UnsafeMemoryAccess::contains_pc(pc);\n+      if (((in_vm || in_native || is_unsafe_memory_access) && thread->doing_unsafe_access()) ||\n@@ -2802,2 +2802,2 @@\n-        if (is_unsafe_arraycopy) {\n-          next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+        if (is_unsafe_memory_access) {\n+          next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -264,1 +264,1 @@\n-          tty->print_cr(\"trap: ic_miss_check at \" INTPTR_FORMAT \" (SIGTRAP)\", pc);\n+          tty->print_cr(\"trap: ic_miss_check at \" INTPTR_FORMAT \" (SIGTRAP)\", p2i(pc));\n@@ -274,1 +274,1 @@\n-          tty->print_cr(\"trap: null_check at \" INTPTR_FORMAT \" (SIGTRAP)\", pc);\n+          tty->print_cr(\"trap: null_check at \" INTPTR_FORMAT \" (SIGTRAP)\", p2i(pc));\n@@ -285,1 +285,1 @@\n-          tty->print_cr(\"trap: null_check at \" INTPTR_FORMAT \" (SIGSEGV)\", pc);\n+          tty->print_cr(\"trap: null_check at \" INTPTR_FORMAT \" (SIGSEGV)\", p2i(pc));\n@@ -295,1 +295,1 @@\n-          tty->print_cr(\"trap: range_check at \" INTPTR_FORMAT \" (SIGTRAP)\", pc);\n+          tty->print_cr(\"trap: range_check at \" INTPTR_FORMAT \" (SIGTRAP)\", p2i(pc));\n@@ -343,2 +343,2 @@\n-        bool is_unsafe_arraycopy = (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc));\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_memory_access = (thread->doing_unsafe_access() && UnsafeMemoryAccess::contains_pc(pc));\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_memory_access) {\n@@ -346,2 +346,2 @@\n-          if (is_unsafe_arraycopy) {\n-            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+          if (is_unsafe_memory_access) {\n+            next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n@@ -371,2 +371,2 @@\n-        if (UnsafeCopyMemory::contains_pc(pc)) {\n-          next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+        if (UnsafeMemoryAccess::contains_pc(pc)) {\n+          next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n@@ -438,3 +438,3 @@\n-  st->print(\"pc =\" INTPTR_FORMAT \"  \", uc->uc_mcontext.jmp_context.iar);\n-  st->print(\"lr =\" INTPTR_FORMAT \"  \", uc->uc_mcontext.jmp_context.lr);\n-  st->print(\"ctr=\" INTPTR_FORMAT \"  \", uc->uc_mcontext.jmp_context.ctr);\n+  st->print(\"pc =\" INTPTR_FORMAT \"  \", (unsigned long)uc->uc_mcontext.jmp_context.iar);\n+  st->print(\"lr =\" INTPTR_FORMAT \"  \", (unsigned long)uc->uc_mcontext.jmp_context.lr);\n+  st->print(\"ctr=\" INTPTR_FORMAT \"  \", (unsigned long)uc->uc_mcontext.jmp_context.ctr);\n@@ -443,1 +443,1 @@\n-    st->print(\"r%-2d=\" INTPTR_FORMAT \"  \", i, uc->uc_mcontext.jmp_context.gpr[i]);\n+    st->print(\"r%-2d=\" INTPTR_FORMAT \"  \", i, (unsigned long)uc->uc_mcontext.jmp_context.gpr[i]);\n@@ -467,1 +467,1 @@\n-  st->print_cr(\"Decoded instructions: (pc=\" PTR_FORMAT \")\", pc);\n+  st->print_cr(\"Decoded instructions: (pc=\" PTR_FORMAT \")\", p2i(pc));\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -260,2 +260,2 @@\n-        bool is_unsafe_arraycopy = (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc));\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_memory_access = (thread->doing_unsafe_access() && UnsafeMemoryAccess::contains_pc(pc));\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_memory_access) {\n@@ -263,2 +263,2 @@\n-          if (is_unsafe_arraycopy) {\n-            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+          if (is_unsafe_memory_access) {\n+            next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n@@ -302,2 +302,2 @@\n-      if (UnsafeCopyMemory::contains_pc(pc)) {\n-        next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+      if (UnsafeMemoryAccess::contains_pc(pc)) {\n+        next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -444,2 +444,2 @@\n-        bool is_unsafe_arraycopy = thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc);\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_memory_access = thread->doing_unsafe_access() && UnsafeMemoryAccess::contains_pc(pc);\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_memory_access) {\n@@ -447,2 +447,2 @@\n-          if (is_unsafe_arraycopy) {\n-            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+          if (is_unsafe_memory_access) {\n+            next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n@@ -452,3 +452,1 @@\n-      }\n-      else\n-\n+      } else\n@@ -456,1 +454,1 @@\n-      if (sig == SIGFPE  &&\n+      if (sig == SIGFPE &&\n@@ -526,2 +524,2 @@\n-        if (UnsafeCopyMemory::contains_pc(pc)) {\n-          next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+        if (UnsafeMemoryAccess::contains_pc(pc)) {\n+          next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -243,2 +243,2 @@\n-        bool is_unsafe_arraycopy = (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc));\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_memory_access = (thread->doing_unsafe_access() && UnsafeMemoryAccess::contains_pc(pc));\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_memory_access) {\n@@ -246,2 +246,2 @@\n-          if (is_unsafe_arraycopy) {\n-            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+          if (is_unsafe_memory_access) {\n+            next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n@@ -289,2 +289,2 @@\n-      if (UnsafeCopyMemory::contains_pc(pc)) {\n-        next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+      if (UnsafeMemoryAccess::contains_pc(pc)) {\n+        next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -327,1 +327,3 @@\n-        if ((nm != nullptr && nm->has_unsafe_access()) || (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc))) {\n+        if ((nm != nullptr && nm->has_unsafe_access()) ||\n+            (thread->doing_unsafe_access() &&\n+             UnsafeMemoryAccess::contains_pc(pc))) {\n@@ -332,6 +334,9 @@\n-          \/\/ Determination of interpreter\/vtable stub\/compiled code null exception\n-          CodeBlob* cb = CodeCache::find_blob(pc);\n-          if (cb != nullptr) {\n-            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);\n-          }\n-      } else if (sig == SIGILL && *(int *)pc == NativeInstruction::not_entrant_illegal_instruction) {\n+        \/\/ Determination of interpreter\/vtable stub\/compiled code null exception\n+        CodeBlob* cb = CodeCache::find_blob(pc);\n+        if (cb != nullptr) {\n+          stub = SharedRuntime::continuation_for_implicit_exception(\n+              thread, pc, SharedRuntime::IMPLICIT_NULL);\n+        }\n+      } else if (sig == SIGILL &&\n+                 *(int*)pc ==\n+                     NativeInstruction::not_entrant_illegal_instruction) {\n@@ -362,2 +367,2 @@\n-    if (UnsafeCopyMemory::contains_pc(pc)) {\n-      next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+    if (UnsafeMemoryAccess::contains_pc(pc)) {\n+      next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -257,1 +257,1 @@\n-      else if ((sig == USE_POLL_BIT_ONLY ? SIGTRAP : SIGSEGV) &&\n+      else if ((sig == (USE_POLL_BIT_ONLY ? SIGTRAP : SIGSEGV)) &&\n@@ -358,2 +358,2 @@\n-        bool is_unsafe_arraycopy = (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc));\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_memory_access = (thread->doing_unsafe_access() && UnsafeMemoryAccess::contains_pc(pc));\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_memory_access) {\n@@ -361,2 +361,2 @@\n-          if (is_unsafe_arraycopy) {\n-            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+          if (is_unsafe_memory_access) {\n+            next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n@@ -382,2 +382,2 @@\n-        if (UnsafeCopyMemory::contains_pc(pc)) {\n-          next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+        if (UnsafeMemoryAccess::contains_pc(pc)) {\n+          next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#elif (__GNUC__ > 13) || ((__GNUC__ == 13) && (__GNUC_MINOR__ >= 2))\n+#elif (__GNUC__ > 13) || ((__GNUC__ == 13) && (__GNUC_MINOR__ > 2))\n@@ -42,6 +42,0 @@\n-#if defined(__clang_major__)\n-#define CORRECT_COMPILER_ATOMIC_SUPPORT\n-#elif defined(__GNUC__) && (__riscv_xlen <= 32 || __GNUC__ > 13)\n-#define CORRECT_COMPILER_ATOMIC_SUPPORT\n-#endif\n-\n@@ -123,1 +117,1 @@\n-#ifndef CORRECT_COMPILER_ATOMIC_SUPPORT\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n@@ -125,1 +119,1 @@\n-\/\/ in GCC 13 and lower when using with 32-bit unsigned integers on RV64,\n+\/\/ in GCC 13.2 and lower when using with 32-bit unsigned integers on RV64,\n@@ -195,5 +189,1 @@\n-  STATIC_ASSERT(byte_size >= 4);\n-#endif\n-\n-#ifndef CORRECT_COMPILER_ATOMIC_SUPPORT\n-  STATIC_ASSERT(byte_size != 4);\n+  STATIC_ASSERT(byte_size > 4);\n@@ -238,1 +228,0 @@\n-#undef CORRECT_COMPILER_ATOMIC_SUPPORT\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/atomic_linux_riscv.hpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -233,2 +233,2 @@\n-        bool is_unsafe_arraycopy = (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc));\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_memory_access = (thread->doing_unsafe_access() && UnsafeMemoryAccess::contains_pc(pc));\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_memory_access) {\n@@ -236,2 +236,2 @@\n-          if (is_unsafe_arraycopy) {\n-            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+          if (is_unsafe_memory_access) {\n+            next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n@@ -275,2 +275,2 @@\n-      if (UnsafeCopyMemory::contains_pc(pc)) {\n-        next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+      if (UnsafeMemoryAccess::contains_pc(pc)) {\n+        next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -263,2 +263,2 @@\n-        bool is_unsafe_arraycopy = thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc);\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_memory_access = thread->doing_unsafe_access() && UnsafeMemoryAccess::contains_pc(pc);\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_memory_access) {\n@@ -266,2 +266,2 @@\n-          if (is_unsafe_arraycopy) {\n-            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+          if (is_unsafe_memory_access) {\n+            next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n@@ -271,3 +271,1 @@\n-      }\n-      else\n-\n+      } else\n@@ -275,1 +273,1 @@\n-      if (sig == SIGFPE  &&\n+      if (sig == SIGFPE &&\n@@ -320,2 +318,2 @@\n-        if (UnsafeCopyMemory::contains_pc(pc)) {\n-          next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+        if (UnsafeMemoryAccess::contains_pc(pc)) {\n+          next_pc = UnsafeMemoryAccess::page_error_continue_pc(pc);\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2899,8 +2899,0 @@\n-  if (!inst._is_postalloc_expand) {\n-    \/\/ Define a MacroAssembler instance for use by the encoding.  The\n-    \/\/ name is chosen to match the __ idiom used for assembly in other\n-    \/\/ parts of hotspot and assumes the existence of the standard\n-    \/\/ #define __ _masm.\n-    encoding->add_code(\"    C2_MacroAssembler _masm(&cbuf);\\n\");\n-  }\n-\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1905,1 +1905,1 @@\n-\/\/ (1) void  ___Node::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+\/\/ (1) void  ___Node::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -2304,1 +2304,1 @@\n-        fprintf( _fp, \"emit_%s(cbuf, \", d32_hi_lo );\n+        fprintf( _fp, \"emit_%s(masm, \", d32_hi_lo );\n@@ -2318,1 +2318,1 @@\n-        fprintf(_fp,\"emit_%s_reloc(cbuf, \", d32_hi_lo );\n+        fprintf(_fp,\"emit_%s_reloc(masm, \", d32_hi_lo );\n@@ -2325,1 +2325,1 @@\n-        fprintf(_fp,\"  emit_%s(cbuf, \", d32_hi_lo);\n+        fprintf(_fp,\"  emit_%s(masm, \", d32_hi_lo);\n@@ -2331,1 +2331,1 @@\n-      fprintf(_fp,\"emit_d16(cbuf, \");\n+      fprintf(_fp,\"emit_d16(masm, \");\n@@ -2337,1 +2337,1 @@\n-      fprintf(_fp,\"emit_d8(cbuf, \");\n+      fprintf(_fp,\"emit_d8(masm, \");\n@@ -2678,1 +2678,1 @@\n-  fprintf(fp, \"void %sNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\\n\", inst._ident);\n+  fprintf(fp, \"void %sNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\\n\", inst._ident);\n@@ -2688,3 +2688,0 @@\n-  \/\/ Save current instruction's starting address (helps with relocation).\n-  fprintf(fp, \"  cbuf.set_insts_mark();\\n\");\n-\n@@ -2693,1 +2690,1 @@\n-    fprintf(fp, \"  ra_->C->output()->constant_table().fill_jump_table(cbuf, (MachConstantNode*) this, _index2label);\\n\");\n+    fprintf(fp, \"  ra_->C->output()->constant_table().fill_jump_table(masm, (MachConstantNode*) this, _index2label);\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1632,1 +1632,1 @@\n-        fprintf(fp,\"  virtual void           emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\\n\");\n+        fprintf(fp,\"  virtual void           emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,1 +230,2 @@\n-  \/\/ Instruction boundaries (required when emitting relocatable values).\n+  \/\/ Mark instruction boundaries, this is required when emitting relocatable values.\n+  \/\/ Basically, all instructions that directly or indirectly use Assembler::emit_data* methods.\n@@ -369,0 +370,1 @@\n+  address       begin()        const   { return code_section()->start(); }\n@@ -377,4 +379,5 @@\n-  address       inst_mark() const { return code_section()->mark();       }\n-  void      set_inst_mark()       {        code_section()->set_mark();   }\n-  void    clear_inst_mark()       {        code_section()->clear_mark(); }\n-\n+  address       inst_mark() const         { return code_section()->mark();          }\n+  void      set_inst_mark()               {        code_section()->set_mark();      }\n+  void      set_inst_mark(address addr)   {        code_section()->set_mark(addr);  }\n+  void    clear_inst_mark()               {        code_section()->clear_mark();    }\n+  void set_inst_end(address addr)         {        code_section()->set_end(addr);   }\n@@ -392,0 +395,6 @@\n+  void relocate(address addr, relocInfo::relocType rtype, int format = 0) {\n+    code_section()->relocate(addr, rtype, format);\n+  }\n+  void relocate(address addr, RelocationHolder const& rspec, int format = 0) {\n+    code_section()->relocate(addr, rspec, format);\n+  }\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1559,2 +1559,1 @@\n-  if (RegisterFinalizersAtInit &&\n-      method()->intrinsic_id() == vmIntrinsics::_Object_init) {\n+  if (method()->intrinsic_id() == vmIntrinsics::_Object_init) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -3219,1 +3220,1 @@\n-    if (_method->has_option_value(CompileCommand::CompileThresholdScaling, scale)) {\n+    if (_method->has_option_value(CompileCommandEnum::CompileThresholdScaling, scale)) {\n@@ -3260,1 +3261,1 @@\n-  if (_method->has_option_value(CompileCommand::CompileThresholdScaling, scale)) {\n+  if (_method->has_option_value(CompileCommandEnum::CompileThresholdScaling, scale)) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1062,2 +1062,1 @@\n-        int indy_index = pool->decode_invokedynamic_index(index);\n-        appendix = Handle(current, pool->cache()->set_dynamic_call(info, indy_index));\n+        appendix = Handle(current, pool->cache()->set_dynamic_call(info, index));\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"jvm.h\"\n@@ -79,0 +80,1 @@\n+  src_info->set_id(_objs->length());\n@@ -96,0 +98,1 @@\n+  src_info->set_has_embedded_pointer();\n@@ -161,0 +164,2 @@\n+  _rw_ptrmap(mtClassShared),\n+  _ro_ptrmap(mtClassShared),\n@@ -171,1 +176,1 @@\n-\n+  _entropy_seed = 0x12345678;\n@@ -191,0 +196,10 @@\n+\/\/ Returns a deterministic sequence of pseudo random numbers. The main purpose is NOT\n+\/\/ for randomness but to get good entropy for the identity_hash() of archived Symbols,\n+\/\/ while keeping the contents of static CDS archives deterministic to ensure\n+\/\/ reproducibility of JDK builds.\n+int ArchiveBuilder::entropy() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"needed to ensure deterministic sequence\");\n+  _entropy_seed = os::next_random(_entropy_seed);\n+  return static_cast<int>(_entropy_seed);\n+}\n+\n@@ -579,0 +594,20 @@\n+\/\/ The objects that have embedded pointers will sink\n+\/\/ towards the end of the list. This ensures we have a maximum\n+\/\/ number of leading zero bits in the relocation bitmap.\n+int ArchiveBuilder::compare_src_objs(SourceObjInfo** a, SourceObjInfo** b) {\n+  if ((*a)->has_embedded_pointer() && !(*b)->has_embedded_pointer()) {\n+    return 1;\n+  } else if (!(*a)->has_embedded_pointer() && (*b)->has_embedded_pointer()) {\n+    return -1;\n+  } else {\n+    \/\/ This is necessary to keep the sorting order stable. Otherwise the\n+    \/\/ archive's contents may not be deterministic.\n+    return (*a)->id() - (*b)->id();\n+  }\n+}\n+\n+void ArchiveBuilder::sort_metadata_objs() {\n+  _rw_src_objs.objs()->sort(compare_src_objs);\n+  _ro_src_objs.objs()->sort(compare_src_objs);\n+}\n+\n@@ -1278,0 +1313,3 @@\n+  \/\/ Split pointer map into read-write and read-only bitmaps\n+  ArchivePtrMarker::initialize_rw_ro_maps(&_rw_ptrmap, &_ro_ptrmap);\n+\n@@ -1279,1 +1317,1 @@\n-  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), heap_info,\n+  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::rw_ptrmap(), ArchivePtrMarker::ro_ptrmap(), heap_info,\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,0 +129,1 @@\n+    bool _has_embedded_pointer;\n@@ -131,0 +132,2 @@\n+    int _id; \/\/ Each object has a unique serial ID, starting from zero. The ID is assigned\n+             \/\/ when the object is added into _source_objs.\n@@ -136,2 +139,2 @@\n-      _ptrmap_start(0), _ptrmap_end(0), _read_only(read_only), _follow_mode(follow_mode),\n-      _size_in_bytes(ref->size() * BytesPerWord), _msotype(ref->msotype()),\n+      _ptrmap_start(0), _ptrmap_end(0), _read_only(read_only), _has_embedded_pointer(false), _follow_mode(follow_mode),\n+      _size_in_bytes(ref->size() * BytesPerWord), _id(0), _msotype(ref->msotype()),\n@@ -167,0 +170,2 @@\n+    bool has_embedded_pointer() const { return _has_embedded_pointer; }\n+    void set_has_embedded_pointer()   { _has_embedded_pointer = true; }\n@@ -168,0 +173,2 @@\n+    int id()              const    { return _id; }\n+    void set_id(int i)             { _id = i; }\n@@ -207,1 +214,8 @@\n-  CHeapBitMap _ptrmap;    \/\/ bitmap used by ArchivePtrMarker\n+\n+  \/\/ Combined bitmap to track pointers in both RW and RO regions. This is updated\n+  \/\/ as objects are copied into RW and RO.\n+  CHeapBitMap _ptrmap;\n+\n+  \/\/ _ptrmap is split into these two bitmaps which are written into the archive.\n+  CHeapBitMap _rw_ptrmap;   \/\/ marks pointers in the RW region\n+  CHeapBitMap _ro_ptrmap;   \/\/ marks pointers in the RO region\n@@ -215,0 +229,1 @@\n+  unsigned int _entropy_seed;\n@@ -337,0 +352,1 @@\n+  int entropy();\n@@ -378,0 +394,2 @@\n+  static int compare_src_objs(SourceObjInfo** a, SourceObjInfo** b);\n+  void sort_metadata_objs();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-    BitMapView bm = r->ptrmap_view();\n+    BitMapView bm = FileMapInfo::current_info()->ptrmap_view(MetaspaceShared::hp);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+CHeapBitMap* ArchivePtrMarker::_rw_ptrmap = nullptr;\n+CHeapBitMap* ArchivePtrMarker::_ro_ptrmap = nullptr;\n@@ -55,0 +57,2 @@\n+  assert(_rw_ptrmap == nullptr, \"initialize only once\");\n+  assert(_ro_ptrmap == nullptr, \"initialize only once\");\n@@ -70,0 +74,31 @@\n+void ArchivePtrMarker::initialize_rw_ro_maps(CHeapBitMap* rw_ptrmap, CHeapBitMap* ro_ptrmap) {\n+  address* rw_bottom = (address*)ArchiveBuilder::current()->rw_region()->base();\n+  address* ro_bottom = (address*)ArchiveBuilder::current()->ro_region()->base();\n+\n+  _rw_ptrmap = rw_ptrmap;\n+  _ro_ptrmap = ro_ptrmap;\n+\n+  size_t rw_size = ArchiveBuilder::current()->rw_region()->used() \/ sizeof(address);\n+  size_t ro_size = ArchiveBuilder::current()->ro_region()->used() \/ sizeof(address);\n+  \/\/ ro_start is the first bit in _ptrmap that covers the pointer that would sit at ro_bottom.\n+  \/\/ E.g., if rw_bottom = (address*)100\n+  \/\/          ro_bottom = (address*)116\n+  \/\/       then for 64-bit platform:\n+  \/\/          ro_start = ro_bottom - rw_bottom = (116 - 100) \/ sizeof(address) = 2;\n+  size_t ro_start = ro_bottom - rw_bottom;\n+\n+  \/\/ Note: ptrmap is big enough only to cover the last pointer in ro_region.\n+  \/\/ See ArchivePtrMarker::compact()\n+  _rw_ptrmap->initialize(rw_size);\n+  _ro_ptrmap->initialize(_ptrmap->size() - ro_start);\n+\n+  for (size_t rw_bit = 0; rw_bit < _rw_ptrmap->size(); rw_bit++) {\n+    _rw_ptrmap->at_put(rw_bit, _ptrmap->at(rw_bit));\n+  }\n+\n+  for(size_t ro_bit = ro_start; ro_bit < _ptrmap->size(); ro_bit++) {\n+    _ro_ptrmap->at_put(ro_bit-ro_start, _ptrmap->at(ro_bit));\n+  }\n+  assert(_ptrmap->size() - ro_start == _ro_ptrmap->size(), \"must be\");\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+  static CHeapBitMap*  _rw_ptrmap;\n+  static CHeapBitMap*  _ro_ptrmap;\n@@ -56,0 +58,1 @@\n+  static void initialize_rw_ro_maps(CHeapBitMap* rw_ptrmap, CHeapBitMap* ro_ptrmap);\n@@ -76,0 +79,8 @@\n+  static CHeapBitMap* rw_ptrmap() {\n+    return _rw_ptrmap;\n+  }\n+\n+  static CHeapBitMap* ro_ptrmap() {\n+    return _ro_ptrmap;\n+  }\n+\n@@ -78,0 +89,2 @@\n+    _rw_ptrmap = nullptr;\n+    _ro_ptrmap = nullptr;\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -594,1 +594,1 @@\n-                                       ConstantPool::encode_invokedynamic_index(indy_index),\n+                                       indy_index,\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+  _use_secondary_supers_table = UseSecondarySupersTable;\n@@ -277,0 +278,1 @@\n+  st->print_cr(\"- use_secondary_supers_table:     %d\", _use_secondary_supers_table);\n@@ -294,0 +296,2 @@\n+  st->print_cr(\"- _rw_ptrmap_start_pos:           \" SIZE_FORMAT, _rw_ptrmap_start_pos);\n+  st->print_cr(\"- _ro_ptrmap_start_pos:           \" SIZE_FORMAT, _ro_ptrmap_start_pos);\n@@ -297,1 +301,0 @@\n-  st->print_cr(\"- ptrmap_size_in_bits:            \" SIZE_FORMAT, _ptrmap_size_in_bits);\n@@ -1456,16 +1459,0 @@\n-BitMapView FileMapRegion::bitmap_view(bool is_oopmap) {\n-  char* bitmap_base = FileMapInfo::current_info()->map_bitmap_region();\n-  bitmap_base += is_oopmap ? _oopmap_offset : _ptrmap_offset;\n-  size_t size_in_bits = is_oopmap ? _oopmap_size_in_bits : _ptrmap_size_in_bits;\n-  return BitMapView((BitMap::bm_word_t*)(bitmap_base), size_in_bits);\n-}\n-\n-BitMapView FileMapRegion::oopmap_view() {\n-  return bitmap_view(true);\n-}\n-\n-BitMapView FileMapRegion::ptrmap_view() {\n-  assert(has_ptrmap(), \"must be\");\n-  return bitmap_view(false);\n-}\n-\n@@ -1500,0 +1487,21 @@\n+BitMapView FileMapInfo::bitmap_view(int region_index, bool is_oopmap) {\n+  FileMapRegion* r = region_at(region_index);\n+  char* bitmap_base = is_static() ? FileMapInfo::current_info()->map_bitmap_region() : FileMapInfo::dynamic_info()->map_bitmap_region();\n+  bitmap_base += is_oopmap ? r->oopmap_offset() : r->ptrmap_offset();\n+  size_t size_in_bits = is_oopmap ? r->oopmap_size_in_bits() : r->ptrmap_size_in_bits();\n+\n+  log_debug(cds, reloc)(\"mapped %s relocation %smap @ \" INTPTR_FORMAT \" (\" SIZE_FORMAT \" bits)\",\n+                        region_name(region_index), is_oopmap ? \"oop\" : \"ptr\",\n+                        p2i(bitmap_base), size_in_bits);\n+\n+  return BitMapView((BitMap::bm_word_t*)(bitmap_base), size_in_bits);\n+}\n+\n+BitMapView FileMapInfo::oopmap_view(int region_index) {\n+    return bitmap_view(region_index, \/*is_oopmap*\/true);\n+  }\n+\n+BitMapView FileMapInfo::ptrmap_view(int region_index) {\n+  return bitmap_view(region_index, \/*is_oopmap*\/false);\n+}\n+\n@@ -1513,0 +1521,2 @@\n+  st->print_cr(\"- ptrmap_offset:                  \" SIZE_FORMAT_X, _ptrmap_offset);\n+  st->print_cr(\"- ptrmap_size_in_bits:            \" SIZE_FORMAT, _ptrmap_size_in_bits);\n@@ -1575,1 +1585,1 @@\n-  size_t old_size = map->size_in_bytes();\n+  size_t old_size = map->size();\n@@ -1584,2 +1594,1 @@\n-\n-  assert(map->size_in_bytes() < old_size, \"Map size should have decreased\");\n+  assert(map->size() <= old_size, \"sanity\");\n@@ -1589,1 +1598,1 @@\n-char* FileMapInfo::write_bitmap_region(const CHeapBitMap* ptrmap, ArchiveHeapInfo* heap_info,\n+char* FileMapInfo::write_bitmap_region(CHeapBitMap* rw_ptrmap, CHeapBitMap* ro_ptrmap, ArchiveHeapInfo* heap_info,\n@@ -1591,1 +1600,5 @@\n-  size_in_bytes = ptrmap->size_in_bytes();\n+  size_t removed_rw_zeros = remove_bitmap_leading_zeros(rw_ptrmap);\n+  size_t removed_ro_zeros = remove_bitmap_leading_zeros(ro_ptrmap);\n+  header()->set_rw_ptrmap_start_pos(removed_rw_zeros);\n+  header()->set_ro_ptrmap_start_pos(removed_ro_zeros);\n+  size_in_bytes = rw_ptrmap->size_in_bytes() + ro_ptrmap->size_in_bytes();\n@@ -1605,2 +1618,3 @@\n-  \/\/ The bitmap region contains up to 3 parts:\n-  \/\/ ptrmap:              metaspace pointers inside the ro\/rw regions\n+  \/\/ The bitmap region contains up to 4 parts:\n+  \/\/ rw_ptrmap:           metaspace pointers inside the read-write region\n+  \/\/ ro_ptrmap:           metaspace pointers inside the read-only region\n@@ -1611,2 +1625,6 @@\n-  written = write_bitmap(ptrmap, buffer, written);\n-  header()->set_ptrmap_size_in_bits(ptrmap->size());\n+\n+  region_at(MetaspaceShared::rw)->init_ptrmap(0, rw_ptrmap->size());\n+  written = write_bitmap(rw_ptrmap, buffer, written);\n+\n+  region_at(MetaspaceShared::ro)->init_ptrmap(written, ro_ptrmap->size());\n+  written = write_bitmap(ro_ptrmap, buffer, written);\n@@ -1907,3 +1925,5 @@\n-    size_t ptrmap_size_in_bits = header()->ptrmap_size_in_bits();\n-    log_debug(cds, reloc)(\"mapped relocation bitmap @ \" INTPTR_FORMAT \" (\" SIZE_FORMAT \" bits)\",\n-                          p2i(bitmap_base), ptrmap_size_in_bits);\n+    BitMapView rw_ptrmap = ptrmap_view(MetaspaceShared::rw);\n+    BitMapView ro_ptrmap = ptrmap_view(MetaspaceShared::ro);\n+\n+    FileMapRegion* rw_region = first_core_region();\n+    FileMapRegion* ro_region = last_core_region();\n@@ -1911,1 +1931,3 @@\n-    BitMapView ptrmap((BitMap::bm_word_t*)bitmap_base, ptrmap_size_in_bits);\n+    \/\/ Patch all pointers inside the RW region\n+    address rw_patch_base = (address)rw_region->mapped_base();\n+    address rw_patch_end  = (address)rw_region->mapped_end();\n@@ -1913,3 +1935,3 @@\n-    \/\/ Patch all pointers in the mapped region that are marked by ptrmap.\n-    address patch_base = (address)mapped_base();\n-    address patch_end  = (address)mapped_end();\n+    \/\/ Patch all pointers inside the RO region\n+    address ro_patch_base = (address)ro_region->mapped_base();\n+    address ro_patch_end  = (address)ro_region->mapped_end();\n@@ -1928,1 +1950,3 @@\n-    SharedDataRelocator patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,\n+    SharedDataRelocator rw_patcher((address*)rw_patch_base + header()->rw_ptrmap_start_pos(), (address*)rw_patch_end, valid_old_base, valid_old_end,\n+                                valid_new_base, valid_new_end, addr_delta);\n+    SharedDataRelocator ro_patcher((address*)ro_patch_base + header()->ro_ptrmap_start_pos(), (address*)ro_patch_end, valid_old_base, valid_old_end,\n@@ -1930,1 +1954,2 @@\n-    ptrmap.iterate(&patcher);\n+    rw_ptrmap.iterate(&rw_patcher);\n+    ro_ptrmap.iterate(&ro_patcher);\n@@ -2423,0 +2448,5 @@\n+  if (! _use_secondary_supers_table && UseSecondarySupersTable) {\n+    log_warning(cds)(\"The shared archive was created without UseSecondarySupersTable.\");\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":65,"deletions":35,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-  BitMapView bitmap_view(bool is_oopmap);\n@@ -161,0 +160,2 @@\n+  size_t ptrmap_offset()            const { return _ptrmap_offset; }\n+  size_t ptrmap_size_in_bits()      const { return _ptrmap_size_in_bits; }\n@@ -170,2 +171,0 @@\n-  BitMapView oopmap_view();\n-  BitMapView ptrmap_view();\n@@ -195,0 +194,1 @@\n+  bool    _use_secondary_supers_table;            \/\/ save the flag UseSecondarySupersTable\n@@ -228,1 +228,0 @@\n-  size_t _ptrmap_size_in_bits;          \/\/ Size of pointer relocation bitmap\n@@ -233,0 +232,2 @@\n+  size_t _rw_ptrmap_start_pos;          \/\/ The first bit in the ptrmap corresponds to this position in the rw region\n+  size_t _ro_ptrmap_start_pos;          \/\/ The first bit in the ptrmap corresponds to this position in the ro region\n@@ -270,1 +271,0 @@\n-  size_t ptrmap_size_in_bits()             const { return _ptrmap_size_in_bits; }\n@@ -274,2 +274,4 @@\n-  size_t heap_oopmap_start_pos()           const { return _heap_oopmap_start_pos;}\n-  size_t heap_ptrmap_start_pos()           const { return _heap_ptrmap_start_pos;}\n+  size_t heap_oopmap_start_pos()           const { return _heap_oopmap_start_pos; }\n+  size_t heap_ptrmap_start_pos()           const { return _heap_ptrmap_start_pos; }\n+  size_t rw_ptrmap_start_pos()             const { return _rw_ptrmap_start_pos; }\n+  size_t ro_ptrmap_start_pos()             const { return _ro_ptrmap_start_pos; }\n@@ -285,1 +287,0 @@\n-  void set_ptrmap_size_in_bits(size_t s)         { _ptrmap_size_in_bits = s; }\n@@ -290,0 +291,2 @@\n+  void set_rw_ptrmap_start_pos(size_t n)         { _rw_ptrmap_start_pos = n; }\n+  void set_ro_ptrmap_start_pos(size_t n)         { _ro_ptrmap_start_pos = n; }\n@@ -446,1 +449,1 @@\n-  char* write_bitmap_region(const CHeapBitMap* ptrmap, ArchiveHeapInfo* heap_info,\n+  char* write_bitmap_region(CHeapBitMap* rw_ptrmap, CHeapBitMap* ro_ptrmap, ArchiveHeapInfo* heap_info,\n@@ -529,0 +532,4 @@\n+  BitMapView bitmap_view(int region_index, bool is_oopmap);\n+  BitMapView oopmap_view(int region_index);\n+  BitMapView ptrmap_view(int region_index);\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1398,1 +1398,1 @@\n-              name == vmSymbols::java_lang_VirtualMachineError() ||\n+              name == vmSymbols::java_lang_InternalError() ||\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -516,3 +516,1 @@\n-  \/\/ Initialize random for updating the hash of symbols\n-  os::init_random(0x12345678);\n-\n+  builder.sort_metadata_objs();\n@@ -668,0 +666,1 @@\n+      CLEAR_PENDING_EXCEPTION;\n@@ -672,0 +671,1 @@\n+      CLEAR_PENDING_EXCEPTION;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -872,4 +872,2 @@\n-    int indy_index = cpool->decode_invokedynamic_index(index);\n-    assert (indy_index >= 0, \"should be\");\n-    assert(indy_index < cpool->cache()->resolved_indy_entries_length(), \"impossible\");\n-    Method* adapter = cpool->resolved_indy_entry_at(indy_index)->method();\n+    assert(index < cpool->cache()->resolved_indy_entries_length(), \"impossible\");\n+    Method* adapter = cpool->resolved_indy_entry_at(index)->method();\n@@ -1502,2 +1500,1 @@\n-  int index = cp->decode_invokedynamic_index(indy_index);\n-  ResolvedIndyEntry* indy_info = cp->resolved_indy_entry_at(index);\n+  ResolvedIndyEntry* indy_info = cp->resolved_indy_entry_at(indy_index);\n@@ -1509,1 +1506,1 @@\n-    oop appendix = cp->resolved_reference_from_indy(index);\n+    oop appendix = cp->resolved_reference_from_indy(indy_index);\n@@ -1516,1 +1513,1 @@\n-    BootstrapInfo bootstrap_specifier(cp, pool_index, index);\n+    BootstrapInfo bootstrap_specifier(cp, pool_index, indy_index);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -1065,1 +1066,1 @@\n-bool ciMethod::has_option(enum CompileCommand option) {\n+bool ciMethod::has_option(CompileCommandEnum option) {\n@@ -1075,1 +1076,1 @@\n-bool ciMethod::has_option_value(enum CompileCommand option, double& value) {\n+bool ciMethod::has_option_value(CompileCommandEnum option, double& value) {\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#include \"compiler\/compilerOracle.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -306,2 +306,2 @@\n-  bool has_option(enum CompileCommand option);\n-  bool has_option_value(enum CompileCommand option, double& value);\n+  bool has_option(CompileCommandEnum option);\n+  bool has_option_value(CompileCommandEnum option, double& value);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -419,1 +419,0 @@\n-        index = cp->decode_invokedynamic_index(index);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-  return ConstantPool::has_appendix_at_if_loaded(cpool, get_method_index());\n+  return ConstantPool::has_appendix_at_if_loaded(cpool, get_method_index(), cur_bc());\n@@ -484,1 +484,1 @@\n-  oop appendix_oop = ConstantPool::appendix_at_if_loaded(cpool, get_method_index());\n+  oop appendix_oop = ConstantPool::appendix_at_if_loaded(cpool, get_method_index(), cur_bc());\n@@ -496,1 +496,1 @@\n-    return ConstantPool::has_local_signature_at_if_loaded(cpool, get_method_index());\n+    return ConstantPool::has_local_signature_at_if_loaded(cpool, get_method_index(), cur_bc());\n@@ -546,1 +546,0 @@\n-\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4191,2 +4191,1 @@\n-  if ((!RegisterFinalizersAtInit && ik->has_finalizer())\n-      || ik->is_abstract() || ik->is_interface()\n+  if (ik->is_abstract() || ik->is_interface()\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+PerfCounter*    ClassLoader::_perf_secondary_hash_time = nullptr;\n@@ -1340,0 +1341,1 @@\n+    NEWPERFTICKCOUNTER(_perf_secondary_hash_time, SUN_CLS, \"secondarySuperHashTime\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,0 +172,3 @@\n+  \/\/ Count the time taken to hash the scondary superclass arrays.\n+  static PerfCounter* _perf_secondary_hash_time;\n+\n@@ -272,0 +275,3 @@\n+  static PerfCounter* perf_secondary_hash_time() {\n+    return _perf_secondary_hash_time;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2084,2 +2084,7 @@\n-oop java_lang_Throwable::cause(oop throwable) {\n-  return throwable->obj_field(_cause_offset);\n+const char* java_lang_Throwable::message_as_utf8(oop throwable) {\n+  oop msg = java_lang_Throwable::message(throwable);\n+  const char* msg_utf8 = nullptr;\n+  if (msg != nullptr) {\n+    msg_utf8 = java_lang_String::as_utf8_string(msg);\n+  }\n+  return msg_utf8;\n@@ -2088,8 +2093,2 @@\n-\/\/ Return Symbol for detailed_message or null\n-Symbol* java_lang_Throwable::detail_message(oop throwable) {\n-  PreserveExceptionMark pm(Thread::current());\n-  oop detailed_message = java_lang_Throwable::message(throwable);\n-  if (detailed_message != nullptr) {\n-    return java_lang_String::as_symbol(detailed_message);\n-  }\n-  return nullptr;\n+oop java_lang_Throwable::cause(oop throwable) {\n+  return throwable->obj_field(_cause_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -601,1 +601,0 @@\n-  static int get_detailMessage_offset() { CHECK_INIT(_detailMessage_offset); }\n@@ -603,0 +602,1 @@\n+  static int get_detailMessage_offset() { CHECK_INIT(_detailMessage_offset); }\n@@ -604,1 +604,1 @@\n-  static oop cause(oop throwable);\n+  static const char* message_as_utf8(oop throwable);\n@@ -606,1 +606,3 @@\n-  static Symbol* detail_message(oop throwable);\n+\n+  static oop cause(oop throwable);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-                                     Symbol* error, Symbol* message,\n-                                     Symbol* cause, Symbol* cause_msg)\n+                                     Symbol* error, const char* message,\n+                                     Symbol* cause, const char* cause_msg)\n@@ -100,2 +100,2 @@\n-ResolutionErrorEntry::ResolutionErrorEntry(Symbol* error, Symbol* message,\n-      Symbol* cause, Symbol* cause_msg):\n+ResolutionErrorEntry::ResolutionErrorEntry(Symbol* error, const char* message,\n+                                           Symbol* cause, const char* cause_msg):\n@@ -103,1 +103,1 @@\n-        _message(message),\n+        _message(message != nullptr ? os::strdup(message) : nullptr),\n@@ -105,1 +105,1 @@\n-        _cause_msg(cause_msg),\n+        _cause_msg(cause_msg != nullptr ? os::strdup(cause_msg) : nullptr),\n@@ -109,1 +109,0 @@\n-  Symbol::maybe_increment_refcount(_message);\n@@ -111,1 +110,0 @@\n-  Symbol::maybe_increment_refcount(_cause_msg);\n@@ -117,1 +115,0 @@\n-  Symbol::maybe_decrement_refcount(_message);\n@@ -119,1 +116,8 @@\n-  Symbol::maybe_decrement_refcount(_cause_msg);\n+\n+  if (_message != nullptr) {\n+    FREE_C_HEAP_ARRAY(char, _message);\n+  }\n+\n+  if (_cause_msg != nullptr) {\n+    FREE_C_HEAP_ARRAY(char, _cause_msg);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -39,2 +39,3 @@\n-  static void add_entry(const constantPoolHandle& pool, int which, Symbol* error, Symbol* message,\n-                        Symbol* cause, Symbol* cause_msg);\n+  static void add_entry(const constantPoolHandle& pool, int cp_index,\n+                        Symbol* error, const char* error_msg,\n+                        Symbol* cause, const char* cause_msg);\n@@ -42,1 +43,1 @@\n-  static void add_entry(const constantPoolHandle& pool, int which, const char* message);\n+  static void add_entry(const constantPoolHandle& pool, int cp_index, const char* message);\n@@ -60,1 +61,1 @@\n-  \/\/ constant pool index.  It assumes it is being called with a index that is less than 0\n+  \/\/ constant pool index.\n@@ -62,1 +63,0 @@\n-    assert(index < 0, \"Unexpected non-negative cpCache index\");\n@@ -71,1 +71,1 @@\n-  Symbol*           _message;\n+  const char*       _message;\n@@ -73,1 +73,1 @@\n-  Symbol*           _cause_msg;\n+  const char*       _cause_msg;\n@@ -79,1 +79,3 @@\n-    ResolutionErrorEntry(Symbol* error, Symbol* message, Symbol* cause, Symbol* cause_msg);\n+  \/\/ The incoming message and cause_msg are copied to the C-Heap.\n+  ResolutionErrorEntry(Symbol* error, const char* message,\n+                       Symbol* cause, const char* cause_msg);\n@@ -81,1 +83,2 @@\n-    ResolutionErrorEntry(const char* message):\n+  \/\/ The incoming nest host error message is already in the C-Heap.\n+  ResolutionErrorEntry(const char* message):\n@@ -88,1 +91,1 @@\n-    ~ResolutionErrorEntry();\n+  ~ResolutionErrorEntry();\n@@ -90,3 +93,4 @@\n-    void set_nest_host_error(const char* message) {\n-      _nest_host_error = message;\n-    }\n+  \/\/ The incoming nest host error message is already in the C-Heap.\n+  void set_nest_host_error(const char* message) {\n+    _nest_host_error = message;\n+  }\n@@ -96,1 +100,1 @@\n-  Symbol*            message() const            { return _message; }\n+  const char*        message() const            { return _message; }\n@@ -98,1 +102,1 @@\n-  Symbol*            cause_msg() const          { return _cause_msg; }\n+  const char*        cause_msg() const          { return _cause_msg; }\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.hpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1802,2 +1802,2 @@\n-                                            Symbol* error, Symbol* message,\n-                                            Symbol* cause, Symbol* cause_msg) {\n+                                            Symbol* error, const char* message,\n+                                            Symbol* cause, const char* cause_msg) {\n@@ -1820,1 +1820,2 @@\n-                                                Symbol** message, Symbol** cause, Symbol** cause_msg) {\n+                                                const char** message,\n+                                                Symbol** cause, const char** cause_msg) {\n@@ -2011,1 +2012,1 @@\n-  \/\/ Throw VirtualMachineError or the pending exception in the JavaThread\n+  \/\/ Throw OOM or the pending exception in the JavaThread\n@@ -2013,1 +2014,1 @@\n-    THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n+    THROW_MSG_NULL(vmSymbols::java_lang_OutOfMemoryError(),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -275,2 +275,3 @@\n-  static void add_resolution_error(const constantPoolHandle& pool, int which, Symbol* error,\n-                                   Symbol* message, Symbol* cause = nullptr, Symbol* cause_msg = nullptr);\n+  static void add_resolution_error(const constantPoolHandle& pool, int which,\n+                                   Symbol* error, const char* message,\n+                                   Symbol* cause = nullptr, const char* cause_msg = nullptr);\n@@ -279,2 +280,2 @@\n-                                       Symbol** message, Symbol** cause, Symbol** cause_msg);\n-\n+                                       const char** message,\n+                                       Symbol** cause, const char** cause_msg);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,2 @@\n-    \/\/ Least significant bits of _handle are always 0, so we use these as\n-    \/\/ the indicator that the _handle is valid.  Otherwise, the _data field\n+    \/\/ Least significant 2 bits of _sym are always 0, so we use these as\n+    \/\/ the indicator that _sym is a valid pointer.  Otherwise, the _data field\n@@ -55,1 +55,1 @@\n-    \/\/ and the lower bits on oops aren't 0, the assert in the constructor\n+    \/\/ and the lower 2 bits of Symbol* aren't 0, the assert in the constructor\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,1 +258,1 @@\n-        THROW_OOP_(Universe::virtual_machine_error_instance(), false);\n+        THROW_OOP_(Universe::internal_error_instance(), false);\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -509,0 +509,3 @@\n+  case vmIntrinsics::_setMemory:\n+    if (!InlineUnsafeOps) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -623,0 +623,3 @@\n+  do_intrinsic(_setMemory,                jdk_internal_misc_Unsafe,     setMemory_name,  setMemory_signature,          F_RN)     \\\n+   do_name(     setMemory_name,                                         \"setMemory0\")                                            \\\n+   do_signature(setMemory_signature,                                    \"(Ljava\/lang\/Object;JJB)V\")                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,36 +76,2 @@\n-#ifdef ASSERT\n-void CodeBlob::verify_parameters() {\n-  assert(is_aligned(_size,            oopSize), \"unaligned size\");\n-  assert(is_aligned(_header_size,     oopSize), \"unaligned size\");\n-  assert(is_aligned(_relocation_size, oopSize), \"unaligned size\");\n-  assert(_data_offset <= size(), \"codeBlob is too small\");\n-  assert(code_end() == content_end(), \"must be the same - see code_end()\");\n-#ifdef COMPILER1\n-  \/\/ probably wrong for tiered\n-  assert(frame_size() >= -1, \"must use frame size or -1 for runtime stubs\");\n-#endif \/\/ COMPILER1\n-}\n-#endif\n-\n-CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size, int relocation_size,\n-                   int content_offset, int code_offset, int frame_complete_offset, int data_offset,\n-                   int frame_size, ImmutableOopMapSet* oop_maps, bool caller_must_gc_arguments) :\n-  _oop_maps(oop_maps),\n-  _name(name),\n-  _size(size),\n-  _header_size(header_size),\n-  _relocation_size(relocation_size),\n-  _content_offset(content_offset),\n-  _code_offset(code_offset),\n-  _frame_complete_offset(frame_complete_offset),\n-  _data_offset(data_offset),\n-  _frame_size(frame_size),\n-  S390_ONLY(_ctable_offset(0) COMMA)\n-  _kind(kind),\n-  _caller_must_gc_arguments(caller_must_gc_arguments)\n-{\n-  DEBUG_ONLY( verify_parameters(); )\n-}\n-\n-CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, int header_size,\n-                   int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :\n+CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, uint16_t header_size,\n+                   int16_t frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :\n@@ -115,1 +81,0 @@\n-  _header_size(header_size),\n@@ -117,1 +82,1 @@\n-  _content_offset(CodeBlob::align_code_offset(_header_size + _relocation_size)),\n+  _content_offset(CodeBlob::align_code_offset(header_size + _relocation_size)),\n@@ -119,1 +84,0 @@\n-  _frame_complete_offset(frame_complete_offset),\n@@ -123,0 +87,2 @@\n+  _header_size(header_size),\n+  _frame_complete_offset(frame_complete_offset),\n@@ -126,1 +92,9 @@\n-  DEBUG_ONLY( verify_parameters(); )\n+  assert(is_aligned(_size,            oopSize), \"unaligned size\");\n+  assert(is_aligned(header_size,      oopSize), \"unaligned size\");\n+  assert(is_aligned(_relocation_size, oopSize), \"unaligned size\");\n+  assert(_data_offset <= _size, \"codeBlob is too small: %d > %d\", _data_offset, _size);\n+  assert(code_end() == content_end(), \"must be the same - see code_end()\");\n+#ifdef COMPILER1\n+  \/\/ probably wrong for tiered\n+  assert(_frame_size >= -1, \"must use frame size or -1 for runtime stubs\");\n+#endif \/\/ COMPILER1\n@@ -132,1 +106,1 @@\n-CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size) :\n+CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, int size, uint16_t header_size) :\n@@ -136,1 +110,0 @@\n-  _header_size(header_size),\n@@ -140,1 +113,0 @@\n-  _frame_complete_offset(CodeOffsets::frame_never_safe),\n@@ -144,0 +116,2 @@\n+  _header_size(header_size),\n+  _frame_complete_offset(CodeOffsets::frame_never_safe),\n@@ -151,1 +125,1 @@\n-void CodeBlob::purge(bool free_code_cache_data, bool unregister_nmethod) {\n+void CodeBlob::purge() {\n@@ -188,2 +162,2 @@\n-  int         header_size,\n-  int         frame_complete,\n+  uint16_t    header_size,\n+  int16_t     frame_complete,\n@@ -201,1 +175,1 @@\n-  blob->purge(true \/* free_code_cache_data *\/, true \/* unregister_nmethod *\/);\n+  blob->purge();\n@@ -411,1 +385,1 @@\n-  int         frame_complete,\n+  int16_t     frame_complete,\n@@ -423,1 +397,1 @@\n-                                           int frame_complete,\n+                                           int16_t frame_complete,\n@@ -671,4 +645,0 @@\n-void UpcallStub::preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) {\n-  ShouldNotReachHere(); \/\/ caller should never have to gc arguments\n-}\n-\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":23,"deletions":53,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n-class UpcallStub; \/\/ for as_upcall_stub()\n-class RuntimeStub; \/\/ for as_runtime_stub()\n+class UpcallStub;      \/\/ for as_upcall_stub()\n+class RuntimeStub;     \/\/ for as_runtime_stub()\n@@ -104,1 +104,1 @@\n-  ImmutableOopMapSet* _oop_maps;                 \/\/ OopMap for this CodeBlob\n+  ImmutableOopMapSet* _oop_maps;   \/\/ OopMap for this CodeBlob\n@@ -107,11 +107,4 @@\n-  int        _size;                              \/\/ total size of CodeBlob in bytes\n-  int        _header_size;                       \/\/ size of header (depends on subclass)\n-  int        _relocation_size;                   \/\/ size of relocation\n-  int        _content_offset;                    \/\/ offset to where content region begins (this includes consts, insts, stubs)\n-  int        _code_offset;                       \/\/ offset to where instructions region begins (this includes insts, stubs)\n-  int        _frame_complete_offset;             \/\/ instruction offsets in [0.._frame_complete_offset) have\n-                                                 \/\/ not finished setting up their frame. Beware of pc's in\n-                                                 \/\/ that range. There is a similar range(s) on returns\n-                                                 \/\/ which we don't detect.\n-  int        _data_offset;                       \/\/ offset to where data region begins\n-  int        _frame_size;                        \/\/ size of stack frame in words (NOT slots. On x64 these are 64bit words)\n+  int      _size;                  \/\/ total size of CodeBlob in bytes\n+  int      _relocation_size;       \/\/ size of relocation (could be bigger than 64Kb)\n+  int      _content_offset;        \/\/ offset to where content region begins (this includes consts, insts, stubs)\n+  int      _code_offset;           \/\/ offset to where instructions region begins (this includes insts, stubs)\n@@ -119,1 +112,2 @@\n-  S390_ONLY(int       _ctable_offset;)\n+  int      _data_offset;           \/\/ offset to where data region begins\n+  int      _frame_size;            \/\/ size of stack frame in words (NOT slots. On x64 these are 64bit words)\n@@ -121,1 +115,1 @@\n-  CodeBlobKind        _kind;                     \/\/ Kind of this code blob\n+  S390_ONLY(int _ctable_offset;)\n@@ -123,1 +117,9 @@\n-  bool                _caller_must_gc_arguments;\n+  uint16_t _header_size;           \/\/ size of header (depends on subclass)\n+  int16_t  _frame_complete_offset; \/\/ instruction offsets in [0.._frame_complete_offset) have\n+                                   \/\/ not finished setting up their frame. Beware of pc's in\n+                                   \/\/ that range. There is a similar range(s) on returns\n+                                   \/\/ which we don't detect.\n+\n+  CodeBlobKind _kind;              \/\/ Kind of this code blob\n+\n+  bool _caller_must_gc_arguments;\n@@ -128,7 +130,1 @@\n-#endif \/\/ not PRODUCT\n-\n-  DEBUG_ONLY( void verify_parameters() );\n-\n-  CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size, int relocation_size,\n-           int content_offset, int code_offset, int data_offset, int frame_complete_offset,\n-           int frame_size, ImmutableOopMapSet* oop_maps, bool caller_must_gc_arguments);\n+#endif\n@@ -136,2 +132,2 @@\n-  CodeBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, int header_size,\n-           int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments);\n+  CodeBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, uint16_t header_size,\n+           int16_t frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments);\n@@ -140,1 +136,1 @@\n-  CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size);\n+  CodeBlob(const char* name, CodeBlobKind kind, int size, uint16_t header_size);\n@@ -155,1 +151,1 @@\n-  virtual void purge(bool free_code_cache_data, bool unregister_nmethod);\n+  void purge();\n@@ -228,1 +224,0 @@\n-  virtual void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) = 0;\n@@ -276,1 +271,1 @@\n-  RuntimeBlob(const char* name, CodeBlobKind kind, int size, int header_size)\n+  RuntimeBlob(const char* name, CodeBlobKind kind, int size, uint16_t header_size)\n@@ -288,2 +283,2 @@\n-    int         header_size,\n-    int         frame_complete,\n+    uint16_t    header_size,\n+    int16_t     frame_complete,\n@@ -327,3 +322,1 @@\n-  \/\/ GC\/Verification support\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) override { \/* nothing to do *\/ }\n-\n+  \/\/ Verification support\n@@ -331,0 +324,1 @@\n+\n@@ -384,1 +378,1 @@\n-    int         frame_complete,\n+    int16_t     frame_complete,\n@@ -397,1 +391,1 @@\n-    int         frame_complete,\n+    int16_t     frame_complete,\n@@ -408,3 +402,1 @@\n-  \/\/ GC\/Verification support\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) override { \/* nothing to do *\/ }\n-\n+  \/\/ Verification support\n@@ -412,0 +404,1 @@\n+\n@@ -432,1 +425,1 @@\n-     int          header_size,\n+     uint16_t     header_size,\n@@ -441,2 +434,1 @@\n-  \/\/ GC\/Verification support\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) override { \/* nothing to do *\/ }\n+  \/\/ Verification support\n@@ -444,0 +436,1 @@\n+\n@@ -635,1 +628,0 @@\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) override;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":36,"deletions":44,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/c2_MacroAssembler.hpp\"\n@@ -188,1 +189,1 @@\n-  static address emit_to_interp_stub(CodeBuffer &cbuf, address mark = nullptr);\n+  static address emit_to_interp_stub(MacroAssembler *masm, address mark = nullptr);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -247,1 +247,0 @@\n-  int chunks_reshared;\n@@ -251,4 +250,2 @@\n-    tty->print_cr(\"Debug Data Chunks: %d, shared %d+%d, non-SP's elided %d\",\n-                  chunks_queried,\n-                  chunks_shared, chunks_reshared,\n-                  chunks_elided);\n+    tty->print_cr(\"Debug Data Chunks: %d, shared %d, non-SP's elided %d\",\n+                  chunks_queried, chunks_shared, chunks_elided);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -391,3 +391,1 @@\n-  Copy::disjoint_words((HeapWord*) content_bytes(),\n-                       (HeapWord*) beg,\n-                       size_in_bytes() \/ sizeof(HeapWord));\n+  (void)memcpy(beg, content_bytes(), size_in_bytes());\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -140,3 +141,0 @@\n-  uint size_gt_32k;\n-  int size_max;\n-\n@@ -161,3 +159,0 @@\n-    int short_pos_max = ((1<<15) - 1);\n-    if (nm->size() > short_pos_max) size_gt_32k++;\n-    if (nm->size() > size_max) size_max = nm->size();\n@@ -186,2 +181,0 @@\n-    if (size_gt_32k != 0)         tty->print_cr(\" size > 32k     = %u\", size_gt_32k);\n-    if (size_max != 0)            tty->print_cr(\" max size       = %d\", size_max);\n@@ -1007,21 +1000,0 @@\n-\/\/ Fill in default values for various flag fields\n-void nmethod::init_defaults() {\n-  \/\/ avoid uninitialized fields, even for short time periods\n-  _exception_cache            = nullptr;\n-\n-  _has_unsafe_access          = 0;\n-  _has_method_handle_invokes  = 0;\n-  _has_wide_vectors           = 0;\n-  _has_monitors               = 0;\n-\n-  _state                      = not_installed;\n-  _has_flushed_dependencies   = 0;\n-  _load_reported              = false; \/\/ jvmti state\n-\n-  _oops_do_mark_link          = nullptr;\n-  _osr_link                   = nullptr;\n-#if INCLUDE_RTM_OPT\n-  _rtm_state                  = NoRTM;\n-#endif\n-}\n-\n@@ -1202,0 +1174,47 @@\n+\/\/ Fill in default values for various fields\n+void nmethod::init_defaults(CodeBuffer *code_buffer, CodeOffsets* offsets) {\n+  \/\/ avoid uninitialized fields, even for short time periods\n+  _exception_cache            = nullptr;\n+  _gc_data                    = nullptr;\n+  _oops_do_mark_link          = nullptr;\n+  _compiled_ic_data           = nullptr;\n+\n+#if INCLUDE_RTM_OPT\n+  _rtm_state                  = NoRTM;\n+#endif\n+  _is_unloading_state         = 0;\n+  _state                      = not_installed;\n+\n+  _has_unsafe_access          = 0;\n+  _has_method_handle_invokes  = 0;\n+  _has_wide_vectors           = 0;\n+  _has_monitors               = 0;\n+  _has_flushed_dependencies   = 0;\n+  _is_unlinked                = 0;\n+  _load_reported              = 0; \/\/ jvmti state\n+\n+  _deoptimization_status      = not_marked;\n+\n+  \/\/ SECT_CONSTS is first in code buffer so the offset should be 0.\n+  int consts_offset = code_buffer->total_offset_of(code_buffer->consts());\n+  assert(consts_offset == 0, \"const_offset: %d\", consts_offset);\n+\n+  _entry_offset          = checked_cast<uint16_t>(offsets->value(CodeOffsets::Entry));\n+  _verified_entry_offset = checked_cast<uint16_t>(offsets->value(CodeOffsets::Verified_Entry));\n+  _stub_offset           = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n+\n+  _skipped_instructions_size = checked_cast<uint16_t>(code_buffer->total_skipped_instructions_size());\n+}\n+\n+\/\/ Post initialization\n+void nmethod::post_init() {\n+  clear_unloading_state();\n+\n+  finalize_relocations();\n+\n+  Universe::heap()->register_nmethod(this);\n+  debug_only(Universe::heap()->verify_nmethod(this));\n+\n+  CodeCache::commit(this);\n+}\n+\n@@ -1217,0 +1236,1 @@\n+  _gc_epoch(CodeCache::gc_epoch()),\n@@ -1218,3 +1238,0 @@\n-  _gc_data(nullptr),\n-  _compiled_ic_data(nullptr),\n-  _is_unlinked(false),\n@@ -1222,3 +1239,1 @@\n-  _native_basic_lock_sp_offset(basic_lock_sp_offset),\n-  _is_unloading_state(0),\n-  _deoptimization_status(not_marked)\n+  _native_basic_lock_sp_offset(basic_lock_sp_offset)\n@@ -1230,2 +1245,3 @@\n-    init_defaults();\n-    _comp_level              = CompLevel_none;\n+    init_defaults(code_buffer, offsets);\n+\n+    _osr_entry_point         = nullptr;\n@@ -1233,3 +1249,3 @@\n-    \/\/ We have no exception handler or deopt handler make the\n-    \/\/ values something that will never match a pc like the nmethod vtable entry\n-    _exception_offset        = 0;\n+    _compile_id              = compile_id;\n+    _comp_level              = CompLevel_none;\n+    _compiler_type           = type;\n@@ -1237,0 +1253,10 @@\n+    _num_stack_arg_slots     = _method->constMethod()->num_stack_arg_slots();\n+\n+    if (offsets->value(CodeOffsets::Exceptions) != -1) {\n+      \/\/ Continuation enter intrinsic\n+      _exception_offset      = code_offset() + offsets->value(CodeOffsets::Exceptions);\n+    } else {\n+      _exception_offset      = 0;\n+    }\n+    \/\/ Native wrappers do not have deopt handlers. Make the values\n+    \/\/ something that will never match a pc like the nmethod vtable entry\n@@ -1239,10 +1265,7 @@\n-    _gc_epoch                = CodeCache::gc_epoch();\n-\n-    _consts_offset           = content_offset()      + code_buffer->total_offset_of(code_buffer->consts());\n-    _stub_offset             = content_offset()      + code_buffer->total_offset_of(code_buffer->stubs());\n-    _oops_offset             = data_offset();\n-    _metadata_offset         = _oops_offset          + align_up(code_buffer->total_oop_size(), oopSize);\n-    _scopes_data_offset      = _metadata_offset      + align_up(code_buffer->total_metadata_size(), wordSize);\n-    _scopes_pcs_offset       = _scopes_data_offset;\n-    _dependencies_offset     = _scopes_pcs_offset;\n-    _handler_table_offset    = _dependencies_offset;\n+    _unwind_handler_offset   = 0;\n+\n+    _metadata_offset         = checked_cast<uint16_t>(align_up(code_buffer->total_oop_size(), oopSize));\n+    _dependencies_offset     = checked_cast<uint16_t>(_metadata_offset + align_up(code_buffer->total_metadata_size(), wordSize));\n+    _scopes_pcs_offset       = _dependencies_offset;\n+    _scopes_data_offset      = _scopes_pcs_offset;\n+    _handler_table_offset    = _scopes_data_offset;\n@@ -1250,1 +1273,0 @@\n-    _skipped_instructions_size = code_buffer->total_skipped_instructions_size();\n@@ -1254,1 +1276,1 @@\n-    _nmethod_end_offset      = _jvmci_data_offset;\n+    DEBUG_ONLY( int data_end_offset = _jvmci_data_offset; )\n@@ -1256,1 +1278,1 @@\n-    _nmethod_end_offset      = _nul_chk_table_offset;\n+    DEBUG_ONLY( int data_end_offset = _nul_chk_table_offset; )\n@@ -1258,7 +1280,1 @@\n-    _compile_id              = compile_id;\n-    _compiler_type           = type;\n-    _entry_point             = code_begin()          + offsets->value(CodeOffsets::Entry);\n-    _verified_entry_point    = code_begin()          + offsets->value(CodeOffsets::Verified_Entry);\n-    _osr_entry_point         = nullptr;\n-    _exception_cache         = nullptr;\n-    _pc_desc_container.reset_to(nullptr);\n+    assert((data_offset() + data_end_offset) <= nmethod_size, \"wrong nmethod's size: %d < %d\", nmethod_size, (data_offset() + data_end_offset));\n@@ -1266,1 +1282,1 @@\n-    _exception_offset        = code_offset()         + offsets->value(CodeOffsets::Exceptions);\n+    _pc_desc_container.reset_to(nullptr);\n@@ -1271,8 +1287,1 @@\n-    clear_unloading_state();\n-\n-    finalize_relocations();\n-\n-    Universe::heap()->register_nmethod(this);\n-    debug_only(Universe::heap()->verify_nmethod(this));\n-\n-    CodeCache::commit(this);\n+    post_init();\n@@ -1336,0 +1345,1 @@\n+\/\/ For normal JIT compiled code\n@@ -1362,0 +1372,1 @@\n+  _gc_epoch(CodeCache::gc_epoch()),\n@@ -1363,7 +1374,1 @@\n-  _gc_data(nullptr),\n-  _compiled_ic_data(nullptr),\n-  _is_unlinked(false),\n-  _native_receiver_sp_offset(in_ByteSize(-1)),\n-  _native_basic_lock_sp_offset(in_ByteSize(-1)),\n-  _is_unloading_state(0),\n-  _deoptimization_status(not_marked)\n+  _osr_link(nullptr)\n@@ -1376,7 +1381,1 @@\n-    init_defaults();\n-    _entry_bci      = entry_bci;\n-    _compile_id     = compile_id;\n-    _compiler_type  = type;\n-    _comp_level     = comp_level;\n-    _orig_pc_offset = orig_pc_offset;\n-    _gc_epoch       = CodeCache::gc_epoch();\n+    init_defaults(code_buffer, offsets);\n@@ -1384,5 +1383,10 @@\n-    \/\/ Section offsets\n-    _consts_offset  = content_offset() + code_buffer->total_offset_of(code_buffer->consts());\n-    _stub_offset    = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n-    set_ctable_begin(header_begin() + _consts_offset);\n-    _skipped_instructions_size = code_buffer->total_skipped_instructions_size();\n+    _osr_entry_point = code_begin() + offsets->value(CodeOffsets::OSR_Entry);\n+    _entry_bci       = entry_bci;\n+    _compile_id      = compile_id;\n+    _comp_level      = comp_level;\n+    _compiler_type   = type;\n+    _orig_pc_offset  = orig_pc_offset;\n+\n+    _num_stack_arg_slots = entry_bci != InvocationEntryBci ? 0 : _method->constMethod()->num_stack_arg_slots();\n+\n+    set_ctable_begin(header_begin() + content_offset());\n@@ -1428,9 +1432,6 @@\n-\n-    _oops_offset             = data_offset();\n-    _metadata_offset         = _oops_offset          + align_up(code_buffer->total_oop_size(), oopSize);\n-    _scopes_data_offset      = _metadata_offset      + align_up(code_buffer->total_metadata_size(), wordSize);\n-\n-    _scopes_pcs_offset       = _scopes_data_offset   + align_up(debug_info->data_size       (), oopSize);\n-    _dependencies_offset     = _scopes_pcs_offset    + adjust_pcs_size(debug_info->pcs_size());\n-    _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies->size_in_bytes(), oopSize);\n-    _nul_chk_table_offset    = _handler_table_offset + align_up(handler_table->size_in_bytes(), oopSize);\n+    _metadata_offset      = checked_cast<uint16_t>(align_up(code_buffer->total_oop_size(), oopSize));\n+    _dependencies_offset  = checked_cast<uint16_t>(_metadata_offset     + align_up(code_buffer->total_metadata_size(), wordSize));\n+    _scopes_pcs_offset    = checked_cast<uint16_t>(_dependencies_offset + align_up((int)dependencies->size_in_bytes(), oopSize));\n+    _scopes_data_offset   = _scopes_pcs_offset    + adjust_pcs_size(debug_info->pcs_size());\n+    _handler_table_offset = _scopes_data_offset   + align_up(debug_info->data_size       (), oopSize);\n+    _nul_chk_table_offset = _handler_table_offset + align_up(handler_table->size_in_bytes(), oopSize);\n@@ -1438,4 +1439,4 @@\n-    _speculations_offset     = _nul_chk_table_offset + align_up(nul_chk_table->size_in_bytes(), oopSize);\n-    _jvmci_data_offset       = _speculations_offset  + align_up(speculations_len, oopSize);\n-    int jvmci_data_size      = compiler->is_jvmci() ? jvmci_data->size() : 0;\n-    _nmethod_end_offset      = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize);\n+    _speculations_offset  = _nul_chk_table_offset + align_up(nul_chk_table->size_in_bytes(), oopSize);\n+    _jvmci_data_offset    = _speculations_offset  + align_up(speculations_len, oopSize);\n+    int jvmci_data_size   = compiler->is_jvmci() ? jvmci_data->size() : 0;\n+    DEBUG_ONLY( int data_end_offset = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize); )\n@@ -1443,1 +1444,1 @@\n-    _nmethod_end_offset      = _nul_chk_table_offset + align_up(nul_chk_table->size_in_bytes(), oopSize);\n+    DEBUG_ONLY( int data_end_offset = _nul_chk_table_offset + align_up(nul_chk_table->size_in_bytes(), oopSize); )\n@@ -1445,4 +1446,1 @@\n-    _entry_point             = code_begin()          + offsets->value(CodeOffsets::Entry);\n-    _verified_entry_point    = code_begin()          + offsets->value(CodeOffsets::Verified_Entry);\n-    _osr_entry_point         = code_begin()          + offsets->value(CodeOffsets::OSR_Entry);\n-    _exception_cache         = nullptr;\n+    assert((data_offset() + data_end_offset) <= nmethod_size, \"wrong nmethod's size: %d < %d\", nmethod_size, (data_offset() + data_end_offset));\n@@ -1450,0 +1448,1 @@\n+    \/\/ after _scopes_pcs_offset is set\n@@ -1457,1 +1456,0 @@\n-    clear_unloading_state();\n@@ -1466,7 +1464,0 @@\n-    finalize_relocations();\n-\n-    Universe::heap()->register_nmethod(this);\n-    debug_only(Universe::heap()->verify_nmethod(this));\n-\n-    CodeCache::commit(this);\n-\n@@ -1484,0 +1475,2 @@\n+    post_init();\n+\n@@ -1487,1 +1480,1 @@\n-           _method->is_static() == (entry_point() == _verified_entry_point),\n+           _method->is_static() == (entry_point() == verified_entry_point()),\n@@ -1616,1 +1609,1 @@\n-    if (printmethod || PrintDebugInfo || CompilerOracle::has_option(mh, CompileCommand::PrintDebugInfo)) {\n+    if (printmethod || PrintDebugInfo || CompilerOracle::has_option(mh, CompileCommandEnum::PrintDebugInfo)) {\n@@ -1620,1 +1613,1 @@\n-    if (printmethod || PrintRelocations || CompilerOracle::has_option(mh, CompileCommand::PrintRelocations)) {\n+    if (printmethod || PrintRelocations || CompilerOracle::has_option(mh, CompileCommandEnum::PrintRelocations)) {\n@@ -1624,1 +1617,1 @@\n-    if (printmethod || PrintDependencies || CompilerOracle::has_option(mh, CompileCommand::PrintDependencies)) {\n+    if (printmethod || PrintDependencies || CompilerOracle::has_option(mh, CompileCommandEnum::PrintDependencies)) {\n@@ -2000,1 +1993,1 @@\n-  if (_is_unlinked) {\n+  if (is_unlinked()) {\n@@ -2034,2 +2027,1 @@\n-void nmethod::purge(bool free_code_cache_data, bool unregister_nmethod) {\n-  assert(!free_code_cache_data, \"must only call not freeing code cache data\");\n+void nmethod::purge(bool unregister_nmethod) {\n@@ -2040,1 +2032,1 @@\n-  Events::log(Thread::current(), \"flushing nmethod \" INTPTR_FORMAT, p2i(this));\n+  Events::log_nmethod_flush(Thread::current(), \"flushing %s nmethod \" INTPTR_FORMAT, is_osr_method() ? \"osr\" : \"\", p2i(this));\n@@ -2063,1 +2055,1 @@\n-  CodeBlob::purge(free_code_cache_data, unregister_nmethod);\n+  CodeBlob::purge();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":115,"deletions":123,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -191,2 +191,17 @@\n-  \/\/ To support simple linked-list chaining of nmethods:\n-  nmethod*  _osr_link;         \/\/ from InstanceKlass::osr_nmethods_head\n+  \/\/ To reduce header size union fields which usages do not overlap.\n+  union {\n+    \/\/ To support simple linked-list chaining of nmethods:\n+    nmethod*  _osr_link; \/\/ from InstanceKlass::osr_nmethods_head\n+    struct {\n+      \/\/ These are used for compiled synchronized native methods to\n+      \/\/ locate the owner and stack slot for the BasicLock. They are\n+      \/\/ needed because there is no debug information for compiled native\n+      \/\/ wrappers and the oop maps are insufficient to allow\n+      \/\/ frame::retrieve_receiver() to work. Currently they are expected\n+      \/\/ to be byte offsets from the Java stack pointer for maximum code\n+      \/\/ sharing between platforms. JVMTI's GetLocalInstance() uses these\n+      \/\/ offsets to find the receiver for non-static native wrapper frames.\n+      ByteSize _native_receiver_sp_offset;\n+      ByteSize _native_basic_lock_sp_offset;\n+    };\n+  };\n@@ -203,0 +218,2 @@\n+  CompiledICData* _compiled_ic_data;\n+\n@@ -204,3 +221,4 @@\n-  address _entry_point;                      \/\/ entry point with class check\n-  address _verified_entry_point;             \/\/ entry point without class check\n-  address _osr_entry_point;                  \/\/ entry point for on stack replacement\n+  address  _osr_entry_point;       \/\/ entry point for on stack replacement\n+  uint16_t _entry_offset;          \/\/ entry point with class check\n+  uint16_t _verified_entry_offset; \/\/ entry point without class check\n+  int      _entry_bci;             \/\/ != InvocationEntryBci if this nmethod is an on-stack replacement method\n@@ -208,1 +226,1 @@\n-  CompiledICData* _compiled_ic_data;\n+  \/\/ _consts_offset == _content_offset because SECT_CONSTS is first in code buffer\n@@ -210,2 +228,1 @@\n-  \/\/ Shared fields for all nmethod's\n-  int _entry_bci;      \/\/ != InvocationEntryBci if this nmethod is an on-stack replacement method\n+  int _stub_offset;\n@@ -213,2 +230,2 @@\n-  \/\/ Offsets for different nmethod parts\n-  int  _exception_offset;\n+  \/\/ Offsets for different stubs section parts\n+  int _exception_offset;\n@@ -224,9 +241,9 @@\n-  int _consts_offset;\n-  int _stub_offset;\n-  int _oops_offset;                       \/\/ offset to where embedded oop table begins (inside data)\n-  int _metadata_offset;                   \/\/ embedded meta data table\n-  int _scopes_data_offset;\n-  int _scopes_pcs_offset;\n-  int _dependencies_offset;\n-  int _handler_table_offset;\n-  int _nul_chk_table_offset;\n+  uint16_t _skipped_instructions_size;\n+\n+  \/\/ _oops_offset == _data_offset,  offset where embedded oop table begins (inside data)\n+  uint16_t _metadata_offset; \/\/ embedded meta data table\n+  uint16_t _dependencies_offset;\n+  uint16_t _scopes_pcs_offset;\n+  int      _scopes_data_offset;\n+  int      _handler_table_offset;\n+  int      _nul_chk_table_offset;\n@@ -234,2 +251,2 @@\n-  int _speculations_offset;\n-  int _jvmci_data_offset;\n+  int      _speculations_offset;\n+  int      _jvmci_data_offset;\n@@ -237,2 +254,0 @@\n-  int _nmethod_end_offset;\n-  int _skipped_instructions_size;\n@@ -244,3 +259,3 @@\n-  int _compile_id;                        \/\/ which compilation made this nmethod\n-\n-  CompilerType _compiler_type;            \/\/ which compiler made this nmethod (u1)\n+  int          _compile_id;            \/\/ which compilation made this nmethod\n+  CompLevel    _comp_level;            \/\/ compilation level (s1)\n+  CompilerType _compiler_type;         \/\/ which compiler made this nmethod (u1)\n@@ -248,1 +263,1 @@\n-  bool _is_unlinked;\n+  uint16_t     _num_stack_arg_slots;   \/\/ Number of arguments passed on the stack\n@@ -256,13 +271,0 @@\n-  \/\/ These are used for compiled synchronized native methods to\n-  \/\/ locate the owner and stack slot for the BasicLock. They are\n-  \/\/ needed because there is no debug information for compiled native\n-  \/\/ wrappers and the oop maps are insufficient to allow\n-  \/\/ frame::retrieve_receiver() to work. Currently they are expected\n-  \/\/ to be byte offsets from the Java stack pointer for maximum code\n-  \/\/ sharing between platforms. JVMTI's GetLocalInstance() uses these\n-  \/\/ offsets to find the receiver for non-static native wrapper frames.\n-  ByteSize _native_receiver_sp_offset;\n-  ByteSize _native_basic_lock_sp_offset;\n-\n-  CompLevel _comp_level;               \/\/ compilation level (s1)\n-\n@@ -272,3 +274,0 @@\n-  \/\/ used by jvmti to track if an event has been posted for this nmethod.\n-  bool _load_reported;\n-\n@@ -283,1 +282,3 @@\n-          _has_flushed_dependencies:1; \/\/ Used for maintenance of dependencies (under CodeCache_lock)\n+          _has_flushed_dependencies:1, \/\/ Used for maintenance of dependencies (under CodeCache_lock)\n+          _is_unlinked:1,              \/\/ mark during class unloading\n+          _load_reported:1;            \/\/ used by jvmti to track if an event has been posted for this nmethod\n@@ -298,0 +299,6 @@\n+  \/\/ Initialize fields to their default values\n+  void init_defaults(CodeBuffer *code_buffer, CodeOffsets* offsets);\n+\n+  \/\/ Post initialization\n+  void post_init();\n+\n@@ -310,1 +317,1 @@\n-  \/\/ Creation support\n+  \/\/ For normal JIT compiled code\n@@ -354,3 +361,0 @@\n-  \/\/ Initialize fields to their default values\n-  void init_defaults();\n-\n@@ -524,3 +528,3 @@\n-  address consts_begin          () const { return           header_begin() + _consts_offset           ; }\n-  address consts_end            () const { return           header_begin() +  code_offset()           ; }\n-  address insts_begin           () const { return           header_begin() +  code_offset()           ; }\n+  address consts_begin          () const { return           content_begin(); }\n+  address consts_end            () const { return           code_begin()   ; }\n+  address insts_begin           () const { return           code_begin()   ; }\n@@ -529,1 +533,1 @@\n-  address stub_end              () const { return           header_begin() + _oops_offset             ; }\n+  address stub_end              () const { return           data_begin()   ; }\n@@ -534,15 +538,16 @@\n-  oop*    oops_begin            () const { return (oop*)   (header_begin() + _oops_offset)            ; }\n-  oop*    oops_end              () const { return (oop*)   (header_begin() + _metadata_offset)        ; }\n-\n-  Metadata** metadata_begin     () const { return (Metadata**) (header_begin() + _metadata_offset)    ; }\n-  Metadata** metadata_end       () const { return (Metadata**) (header_begin() + _scopes_data_offset) ; }\n-\n-  address scopes_data_begin     () const { return           header_begin() + _scopes_data_offset      ; }\n-  address scopes_data_end       () const { return           header_begin() + _scopes_pcs_offset       ; }\n-  PcDesc* scopes_pcs_begin      () const { return (PcDesc*)(header_begin() + _scopes_pcs_offset)      ; }\n-  PcDesc* scopes_pcs_end        () const { return (PcDesc*)(header_begin() + _dependencies_offset)    ; }\n-  address dependencies_begin    () const { return           header_begin() + _dependencies_offset     ; }\n-  address dependencies_end      () const { return           header_begin() + _handler_table_offset    ; }\n-  address handler_table_begin   () const { return           header_begin() + _handler_table_offset    ; }\n-  address handler_table_end     () const { return           header_begin() + _nul_chk_table_offset    ; }\n-  address nul_chk_table_begin   () const { return           header_begin() + _nul_chk_table_offset    ; }\n+\n+  oop*    oops_begin            () const { return (oop*)    data_begin(); }\n+  oop*    oops_end              () const { return (oop*)   (data_begin() + _metadata_offset)          ; }\n+\n+  Metadata** metadata_begin     () const { return (Metadata**) (data_begin() + _metadata_offset)      ; }\n+  Metadata** metadata_end       () const { return (Metadata**) (data_begin() + _dependencies_offset)  ; }\n+\n+  address dependencies_begin    () const { return           data_begin() + _dependencies_offset       ; }\n+  address dependencies_end      () const { return           data_begin() + _scopes_pcs_offset         ; }\n+  PcDesc* scopes_pcs_begin      () const { return (PcDesc*)(data_begin() + _scopes_pcs_offset)        ; }\n+  PcDesc* scopes_pcs_end        () const { return (PcDesc*)(data_begin() + _scopes_data_offset)       ; }\n+  address scopes_data_begin     () const { return           data_begin() + _scopes_data_offset        ; }\n+  address scopes_data_end       () const { return           data_begin() + _handler_table_offset      ; }\n+  address handler_table_begin   () const { return           data_begin() + _handler_table_offset      ; }\n+  address handler_table_end     () const { return           data_begin() + _nul_chk_table_offset      ; }\n+  address nul_chk_table_begin   () const { return           data_begin() + _nul_chk_table_offset      ; }\n@@ -551,5 +556,5 @@\n-  address nul_chk_table_end     () const { return           header_begin() + _speculations_offset     ; }\n-  address speculations_begin    () const { return           header_begin() + _speculations_offset     ; }\n-  address speculations_end      () const { return           header_begin() + _jvmci_data_offset       ; }\n-  address jvmci_data_begin      () const { return           header_begin() + _jvmci_data_offset       ; }\n-  address jvmci_data_end        () const { return           header_begin() + _nmethod_end_offset      ; }\n+  address nul_chk_table_end     () const { return           data_begin() + _speculations_offset       ; }\n+  address speculations_begin    () const { return           data_begin() + _speculations_offset       ; }\n+  address speculations_end      () const { return           data_begin() + _jvmci_data_offset         ; }\n+  address jvmci_data_begin      () const { return           data_begin() + _jvmci_data_offset         ; }\n+  address jvmci_data_end        () const { return           data_end(); }\n@@ -557,1 +562,1 @@\n-  address nul_chk_table_end     () const { return           header_begin() + _nmethod_end_offset      ; }\n+  address nul_chk_table_end     () const { return           data_end(); }\n@@ -597,2 +602,2 @@\n-  address entry_point() const          { return _entry_point;          } \/\/ normal entry point\n-  address verified_entry_point() const { return _verified_entry_point; } \/\/ if klass is correct\n+  address entry_point() const          { return code_begin() + _entry_offset;          } \/\/ normal entry point\n+  address verified_entry_point() const { return code_begin() + _verified_entry_offset; } \/\/ if klass is correct\n@@ -618,3 +623,0 @@\n-  bool is_unlinked() const             { return _is_unlinked; }\n-  void set_is_unlinked()               { assert(!_is_unlinked, \"already unlinked\"); _is_unlinked = true; }\n-\n@@ -680,0 +682,6 @@\n+  bool  is_unlinked() const                       { return _is_unlinked; }\n+  void  set_is_unlinked()                         {\n+     assert(!_is_unlinked, \"already unlinked\");\n+      _is_unlinked = true;\n+  }\n+\n@@ -724,1 +732,0 @@\n-  void set_exception_cache(ExceptionCache *ec)    { _exception_cache = ec; }\n@@ -753,1 +760,1 @@\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) override;\n+  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f);\n@@ -789,5 +796,9 @@\n-  int   osr_entry_bci() const                     { assert(is_osr_method(), \"wrong kind of nmethod\"); return _entry_bci; }\n-  address  osr_entry() const                      { assert(is_osr_method(), \"wrong kind of nmethod\"); return _osr_entry_point; }\n-  void  invalidate_osr_method();\n-  nmethod* osr_link() const                       { return _osr_link; }\n-  void     set_osr_link(nmethod *n)               { _osr_link = n; }\n+  int      osr_entry_bci()    const { assert(is_osr_method(), \"wrong kind of nmethod\"); return _entry_bci; }\n+  address  osr_entry()        const { assert(is_osr_method(), \"wrong kind of nmethod\"); return _osr_entry_point; }\n+  nmethod* osr_link()         const { return _osr_link; }\n+  void     set_osr_link(nmethod *n) { _osr_link = n; }\n+  void     invalidate_osr_method();\n+\n+  int num_stack_arg_slots(bool rounded = true) const {\n+    return rounded ? align_up(_num_stack_arg_slots, 2) : _num_stack_arg_slots;\n+  }\n@@ -802,1 +813,1 @@\n-  void purge(bool free_code_cache_data, bool unregister_nmethod) override;\n+  void purge(bool unregister_nmethod);\n@@ -967,0 +978,1 @@\n+    assert(is_native_method(), \"sanity\");\n@@ -970,0 +982,1 @@\n+    assert(is_native_method(), \"sanity\");\n@@ -974,3 +987,2 @@\n-  static ByteSize verified_entry_point_offset() { return byte_offset_of(nmethod, _verified_entry_point); }\n-  static ByteSize osr_entry_point_offset()      { return byte_offset_of(nmethod, _osr_entry_point); }\n-  static ByteSize state_offset()                { return byte_offset_of(nmethod, _state); }\n+  static ByteSize osr_entry_point_offset() { return byte_offset_of(nmethod, _osr_entry_point); }\n+  static ByteSize state_offset()           { return byte_offset_of(nmethod, _state); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":101,"deletions":89,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -170,2 +170,1 @@\n-\n-  bool equals(const FullMethodName& b) const {\n+  bool operator== (const FullMethodName& b) const {\n@@ -174,2 +173,0 @@\n-\n-  bool operator== (const FullMethodName& other) const { return equals(other); }\n@@ -295,0 +292,8 @@\n+};\n+\n+\/\/ The MemStatTable contains records of memory usage of all compilations. It is printed,\n+\/\/ as memory summary, either with jcmd Compiler.memory, or - if the \"print\" suboption has\n+\/\/ been given with the MemStat compile command - as summary printout at VM exit.\n+\/\/ For any given compiled method, we only keep the memory statistics of the most recent\n+\/\/ compilation, but on a per-compiler basis. If one needs statistics of prior compilations,\n+\/\/ one needs to look into the log produced by the \"print\" suboption.\n@@ -296,2 +301,13 @@\n-  bool equals(const FullMethodName& b) const {\n-    return _method.equals(b);\n+class MemStatTableKey {\n+  const FullMethodName _fmn;\n+  const CompilerType _comptype;\n+public:\n+  MemStatTableKey(FullMethodName fmn, CompilerType comptype) :\n+    _fmn(fmn), _comptype(comptype) {}\n+  MemStatTableKey(const MemStatTableKey& o) :\n+    _fmn(o._fmn), _comptype(o._comptype) {}\n+  bool operator== (const MemStatTableKey& other) const {\n+    return _fmn == other._fmn && _comptype == other._comptype;\n+  }\n+  static unsigned compute_hash(const MemStatTableKey& n) {\n+    return FullMethodName::compute_hash(n._fmn) + (unsigned)n._comptype;\n@@ -302,2 +318,2 @@\n-    public ResourceHashtable<FullMethodName, MemStatEntry*, 7919, AnyObj::C_HEAP,\n-                             mtInternal, FullMethodName::compute_hash>\n+    public ResourceHashtable<MemStatTableKey, MemStatEntry*, 7919, AnyObj::C_HEAP,\n+                             mtInternal, MemStatTableKey::compute_hash>\n@@ -311,2 +327,2 @@\n-\n-    MemStatEntry** pe = get(fmn);\n+    MemStatTableKey key(fmn, comptype);\n+    MemStatEntry** pe = get(key);\n@@ -316,1 +332,1 @@\n-      put(fmn, e);\n+      put(key, e);\n@@ -341,1 +357,1 @@\n-    auto do_f = [&] (const FullMethodName& ignored, MemStatEntry* e) {\n+    auto do_f = [&] (const MemStatTableKey& ignored, MemStatEntry* e) {\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-    if (CompilerOracle::has_option_value(method, CompileCommand::CompileThresholdScaling, threshold_scaling)) {\n+    if (CompilerOracle::has_option_value(method, CompileCommandEnum::CompileThresholdScaling, threshold_scaling)) {\n@@ -270,1 +270,1 @@\n-    if (CompilerOracle::has_option_value(method, CompileCommand::CompileThresholdScaling, threshold_scaling)) {\n+    if (CompilerOracle::has_option_value(method, CompileCommandEnum::CompileThresholdScaling, threshold_scaling)) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1552,1 +1552,1 @@\n-  if (excluded || (CompilerOracle::has_option_value(method, CompileCommand::CompileThresholdScaling, scale) && scale == 0)) {\n+  if (excluded || (CompilerOracle::has_option_value(method, CompileCommandEnum::CompileThresholdScaling, scale) && scale == 0)) {\n@@ -1796,1 +1796,1 @@\n-    blob->purge(true \/* free_code_cache_data *\/, true \/* unregister_nmethod *\/);\n+    blob->purge();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-enum RTMState {\n+enum RTMState: u1 {\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-#define init_default_cc(name, type, dvalue, cc_flag) { type v; if (!_modified[name##Index] && CompileCommand::cc_flag != CompileCommand::Unknown && CompilerOracle::has_option_value(method, CompileCommand::cc_flag, v) && v != this->name##Option) { set.cloned()->name##Option = v; } }\n+#define init_default_cc(name, type, dvalue, cc_flag) { type v; if (!_modified[name##Index] && CompileCommandEnum::cc_flag != CompileCommandEnum::Unknown && CompilerOracle::has_option_value(method, CompileCommandEnum::cc_flag, v) && v != this->name##Option) { set.cloned()->name##Option = v; } }\n@@ -441,1 +441,1 @@\n-      if (CompilerOracle::has_option_value(method, CompileCommand::TraceAutoVectorization, option)) {\n+      if (CompilerOracle::has_option_value(method, CompileCommandEnum::TraceAutoVectorization, option)) {\n@@ -451,1 +451,1 @@\n-      if (CompilerOracle::has_option_value(method, CompileCommand::PrintIdealPhase, option)) {\n+      if (CompilerOracle::has_option_value(method, CompileCommandEnum::PrintIdealPhase, option)) {\n@@ -467,1 +467,1 @@\n-        CompilerOracle::has_option_value(method, CompileCommand::ControlIntrinsic, option_value)) {\n+        CompilerOracle::has_option_value(method, CompileCommandEnum::ControlIntrinsic, option_value)) {\n@@ -487,1 +487,1 @@\n-        CompilerOracle::has_option_value(method, CompileCommand::DisableIntrinsic, option_value)) {\n+        CompilerOracle::has_option_value(method, CompileCommandEnum::DisableIntrinsic, option_value)) {\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"compiler\/compilerOracle.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-static enum OptionType option2type(enum CompileCommand option) {\n+static enum OptionType option2type(CompileCommandEnum option) {\n@@ -71,1 +71,1 @@\n-static const char* option2name(enum CompileCommand option) {\n+static const char* option2name(CompileCommandEnum option) {\n@@ -109,1 +109,1 @@\n-static bool option_filter[static_cast<int>(CompileCommand::Unknown) + 1] = { 0 };\n+static bool option_filter[static_cast<int>(CompileCommandEnum::Unknown) + 1] = { 0 };\n@@ -111,2 +111,2 @@\n-static void command_set_in_filter(enum CompileCommand option) {\n-  assert(option != CompileCommand::Unknown, \"sanity\");\n+static void command_set_in_filter(CompileCommandEnum option) {\n+  assert(option != CompileCommandEnum::Unknown, \"sanity\");\n@@ -115,3 +115,3 @@\n-  if ((option != CompileCommand::DontInline) &&\n-      (option != CompileCommand::Inline) &&\n-      (option != CompileCommand::Log)) {\n+  if ((option != CompileCommandEnum::DontInline) &&\n+      (option != CompileCommandEnum::Inline) &&\n+      (option != CompileCommandEnum::Log)) {\n@@ -123,1 +123,1 @@\n-static bool has_command(enum CompileCommand option) {\n+static bool has_command(CompileCommandEnum option) {\n@@ -130,1 +130,1 @@\n-  enum CompileCommand _option;\n+  CompileCommandEnum _option;\n@@ -143,1 +143,1 @@\n-    _option(CompileCommand::Unknown) {\n+    _option(CompileCommandEnum::Unknown) {\n@@ -149,1 +149,1 @@\n-  TypedMethodOptionMatcher* match(const methodHandle &method, enum CompileCommand option);\n+  TypedMethodOptionMatcher* match(const methodHandle &method, CompileCommandEnum option);\n@@ -151,1 +151,1 @@\n-  void init(enum CompileCommand option, TypedMethodOptionMatcher* next) {\n+  void init(CompileCommandEnum option, TypedMethodOptionMatcher* next) {\n@@ -164,1 +164,1 @@\n-  enum CompileCommand option() { return _option; }\n+  CompileCommandEnum option() { return _option; }\n@@ -289,1 +289,1 @@\n-TypedMethodOptionMatcher* TypedMethodOptionMatcher::match(const methodHandle& method, enum CompileCommand option) {\n+TypedMethodOptionMatcher* TypedMethodOptionMatcher::match(const methodHandle& method, CompileCommandEnum option) {\n@@ -304,1 +304,1 @@\n-                             enum CompileCommand option,\n+                             CompileCommandEnum option,\n@@ -307,1 +307,1 @@\n-  if (option == CompileCommand::Log && !LogCompilation) {\n+  if (option == CompileCommandEnum::Log && !LogCompilation) {\n@@ -313,1 +313,1 @@\n-  if (option == CompileCommand::Blackhole && !UnlockExperimentalVMOptions) {\n+  if (option == CompileCommandEnum::Blackhole && !UnlockExperimentalVMOptions) {\n@@ -336,1 +336,1 @@\n-bool CompilerOracle::has_option_value(const methodHandle& method, enum CompileCommand option, T& value) {\n+bool CompilerOracle::has_option_value(const methodHandle& method, CompileCommandEnum option, T& value) {\n@@ -351,2 +351,2 @@\n-static bool resolve_inlining_predicate(enum CompileCommand option, const methodHandle& method) {\n-  assert(option == CompileCommand::Inline || option == CompileCommand::DontInline, \"Sanity\");\n+static bool resolve_inlining_predicate(CompileCommandEnum option, const methodHandle& method) {\n+  assert(option == CompileCommandEnum::Inline || option == CompileCommandEnum::DontInline, \"Sanity\");\n@@ -355,2 +355,2 @@\n-  bool has_inline = CompilerOracle::has_option_value(method, CompileCommand::Inline, v1);\n-  bool has_dnotinline = CompilerOracle::has_option_value(method, CompileCommand::DontInline, v2);\n+  bool has_inline = CompilerOracle::has_option_value(method, CompileCommandEnum::Inline, v1);\n+  bool has_dnotinline = CompilerOracle::has_option_value(method, CompileCommandEnum::DontInline, v2);\n@@ -362,1 +362,1 @@\n-      enum CompileCommand last_one = CompileCommand::Unknown;\n+      CompileCommandEnum last_one = CompileCommandEnum::Unknown;\n@@ -366,1 +366,1 @@\n-        if (last_one == CompileCommand::Inline || last_one == CompileCommand::DontInline) {\n+        if (last_one == CompileCommandEnum::Inline || last_one == CompileCommandEnum::DontInline) {\n@@ -377,1 +377,1 @@\n-      return option == CompileCommand::Inline ? v1 : v2;\n+      return option == CompileCommandEnum::Inline ? v1 : v2;\n@@ -380,1 +380,1 @@\n-    if (option == CompileCommand::Inline) {\n+    if (option == CompileCommandEnum::Inline) {\n@@ -388,1 +388,1 @@\n-static bool check_predicate(enum CompileCommand option, const methodHandle& method) {\n+static bool check_predicate(CompileCommandEnum option, const methodHandle& method) {\n@@ -390,1 +390,1 @@\n-  if (option == CompileCommand::Inline || option == CompileCommand::DontInline) {\n+  if (option == CompileCommandEnum::Inline || option == CompileCommandEnum::DontInline) {\n@@ -406,5 +406,5 @@\n-template bool CompilerOracle::has_option_value<intx>(const methodHandle& method, enum CompileCommand option, intx& value);\n-template bool CompilerOracle::has_option_value<uintx>(const methodHandle& method, enum CompileCommand option, uintx& value);\n-template bool CompilerOracle::has_option_value<bool>(const methodHandle& method, enum CompileCommand option, bool& value);\n-template bool CompilerOracle::has_option_value<ccstr>(const methodHandle& method, enum CompileCommand option, ccstr& value);\n-template bool CompilerOracle::has_option_value<double>(const methodHandle& method, enum CompileCommand option, double& value);\n+template bool CompilerOracle::has_option_value<intx>(const methodHandle& method, CompileCommandEnum option, intx& value);\n+template bool CompilerOracle::has_option_value<uintx>(const methodHandle& method, CompileCommandEnum option, uintx& value);\n+template bool CompilerOracle::has_option_value<bool>(const methodHandle& method, CompileCommandEnum option, bool& value);\n+template bool CompilerOracle::has_option_value<ccstr>(const methodHandle& method, CompileCommandEnum option, ccstr& value);\n+template bool CompilerOracle::has_option_value<double>(const methodHandle& method, CompileCommandEnum option, double& value);\n@@ -413,1 +413,1 @@\n-bool CompilerOracle::option_matches_type(enum CompileCommand option, T& value) {\n+bool CompilerOracle::option_matches_type(CompileCommandEnum option, T& value) {\n@@ -424,5 +424,5 @@\n-template bool CompilerOracle::option_matches_type<intx>(enum CompileCommand option, intx& value);\n-template bool CompilerOracle::option_matches_type<uintx>(enum CompileCommand option, uintx& value);\n-template bool CompilerOracle::option_matches_type<bool>(enum CompileCommand option, bool& value);\n-template bool CompilerOracle::option_matches_type<ccstr>(enum CompileCommand option, ccstr& value);\n-template bool CompilerOracle::option_matches_type<double>(enum CompileCommand option, double& value);\n+template bool CompilerOracle::option_matches_type<intx>(CompileCommandEnum option, intx& value);\n+template bool CompilerOracle::option_matches_type<uintx>(CompileCommandEnum option, uintx& value);\n+template bool CompilerOracle::option_matches_type<bool>(CompileCommandEnum option, bool& value);\n+template bool CompilerOracle::option_matches_type<ccstr>(CompileCommandEnum option, ccstr& value);\n+template bool CompilerOracle::option_matches_type<double>(CompileCommandEnum option, double& value);\n@@ -430,1 +430,1 @@\n-bool CompilerOracle::has_option(const methodHandle& method, enum CompileCommand option) {\n+bool CompilerOracle::has_option(const methodHandle& method, CompileCommandEnum option) {\n@@ -437,1 +437,1 @@\n-  if (check_predicate(CompileCommand::Exclude, method)) {\n+  if (check_predicate(CompileCommandEnum::Exclude, method)) {\n@@ -440,2 +440,2 @@\n-  if (has_command(CompileCommand::CompileOnly)) {\n-    return !check_predicate(CompileCommand::CompileOnly, method);\n+  if (has_command(CompileCommandEnum::CompileOnly)) {\n+    return !check_predicate(CompileCommandEnum::CompileOnly, method);\n@@ -447,1 +447,1 @@\n-  return (check_predicate(CompileCommand::Inline, method));\n+  return (check_predicate(CompileCommandEnum::Inline, method));\n@@ -451,1 +451,1 @@\n-  return check_predicate(CompileCommand::DontInline, method) || check_predicate(CompileCommand::Exclude, method);\n+  return check_predicate(CompileCommandEnum::DontInline, method) || check_predicate(CompileCommandEnum::Exclude, method);\n@@ -455,1 +455,1 @@\n-  return check_predicate(CompileCommand::Print, method);\n+  return check_predicate(CompileCommandEnum::Print, method);\n@@ -459,1 +459,1 @@\n-  return has_command(CompileCommand::Print);\n+  return has_command(CompileCommandEnum::Print);\n@@ -464,1 +464,1 @@\n-  return has_command(CompileCommand::MemStat) || has_command(CompileCommand::MemLimit);\n+  return has_command(CompileCommandEnum::MemStat) || has_command(CompileCommandEnum::MemLimit);\n@@ -473,1 +473,1 @@\n-  if (!has_command(CompileCommand::Log)) {\n+  if (!has_command(CompileCommandEnum::Log)) {\n@@ -476,1 +476,1 @@\n-  return (check_predicate(CompileCommand::Log, method));\n+  return (check_predicate(CompileCommandEnum::Log, method));\n@@ -480,1 +480,1 @@\n-  return check_predicate(CompileCommand::Break, method);\n+  return check_predicate(CompileCommandEnum::Break, method);\n@@ -484,1 +484,1 @@\n-  if (!check_predicate(CompileCommand::Blackhole, method)) {\n+  if (!check_predicate(CompileCommandEnum::Blackhole, method)) {\n@@ -514,2 +514,2 @@\n-static enum CompileCommand match_option_name(const char* line, int* bytes_read, char* errorbuf, int bufsize) {\n-  assert(ARRAY_SIZE(option_names) == static_cast<int>(CompileCommand::Count), \"option_names size mismatch\");\n+static CompileCommandEnum match_option_name(const char* line, int* bytes_read, char* errorbuf, int bufsize) {\n+  assert(ARRAY_SIZE(option_names) == static_cast<int>(CompileCommandEnum::Count), \"option_names size mismatch\");\n@@ -523,1 +523,1 @@\n-        return static_cast<enum CompileCommand>(i);\n+        return static_cast<CompileCommandEnum>(i);\n@@ -528,1 +528,1 @@\n-  return CompileCommand::Unknown;\n+  return CompileCommandEnum::Unknown;\n@@ -532,1 +532,1 @@\n-enum CompileCommand CompilerOracle::parse_option_name(const char* line) {\n+CompileCommandEnum CompilerOracle::parse_option_name(const char* line) {\n@@ -535,1 +535,1 @@\n-      return static_cast<enum CompileCommand>(i);\n+      return static_cast<CompileCommandEnum>(i);\n@@ -538,1 +538,1 @@\n-  return CompileCommand::Unknown;\n+  return CompileCommandEnum::Unknown;\n@@ -558,1 +558,1 @@\n-static void print_option(enum CompileCommand option, const char* name, enum OptionType type) {\n+static void print_option(CompileCommandEnum option, const char* name, enum OptionType type) {\n@@ -567,1 +567,1 @@\n-#define enum_of_options(option, name, ctype) print_option(CompileCommand::option, name, OptionType::ctype);\n+#define enum_of_options(option, name, ctype) print_option(CompileCommandEnum::option, name, OptionType::ctype);\n@@ -702,1 +702,1 @@\n-        TypedMethodOptionMatcher* matcher, enum CompileCommand option, char* errorbuf, const int buf_size) {\n+        TypedMethodOptionMatcher* matcher, CompileCommandEnum option, char* errorbuf, const int buf_size) {\n@@ -711,1 +711,1 @@\n-    if (option == CompileCommand::MemLimit) {\n+    if (option == CompileCommandEnum::MemLimit) {\n@@ -729,1 +729,1 @@\n-    if (option == CompileCommand::MemStat) {\n+    if (option == CompileCommandEnum::MemStat) {\n@@ -772,2 +772,2 @@\n-      if (option == CompileCommand::ControlIntrinsic || option == CompileCommand::DisableIntrinsic) {\n-        ControlIntrinsicValidator validator(value, (option == CompileCommand::DisableIntrinsic));\n+      if (option == CompileCommandEnum::ControlIntrinsic || option == CompileCommandEnum::DisableIntrinsic) {\n+        ControlIntrinsicValidator validator(value, (option == CompileCommandEnum::DisableIntrinsic));\n@@ -780,1 +780,1 @@\n-      else if (option == CompileCommand::TraceAutoVectorization) {\n+      else if (option == CompileCommandEnum::TraceAutoVectorization) {\n@@ -786,1 +786,1 @@\n-      } else if (option == CompileCommand::PrintIdealPhase) {\n+      } else if (option == CompileCommandEnum::PrintIdealPhase) {\n@@ -792,1 +792,1 @@\n-      } else if (option == CompileCommand::TestOptionList) {\n+      } else if (option == CompileCommandEnum::TestOptionList) {\n@@ -865,2 +865,2 @@\n-    enum CompileCommand option = match_option_name(option_buf, &bytes_read2, errorbuf, buf_size);\n-    if (option == CompileCommand::Unknown) {\n+    CompileCommandEnum option = match_option_name(option_buf, &bytes_read2, errorbuf, buf_size);\n+    if (option == CompileCommandEnum::Unknown) {\n@@ -917,1 +917,1 @@\n-  enum CompileCommand option = match_option_name(line, &bytes_read, error_buf, sizeof(error_buf));\n+  CompileCommandEnum option = match_option_name(line, &bytes_read, error_buf, sizeof(error_buf));\n@@ -921,1 +921,1 @@\n-  if (option == CompileCommand::Unknown) {\n+  if (option == CompileCommandEnum::Unknown) {\n@@ -926,1 +926,1 @@\n-  if (option == CompileCommand::Quiet) {\n+  if (option == CompileCommandEnum::Quiet) {\n@@ -931,1 +931,1 @@\n-  if (option == CompileCommand::Help) {\n+  if (option == CompileCommandEnum::Help) {\n@@ -936,1 +936,1 @@\n-  if (option == CompileCommand::Option) {\n+  if (option == CompileCommandEnum::Option) {\n@@ -978,2 +978,2 @@\n-        enum CompileCommand option = match_option_name(option_type, &bytes_read, error_buf, sizeof(error_buf));\n-        if (option == CompileCommand::Unknown) {\n+        CompileCommandEnum option = match_option_name(option_type, &bytes_read, error_buf, sizeof(error_buf));\n+        if (option == CompileCommandEnum::Unknown) {\n@@ -1016,1 +1016,1 @@\n-      } else if (option == CompileCommand::MemStat) {\n+      } else if (option == CompileCommandEnum::MemStat) {\n@@ -1128,1 +1128,1 @@\n-  if (has_command(CompileCommand::Print)) {\n+  if (has_command(CompileCommandEnum::Print)) {\n@@ -1152,1 +1152,1 @@\n-        register_command(matcher, CompileCommand::CompileOnly, true);\n+        register_command(matcher, CompileCommandEnum::CompileOnly, true);\n@@ -1167,1 +1167,1 @@\n-enum CompileCommand CompilerOracle::string_to_option(const char* name) {\n+CompileCommandEnum CompilerOracle::string_to_option(const char* name) {\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-enum class CompileCommand {\n+enum class CompileCommandEnum : int {\n@@ -126,1 +126,1 @@\n-  static void print_command(enum CompileCommand option, const char* name, enum OptionType type);\n+  static void print_command(CompileCommandEnum option, const char* name, enum OptionType type);\n@@ -168,1 +168,1 @@\n-  static bool has_option(const methodHandle& method, enum CompileCommand option);\n+  static bool has_option(const methodHandle& method, CompileCommandEnum option);\n@@ -173,1 +173,1 @@\n-  static bool has_option_value(const methodHandle& method, enum CompileCommand option, T& value);\n+  static bool has_option_value(const methodHandle& method, CompileCommandEnum option, T& value);\n@@ -177,1 +177,1 @@\n-  static bool option_matches_type(enum CompileCommand option, T& value);\n+  static bool option_matches_type(CompileCommandEnum option, T& value);\n@@ -188,2 +188,2 @@\n-  \/\/ returns CompileCommand::Unknown on names not matching an option.\n-  static enum CompileCommand string_to_option(const char* name);\n+  \/\/ returns CompileCommandEnum::Unknown on names not matching an option.\n+  static CompileCommandEnum string_to_option(const char* name);\n@@ -192,2 +192,2 @@\n-  \/\/ returns CompileCommand::Unknown if name is not an option.\n-  static enum CompileCommand parse_option_name(const char* name);\n+  \/\/ returns CompileCommandEnum::Unknown if name is not an option.\n+  static CompileCommandEnum parse_option_name(const char* name);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-        CompileCommand::Unknown != CompilerOracle::parse_option_name(method_name)) &&\n+        CompileCommandEnum::Unknown != CompilerOracle::parse_option_name(method_name)) &&\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-void G1BarrierSet::invalidate(JavaThread* thread, MemRegion mr) {\n+void G1BarrierSet::write_region(JavaThread* thread, MemRegion mr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-  void invalidate(JavaThread* thread, MemRegion mr);\n-\n@@ -76,4 +74,2 @@\n-  inline void invalidate(MemRegion mr);\n-  inline void write_region(JavaThread* thread, MemRegion mr);\n-\n-  inline void write_ref_array_work(MemRegion mr);\n+  inline void write_region(MemRegion mr);\n+  void write_region(JavaThread* thread, MemRegion mr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,10 +71,2 @@\n-inline void G1BarrierSet::invalidate(MemRegion mr) {\n-  invalidate(JavaThread::current(), mr);\n-}\n-\n-inline void G1BarrierSet::write_region(JavaThread* thread, MemRegion mr) {\n-  invalidate(thread, mr);\n-}\n-\n-inline void G1BarrierSet::write_ref_array_work(MemRegion mr) {\n-  invalidate(mr);\n+inline void G1BarrierSet::write_region(MemRegion mr) {\n+  write_region(JavaThread::current(), mr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.inline.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -46,0 +46,19 @@\n+void G1BlockOffsetTable::set_offset_array(uint8_t* addr, uint8_t offset) {\n+  check_address(addr, \"Block offset table address out of range\");\n+  Atomic::store(addr, offset);\n+}\n+\n+void G1BlockOffsetTable::set_offset_array(uint8_t* addr, HeapWord* high, HeapWord* low) {\n+  assert(high >= low, \"addresses out of order\");\n+  size_t offset = pointer_delta(high, low);\n+  check_offset(offset, \"offset too large\");\n+  set_offset_array(addr, (uint8_t)offset);\n+}\n+\n+void G1BlockOffsetTable::set_offset_array(uint8_t* left, uint8_t* right, uint8_t offset) {\n+  check_address(right, \"Right block offset table address out of range\");\n+  assert(left <= right, \"indexes out of order\");\n+  size_t num_cards = right - left + 1;\n+  memset_with_concurrent_readers(left, offset, num_cards);\n+}\n+\n@@ -214,10 +233,11 @@\n-  for (uint8_t* j = offset_card + 1; j <= end_card; j++) {\n-    assert(offset_array(j) > 0 &&\n-           offset_array(j) <= (uint8_t) (CardTable::card_size_in_words() + BOTConstants::N_powers - 1),\n-           \"offset array should have been set - \"\n-           \"%u not > 0 OR %u not <= %u\",\n-           (uint) offset_array(j),\n-           (uint) offset_array(j),\n-           (uint) (CardTable::card_size_in_words() + BOTConstants::N_powers - 1));\n-  }\n-#endif\n+\n+  G1BlockOffsetTable::verify_for_block(blk_start, blk_end);\n+#endif \/\/ ASSERT\n+}\n+\n+#ifdef ASSERT\n+void G1BlockOffsetTable::verify_offset(uint8_t* card_index, uint8_t upper_boundary) const {\n+  assert(offset_array(card_index) <= upper_boundary,\n+         \"Offset %u should not be larger than upper boundary %u.\",\n+         (uint) offset_array(card_index),\n+         (uint) upper_boundary);\n@@ -226,4 +246,2 @@\n-void G1BlockOffsetTable::verify(const HeapRegion* hr) const {\n-  assert(hr->bottom() < hr->top(), \"Only non-empty regions should be verified.\");\n-  uint8_t* start_card = entry_for_addr(hr->bottom());\n-  uint8_t* end_card = entry_for_addr(hr->top() - 1);\n+void G1BlockOffsetTable::verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const {\n+  assert(is_crossing_card_boundary(blk_start, blk_end), \"precondition\");\n@@ -231,22 +249,4 @@\n-  for (uint8_t* current_card = start_card; current_card < end_card; current_card++) {\n-    uint8_t entry = offset_array(current_card);\n-    if (entry < CardTable::card_size_in_words()) {\n-      \/\/ The entry should point to an object before the current card. Verify that\n-      \/\/ it is possible to walk from that object in to the current card by just\n-      \/\/ iterating over the objects following it.\n-      HeapWord* card_address = addr_for_entry(current_card);\n-      HeapWord* obj_end = card_address - entry;\n-      while (obj_end < card_address) {\n-        HeapWord* obj = obj_end;\n-        size_t obj_size = hr->block_size(obj);\n-        obj_end = obj + obj_size;\n-        guarantee(obj_end > obj && obj_end <= hr->top(),\n-                  \"Invalid object end. obj: \" PTR_FORMAT \" obj_size: \" SIZE_FORMAT \" obj_end: \" PTR_FORMAT \" top: \" PTR_FORMAT,\n-                  p2i(obj), obj_size, p2i(obj_end), p2i(hr->top()));\n-      }\n-    } else {\n-      \/\/ Because we refine the BOT based on which cards are dirty there is not much we can verify here.\n-      \/\/ We need to make sure that we are going backwards and that we don't pass the start of the\n-      \/\/ corresponding heap region. But that is about all we can verify.\n-      size_t backskip = BOTConstants::entry_to_cards_back(entry);\n-      guarantee(backskip >= 1, \"Must be going back at least one card.\");\n+  uint8_t* start_card = entry_for_addr(align_up_by_card_size(blk_start));\n+  uint8_t* end_card = entry_for_addr(blk_end - 1);\n+  \/\/ Check cards in [start_card, end_card]\n+  verify_offset(start_card, CardTable::card_size_in_words());\n@@ -254,4 +254,5 @@\n-      size_t max_backskip = current_card - start_card;\n-      guarantee(backskip <= max_backskip,\n-                \"Going backwards beyond the start_card. start_card: \" SIZE_FORMAT \" current_card: \" SIZE_FORMAT \" backskip: \" SIZE_FORMAT,\n-                p2i(start_card), p2i(current_card), backskip);\n+  for (uint8_t* current_card = start_card + 1; current_card <= end_card; ++current_card) {\n+    assert(offset_array(current_card) > 0,\n+           \"Offset %u is not larger than 0.\",\n+           (uint) offset_array(current_card));\n+    verify_offset(current_card, (uint8_t) (CardTable::card_size_in_words() + BOTConstants::N_powers - 1));\n@@ -259,4 +260,6 @@\n-      HeapWord* backskip_address = addr_for_entry(current_card - backskip);\n-      guarantee(backskip_address >= hr->bottom(),\n-                \"Going backwards beyond bottom of the region: bottom: \" PTR_FORMAT \", backskip_address: \" PTR_FORMAT,\n-                p2i(hr->bottom()), p2i(backskip_address));\n+    uint8_t* prev  = current_card - 1;\n+    uint8_t* value = current_card;\n+    if (offset_array(prev) != offset_array(value)) {\n+      assert(offset_array(value) >= offset_array(prev), \"monotonic\");\n+      size_t n_cards_back = BOTConstants::entry_to_cards_back(offset_array(value));\n+      assert(start_card == (current_card - n_cards_back), \"inv\");\n@@ -266,0 +269,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":48,"deletions":44,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -35,3 +35,0 @@\n-\/\/ Forward declarations\n-class HeapRegion;\n-\n@@ -62,1 +59,0 @@\n-  inline void set_offset_array_raw(uint8_t* addr, uint8_t offset);\n@@ -69,0 +65,6 @@\n+  \/\/ Mapping from address to object start array entry\n+  inline uint8_t* entry_for_addr(const void* const p) const;\n+\n+  \/\/ Mapping from object start array entry to address of first word\n+  inline HeapWord* addr_for_entry(const uint8_t* const p) const;\n+\n@@ -80,0 +82,3 @@\n+  void verify_offset(uint8_t* card_index, uint8_t upper) const NOT_DEBUG_RETURN;\n+  void verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const NOT_DEBUG_RETURN;\n+\n@@ -102,6 +107,0 @@\n-  \/\/ Mapping from address to object start array entry\n-  uint8_t* entry_for_addr(const void* const p) const;\n-\n-  \/\/ Mapping from object start array entry to address of first word\n-  HeapWord* addr_for_entry(const uint8_t* const p) const;\n-\n@@ -115,2 +114,0 @@\n-  void verify(const HeapRegion* hr) const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -57,24 +57,0 @@\n-void G1BlockOffsetTable::set_offset_array_raw(uint8_t* addr, uint8_t offset) {\n-  Atomic::store(addr, offset);\n-}\n-\n-void G1BlockOffsetTable::set_offset_array(uint8_t* addr, uint8_t offset) {\n-  check_address(addr, \"Block offset table address out of range\");\n-  set_offset_array_raw(addr, offset);\n-}\n-\n-void G1BlockOffsetTable::set_offset_array(uint8_t* addr, HeapWord* high, HeapWord* low) {\n-  check_address(addr, \"Block offset table address out of range\");\n-  assert(high >= low, \"addresses out of order\");\n-  size_t offset = pointer_delta(high, low);\n-  check_offset(offset, \"offset too large\");\n-  set_offset_array(addr, (uint8_t)offset);\n-}\n-\n-void G1BlockOffsetTable::set_offset_array(uint8_t* left, uint8_t* right, uint8_t offset) {\n-  check_address(right, \"Right block offset table address out of range\");\n-  assert(left <= right, \"indexes out of order\");\n-  size_t num_cards = right - left + 1;\n-  memset_with_concurrent_readers(left, offset, num_cards);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -872,1 +872,1 @@\n-    if (r->is_old_or_humongous() && !r->is_collection_set_candidate()) {\n+    if (r->is_old_or_humongous() && !r->is_collection_set_candidate() && !r->in_collection_set()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -537,1 +537,1 @@\n-  trace_time(\"Serial Rebuild Free List \", _recorded_serial_rebuild_freelist_time_ms);\n+  trace_time(\"Serial Rebuild Free List\", _recorded_serial_rebuild_freelist_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,1 +624,5 @@\n-    if (_failures->count() >= G1MaxVerifyFailures) {\n+    \/\/ Check for null references first - they are fairly common and since there is\n+    \/\/ nothing to do for them anyway (they can't fail verification), it makes sense\n+    \/\/ to handle them first.\n+    T heap_oop = RawAccess<>::oop_load(p);\n+    if (CompressedOops::is_null(heap_oop)) {\n@@ -628,2 +632,1 @@\n-    T heap_oop = RawAccess<>::oop_load(p);\n-    if (CompressedOops::is_null(heap_oop)) {\n+    if (_failures->count() >= G1MaxVerifyFailures) {\n@@ -632,0 +635,1 @@\n+\n@@ -698,5 +702,0 @@\n-  \/\/ Only regions in old generation contain valid BOT.\n-  if (!is_empty() && !is_young()) {\n-    _bot->verify(this);\n-  }\n-\n@@ -728,4 +727,0 @@\n-void HeapRegion::update_bot_for_block(HeapWord* start, HeapWord* end) {\n-  _bot->update_for_block(start, end);\n-}\n-\n@@ -745,1 +740,1 @@\n-    update_bot_for_obj(address, word_size);\n+    update_bot_for_block(address, address + word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -170,3 +170,0 @@\n-  \/\/ Update BOT if this obj is the first entering a new card (i.e. crossing the card boundary).\n-  inline void update_bot_for_obj(HeapWord* obj_start, size_t obj_size);\n-\n@@ -175,1 +172,1 @@\n-  void update_bot_for_block(HeapWord* start, HeapWord* end);\n+  inline void update_bot_for_block(HeapWord* start, HeapWord* end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -256,7 +256,3 @@\n-inline void HeapRegion::update_bot_for_obj(HeapWord* obj_start, size_t obj_size) {\n-  assert(is_old(), \"should only do BOT updates for old regions\");\n-\n-  HeapWord* obj_end = obj_start + obj_size;\n-\n-  assert(is_in(obj_start), \"obj_start must be in this region: \" HR_FORMAT\n-         \" obj_start \" PTR_FORMAT \" obj_end \" PTR_FORMAT,\n+inline void HeapRegion::update_bot_for_block(HeapWord* start, HeapWord* end) {\n+  assert(is_in(start), \"The start address must be in this region: \" HR_FORMAT\n+         \" start \" PTR_FORMAT \" end \" PTR_FORMAT,\n@@ -264,1 +260,1 @@\n-         p2i(obj_start), p2i(obj_end));\n+         p2i(start), p2i(end));\n@@ -266,1 +262,1 @@\n-  _bot->update_for_block(obj_start, obj_end);\n+  _bot->update_for_block(start, end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -230,2 +230,2 @@\n-    if (m.is_marked()) {\n-      forwardee = cast_to_oop(m.decode_pointer());\n+    if (m.is_forwarded()) {\n+      forwardee = m.forwardee();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,2 +214,2 @@\n-  if (m.is_marked()) {\n-    obj = cast_to_oop(m.decode_pointer());\n+  if (m.is_forwarded()) {\n+    obj = m.forwardee();\n@@ -447,1 +447,1 @@\n-  region->update_bot_for_obj(obj_start, word_sz);\n+  region->update_bot_for_block(obj_start, obj_start + word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -487,7 +487,2 @@\n-\n-  \/\/ Must be before collection set calculation, requires collection set to not\n-  \/\/ be calculated yet.\n-  if (collector_state()->in_concurrent_start_gc()) {\n-    concurrent_mark()->pre_concurrent_start(_gc_cause);\n-  }\n-\n+  \/\/ Flush various data in thread-local buffers to be able to determine the collection\n+  \/\/ set\n@@ -504,0 +499,4 @@\n+  if (collector_state()->in_concurrent_start_gc()) {\n+    concurrent_mark()->pre_concurrent_start(_gc_cause);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+\/\/ - Flush pin count cache (Java threads)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -645,0 +645,32 @@\n+size_t ParallelCompactData::live_words_in_space(const MutableSpace* space,\n+                                                HeapWord** full_region_prefix_end) {\n+  size_t cur_region = addr_to_region_idx(space->bottom());\n+  const size_t end_region = addr_to_region_idx(region_align_up(space->top()));\n+  size_t live_words = 0;\n+  if (full_region_prefix_end == nullptr) {\n+    for (\/* empty *\/; cur_region < end_region; ++cur_region) {\n+      live_words += _region_data[cur_region].data_size();\n+    }\n+  } else {\n+    bool first_set = false;\n+    for (\/* empty *\/; cur_region < end_region; ++cur_region) {\n+      size_t live_words_in_region = _region_data[cur_region].data_size();\n+      if (!first_set && live_words_in_region < RegionSize) {\n+        *full_region_prefix_end = region_to_addr(cur_region);\n+        first_set = true;\n+      }\n+      live_words += live_words_in_region;\n+    }\n+    if (!first_set) {\n+      \/\/ All regions are full of live objs.\n+      assert(is_region_aligned(space->top()), \"inv\");\n+      *full_region_prefix_end = space->top();\n+    }\n+    assert(*full_region_prefix_end != nullptr, \"postcondition\");\n+    assert(is_region_aligned(*full_region_prefix_end), \"inv\");\n+    assert(*full_region_prefix_end >= space->bottom(), \"in-range\");\n+    assert(*full_region_prefix_end <= space->top(), \"in-range\");\n+  }\n+  return live_words;\n+}\n+\n@@ -985,44 +1017,2 @@\n-ParallelCompactData::RegionData*\n-PSParallelCompact::first_dead_space_region(const RegionData* beg,\n-                                           const RegionData* end)\n-{\n-  const size_t region_size = ParallelCompactData::RegionSize;\n-  ParallelCompactData& sd = summary_data();\n-  size_t left = sd.region(beg);\n-  size_t right = end > beg ? sd.region(end) - 1 : left;\n-\n-  \/\/ Binary search.\n-  while (left < right) {\n-    \/\/ Equivalent to (left + right) \/ 2, but does not overflow.\n-    const size_t middle = left + (right - left) \/ 2;\n-    RegionData* const middle_ptr = sd.region(middle);\n-    HeapWord* const dest = middle_ptr->destination();\n-    HeapWord* const addr = sd.region_to_addr(middle);\n-    assert(dest != nullptr, \"sanity\");\n-    assert(dest <= addr, \"must move left\");\n-\n-    if (middle > left && dest < addr) {\n-      right = middle - 1;\n-    } else if (middle < right && middle_ptr->data_size() == region_size) {\n-      left = middle + 1;\n-    } else {\n-      return middle_ptr;\n-    }\n-  }\n-  return sd.region(left);\n-}\n-\n-\/\/ Return the address of the end of the dense prefix, a.k.a. the start of the\n-\/\/ compacted region.  The address is always on a region boundary.\n-\/\/\n-\/\/ Completely full regions at the left are skipped, since no compaction can\n-\/\/ occur in those regions.  Then the maximum amount of dead wood to allow is\n-\/\/ computed, based on the density (amount live \/ capacity) of the generation;\n-\/\/ the region with approximately that amount of dead space to the left is\n-\/\/ identified as the limit region.  Regions between the last completely full\n-\/\/ region and the limit region are scanned and the one that has the best\n-\/\/ (maximum) reclaimed_ratio() is selected.\n-HeapWord*\n-PSParallelCompact::compute_dense_prefix(const SpaceId id,\n-                                        bool maximum_compaction)\n-{\n+HeapWord* PSParallelCompact::compute_dense_prefix_for_old_space(MutableSpace* old_space,\n+                                                                HeapWord* full_region_prefix_end) {\n@@ -1032,32 +1022,0 @@\n-  const MutableSpace* const space = _space_info[id].space();\n-  HeapWord* const top = space->top();\n-  HeapWord* const top_aligned_up = sd.region_align_up(top);\n-  HeapWord* const new_top = _space_info[id].new_top();\n-  HeapWord* const new_top_aligned_up = sd.region_align_up(new_top);\n-  HeapWord* const bottom = space->bottom();\n-  const RegionData* const beg_cp = sd.addr_to_region_ptr(bottom);\n-  const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);\n-  const RegionData* const new_top_cp =\n-    sd.addr_to_region_ptr(new_top_aligned_up);\n-\n-  \/\/ Skip full regions at the beginning of the space--they are necessarily part\n-  \/\/ of the dense prefix.\n-  const RegionData* const full_cp = first_dead_space_region(beg_cp, new_top_cp);\n-  assert(full_cp->destination() == sd.region_to_addr(full_cp) ||\n-         space->is_empty(), \"no dead space allowed to the left\");\n-  assert(full_cp->data_size() < region_size || full_cp == new_top_cp - 1,\n-         \"region must have dead space\");\n-\n-  \/\/ The gc number is saved whenever a maximum compaction is done, and used to\n-  \/\/ determine when the maximum compaction interval has expired.  This avoids\n-  \/\/ successive max compactions for different reasons.\n-  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n-  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n-  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n-  const bool interval_ended = gcs_since_max > HeapMaximumCompactionInterval ||\n-    total_invocations == HeapFirstMaximumCompactionCount;\n-  if (maximum_compaction || full_cp == top_cp || interval_ended) {\n-    _maximum_compaction_gc_num = total_invocations;\n-    return sd.region_to_addr(full_cp);\n-  }\n-\n@@ -1065,1 +1023,1 @@\n-  const RegionData* const start_region = full_cp;\n+  const RegionData* const start_region = sd.addr_to_region_ptr(full_region_prefix_end);\n@@ -1068,1 +1026,1 @@\n-  const RegionData* const end_region = sd.addr_to_region_ptr(space->top());\n+  const RegionData* const end_region = sd.addr_to_region_ptr(old_space->top());\n@@ -1071,1 +1029,1 @@\n-  size_t max_waste = space->capacity_in_words() * (MarkSweepDeadRatio \/ 100.0);\n+  size_t max_waste = old_space->capacity_in_words() * (MarkSweepDeadRatio \/ 100.0);\n@@ -1084,2 +1042,2 @@\n-  assert(prefix_end >= sd.region_to_addr(full_cp), \"in-range\");\n-  assert(prefix_end <= space->top(), \"in-range\");\n+  assert(prefix_end >= full_region_prefix_end, \"in-range\");\n+  assert(prefix_end <= old_space->top(), \"in-range\");\n@@ -1089,13 +1047,0 @@\n-void PSParallelCompact::summarize_spaces_quick()\n-{\n-  for (unsigned int i = 0; i < last_space_id; ++i) {\n-    const MutableSpace* space = _space_info[i].space();\n-    HeapWord** nta = _space_info[i].new_top_addr();\n-    bool result = _summary_data.summarize(_space_info[i].split_info(),\n-                                          space->bottom(), space->top(), nullptr,\n-                                          space->bottom(), space->end(), nta);\n-    assert(result, \"space must fit into itself\");\n-    _space_info[i].set_dense_prefix(space->bottom());\n-  }\n-}\n-\n@@ -1126,0 +1071,6 @@\n+  assert(_summary_data.is_region_aligned(dense_prefix_end), \"precondition\");\n+  assert(dense_prefix_end <= space(id)->top(), \"precondition\");\n+  if (dense_prefix_end == space(id)->top()) {\n+    \/\/ Must not have single-word gap right before prefix-end\/top.\n+    return;\n+  }\n@@ -1150,50 +1101,0 @@\n-void\n-PSParallelCompact::summarize_space(SpaceId id, bool maximum_compaction)\n-{\n-  assert(id < last_space_id, \"id out of range\");\n-  assert(_space_info[id].dense_prefix() == _space_info[id].space()->bottom(),\n-         \"should have been reset in summarize_spaces_quick()\");\n-\n-  const MutableSpace* space = _space_info[id].space();\n-  if (_space_info[id].new_top() != space->bottom()) {\n-    HeapWord* dense_prefix_end = compute_dense_prefix(id, maximum_compaction);\n-    _space_info[id].set_dense_prefix(dense_prefix_end);\n-\n-    \/\/ Recompute the summary data, taking into account the dense prefix.  If\n-    \/\/ every last byte will be reclaimed, then the existing summary data which\n-    \/\/ compacts everything can be left in place.\n-    if (!maximum_compaction && dense_prefix_end != space->bottom()) {\n-      \/\/ If dead space crosses the dense prefix boundary, it is (at least\n-      \/\/ partially) filled with a dummy object, marked live and added to the\n-      \/\/ summary data.  This simplifies the copy\/update phase and must be done\n-      \/\/ before the final locations of objects are determined, to prevent\n-      \/\/ leaving a fragment of dead space that is too small to fill.\n-      fill_dense_prefix_end(id);\n-\n-      \/\/ Compute the destination of each Region, and thus each object.\n-      _summary_data.summarize_dense_prefix(space->bottom(), dense_prefix_end);\n-      _summary_data.summarize(_space_info[id].split_info(),\n-                              dense_prefix_end, space->top(), nullptr,\n-                              dense_prefix_end, space->end(),\n-                              _space_info[id].new_top_addr());\n-    }\n-  }\n-\n-  if (log_develop_is_enabled(Trace, gc, compaction)) {\n-    const size_t region_size = ParallelCompactData::RegionSize;\n-    HeapWord* const dense_prefix_end = _space_info[id].dense_prefix();\n-    const size_t dp_region = _summary_data.addr_to_region_idx(dense_prefix_end);\n-    const size_t dp_words = pointer_delta(dense_prefix_end, space->bottom());\n-    HeapWord* const new_top = _space_info[id].new_top();\n-    const HeapWord* nt_aligned_up = _summary_data.region_align_up(new_top);\n-    const size_t cr_words = pointer_delta(nt_aligned_up, dense_prefix_end);\n-    log_develop_trace(gc, compaction)(\n-        \"id=%d cap=\" SIZE_FORMAT \" dp=\" PTR_FORMAT \" \"\n-        \"dp_region=\" SIZE_FORMAT \" \" \"dp_count=\" SIZE_FORMAT \" \"\n-        \"cr_count=\" SIZE_FORMAT \" \" \"nt=\" PTR_FORMAT,\n-        id, space->capacity_in_words(), p2i(dense_prefix_end),\n-        dp_region, dp_words \/ region_size,\n-        cr_words \/ region_size, p2i(new_top));\n-  }\n-}\n-\n@@ -1223,3 +1124,6 @@\n-void PSParallelCompact::summary_phase(bool maximum_compaction)\n-{\n-  GCTraceTime(Info, gc, phases) tm(\"Summary Phase\", &_gc_timer);\n+bool PSParallelCompact::reassess_maximum_compaction(bool maximum_compaction,\n+                                                    size_t total_live_words,\n+                                                    MutableSpace* const old_space,\n+                                                    HeapWord* full_region_prefix_end) {\n+  \/\/ Check if all live objs are larger than old-gen.\n+  const bool is_old_gen_overflowing = (total_live_words > old_space->capacity_in_words());\n@@ -1227,2 +1131,6 @@\n-  \/\/ Quick summarization of each space into itself, to see how much is live.\n-  summarize_spaces_quick();\n+  \/\/ JVM flags\n+  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n+  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n+  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n+  const bool is_interval_ended = gcs_since_max > HeapMaximumCompactionInterval\n+                              || total_invocations == HeapFirstMaximumCompactionCount;\n@@ -1230,3 +1138,3 @@\n-  log_develop_trace(gc, compaction)(\"summary phase:  after summarizing each space to self\");\n-  NOT_PRODUCT(print_region_ranges());\n-  NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));\n+  \/\/ If all regions in old-gen are full\n+  const bool is_region_full =\n+    full_region_prefix_end >= _summary_data.region_align_down(old_space->top());\n@@ -1234,5 +1142,3 @@\n-  \/\/ The amount of live data that will end up in old space (assuming it fits).\n-  size_t old_space_total_live = 0;\n-  for (unsigned int id = old_space_id; id < last_space_id; ++id) {\n-    old_space_total_live += pointer_delta(_space_info[id].new_top(),\n-                                          _space_info[id].space()->bottom());\n+  if (maximum_compaction || is_old_gen_overflowing || is_interval_ended || is_region_full) {\n+    _maximum_compaction_gc_num = total_invocations;\n+    return true;\n@@ -1241,0 +1147,7 @@\n+  return false;\n+}\n+\n+void PSParallelCompact::summary_phase(bool maximum_compaction)\n+{\n+  GCTraceTime(Info, gc, phases) tm(\"Summary Phase\", &_gc_timer);\n+\n@@ -1242,5 +1155,17 @@\n-  const size_t old_capacity = old_space->capacity_in_words();\n-  if (old_space_total_live > old_capacity) {\n-    \/\/ XXX - should also try to expand\n-    maximum_compaction = true;\n-  }\n+  {\n+    size_t total_live_words = 0;\n+    HeapWord* full_region_prefix_end = nullptr;\n+    {\n+      \/\/ old-gen\n+      size_t live_words = _summary_data.live_words_in_space(old_space,\n+                                                            &full_region_prefix_end);\n+      total_live_words += live_words;\n+    }\n+    \/\/ young-gen\n+    for (uint i = eden_space_id; i < last_space_id; ++i) {\n+      const MutableSpace* space = _space_info[i].space();\n+      size_t live_words = _summary_data.live_words_in_space(space);\n+      total_live_words += live_words;\n+      _space_info[i].set_new_top(space->bottom() + live_words);\n+      _space_info[i].set_dense_prefix(space->bottom());\n+    }\n@@ -1248,2 +1173,20 @@\n-  \/\/ Old generations.\n-  summarize_space(old_space_id, maximum_compaction);\n+    maximum_compaction = reassess_maximum_compaction(maximum_compaction,\n+                                                     total_live_words,\n+                                                     old_space,\n+                                                     full_region_prefix_end);\n+    HeapWord* dense_prefix_end =\n+      maximum_compaction ? full_region_prefix_end\n+                         : compute_dense_prefix_for_old_space(old_space,\n+                                                              full_region_prefix_end);\n+    SpaceId id = old_space_id;\n+    _space_info[id].set_dense_prefix(dense_prefix_end);\n+\n+    if (dense_prefix_end != old_space->bottom()) {\n+      fill_dense_prefix_end(id);\n+      _summary_data.summarize_dense_prefix(old_space->bottom(), dense_prefix_end);\n+    }\n+    _summary_data.summarize(_space_info[id].split_info(),\n+                            dense_prefix_end, old_space->top(), nullptr,\n+                            dense_prefix_end, old_space->end(),\n+                            _space_info[id].new_top_addr());\n+  }\n@@ -1333,4 +1276,0 @@\n-  if (ScavengeBeforeFullGC) {\n-    PSScavenge::invoke_no_policy();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":107,"deletions":168,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -409,0 +409,4 @@\n+\n+  size_t live_words_in_space(const MutableSpace* space,\n+                             HeapWord** full_region_prefix_end = nullptr);\n+\n@@ -938,0 +942,5 @@\n+  static bool reassess_maximum_compaction(bool maximum_compaction,\n+                                          size_t total_live_words,\n+                                          MutableSpace* const old_space,\n+                                          HeapWord* full_region_prefix_end);\n+\n@@ -941,10 +950,3 @@\n-  \/\/ Methods used to compute the dense prefix.\n-\n-  \/\/ Return a pointer to the first region in the range [beg, end) that is not\n-  \/\/ completely full.\n-  static RegionData* first_dead_space_region(const RegionData* beg,\n-                                             const RegionData* end);\n-\n-  \/\/ Compute the dense prefix for the designated space.\n-  static HeapWord* compute_dense_prefix(const SpaceId id,\n-                                        bool maximum_compaction);\n+  \/\/ Identify the dense-fix in the old-space to avoid moving much memory with little reclaimed.\n+  static HeapWord* compute_dense_prefix_for_old_space(MutableSpace* old_space,\n+                                                      HeapWord* full_region_prefix_end);\n@@ -956,2 +958,0 @@\n-  static void summarize_spaces_quick();\n-  static void summarize_space(SpaceId id, bool maximum_compaction);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  if (!m.is_marked()) {\n+  if (!m.is_forwarded()) {\n@@ -156,1 +156,1 @@\n-    return cast_to_oop(m.decode_pointer());\n+    return m.forwardee();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n@@ -34,3 +34,3 @@\n-void CardTableRS::scan_old_to_young_refs(TenuredSpace* sp, HeapWord* saved_mark_word) {\n-  const MemRegion ur    = sp->used_region();\n-  const MemRegion urasm = MemRegion(sp->bottom(), saved_mark_word);\n+void CardTableRS::scan_old_to_young_refs(TenuredGeneration* tg, HeapWord* saved_top) {\n+  const MemRegion ur    = tg->used_region();\n+  const MemRegion urasm = MemRegion(tg->space()->bottom(), saved_top);\n@@ -39,1 +39,0 @@\n-         \"Did you forget to call save_marks()? \"\n@@ -46,1 +45,1 @@\n-    non_clean_card_iterate(sp, urasm, &cl);\n+    non_clean_card_iterate(tg, urasm, &cl);\n@@ -228,1 +227,1 @@\n-void CardTableRS::non_clean_card_iterate(TenuredSpace* sp,\n+void CardTableRS::non_clean_card_iterate(TenuredGeneration* tg,\n@@ -241,1 +240,1 @@\n-    HeapWord* result = sp->block_start_const(addr);\n+    HeapWord* result = tg->block_start(addr);\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-class TenuredSpace;\n@@ -63,1 +62,1 @@\n-  void scan_old_to_young_refs(TenuredSpace* sp, HeapWord* saved_mark_word);\n+  void scan_old_to_young_refs(TenuredGeneration* tg, HeapWord* saved_top);\n@@ -86,1 +85,1 @@\n-  void non_clean_card_iterate(TenuredSpace* sp,\n+  void non_clean_card_iterate(TenuredGeneration* tg,\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/serial\/defNewGeneration.inline.hpp\"\n@@ -46,1 +45,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n@@ -79,14 +78,0 @@\n-class YoungGenScanClosure : public InHeapScanClosure {\n-  template <typename T>\n-  void do_oop_work(T* p) {\n-    assert(SerialHeap::heap()->young_gen()->to()->is_in_reserved(p), \"precondition\");\n-\n-    try_scavenge(p, [] (auto) {});\n-  }\n-public:\n-  YoungGenScanClosure(DefNewGeneration* g) : InHeapScanClosure(g) {}\n-\n-  void do_oop(oop* p)       { do_oop_work(p); }\n-  void do_oop(narrowOop* p) { do_oop_work(p); }\n-};\n-\n@@ -234,4 +219,1 @@\n-    do {\n-      _heap->oop_since_save_marks_iterate(_young_cl, _old_cl);\n-    } while (!_heap->no_allocs_since_save_marks());\n-    guarantee(_heap->young_gen()->promo_failure_scan_is_complete(), \"Failed to finish scan\");\n+    _heap->scan_evacuated_objs(_young_cl, _old_cl);\n@@ -379,7 +361,0 @@\n-\n-  \/\/ Set next compaction spaces.\n-  eden()->set_next_compaction_space(from());\n-  \/\/ The to-space is normally empty before a compaction so need\n-  \/\/ not be considered.  The exception is during promotion\n-  \/\/ failure handling when to-space can contain live objects.\n-  from()->set_next_compaction_space(nullptr);\n@@ -392,5 +367,0 @@\n-  eden()->set_next_compaction_space(from());\n-  \/\/ The to-space is normally empty before a compaction so need\n-  \/\/ not be considered.  The exception is during promotion\n-  \/\/ failure handling when to-space can contain live objects.\n-  from()->set_next_compaction_space(nullptr);\n@@ -591,0 +561,23 @@\n+\/\/ If \"p\" is in the space, returns the address of the start of the\n+\/\/ \"block\" that contains \"p\".  We say \"block\" instead of \"object\" since\n+\/\/ some heaps may not pack objects densely; a chunk may either be an\n+\/\/ object or a non-object.  If \"p\" is not in the space, return null.\n+\/\/ Very general, slow implementation.\n+static HeapWord* block_start_const(const ContiguousSpace* cs, const void* p) {\n+  assert(MemRegion(cs->bottom(), cs->end()).contains(p),\n+         \"p (\" PTR_FORMAT \") not in space [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+         p2i(p), p2i(cs->bottom()), p2i(cs->end()));\n+  if (p >= cs->top()) {\n+    return cs->top();\n+  } else {\n+    HeapWord* last = cs->bottom();\n+    HeapWord* cur = last;\n+    while (cur <= p) {\n+      last = cur;\n+      cur += cast_to_oop(cur)->size();\n+    }\n+    assert(oopDesc::is_oop(cast_to_oop(last)), PTR_FORMAT \" should be an object start\", p2i(last));\n+    return last;\n+  }\n+}\n+\n@@ -593,1 +586,1 @@\n-    return eden()->block_start_const(p);\n+    return block_start_const(eden(), p);\n@@ -596,1 +589,1 @@\n-    return from()->block_start_const(p);\n+    return block_start_const(from(), p);\n@@ -599,1 +592,1 @@\n-  return to()->block_start_const(p);\n+  return block_start_const(to(), p);\n@@ -687,3 +680,0 @@\n-  assert(heap->no_allocs_since_save_marks(),\n-         \"save marks have not been newly set.\");\n-\n@@ -697,3 +687,0 @@\n-  assert(heap->no_allocs_since_save_marks(),\n-         \"save marks have not been newly set.\");\n-\n@@ -709,0 +696,1 @@\n+    HeapWord* saved_top_in_old_gen = _old_gen->space()->top();\n@@ -715,1 +703,1 @@\n-    _old_gen->scan_old_to_young_refs();\n+    _old_gen->scan_old_to_young_refs(saved_top_in_old_gen);\n@@ -732,1 +720,0 @@\n-  assert(heap->no_allocs_since_save_marks(), \"save marks have not been newly set.\");\n@@ -739,3 +726,0 @@\n-  \/\/ Verify that the usage of keep_alive didn't copy any objects.\n-  assert(heap->no_allocs_since_save_marks(), \"save marks have not been newly set.\");\n-\n@@ -777,1 +761,0 @@\n-    from()->set_next_compaction_space(to());\n@@ -798,1 +781,0 @@\n-  from()->set_next_compaction_space(nullptr);\n@@ -903,9 +885,0 @@\n-void DefNewGeneration::save_marks() {\n-  set_saved_mark_word();\n-}\n-\n-\n-bool DefNewGeneration::no_allocs_since_save_marks() {\n-  return saved_mark_at_top();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":30,"deletions":57,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -174,4 +174,0 @@\n-  HeapWord* saved_mark_word()   const    { return _saved_mark_word; }\n-  void set_saved_mark_word()             { _saved_mark_word = to()->top(); }\n-  bool saved_mark_at_top()               { return _saved_mark_word == _to_space->top(); }\n-\n@@ -246,11 +242,0 @@\n-  \/\/ Accessing marks\n-  void save_marks();\n-\n-  bool no_allocs_since_save_marks();\n-\n-  \/\/ Need to declare the full complement of closures, whether we'll\n-  \/\/ override them or not, or get message from the compiler:\n-  \/\/   oop_since_save_marks_iterate_nv hides virtual function...\n-  template <typename OopClosureType>\n-  void oop_since_save_marks_iterate(OopClosureType* cl);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SERIAL_DEFNEWGENERATION_INLINE_HPP\n-#define SHARE_GC_SERIAL_DEFNEWGENERATION_INLINE_HPP\n-\n-#include \"gc\/serial\/defNewGeneration.hpp\"\n-\n-#include \"gc\/serial\/cardTableRS.hpp\"\n-#include \"gc\/shared\/space.inline.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"utilities\/devirtualizer.inline.hpp\"\n-\n-\/\/ Methods of protected closure types\n-\n-template <typename OopClosureType>\n-void DefNewGeneration::oop_since_save_marks_iterate(OopClosureType* cl) {\n-  Generation::oop_since_save_marks_iterate_impl(cl, to(), _saved_mark_word);\n-  set_saved_mark_word();\n-}\n-\n-#endif \/\/ SHARE_GC_SERIAL_DEFNEWGENERATION_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n@@ -203,9 +203,0 @@\n-\n-  \/\/ Apply \"blk->do_oop\" to the addresses of all reference fields in objects\n-  \/\/ starting with the _saved_mark_word, which was noted during a generation's\n-  \/\/ save_marks and is required to denote the head of an object.\n-  \/\/ Fields in objects allocated by applications of the closure\n-  \/\/ *are* included in the iteration.\n-  \/\/ Updates saved_mark_word to point to just after the last object iterated over.\n-  template <typename OopClosureType>\n-  void oop_since_save_marks_iterate_impl(OopClosureType* blk, ContiguousSpace* space, HeapWord* saved_mark_word);\n@@ -214,17 +205,0 @@\n-template <typename OopClosureType>\n-void Generation::oop_since_save_marks_iterate_impl(OopClosureType* blk, ContiguousSpace* space, HeapWord* saved_mark_word) {\n-  HeapWord* t;\n-  HeapWord* p = saved_mark_word;\n-  assert(p != nullptr, \"expected saved mark\");\n-\n-  const intx interval = PrefetchScanIntervalInBytes;\n-  do {\n-    t = space->top();\n-    while (p < t) {\n-      Prefetch::write(p, interval);\n-      oop m = cast_to_oop(p);\n-      p += m->oop_iterate_size(blk);\n-    }\n-  } while (t < space->top());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -37,1 +38,1 @@\n-#include \"gc\/serial\/serialFullGC.inline.hpp\"\n+#include \"gc\/serial\/serialFullGC.hpp\"\n@@ -40,0 +41,2 @@\n+#include \"gc\/serial\/serialStringDedup.hpp\"\n+#include \"gc\/serial\/tenuredGeneration.inline.hpp\"\n@@ -42,0 +45,1 @@\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n@@ -51,1 +55,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n@@ -59,0 +63,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -64,0 +69,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -169,0 +175,3 @@\n+  \/\/ Used for BOT update\n+  TenuredGeneration* _old_gen;\n+\n@@ -194,1 +203,1 @@\n-          static_cast<TenuredSpace*>(_spaces[0]._space)->update_for_block(result, result + words);\n+          _old_gen->update_for_block(result, result + words);\n@@ -270,1 +279,1 @@\n-    bool is_promotion_failed = (heap->young_gen()->from()->next_compaction_space() != nullptr);\n+    bool is_promotion_failed = !heap->young_gen()->to()->is_empty();\n@@ -278,0 +287,1 @@\n+    _old_gen = heap->old_gen();\n@@ -330,1 +340,1 @@\n-          size_t size = SerialFullGC::adjust_pointers(cast_to_oop(cur_addr));\n+          size_t size = cast_to_oop(cur_addr)->oop_iterate_size(&SerialFullGC::adjust_pointer_closure);\n@@ -612,0 +622,19 @@\n+template <class T> void SerialFullGC::adjust_pointer(T* p) {\n+  T heap_oop = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(heap_oop)) {\n+    oop obj = CompressedOops::decode_not_null(heap_oop);\n+    assert(Universe::heap()->is_in(obj), \"should be in heap\");\n+\n+    if (obj->is_forwarded()) {\n+      oop new_obj = obj->forwardee();\n+      assert(is_object_aligned(new_obj), \"oop must be aligned\");\n+      RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void AdjustPointerClosure::do_oop_work(T* p)           { SerialFullGC::adjust_pointer(p); }\n+inline void AdjustPointerClosure::do_oop(oop* p)       { do_oop_work(p); }\n+inline void AdjustPointerClosure::do_oop(narrowOop* p) { do_oop_work(p); }\n+\n@@ -722,4 +751,0 @@\n-  \/\/ Set saved marks for allocation profiler (and other things? -- dld)\n-  \/\/ (Should this be in general part?)\n-  gch->save_marks();\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":35,"deletions":10,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -136,2 +136,0 @@\n-  static size_t adjust_pointers(oop obj);\n-\n@@ -140,1 +138,1 @@\n-  template <class T> static inline void adjust_pointer(T* p);\n+  template <class T> static void adjust_pointer(T* p);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SERIAL_SERIALFULLGC_INLINE_HPP\n-#define SHARE_GC_SERIAL_SERIALFULLGC_INLINE_HPP\n-\n-#include \"gc\/serial\/serialFullGC.hpp\"\n-\n-#include \"classfile\/classLoaderData.inline.hpp\"\n-#include \"classfile\/javaClasses.inline.hpp\"\n-#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n-#include \"gc\/serial\/serialStringDedup.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/compressedOops.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/stack.inline.hpp\"\n-\n-template <class T> inline void SerialFullGC::adjust_pointer(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    assert(Universe::heap()->is_in(obj), \"should be in heap\");\n-\n-    if (obj->is_forwarded()) {\n-      oop new_obj = obj->forwardee();\n-      assert(is_object_aligned(new_obj), \"oop must be aligned\");\n-      RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n-    }\n-  }\n-}\n-\n-template <typename T>\n-void AdjustPointerClosure::do_oop_work(T* p)           { SerialFullGC::adjust_pointer(p); }\n-inline void AdjustPointerClosure::do_oop(oop* p)       { do_oop_work(p); }\n-inline void AdjustPointerClosure::do_oop(narrowOop* p) { do_oop_work(p); }\n-\n-inline size_t SerialFullGC::adjust_pointers(oop obj) {\n-  return obj->oop_iterate_size(&SerialFullGC::adjust_pointer_closure);\n-}\n-\n-#endif \/\/ SHARE_GC_SERIAL_SERIALFULLGC_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.inline.hpp","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/serial\/defNewGeneration.inline.hpp\"\n@@ -35,1 +34,1 @@\n-#include \"gc\/serial\/serialHeap.hpp\"\n+#include \"gc\/serial\/serialHeap.inline.hpp\"\n@@ -502,1 +501,1 @@\n-  bool old_collects_young = complete && !ScavengeBeforeFullGC;\n+  bool old_collects_young = complete;\n@@ -760,3 +759,28 @@\n-bool SerialHeap::no_allocs_since_save_marks() {\n-  return _young_gen->no_allocs_since_save_marks() &&\n-         _old_gen->no_allocs_since_save_marks();\n+template <typename OopClosureType>\n+static void oop_iterate_from(OopClosureType* blk, ContiguousSpace* space, HeapWord** from) {\n+  assert(*from != nullptr, \"precondition\");\n+  HeapWord* t;\n+  HeapWord* p = *from;\n+\n+  const intx interval = PrefetchScanIntervalInBytes;\n+  do {\n+    t = space->top();\n+    while (p < t) {\n+      Prefetch::write(p, interval);\n+      p += cast_to_oop(p)->oop_iterate_size(blk);\n+    }\n+  } while (t < space->top());\n+\n+  *from = space->top();\n+}\n+\n+void SerialHeap::scan_evacuated_objs(YoungGenScanClosure* young_cl,\n+                                     OldGenScanClosure* old_cl) {\n+  ContiguousSpace* to_space = young_gen()->to();\n+  do {\n+    oop_iterate_from(young_cl, to_space, &_young_gen_saved_top);\n+    oop_iterate_from(old_cl, old_gen()->space(), &_old_gen_saved_top);\n+    \/\/ Recheck to-space only, because postcondition of oop_iterate_from is no\n+    \/\/ unscanned objs\n+  } while (_young_gen_saved_top != to_space->top());\n+  guarantee(young_gen()->promo_failure_scan_is_complete(), \"Failed to finish scan\");\n@@ -928,2 +952,2 @@\n-  _young_gen->save_marks();\n-  _old_gen->save_marks();\n+  _young_gen_saved_top = _young_gen->to()->top();\n+  _old_gen_saved_top = _old_gen->space()->top();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-\n+  HeapWord* _young_gen_saved_top;\n+  HeapWord* _old_gen_saved_top;\n@@ -238,9 +239,0 @@\n-  \/\/ The functions below are helper functions that a subclass of\n-  \/\/ \"CollectedHeap\" can use in the implementation of its virtual\n-  \/\/ functions.\n-\n-  class GenClosure : public StackObj {\n-   public:\n-    virtual void do_generation(Generation* gen) = 0;\n-  };\n-\n@@ -282,4 +274,0 @@\n-  \/\/ Returns \"true\" iff no allocations have occurred since the last\n-  \/\/ call to \"save_marks\".\n-  bool no_allocs_since_save_marks();\n-\n@@ -358,7 +346,2 @@\n-  \/\/ Apply \"cur->do_oop\" or \"older->do_oop\" to all the oops in objects\n-  \/\/ allocated since the last call to save_marks in the young generation.\n-  \/\/ The \"cur\" closure is applied to references in the younger generation\n-  \/\/ at \"level\", and the \"older\" closure to older generations.\n-  template <typename OopClosureType1, typename OopClosureType2>\n-  void oop_since_save_marks_iterate(OopClosureType1* cur,\n-                                    OopClosureType2* older);\n+  void scan_evacuated_objs(YoungGenScanClosure* young_cl,\n+                           OldGenScanClosure* old_cl);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/serial\/defNewGeneration.inline.hpp\"\n@@ -32,7 +31,1 @@\n-\n-template <typename OopClosureType1, typename OopClosureType2>\n-void SerialHeap::oop_since_save_marks_iterate(OopClosureType1* cur,\n-                                              OopClosureType2* older) {\n-  young_gen()->oop_since_save_marks_iterate(cur);\n-  old_gen()->oop_since_save_marks_iterate(older);\n-}\n+#include \"oops\/oop.inline.hpp\"\n@@ -103,0 +96,14 @@\n+class YoungGenScanClosure : public InHeapScanClosure {\n+  template <typename T>\n+  void do_oop_work(T* p) {\n+    assert(SerialHeap::heap()->young_gen()->to()->is_in_reserved(p), \"precondition\");\n+\n+    try_scavenge(p, [] (auto) {});\n+  }\n+public:\n+  YoungGenScanClosure(DefNewGeneration* g) : InHeapScanClosure(g) {}\n+\n+  void do_oop(oop* p)       { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { do_oop_work(p); }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.inline.hpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n@@ -267,2 +268,14 @@\n-HeapWord* TenuredGeneration::block_start(const void* p) const {\n-  return space()->block_start_const(p);\n+HeapWord* TenuredGeneration::block_start(const void* addr) const {\n+  HeapWord* cur_block = _bts->block_start_reaching_into_card(addr);\n+\n+  while (true) {\n+    HeapWord* next_block = cur_block + cast_to_oop(cur_block)->size();\n+    if (next_block > addr) {\n+      assert(cur_block <= addr, \"postcondition\");\n+      return cur_block;\n+    }\n+    cur_block = next_block;\n+    \/\/ Because the BOT is precise, we should never step into the next card\n+    \/\/ (i.e. crossing the card boundary).\n+    assert(!SerialBlockOffsetTable::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n+  }\n@@ -271,2 +284,2 @@\n-void TenuredGeneration::scan_old_to_young_refs() {\n-  _rs->scan_old_to_young_refs(space(), saved_mark_word());\n+void TenuredGeneration::scan_old_to_young_refs(HeapWord* saved_top_in_old_gen) {\n+  _rs->scan_old_to_young_refs(this, saved_top_in_old_gen);\n@@ -307,1 +320,2 @@\n-  _the_space  = new TenuredSpace(_bts, MemRegion(bottom, end));\n+  _the_space  = new ContiguousSpace();\n+  _the_space->initialize(MemRegion(bottom, end), SpaceDecorator::Clear, SpaceDecorator::Mangle);\n@@ -469,1 +483,1 @@\n-  return _the_space->allocate(word_size);\n+  return allocate(word_size, is_tlab);\n@@ -486,1 +500,0 @@\n-  TenuredSpace* space = _the_space;\n@@ -490,1 +503,1 @@\n-    space->update_for_block(start, start + word_size);\n+    _bts->update_for_block(start, start + word_size);\n@@ -495,8 +508,0 @@\n-void TenuredGeneration::save_marks() {\n-  set_saved_mark_word();\n-}\n-\n-bool TenuredGeneration::no_allocs_since_save_marks() {\n-  return saved_mark_at_top();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  TenuredSpace*       _the_space;       \/\/ Actual space holding objects\n+  ContiguousSpace*    _the_space;       \/\/ Actual space holding objects\n@@ -91,1 +91,1 @@\n-  TenuredSpace* space() const { return _the_space; }\n+  ContiguousSpace* space() const { return _the_space; }\n@@ -93,2 +93,0 @@\n-  void set_saved_mark_word() { _saved_mark_word = _the_space->top(); }\n-  bool saved_mark_at_top() { return _saved_mark_word == space()->top(); }\n@@ -115,1 +113,1 @@\n-  HeapWord* block_start(const void* p) const;\n+  HeapWord* block_start(const void* addr) const;\n@@ -117,1 +115,1 @@\n-  void scan_old_to_young_refs();\n+  void scan_old_to_young_refs(HeapWord* saved_top_in_old_gen);\n@@ -137,0 +135,1 @@\n+  inline void update_for_block(HeapWord* start, HeapWord* end);\n@@ -141,7 +140,0 @@\n-  template <typename OopClosureType>\n-  void oop_since_save_marks_iterate(OopClosureType* cl);\n-\n-  void save_marks();\n-\n-  bool no_allocs_since_save_marks();\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n@@ -48,0 +48,4 @@\n+inline void TenuredGeneration::update_for_block(HeapWord* start, HeapWord* end) {\n+  _bts->update_for_block(start, end);\n+}\n+\n@@ -49,1 +53,1 @@\n-                                                 bool is_tlab) {\n+                                      bool is_tlab) {\n@@ -51,1 +55,5 @@\n-  return _the_space->allocate(word_size);\n+  HeapWord* res = _the_space->allocate(word_size);\n+  if (res != nullptr) {\n+    _bts->update_for_block(res, res + word_size);\n+  }\n+  return res;\n@@ -55,1 +63,1 @@\n-                                                     bool is_tlab) {\n+                                          bool is_tlab) {\n@@ -57,7 +65,5 @@\n-  return _the_space->par_allocate(word_size);\n-}\n-\n-template <typename OopClosureType>\n-void TenuredGeneration::oop_since_save_marks_iterate(OopClosureType* blk) {\n-  Generation::oop_since_save_marks_iterate_impl(blk, _the_space, _saved_mark_word);\n-  set_saved_mark_word();\n+  HeapWord* res = _the_space->par_allocate(word_size);\n+  if (res != nullptr) {\n+    _bts->update_for_block(res, res + word_size);\n+  }\n+  return res;\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.inline.hpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"gc\/serial\/defNewGeneration.hpp\"\n+#include \"gc\/serial\/generation.hpp\"\n@@ -48,1 +50,1 @@\n-  nonstatic_field(TenuredGeneration,                 _the_space,             TenuredSpace*)                 \\\n+  nonstatic_field(TenuredGeneration,                 _the_space,             ContiguousSpace*)              \\\n@@ -61,2 +63,0 @@\n-  nonstatic_field(TenuredSpace,                      _offsets,               SerialBlockOffsetTable*)       \\\n-                                                                                                            \\\n@@ -73,1 +73,0 @@\n-  declare_type(TenuredSpace,                 ContiguousSpace)                 \\\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n@@ -205,0 +205,1 @@\n+  assert(_covered[0].contains(mr) || _covered[1].contains(mr), \"precondition\");\n@@ -229,9 +230,0 @@\n-void CardTable::invalidate(MemRegion mr) {\n-  assert(align_down(mr.start(), HeapWordSize) == mr.start(), \"Unaligned start\");\n-  assert(align_up  (mr.end(),   HeapWordSize) == mr.end(),   \"Unaligned end\"  );\n-  for (int i = 0; i < max_covered_regions; i++) {\n-    MemRegion mri = mr.intersection(_covered[i]);\n-    if (!mri.is_empty()) dirty_MemRegion(mri);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -134,2 +134,0 @@\n-  void invalidate(MemRegion mr);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n@@ -83,1 +83,1 @@\n-void CardTableBarrierSet::write_ref_array_work(MemRegion mr) {\n+void CardTableBarrierSet::write_region(MemRegion mr) {\n@@ -87,4 +87,0 @@\n-void CardTableBarrierSet::invalidate(MemRegion mr) {\n-  _card_table->invalidate(mr);\n-}\n-\n@@ -144,1 +140,1 @@\n-      invalidate(mr);\n+      write_region(mr);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    invalidate(mr);\n+    write_region(mr);\n@@ -73,2 +73,0 @@\n-  void write_ref_array_work(MemRegion mr);\n-\n@@ -83,1 +81,1 @@\n-  virtual void invalidate(MemRegion mr);\n+  virtual void write_region(MemRegion mr);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-      nm->purge(false \/* free_code_cache_data *\/, _unregister_nmethods_during_purge);\n+      nm->purge(_unregister_nmethods_during_purge);\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,4 +43,0 @@\n-  if (!UseParallelGC && FLAG_IS_DEFAULT(ScavengeBeforeFullGC)) {\n-    FLAG_SET_DEFAULT(ScavengeBeforeFullGC, false);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,3 +157,0 @@\n-  product(bool, ScavengeBeforeFullGC, true,                                 \\\n-          \"Scavenge youngest generation before each full GC.\")              \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  virtual void invalidate(MemRegion mr) = 0;\n+  virtual void write_region(MemRegion mr) = 0;\n@@ -64,1 +64,1 @@\n-                                   bool dest_uninitialized = false) {}\n+                                   bool dest_uninitialized) {}\n@@ -66,1 +66,1 @@\n-                                   bool dest_uninitialized = false) {}\n+                                   bool dest_uninitialized) {}\n@@ -71,4 +71,0 @@\n- protected:\n-  virtual void write_ref_array_work(MemRegion mr) = 0;\n-\n- public:\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  write_ref_array_work(MemRegion(aligned_start, aligned_end));\n+  write_region(MemRegion(aligned_start, aligned_end));\n@@ -141,1 +141,1 @@\n-  bs->invalidate(MemRegion((HeapWord*)(void*)dst, size));\n+  bs->write_region(MemRegion((HeapWord*)(void*)dst, size));\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -413,1 +413,1 @@\n-\/\/ service thread of pending cleanup work.  It must be lock-free because\n+\/\/ ServiceThread of pending cleanup work.  It must be lock-free because\n@@ -708,1 +708,1 @@\n-      \/\/ some.  And the service thread will drain the entire deferred list\n+      \/\/ some.  And the ServiceThread will drain the entire deferred list\n@@ -883,5 +883,1 @@\n-\/\/\n-\/\/ We don't want cleanup work to linger indefinitely, but we also don't want\n-\/\/ to run the service thread too often.  We're also very limited in what we\n-\/\/ can do in a release operation, where cleanup work is created.\n-\/\/\n+\n@@ -890,1 +886,1 @@\n-\/\/ request state.  A safepoint cleanup task notifies the service thread when\n+\/\/ request state. The ServiceThread checks at timed intervals if\n@@ -892,3 +888,2 @@\n-\/\/ request state.  But that notification is deferred if the service thread\n-\/\/ has run recently, and we also avoid duplicate notifications.  The service\n-\/\/ thread updates the timestamp and resets the state flags on every iteration.\n+\/\/ request state.  We don't want to run empty block cleanup too often in the\n+\/\/ face of frequent explicit ServiceThread wakeups, hence the defer period.\n@@ -899,2 +894,2 @@\n-\/\/ Flag for avoiding duplicate notifications.\n-static bool needs_cleanup_triggered = false;\n+\/\/ Time after which a cleanup is permitted.\n+static jlong cleanup_permit_time = 0;\n@@ -902,17 +897,3 @@\n-\/\/ Time after which a notification can be made.\n-static jlong cleanup_trigger_permit_time = 0;\n-\n-\/\/ Minimum time since last service thread check before notification is\n-\/\/ permitted.  The value of 500ms was an arbitrary choice; frequent, but not\n-\/\/ too frequent.\n-const jlong cleanup_trigger_defer_period = 500 * NANOSECS_PER_MILLISEC;\n-\n-void OopStorage::trigger_cleanup_if_needed() {\n-  MonitorLocker ml(Service_lock, Monitor::_no_safepoint_check_flag);\n-  if (Atomic::load(&needs_cleanup_requested) &&\n-      !needs_cleanup_triggered &&\n-      (os::javaTimeNanos() > cleanup_trigger_permit_time)) {\n-    needs_cleanup_triggered = true;\n-    ml.notify_all();\n-  }\n-}\n+\/\/ Minimum time between ServiceThread cleanups.\n+\/\/ The value of 500ms was an arbitrary choice; frequent, but not too frequent.\n+const jlong cleanup_defer_period = 500 * NANOSECS_PER_MILLISEC;\n@@ -922,7 +903,11 @@\n-  cleanup_trigger_permit_time =\n-    os::javaTimeNanos() + cleanup_trigger_defer_period;\n-  needs_cleanup_triggered = false;\n-  \/\/ Set the request flag false and return its old value.\n-  \/\/ Needs to be atomic to avoid dropping a concurrent request.\n-  \/\/ Can't use Atomic::xchg, which may not support bool.\n-  return Atomic::cmpxchg(&needs_cleanup_requested, true, false);\n+\n+  if (Atomic::load_acquire(&needs_cleanup_requested) &&\n+      os::javaTimeNanos() > cleanup_permit_time) {\n+    cleanup_permit_time =\n+      os::javaTimeNanos() + cleanup_defer_period;\n+    \/\/ Set the request flag false and return its old value.\n+    Atomic::release_store(&needs_cleanup_requested, false);\n+    return true;\n+  } else {\n+    return false;\n+  }\n@@ -931,2 +916,2 @@\n-\/\/ Record that cleanup is needed, without notifying the Service thread.\n-\/\/ Used by release(), where we can't lock even Service_lock.\n+\/\/ Record that cleanup is needed, without notifying the Service thread, because\n+\/\/ we can't lock the Service_lock.  Used by release().\n@@ -934,2 +919,2 @@\n-  \/\/ Set local flag first, else service thread could wake up and miss\n-  \/\/ the request.  This order may instead (rarely) unnecessarily notify.\n+  \/\/ Set local flag first, else ServiceThread could wake up and miss\n+  \/\/ the request.\n@@ -941,3 +926,2 @@\n-  \/\/ Service thread might have oopstorage work, but not for this object.\n-  \/\/ Check for deferred updates even though that's not a service thread\n-  \/\/ trigger; since we're here, we might as well process them.\n+  \/\/ ServiceThread might have oopstorage work, but not for this object.\n+  \/\/ But check for deferred updates, which might provide cleanup work.\n@@ -989,1 +973,1 @@\n-        \/\/ service thread.  Instead, iteration completion notifies.\n+        \/\/ ServiceThread.  Instead, iteration completion notifies.\n@@ -1001,4 +985,2 @@\n-  \/\/ Exceeded work limit or can't delete last block.  This will\n-  \/\/ cause the service thread to loop, giving other subtasks an\n-  \/\/ opportunity to run too.  There's no need for a notification,\n-  \/\/ because we are part of the service thread (unless gtesting).\n+  \/\/ Exceeded work limit or can't delete last block so still needs cleanup\n+  \/\/ for the next time.\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":32,"deletions":50,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  assert(!m.is_marked(), \"precondition\");\n+  assert(!m.is_forwarded(), \"precondition\");\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n@@ -46,1 +45,0 @@\n-  _next_compaction_space(nullptr),\n@@ -67,1 +65,0 @@\n-  _next_compaction_space = nullptr;\n@@ -128,19 +125,0 @@\n-\/\/ Very general, slow implementation.\n-HeapWord* ContiguousSpace::block_start_const(const void* p) const {\n-  assert(MemRegion(bottom(), end()).contains(p),\n-         \"p (\" PTR_FORMAT \") not in space [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-         p2i(p), p2i(bottom()), p2i(end()));\n-  if (p >= top()) {\n-    return top();\n-  } else {\n-    HeapWord* last = bottom();\n-    HeapWord* cur = last;\n-    while (cur <= p) {\n-      last = cur;\n-      cur += cast_to_oop(cur)->size();\n-    }\n-    assert(oopDesc::is_oop(cast_to_oop(last)), PTR_FORMAT \" should be an object start\", p2i(last));\n-    return last;\n-  }\n-}\n-\n@@ -192,25 +170,0 @@\n-\n-#if INCLUDE_SERIALGC\n-HeapWord* TenuredSpace::block_start_const(const void* addr) const {\n-  HeapWord* cur_block = _offsets->block_start_reaching_into_card(addr);\n-\n-  while (true) {\n-    HeapWord* next_block = cur_block + cast_to_oop(cur_block)->size();\n-    if (next_block > addr) {\n-      assert(cur_block <= addr, \"postcondition\");\n-      return cur_block;\n-    }\n-    cur_block = next_block;\n-    \/\/ Because the BOT is precise, we should never step into the next card\n-    \/\/ (i.e. crossing the card boundary).\n-    assert(!SerialBlockOffsetTable::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n-  }\n-}\n-\n-TenuredSpace::TenuredSpace(SerialBlockOffsetTable* offsets,\n-                           MemRegion mr) :\n-  _offsets(offsets)\n-{\n-  initialize(mr, SpaceDecorator::Clear, SpaceDecorator::Mangle);\n-}\n-#endif \/\/ INCLUDE_SERIALGC\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -67,3 +67,0 @@\n-\n-  ContiguousSpace* _next_compaction_space;\n-\n@@ -126,12 +123,0 @@\n-  \/\/ Returns the next space (in the current generation) to be compacted in\n-  \/\/ the global compaction order.  Also is used to select the next\n-  \/\/ space into which to compact.\n-\n-  ContiguousSpace* next_compaction_space() const {\n-    return _next_compaction_space;\n-  }\n-\n-  void set_next_compaction_space(ContiguousSpace* csp) {\n-    _next_compaction_space = csp;\n-  }\n-\n@@ -172,6 +157,0 @@\n-  \/\/ If \"p\" is in the space, returns the address of the start of the\n-  \/\/ \"block\" that contains \"p\".  We say \"block\" instead of \"object\" since\n-  \/\/ some heaps may not pack objects densely; a chunk may either be an\n-  \/\/ object or a non-object.  If \"p\" is not in the space, return null.\n-  virtual HeapWord* block_start_const(const void* p) const;\n-\n@@ -185,25 +164,0 @@\n-#if INCLUDE_SERIALGC\n-\n-\/\/ Class TenuredSpace is used by TenuredGeneration; it supports an efficient\n-\/\/ \"block_start\" operation via a SerialBlockOffsetTable.\n-\n-class TenuredSpace: public ContiguousSpace {\n-  friend class VMStructs;\n- protected:\n-  SerialBlockOffsetTable* _offsets;\n-\n- public:\n-  \/\/ Constructor\n-  TenuredSpace(SerialBlockOffsetTable* offsets,\n-               MemRegion mr);\n-\n-  HeapWord* block_start_const(const void* addr) const override;\n-\n-  \/\/ Add offset table update.\n-  inline HeapWord* allocate(size_t word_size) override;\n-  inline HeapWord* par_allocate(size_t word_size) override;\n-\n-  inline void update_for_block(HeapWord* start, HeapWord* end);\n-};\n-#endif \/\/INCLUDE_SERIALGC\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_SPACE_INLINE_HPP\n-#define SHARE_GC_SHARED_SPACE_INLINE_HPP\n-\n-#include \"gc\/shared\/space.hpp\"\n-\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"gc\/shared\/spaceDecorator.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"runtime\/prefetch.inline.hpp\"\n-#include \"runtime\/safepoint.hpp\"\n-\n-#if INCLUDE_SERIALGC\n-inline HeapWord* TenuredSpace::allocate(size_t size) {\n-  HeapWord* res = ContiguousSpace::allocate(size);\n-  if (res != nullptr) {\n-    _offsets->update_for_block(res, res + size);\n-  }\n-  return res;\n-}\n-\n-inline HeapWord* TenuredSpace::par_allocate(size_t size) {\n-  HeapWord* res = ContiguousSpace::par_allocate(size);\n-  if (res != nullptr) {\n-    _offsets->update_for_block(res, res + size);\n-  }\n-  return res;\n-}\n-\n-inline void TenuredSpace::update_for_block(HeapWord* start, HeapWord* end) {\n-  _offsets->update_for_block(start, end);\n-}\n-#endif \/\/ INCLUDE_SERIALGC\n-\n-#endif \/\/ SHARE_GC_SHARED_SPACE_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/spaceDecorator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-#include \"gc\/serial\/defNewGeneration.hpp\"\n-#include \"gc\/serial\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/space.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -603,3 +603,1 @@\n-  const uintptr_t non_mark_bits_mask = ZPointerMarkMetadataMask ^ ZPointerAllMetadataMask;\n-  const uintptr_t non_mark_prev_bits = untype(prev) & non_mark_bits_mask;\n-  return color(addr, ZPointerLoadGoodMask | ZPointerMarkedYoung | ZPointerFinalizable | non_mark_prev_bits | ZPointerRememberedMask);\n+  return color(addr, ZPointerLoadGoodMask | ZPointerMarkedYoung | ZPointerFinalizable | ZPointerRememberedMask);\n@@ -613,3 +611,1 @@\n-  const uintptr_t non_mark_bits_mask = ZPointerMarkMetadataMask ^ ZPointerAllMetadataMask;\n-  const uintptr_t non_mark_prev_bits = untype(prev) & non_mark_bits_mask;\n-  return color(addr, ZPointerLoadGoodMask | ZPointerMarkedYoung | ZPointerMarkedOld | non_mark_prev_bits | ZPointerRememberedMask);\n+  return color(addr, ZPointerLoadGoodMask | ZPointerMarkedYoung | ZPointerMarkedOld | ZPointerRememberedMask);\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.inline.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -144,12 +144,0 @@\n-\/\/\n-\/\/ Clean barrier\n-\/\/\n-\n-zaddress ZBarrier::verify_old_object_live_slow_path(zaddress addr) {\n-  \/\/ Verify that the object was indeed alive\n-  assert(ZHeap::heap()->is_young(addr) || ZHeap::heap()->is_object_live(addr), \"Should be live\");\n-\n-  return addr;\n-}\n-\n-\/\/\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -111,2 +111,0 @@\n-  static zaddress verify_old_object_live_slow_path(zaddress addr);\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,2 +313,1 @@\n-  \/\/ Preclean young if implied by configuration\n-  return ScavengeBeforeFullGC;\n+  return false;\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,8 @@\n+  uintptr_t index(zoffset from_offset);\n+\n+  ZForwardingEntry find(uintptr_t from_index, ZForwardingCursor* cursor) const;\n+  zaddress find(zoffset from_offset, ZForwardingCursor* cursor);\n+\n+  zoffset insert(uintptr_t from_index, zoffset to_offset, ZForwardingCursor* cursor);\n+  zaddress insert(zoffset from_offset, zaddress to_addr, ZForwardingCursor* cursor);\n+\n@@ -143,1 +151,3 @@\n-  zaddress find(zaddress_unsafe addr);\n+  zaddress find(zaddress from_addr, ZForwardingCursor* cursor);\n+  zaddress find(zaddress_unsafe from_addr, ZForwardingCursor* cursor);\n+  zaddress find(zaddress_unsafe from_addr);\n@@ -145,2 +155,1 @@\n-  ZForwardingEntry find(uintptr_t from_index, ZForwardingCursor* cursor) const;\n-  zoffset insert(uintptr_t from_index, zoffset to_offset, ZForwardingCursor* cursor);\n+  zaddress insert(zaddress from_addr, zaddress to_addr, ZForwardingCursor* cursor);\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,5 +221,2 @@\n-inline zaddress ZForwarding::find(zaddress_unsafe addr) {\n-  const uintptr_t from_index = (ZAddress::offset(addr) - start()) >> object_alignment_shift();\n-  ZForwardingCursor cursor;\n-  const ZForwardingEntry entry = find(from_index, &cursor);\n-  return entry.populated() ? ZOffset::address(to_zoffset(entry.to_offset())) : zaddress::null;\n+inline uintptr_t ZForwarding::index(zoffset from_offset) {\n+  return (from_offset - start()) >> object_alignment_shift();\n@@ -246,0 +243,19 @@\n+inline zaddress ZForwarding::find(zoffset from_offset, ZForwardingCursor* cursor) {\n+  const uintptr_t from_index = index(from_offset);\n+  const ZForwardingEntry entry = find(from_index, cursor);\n+  return entry.populated() ? ZOffset::address(to_zoffset(entry.to_offset())) : zaddress::null;\n+}\n+\n+inline zaddress ZForwarding::find(zaddress from_addr, ZForwardingCursor* cursor) {\n+  return find(ZAddress::offset(from_addr), cursor);\n+}\n+\n+inline zaddress ZForwarding::find(zaddress_unsafe from_addr, ZForwardingCursor* cursor) {\n+  return find(ZAddress::offset(from_addr), cursor);\n+}\n+\n+inline zaddress ZForwarding::find(zaddress_unsafe from_addr) {\n+  ZForwardingCursor cursor;\n+  return find(from_addr, &cursor);\n+}\n+\n@@ -274,0 +290,11 @@\n+inline zaddress ZForwarding::insert(zoffset from_offset, zaddress to_addr, ZForwardingCursor* cursor) {\n+  const uintptr_t from_index = index(from_offset);\n+  const zoffset to_offset = ZAddress::offset(to_addr);\n+  const zoffset to_offset_final = insert(from_index, to_offset, cursor);\n+  return ZOffset::address(to_offset_final);\n+}\n+\n+inline zaddress ZForwarding::insert(zaddress from_addr, zaddress to_addr, ZForwardingCursor* cursor) {\n+  return insert(ZAddress::offset(from_addr), to_addr, cursor);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.inline.hpp","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-      if (!seen_gc_safepoint && gc_safepoint_happened()) {\n+      if (is_reference_type(element_type) && !seen_gc_safepoint && gc_safepoint_happened()) {\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,29 +55,0 @@\n-static uintptr_t forwarding_index(ZForwarding* forwarding, zoffset from_offset) {\n-  return (from_offset - forwarding->start()) >> forwarding->object_alignment_shift();\n-}\n-\n-static zaddress forwarding_find(ZForwarding* forwarding, zoffset from_offset, ZForwardingCursor* cursor) {\n-  const uintptr_t from_index = forwarding_index(forwarding, from_offset);\n-  const ZForwardingEntry entry = forwarding->find(from_index, cursor);\n-  return entry.populated() ? ZOffset::address(to_zoffset(entry.to_offset())) : zaddress::null;\n-}\n-\n-static zaddress forwarding_find(ZForwarding* forwarding, zaddress_unsafe from_addr, ZForwardingCursor* cursor) {\n-  return forwarding_find(forwarding, ZAddress::offset(from_addr), cursor);\n-}\n-\n-static zaddress forwarding_find(ZForwarding* forwarding, zaddress from_addr, ZForwardingCursor* cursor) {\n-  return forwarding_find(forwarding, ZAddress::offset(from_addr), cursor);\n-}\n-\n-static zaddress forwarding_insert(ZForwarding* forwarding, zoffset from_offset, zaddress to_addr, ZForwardingCursor* cursor) {\n-  const uintptr_t from_index = forwarding_index(forwarding, from_offset);\n-  const zoffset to_offset = ZAddress::offset(to_addr);\n-  const zoffset to_offset_final = forwarding->insert(from_index, to_offset, cursor);\n-  return ZOffset::address(to_offset_final);\n-}\n-\n-static zaddress forwarding_insert(ZForwarding* forwarding, zaddress from_addr, zaddress to_addr, ZForwardingCursor* cursor) {\n-  return forwarding_insert(forwarding, ZAddress::offset(from_addr), to_addr, cursor);\n-}\n-\n@@ -371,1 +342,1 @@\n-  const zaddress to_addr_final = forwarding_insert(forwarding, from_addr, to_addr, cursor);\n+  const zaddress to_addr_final = forwarding->insert(from_addr, to_addr, cursor);\n@@ -385,1 +356,1 @@\n-  zaddress to_addr = forwarding_find(forwarding, from_addr, &cursor);\n+  zaddress to_addr = forwarding->find(from_addr, &cursor);\n@@ -412,2 +383,1 @@\n-  ZForwardingCursor cursor;\n-  const zaddress to_addr = forwarding_find(forwarding, from_addr, &cursor);\n+  const zaddress to_addr = forwarding->find(from_addr);\n@@ -629,1 +599,1 @@\n-      const zaddress to_addr = forwarding_find(_forwarding, from_addr, &cursor);\n+      const zaddress to_addr = _forwarding->find(from_addr, &cursor);\n@@ -653,1 +623,1 @@\n-    const zaddress to_addr = forwarding_insert(_forwarding, from_addr, allocated_addr, &cursor);\n+    const zaddress to_addr = _forwarding->insert(from_addr, allocated_addr, &cursor);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":6,"deletions":36,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+  friend class ZMapperTest;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemory.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+          range(0, 100)                                                     \\\n","filename":"src\/hotspot\/share\/gc\/z\/z_globals.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,1 @@\n-        if (RegisterFinalizersAtInit && m->code_size() == 1) {\n+        if (m->code_size() == 1) {\n@@ -264,1 +264,1 @@\n-        int method_index = cpool->decode_invokedynamic_index(invoke_bc.get_index_u4(code));\n+        int method_index = invoke_bc.get_index_u4(code);\n@@ -397,2 +397,1 @@\n-        int indy_index = method->constants()->decode_invokedynamic_index(index);\n-        method->constants()->resolved_indy_entry_at(indy_index)->set_num_parameters(callee_parameters);\n+        method->constants()->resolved_indy_entry_at(index)->set_num_parameters(callee_parameters);\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    int encoded_index = ResolutionErrorTable::encode_indy_index(ConstantPool::encode_invokedynamic_index(_indy_index));\n+    int encoded_index = ResolutionErrorTable::encode_indy_index(_indy_index);\n","filename":"src\/hotspot\/share\/interpreter\/bootstrapInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-  int decode_indy_index() const         { return ConstantPool::decode_invokedynamic_index(_indy_index); }\n","filename":"src\/hotspot\/share\/interpreter\/bootstrapInfo.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  return cpcache()->resolved_indy_entry_at(ConstantPool::decode_invokedynamic_index(index));\n+  return cpcache()->resolved_indy_entry_at(index);\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -558,2 +558,1 @@\n-          int i = get_native_index_u4();\n-          indy_index = ConstantPool::decode_invokedynamic_index(i);\n+          indy_index = get_native_index_u4();\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -867,5 +867,1 @@\n-    if (JvmtiExport::can_hotswap_or_post_breakpoint() && info.resolved_method()->is_old()) {\n-      resolved_method = methodHandle(current, info.resolved_method()->get_new_method());\n-    } else {\n-      resolved_method = methodHandle(current, info.resolved_method());\n-    }\n+    resolved_method = methodHandle(current, info.resolved_method());\n@@ -874,0 +870,3 @@\n+  \/\/ Don't allow safepoints until the method is cached.\n+  NoSafepointVerifier nsv;\n+\n@@ -963,1 +962,1 @@\n-  pool->cache()->set_dynamic_call(info, pool->decode_invokedynamic_index(index));\n+  pool->cache()->set_dynamic_call(info, index);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -115,0 +116,21 @@\n+\/\/ Redefinition safepoint may have updated the method. Make sure the new version of the method is returned.\n+\/\/ Callers are responsible for not safepointing and storing this method somewhere safe where redefinition\n+\/\/ can replace it if runs again.  Safe places are constant pool cache and code cache metadata.\n+\/\/ The old method is safe in CallInfo since its a methodHandle (it won't get deleted), and accessed with these\n+\/\/ accessors.\n+Method* CallInfo::resolved_method() const {\n+  if (JvmtiExport::can_hotswap_or_post_breakpoint() && _resolved_method->is_old()) {\n+    return _resolved_method->get_new_method();\n+  } else {\n+    return _resolved_method();\n+  }\n+}\n+\n+Method* CallInfo::selected_method() const {\n+  if (JvmtiExport::can_hotswap_or_post_breakpoint() && _selected_method->is_old()) {\n+    return _selected_method->get_new_method();\n+  } else {\n+    return _selected_method();\n+  }\n+}\n+\n@@ -1760,2 +1782,1 @@\n-  int index = pool->decode_invokedynamic_index(indy_index);\n-  int pool_index = pool->resolved_indy_entry_at(index)->constant_pool_index();\n+  int pool_index = pool->resolved_indy_entry_at(indy_index)->constant_pool_index();\n@@ -1764,1 +1785,1 @@\n-  BootstrapInfo bootstrap_specifier(pool, pool_index, index);\n+  BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,2 +95,2 @@\n-  Method* resolved_method() const                { return _resolved_method(); }\n-  Method* selected_method() const                { return _selected_method(); }\n+  Method* resolved_method() const;\n+  Method* selected_method() const;\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -184,12 +184,0 @@\n-InterpreterOopMap::~InterpreterOopMap() {\n-  \/\/ The expectation is that the bit mask was allocated\n-  \/\/ last in this resource area.  That would make the free of the\n-  \/\/ bit_mask effective (see how FREE_RESOURCE_ARRAY does a free).\n-  \/\/ If it was not allocated last, there is not a correctness problem\n-  \/\/ but the space for the bit_mask is not freed.\n-  assert(_resource_allocate_bit_mask, \"Trying to free C heap space\");\n-  if (mask_size() > small_mask_limit) {\n-    FREE_RESOURCE_ARRAY(uintptr_t, _bit_mask[0], mask_word_size());\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -131,1 +131,0 @@\n-  ~InterpreterOopMap();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-    Bytes::put_native_u4(p, ConstantPool::encode_invokedynamic_index(_invokedynamic_index));\n+    Bytes::put_native_u4(p, (u2)_invokedynamic_index);\n@@ -315,2 +315,1 @@\n-    int cache_index = ConstantPool::decode_invokedynamic_index(\n-                        Bytes::get_native_u4(p));\n+    int cache_index = Bytes::get_native_u4(p);\n@@ -534,1 +533,1 @@\n-  if (RegisterFinalizersAtInit && _klass->name() == vmSymbols::java_lang_Object()) {\n+  if (_klass->name() == vmSymbols::java_lang_Object()) {\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2250,1 +2250,1 @@\n-        u4 index = cp->constant_pool()->decode_invokedynamic_index(Bytes::get_native_u4(pc+1)); \/\/ index is originally negative\n+        u4 index = Bytes::get_native_u4(pc+1);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,0 +223,5 @@\n+  if (source == DCmd_Source_Internal && _args != nullptr && strcmp(_args, \"help\") == 0) {\n+     print_java_help(\"printStartupHelp\");\n+     vm_exit(0);\n+  }\n+\n@@ -244,1 +249,1 @@\n-void JfrDCmd::print_help(const char* name) const {\n+void JfrDCmd::print_java_help(const char* help_method) const {\n@@ -248,1 +253,1 @@\n-  JfrJavaArguments printHelp(&result, javaClass(), \"printHelp\", signature, thread);\n+  JfrJavaArguments printHelp(&result, javaClass(), help_method, signature, thread);\n@@ -253,0 +258,4 @@\n+void JfrDCmd::print_help(const char* name) const {\n+  print_java_help(\"printHelp\");\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  void print_java_help(const char* help_method) const;\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-jlong JNICALL jfr_register_stack_filter(JNIEnv* env, jobject classes, jobject methods);\n+jlong JNICALL jfr_register_stack_filter(JNIEnv* env, jclass jvm, jobjectArray classes, jobjectArray methods);\n@@ -166,1 +166,1 @@\n-jlong JNICALL jfr_unregister_stack_filter(JNIEnv* env, jlong start_filter_id);\n+jlong JNICALL jfr_unregister_stack_filter(JNIEnv* env, jclass jvm, jlong id);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -267,6 +267,6 @@\n-  if (last != sampler->last_resolved()) {\n-    ResourceMark rm;\n-    JfrKlassUnloading::sort();\n-    StackTraceBlobInstaller installer;\n-    iterate_samples(installer);\n-  }\n+  assert(last != nullptr, \"invariant\");\n+  assert(last != sampler->last_resolved(), \"invariant\");\n+  ResourceMark rm;\n+  JfrKlassUnloading::sort();\n+  StackTraceBlobInstaller installer;\n+  iterate_samples(installer);\n@@ -280,0 +280,3 @@\n+  if (!ObjectSampler::has_unresolved_entry()) {\n+    return;\n+  }\n@@ -425,2 +428,4 @@\n-  BlobInstaller installer;\n-  iterate_samples(installer);\n+  if (saved_type_set_blobs.valid()) {\n+    BlobInstaller installer;\n+    iterate_samples(installer);\n+  }\n@@ -439,0 +444,1 @@\n+\/\/ This routine has exclusive access to the sampler instance on entry.\n@@ -442,2 +448,8 @@\n-  const ObjectSample* last = ObjectSampler::sampler()->last();\n-  if (writer.has_data() && last != nullptr) {\n+  assert(ClassLoaderDataGraph_lock->owned_by_self(), \"invariant\");\n+  if (!ObjectSampler::has_unresolved_entry()) {\n+    return;\n+  }\n+  const ObjectSample* const last = ObjectSampler::sampler()->last();\n+  assert(last != nullptr, \"invariant\");\n+  assert(last != ObjectSampler::sampler()->last_resolved(), \"invariant\");\n+  if (writer.has_data()) {\n@@ -445,2 +457,0 @@\n-    install_type_set_blobs();\n-    ObjectSampler::sampler()->set_last_resolved(last);\n@@ -448,0 +458,2 @@\n+  install_type_set_blobs();\n+  ObjectSampler::sampler()->set_last_resolved(last);\n@@ -450,0 +462,1 @@\n+\/\/ This routine does NOT have exclusive access to the sampler instance on entry.\n@@ -452,1 +465,2 @@\n-  if (writer.has_data() && ObjectSampler::sampler()->last() != nullptr) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  if (writer.has_data() && ObjectSampler::has_unresolved_entry()) {\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"jfr\/utilities\/jfrSignal.hpp\"\n@@ -62,0 +63,19 @@\n+\/\/ A notification mechanism to let class unloading determine if to save unloaded typesets.\n+static JfrSignal _unresolved_entry;\n+\n+static inline void signal_unresolved_entry() {\n+  _unresolved_entry.signal_if_not_set();\n+}\n+\n+static inline void clear_unresolved_entry() {\n+  _unresolved_entry.reset();\n+}\n+\n+static inline void signal_resolved() {\n+  clear_unresolved_entry();\n+}\n+\n+bool ObjectSampler::has_unresolved_entry() {\n+  return _unresolved_entry.is_signaled();\n+}\n+\n@@ -111,0 +131,2 @@\n+  clear_unresolved_entry();\n+  assert(!has_unresolved_entry(), \"invariant\");\n@@ -245,0 +267,1 @@\n+  signal_unresolved_entry();\n@@ -307,0 +330,1 @@\n+  signal_resolved();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  static bool has_unresolved_entry();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -687,11 +687,0 @@\n-  <Event name=\"SafepointCleanup\" category=\"Java Virtual Machine, Runtime, Safepoint\" label=\"Safepoint Cleanup\" description=\"Safepointing begin running cleanup tasks\"\n-    thread=\"true\">\n-    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n-  <\/Event>\n-\n-  <Event name=\"SafepointCleanupTask\" category=\"Java Virtual Machine, Runtime, Safepoint\" label=\"Safepoint Cleanup Task\" description=\"Safepointing begin running cleanup tasks\"\n-    thread=\"true\">\n-    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n-    <Field type=\"string\" name=\"name\" label=\"Task Name\" description=\"The task name\" \/>\n-  <\/Event>\n-\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,4 @@\n+  void reset() const {\n+    Atomic::release_store(&_signaled, false);\n+  }\n+\n@@ -44,0 +48,6 @@\n+  void signal_if_not_set() const {\n+    if (!is_signaled()) {\n+      signal();\n+    }\n+  }\n+\n@@ -46,1 +56,1 @@\n-      Atomic::release_store(&_signaled, false);\n+      reset();\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSignal.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -707,0 +707,1 @@\n+    JVMCINMethodHandle& nmethod_handle,\n@@ -808,0 +809,2 @@\n+      guarantee(nm != nullptr, \"successful compile must produce an nmethod\");\n+      nmethod_handle.set_nmethod(nm);\n@@ -816,4 +819,2 @@\n-      if (nm != nullptr) {\n-        if (_nmethod_entry_patch_offset != -1) {\n-          err_msg msg(\"\");\n-          BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+      if (_nmethod_entry_patch_offset != -1) {\n+        BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n@@ -821,3 +822,4 @@\n-          if (!bs_nm->verify_barrier(nm, msg)) {\n-            JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n-          }\n+        \/\/ an empty error buffer for use by the verify_barrier code\n+        err_msg msg(\"\");\n+        if (!bs_nm->verify_barrier(nm, msg)) {\n+          JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n@@ -1246,1 +1248,2 @@\n-      if (CompiledDirectCall::emit_to_interp_stub(buffer, _instructions->start() + pc_offset) == nullptr) {\n+      MacroAssembler masm(&buffer);\n+      if (CompiledDirectCall::emit_to_interp_stub(&masm, _instructions->start() + pc_offset) == nullptr) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -335,0 +335,1 @@\n+                                   JVMCINMethodHandle& nmethod_handle,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -64,0 +65,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -911,1 +913,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which))\n+C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which, jint opcode))\n@@ -913,1 +915,1 @@\n-  oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, which);\n+  oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, which, Bytecodes::Code(opcode));\n@@ -1109,0 +1111,1 @@\n+  JVMCINMethodHandle nmethod_handle(THREAD);\n@@ -1116,0 +1119,1 @@\n+      nmethod_handle,\n@@ -1207,1 +1211,2 @@\n-  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror);\n+  JVMCINMethodHandle nmethod_handle(THREAD);\n+  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, nmethod_handle);\n@@ -1481,0 +1486,1 @@\n+  KeepStackGCProcessedMark keep_stack(THREAD);\n@@ -1626,5 +1632,1 @@\n-C2V_VMENTRY_0(int, decodeIndyIndexToCPIndex, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint encoded_indy_index, jboolean resolve))\n-  if (!ConstantPool::is_invokedynamic_index(encoded_indy_index)) {\n-    JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"not an encoded indy index %d\", encoded_indy_index));\n-  }\n-\n+C2V_VMENTRY_0(int, decodeIndyIndexToCPIndex, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint indy_index, jboolean resolve))\n@@ -1633,1 +1635,0 @@\n-  int indy_index = cp->decode_invokedynamic_index(encoded_indy_index);\n@@ -1635,1 +1636,1 @@\n-    LinkResolver::resolve_invoke(callInfo, Handle(), cp, encoded_indy_index, Bytecodes::_invokedynamic, CHECK_0);\n+    LinkResolver::resolve_invoke(callInfo, Handle(), cp, indy_index, Bytecodes::_invokedynamic, CHECK_0);\n@@ -1668,1 +1669,1 @@\n-C2V_VMENTRY_0(jint, isResolvedInvokeHandleInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_0(jint, isResolvedInvokeHandleInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, jint opcode))\n@@ -1702,2 +1703,2 @@\n-  if (cp->is_invokedynamic_index(index)) {\n-    if (cp->resolved_indy_entry_at(cp->decode_invokedynamic_index(index))->is_resolved()) {\n+  if ((Bytecodes::Code)opcode == Bytecodes::_invokedynamic) {\n+    if (cp->resolved_indy_entry_at(index)->is_resolved()) {\n@@ -2765,1 +2766,2 @@\n-      nmethod* nm = JVMCIENV->get_nmethod(obj);\n+      JVMCINMethodHandle nmethod_handle(THREAD);\n+      nmethod* nm = JVMCIENV->get_nmethod(obj, nmethod_handle);\n@@ -2788,1 +2790,2 @@\n-      nmethod* nm = JVMCIENV->get_nmethod(obj);\n+      JVMCINMethodHandle nmethod_handle(THREAD);\n+      nmethod* nm = JVMCIENV->get_nmethod(obj, nmethod_handle);\n@@ -2840,1 +2843,2 @@\n-  JVMCIENV->get_nmethod(code);\n+  JVMCINMethodHandle nmethod_handle(THREAD);\n+  JVMCIENV->get_nmethod(code, nmethod_handle);\n@@ -3222,1 +3226,1 @@\n-  {CC \"lookupAppendixInPool\",                         CC \"(\" HS_CONSTANT_POOL2 \"I)\" OBJECTCONSTANT,                                         FN_PTR(lookupAppendixInPool)},\n+  {CC \"lookupAppendixInPool\",                         CC \"(\" HS_CONSTANT_POOL2 \"II)\" OBJECTCONSTANT,                                        FN_PTR(lookupAppendixInPool)},\n@@ -3234,1 +3238,1 @@\n-  {CC \"isResolvedInvokeHandleInPool\",                 CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(isResolvedInvokeHandleInPool)},\n+  {CC \"isResolvedInvokeHandleInPool\",                 CC \"(\" HS_CONSTANT_POOL2 \"II)I\",                                                      FN_PTR(isResolvedInvokeHandleInPool)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -1725,6 +1727,0 @@\n-  nmethod* nm = JVMCIENV->get_nmethod(mirror);\n-  if (nm == nullptr) {\n-    \/\/ Nothing to do\n-    return;\n-  }\n-\n@@ -1739,0 +1735,8 @@\n+  JavaThread* thread = JavaThread::cast(current);\n+  JVMCINMethodHandle nmethod_handle(thread);\n+  nmethod* nm = JVMCIENV->get_nmethod(mirror, nmethod_handle);\n+  if (nm == nullptr) {\n+    \/\/ Nothing to do\n+    return;\n+  }\n+\n@@ -1828,1 +1832,9 @@\n-nmethod* JVMCIEnv::get_nmethod(JVMCIObject obj) {\n+void JVMCINMethodHandle::set_nmethod(nmethod* nm) {\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm != nullptr) {\n+    bs_nm->nmethod_entry_barrier(nm);\n+  }\n+  _thread->set_live_nmethod(nm);\n+}\n+\n+nmethod* JVMCIEnv::get_nmethod(JVMCIObject obj, JVMCINMethodHandle& nmethod_handle) {\n@@ -1831,1 +1843,5 @@\n-    return cb->as_nmethod_or_null();\n+    nmethod* nm = cb->as_nmethod_or_null();\n+    if (nm != nullptr) {\n+      nmethod_handle.set_nmethod(nm);\n+      return nm;\n+    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -91,0 +91,15 @@\n+\/\/ A helper class to main a strong link to an nmethod that might not otherwise be referenced.  Only\n+\/\/ one nmethod can be kept alive in this manner.\n+class JVMCINMethodHandle : public StackObj {\n+  JavaThread* _thread;\n+\n+ public:\n+  JVMCINMethodHandle(JavaThread* thread): _thread(thread) {}\n+\n+  void set_nmethod(nmethod* nm);\n+\n+  ~JVMCINMethodHandle() {\n+    _thread->clear_live_nmethod();\n+  }\n+};\n+\n@@ -373,1 +388,1 @@\n-  \/\/ Given an instance of HotSpotInstalledCode return the corresponding CodeBlob*.\n+  \/\/ Given an instance of HotSpotInstalledCode, return the corresponding CodeBlob*.\n@@ -376,2 +391,2 @@\n-  \/\/ Given an instance of HotSpotInstalledCode return the corresponding nmethod.\n-  nmethod* get_nmethod(JVMCIObject code);\n+  \/\/ Given an instance of HotSpotInstalledCode, return the corresponding nmethod.\n+  nmethod* get_nmethod(JVMCIObject code, JVMCINMethodHandle& nmethod_handle);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1859,3 +1859,2 @@\n-    int indy_index = cpool->decode_invokedynamic_index(index);\n-    if (cpool->resolved_indy_entry_at(indy_index)->is_resolved()) {\n-      return cpool->resolved_indy_entry_at(indy_index)->method();\n+    if (cpool->resolved_indy_entry_at(index)->is_resolved()) {\n+      return cpool->resolved_indy_entry_at(index)->method();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-  nonstatic_field(nmethod,                     _verified_entry_point,                         address)                               \\\n+  nonstatic_field(nmethod,                     _verified_entry_offset,                        u2)                                    \\\n@@ -345,0 +345,1 @@\n+  static_field(StubRoutines,                _unsafe_setmemory,                                address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-    size_t  _length;                             \/\/ the length in segments\n-    bool    _used;                               \/\/ Used bit\n+    uint32_t  _length;                           \/\/ the length in segments\n+    bool      _used;                             \/\/ Used bit\n@@ -54,1 +54,1 @@\n-  void initialize(size_t length)                 { _header._length = length; set_used(); }\n+  void initialize(size_t length)                 { set_length(length); set_used(); }\n@@ -56,1 +56,3 @@\n-  void set_length(size_t length)                 { _header._length = length; }\n+  void set_length(size_t length)                 {\n+    _header._length = checked_cast<uint32_t>(length);\n+  }\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -164,0 +164,3 @@\n+uintx Universe::_the_array_interfaces_bitmap = 0;\n+uintx Universe::_the_empty_klass_bitmap      = 0;\n+\n@@ -229,1 +232,1 @@\n-static BuiltinException _virtual_machine_error;\n+static BuiltinException _internal_error;\n@@ -246,1 +249,1 @@\n-oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error.instance(); }\n+oop Universe::internal_error_instance()           { return _internal_error.instance(); }\n@@ -302,1 +305,1 @@\n-  _virtual_machine_error.store_in_cds();\n+  _internal_error.store_in_cds();\n@@ -318,1 +321,1 @@\n-    _virtual_machine_error.load_from_cds();\n+    _internal_error.load_from_cds();\n@@ -334,1 +337,1 @@\n-  _virtual_machine_error.serialize(f);\n+  _internal_error.serialize(f);\n@@ -440,0 +443,5 @@\n+    if (UseSecondarySupersTable) {\n+      Universe::_the_array_interfaces_bitmap = Klass::compute_secondary_supers_bitmap(_the_array_interfaces_array);\n+      Universe::_the_empty_klass_bitmap      = Klass::compute_secondary_supers_bitmap(_the_empty_klass_array);\n+    }\n+\n@@ -1087,1 +1095,1 @@\n-  Klass* k = vmClasses::VirtualMachineError_klass();\n+  Klass* k = vmClasses::InternalError_klass();\n@@ -1090,1 +1098,1 @@\n-     tty->print_cr(\"Unable to link\/verify VirtualMachineError class\");\n+     tty->print_cr(\"Unable to link\/verify InternalError class\");\n@@ -1093,1 +1101,1 @@\n-  _virtual_machine_error.init_if_empty(vmSymbols::java_lang_VirtualMachineError(), CHECK_false);\n+  _internal_error.init_if_empty(vmSymbols::java_lang_InternalError(), CHECK_false);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -99,0 +99,3 @@\n+  static uintx _the_array_interfaces_bitmap;\n+  static uintx _the_empty_klass_bitmap;\n+\n@@ -229,2 +232,2 @@\n-  static oop          virtual_machine_error_instance();\n-  static oop          vm_exception()                  { return virtual_machine_error_instance(); }\n+  static oop          internal_error_instance();\n+  static oop          vm_exception()                  { return internal_error_instance(); }\n@@ -232,1 +235,2 @@\n-  static Array<Klass*>* the_array_interfaces_array()  { return _the_array_interfaces_array;   }\n+  static Array<Klass*>* the_array_interfaces_array()  { return _the_array_interfaces_array; }\n+  static uintx        the_array_interfaces_bitmap()   { return _the_array_interfaces_bitmap; }\n@@ -265,0 +269,2 @@\n+  static uintx                   the_empty_klass_bitmap() { return _the_empty_klass_bitmap; }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -182,1 +182,2 @@\n-  set_secondary_supers(Universe::the_array_interfaces_array());\n+  set_secondary_supers(Universe::the_array_interfaces_array(),\n+                       Universe::the_array_interfaces_bitmap());\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -655,1 +655,1 @@\n-bool ConstantPool::has_appendix_at_if_loaded(const constantPoolHandle& cpool, int which) {\n+bool ConstantPool::has_appendix_at_if_loaded(const constantPoolHandle& cpool, int which, Bytecodes::Code code) {\n@@ -657,3 +657,2 @@\n-  if (is_invokedynamic_index(which)) {\n-    int indy_index = decode_invokedynamic_index(which);\n-    return cpool->resolved_indy_entry_at(indy_index)->has_appendix();\n+  if (code == Bytecodes::_invokedynamic) {\n+    return cpool->resolved_indy_entry_at(which)->has_appendix();\n@@ -665,1 +664,1 @@\n-oop ConstantPool::appendix_at_if_loaded(const constantPoolHandle& cpool, int which) {\n+oop ConstantPool::appendix_at_if_loaded(const constantPoolHandle& cpool, int which, Bytecodes::Code code) {\n@@ -667,3 +666,2 @@\n-  if (is_invokedynamic_index(which)) {\n-    int indy_index = decode_invokedynamic_index(which);\n-    return cpool->resolved_reference_from_indy(indy_index);\n+  if (code == Bytecodes::_invokedynamic) {\n+    return cpool->resolved_reference_from_indy(which);\n@@ -676,1 +674,1 @@\n-bool ConstantPool::has_local_signature_at_if_loaded(const constantPoolHandle& cpool, int which) {\n+bool ConstantPool::has_local_signature_at_if_loaded(const constantPoolHandle& cpool, int which, Bytecodes::Code code) {\n@@ -678,3 +676,2 @@\n-  if (is_invokedynamic_index(which)) {\n-    int indy_index = decode_invokedynamic_index(which);\n-    return cpool->resolved_indy_entry_at(indy_index)->has_local_signature();\n+  if (code == Bytecodes::_invokedynamic) {\n+    return cpool->resolved_indy_entry_at(which)->has_local_signature();\n@@ -742,2 +739,0 @@\n-  guarantee(!ConstantPool::is_invokedynamic_index(index),\n-            \"an invokedynamic instruction does not have a klass\");\n@@ -805,1 +800,3 @@\n-static Symbol* exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception) {\n+static const char* exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception) {\n+  \/\/ Note: caller needs ResourceMark\n+\n@@ -807,3 +804,3 @@\n-  Symbol* message = java_lang_Throwable::detail_message(pending_exception);\n-  if (message != nullptr) {\n-    return message;\n+  const char* msg = java_lang_Throwable::message_as_utf8(pending_exception);\n+  if (msg != nullptr) {\n+    return msg;\n@@ -812,0 +809,1 @@\n+  Symbol* message = nullptr;\n@@ -834,1 +832,1 @@\n-  return message;\n+  return message != nullptr ? message->as_C_string() : nullptr;\n@@ -837,1 +835,1 @@\n-static void add_resolution_error(const constantPoolHandle& this_cp, int which,\n+static void add_resolution_error(JavaThread* current, const constantPoolHandle& this_cp, int which,\n@@ -840,0 +838,1 @@\n+  ResourceMark rm(current);\n@@ -845,1 +844,1 @@\n-  Symbol* cause_msg = nullptr;\n+  const char* cause_msg = nullptr;\n@@ -848,1 +847,1 @@\n-    cause_msg = java_lang_Throwable::detail_message(cause);\n+    cause_msg = java_lang_Throwable::message_as_utf8(cause);\n@@ -851,1 +850,1 @@\n-  Symbol* message = exception_message(this_cp, which, tag, pending_exception);\n+  const char* message = exception_message(this_cp, which, tag, pending_exception);\n@@ -858,1 +857,1 @@\n-  Symbol* message = nullptr;\n+  const char* message = nullptr;\n@@ -860,1 +859,1 @@\n-  Symbol* cause_msg = nullptr;\n+  const char* cause_msg = nullptr;\n@@ -863,1 +862,0 @@\n-  const char* cause_str = cause_msg != nullptr ? cause_msg->as_C_string() : nullptr;\n@@ -867,1 +865,0 @@\n-    char* msg = message->as_C_string();\n@@ -869,2 +866,2 @@\n-      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_str);\n-      THROW_MSG_CAUSE(error, msg, h_cause);\n+      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_msg);\n+      THROW_MSG_CAUSE(error, message, h_cause);\n@@ -872,1 +869,1 @@\n-      THROW_MSG(error, msg);\n+      THROW_MSG(error, message);\n@@ -876,1 +873,1 @@\n-      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_str);\n+      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_msg);\n@@ -898,1 +895,1 @@\n-    add_resolution_error(this_cp, cp_index, tag, PENDING_EXCEPTION);\n+    add_resolution_error(THREAD, this_cp, cp_index, tag, PENDING_EXCEPTION);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":29,"deletions":32,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -251,8 +251,0 @@\n-  \/\/ Invokedynamic indexes.\n-  \/\/ They must look completely different from normal indexes.\n-  \/\/ The main reason is that byte swapping is sometimes done on normal indexes.\n-  \/\/ Finally, it is helpful for debugging to tell the two apart.\n-  static bool is_invokedynamic_index(int i) { return (i < 0); }\n-  static int  decode_invokedynamic_index(int i) { assert(is_invokedynamic_index(i),  \"\"); return ~i; }\n-  static int  encode_invokedynamic_index(int i) { assert(!is_invokedynamic_index(i), \"\"); return ~i; }\n-\n@@ -764,3 +756,3 @@\n-  static bool       has_appendix_at_if_loaded      (const constantPoolHandle& this_cp, int which);\n-  static oop            appendix_at_if_loaded      (const constantPoolHandle& this_cp, int which);\n-  static bool has_local_signature_at_if_loaded     (const constantPoolHandle& this_cp, int which);\n+  static bool       has_appendix_at_if_loaded      (const constantPoolHandle& this_cp, int which, Bytecodes::Code code);\n+  static oop            appendix_at_if_loaded      (const constantPoolHandle& this_cp, int which, Bytecodes::Code code);\n+  static bool has_local_signature_at_if_loaded     (const constantPoolHandle& this_cp, int which, Bytecodes::Code code);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  return cache()->resolved_indy_entry_at(decode_invokedynamic_index(indy_index))->constant_pool_index();\n+  return cache()->resolved_indy_entry_at(indy_index)->constant_pool_index();\n","filename":"src\/hotspot\/share\/oops\/constantPool.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-\n+  ResourceMark rm(THREAD);\n@@ -571,1 +571,1 @@\n-  Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);\n+  const char* message = java_lang_Throwable::message_as_utf8(PENDING_EXCEPTION);\n@@ -573,2 +573,1 @@\n-  int encoded_index = ResolutionErrorTable::encode_indy_index(\n-                          ConstantPool::encode_invokedynamic_index(index));\n+  int encoded_index = ResolutionErrorTable::encode_indy_index(index);\n@@ -593,2 +592,1 @@\n-    int encoded_index = ResolutionErrorTable::encode_indy_index(\n-                          ConstantPool::encode_invokedynamic_index(index));\n+    int encoded_index = ResolutionErrorTable::encode_indy_index(index);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1430,1 +1430,3 @@\n-  Array<InstanceKlass*>* interfaces = transitive_interfaces;\n+  \/\/ We need the cast because Array<Klass*> is NOT a supertype of Array<InstanceKlass*>,\n+  \/\/ (but it's safe to do here because we won't write into _secondary_supers from this point on).\n+  Array<Klass*>* interfaces = (Array<Klass*>*)(address)transitive_interfaces;\n@@ -1434,1 +1436,1 @@\n-    set_secondary_supers(Universe::the_empty_klass_array());\n+    set_secondary_supers(Universe::the_empty_klass_array(), Universe::the_empty_klass_bitmap());\n@@ -1440,10 +1442,9 @@\n-    \/\/ We need the cast because Array<Klass*> is NOT a supertype of Array<InstanceKlass*>,\n-    \/\/ (but it's safe to do here because we won't write into _secondary_supers from this point on).\n-    set_secondary_supers((Array<Klass*>*)(address)interfaces);\n-    return nullptr;\n-  } else {\n-    \/\/ Copy transitive interfaces to a temporary growable array to be constructed\n-    \/\/ into the secondary super list with extra slots.\n-    GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(interfaces->length());\n-    for (int i = 0; i < interfaces->length(); i++) {\n-      secondaries->push(interfaces->at(i));\n+    if (!UseSecondarySupersTable) {\n+      set_secondary_supers(interfaces);\n+      return nullptr;\n+    } else if (num_extra_slots == 0 && interfaces->length() <= 1) {\n+      \/\/ We will reuse the transitive interfaces list if we're certain\n+      \/\/ it's in hash order.\n+      uintx bitmap = compute_secondary_supers_bitmap(interfaces);\n+      set_secondary_supers(interfaces, bitmap);\n+      return nullptr;\n@@ -1451,1 +1452,7 @@\n-    return secondaries;\n+    \/\/ ... fall through if that didn't work.\n+  }\n+  \/\/ Copy transitive interfaces to a temporary growable array to be constructed\n+  \/\/ into the secondary super list with extra slots.\n+  GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(interfaces->length());\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    secondaries->push(interfaces->at(i));\n@@ -1453,0 +1460,1 @@\n+  return secondaries;\n@@ -1504,1 +1512,1 @@\n-  bool has_finalizer_flag = has_finalizer(); \/\/ Query before possible GC\n+  assert(!is_abstract() && !is_interface(), \"Should not create this object\");\n@@ -1506,8 +1514,1 @@\n-\n-  instanceOop i;\n-\n-  i = (instanceOop)Universe::heap()->obj_allocate(this, size, CHECK_NULL);\n-  if (has_finalizer_flag && !RegisterFinalizersAtInit) {\n-    i = register_finalizer(i, CHECK_NULL);\n-  }\n-  return i;\n+  return (instanceOop)Universe::heap()->obj_allocate(this, size, CHECK_NULL);\n@@ -3540,1 +3541,1 @@\n-  st->print(BULLET\"methods:           \"); methods()->print_value_on(st);                  st->cr();\n+  st->print(BULLET\"methods:           \"); methods()->print_value_on(st);               st->cr();\n@@ -3560,0 +3561,23 @@\n+\n+  st->print(BULLET\"secondary supers: \"); secondary_supers()->print_value_on(st); st->cr();\n+  if (UseSecondarySupersTable) {\n+    st->print(BULLET\"hash_slot:         %d\", hash_slot()); st->cr();\n+    st->print(BULLET\"bitmap:            \" UINTX_FORMAT_X_0, _bitmap); st->cr();\n+  }\n+  if (secondary_supers() != nullptr) {\n+    if (Verbose) {\n+      bool is_hashed = UseSecondarySupersTable && (_bitmap != SECONDARY_SUPERS_BITMAP_FULL);\n+      st->print_cr(BULLET\"---- secondary supers (%d words):\", _secondary_supers->length());\n+      for (int i = 0; i < _secondary_supers->length(); i++) {\n+        ResourceMark rm; \/\/ for external_name()\n+        Klass* secondary_super = _secondary_supers->at(i);\n+        st->print(BULLET\"%2d:\", i);\n+        if (is_hashed) {\n+          int home_slot = compute_home_slot(secondary_super, _bitmap);\n+          int distance = (i - home_slot) & SECONDARY_SUPERS_TABLE_MASK;\n+          st->print(\" dist:%02d:\", distance);\n+        }\n+        st->print_cr(\" %p %s\", secondary_super, secondary_super->external_name());\n+      }\n+    }\n+  }\n@@ -3617,0 +3641,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":48,"deletions":23,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -962,1 +962,0 @@\n-  \/\/  - the class has a finalizer (if !RegisterFinalizersAtInit)\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -56,0 +58,1 @@\n+#include \"utilities\/rotate_bits.hpp\"\n@@ -80,0 +83,41 @@\n+uint8_t Klass::compute_hash_slot(Symbol* n) {\n+  uint hash_code;\n+  \/\/ Special cases for the two superclasses of all Array instances.\n+  \/\/ Code elsewhere assumes, for all instances of ArrayKlass, that\n+  \/\/ these two interfaces will be in this order.\n+\n+  \/\/ We ensure there are some empty slots in the hash table between\n+  \/\/ these two very common interfaces because if they were adjacent\n+  \/\/ (e.g. Slots 0 and 1), then any other class which hashed to 0 or 1\n+  \/\/ would result in a probe length of 3.\n+  if (n == vmSymbols::java_lang_Cloneable()) {\n+    hash_code = 0;\n+  } else if (n == vmSymbols::java_io_Serializable()) {\n+    hash_code = SECONDARY_SUPERS_TABLE_SIZE \/ 2;\n+  } else {\n+    auto s = (const jbyte*) n->bytes();\n+    hash_code = java_lang_String::hash_code(s, n->utf8_length());\n+    \/\/ We use String::hash_code here (rather than e.g.\n+    \/\/ Symbol::identity_hash()) in order to have a hash code that\n+    \/\/ does not change from run to run. We want that because the\n+    \/\/ hash value for a secondary superclass appears in generated\n+    \/\/ code as a constant.\n+\n+    \/\/ This constant is magic: see Knuth, \"Fibonacci Hashing\".\n+    constexpr uint multiplier\n+      = 2654435769; \/\/ (uint)(((u8)1 << 32) \/ ((1 + sqrt(5)) \/ 2 ))\n+    constexpr uint hash_shift = sizeof(hash_code) * 8 - 6;\n+    \/\/ The leading bits of the least significant half of the product.\n+    hash_code = (hash_code * multiplier) >> hash_shift;\n+\n+    if (StressSecondarySupers) {\n+      \/\/ Generate many hash collisions in order to stress-test the\n+      \/\/ linear search fallback.\n+      hash_code = hash_code % 3;\n+      hash_code = hash_code * (SECONDARY_SUPERS_TABLE_SIZE \/ 3);\n+    }\n+  }\n+\n+  return (hash_code & SECONDARY_SUPERS_TABLE_MASK);\n+}\n+\n@@ -82,1 +126,17 @@\n-  if (_name != nullptr) _name->increment_refcount();\n+\n+  if (_name != nullptr) {\n+    _name->increment_refcount();\n+  }\n+\n+  if (UseSecondarySupersTable) {\n+    elapsedTimer selftime;\n+    selftime.start();\n+\n+    _hash_slot = compute_hash_slot(n);\n+    assert(_hash_slot < SECONDARY_SUPERS_TABLE_SIZE, \"required\");\n+\n+    selftime.stop();\n+    if (UsePerfData) {\n+      ClassLoader::perf_secondary_hash_time()->inc(selftime.ticks());\n+    }\n+  }\n@@ -239,0 +299,169 @@\n+void Klass::set_secondary_supers(Array<Klass*>* secondaries) {\n+  assert(!UseSecondarySupersTable || secondaries == nullptr, \"\");\n+  set_secondary_supers(secondaries, SECONDARY_SUPERS_BITMAP_EMPTY);\n+}\n+\n+void Klass::set_secondary_supers(Array<Klass*>* secondaries, uintx bitmap) {\n+#ifdef ASSERT\n+  if (UseSecondarySupersTable && secondaries != nullptr) {\n+    uintx real_bitmap = compute_secondary_supers_bitmap(secondaries);\n+    assert(bitmap == real_bitmap, \"must be\");\n+  }\n+#endif\n+  _bitmap = bitmap;\n+  _secondary_supers = secondaries;\n+\n+  if (secondaries != nullptr) {\n+    LogMessage(class, load) msg;\n+    NonInterleavingLogStream log {LogLevel::Debug, msg};\n+    if (log.is_enabled()) {\n+      ResourceMark rm;\n+      log.print_cr(\"set_secondary_supers: hash_slot: %d; klass: %s\", hash_slot(), external_name());\n+      print_secondary_supers_on(&log);\n+    }\n+  }\n+}\n+\n+\/\/ Hashed secondary superclasses\n+\/\/\n+\/\/ We use a compressed 64-entry hash table with linear probing. We\n+\/\/ start by creating a hash table in the usual way, followed by a pass\n+\/\/ that removes all the null entries. To indicate which entries would\n+\/\/ have been null we use a bitmap that contains a 1 in each position\n+\/\/ where an entry is present, 0 otherwise. This bitmap also serves as\n+\/\/ a kind of Bloom filter, which in many cases allows us quickly to\n+\/\/ eliminate the possibility that something is a member of a set of\n+\/\/ secondaries.\n+uintx Klass::hash_secondary_supers(Array<Klass*>* secondaries, bool rewrite) {\n+  const int length = secondaries->length();\n+\n+  if (length == 0) {\n+    return SECONDARY_SUPERS_BITMAP_EMPTY;\n+  }\n+\n+  if (length == 1) {\n+    int hash_slot = secondaries->at(0)->hash_slot();\n+    return uintx(1) << hash_slot;\n+  }\n+\n+  \/\/ For performance reasons we don't use a hashed table unless there\n+  \/\/ are at least two empty slots in it. If there were only one empty\n+  \/\/ slot it'd take a long time to create the table and the resulting\n+  \/\/ search would be no faster than linear probing.\n+  if (length > SECONDARY_SUPERS_TABLE_SIZE - 2) {\n+    return SECONDARY_SUPERS_BITMAP_FULL;\n+  }\n+\n+  {\n+    PerfTraceTime ptt(ClassLoader::perf_secondary_hash_time());\n+\n+    ResourceMark rm;\n+    uintx bitmap = SECONDARY_SUPERS_BITMAP_EMPTY;\n+    auto hashed_secondaries = new GrowableArray<Klass*>(SECONDARY_SUPERS_TABLE_SIZE,\n+                                                        SECONDARY_SUPERS_TABLE_SIZE, nullptr);\n+\n+    for (int j = 0; j < length; j++) {\n+      Klass* k = secondaries->at(j);\n+      hash_insert(k, hashed_secondaries, bitmap);\n+    }\n+\n+    \/\/ Pack the hashed secondaries array by copying it into the\n+    \/\/ secondaries array, sans nulls, if modification is allowed.\n+    \/\/ Otherwise, validate the order.\n+    int i = 0;\n+    for (int slot = 0; slot < SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      bool has_element = ((bitmap >> slot) & 1) != 0;\n+      assert(has_element == (hashed_secondaries->at(slot) != nullptr), \"\");\n+      if (has_element) {\n+        Klass* k = hashed_secondaries->at(slot);\n+        if (rewrite) {\n+          secondaries->at_put(i, k);\n+        } else if (secondaries->at(i) != k) {\n+          assert(false, \"broken secondary supers hash table\");\n+          return SECONDARY_SUPERS_BITMAP_FULL;\n+        }\n+        i++;\n+      }\n+    }\n+    assert(i == secondaries->length(), \"mismatch\");\n+\n+    return bitmap;\n+  }\n+}\n+\n+void Klass::hash_insert(Klass* klass, GrowableArray<Klass*>* secondaries, uintx& bitmap) {\n+  assert(bitmap != SECONDARY_SUPERS_BITMAP_FULL, \"\");\n+\n+  int dist = 0;\n+  for (int slot = klass->hash_slot(); true; slot = (slot + 1) & SECONDARY_SUPERS_TABLE_MASK) {\n+    Klass* existing = secondaries->at(slot);\n+    assert(((bitmap >> slot) & 1) == (existing != nullptr), \"mismatch\");\n+    if (existing == nullptr) { \/\/ no conflict\n+      secondaries->at_put(slot, klass);\n+      bitmap |= uintx(1) << slot;\n+      assert(bitmap != SECONDARY_SUPERS_BITMAP_FULL, \"\");\n+      return;\n+    } else {\n+      \/\/ Use Robin Hood hashing to minimize the worst case search.\n+      \/\/ Also, every permutation of the insertion sequence produces\n+      \/\/ the same final Robin Hood hash table, provided that a\n+      \/\/ consistent tie breaker is used.\n+      int existing_dist = (slot - existing->hash_slot()) & SECONDARY_SUPERS_TABLE_MASK;\n+      if (existing_dist < dist\n+          \/\/ This tie breaker ensures that the hash order is maintained.\n+          || ((existing_dist == dist)\n+              && (uintptr_t(existing) < uintptr_t(klass)))) {\n+        Klass* tmp = secondaries->at(slot);\n+        secondaries->at_put(slot, klass);\n+        klass = tmp;\n+        dist = existing_dist;\n+      }\n+      ++dist;\n+    }\n+  }\n+}\n+\n+Array<Klass*>* Klass::pack_secondary_supers(ClassLoaderData* loader_data,\n+                                            GrowableArray<Klass*>* primaries,\n+                                            GrowableArray<Klass*>* secondaries,\n+                                            uintx& bitmap, TRAPS) {\n+  int new_length = primaries->length() + secondaries->length();\n+  Array<Klass*>* secondary_supers = MetadataFactory::new_array<Klass*>(loader_data, new_length, CHECK_NULL);\n+\n+  \/\/ Combine the two arrays into a metadata object to pack the array.\n+  \/\/ The primaries are added in the reverse order, then the secondaries.\n+  int fill_p = primaries->length();\n+  for (int j = 0; j < fill_p; j++) {\n+    secondary_supers->at_put(j, primaries->pop());  \/\/ add primaries in reverse order.\n+  }\n+  for( int j = 0; j < secondaries->length(); j++ ) {\n+    secondary_supers->at_put(j+fill_p, secondaries->at(j));  \/\/ add secondaries on the end.\n+  }\n+#ifdef ASSERT\n+  \/\/ We must not copy any null placeholders left over from bootstrap.\n+  for (int j = 0; j < secondary_supers->length(); j++) {\n+    assert(secondary_supers->at(j) != nullptr, \"correct bootstrapping order\");\n+  }\n+#endif\n+\n+  if (UseSecondarySupersTable) {\n+    bitmap = hash_secondary_supers(secondary_supers, \/*rewrite=*\/true); \/\/ rewrites freshly allocated array\n+  } else {\n+    bitmap = SECONDARY_SUPERS_BITMAP_EMPTY;\n+  }\n+  return secondary_supers;\n+}\n+\n+uintx Klass::compute_secondary_supers_bitmap(Array<Klass*>* secondary_supers) {\n+  return hash_secondary_supers(secondary_supers, \/*rewrite=*\/false); \/\/ no rewrites allowed\n+}\n+\n+uint8_t Klass::compute_home_slot(Klass* k, uintx bitmap) {\n+  uint8_t hash = k->hash_slot();\n+  if (hash > 0) {\n+    return population_count(bitmap << (SECONDARY_SUPERS_TABLE_SIZE - hash));\n+  }\n+  return 0;\n+}\n+\n+\n@@ -329,20 +558,3 @@\n-    \/\/ The primaries are added in the reverse order, then the secondaries.\n-    int new_length = primaries->length() + secondaries->length();\n-    Array<Klass*>* s2 = MetadataFactory::new_array<Klass*>(\n-                                       class_loader_data(), new_length, CHECK);\n-    int fill_p = primaries->length();\n-    for (int j = 0; j < fill_p; j++) {\n-      s2->at_put(j, primaries->pop());  \/\/ add primaries in reverse order.\n-    }\n-    for( int j = 0; j < secondaries->length(); j++ ) {\n-      s2->at_put(j+fill_p, secondaries->at(j));  \/\/ add secondaries on the end.\n-    }\n-\n-  #ifdef ASSERT\n-      \/\/ We must not copy any null placeholders left over from bootstrap.\n-    for (int j = 0; j < s2->length(); j++) {\n-      assert(s2->at(j) != nullptr, \"correct bootstrapping order\");\n-    }\n-  #endif\n-\n-    set_secondary_supers(s2);\n+    uintx bitmap = 0;\n+    Array<Klass*>* s2 = pack_secondary_supers(class_loader_data(), primaries, secondaries, bitmap, CHECK);\n+    set_secondary_supers(s2, bitmap);\n@@ -356,1 +568,1 @@\n-  set_secondary_supers(Universe::the_empty_klass_array());\n+  set_secondary_supers(Universe::the_empty_klass_array(), Universe::the_empty_klass_bitmap());\n@@ -517,1 +729,0 @@\n-  it->push(&_secondary_super_cache);\n@@ -548,0 +759,5 @@\n+  \/\/ _secondary_super_cache may be updated by an is_subtype_of() call\n+  \/\/ while ArchiveBuilder is copying metaspace objects. Let's reset it to\n+  \/\/ null and let it be repopulated at runtime.\n+  set_secondary_super_cache(nullptr);\n+\n@@ -555,0 +771,5 @@\n+\n+  \/\/ FIXME: validation in Klass::hash_secondary_supers() may fail for shared klasses.\n+  \/\/ Even though the bitmaps always match, the canonical order of elements in the table\n+  \/\/ is not guaranteed to stay the same (see tie breaker during Robin Hood hashing in Klass::hash_insert).\n+  \/\/assert(compute_secondary_supers_bitmap(secondary_supers()) == _bitmap, \"broken table\");\n@@ -960,0 +1181,97 @@\n+\n+class LookupStats : StackObj {\n+ private:\n+  uint _no_of_samples;\n+  uint _worst;\n+  uint _worst_count;\n+  uint _average;\n+  uint _best;\n+  uint _best_count;\n+ public:\n+  LookupStats() : _no_of_samples(0), _worst(0), _worst_count(0), _average(0), _best(INT_MAX), _best_count(0) {}\n+\n+  ~LookupStats() {\n+    assert(_best <= _worst || _no_of_samples == 0, \"sanity\");\n+  }\n+\n+  void sample(uint value) {\n+    ++_no_of_samples;\n+    _average += value;\n+\n+    if (_worst < value) {\n+      _worst = value;\n+      _worst_count = 1;\n+    } else if (_worst == value) {\n+      ++_worst_count;\n+    }\n+\n+    if (_best > value) {\n+      _best = value;\n+      _best_count = 1;\n+    } else if (_best == value) {\n+      ++_best_count;\n+    }\n+  }\n+\n+  void print_on(outputStream* st) const {\n+    st->print(\"best: %2d (%4.1f%%)\", _best, (100.0 * _best_count) \/ _no_of_samples);\n+    if (_best_count < _no_of_samples) {\n+      st->print(\"; average: %4.1f; worst: %2d (%4.1f%%)\",\n+                (1.0 * _average) \/ _no_of_samples,\n+                _worst, (100.0 * _worst_count) \/ _no_of_samples);\n+    }\n+  }\n+};\n+\n+static void print_positive_lookup_stats(Array<Klass*>* secondary_supers, uintx bitmap, outputStream* st) {\n+  int num_of_supers = secondary_supers->length();\n+\n+  LookupStats s;\n+  for (int i = 0; i < num_of_supers; i++) {\n+    Klass* secondary_super = secondary_supers->at(i);\n+    int home_slot = Klass::compute_home_slot(secondary_super, bitmap);\n+    uint score = 1 + ((i - home_slot) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+    s.sample(score);\n+  }\n+  st->print(\"positive_lookup: \"); s.print_on(st);\n+}\n+\n+static uint compute_distance_to_nearest_zero(int slot, uintx bitmap) {\n+  assert(~bitmap != 0, \"no zeroes\");\n+  uintx start = rotate_right(bitmap, slot);\n+  return count_trailing_zeros(~start);\n+}\n+\n+static void print_negative_lookup_stats(uintx bitmap, outputStream* st) {\n+  LookupStats s;\n+  for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+    uint score = compute_distance_to_nearest_zero(slot, bitmap);\n+    s.sample(score);\n+  }\n+  st->print(\"negative_lookup: \"); s.print_on(st);\n+}\n+\n+void Klass::print_secondary_supers_on(outputStream* st) const {\n+  if (secondary_supers() != nullptr) {\n+    if (UseSecondarySupersTable) {\n+      st->print(\"  - \"); st->print(\"%d elements;\", _secondary_supers->length());\n+      st->print_cr(\" bitmap: \" UINTX_FORMAT_X_0 \";\", _bitmap);\n+      if (_bitmap != SECONDARY_SUPERS_BITMAP_EMPTY &&\n+          _bitmap != SECONDARY_SUPERS_BITMAP_FULL) {\n+        st->print(\"  - \"); print_positive_lookup_stats(secondary_supers(), _bitmap, st); st->cr();\n+        st->print(\"  - \"); print_negative_lookup_stats(_bitmap, st); st->cr();\n+      }\n+    }\n+  } else {\n+    st->print(\"null\");\n+  }\n+}\n+\n+void Klass::on_secondary_supers_verification_failure(Klass* super, Klass* sub, bool linear_result, bool table_result, const char* msg) {\n+  ResourceMark rm;\n+  super->print();\n+  sub->print();\n+  fatal(\"%s: %s implements %s: is_subtype_of: %d; linear_search: %d; table_lookup: %d\",\n+        msg, sub->external_name(), super->external_name(),\n+        sub->is_subtype_of(super), linear_result, table_result);\n+}\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":342,"deletions":24,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -162,0 +162,6 @@\n+  \/\/ Bitmap and hash code used by hashed secondary supers.\n+  uintx    _bitmap;\n+  uint8_t  _hash_slot;\n+\n+  static uint8_t compute_hash_slot(Symbol* s);\n+\n@@ -234,1 +240,4 @@\n-  void set_secondary_supers(Array<Klass*>* k) { _secondary_supers = k; }\n+  void set_secondary_supers(Array<Klass*>* k);\n+  void set_secondary_supers(Array<Klass*>* k, uintx bitmap);\n+\n+  uint8_t hash_slot() const { return _hash_slot; }\n@@ -385,0 +394,4 @@\n+ private:\n+  static void  hash_insert(Klass* klass, GrowableArray<Klass*>* secondaries, uintx& bitmap);\n+  static uintx hash_secondary_supers(Array<Klass*>* secondaries, bool rewrite);\n+\n@@ -386,0 +399,15 @@\n+  \/\/ Secondary supers table support\n+  static Array<Klass*>* pack_secondary_supers(ClassLoaderData* loader_data,\n+                                              GrowableArray<Klass*>* primaries,\n+                                              GrowableArray<Klass*>* secondaries,\n+                                              uintx& bitmap,\n+                                              TRAPS);\n+\n+  static uintx   compute_secondary_supers_bitmap(Array<Klass*>* secondary_supers);\n+  static uint8_t compute_home_slot(Klass* k, uintx bitmap);\n+\n+  static constexpr int SECONDARY_SUPERS_TABLE_SIZE = sizeof(_bitmap) * 8;\n+  static constexpr int SECONDARY_SUPERS_TABLE_MASK = SECONDARY_SUPERS_TABLE_SIZE - 1;\n+\n+  static constexpr uintx SECONDARY_SUPERS_BITMAP_EMPTY    = 0;\n+  static constexpr uintx SECONDARY_SUPERS_BITMAP_FULL     = ~(uintx)0;\n@@ -402,0 +430,1 @@\n+  static ByteSize bitmap_offset()                { return byte_offset_of(Klass, _bitmap); }\n@@ -714,0 +743,2 @@\n+  void print_secondary_supers_on(outputStream* st) const;\n+\n@@ -728,0 +759,2 @@\n+\n+  static void on_secondary_supers_verification_failure(Klass* super, Klass* sub, bool linear_result, bool table_result, const char* msg);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -146,0 +146,3 @@\n+  bool is_forwarded()   const {\n+    return (mask_bits(value(), lock_mask_in_place) == marked_value);\n+  }\n@@ -228,1 +231,1 @@\n-  markWord clear_lock_bits() { return markWord(value() & ~lock_mask_in_place); }\n+  markWord clear_lock_bits() const { return markWord(value() & ~lock_mask_in_place); }\n@@ -262,1 +265,5 @@\n-  inline void* decode_pointer() { return (void*)clear_lock_bits().value(); }\n+  inline void* decode_pointer() const { return (void*)clear_lock_bits().value(); }\n+\n+  inline oop forwardee() const {\n+    return cast_to_oop(decode_pointer());\n+  }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1279,1 +1279,1 @@\n-      THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(), \"Out of space in CodeCache for adapters\");\n+      THROW_MSG_NULL(vmSymbols::java_lang_OutOfMemoryError(), \"Out of space in CodeCache for adapters\");\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,4 +397,0 @@\n-  \/\/ the number of argument reg slots that the compiled method uses on the stack.\n-  int num_stack_arg_slots(bool rounded = true) const {\n-    return rounded ? align_up(constMethod()->num_stack_arg_slots(), 2) : constMethod()->num_stack_arg_slots(); }\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+\n@@ -26,0 +27,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -43,1 +45,1 @@\n-  CompilerOracle::has_option_value(mh, CompileCommand::CompileThresholdScaling, scale);\n+  CompilerOracle::has_option_value(mh, CompileCommandEnum::CompileThresholdScaling, scale);\n","filename":"src\/hotspot\/share\/oops\/methodCounters.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"compiler\/compilerOracle.hpp\"\n","filename":"src\/hotspot\/share\/oops\/methodCounters.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1322,1 +1322,1 @@\n-  CompilerOracle::has_option_value(mh, CompileCommand::CompileThresholdScaling, scale);\n+  CompilerOracle::has_option_value(mh, CompileCommandEnum::CompileThresholdScaling, scale);\n@@ -1339,2 +1339,2 @@\n-      !CompilerOracle::has_option(mh, CompileCommand::NoRTMLockEliding)) {\n-    if (CompilerOracle::has_option(mh, CompileCommand::UseRTMLockEliding) || !UseRTMDeopt) {\n+      !CompilerOracle::has_option(mh, CompileCommandEnum::NoRTMLockEliding)) {\n+    if (CompilerOracle::has_option(mh, CompileCommandEnum::UseRTMLockEliding) || !UseRTMDeopt) {\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -311,1 +311,2 @@\n-    set_secondary_supers(Universe::the_array_interfaces_array());\n+    set_secondary_supers(Universe::the_array_interfaces_array(),\n+                         Universe::the_array_interfaces_bitmap());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -265,3 +265,1 @@\n-  \/\/ The extra heap check is needed since the obj might be locked, in which case the\n-  \/\/ mark would point to a stack location and have the sentinel bit cleared\n-  return mark().is_marked();\n+  return mark().is_forwarded();\n@@ -292,2 +290,1 @@\n-  assert(is_forwarded(), \"only decode when actually forwarded\");\n-  return cast_to_oop(mark().decode_pointer());\n+  return mark().forwardee();\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-      (closure._cb->as_nmethod()->method()->num_stack_arg_slots()*VMRegImpl::stack_slot_size) >>LogBytesPerWord,\n+      (closure._cb->as_nmethod()->num_stack_arg_slots()*VMRegImpl::stack_slot_size) >>LogBytesPerWord,\n@@ -567,1 +567,1 @@\n-      (closure._cb->as_nmethod()->method()->num_stack_arg_slots()*VMRegImpl::stack_slot_size) >>LogBytesPerWord);\n+      (closure._cb->as_nmethod()->num_stack_arg_slots()*VMRegImpl::stack_slot_size) >>LogBytesPerWord);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -76,3 +77,0 @@\n-  \/\/ This is called at a safepoint during dumping of a static CDS archive. The caller should have\n-  \/\/ called os::init_random() with a deterministic seed and then iterate all archived Symbols in\n-  \/\/ a deterministic order.\n@@ -80,1 +78,1 @@\n-  _hash_and_refcount =  pack_hash_and_refcount((short)os::random(), PERM_REFCOUNT);\n+  _hash_and_refcount =  pack_hash_and_refcount((short)ArchiveBuilder::current()->entropy(), PERM_REFCOUNT);\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -727,1 +727,1 @@\n-int AddPNode::unpack_offsets(Node* elements[], int length) {\n+int AddPNode::unpack_offsets(Node* elements[], int length) const {\n@@ -729,1 +729,1 @@\n-  Node* addr = this;\n+  Node const* addr = this;\n@@ -1083,1 +1083,1 @@\n-static Node* build_min_max_int(Node* a, Node* b, bool is_max) {\n+Node* MaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n@@ -1091,0 +1091,8 @@\n+Node* MaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n+  if (is_max) {\n+    return new MaxLNode(phase->C, a, b);\n+  } else {\n+    return new MinLNode(phase->C, a, b);\n+  }\n+}\n+\n@@ -1419,0 +1427,8 @@\n+Node* MaxNode::Identity(PhaseGVN* phase) {\n+  if (in(1) == in(2)) {\n+      return in(1);\n+  }\n+\n+  return AddNode::Identity(phase);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-  int unpack_offsets(Node* elements[], int length);\n+  int unpack_offsets(Node* elements[], int length) const;\n@@ -272,0 +272,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -298,0 +299,3 @@\n+\n+  static Node* build_min_max_int(Node* a, Node* b, bool is_max);\n+  static Node* build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-void C2CodeStubList::emit(CodeBuffer& cb) {\n-  C2_MacroAssembler masm(&cb);\n+void C2CodeStubList::emit(C2_MacroAssembler& masm) {\n@@ -42,1 +41,1 @@\n-    if (cb.insts()->maybe_expand_to_ensure_remaining(max_size) && cb.blob() == nullptr) {\n+    if (masm.code()->insts()->maybe_expand_to_ensure_remaining(max_size) && masm.code()->blob() == nullptr) {\n@@ -47,1 +46,1 @@\n-    DEBUG_ONLY(int size_before = cb.insts_size();)\n+    DEBUG_ONLY(int size_before = masm.offset();)\n@@ -51,1 +50,1 @@\n-    DEBUG_ONLY(int actual_size = cb.insts_size() - size_before;)\n+    DEBUG_ONLY(int actual_size = masm.offset() - size_before;)\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  void emit(CodeBuffer& cb);\n+  void emit(C2_MacroAssembler& masm);\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,0 +356,6 @@\n+  product(bool, MergeStores, true, DIAGNOSTIC,                              \\\n+          \"Optimize stores by combining values into larger store\")          \\\n+                                                                            \\\n+  develop(bool, TraceMergeStores, false,                                    \\\n+          \"Trace creation of merged stores\")                                \\\n+                                                                            \\\n@@ -791,0 +797,7 @@\n+                                                                            \\\n+  product(bool, InlineSecondarySupersTest, true, DIAGNOSTIC,                \\\n+          \"Inline the secondary supers hash lookup.\")                       \\\n+                                                                            \\\n+  product(bool, UseStoreStoreForCtor, true, DIAGNOSTIC,                     \\\n+          \"Use StoreStore barrier instead of Release barrier at the end \"   \\\n+          \"of constructors\")                                                \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -260,0 +260,3 @@\n+  case vmIntrinsics::_setMemory:\n+    if (StubRoutines::unsafe_setmemory() == nullptr) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -557,0 +557,4 @@\n+    if (!allow_inline && (C->print_inlining() || C->print_intrinsics())) {\n+      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n+                        \"late call devirtualization\");\n+    }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -690,1 +690,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const { }\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const { }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -626,0 +627,1 @@\n+                  _allow_macro_nodes(true),\n@@ -917,0 +919,1 @@\n+    _allow_macro_nodes(true),\n@@ -933,0 +936,1 @@\n+    _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n@@ -1085,1 +1089,1 @@\n-    if (method_has_option(CompileCommand::NoRTMLockEliding) || ((rtm_state & NoRTM) != 0)) {\n+    if (method_has_option(CompileCommandEnum::NoRTMLockEliding) || ((rtm_state & NoRTM) != 0)) {\n@@ -1088,1 +1092,1 @@\n-    } else if (method_has_option(CompileCommand::UseRTMLockEliding) || ((rtm_state & UseRTM) != 0) || !UseRTMDeopt) {\n+    } else if (method_has_option(CompileCommandEnum::UseRTMLockEliding) || ((rtm_state & UseRTM) != 0) || !UseRTMDeopt) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"compiler\/compilerOracle.hpp\"\n@@ -49,0 +48,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -321,0 +321,1 @@\n+  bool                  _allow_macro_nodes;     \/\/ True if we allow creation of macro nodes.\n@@ -681,1 +682,1 @@\n-  bool          method_has_option(enum CompileCommand option) {\n+  bool          method_has_option(CompileCommandEnum option) {\n@@ -790,0 +791,3 @@\n+  bool       allow_macro_nodes() { return _allow_macro_nodes;  }\n+  void reset_allow_macro_nodes() { _allow_macro_nodes = false;  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -147,2 +147,1 @@\n-bool ConstantTable::emit(CodeBuffer& cb) const {\n-  MacroAssembler _masm(&cb);\n+bool ConstantTable::emit(C2_MacroAssembler* masm) const {\n@@ -153,1 +152,1 @@\n-      constant_addr = _masm.array_constant(con.type(), con.get_array(), con.alignment());\n+      constant_addr = masm->array_constant(con.type(), con.get_array(), con.alignment());\n@@ -156,4 +155,4 @@\n-      case T_INT:    constant_addr = _masm.int_constant(   con.get_jint()   ); break;\n-      case T_LONG:   constant_addr = _masm.long_constant(  con.get_jlong()  ); break;\n-      case T_FLOAT:  constant_addr = _masm.float_constant( con.get_jfloat() ); break;\n-      case T_DOUBLE: constant_addr = _masm.double_constant(con.get_jdouble()); break;\n+      case T_INT:    constant_addr = masm->int_constant(   con.get_jint()   ); break;\n+      case T_LONG:   constant_addr = masm->long_constant(  con.get_jlong()  ); break;\n+      case T_FLOAT:  constant_addr = masm->float_constant( con.get_jfloat() ); break;\n+      case T_DOUBLE: constant_addr = masm->double_constant(con.get_jdouble()); break;\n@@ -162,2 +161,2 @@\n-        int oop_index = _masm.oop_recorder()->find_index(obj);\n-        constant_addr = _masm.address_constant((address) obj, oop_Relocation::spec(oop_index));\n+        int oop_index = masm->oop_recorder()->find_index(obj);\n+        constant_addr = masm->address_constant((address) obj, oop_Relocation::spec(oop_index));\n@@ -168,1 +167,1 @@\n-        constant_addr = _masm.address_constant(addr);\n+        constant_addr = masm->address_constant(addr);\n@@ -178,1 +177,1 @@\n-        constant_addr = _masm.address_constant(dummy);\n+        constant_addr = masm->address_constant(dummy);\n@@ -182,2 +181,2 @@\n-        assert((constant_addr - _masm.code()->consts()->start()) == con.offset(),\n-              \"must be: %d == %d\", (int)(constant_addr - _masm.code()->consts()->start()), (int)(con.offset()));\n+        assert((constant_addr - masm->code()->consts()->start()) == con.offset(),\n+              \"must be: %d == %d\", (int)(constant_addr - masm->code()->consts()->start()), (int)(con.offset()));\n@@ -188,1 +187,1 @@\n-          last_addr = _masm.address_constant(dummy + j);\n+          last_addr = masm->address_constant(dummy + j);\n@@ -194,1 +193,1 @@\n-        address start = _masm.code()->consts()->start();\n+        address start = masm->code()->consts()->start();\n@@ -206,2 +205,2 @@\n-        int metadata_index = _masm.oop_recorder()->find_index(obj);\n-        constant_addr = _masm.address_constant((address) obj, metadata_Relocation::spec(metadata_index));\n+        int metadata_index = masm->oop_recorder()->find_index(obj);\n+        constant_addr = masm->address_constant((address) obj, metadata_Relocation::spec(metadata_index));\n@@ -217,2 +216,2 @@\n-    assert((constant_addr - _masm.code()->consts()->start()) == con.offset(),\n-            \"must be: %d == %d\", (int)(constant_addr - _masm.code()->consts()->start()), (int)(con.offset()));\n+    assert((constant_addr - masm->code()->consts()->start()) == con.offset(),\n+            \"must be: %d == %d\", (int)(constant_addr - masm->code()->consts()->start()), (int)(con.offset()));\n@@ -295,1 +294,1 @@\n-void ConstantTable::fill_jump_table(CodeBuffer& cb, MachConstantNode* n, GrowableArray<Label*> labels) const {\n+void ConstantTable::fill_jump_table(C2_MacroAssembler* masm, MachConstantNode* n, GrowableArray<Label*> labels) const {\n@@ -307,2 +306,1 @@\n-  MacroAssembler _masm(&cb);\n-  address* jump_table_base = (address*) (_masm.code()->consts()->start() + offset);\n+  address* jump_table_base = (address*) (masm->code()->consts()->start() + offset);\n@@ -313,2 +311,2 @@\n-    *constant_addr = cb.consts()->target(*labels.at(i), (address) constant_addr);\n-    cb.consts()->relocate((address) constant_addr, relocInfo::internal_word_type);\n+    *constant_addr = masm->code()->consts()->target(*labels.at(i), (address) constant_addr);\n+    masm->code()->consts()->relocate((address) constant_addr, relocInfo::internal_word_type);\n","filename":"src\/hotspot\/share\/opto\/constantTable.cpp","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-class CodeBuffer;\n@@ -34,0 +33,1 @@\n+class C2_MacroAssembler;\n@@ -142,1 +142,1 @@\n-  bool emit(CodeBuffer& cb) const;\n+  bool emit(C2_MacroAssembler* masm) const;\n@@ -175,1 +175,1 @@\n-  void     fill_jump_table(CodeBuffer& cb, MachConstantNode* n, GrowableArray<Label*> labels) const;\n+  void     fill_jump_table(C2_MacroAssembler* masm, MachConstantNode* n, GrowableArray<Label*> labels) const;\n","filename":"src\/hotspot\/share\/opto\/constantTable.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -202,1 +202,3 @@\n-        storestore_worklist.append(n->as_MemBarStoreStore());\n+        if (!UseStoreStoreForCtor || n->req() > MemBarNode::Precedent) {\n+          storestore_worklist.append(n->as_MemBarStoreStore());\n+        }\n@@ -493,0 +495,1 @@\n+  assert(cmp->Opcode() == Op_CmpP || cmp->Opcode() == Op_CmpN, \"not expected node: %s\", cmp->Name());\n@@ -496,2 +499,1 @@\n-  return (cmp->Opcode() == Op_CmpP || cmp->Opcode() == Op_CmpN) &&\n-         (left == n || right == n) &&\n+  return (left == n || right == n) &&\n@@ -560,2 +562,6 @@\n-        NOT_PRODUCT(use->dump();)\n-        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP is not to an instance.\", n->_idx, _invocation);)\n+#ifndef PRODUCT\n+        if (TraceReduceAllocationMerges) {\n+          tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP is not to an instance.\", n->_idx, _invocation);\n+          use->dump();\n+        }\n+#endif\n@@ -571,5 +577,12 @@\n-          Node* iff_cmp = iff->in(1)->in(1); \/\/ if->bool->cmp\n-          if (!can_reduce_cmp(n, iff_cmp)) {\n-            NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);)\n-            NOT_PRODUCT(n->dump(5);)\n-            return false;\n+          if (iff->Opcode() == Op_If && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp()) {\n+            Node* iff_cmp = iff->in(1)->in(1);\n+            int opc = iff_cmp->Opcode();\n+            if ((opc == Op_CmpP || opc == Op_CmpN) && !can_reduce_cmp(n, iff_cmp)) {\n+#ifndef PRODUCT\n+              if (TraceReduceAllocationMerges) {\n+                tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);\n+                n->dump(5);\n+              }\n+#endif\n+              return false;\n+            }\n@@ -700,1 +713,0 @@\n-  Node* minus_one          = _igvn->transform(ConINode::make(-1));\n@@ -702,2 +714,2 @@\n-  Node* boll               = _igvn->transform(new BoolNode(cmp, BoolTest::ne));\n-  IfNode* if_ne            = _igvn->transform(new IfNode(current_control, boll, PROB_MIN, COUNT_UNKNOWN))->as_If();\n+  Node* bol                = _igvn->transform(new BoolNode(cmp, BoolTest::ne));\n+  IfNode* if_ne            = _igvn->transform(new IfNode(current_control, bol, PROB_MIN, COUNT_UNKNOWN))->as_If();\n@@ -967,2 +979,2 @@\n-      Node* boll = _igvn->transform(new BoolNode(ncmp, mask));\n-      res_phi_input = boll->as_Bool()->as_int_value(_igvn);\n+      Node* bol = _igvn->transform(new BoolNode(ncmp, mask));\n+      res_phi_input = bol->as_Bool()->as_int_value(_igvn);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":27,"deletions":15,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3271,2 +3271,3 @@\n-  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr()->try_improve();\n-  const TypeOopPtr *toop = tk->cast_to_exactness(false)->as_instance_type();\n+  const TypeKlassPtr* klass_ptr_type = _gvn.type(superklass)->is_klassptr();\n+  const TypeKlassPtr* improved_klass_ptr_type = klass_ptr_type->try_improve();\n+  const TypeOopPtr* toop = improved_klass_ptr_type->cast_to_exactness(false)->as_instance_type();\n@@ -3280,1 +3281,1 @@\n-  if (tk->singleton()) {\n+  if (improved_klass_ptr_type->singleton()) {\n@@ -3283,1 +3284,1 @@\n-      switch (C->static_subtype_check(tk, objtp->as_klass_type())) {\n+      switch (C->static_subtype_check(improved_klass_ptr_type, objtp->as_klass_type())) {\n@@ -3349,1 +3350,1 @@\n-  if (tk->klass_is_exact()) {\n+  if (improved_klass_ptr_type->klass_is_exact()) {\n@@ -3359,1 +3360,1 @@\n-      cast_obj = maybe_cast_profiled_receiver(not_null_obj, tk, spec_obj_type, safe_for_replace);\n+      cast_obj = maybe_cast_profiled_receiver(not_null_obj, improved_klass_ptr_type, spec_obj_type, safe_for_replace);\n@@ -3371,1 +3372,5 @@\n-    Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass );\n+    Node* improved_superklass = superklass;\n+    if (improved_klass_ptr_type != klass_ptr_type && improved_klass_ptr_type->singleton()) {\n+      improved_superklass = makecon(improved_klass_ptr_type);\n+    }\n+    Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, improved_superklass);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -510,0 +510,1 @@\n+  case vmIntrinsics::_setMemory:                return inline_unsafe_setMemory();\n@@ -4947,0 +4948,51 @@\n+\n+  return true;\n+}\n+\n+\/\/ unsafe_setmemory(void *base, ulong offset, size_t length, char fill_value);\n+\/\/ Fill 'length' bytes starting from 'base[offset]' with 'fill_value'\n+bool LibraryCallKit::inline_unsafe_setMemory() {\n+  if (callee()->is_static())  return false;  \/\/ caller must have the capability!\n+  null_check_receiver();  \/\/ null-check receiver\n+  if (stopped())  return true;\n+\n+  C->set_has_unsafe_access(true);  \/\/ Mark eventual nmethod as \"unsafe\".\n+\n+  Node* dst_base =         argument(1);  \/\/ type: oop\n+  Node* dst_off  = ConvL2X(argument(2)); \/\/ type: long\n+  Node* size     = ConvL2X(argument(4)); \/\/ type: long\n+  Node* byte     =         argument(6);  \/\/ type: byte\n+\n+  assert(Unsafe_field_offset_to_byte_offset(11) == 11,\n+         \"fieldOffset must be byte-scaled\");\n+\n+  Node* dst_addr = make_unsafe_address(dst_base, dst_off);\n+\n+  Node* thread = _gvn.transform(new ThreadLocalNode());\n+  Node* doing_unsafe_access_addr = basic_plus_adr(top(), thread, in_bytes(JavaThread::doing_unsafe_access_offset()));\n+  BasicType doing_unsafe_access_bt = T_BYTE;\n+  assert((sizeof(bool) * CHAR_BIT) == 8, \"not implemented\");\n+\n+  \/\/ update volatile field\n+  store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  int flags = RC_LEAF | RC_NO_FP;\n+\n+  const TypePtr* dst_type = TypePtr::BOTTOM;\n+\n+  \/\/ Adjust memory effects of the runtime call based on input values.\n+  if (!has_wide_mem(_gvn, dst_addr, dst_base)) {\n+    dst_type = _gvn.type(dst_addr)->is_ptr(); \/\/ narrow out memory\n+\n+    flags |= RC_NARROW_MEM; \/\/ narrow in memory\n+  }\n+\n+  \/\/ Call it.  Note that the length argument is not scaled.\n+  make_runtime_call(flags,\n+                    OptoRuntime::make_setmemory_Type(),\n+                    StubRoutines::unsafe_setmemory(),\n+                    \"unsafe_setmemory\",\n+                    dst_type,\n+                    dst_addr, size XTOP, byte);\n+\n+  store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,0 +234,1 @@\n+  bool inline_unsafe_setMemory();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -935,1 +935,1 @@\n-          float worst_case_trip_cnt = ((float)t->_hi - t->_lo) \/ ABS(cl->stride_con());\n+          float worst_case_trip_cnt = ((float)t->_hi - t->_lo) \/ ABS((float)cl->stride_con());\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-\/\/---------------------find_invariant-----------------------------\n@@ -261,1 +260,1 @@\n-int IdealLoopTree::find_invariant(Node* n, PhaseIdealLoop *phase) {\n+int IdealLoopTree::find_invariant(Node* n, PhaseIdealLoop* phase) {\n@@ -269,1 +268,18 @@\n-\/\/---------------------is_associative-----------------------------\n+\/\/ Return TRUE if \"n\" is an associative cmp node. A cmp node is\n+\/\/ associative if it is only used for equals or not-equals\n+\/\/ comparisons of integers or longs. We cannot reassociate\n+\/\/ non-equality comparisons due to possibility of overflow.\n+bool IdealLoopTree::is_associative_cmp(Node* n) {\n+  if (n->Opcode() != Op_CmpI && n->Opcode() != Op_CmpL) {\n+    return false;\n+  }\n+  for (DUIterator i = n->outs(); n->has_out(i); i++) {\n+    BoolNode* bool_out = n->out(i)->isa_Bool();\n+    if (bool_out == nullptr || !(bool_out->_test._test == BoolTest::eq ||\n+                                 bool_out->_test._test == BoolTest::ne)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -277,1 +293,1 @@\n-    if (base_op == Op_AddI || base_op == Op_SubI) {\n+    if (base_op == Op_AddI || base_op == Op_SubI || base_op == Op_CmpI) {\n@@ -280,1 +296,1 @@\n-    if (base_op == Op_AddL || base_op == Op_SubL) {\n+    if (base_op == Op_AddL || base_op == Op_SubL || base_op == Op_CmpL) {\n@@ -285,1 +301,2 @@\n-    \/\/ Integer \"add\/sub\/mul\/and\/or\/xor\" operations are associative.\n+    \/\/ Integer \"add\/sub\/mul\/and\/or\/xor\" operations are associative. Integer\n+    \/\/ \"cmp\" operations are associative if it is an equality comparison.\n@@ -291,1 +308,2 @@\n-        || op == Op_XorI || op == Op_XorL;\n+        || op == Op_XorI || op == Op_XorL\n+        || is_associative_cmp(n);\n@@ -295,1 +313,0 @@\n-\/\/---------------------reassociate_add_sub------------------------\n@@ -311,2 +328,5 @@\n-Node* IdealLoopTree::reassociate_add_sub(Node* n1, int inv1_idx, int inv2_idx, PhaseIdealLoop *phase) {\n-  assert(n1->is_Add() || n1->is_Sub(), \"Target node should be add or subtract\");\n+\/\/ Apply the same transformations to == and !=\n+\/\/ inv1 == (x + inv2) => ( inv1 - inv2 ) == x\n+\/\/ inv1 == (x - inv2) => ( inv1 + inv2 ) == x\n+\/\/ inv1 == (inv2 - x) => (-inv1 + inv2 ) == x\n+Node* IdealLoopTree::reassociate_add_sub_cmp(Node* n1, int inv1_idx, int inv2_idx, PhaseIdealLoop* phase) {\n@@ -314,0 +334,5 @@\n+  bool n1_is_sub = n1->is_Sub() && !n1->is_Cmp();\n+  bool n1_is_cmp = n1->is_Cmp();\n+  bool n2_is_sub = n2->is_Sub();\n+  assert(n1->is_Add() || n1_is_sub || n1_is_cmp, \"Target node should be add, subtract, or compare\");\n+  assert(n2->is_Add() || (n2_is_sub && !n2->is_Cmp()), \"Child node should be add or subtract\");\n@@ -318,4 +343,6 @@\n-  bool neg_x    = n2->is_Sub() && inv2_idx == 1;\n-  bool neg_inv2 = n2->is_Sub() && inv2_idx == 2;\n-  bool neg_inv1 = n1->is_Sub() && inv1_idx == 2;\n-  if (n1->is_Sub() && inv1_idx == 1) {\n+  \/\/ Determine whether x, inv1, or inv2 should be negative in the transformed\n+  \/\/ expression\n+  bool neg_x = n2_is_sub && inv2_idx == 1;\n+  bool neg_inv2 = (n2_is_sub && !n1_is_cmp && inv2_idx == 2) || (n1_is_cmp && !n2_is_sub);\n+  bool neg_inv1 = (n1_is_sub && inv1_idx == 2) || (n1_is_cmp && inv2_idx == 1 && n2_is_sub);\n+  if (n1_is_sub && inv1_idx == 1) {\n@@ -326,1 +353,1 @@\n-  bool is_int = n1->bottom_type()->isa_int() != nullptr;\n+  bool is_int = n2->bottom_type()->isa_int() != nullptr;\n@@ -352,0 +379,3 @@\n+    if (n1_is_cmp) {\n+      return new CmpINode(x, inv);\n+    }\n@@ -364,0 +394,3 @@\n+    if (n1_is_cmp) {\n+      return new CmpLNode(x, inv);\n+    }\n@@ -372,1 +405,0 @@\n-\/\/---------------------reassociate-----------------------------\n@@ -374,2 +406,2 @@\n-\/\/ and\/or\/xor operators.\n-\/\/ For add\/sub expressions: see \"reassociate_add_sub\"\n+\/\/ and\/or\/xor\/cmp operators.\n+\/\/ For add\/sub\/cmp expressions: see \"reassociate_add_sub_cmp\"\n@@ -402,1 +434,3 @@\n-      result = reassociate_add_sub(n1, inv1_idx, inv2_idx, phase);\n+    case Op_CmpI:\n+    case Op_CmpL:\n+      result = reassociate_add_sub_cmp(n1, inv1_idx, inv2_idx, phase);\n@@ -425,1 +459,1 @@\n-  phase->register_new_node(result, phase->get_ctrl(n1));\n+  phase->register_new_node_with_ctrl_of(result, n1);\n@@ -1019,0 +1053,2 @@\n+      case Op_LoadVectorGather:\n+      case Op_LoadVectorGatherMasked:\n@@ -1397,34 +1433,0 @@\n-\/\/ Is 'n' a node that can be found on the input chain of a Template Assertion Predicate bool (i.e. between a Template\n-\/\/ Assertion Predicate If node and the OpaqueLoop* nodes)?\n-static bool is_part_of_template_assertion_predicate_bool(Node* n) {\n-  int op = n->Opcode();\n-  return (n->is_Bool() ||\n-          n->is_Cmp() ||\n-          op == Op_AndL ||\n-          op == Op_OrL ||\n-          op == Op_RShiftL ||\n-          op == Op_LShiftL ||\n-          op == Op_LShiftI ||\n-          op == Op_AddL ||\n-          op == Op_AddI ||\n-          op == Op_MulL ||\n-          op == Op_MulI ||\n-          op == Op_SubL ||\n-          op == Op_SubI ||\n-          op == Op_ConvI2L ||\n-          op == Op_CastII);\n-}\n-\n-bool PhaseIdealLoop::subgraph_has_opaque(Node* n) {\n-  if (n->Opcode() == Op_OpaqueLoopInit || n->Opcode() == Op_OpaqueLoopStride) {\n-    return true;\n-  }\n-  if (!is_part_of_template_assertion_predicate_bool(n)) {\n-    return false;\n-  }\n-  uint init;\n-  uint stride;\n-  count_opaque_loop_nodes(n, init, stride);\n-  return init != 0 || stride != 0;\n-}\n-\n@@ -1474,5 +1476,11 @@\n-    if (is_part_of_template_assertion_predicate_bool(n)) {\n-      for (uint j = 1; j < n->req(); j++) {\n-        Node* m = n->in(j);\n-        if (m != nullptr) {\n-          wq.push(m);\n+    if (TemplateAssertionPredicateExpressionNode::is_maybe_in_expression(n)) {\n+      if (n->is_OpaqueLoopInit()) {\n+        init++;\n+      } else if (n->is_OpaqueLoopStride()) {\n+        stride++;\n+      } else {\n+        for (uint j = 1; j < n->req(); j++) {\n+          Node* m = n->in(j);\n+          if (m != nullptr) {\n+            wq.push(m);\n+          }\n@@ -1481,6 +1489,0 @@\n-      continue;\n-    }\n-    if (n->Opcode() == Op_OpaqueLoopInit) {\n-      init++;\n-    } else if (n->Opcode() == Op_OpaqueLoopStride) {\n-      stride++;\n@@ -1946,0 +1948,6 @@\n+  if (init->is_CastII()) {\n+    \/\/ skip over the cast added by PhaseIdealLoop::cast_incr_before_loop() when pre\/post\/main loops are created because\n+    \/\/ it can get in the way of type propagation\n+    assert(init->as_CastII()->carry_dependency() && loop_head->skip_assertion_predicates_with_halt() == init->in(0), \"casted iv phi from pre loop expected\");\n+    init = init->in(1);\n+  }\n@@ -2184,1 +2192,1 @@\n-      register_new_node(limit_l, get_ctrl(limit));\n+      register_new_node_with_ctrl_of(limit_l, limit);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":74,"deletions":66,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -742,2 +742,2 @@\n-  \/\/ Reassociate invariant add and subtract expressions.\n-  Node* reassociate_add_sub(Node* n1, int inv1_idx, int inv2_idx, PhaseIdealLoop *phase);\n+  \/\/ Reassociate invariant add, subtract, and compare expressions.\n+  Node* reassociate_add_sub_cmp(Node* n1, int inv1_idx, int inv2_idx, PhaseIdealLoop* phase);\n@@ -749,0 +749,2 @@\n+  \/\/ Return TRUE if \"n\" is an associative cmp node.\n+  bool is_associative_cmp(Node* n);\n@@ -952,1 +954,0 @@\n-  static bool subgraph_has_opaque(Node* n);\n@@ -1674,0 +1675,3 @@\n+  void register_new_node_with_ctrl_of(Node* new_node, Node* ctrl_of) {\n+    register_new_node(new_node, get_ctrl(ctrl_of));\n+  }\n@@ -1757,6 +1761,0 @@\n-  bool clone_cmp_down(Node* n, const Node* blk1, const Node* blk2);\n-\n-  void clone_loadklass_nodes_at_cmp_index(const Node* n, Node* cmp, int i);\n-\n-  bool clone_cmp_loadklass_down(Node* n, const Node* blk1, const Node* blk2);\n-\n@@ -1765,0 +1763,4 @@\n+  bool clone_cmp_loadklass_down(Node* n, const Node* blk1, const Node* blk2);\n+  void clone_loadklass_nodes_at_cmp_index(const Node* n, Node* cmp, int i);\n+  bool clone_cmp_down(Node* n, const Node* blk1, const Node* blk2);\n+  void clone_template_assertion_predicate_expression_down(Node* node);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-      register_new_node(neg, get_ctrl(add->in(2)));\n+      register_new_node_with_ctrl_of(neg, add->in(2));\n@@ -657,1 +657,1 @@\n-              register_new_node(nn, get_ctrl(n));\n+              register_new_node_with_ctrl_of(nn, n);\n@@ -663,1 +663,1 @@\n-              register_new_node(nn, get_ctrl(n));\n+              register_new_node_with_ctrl_of(nn, n);\n@@ -2271,1 +2271,1 @@\n-          register_new_node(pinned_clone, get_ctrl(use));\n+          register_new_node_with_ctrl_of(pinned_clone, use);\n@@ -3917,1 +3917,1 @@\n-          register_new_node(pinned_clone, get_ctrl(n_clone));\n+          register_new_node_with_ctrl_of(pinned_clone, n_clone);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-void MachNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -551,0 +551,5 @@\n+  if (barrier_data() != 0) {\n+    st->print(\" barrier(\");\n+    BarrierSet::barrier_set()->barrier_set_c2()->dump_barrier_data(this, st);\n+    st->print(\") \");\n+  }\n@@ -563,0 +568,1 @@\n+  MachNode::dump_spec(st);\n@@ -568,5 +574,0 @@\n-  if (barrier_data() != 0) {\n-    st->print(\" barrier(\");\n-    BarrierSet::barrier_set()->barrier_set_c2()->dump_barrier_data(this, st);\n-    st->print(\")\");\n-  }\n@@ -607,1 +608,1 @@\n-void MachNullCheckNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachNullCheckNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/c2_MacroAssembler.hpp\"\n@@ -37,1 +38,0 @@\n-class CodeBuffer;\n@@ -287,2 +287,2 @@\n-  \/\/ Emit bytes into cbuf\n-  virtual void  emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  \/\/ Emit bytes using C2_MacroAssembler\n+  virtual void  emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -424,1 +424,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -450,1 +450,1 @@\n-  virtual void emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const;\n+  virtual void emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const;\n@@ -501,1 +501,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -515,1 +515,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -530,1 +530,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -555,1 +555,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -613,1 +613,1 @@\n-  uint implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const;\n+  uint implementation( C2_MacroAssembler *masm, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const;\n@@ -615,1 +615,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -678,1 +678,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const { }\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const { }\n@@ -718,1 +718,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -949,1 +949,1 @@\n-  int resolved_method_index(CodeBuffer &cbuf) const {\n+  int resolved_method_index(C2_MacroAssembler *masm) const {\n@@ -955,1 +955,1 @@\n-      return cbuf.oop_recorder()->find_index(_method->constant_encoding());\n+      return masm->code()->oop_recorder()->find_index(_method->constant_encoding());\n@@ -1060,1 +1060,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {}\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {}\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -636,1 +636,4 @@\n-      } else if (reduce_merge_precheck && (use->is_Phi() || use->is_EncodeP() || use->Opcode() == Op_MemBarRelease)) {\n+      } else if (reduce_merge_precheck &&\n+                 (use->is_Phi() || use->is_EncodeP() ||\n+                  use->Opcode() == Op_MemBarRelease ||\n+                  (UseStoreStoreForCtor && use->Opcode() == Op_MemBarStoreStore))) {\n@@ -2448,0 +2451,2 @@\n+  \/\/ Do not allow new macro nodes once we started to expand\n+  C->reset_allow_macro_nodes();\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1893,5 +1893,1 @@\n-  if (leaf->is_LoadStore()) {\n-    mach->set_barrier_data(leaf->as_LoadStore()->barrier_data());\n-  } else if (leaf->is_Mem()) {\n-    mach->set_barrier_data(leaf->as_Mem()->barrier_data());\n-  }\n+  mach->set_barrier_data(MemNode::barrier_data(leaf));\n@@ -2481,0 +2477,7 @@\n+    case Op_LoadVectorGather:\n+      if (is_subword_type(n->bottom_type()->is_vect()->element_basic_type())) {\n+        Node* pair = new BinaryNode(n->in(MemNode::ValueIn), n->in(MemNode::ValueIn+1));\n+        n->set_req(MemNode::ValueIn, pair);\n+        n->del_req(MemNode::ValueIn+1);\n+      }\n+      break;\n@@ -2482,0 +2485,8 @@\n+      if (is_subword_type(n->bottom_type()->is_vect()->element_basic_type())) {\n+        Node* pair2 = new BinaryNode(n->in(MemNode::ValueIn + 1), n->in(MemNode::ValueIn + 2));\n+        Node* pair1 = new BinaryNode(n->in(MemNode::ValueIn), pair2);\n+        n->set_req(MemNode::ValueIn, pair1);\n+        n->del_req(MemNode::ValueIn+2);\n+        n->del_req(MemNode::ValueIn+1);\n+        break;\n+      } \/\/ fall-through\n@@ -2503,0 +2514,8 @@\n+    case Op_PartialSubtypeCheck: {\n+      if (UseSecondarySupersTable && n->in(2)->is_Con()) {\n+        \/\/ PartialSubtypeCheck uses both constant and register operands for superclass input.\n+        n->set_req(2, new BinaryNode(n->in(2), n->in(2)));\n+        break;\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2457,0 +2457,6 @@\n+  if (tkls != nullptr && !UseSecondarySupersCache\n+      && tkls->offset() == in_bytes(Klass::secondary_super_cache_offset()))  {\n+    \/\/ Treat Klass::_secondary_super_cache as a constant when the cache is disabled.\n+    return TypePtr::NULL_PTR;\n+  }\n+\n@@ -2694,0 +2700,686 @@\n+\/\/ Class to parse array pointers, and determine if they are adjacent. We parse the form:\n+\/\/\n+\/\/   pointer =   base\n+\/\/             + constant_offset\n+\/\/             + LShiftL( ConvI2L(int_offset + int_con), int_offset_shift)\n+\/\/             + sum(other_offsets)\n+\/\/\n+\/\/\n+\/\/ Note: we accumulate all constant offsets into constant_offset, even the int constant behind\n+\/\/       the \"LShiftL(ConvI2L(...))\" pattern. We convert \"ConvI2L(int_offset + int_con)\" to\n+\/\/       \"ConvI2L(int_offset) + int_con\", which is only safe if we can assume that either all\n+\/\/       compared addresses have an overflow for \"int_offset + int_con\" or none.\n+\/\/       For loads and stores on arrays, we know that if one overflows and the other not, then\n+\/\/       the two addresses lay almost max_int indices apart, but the maximal array size is\n+\/\/       only about half of that. Therefore, the RangeCheck on at least one of them must have\n+\/\/       failed.\n+\/\/\n+\/\/   constant_offset += LShiftL( ConvI2L(int_con), int_offset_shift)\n+\/\/\n+\/\/   pointer =   base\n+\/\/             + constant_offset\n+\/\/             + LShiftL( ConvI2L(int_offset), int_offset_shift)\n+\/\/             + sum(other_offsets)\n+\/\/\n+class ArrayPointer {\n+private:\n+  const bool _is_valid;          \/\/ The parsing succeeded\n+  const Node* _pointer;          \/\/ The final pointer to the position in the array\n+  const Node* _base;             \/\/ Base address of the array\n+  const jlong _constant_offset;  \/\/ Sum of collected constant offsets\n+  const Node* _int_offset;       \/\/ (optional) Offset behind LShiftL and ConvI2L\n+  const jint  _int_offset_shift; \/\/ (optional) Shift value for int_offset\n+  const GrowableArray<Node*>* _other_offsets; \/\/ List of other AddP offsets\n+\n+  ArrayPointer(const bool is_valid,\n+               const Node* pointer,\n+               const Node* base,\n+               const jlong constant_offset,\n+               const Node* int_offset,\n+               const jint int_offset_shift,\n+               const GrowableArray<Node*>* other_offsets) :\n+      _is_valid(is_valid),\n+      _pointer(pointer),\n+      _base(base),\n+      _constant_offset(constant_offset),\n+      _int_offset(int_offset),\n+      _int_offset_shift(int_offset_shift),\n+      _other_offsets(other_offsets)\n+  {\n+    assert(_pointer != nullptr, \"must always have pointer\");\n+    assert(is_valid == (_base != nullptr), \"have base exactly if valid\");\n+    assert(is_valid == (_other_offsets != nullptr), \"have other_offsets exactly if valid\");\n+  }\n+\n+  static ArrayPointer make_invalid(const Node* pointer) {\n+    return ArrayPointer(false, pointer, nullptr, 0, nullptr, 0, nullptr);\n+  }\n+\n+  static bool parse_int_offset(Node* offset, Node*& int_offset, jint& int_offset_shift) {\n+    \/\/ offset = LShiftL( ConvI2L(int_offset), int_offset_shift)\n+    if (offset->Opcode() == Op_LShiftL &&\n+        offset->in(1)->Opcode() == Op_ConvI2L &&\n+        offset->in(2)->Opcode() == Op_ConI) {\n+      int_offset = offset->in(1)->in(1); \/\/ LShiftL -> ConvI2L -> int_offset\n+      int_offset_shift = offset->in(2)->get_int(); \/\/ LShiftL -> int_offset_shift\n+      return true;\n+    }\n+\n+    \/\/ offset = ConvI2L(int_offset) = LShiftL( ConvI2L(int_offset), 0)\n+    if (offset->Opcode() == Op_ConvI2L) {\n+      int_offset = offset->in(1);\n+      int_offset_shift = 0;\n+      return true;\n+    }\n+\n+    \/\/ parse failed\n+    return false;\n+  }\n+\n+public:\n+  \/\/ Parse the structure above the pointer\n+  static ArrayPointer make(PhaseGVN* phase, const Node* pointer) {\n+    assert(phase->type(pointer)->isa_aryptr() != nullptr, \"must be array pointer\");\n+    if (!pointer->is_AddP()) { return ArrayPointer::make_invalid(pointer); }\n+\n+    const Node* base = pointer->in(AddPNode::Base);\n+    if (base == nullptr) { return ArrayPointer::make_invalid(pointer); }\n+\n+    const int search_depth = 5;\n+    Node* offsets[search_depth];\n+    int count = pointer->as_AddP()->unpack_offsets(offsets, search_depth);\n+\n+    \/\/ We expect at least a constant each\n+    if (count <= 0) { return ArrayPointer::make_invalid(pointer); }\n+\n+    \/\/ We extract the form:\n+    \/\/\n+    \/\/   pointer =   base\n+    \/\/             + constant_offset\n+    \/\/             + LShiftL( ConvI2L(int_offset + int_con), int_offset_shift)\n+    \/\/             + sum(other_offsets)\n+    \/\/\n+    jlong constant_offset = 0;\n+    Node* int_offset = nullptr;\n+    jint int_offset_shift = 0;\n+    GrowableArray<Node*>* other_offsets = new GrowableArray<Node*>(count);\n+\n+    for (int i = 0; i < count; i++) {\n+      Node* offset = offsets[i];\n+      if (offset->Opcode() == Op_ConI) {\n+        \/\/ Constant int offset\n+        constant_offset += offset->get_int();\n+      } else if (offset->Opcode() == Op_ConL) {\n+        \/\/ Constant long offset\n+        constant_offset += offset->get_long();\n+      } else if(int_offset == nullptr && parse_int_offset(offset, int_offset, int_offset_shift)) {\n+        \/\/ LShiftL( ConvI2L(int_offset), int_offset_shift)\n+        int_offset = int_offset->uncast();\n+        if (int_offset->Opcode() == Op_AddI && int_offset->in(2)->Opcode() == Op_ConI) {\n+          \/\/ LShiftL( ConvI2L(int_offset + int_con), int_offset_shift)\n+          constant_offset += ((jlong)int_offset->in(2)->get_int()) << int_offset_shift;\n+          int_offset = int_offset->in(1);\n+        }\n+      } else {\n+        \/\/ All others\n+        other_offsets->append(offset);\n+      }\n+    }\n+\n+    return ArrayPointer(true, pointer, base, constant_offset, int_offset, int_offset_shift, other_offsets);\n+  }\n+\n+  bool is_adjacent_to_and_before(const ArrayPointer& other, const jlong data_size) const {\n+    if (!_is_valid || !other._is_valid) { return false; }\n+\n+    \/\/ Offset adjacent?\n+    if (this->_constant_offset + data_size != other._constant_offset) { return false; }\n+\n+    \/\/ All other components identical?\n+    if (this->_base != other._base ||\n+        this->_int_offset != other._int_offset ||\n+        this->_int_offset_shift != other._int_offset_shift ||\n+        this->_other_offsets->length() != other._other_offsets->length()) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < this->_other_offsets->length(); i++) {\n+      Node* o1 = this->_other_offsets->at(i);\n+      Node* o2 = other._other_offsets->at(i);\n+      if (o1 != o2) { return false; }\n+    }\n+\n+    return true;\n+  }\n+\n+#ifndef PRODUCT\n+  void dump() {\n+    if (!_is_valid) {\n+      tty->print(\"ArrayPointer[%d %s, invalid]\", _pointer->_idx, _pointer->Name());\n+      return;\n+    }\n+    tty->print(\"ArrayPointer[%d %s, base[%d %s] + %lld\",\n+               _pointer->_idx, _pointer->Name(),\n+               _base->_idx, _base->Name(),\n+               (long long)_constant_offset);\n+    if (_int_offset != 0) {\n+      tty->print(\" + I2L[%d %s] << %d\",\n+                 _int_offset->_idx, _int_offset->Name(), _int_offset_shift);\n+    }\n+    for (int i = 0; i < _other_offsets->length(); i++) {\n+      Node* n = _other_offsets->at(i);\n+      tty->print(\" + [%d %s]\", n->_idx, n->Name());\n+    }\n+    tty->print_cr(\"]\");\n+  }\n+#endif\n+};\n+\n+\/\/ Link together multiple stores (B\/S\/C\/I) into a longer one.\n+\/\/\n+\/\/ Example: _store = StoreB[i+3]\n+\/\/\n+\/\/   RangeCheck[i+0]           RangeCheck[i+0]\n+\/\/   StoreB[i+0]\n+\/\/   RangeCheck[i+1]           RangeCheck[i+1]\n+\/\/   StoreB[i+1]         -->   pass:             fail:\n+\/\/   StoreB[i+2]               StoreI[i+0]       StoreB[i+0]\n+\/\/   StoreB[i+3]\n+\/\/\n+\/\/ The 4 StoreB are merged into a single StoreI node. We have to be careful with RangeCheck[i+1]: before\n+\/\/ the optimization, if this RangeCheck[i+1] fails, then we execute only StoreB[i+0], and then trap. After\n+\/\/ the optimization, the new StoreI[i+0] is on the passing path of RangeCheck[i+1], and StoreB[i+0] on the\n+\/\/ failing path.\n+\/\/\n+\/\/ Note: For normal array stores, every store at first has a RangeCheck. But they can be removed with:\n+\/\/       - RCE (RangeCheck Elimination): the RangeChecks in the loop are hoisted out and before the loop,\n+\/\/                                       and possibly no RangeChecks remain between the stores.\n+\/\/       - RangeCheck smearing: the earlier RangeChecks are adjusted such that they cover later RangeChecks,\n+\/\/                              and those later RangeChecks can be removed. Example:\n+\/\/\n+\/\/                              RangeCheck[i+0]                         RangeCheck[i+0] <- before first store\n+\/\/                              StoreB[i+0]                             StoreB[i+0]     <- first store\n+\/\/                              RangeCheck[i+1]     --> smeared -->     RangeCheck[i+3] <- only RC between first and last store\n+\/\/                              StoreB[i+0]                             StoreB[i+1]     <- second store\n+\/\/                              RangeCheck[i+2]     --> removed\n+\/\/                              StoreB[i+0]                             StoreB[i+2]\n+\/\/                              RangeCheck[i+3]     --> removed\n+\/\/                              StoreB[i+0]                             StoreB[i+3]     <- last store\n+\/\/\n+\/\/                              Thus, it is a common pattern that between the first and last store in a chain\n+\/\/                              of adjacent stores there remains exactly one RangeCheck, located between the\n+\/\/                              first and the second store (e.g. RangeCheck[i+3]).\n+\/\/\n+class MergePrimitiveArrayStores : public StackObj {\n+private:\n+  PhaseGVN* _phase;\n+  StoreNode* _store;\n+\n+public:\n+  MergePrimitiveArrayStores(PhaseGVN* phase, StoreNode* store) : _phase(phase), _store(store) {}\n+\n+  StoreNode* run();\n+\n+private:\n+  bool is_compatible_store(const StoreNode* other_store) const;\n+  bool is_adjacent_pair(const StoreNode* use_store, const StoreNode* def_store) const;\n+  bool is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const;\n+  static bool is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out);\n+  enum CFGStatus { SuccessNoRangeCheck, SuccessWithRangeCheck, Failure };\n+  static CFGStatus cfg_status_for_pair(const StoreNode* use_store, const StoreNode* def_store);\n+\n+  class Status {\n+  private:\n+    StoreNode* _found_store;\n+    bool       _found_range_check;\n+\n+    Status(StoreNode* found_store, bool found_range_check)\n+      : _found_store(found_store), _found_range_check(found_range_check) {}\n+\n+  public:\n+    StoreNode* found_store() const { return _found_store; }\n+    bool found_range_check() const { return _found_range_check; }\n+    static Status make_failure() { return Status(nullptr, false); }\n+\n+    static Status make(StoreNode* found_store, const CFGStatus cfg_status) {\n+      if (cfg_status == CFGStatus::Failure) {\n+        return Status::make_failure();\n+      }\n+      return Status(found_store, cfg_status == CFGStatus::SuccessWithRangeCheck);\n+    }\n+  };\n+\n+  Status find_adjacent_use_store(const StoreNode* def_store) const;\n+  Status find_adjacent_def_store(const StoreNode* use_store) const;\n+  Status find_use_store(const StoreNode* def_store) const;\n+  Status find_def_store(const StoreNode* use_store) const;\n+  Status find_use_store_unidirectional(const StoreNode* def_store) const;\n+  Status find_def_store_unidirectional(const StoreNode* use_store) const;\n+\n+  void collect_merge_list(Node_List& merge_list) const;\n+  Node* make_merged_input_value(const Node_List& merge_list);\n+  StoreNode* make_merged_store(const Node_List& merge_list, Node* merged_input_value);\n+\n+  DEBUG_ONLY( void trace(const Node_List& merge_list, const Node* merged_input_value, const StoreNode* merged_store) const; )\n+};\n+\n+StoreNode* MergePrimitiveArrayStores::run() {\n+  \/\/ Check for B\/S\/C\/I\n+  int opc = _store->Opcode();\n+  if (opc != Op_StoreB && opc != Op_StoreC && opc != Op_StoreI) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Only merge stores on arrays, and the stores must have the same size as the elements.\n+  const TypeAryPtr* aryptr_t = _store->adr_type()->isa_aryptr();\n+  if (aryptr_t == nullptr) {\n+    return nullptr;\n+  }\n+  BasicType bt = aryptr_t->elem()->array_element_basic_type();\n+  if (!is_java_primitive(bt) ||\n+      type2aelembytes(bt) != _store->memory_size()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ The _store must be the \"last\" store in a chain. If we find a use we could merge with\n+  \/\/ then that use or a store further down is the \"last\" store.\n+  Status status_use = find_adjacent_use_store(_store);\n+  if (status_use.found_store() != nullptr) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Check if we can merge with at least one def, so that we have at least 2 stores to merge.\n+  Status status_def = find_adjacent_def_store(_store);\n+  if (status_def.found_store() == nullptr) {\n+    return nullptr;\n+  }\n+\n+  ResourceMark rm;\n+  Node_List merge_list;\n+  collect_merge_list(merge_list);\n+\n+  Node* merged_input_value = make_merged_input_value(merge_list);\n+  if (merged_input_value == nullptr) { return nullptr; }\n+\n+  StoreNode* merged_store = make_merged_store(merge_list, merged_input_value);\n+\n+  DEBUG_ONLY( if(TraceMergeStores) { trace(merge_list, merged_input_value, merged_store); } )\n+\n+  return merged_store;\n+}\n+\n+\/\/ Check compatibility between _store and other_store.\n+bool MergePrimitiveArrayStores::is_compatible_store(const StoreNode* other_store) const {\n+  int opc = _store->Opcode();\n+  assert(opc == Op_StoreB || opc == Op_StoreC || opc == Op_StoreI, \"precondition\");\n+  assert(_store->adr_type()->isa_aryptr() != nullptr, \"must be array store\");\n+\n+  if (other_store == nullptr ||\n+      _store->Opcode() != other_store->Opcode() ||\n+      other_store->adr_type()->isa_aryptr() == nullptr) {\n+    return false;\n+  }\n+\n+  \/\/ Check that the size of the stores, and the array elements are all the same.\n+  const TypeAryPtr* aryptr_t1 = _store->adr_type()->is_aryptr();\n+  const TypeAryPtr* aryptr_t2 = other_store->adr_type()->is_aryptr();\n+  BasicType aryptr_bt1 = aryptr_t1->elem()->array_element_basic_type();\n+  BasicType aryptr_bt2 = aryptr_t2->elem()->array_element_basic_type();\n+  if (!is_java_primitive(aryptr_bt1) || !is_java_primitive(aryptr_bt2)) {\n+    return false;\n+  }\n+  int size1 = type2aelembytes(aryptr_bt1);\n+  int size2 = type2aelembytes(aryptr_bt2);\n+  if (size1 != size2 ||\n+      size1 != _store->memory_size() ||\n+      _store->memory_size() != other_store->memory_size()) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool MergePrimitiveArrayStores::is_adjacent_pair(const StoreNode* use_store, const StoreNode* def_store) const {\n+  if (!is_adjacent_input_pair(def_store->in(MemNode::ValueIn),\n+                              use_store->in(MemNode::ValueIn),\n+                              def_store->memory_size())) {\n+    return false;\n+  }\n+\n+  ResourceMark rm;\n+  ArrayPointer array_pointer_use = ArrayPointer::make(_phase, use_store->in(MemNode::Address));\n+  ArrayPointer array_pointer_def = ArrayPointer::make(_phase, def_store->in(MemNode::Address));\n+  if (!array_pointer_def.is_adjacent_to_and_before(array_pointer_use, use_store->memory_size())) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool MergePrimitiveArrayStores::is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n+  \/\/ Pattern: [n1 = ConI, n2 = ConI]\n+  if (n1->Opcode() == Op_ConI) {\n+    return n2->Opcode() == Op_ConI;\n+  }\n+\n+  \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n+  Node const* base_n2;\n+  jint shift_n2;\n+  if (!is_con_RShift(n2, base_n2, shift_n2)) {\n+    return false;\n+  }\n+  if (n1->Opcode() == Op_ConvL2I) {\n+    \/\/ look through\n+    n1 = n1->in(1);\n+  }\n+  Node const* base_n1;\n+  jint shift_n1;\n+  if (n1 == base_n2) {\n+    \/\/ n1 = base = base >> 0\n+    base_n1 = n1;\n+    shift_n1 = 0;\n+  } else if (!is_con_RShift(n1, base_n1, shift_n1)) {\n+    return false;\n+  }\n+  int bits_per_store = memory_size * 8;\n+  if (base_n1 != base_n2 ||\n+      shift_n1 + bits_per_store != shift_n2 ||\n+      shift_n1 % bits_per_store != 0) {\n+    return false;\n+  }\n+\n+  \/\/ both load from same value with correct shift\n+  return true;\n+}\n+\n+\/\/ Detect pattern: n = base_out >> shift_out\n+bool MergePrimitiveArrayStores::is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out) {\n+  assert(n != nullptr, \"precondition\");\n+\n+  int opc = n->Opcode();\n+  if (opc == Op_ConvL2I) {\n+    n = n->in(1);\n+    opc = n->Opcode();\n+  }\n+\n+  if ((opc == Op_RShiftI ||\n+       opc == Op_RShiftL ||\n+       opc == Op_URShiftI ||\n+       opc == Op_URShiftL) &&\n+      n->in(2)->is_ConI()) {\n+    base_out = n->in(1);\n+    shift_out = n->in(2)->get_int();\n+    assert(shift_out >= 0, \"must be positive\");\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/ Check if there is nothing between the two stores, except optionally a RangeCheck leading to an uncommon trap.\n+MergePrimitiveArrayStores::CFGStatus MergePrimitiveArrayStores::cfg_status_for_pair(const StoreNode* use_store, const StoreNode* def_store) {\n+  assert(use_store->in(MemNode::Memory) == def_store, \"use-def relationship\");\n+\n+  Node* ctrl_use = use_store->in(MemNode::Control);\n+  Node* ctrl_def = def_store->in(MemNode::Control);\n+  if (ctrl_use == nullptr || ctrl_def == nullptr) {\n+    return CFGStatus::Failure;\n+  }\n+\n+  if (ctrl_use == ctrl_def) {\n+    \/\/ Same ctrl -> no RangeCheck in between.\n+    \/\/ Check: use_store must be the only use of def_store.\n+    if (def_store->outcnt() > 1) {\n+      return CFGStatus::Failure;\n+    }\n+    return CFGStatus::SuccessNoRangeCheck;\n+  }\n+\n+  \/\/ Different ctrl -> could have RangeCheck in between.\n+  \/\/ Check: 1. def_store only has these uses: use_store and MergeMem for uncommon trap, and\n+  \/\/        2. ctrl separated by RangeCheck.\n+  if (def_store->outcnt() != 2) {\n+    return CFGStatus::Failure; \/\/ Cannot have exactly these uses: use_store and MergeMem for uncommon trap.\n+  }\n+  int use_store_out_idx = def_store->raw_out(0) == use_store ? 0 : 1;\n+  Node* merge_mem = def_store->raw_out(1 - use_store_out_idx)->isa_MergeMem();\n+  if (merge_mem == nullptr ||\n+      merge_mem->outcnt() != 1) {\n+    return CFGStatus::Failure; \/\/ Does not have MergeMem for uncommon trap.\n+  }\n+  if (!ctrl_use->is_IfProj() ||\n+      !ctrl_use->in(0)->is_RangeCheck() ||\n+      ctrl_use->in(0)->outcnt() != 2) {\n+    return CFGStatus::Failure; \/\/ Not RangeCheck.\n+  }\n+  ProjNode* other_proj = ctrl_use->as_IfProj()->other_if_proj();\n+  Node* trap = other_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check);\n+  if (trap != merge_mem->unique_out() ||\n+      ctrl_use->in(0)->in(0) != ctrl_def) {\n+    return CFGStatus::Failure; \/\/ Not RangeCheck with merge_mem leading to uncommon trap.\n+  }\n+\n+  return CFGStatus::SuccessWithRangeCheck;\n+}\n+\n+MergePrimitiveArrayStores::Status MergePrimitiveArrayStores::find_adjacent_use_store(const StoreNode* def_store) const {\n+  Status status_use = find_use_store(def_store);\n+  StoreNode* use_store = status_use.found_store();\n+  if (use_store != nullptr && !is_adjacent_pair(use_store, def_store)) {\n+    return Status::make_failure();\n+  }\n+  return status_use;\n+}\n+\n+MergePrimitiveArrayStores::Status MergePrimitiveArrayStores::find_adjacent_def_store(const StoreNode* use_store) const {\n+  Status status_def = find_def_store(use_store);\n+  StoreNode* def_store = status_def.found_store();\n+  if (def_store != nullptr && !is_adjacent_pair(use_store, def_store)) {\n+    return Status::make_failure();\n+  }\n+  return status_def;\n+}\n+\n+MergePrimitiveArrayStores::Status MergePrimitiveArrayStores::find_use_store(const StoreNode* def_store) const {\n+  Status status_use = find_use_store_unidirectional(def_store);\n+\n+#ifdef ASSERT\n+  StoreNode* use_store = status_use.found_store();\n+  if (use_store != nullptr) {\n+    Status status_def = find_def_store_unidirectional(use_store);\n+    assert(status_def.found_store() == def_store &&\n+           status_def.found_range_check() == status_use.found_range_check(),\n+           \"find_use_store and find_def_store must be symmetric\");\n+  }\n+#endif\n+\n+  return status_use;\n+}\n+\n+MergePrimitiveArrayStores::Status MergePrimitiveArrayStores::find_def_store(const StoreNode* use_store) const {\n+  Status status_def = find_def_store_unidirectional(use_store);\n+\n+#ifdef ASSERT\n+  StoreNode* def_store = status_def.found_store();\n+  if (def_store != nullptr) {\n+    Status status_use = find_use_store_unidirectional(def_store);\n+    assert(status_use.found_store() == use_store &&\n+           status_use.found_range_check() == status_def.found_range_check(),\n+           \"find_use_store and find_def_store must be symmetric\");\n+  }\n+#endif\n+\n+  return status_def;\n+}\n+\n+MergePrimitiveArrayStores::Status MergePrimitiveArrayStores::find_use_store_unidirectional(const StoreNode* def_store) const {\n+  assert(is_compatible_store(def_store), \"precondition: must be compatible with _store\");\n+\n+  for (DUIterator_Fast imax, i = def_store->fast_outs(imax); i < imax; i++) {\n+    StoreNode* use_store = def_store->fast_out(i)->isa_Store();\n+    if (is_compatible_store(use_store)) {\n+      return Status::make(use_store, cfg_status_for_pair(use_store, def_store));\n+    }\n+  }\n+\n+  return Status::make_failure();\n+}\n+\n+MergePrimitiveArrayStores::Status MergePrimitiveArrayStores::find_def_store_unidirectional(const StoreNode* use_store) const {\n+  assert(is_compatible_store(use_store), \"precondition: must be compatible with _store\");\n+\n+  StoreNode* def_store = use_store->in(MemNode::Memory)->isa_Store();\n+  if (!is_compatible_store(def_store)) {\n+    return Status::make_failure();\n+  }\n+\n+  return Status::make(def_store, cfg_status_for_pair(use_store, def_store));\n+}\n+\n+void MergePrimitiveArrayStores::collect_merge_list(Node_List& merge_list) const {\n+  \/\/ The merged store can be at most 8 bytes.\n+  const uint merge_list_max_size = 8 \/ _store->memory_size();\n+  assert(merge_list_max_size >= 2 &&\n+         merge_list_max_size <= 8 &&\n+         is_power_of_2(merge_list_max_size),\n+         \"must be 2, 4 or 8\");\n+\n+  \/\/ Traverse up the chain of adjacent def stores.\n+  StoreNode* current = _store;\n+  merge_list.push(current);\n+  while (current != nullptr && merge_list.size() < merge_list_max_size) {\n+    Status status = find_adjacent_def_store(current);\n+    current = status.found_store();\n+    if (current != nullptr) {\n+      merge_list.push(current);\n+\n+      \/\/ We can have at most one RangeCheck.\n+      if (status.found_range_check()) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  \/\/ Truncate the merge_list to a power of 2.\n+  const uint pow2size = round_down_power_of_2(merge_list.size());\n+  assert(pow2size >= 2, \"must be merging at least 2 stores\");\n+  while (merge_list.size() > pow2size) { merge_list.pop(); }\n+}\n+\n+\/\/ Merge the input values of the smaller stores to a single larger input value.\n+Node* MergePrimitiveArrayStores::make_merged_input_value(const Node_List& merge_list) {\n+  int new_memory_size = _store->memory_size() * merge_list.size();\n+  Node* first = merge_list.at(merge_list.size()-1);\n+  Node* merged_input_value = nullptr;\n+  if (_store->in(MemNode::ValueIn)->Opcode() == Op_ConI) {\n+    \/\/ Pattern: [ConI, ConI, ...] -> new constant\n+    jlong con = 0;\n+    jlong bits_per_store = _store->memory_size() * 8;\n+    jlong mask = (((jlong)1) << bits_per_store) - 1;\n+    for (uint i = 0; i < merge_list.size(); i++) {\n+      jlong con_i = merge_list.at(i)->in(MemNode::ValueIn)->get_int();\n+      con = con << bits_per_store;\n+      con = con | (mask & con_i);\n+    }\n+    merged_input_value = _phase->longcon(con);\n+  } else {\n+    \/\/ Pattern: [base >> 24, base >> 16, base >> 8, base] -> base\n+    \/\/             |                                  |\n+    \/\/           _store                             first\n+    \/\/\n+    merged_input_value = first->in(MemNode::ValueIn);\n+    Node const* base_last;\n+    jint shift_last;\n+    bool is_true = is_con_RShift(_store->in(MemNode::ValueIn), base_last, shift_last);\n+    assert(is_true, \"must detect con RShift\");\n+    if (merged_input_value != base_last && merged_input_value->Opcode() == Op_ConvL2I) {\n+      \/\/ look through\n+      merged_input_value = merged_input_value->in(1);\n+    }\n+    if (merged_input_value != base_last) {\n+      \/\/ merged_input_value is not the base\n+      return nullptr;\n+    }\n+  }\n+\n+  if (_phase->type(merged_input_value)->isa_long() != nullptr && new_memory_size <= 4) {\n+    \/\/ Example:\n+    \/\/\n+    \/\/   long base = ...;\n+    \/\/   a[0] = (byte)(base >> 0);\n+    \/\/   a[1] = (byte)(base >> 8);\n+    \/\/\n+    merged_input_value = _phase->transform(new ConvL2INode(merged_input_value));\n+  }\n+\n+  assert((_phase->type(merged_input_value)->isa_int() != nullptr && new_memory_size <= 4) ||\n+         (_phase->type(merged_input_value)->isa_long() != nullptr && new_memory_size == 8),\n+         \"merged_input_value is either int or long, and new_memory_size is small enough\");\n+\n+  return merged_input_value;\n+}\n+\n+\/\/                                                                                                          \/\/\n+\/\/ first_ctrl    first_mem   first_adr                first_ctrl    first_mem         first_adr             \/\/\n+\/\/  |                |           |                     |                |                 |                 \/\/\n+\/\/  |                |           |                     |                +---------------+ |                 \/\/\n+\/\/  |                |           |                     |                |               | |                 \/\/\n+\/\/  |                | +---------+                     |                | +---------------+                 \/\/\n+\/\/  |                | |                               |                | |             | |                 \/\/\n+\/\/  +--------------+ | |  v1                           +------------------------------+ | |  v1             \/\/\n+\/\/  |              | | |  |                            |                | |           | | |  |              \/\/\n+\/\/ RangeCheck     first_store                         RangeCheck        | |          first_store            \/\/\n+\/\/  |                |  |                              |                | |                |                \/\/\n+\/\/ last_ctrl         |  +----> unc_trap               last_ctrl         | |                +----> unc_trap  \/\/\n+\/\/  |                |                       ===>      |                | |                                 \/\/\n+\/\/  +--------------+ | a2 v2                           |                | |                                 \/\/\n+\/\/  |              | | |  |                            |                | |                                 \/\/\n+\/\/  |             second_store                         |                | |                                 \/\/\n+\/\/  |                |                                 |                | | [v1 v2   ...   vn]              \/\/\n+\/\/ ...              ...                                |                | |         |                       \/\/\n+\/\/  |                |                                 |                | |         v                       \/\/\n+\/\/  +--------------+ | an vn                           +--------------+ | | merged_input_value              \/\/\n+\/\/                 | | |  |                                           | | |  |                              \/\/\n+\/\/                last_store (= _store)                              merged_store                           \/\/\n+\/\/                                                                                                          \/\/\n+StoreNode* MergePrimitiveArrayStores::make_merged_store(const Node_List& merge_list, Node* merged_input_value) {\n+  Node* first_store = merge_list.at(merge_list.size()-1);\n+  Node* last_ctrl   = _store->in(MemNode::Control); \/\/ after (optional) RangeCheck\n+  Node* first_mem   = first_store->in(MemNode::Memory);\n+  Node* first_adr   = first_store->in(MemNode::Address);\n+\n+  const TypePtr* new_adr_type = _store->adr_type();\n+\n+  int new_memory_size = _store->memory_size() * merge_list.size();\n+  BasicType bt = T_ILLEGAL;\n+  switch (new_memory_size) {\n+    case 2: bt = T_SHORT; break;\n+    case 4: bt = T_INT;   break;\n+    case 8: bt = T_LONG;  break;\n+  }\n+\n+  StoreNode* merged_store = StoreNode::make(*_phase, last_ctrl, first_mem, first_adr,\n+                                            new_adr_type, merged_input_value, bt, MemNode::unordered);\n+\n+  \/\/ Marking the store mismatched is sufficient to prevent reordering, since array stores\n+  \/\/ are all on the same slice. Hence, we need no barriers.\n+  merged_store->set_mismatched_access();\n+\n+  \/\/ Constants above may now also be be packed -> put candidate on worklist\n+  _phase->is_IterGVN()->_worklist.push(first_mem);\n+\n+  return merged_store;\n+}\n+\n+#ifdef ASSERT\n+void MergePrimitiveArrayStores::trace(const Node_List& merge_list, const Node* merged_input_value, const StoreNode* merged_store) const {\n+  stringStream ss;\n+  ss.print_cr(\"[TraceMergeStores]: Replace\");\n+  for (int i = (int)merge_list.size() - 1; i >= 0; i--) {\n+    merge_list.at(i)->dump(\"\\n\", false, &ss);\n+  }\n+  ss.print_cr(\"[TraceMergeStores]: with\");\n+  merged_input_value->dump(\"\\n\", false, &ss);\n+  merged_store->dump(\"\\n\", false, &ss);\n+  tty->print(\"%s\", ss.as_string());\n+}\n+#endif\n+\n@@ -2779,0 +3471,12 @@\n+#ifdef VM_LITTLE_ENDIAN\n+  if (MergeStores && UseUnalignedAccesses) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      MergePrimitiveArrayStores merge(phase, this);\n+      Node* progress = merge.run();\n+      if (progress != nullptr) { return progress; }\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n+  }\n+#endif\n+\n@@ -3433,1 +4137,1 @@\n-    } else if (opc == Op_MemBarRelease) {\n+    } else if (opc == Op_MemBarRelease || (UseStoreStoreForCtor && opc == Op_MemBarStoreStore)) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":705,"deletions":1,"binary":false,"changes":706,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,6 @@\n+\n+  Node* minmax = Ideal_minmax(phase, this);\n+  if (minmax != nullptr) {\n+    return minmax;\n+  }\n+\n@@ -166,0 +172,7 @@\n+  if (phase->type(in(Condition)) == TypeInt::ZERO) {\n+    return phase->type(in(IfFalse))->filter(_type); \/\/ Always pick left (false) input\n+  }\n+  if (phase->type(in(Condition)) == TypeInt::ONE) {\n+    return phase->type(in(IfTrue))->filter(_type);  \/\/ Always pick right (true) input\n+  }\n+\n@@ -188,0 +201,58 @@\n+\/\/ Try to identify min\/max patterns in CMoves\n+Node* CMoveNode::Ideal_minmax(PhaseGVN* phase, CMoveNode* cmove) {\n+  \/\/ Only create MinL\/MaxL if we are allowed to create macro nodes.\n+  if (!phase->C->allow_macro_nodes()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ The BoolNode may have been idealized into a constant. If that's the case, then Identity should take care of it instead.\n+  BoolNode* bol = cmove->in(CMoveNode::Condition)->isa_Bool();\n+  if (bol == nullptr) {\n+    return nullptr;\n+  }\n+\n+  Node* cmp = bol->in(1);\n+  int cmove_op = cmove->Opcode();\n+  int cmp_op = cmp->Opcode();\n+\n+  \/\/ Ensure comparison is an integral type, and that the cmove is of the same type.\n+  if (!((cmp_op == Op_CmpI && cmove_op == Op_CMoveI) || (cmp_op == Op_CmpL && cmove_op == Op_CMoveL))) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Only accept canonicalized le and lt comparisons\n+  int test = bol->_test._test;\n+  if (test != BoolTest::le && test != BoolTest::lt) {\n+    return nullptr;\n+  }\n+\n+  \/\/ The values being compared\n+  Node* cmp_l = cmp->in(1);\n+  Node* cmp_r = cmp->in(2);\n+\n+  \/\/ The values being selected\n+  Node* cmove_l = cmove->in(CMoveNode::IfTrue);\n+  Node* cmove_r = cmove->in(CMoveNode::IfFalse);\n+\n+  \/\/ For this transformation to be valid, the values being compared must be the same as the values being selected.\n+  \/\/ We accept two different forms, \"a < b ? a : b\" and \"a < b ? b : a\". For the first form, the lhs and rhs of the\n+  \/\/ comparison and cmove are the same, resulting in a minimum. For the second form, the lhs and rhs of both are flipped,\n+  \/\/ resulting in a maximum. If neither form is found, bail out.\n+\n+  bool is_max;\n+  if (cmp_l == cmove_l && cmp_r == cmove_r) {\n+    is_max = false;\n+  } else if (cmp_l == cmove_r && cmp_r == cmove_l) {\n+    is_max = true;\n+  } else {\n+    return nullptr;\n+  }\n+\n+  \/\/ Create the Min\/Max node based on the type and kind\n+  if (cmp_op == Op_CmpL) {\n+    return MaxNode::build_min_max_long(phase, cmp_l, cmp_r, is_max);\n+  } else {\n+    return MaxNode::build_min_max_int(cmp_l, cmp_r, is_max);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,2 @@\n-  static Node *is_cmove_id( PhaseTransform *phase, Node *cmp, Node *t, Node *f, BoolNode *b );\n+  static Node* is_cmove_id(PhaseTransform* phase, Node* cmp, Node* t, Node* f, BoolNode* b);\n+  static Node* Ideal_minmax(PhaseGVN* phase, CMoveNode* cmov);\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1095,2 +1095,2 @@\n-\/\/ Emit bytes starting at parameter 'ptr'.\n-void Node::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {}\n+\/\/ Emit bytes using C2_MacroAssembler\n+void Node::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {}\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+class C2_MacroAssembler;\n@@ -1184,3 +1185,2 @@\n-  \/\/ Emit bytes starting at parameter 'ptr'\n-  \/\/ Bump 'ptr' by the number of output bytes\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  \/\/ Emit bytes using C2_MacroAssembler\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -1711,0 +1711,16 @@\n+  void push_non_cfg_inputs_of(const Node* node) {\n+    for (uint i = 1; i < node->req(); i++) {\n+      Node* input = node->in(i);\n+      if (input != nullptr && !input->is_CFG()) {\n+        push(input);\n+      }\n+    }\n+  }\n+\n+  void push_outputs_of(const Node* node) {\n+    for (DUIterator_Fast imax, i = node->fast_outs(imax); i < imax; i++) {\n+      Node* output = node->fast_out(i);\n+      push(output);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -366,1 +366,2 @@\n-  fill_buffer(cb, blk_starts);\n+  C2_MacroAssembler masm(cb);\n+  fill_buffer(&masm, blk_starts);\n@@ -1371,1 +1372,1 @@\n-void PhaseOutput::fill_buffer(CodeBuffer* cb, uint* blk_starts) {\n+void PhaseOutput::fill_buffer(C2_MacroAssembler* masm, uint* blk_starts) {\n@@ -1427,1 +1428,1 @@\n-    if (!constant_table().emit(*cb)) {\n+    if (!constant_table().emit(masm)) {\n@@ -1450,1 +1451,1 @@\n-      cb->flush_bundle(true);\n+      masm->code()->flush_bundle(true);\n@@ -1457,1 +1458,1 @@\n-      MacroAssembler(cb).block_comment(st.freeze());\n+      masm->block_comment(st.freeze());\n@@ -1467,1 +1468,1 @@\n-    MacroAssembler(cb).bind(blk_labels[block->_pre_order]);\n+    masm->bind(blk_labels[block->_pre_order]);\n@@ -1491,1 +1492,1 @@\n-        cb->flush_bundle(false);\n+        masm->code()->flush_bundle(false);\n@@ -1502,2 +1503,2 @@\n-          cb->flush_bundle(true);\n-          current_offset = cb->insts_size();\n+          masm->code()->flush_bundle(true);\n+          current_offset = masm->offset();\n@@ -1530,2 +1531,2 @@\n-          cb->insts()->maybe_expand_to_ensure_remaining(MAX_inst_size);\n-          if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n+          masm->code()->insts()->maybe_expand_to_ensure_remaining(MAX_inst_size);\n+          if ((masm->code()->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1535,3 +1536,3 @@\n-          nop->emit(*cb, C->regalloc());\n-          cb->flush_bundle(true);\n-          current_offset = cb->insts_size();\n+          nop->emit(masm, C->regalloc());\n+          masm->code()->flush_bundle(true);\n+          current_offset = masm->offset();\n@@ -1615,3 +1616,3 @@\n-                nop->emit(*cb, C->regalloc());\n-                cb->flush_bundle(true);\n-                current_offset = cb->insts_size();\n+                nop->emit(masm, C->regalloc());\n+                masm->code()->flush_bundle(true);\n+                current_offset = masm->offset();\n@@ -1682,2 +1683,2 @@\n-      cb->insts()->maybe_expand_to_ensure_remaining(MAX_inst_size);\n-      if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n+      masm->code()->insts()->maybe_expand_to_ensure_remaining(MAX_inst_size);\n+      if ((masm->code()->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1691,1 +1692,1 @@\n-        node_offsets[n->_idx] = cb->insts_size();\n+        node_offsets[n->_idx] = masm->offset();\n@@ -1697,3 +1698,3 @@\n-      DEBUG_ONLY(uint instr_offset = cb->insts_size());\n-      n->emit(*cb, C->regalloc());\n-      current_offset = cb->insts_size();\n+      DEBUG_ONLY(uint instr_offset = masm->offset());\n+      n->emit(masm, C->regalloc());\n+      current_offset = masm->offset();\n@@ -1718,1 +1719,1 @@\n-        Disassembler::decode(cb->insts_begin() + instr_offset, cb->insts_begin() + current_offset + 1, tty);\n+        Disassembler::decode(masm->code()->insts_begin() + instr_offset, masm->code()->insts_begin() + current_offset + 1, tty);\n@@ -1749,1 +1750,1 @@\n-        cb->set_insts_end(cb->insts_end() - Pipeline::instr_unit_size());\n+        masm->code()->set_insts_end(masm->code()->insts_end() - Pipeline::instr_unit_size());\n@@ -1754,1 +1755,1 @@\n-          node_offsets[delay_slot->_idx] = cb->insts_size();\n+          node_offsets[delay_slot->_idx] = masm->offset();\n@@ -1776,1 +1777,1 @@\n-        delay_slot->emit(*cb, C->regalloc());\n+        delay_slot->emit(masm, C->regalloc());\n@@ -1793,2 +1794,2 @@\n-        nop->emit(*cb, C->regalloc());\n-        current_offset = cb->insts_size();\n+        nop->emit(masm, C->regalloc());\n+        current_offset = masm->offset();\n@@ -1812,1 +1813,1 @@\n-  MacroAssembler(cb).bind( blk_labels[nblocks] );\n+  masm->bind( blk_labels[nblocks] );\n@@ -1830,1 +1831,1 @@\n-  if (!cb->finalize_stubs()) {\n+  if (!masm->code()->finalize_stubs()) {\n@@ -1836,1 +1837,1 @@\n-  bs->emit_stubs(*cb);\n+  bs->emit_stubs(*masm->code());\n@@ -1840,1 +1841,2 @@\n-  _stub_list.emit(*cb);\n+  assert(masm->inst_mark() == nullptr, \"should be.\");\n+  _stub_list.emit(*masm);\n@@ -1845,1 +1847,1 @@\n-  Scheduling::increment_method_size(cb->insts_size());\n+  Scheduling::increment_method_size(masm->offset());\n@@ -1856,1 +1858,1 @@\n-    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));\n+    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(masm));\n@@ -1861,1 +1863,1 @@\n-    _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));\n+    _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(masm));\n@@ -1867,1 +1869,1 @@\n-      _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));\n+      _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(masm));\n@@ -1872,1 +1874,1 @@\n-  if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n+  if ((masm->code()->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -3360,0 +3362,2 @@\n+  C2_MacroAssembler masm(&buf);\n+  masm.bind(fakeL);\n@@ -3361,2 +3365,0 @@\n-    MacroAssembler masm(&buf);\n-    masm.bind(fakeL);\n@@ -3366,1 +3368,1 @@\n-  n->emit(buf, C->regalloc());\n+  n->emit(&masm, C->regalloc());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":43,"deletions":41,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-  void fill_buffer(CodeBuffer* cb, uint* blk_starts);\n+  void fill_buffer(C2_MacroAssembler* masm, uint* blk_starts);\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1019,1 +1019,2 @@\n-    _exits.insert_mem_bar(Op_MemBarRelease, alloc_with_final());\n+    _exits.insert_mem_bar(UseStoreStoreForCtor ? Op_MemBarStoreStore : Op_MemBarRelease,\n+                          alloc_with_final());\n@@ -2242,2 +2243,1 @@\n-  if (RegisterFinalizersAtInit &&\n-      method()->intrinsic_id() == vmIntrinsics::_Object_init) {\n+  if (method()->intrinsic_id() == vmIntrinsics::_Object_init) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2276,1 +2276,9 @@\n-  assert( igvn->hash_find(this) != this, \"Need to remove from hash before changing edges\" );\n+#ifdef ASSERT\n+  if (igvn->hash_find(this) == this) {\n+    tty->print_cr(\"Need to remove from hash before changing edges\");\n+    this->dump(1);\n+    tty->print_cr(\"Set at i = %d\", i);\n+    n->dump();\n+    assert(false, \"Need to remove from hash before changing edges\");\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpression::maybe_contains,\n+  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpressionNode::is_maybe_in_expression,\n@@ -335,0 +335,22 @@\n+\n+\/\/ Check if this node belongs a Template Assertion Predicate Expression (including OpaqueLoop* nodes).\n+bool TemplateAssertionPredicateExpressionNode::is_in_expression(Node* node) {\n+  if (is_maybe_in_expression(node)) {\n+    ResourceMark rm;\n+    Unique_Node_List list;\n+    list.push(node);\n+    for (uint i = 0; i < list.size(); i++) {\n+      Node* next = list.at(i);\n+      if (next->is_OpaqueLoopInit() || next->is_OpaqueLoopStride()) {\n+        return true;\n+      } else if (is_maybe_in_expression(next)) {\n+        list.push_non_cfg_inputs_of(next);\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool TemplateAssertionPredicateExpressionNode::is_template_assertion_predicate(Node* node) {\n+  return node->is_If() && node->in(1)->is_Opaque4();\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -286,8 +286,35 @@\n-  \/\/ Is 'n' a node that could be part of a Template Assertion Predicate Expression (i.e. could be found on the input\n-  \/\/ chain of a Template Assertion Predicate Opaque4Node up to and including the OpaqueLoop* nodes)?\n-  static bool maybe_contains(const Node* n) {\n-    const int opcode = n->Opcode();\n-    return (opcode == Op_OpaqueLoopInit ||\n-            opcode == Op_OpaqueLoopStride ||\n-            n->is_Bool() ||\n-            n->is_Cmp() ||\n+  Opaque4Node* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl,PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init_and_stride(Node* new_init, Node* new_stride, Node* new_ctrl, PhaseIdealLoop* phase);\n+};\n+\n+\/\/ Class to represent a node being part of a Template Assertion Predicate Expression.\n+\/\/\n+\/\/ The expression itself can belong to no, one, or two Template Assertion Predicates:\n+\/\/ - None: This node is already dead (i.e. we replaced the Bool condition of the Template Assertion Predicate).\n+\/\/ - Two: A OpaqueLoopInitNode could be part of two Template Assertion Predicates.\n+\/\/ - One: In all other cases.\n+class TemplateAssertionPredicateExpressionNode : public StackObj {\n+  Node* const _node;\n+\n+ public:\n+  explicit TemplateAssertionPredicateExpressionNode(Node* node) : _node(node) {\n+    assert(is_in_expression(node), \"must be valid\");\n+  }\n+  NONCOPYABLE(TemplateAssertionPredicateExpressionNode);\n+\n+ private:\n+  static bool is_template_assertion_predicate(Node* node);\n+\n+ public:\n+  \/\/ Check whether the provided node is part of a Template Assertion Predicate Expression or not.\n+  static bool is_in_expression(Node* node);\n+\n+  \/\/ Check if the opcode of node could be found in a Template Assertion Predicate Expression.\n+  \/\/ This also provides a fast check whether a node is unrelated.\n+  static bool is_maybe_in_expression(const Node* node) {\n+    const int opcode = node->Opcode();\n+    return (node->is_OpaqueLoopInit() ||\n+            node->is_OpaqueLoopStride() ||\n+            node->is_Bool() ||\n+            node->is_Cmp() ||\n@@ -309,3 +336,27 @@\n-  Opaque4Node* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n-  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl,PhaseIdealLoop* phase);\n-  Opaque4Node* clone_and_replace_init_and_stride(Node* new_init, Node* new_stride, Node* new_ctrl, PhaseIdealLoop* phase);\n+  \/\/ Apply the given function to all Template Assertion Predicates (if any) to which this Template Assertion Predicate\n+  \/\/ Expression Node belongs to.\n+  template <class Callback>\n+  void for_each_template_assertion_predicate(Callback callback) {\n+    ResourceMark rm;\n+    Unique_Node_List list;\n+    list.push(_node);\n+    DEBUG_ONLY(int template_counter = 0;)\n+    for (uint i = 0; i < list.size(); i++) {\n+      Node* next = list.at(i);\n+      if (is_template_assertion_predicate(next)) {\n+        callback(next->as_If());\n+        DEBUG_ONLY(template_counter++;)\n+      } else {\n+        assert(!next->is_CFG(), \"no CFG expected in Template Assertion Predicate Expression\");\n+        list.push_outputs_of(next);\n+      }\n+    }\n+\n+    \/\/ Each node inside a Template Assertion Predicate Expression is in between a Template Assertion Predicate and\n+    \/\/ its OpaqueLoop* nodes (or an OpaqueLoop* node itself). The OpaqueLoop* nodes do not common up. Therefore, each\n+    \/\/ Template Assertion Predicate Expression node belongs to a single expression - except for OpaqueLoopInitNodes.\n+    \/\/ An OpaqueLoopInitNode is shared between the init and last value Template Assertion Predicate at creation.\n+    \/\/ Later, when cloning the expressions, they are no longer shared.\n+    assert(template_counter <= 2, \"a node cannot be part of more than two templates\");\n+    assert(template_counter <= 1 || _node->is_OpaqueLoopInit(), \"only OpaqueLoopInit nodes can be part of two templates\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -774,0 +774,23 @@\n+\/\/ Takes as parameters:\n+\/\/ void *dest\n+\/\/ long size\n+\/\/ uchar byte\n+const TypeFunc* OptoRuntime::make_setmemory_Type() {\n+  \/\/ create input type (domain)\n+  int argcnt = NOT_LP64(3) LP64_ONLY(4);\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;        \/\/ dest\n+  fields[argp++] = TypeX_X;                 \/\/ size\n+  LP64_ONLY(fields[argp++] = Type::HALF);   \/\/ size\n+  fields[argp++] = TypeInt::UBYTE;          \/\/ bytevalue\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,0 +269,2 @@\n+  static const TypeFunc* make_setmemory_Type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,19 +98,1 @@\n-  if (subgraph_has_opaque(n)) {\n-    Unique_Node_List wq;\n-    wq.push(n);\n-    for (uint i = 0; i < wq.size(); i++) {\n-      Node* m = wq.at(i);\n-      if (m->is_If()) {\n-        assert(assertion_predicate_has_loop_opaque_node(m->as_If()), \"opaque node not reachable from if?\");\n-        TemplateAssertionPredicateExpression template_assertion_predicate_expression(m->in(1)->as_Opaque4());\n-        Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(m->in(0), this);\n-        _igvn.replace_input_of(m, 1, cloned_opaque4_node);\n-      } else {\n-        assert(!m->is_CFG(), \"not CFG expected\");\n-        for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax; j++) {\n-          Node* u = m->fast_out(j);\n-          wq.push(u);\n-        }\n-      }\n-    }\n-  }\n+  clone_template_assertion_predicate_expression_down(n);\n@@ -430,0 +412,21 @@\n+\/\/ 'n' could be a node belonging to a Template Assertion Predicate Expression (i.e. any node between a Template\n+\/\/ Assertion Predicate and its OpaqueLoop* nodes (included)). We cannot simply split this node up since this would\n+\/\/ create a phi node inside the Template Assertion Predicate Expression - making it unrecognizable as such. Therefore,\n+\/\/ we completely clone the entire Template Assertion Predicate Expression \"down\". This ensures that we have an\n+\/\/ untouched copy that is still recognized by the Template Assertion Predicate matching code.\n+void PhaseIdealLoop::clone_template_assertion_predicate_expression_down(Node* node) {\n+  if (!TemplateAssertionPredicateExpressionNode::is_in_expression(node)) {\n+    return;\n+  }\n+\n+  TemplateAssertionPredicateExpressionNode template_assertion_predicate_expression_node(node);\n+  auto clone_expression = [&](IfNode* template_assertion_predicate) {\n+    Opaque4Node* opaque4_node = template_assertion_predicate->in(1)->as_Opaque4();\n+    TemplateAssertionPredicateExpression template_assertion_predicate_expression(opaque4_node);\n+    Node* new_ctrl = template_assertion_predicate->in(0);\n+    Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(new_ctrl, this);\n+    igvn().replace_input_of(template_assertion_predicate, 1, cloned_opaque4_node);\n+  };\n+  template_assertion_predicate_expression_node.for_each_template_assertion_predicate(clone_expression);\n+}\n+\n@@ -759,1 +762,1 @@\n-      register_new_node(pinned_clone, get_ctrl(use));\n+      register_new_node_with_ctrl_of(pinned_clone, use);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":23,"deletions":20,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2013,1 +2013,1 @@\n-    kit.insert_mem_bar(Op_MemBarRelease, result);\n+    kit.insert_mem_bar(UseStoreStoreForCtor ? Op_MemBarStoreStore : Op_MemBarRelease, result);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/rootnode.hpp\"\n@@ -2556,2 +2557,1 @@\n-        igvn().register_new_node_with_optimizer(mask);\n-        phase()->set_ctrl(mask, phase()->get_ctrl(p->at(0)));\n+        phase()->register_new_node_with_ctrl_of(mask, p->at(0));\n@@ -2631,2 +2631,1 @@\n-        igvn().register_new_node_with_optimizer(longval);\n-        phase()->set_ctrl(longval, phase()->get_ctrl(first));\n+        phase()->register_new_node_with_ctrl_of(longval, first);\n@@ -2672,2 +2671,1 @@\n-      igvn().register_new_node_with_optimizer(vn);\n-      phase()->set_ctrl(vn, phase()->get_ctrl(first));\n+      phase()->register_new_node_with_ctrl_of(vn, first);\n@@ -2742,2 +2740,1 @@\n-    igvn().register_new_node_with_optimizer(vn);\n-    phase()->set_ctrl(vn, phase()->get_ctrl(opd));\n+    phase()->register_new_node_with_ctrl_of(vn, opd);\n@@ -2763,2 +2760,2 @@\n-          cnt = ConNode::make(TypeInt::make(shift & mask));\n-          igvn().register_new_node_with_optimizer(cnt);\n+          cnt = igvn().intcon(shift & mask);\n+          phase()->set_ctrl(cnt, phase()->C->root());\n@@ -2768,2 +2765,1 @@\n-          cnt = ConNode::make(TypeInt::make(mask));\n-          igvn().register_new_node_with_optimizer(cnt);\n+          cnt = igvn().intcon(mask);\n@@ -2771,2 +2767,1 @@\n-          igvn().register_new_node_with_optimizer(cnt);\n-          phase()->set_ctrl(cnt, phase()->get_ctrl(opd));\n+          phase()->register_new_node_with_ctrl_of(cnt, opd);\n@@ -2781,2 +2776,1 @@\n-      igvn().register_new_node_with_optimizer(cnt);\n-      phase()->set_ctrl(cnt, phase()->get_ctrl(opd));\n+      phase()->register_new_node_with_ctrl_of(cnt, opd);\n@@ -2800,2 +2794,1 @@\n-         igvn().register_new_node_with_optimizer(conv);\n-         phase()->set_ctrl(conv, phase()->get_ctrl(opd));\n+         phase()->register_new_node_with_ctrl_of(conv, opd);\n@@ -2809,2 +2802,1 @@\n-    igvn().register_new_node_with_optimizer(vn);\n-    phase()->set_ctrl(vn, phase()->get_ctrl(opd));\n+    phase()->register_new_node_with_ctrl_of(vn, opd);\n@@ -2839,2 +2831,1 @@\n-  igvn().register_new_node_with_optimizer(pk);\n-  phase()->set_ctrl(pk, phase()->get_ctrl(opd));\n+  phase()->register_new_node_with_ctrl_of(pk, opd);\n@@ -3643,1 +3634,1 @@\n-      igvn().register_new_node_with_optimizer(invar);\n+      phase()->register_new_node(invar, pre_ctrl);\n@@ -3651,2 +3642,1 @@\n-    igvn().register_new_node_with_optimizer(xboi);\n-    phase()->set_ctrl(xboi, pre_ctrl);\n+    phase()->register_new_node(xboi, pre_ctrl);\n@@ -3662,1 +3652,1 @@\n-    igvn().register_new_node_with_optimizer(xbase);\n+    phase()->register_new_node(xbase, pre_ctrl);\n@@ -3666,1 +3656,1 @@\n-    igvn().register_new_node_with_optimizer(xbase);\n+    phase()->register_new_node(xbase, pre_ctrl);\n@@ -3674,2 +3664,1 @@\n-    igvn().register_new_node_with_optimizer(xboi);\n-    phase()->set_ctrl(xboi, pre_ctrl);\n+    phase()->register_new_node(xboi, pre_ctrl);\n@@ -3684,2 +3673,1 @@\n-  igvn().register_new_node_with_optimizer(XBOI);\n-  phase()->set_ctrl(XBOI, pre_ctrl);\n+  phase()->register_new_node(XBOI, pre_ctrl);\n@@ -3699,2 +3687,1 @@\n-  igvn().register_new_node_with_optimizer(XBOI_OP_old_limit);\n-  phase()->set_ctrl(XBOI_OP_old_limit, pre_ctrl);\n+  phase()->register_new_node(XBOI_OP_old_limit, pre_ctrl);\n@@ -3711,2 +3698,1 @@\n-  igvn().register_new_node_with_optimizer(adjust_pre_iter);\n-  phase()->set_ctrl(adjust_pre_iter, pre_ctrl);\n+  phase()->register_new_node(adjust_pre_iter, pre_ctrl);\n@@ -3725,2 +3711,1 @@\n-  igvn().register_new_node_with_optimizer(new_limit);\n-  phase()->set_ctrl(new_limit, pre_ctrl);\n+  phase()->register_new_node(new_limit, pre_ctrl);\n@@ -3734,2 +3719,1 @@\n-  igvn().register_new_node_with_optimizer(constrained_limit);\n-  phase()->set_ctrl(constrained_limit, pre_ctrl);\n+  phase()->register_new_node(constrained_limit, pre_ctrl);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":23,"deletions":39,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -305,0 +305,1 @@\n+    is_supported |= Matcher::supports_vector_predicate_op_emulation(sopc, num_elem, type);\n@@ -1039,1 +1040,7 @@\n-  bool mismatched_ms = from_ms->get_con() && !is_mask && arr_type != nullptr && arr_type->elem()->array_element_basic_type() != elem_bt;\n+  \/\/ For non-masked mismatched memory segment vector read\/write accesses, intrinsification can continue\n+  \/\/ with unknown backing storage type and compiler can skip inserting explicit reinterpretation IR after\n+  \/\/ loading from or before storing to backing storage which is mandatory for semantic correctness of\n+  \/\/ big-endian memory layout.\n+  bool mismatched_ms = LITTLE_ENDIAN_ONLY(false)\n+      BIG_ENDIAN_ONLY(from_ms->get_con() && !is_mask && arr_type != nullptr &&\n+                      arr_type->elem()->array_element_basic_type() != elem_bt);\n@@ -1041,0 +1048,6 @@\n+  if (!is_java_primitive(mem_elem_bt)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** non-primitive array element type\");\n+    }\n+    return false;\n+  }\n@@ -1503,2 +1516,2 @@\n-    if (!arch_supports_vector(is_scatter ? Op_StoreVectorScatterMasked : Op_LoadVectorGatherMasked, num_elem, elem_bt,\n-                              (VectorMaskUseType) (VecMaskUseLoad | VecMaskUsePred))) {\n+    VectorMaskUseType mask = (VectorMaskUseType) (VecMaskUseLoad | VecMaskUsePred);\n+    if (!arch_supports_vector(is_scatter ? Op_StoreVectorScatterMasked : Op_LoadVectorGatherMasked, num_elem, elem_bt, mask)) {\n@@ -1525,1 +1538,2 @@\n-  if (!arch_supports_vector(Op_LoadVector, num_elem, T_INT, VecMaskNotUsed)) {\n+  \/\/ For sub-word gathers expander receive index array.\n+  if (!is_subword_type(elem_bt) && !arch_supports_vector(Op_LoadVector, num_elem, T_INT, VecMaskNotUsed)) {\n@@ -1567,0 +1581,1 @@\n+  Node* index_vect = nullptr;\n@@ -1568,5 +1583,7 @@\n-  Node* index_vect = unbox_vector(argument(8), vbox_idx_type, T_INT, num_elem);\n-  if (index_vect == nullptr) {\n-    set_map(old_map);\n-    set_sp(old_sp);\n-    return false;\n+  if (!is_subword_type(elem_bt)) {\n+    index_vect = unbox_vector(argument(8), vbox_idx_type, T_INT, num_elem);\n+    if (index_vect == nullptr) {\n+      set_map(old_map);\n+      set_sp(old_sp);\n+      return false;\n+    }\n@@ -1611,0 +1628,3 @@\n+    Node* index    = argument(11);\n+    Node* indexMap = argument(12);\n+    Node* indexM   = argument(13);\n@@ -1612,1 +1632,6 @@\n-      vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_vect, mask));\n+      if (is_subword_type(elem_bt)) {\n+        Node* index_arr_base = array_element_address(indexMap, indexM, T_INT);\n+        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_arr_base, mask, index));\n+      } else {\n+        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_vect, mask));\n+      }\n@@ -1614,1 +1639,6 @@\n-      vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_vect));\n+      if (is_subword_type(elem_bt)) {\n+        Node* index_arr_base = array_element_address(indexMap, indexM, T_INT);\n+        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_arr_base, index));\n+      } else {\n+        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_vect));\n+      }\n@@ -2699,1 +2729,1 @@\n-  Node* operation = gvn().transform(VectorInsertNode::make(opd, insert_val, idx->get_con()));\n+  Node* operation = gvn().transform(VectorInsertNode::make(opd, insert_val, idx->get_con(), gvn()));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -464,1 +464,4 @@\n-  if (is_loop_member(adr)) {\n+  if (!invariant(adr)) {\n+    \/\/ The address must be invariant for the current loop. But if we are in a main-loop,\n+    \/\/ it must also be invariant of the pre-loop, otherwise we cannot use this address\n+    \/\/ for the pre-loop limit adjustment required for main-loop alignment.\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1679,1 +1679,1 @@\n-Node* VectorInsertNode::make(Node* vec, Node* new_val, int position) {\n+Node* VectorInsertNode::make(Node* vec, Node* new_val, int position, PhaseGVN& gvn) {\n@@ -1681,1 +1681,1 @@\n-  ConINode* pos = ConINode::make(position);\n+  ConINode* pos = gvn.intcon(position);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -893,1 +893,1 @@\n-  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices)\n+  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* offset = nullptr)\n@@ -896,1 +896,0 @@\n-    assert(indices->bottom_type()->is_vect(), \"indices must be in vector\");\n@@ -898,1 +897,7 @@\n-    assert(req() == MemNode::ValueIn + 1, \"match_edge expects that last input is in MemNode::ValueIn\");\n+    DEBUG_ONLY(bool is_subword = is_subword_type(vt->element_basic_type()));\n+    assert(is_subword || indices->bottom_type()->is_vect(), \"indices must be in vector\");\n+    assert(is_subword || !offset, \"\");\n+    assert(req() == MemNode::ValueIn + 1, \"match_edge expects that index input is in MemNode::ValueIn\");\n+    if (offset) {\n+      add_req(offset);\n+    }\n@@ -902,1 +907,6 @@\n-  virtual uint match_edge(uint idx) const { return idx == MemNode::Address || idx == MemNode::ValueIn; }\n+  virtual uint match_edge(uint idx) const {\n+     return idx == MemNode::Address ||\n+            idx == MemNode::ValueIn ||\n+            ((is_subword_type(vect_type()->element_basic_type())) &&\n+              idx == MemNode::ValueIn + 1);\n+  }\n@@ -1006,1 +1016,1 @@\n-  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask)\n+  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask, Node* offset = nullptr)\n@@ -1009,2 +1019,0 @@\n-    assert(indices->bottom_type()->is_vect(), \"indices must be in vector\");\n-    assert(mask->bottom_type()->isa_vectmask(), \"sanity\");\n@@ -1014,0 +1022,3 @@\n+    if (is_subword_type(vt->element_basic_type())) {\n+      add_req(offset);\n+    }\n@@ -1019,1 +1030,3 @@\n-                                                   idx == MemNode::ValueIn + 1; }\n+                                                   idx == MemNode::ValueIn + 1 ||\n+                                                   (is_subword_type(vect_type()->is_vect()->element_basic_type()) &&\n+                                                   idx == MemNode::ValueIn + 2); }\n@@ -1691,1 +1704,1 @@\n-  static Node* make(Node* vec, Node* new_val, int position);\n+  static Node* make(Node* vec, Node* new_val, int position, PhaseGVN& gvn);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1069,1 +1069,1 @@\n-          pool_index = mh->constants()->resolved_indy_entry_at(mh->constants()->decode_invokedynamic_index(cpci))->constant_pool_index();\n+          pool_index = mh->constants()->resolved_indy_entry_at(cpci)->constant_pool_index();\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2000,0 +2000,1 @@\n+  JavaThread* current = JavaThread::current();\n@@ -2001,1 +2002,3 @@\n-  bool self = target_jt == JavaThread::current();\n+  bool self = target_jt == current;\n+\n+  assert(!Continuations::enabled() || self || !is_virtual || current->is_VTMS_transition_disabler(), \"sanity check\");\n@@ -2076,1 +2079,3 @@\n-  assert(_target_jt == nullptr || _target_jt->vthread() == target_h(), \"sanity check\");\n+  \/\/ Use jvmti_vthread() instead of vthread() as target could have temporarily changed\n+  \/\/ identity to carrier thread (see VirtualThread.switchToCarrierThread).\n+  assert(_target_jt == nullptr || _target_jt->jvmti_vthread() == target_h(), \"sanity check\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -509,1 +509,3 @@\n-    assert(_target_jt->vthread() == target_h(), \"sanity check\");\n+    \/\/ Use jvmti_vthread() instead of vthread() as target could have temporarily changed\n+    \/\/ identity to carrier thread (see VirtualThread.switchToCarrierThread).\n+    assert(_target_jt->jvmti_vthread() == target_h(), \"sanity check\");\n@@ -529,1 +531,3 @@\n-    assert(_target_jt->vthread() == target_h(), \"sanity check\");\n+    \/\/ Use jvmti_vthread() instead of vthread() as target could have temporarily changed\n+    \/\/ identity to carrier thread (see VirtualThread.switchToCarrierThread).\n+    assert(_target_jt->jvmti_vthread() == target_h(), \"sanity check\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -267,41 +267,1 @@\n-class VM_VirtualThreadGetCurrentLocation : public VM_Operation {\n- private:\n-   Handle _vthread_h;\n-   jmethodID _method_id;\n-   int _bci;\n-   bool _completed;\n-\n- public:\n-  VM_VirtualThreadGetCurrentLocation(Handle vthread_h)\n-    : _vthread_h(vthread_h),\n-      _method_id(nullptr),\n-      _bci(0),\n-      _completed(false)\n-  {}\n-\n-  VMOp_Type type() const { return VMOp_VirtualThreadGetCurrentLocation; }\n-  void doit() {\n-    if (!JvmtiEnvBase::is_vthread_alive(_vthread_h())) {\n-      return; \/\/ _completed remains false.\n-    }\n-    ResourceMark rm;\n-    javaVFrame* jvf = JvmtiEnvBase::get_vthread_jvf(_vthread_h());\n-\n-    if (jvf != nullptr) {\n-      \/\/ jvf can be null, when the native enterSpecial frame is on the top.\n-      Method* method = jvf->method();\n-      _method_id = method->jmethod_id();\n-      _bci = jvf->bci();\n-    }\n-    _completed = true;\n-  }\n-  void get_current_location(jmethodID *method_id, int *bci) {\n-    *method_id = _method_id;\n-    *bci = _bci;\n-  }\n-  bool completed() {\n-    return _completed;\n-  }\n-};\n-\n-class GetCurrentLocationClosure : public HandshakeClosure {\n+class GetCurrentLocationClosure : public JvmtiUnitedHandshakeClosure {\n@@ -314,1 +274,1 @@\n-    : HandshakeClosure(\"GetCurrentLocation\"),\n+    : JvmtiUnitedHandshakeClosure(\"GetCurrentLocation\"),\n@@ -318,0 +278,1 @@\n+\n@@ -338,0 +299,15 @@\n+  void do_vthread(Handle target_h) {\n+    assert(_target_jt == nullptr || !_target_jt->is_exiting(), \"sanity check\");\n+    \/\/ Use jvmti_vthread() instead of vthread() as target could have temporarily changed\n+    \/\/ identity to carrier thread (see VirtualThread.switchToCarrierThread).\n+    assert(_target_jt == nullptr || _target_jt->jvmti_vthread() == target_h(), \"sanity check\");\n+    ResourceMark rm;\n+    javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(target_h());\n+\n+    if (jvf != nullptr) {\n+      Method* method = jvf->method();\n+      _method_id = method->jmethod_id();\n+      _bci = jvf->bci();\n+    }\n+    _completed = true;\n+  }\n@@ -375,1 +351,0 @@\n-\n@@ -378,1 +353,10 @@\n-    oop thread_oop = jvmti_thread_state()->get_thread_oop();\n+    if (event_type == JVMTI_EVENT_SINGLE_STEP &&\n+        ((thread == nullptr && is_virtual()) || thread->has_last_Java_frame())) {\n+      JavaThread* current = JavaThread::current();\n+      HandleMark hm(current);\n+      oop thread_oop = jvmti_thread_state()->get_thread_oop();\n+      Handle thread_h(current, thread_oop);\n+      ThreadsListHandle tlh(current);\n+\n+      GetCurrentLocationClosure op;\n+      JvmtiHandshake::execute(&op, &tlh, thread, thread_h);\n@@ -380,8 +364,0 @@\n-    if (thread == nullptr && event_type == JVMTI_EVENT_SINGLE_STEP && is_virtual()) {\n-      \/\/ Handle the unmounted virtual thread case.\n-      jmethodID method_id;\n-      int bci;\n-      JavaThread* cur_thread = JavaThread::current();\n-      HandleMark hm(cur_thread);\n-      VM_VirtualThreadGetCurrentLocation op(Handle(cur_thread, thread_oop));\n-      VMThread::execute(&op);\n@@ -389,1 +365,2 @@\n-        \/\/ Do nothing if virtual thread has been already terminated.\n+        jmethodID method_id;\n+        int bci;\n@@ -393,17 +370,0 @@\n-      return;\n-    }\n-    if (event_type == JVMTI_EVENT_SINGLE_STEP && thread->has_last_Java_frame()) {\n-      jmethodID method_id;\n-      int bci;\n-      \/\/ The java thread stack may not be walkable for a running thread\n-      \/\/ so get current location with direct handshake.\n-      GetCurrentLocationClosure op;\n-      Thread *current = Thread::current();\n-      if (thread->is_handshake_safe_for(current)) {\n-        op.do_thread(thread);\n-      } else {\n-        Handshake::execute(&op, thread);\n-        guarantee(op.completed(), \"Handshake failed. Target thread is not alive?\");\n-      }\n-      op.get_current_location(&method_id, &bci);\n-      set_current_location(method_id, bci);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":31,"deletions":71,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -123,3 +123,0 @@\n-    int indy_index_old = old_cp->decode_invokedynamic_index(index_old);\n-    int indy_index_new = new_cp->decode_invokedynamic_index(index_new);\n-\n@@ -134,2 +131,2 @@\n-    int cpi_old = old_cp->cache()->resolved_indy_entry_at(indy_index_old)->constant_pool_index();\n-    int cpi_new = new_cp->cache()->resolved_indy_entry_at(indy_index_new)->constant_pool_index();\n+    int cpi_old = old_cp->cache()->resolved_indy_entry_at(index_old)->constant_pool_index();\n+    int cpi_new = new_cp->cache()->resolved_indy_entry_at(index_new)->constant_pool_index();\n","filename":"src\/hotspot\/share\/prims\/methodComparator.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -396,1 +396,6 @@\n-    Copy::fill_to_memory_atomic(p, sz, value);\n+    if (StubRoutines::unsafe_setmemory() != nullptr) {\n+      MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));\n+      StubRoutines::UnsafeSetMemory_stub()(p, sz, value);\n+    } else {\n+      Copy::fill_to_memory_atomic(p, sz, value);\n+    }\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -1886,4 +1887,0 @@\n-WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))\n-  return ConstantPool::encode_invokedynamic_index(index);\n-WB_END\n-\n@@ -1991,1 +1988,1 @@\n-  enum CompileCommand option = CompilerOracle::string_to_option(flag_name);\n+  CompileCommandEnum option = CompilerOracle::string_to_option(flag_name);\n@@ -1993,1 +1990,1 @@\n-  if (option == CompileCommand::Unknown) {\n+  if (option == CompileCommandEnum::Unknown) {\n@@ -2847,2 +2844,0 @@\n-  {CC\"encodeConstantPoolIndyIndex0\",\n-      CC\"(I)I\",                      (void*)&WB_ConstantPoolEncodeIndyIndex},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -193,0 +193,3 @@\n+  \/\/ Does platform support secondary supers table lookup?\n+  constexpr static bool supports_secondary_supers_table() { return false; }\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -504,0 +504,3 @@\n+  { \"PreserveAllAnnotations\",       JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n+  { \"UseNotificationThread\",        JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n+  { \"UseEmptySlotsInSupers\",        JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -541,0 +544,1 @@\n+  { \"ScavengeBeforeFullGC\",         JDK_Version::undefined(), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n@@ -1715,5 +1719,0 @@\n-  \/\/ This appears to improve mutator locality\n-  if (FLAG_SET_CMDLINE(ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {\n-    return JNI_EINVAL;\n-  }\n-\n@@ -2735,4 +2734,0 @@\n-      \/\/ disable scavenge before parallel mark-compact\n-      if (FLAG_SET_CMDLINE(ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n@@ -3648,0 +3643,5 @@\n+  \/\/ The VMThread needs to stop now and then to execute these debug options.\n+  if ((HandshakeALot || SafepointALot) && FLAG_IS_DEFAULT(GuaranteedSafepointInterval)) {\n+    FLAG_SET_DEFAULT(GuaranteedSafepointInterval, 1000);\n+  }\n+\n@@ -3688,0 +3688,11 @@\n+  if (FLAG_IS_DEFAULT(UseSecondarySupersTable)) {\n+    FLAG_SET_DEFAULT(UseSecondarySupersTable, VM_Version::supports_secondary_supers_table());\n+  } else if (UseSecondarySupersTable && !VM_Version::supports_secondary_supers_table()) {\n+    warning(\"UseSecondarySupersTable is not supported\");\n+    FLAG_SET_DEFAULT(UseSecondarySupersTable, false);\n+  }\n+  if (!UseSecondarySupersTable) {\n+    FLAG_SET_DEFAULT(StressSecondarySupers, false);\n+    FLAG_SET_DEFAULT(VerifySecondarySupers, false);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1245,1 +1245,0 @@\n-  assert(chunk->to_offset(top.sp()) <= chunk->sp(), \"\");\n@@ -2312,1 +2311,1 @@\n-    int stack_args_slots = f.cb()->as_nmethod()->method()->num_stack_arg_slots(false \/* rounded *\/);\n+    int stack_args_slots = f.cb()->as_nmethod()->num_stack_arg_slots(false \/* rounded *\/);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -394,0 +394,1 @@\n+  DEBUG_ONLY(GrowableArray<oop> lock_order{0};)\n@@ -403,0 +404,7 @@\n+#ifdef ASSERT\n+      if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n+        for (MonitorInfo* mi : *monitors) {\n+          lock_order.push(mi->owner());\n+        }\n+      }\n+#endif \/\/ ASSERT\n@@ -434,0 +442,5 @@\n+#ifdef ASSERT\n+  if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n+    deoptee_thread->lock_stack().verify_consistent_lock_order(lock_order, exec_mode != Deoptimization::Unpack_none);\n+  }\n+#endif \/\/ ASSERT\n@@ -1645,1 +1658,1 @@\n-        if (LockingMode == LM_LIGHTWEIGHT && exec_mode == Unpack_none) {\n+        if (LockingMode == LM_LIGHTWEIGHT) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -950,0 +950,1 @@\n+  ResourceMark rm(thread);\n@@ -977,2 +978,3 @@\n-    if (reg_map->include_argument_oops()) {\n-      _cb->preserve_callee_argument_oops(*this, reg_map, f);\n+    if (reg_map->include_argument_oops() && _cb->is_nmethod()) {\n+      \/\/ Only nmethod preserves outgoing arguments at call.\n+      _cb->as_nmethod()->preserve_callee_argument_oops(*this, reg_map, f);\n@@ -1437,1 +1439,1 @@\n-      assert(stack_arg_slots ==  m->num_stack_arg_slots(false \/* rounded *\/), \"\");\n+      assert(stack_arg_slots ==  nm->as_nmethod()->num_stack_arg_slots(false \/* rounded *\/) || nm->is_osr_method(), \"\");\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -674,4 +674,0 @@\n-  product(bool, RegisterFinalizersAtInit, true,                             \\\n-          \"(Deprecated) Register finalizable objects at end of \"            \\\n-          \"Object.<init> or after allocation\")                              \\\n-                                                                            \\\n@@ -747,3 +743,2 @@\n-          \"off). The check is performed on GuaranteedSafepointInterval, \"   \\\n-          \"AsyncDeflationInterval or GuaranteedAsyncDeflationInterval, \"    \\\n-          \"whichever is lower.\")                                            \\\n+          \"off). The check is performed on AsyncDeflationInterval or \"      \\\n+          \"GuaranteedAsyncDeflationInterval, whichever is lower.\")          \\\n@@ -802,1 +797,1 @@\n-          \"Preserve RuntimeInvisibleAnnotations as well \"                   \\\n+          \"(Deprecated) Preserve RuntimeInvisibleAnnotations as well \"      \\\n@@ -875,3 +870,0 @@\n-  develop(bool, TraceInvocationCounterOverflow, false,                      \\\n-          \"Trace method invocation counter overflow\")                       \\\n-                                                                            \\\n@@ -963,1 +955,1 @@\n-          \"Use Notification Thread\")                                        \\\n+          \"(Deprecated) Use Notification Thread\")                           \\\n@@ -989,3 +981,0 @@\n-  product(bool, PrintMethodFlushingStatistics, false, DIAGNOSTIC,           \\\n-          \"print statistics about method flushing\")                         \\\n-                                                                            \\\n@@ -1280,1 +1269,1 @@\n-  product(intx, GuaranteedSafepointInterval, 1000, DIAGNOSTIC,              \\\n+  product(intx, GuaranteedSafepointInterval, 0, DIAGNOSTIC,                 \\\n@@ -1285,0 +1274,5 @@\n+  product(intx, ServiceThreadCleanupInterval, 1000, DIAGNOSTIC,             \\\n+          \"Wake the ServiceThread to do periodic cleanup checks every so \"  \\\n+          \"many milliseconds (0 means none)\")                               \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n@@ -1961,1 +1955,2 @@\n-                \"Allow allocating fields in empty slots of super-classes\")  \\\n+          \"(Deprecated) Allow allocating fields in empty slots of \"         \\\n+          \"super-classes\")                                                  \\\n@@ -1996,0 +1991,12 @@\n+                                                                            \\\n+  product(bool, UseSecondarySupersCache, true, DIAGNOSTIC,                  \\\n+                \"Use secondary supers cache during subtype checks.\")        \\\n+                                                                            \\\n+  product(bool, UseSecondarySupersTable, false, DIAGNOSTIC,                 \\\n+                \"Use hash table to lookup secondary supers.\")               \\\n+                                                                            \\\n+  product(bool, VerifySecondarySupers, false, DIAGNOSTIC,                   \\\n+          \"Check that linear and hashed secondary lookups return the same result.\") \\\n+                                                                            \\\n+  product(bool, StressSecondarySupers, false, DIAGNOSTIC,                   \\\n+          \"Use a terrible hash function in order to generate many collisions.\") \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+#include \"utilities\/events.hpp\"\n@@ -369,0 +370,2 @@\n+  Events::log(thread, \"Before exit entered\");\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -470,0 +470,1 @@\n+  _live_nmethod(nullptr),\n@@ -913,0 +914,14 @@\n+    \/\/ Check for monitor counts being out of sync.\n+    assert(held_monitor_count() == jni_monitor_count(),\n+           \"held monitor count should be equal to jni: \" INTX_FORMAT \" != \" INTX_FORMAT,\n+           held_monitor_count(), jni_monitor_count());\n+    \/\/ All in-use monitors, including JNI-locked ones, should have been released above.\n+    assert(held_monitor_count() == 0, \"Failed to unlock \" INTX_FORMAT \" object monitors\",\n+           held_monitor_count());\n+  } else {\n+    \/\/ Check for monitor counts being out of sync.\n+    assert(held_monitor_count() == jni_monitor_count(),\n+           \"held monitor count should be equal to jni: \" INTX_FORMAT \" != \" INTX_FORMAT,\n+           held_monitor_count(), jni_monitor_count());\n+    \/\/ It is possible that a terminating thread failed to unlock monitors it locked\n+    \/\/ via JNI so we don't assert the count is zero.\n@@ -915,6 +930,0 @@\n-  \/\/ Since above code may not release JNI monitors and if someone forgot to do an\n-  \/\/ JNI monitorexit, held count should be equal jni count.\n-  \/\/ Consider scan all object monitor for this owner if JNI count > 0 (at least on detach).\n-  assert(held_monitor_count() == jni_monitor_count(),\n-         \"held monitor count should be equal to jni: \" INTX_FORMAT \" != \" INTX_FORMAT,\n-         held_monitor_count(), jni_monitor_count());\n@@ -925,1 +934,1 @@\n-      exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\", os::current_thread_id());\n+                   exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\", os::current_thread_id());\n@@ -963,3 +972,6 @@\n-  log_info(os, thread)(\"JavaThread %s (tid: \" UINTX_FORMAT \").\",\n-    exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\",\n-    os::current_thread_id());\n+  if (log_is_enabled(Info, os, thread)) {\n+    ResourceMark rm(this);\n+    log_info(os, thread)(\"JavaThread %s (name: \\\"%s\\\", tid: \" UINTX_FORMAT \").\",\n+                         exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\",\n+                         name(), os::current_thread_id());\n+  }\n@@ -1421,0 +1433,4 @@\n+\n+  if (_live_nmethod != nullptr && cf != nullptr) {\n+    cf->do_nmethod(_live_nmethod);\n+  }\n@@ -1476,0 +1492,6 @@\n+\n+#if INCLUDE_JVMCI\n+  if (_live_nmethod != nullptr) {\n+    cf->do_nmethod(_live_nmethod);\n+  }\n+#endif\n@@ -1583,0 +1605,2 @@\n+  \/\/ Use raw field members for stack base\/size as this could be\n+  \/\/ called before a thread has run enough to initialize them.\n@@ -1584,2 +1608,2 @@\n-            p2i(stack_end()), p2i(stack_base()),\n-            PROPERFMTARGS(stack_size()));\n+            p2i(_stack_base - _stack_size), p2i(_stack_base),\n+            PROPERFMTARGS(_stack_size));\n@@ -1991,0 +2015,2 @@\n+\/\/ Slow-path increment of the held monitor counts. JNI locking is always\n+\/\/ this slow-path.\n@@ -1993,1 +2019,1 @@\n-  assert(_held_monitor_count >= 0, \"Must always be greater than 0: \" INTX_FORMAT, _held_monitor_count);\n+  assert(_held_monitor_count >= 0, \"Must always be non-negative: \" INTX_FORMAT, _held_monitor_count);\n@@ -1996,1 +2022,1 @@\n-    assert(_jni_monitor_count >= 0, \"Must always be greater than 0: \" INTX_FORMAT, _jni_monitor_count);\n+    assert(_jni_monitor_count >= 0, \"Must always be non-negative: \" INTX_FORMAT, _jni_monitor_count);\n@@ -1999,0 +2025,2 @@\n+  assert(_held_monitor_count >= _jni_monitor_count, \"Monitor count discrepancy detected - held count \"\n+         INTX_FORMAT \" is less than JNI count \" INTX_FORMAT, _held_monitor_count, _jni_monitor_count);\n@@ -2002,0 +2030,2 @@\n+\/\/ Slow-path decrement of the held monitor counts. JNI unlocking is always\n+\/\/ this slow-path.\n@@ -2010,0 +2040,6 @@\n+  \/\/ When a thread is detaching with still owned JNI monitors, the logic that releases\n+  \/\/ the monitors doesn't know to set the \"jni\" flag and so the counts can get out of sync.\n+  \/\/ So we skip this assert if the thread is exiting. Once all monitors are unlocked the\n+  \/\/ JNI count is directly set to zero.\n+  assert(_held_monitor_count >= _jni_monitor_count || is_exiting(), \"Monitor count discrepancy detected - held count \"\n+         INTX_FORMAT \" is less than JNI count \" INTX_FORMAT, _held_monitor_count, _jni_monitor_count);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":50,"deletions":14,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -382,0 +382,4 @@\n+  \/\/ This field is used to keep an nmethod visible to the GC so that it and its contained oops can\n+  \/\/ be kept alive\n+  nmethod*  _live_nmethod;\n+\n@@ -414,0 +418,9 @@\n+  void set_live_nmethod(nmethod* nm) {\n+    assert(_live_nmethod == nullptr, \"only one\");\n+    _live_nmethod = nm;\n+  }\n+\n+  void clear_live_nmethod() {\n+    _live_nmethod = nullptr;\n+  }\n+\n@@ -814,0 +827,1 @@\n+  static ByteSize jni_monitor_count_offset()  { return byte_offset_of(JavaThread, _jni_monitor_count); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n@@ -31,0 +33,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -38,0 +41,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -102,0 +106,54 @@\n+#ifdef ASSERT\n+void LockStack::verify_consistent_lock_order(GrowableArray<oop>& lock_order, bool leaf_frame) const {\n+  int top_index = to_index(_top);\n+  int lock_index = lock_order.length();\n+\n+  if (!leaf_frame) {\n+    \/\/ If the lock_order is not from the leaf frame we must search\n+    \/\/ for the top_index which fits with the most recent fast_locked\n+    \/\/ objects in the lock stack.\n+    while (lock_index-- > 0) {\n+      const oop obj = lock_order.at(lock_index);\n+      if (contains(obj)) {\n+        for (int index = 0; index < top_index; index++) {\n+          if (_base[index] == obj) {\n+            \/\/ Found top index\n+            top_index = index + 1;\n+            break;\n+          }\n+        }\n+\n+        if (VM_Version::supports_recursive_lightweight_locking()) {\n+          \/\/ With recursive looks there may be more of the same object\n+          while (lock_index-- > 0 && lock_order.at(lock_index) == obj) {\n+            top_index++;\n+          }\n+          assert(top_index <= to_index(_top), \"too many obj in lock_order\");\n+        }\n+\n+        break;\n+      }\n+    }\n+\n+    lock_index = lock_order.length();\n+  }\n+\n+  while (lock_index-- > 0) {\n+    const oop obj = lock_order.at(lock_index);\n+    const markWord mark = obj->mark_acquire();\n+    assert(obj->is_locked(), \"must be locked\");\n+    if (top_index > 0 && obj == _base[top_index - 1]) {\n+      assert(mark.is_fast_locked() || mark.monitor()->is_owner_anonymous(),\n+             \"must be fast_locked or inflated by other thread\");\n+      top_index--;\n+    } else {\n+      assert(!mark.is_fast_locked(), \"must be inflated\");\n+      assert(mark.monitor()->owner_raw() == get_thread() ||\n+             (!leaf_frame && get_thread()->current_waiting_monitor() == mark.monitor()),\n+             \"must be owned by (or waited on by) thread\");\n+      assert(!contains(obj), \"must not be on lock_stack\");\n+    }\n+  }\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+template<typename>\n+class GrowableArray;\n@@ -122,0 +124,3 @@\n+\n+  \/\/ Verify Lock Stack consistent with lock order\n+  void verify_consistent_lock_order(GrowableArray<oop>& lock_order, bool leaf_frame) const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,5 +53,1 @@\n-  \/\/ We wait for the lowest of these three intervals:\n-  \/\/  - GuaranteedSafepointInterval\n-  \/\/      While deflation is not related to safepoint anymore, this keeps compatibility with\n-  \/\/      the old behavior when deflation also happened at safepoints. Users who set this\n-  \/\/      option to get more\/less frequent deflations would be served with this option.\n+  \/\/ We wait for the lowest of these two intervals:\n@@ -66,3 +62,0 @@\n-  if (GuaranteedSafepointInterval > 0) {\n-    wait_time = MIN2(wait_time, GuaranteedSafepointInterval);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -111,13 +111,0 @@\n-\/\/ Tunables ...\n-\/\/ The knob* variables are effectively final.  Once set they should\n-\/\/ never be modified hence.  Consider using __read_mostly with GCC.\n-\n-int ObjectMonitor::Knob_SpinLimit    = 5000;    \/\/ derived by an external tool -\n-\n-static int Knob_Bonus               = 100;     \/\/ spin success bonus\n-static int Knob_BonusB              = 100;     \/\/ spin success bonus\n-static int Knob_Penalty             = 200;     \/\/ spin failure penalty\n-static int Knob_Poverty             = 1000;\n-static int Knob_FixedSpin           = 0;\n-static int Knob_PreSpin             = 10;      \/\/ 20-100 likely better\n-\n@@ -409,1 +396,1 @@\n-  if (TrySpin(current) > 0) {\n+  if (TrySpin(current)) {\n@@ -538,1 +525,1 @@\n-int ObjectMonitor::TryLock(JavaThread* current) {\n+ObjectMonitor::TryLockResult ObjectMonitor::TryLock(JavaThread* current) {\n@@ -540,1 +527,1 @@\n-  if (own != nullptr) return 0;\n+  if (own != nullptr) return TryLockResult::HasOwner;\n@@ -543,1 +530,1 @@\n-    return 1;\n+    return TryLockResult::Success;\n@@ -549,1 +536,1 @@\n-  return -1;\n+  return TryLockResult::Interference;\n@@ -726,1 +713,1 @@\n-  if (TryLock (current) > 0) {\n+  if (TryLock(current) == TryLockResult::Success) {\n@@ -760,1 +747,1 @@\n-  if (TrySpin(current) > 0) {\n+  if (TrySpin(current)) {\n@@ -797,1 +784,1 @@\n-    if (TryLock (current) > 0) {\n+    if (TryLock(current) == TryLockResult::Success) {\n@@ -850,1 +837,3 @@\n-    if (TryLock(current) > 0) break;\n+    if (TryLock(current) == TryLockResult::Success) {\n+      break;\n+    }\n@@ -865,1 +854,3 @@\n-    if (TryLock(current) > 0) break;\n+    if (TryLock(current) == TryLockResult::Success) {\n+      break;\n+    }\n@@ -898,1 +889,3 @@\n-    if (TrySpin(current) > 0) break;\n+    if (TrySpin(current)) {\n+      break;\n+    }\n@@ -997,2 +990,3 @@\n-    if (TryLock(current) > 0) break;\n-    if (TrySpin(current) > 0) break;\n+    if (TrySpin(current)) {\n+        break;\n+    }\n@@ -1015,1 +1009,3 @@\n-    if (TryLock(current) > 0) break;\n+    if (TryLock(current) == TryLockResult::Success) {\n+      break;\n+    }\n@@ -1857,8 +1853,13 @@\n-\/\/ Spinning: Fixed frequency (100%), vary duration\n-int ObjectMonitor::TrySpin(JavaThread* current) {\n-  \/\/ Dumb, brutal spin.  Good for comparative measurements against adaptive spinning.\n-  int ctr = Knob_FixedSpin;\n-  if (ctr != 0) {\n-    while (--ctr >= 0) {\n-      if (TryLock(current) > 0) return 1;\n-      SpinPause();\n+int ObjectMonitor::Knob_SpinLimit    = 5000;   \/\/ derived by an external tool\n+\n+static int Knob_Bonus               = 100;     \/\/ spin success bonus\n+static int Knob_Penalty             = 200;     \/\/ spin failure penalty\n+static int Knob_Poverty             = 1000;\n+static int Knob_FixedSpin           = 0;\n+static int Knob_PreSpin             = 10;      \/\/ 20-100 likely better, but it's not better in my testing.\n+\n+inline static int adjust_up(int spin_duration) {\n+  int x = spin_duration;\n+  if (x < ObjectMonitor::Knob_SpinLimit) {\n+    if (x < Knob_Poverty) {\n+      x = Knob_Poverty;\n@@ -1866,1 +1867,3 @@\n-    return 0;\n+    return x + Knob_Bonus;\n+  } else {\n+    return spin_duration;\n@@ -1868,0 +1871,16 @@\n+}\n+\n+inline static int adjust_down(int spin_duration) {\n+  \/\/ TODO: Use an AIMD-like policy to adjust _SpinDuration.\n+  \/\/ AIMD is globally stable.\n+  int x = spin_duration;\n+  if (x > 0) {\n+    \/\/ Consider an AIMD scheme like: x -= (x >> 3) + 100\n+    \/\/ This is globally sample and tends to damp the response.\n+    x -= Knob_Penalty;\n+    if (x < 0) { x = 0; }\n+    return x;\n+  } else {\n+    return spin_duration;\n+  }\n+}\n@@ -1869,9 +1888,6 @@\n-  for (ctr = Knob_PreSpin + 1; --ctr >= 0;) {\n-    if (TryLock(current) > 0) {\n-      \/\/ Increase _SpinDuration ...\n-      \/\/ Note that we don't clamp SpinDuration precisely at SpinLimit.\n-      \/\/ Raising _SpurDuration to the poverty line is key.\n-      int x = _SpinDuration;\n-      if (x < Knob_SpinLimit) {\n-        if (x < Knob_Poverty) x = Knob_Poverty;\n-        _SpinDuration = x + Knob_BonusB;\n+bool ObjectMonitor::short_fixed_spin(JavaThread* current, int spin_count, bool adapt) {\n+  for (int ctr = 0; ctr < spin_count; ctr++) {\n+    TryLockResult status = TryLock(current);\n+    if (status == TryLockResult::Success) {\n+      if (adapt) {\n+        _SpinDuration = adjust_up(_SpinDuration);\n@@ -1879,1 +1895,3 @@\n-      return 1;\n+      return true;\n+    } else if (status == TryLockResult::Interference) {\n+      break;\n@@ -1883,0 +1901,11 @@\n+  return false;\n+}\n+\n+\/\/ Spinning: Fixed frequency (100%), vary duration\n+bool ObjectMonitor::TrySpin(JavaThread* current) {\n+\n+  \/\/ Dumb, brutal spin.  Good for comparative measurements against adaptive spinning.\n+  int knob_fixed_spin = Knob_FixedSpin;  \/\/ 0 (don't spin: default), 2000 good test\n+  if (knob_fixed_spin > 0) {\n+    return short_fixed_spin(current, knob_fixed_spin, false);\n+  }\n@@ -1890,0 +1919,6 @@\n+\n+  int knob_pre_spin = Knob_PreSpin; \/\/ 10 (default), 100, 1000 or 2000\n+  if (short_fixed_spin(current, knob_pre_spin, true)) {\n+    return true;\n+  }\n+\n@@ -1898,2 +1933,2 @@\n-  ctr = _SpinDuration;\n-  if (ctr <= 0) return 0;\n+  int ctr = _SpinDuration;\n+  if (ctr <= 0) return false;\n@@ -1931,1 +1966,1 @@\n-        goto Abort;           \/\/ abrupt spin egress\n+        break;\n@@ -1963,6 +1998,2 @@\n-        int x = _SpinDuration;\n-        if (x < Knob_SpinLimit) {\n-          if (x < Knob_Poverty) x = Knob_Poverty;\n-          _SpinDuration = x + Knob_Bonus;\n-        }\n-        return 1;\n+        _SpinDuration = adjust_up(_SpinDuration);\n+        return true;\n@@ -1973,1 +2004,1 @@\n-      \/\/ * exit spin with prejudice -- goto Abort;\n+      \/\/ * exit spin with prejudice -- abort without adapting spinner\n@@ -1976,2 +2007,1 @@\n-      prv = ox;\n-      goto Abort;\n+      break;\n@@ -1982,1 +2012,1 @@\n-      goto Abort;\n+      break;\n@@ -1992,11 +2022,2 @@\n-  \/\/ TODO: Use an AIMD-like policy to adjust _SpinDuration.\n-  \/\/ AIMD is globally stable.\n-  {\n-    int x = _SpinDuration;\n-    if (x > 0) {\n-      \/\/ Consider an AIMD scheme like: x -= (x >> 3) + 100\n-      \/\/ This is globally sample and tends to damp the response.\n-      x -= Knob_Penalty;\n-      if (x < 0) x = 0;\n-      _SpinDuration = x;\n-    }\n+  if (ctr < 0) {\n+    _SpinDuration = adjust_down(_SpinDuration);\n@@ -2005,1 +2026,0 @@\n- Abort:\n@@ -2013,1 +2033,3 @@\n-    if (TryLock(current) > 0) return 1;\n+    if (TryLock(current) == TryLockResult::Success) {\n+      return true;\n+    }\n@@ -2015,1 +2037,2 @@\n-  return 0;\n+\n+  return false;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":96,"deletions":73,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -356,2 +356,8 @@\n-  int       TryLock(JavaThread* current);\n-  int       TrySpin(JavaThread* current);\n+\n+\n+  enum class TryLockResult { Interference = -1, HasOwner = 0, Success = 1 };\n+\n+  TryLockResult  TryLock(JavaThread* current);\n+\n+  bool      TrySpin(JavaThread* current);\n+  bool      short_fixed_spin(JavaThread* current, int spin_count, bool adapt);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -83,6 +83,0 @@\n-static void post_safepoint_cleanup_event(EventSafepointCleanup& event, uint64_t safepoint_id) {\n-  if (event.should_commit()) {\n-    event.set_safepointId(safepoint_id);\n-    event.commit();\n-  }\n-}\n@@ -104,10 +98,0 @@\n-static void post_safepoint_cleanup_task_event(EventSafepointCleanupTask& event,\n-                                              uint64_t safepoint_id,\n-                                              const char* name) {\n-  if (event.should_commit()) {\n-    event.set_safepointId(safepoint_id);\n-    event.set_name(name);\n-    event.commit();\n-  }\n-}\n-\n@@ -438,6 +422,0 @@\n-  \/\/ We do the safepoint cleanup first since a GC related safepoint\n-  \/\/ needs cleanup to be completed before running the GC op.\n-  EventSafepointCleanup cleanup_event;\n-  do_cleanup_tasks();\n-  post_safepoint_cleanup_event(cleanup_event, _safepoint_id);\n-\n@@ -445,1 +423,0 @@\n-  SafepointTracing::cleanup();\n@@ -510,62 +487,0 @@\n-class ParallelCleanupTask : public WorkerTask {\n-private:\n-  SubTasksDone _subtasks;\n-\n-  class Tracer {\n-  private:\n-    const char*               _name;\n-    EventSafepointCleanupTask _event;\n-    TraceTime                 _timer;\n-\n-  public:\n-    Tracer(const char* name) :\n-        _name(name),\n-        _event(),\n-        _timer(name, TRACETIME_LOG(Info, safepoint, cleanup)) {}\n-    ~Tracer() {\n-      post_safepoint_cleanup_task_event(_event, SafepointSynchronize::safepoint_id(), _name);\n-    }\n-  };\n-\n-public:\n-  ParallelCleanupTask() :\n-    WorkerTask(\"Parallel Safepoint Cleanup\"),\n-    _subtasks(SafepointSynchronize::SAFEPOINT_CLEANUP_NUM_TASKS) {}\n-\n-  uint expected_num_workers() const {\n-    uint workers = 0;\n-\n-    return MAX2<uint>(1, workers);\n-  }\n-\n-  void work(uint worker_id) {\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_REQUEST_OOPSTORAGE_CLEANUP)) {\n-      \/\/ Don't bother reporting event or time for this very short operation.\n-      \/\/ To have any utility we'd also want to report whether needed.\n-      OopStorage::trigger_cleanup_if_needed();\n-    }\n-\n-    _subtasks.all_tasks_claimed();\n-  }\n-};\n-\n-\/\/ Various cleaning tasks that should be done periodically at safepoints.\n-void SafepointSynchronize::do_cleanup_tasks() {\n-\n-  TraceTime timer(\"safepoint cleanup tasks\", TRACETIME_LOG(Info, safepoint, cleanup));\n-\n-  CollectedHeap* heap = Universe::heap();\n-  assert(heap != nullptr, \"heap not initialized yet?\");\n-  ParallelCleanupTask cleanup;\n-  WorkerThreads* cleanup_workers = heap->safepoint_workers();\n-  const uint expected_num_workers = cleanup.expected_num_workers();\n-  if (cleanup_workers != nullptr && expected_num_workers > 1) {\n-    \/\/ Parallel cleanup using GC provided thread pool.\n-    const uint num_workers = MIN2(expected_num_workers, cleanup_workers->active_workers());\n-    cleanup_workers->run_task(&cleanup, num_workers);\n-  } else {\n-    \/\/ Serial cleanup using VMThread.\n-    cleanup.work(0);\n-  }\n-}\n-\n@@ -949,1 +864,0 @@\n-jlong SafepointTracing::_last_safepoint_cleanup_time_ns = 0;\n@@ -957,1 +871,0 @@\n-jlong     SafepointTracing::_max_cleanup_time = 0;\n@@ -973,1 +886,1 @@\n-            \"[ time:       sync    cleanup       vmop      total ]\");\n+            \"[ time:       sync    vmop      total ]\");\n@@ -1002,2 +915,1 @@\n-           INT64_FORMAT_W(10) \" \" INT64_FORMAT_W(10) \" \"\n-           INT64_FORMAT_W(10) \" \" INT64_FORMAT_W(10) \" ]\",\n+           INT64_FORMAT_W(10) \" \" INT64_FORMAT_W(10) \" \" INT64_FORMAT_W(10) \" ]\",\n@@ -1005,2 +917,1 @@\n-           (int64_t)(_last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns),\n-           (int64_t)(_last_safepoint_end_time_ns - _last_safepoint_cleanup_time_ns),\n+           (int64_t)(_last_safepoint_end_time_ns - _last_safepoint_sync_time_ns),\n@@ -1027,2 +938,0 @@\n-  log_info(safepoint, stats)(\"Maximum cleanup time  \" INT64_FORMAT\" ns\",\n-                              (int64_t)(_max_cleanup_time));\n@@ -1041,1 +950,0 @@\n-  _last_safepoint_cleanup_time_ns = 0;\n@@ -1057,4 +965,0 @@\n-void SafepointTracing::cleanup() {\n-  _last_safepoint_cleanup_time_ns = os::javaTimeNanos();\n-}\n-\n@@ -1067,3 +971,0 @@\n-  if (_max_cleanup_time < (_last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns)) {\n-    _max_cleanup_time = _last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns;\n-  }\n@@ -1081,1 +982,0 @@\n-     \"Cleanup: \" JLONG_FORMAT \" ns, \"\n@@ -1087,2 +987,1 @@\n-      _last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns,\n-      _last_safepoint_end_time_ns     - _last_safepoint_cleanup_time_ns,\n+      _last_safepoint_end_time_ns     - _last_safepoint_sync_time_ns,\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":4,"deletions":105,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -71,7 +71,0 @@\n-  \/\/ The enums are listed in the order of the tasks when done serially.\n-  enum SafepointCleanupTasks {\n-    SAFEPOINT_CLEANUP_REQUEST_OOPSTORAGE_CLEANUP,\n-    \/\/ Leave this one last.\n-    SAFEPOINT_CLEANUP_NUM_TASKS\n-  };\n-\n@@ -158,2 +151,0 @@\n-  static void do_cleanup_tasks();\n-\n@@ -242,1 +233,0 @@\n-  static jlong _last_safepoint_cleanup_time_ns;\n@@ -254,1 +244,0 @@\n-  static jlong     _max_cleanup_time;\n@@ -265,1 +254,0 @@\n-  static void cleanup();\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,2 +129,3 @@\n-        \/\/ Wait until notified that there is some work to do.\n-        ml.wait();\n+        \/\/ Wait until notified that there is some work to do or timer expires.\n+        \/\/ Some cleanup requests don't notify the ServiceThread so work needs to be done at periodic intervals.\n+        ml.wait(ServiceThreadCleanupInterval);\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+uint SharedRuntime::_unsafe_set_memory_ctr=0;\n@@ -544,1 +545,0 @@\n-\n@@ -1399,2 +1399,1 @@\n-  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  return get_resolved_entry(current, callee_method);\n@@ -1453,2 +1452,1 @@\n-  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  return get_resolved_entry(current, callee_method);\n@@ -1491,0 +1489,11 @@\n+\/\/ return verified_code_entry if interp_only_mode is not set for the current thread;\n+\/\/ otherwise return c2i entry.\n+address SharedRuntime::get_resolved_entry(JavaThread* current, methodHandle callee_method) {\n+  if (current->is_interp_only_mode() && !callee_method->is_special_native_intrinsic()) {\n+    \/\/ In interp_only_mode we need to go to the interpreted entry\n+    \/\/ The c2i won't patch in this mode -- see fixup_callers_callsite\n+    return callee_method->get_c2i_entry();\n+  }\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n+  return callee_method->verified_code_entry();\n+}\n@@ -1499,12 +1508,0 @@\n-\n-    if (current->is_interp_only_mode()) {\n-      RegisterMap reg_map(current,\n-                          RegisterMap::UpdateMap::skip,\n-                          RegisterMap::ProcessFrames::include,\n-                          RegisterMap::WalkContinuation::skip);\n-      frame stub_frame = current->last_frame();\n-      assert(stub_frame.is_runtime_frame(), \"must be a runtimeStub\");\n-      frame caller = stub_frame.sender(&reg_map);\n-      enter_special = caller.cb() != nullptr && caller.cb()->is_nmethod()\n-        && caller.cb()->as_nmethod()->method()->is_continuation_enter_intrinsic();\n-    }\n@@ -1512,12 +1509,0 @@\n-\n-  if (current->is_interp_only_mode() && enter_special) {\n-    \/\/ enterSpecial is compiled and calls this method to resolve the call to Continuation::enter\n-    \/\/ but in interp_only_mode we need to go to the interpreted entry\n-    \/\/ The c2i won't patch in this mode -- see fixup_callers_callsite\n-    \/\/\n-    \/\/ This should probably be done in all cases, not just enterSpecial (see JDK-8218403),\n-    \/\/ but that's part of a larger fix, and the situation is worse for enterSpecial, as it has no\n-    \/\/ interpreted version.\n-    return callee_method->get_c2i_entry();\n-  }\n-\n@@ -1525,2 +1510,1 @@\n-  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  return get_resolved_entry(current, callee_method);\n@@ -1529,1 +1513,0 @@\n-\n@@ -1538,2 +1521,1 @@\n-  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  return get_resolved_entry(current, callee_method);\n@@ -1552,2 +1534,1 @@\n-  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  return get_resolved_entry(current, callee_method);\n@@ -1953,0 +1934,14 @@\n+\/\/ This is only called when CheckJNICalls is true, and only\n+\/\/ for virtual thread termination.\n+JRT_LEAF(void,  SharedRuntime::log_jni_monitor_still_held())\n+  assert(CheckJNICalls, \"Only call this when checking JNI usage\");\n+  if (log_is_enabled(Debug, jni)) {\n+    JavaThread* current = JavaThread::current();\n+    int64_t vthread_id = java_lang_Thread::thread_id(current->vthread());\n+    int64_t carrier_id = java_lang_Thread::thread_id(current->threadObj());\n+    log_debug(jni)(\"VirtualThread (tid: \" INT64_FORMAT \", carrier id: \" INT64_FORMAT\n+                   \") exiting with Objects still locked by JNI MonitorEnter.\",\n+                   vthread_id, carrier_id);\n+  }\n+JRT_END\n+\n@@ -1991,0 +1986,1 @@\n+  if (_unsafe_set_memory_ctr) tty->print_cr(\"%5u unsafe set memorys\", _unsafe_set_memory_ctr);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":32,"deletions":36,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -352,0 +352,3 @@\n+  \/\/ Issue UL warning for unlocked JNI monitor on virtual thread termination\n+  static void log_jni_monitor_still_held();\n+\n@@ -499,0 +502,1 @@\n+  static address get_resolved_entry        (JavaThread* current, methodHandle callee_method);\n@@ -545,0 +549,2 @@\n+  static uint _unsafe_set_memory_ctr;      \/\/ Slow-path includes alignment checks\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  return (cb()->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"oops\/klass.hpp\"\n@@ -43,4 +44,4 @@\n-UnsafeCopyMemory* UnsafeCopyMemory::_table                      = nullptr;\n-int UnsafeCopyMemory::_table_length                             = 0;\n-int UnsafeCopyMemory::_table_max_length                         = 0;\n-address UnsafeCopyMemory::_common_exit_stub_pc                  = nullptr;\n+UnsafeMemoryAccess* UnsafeMemoryAccess::_table                  = nullptr;\n+int UnsafeMemoryAccess::_table_length                           = 0;\n+int UnsafeMemoryAccess::_table_max_length                       = 0;\n+address UnsafeMemoryAccess::_common_exit_stub_pc                = nullptr;\n@@ -112,0 +113,2 @@\n+address StubRoutines::_unsafe_setmemory                  = nullptr;\n+\n@@ -194,0 +197,4 @@\n+address StubRoutines::_lookup_secondary_supers_table_slow_path_stub = nullptr;\n+address StubRoutines::_lookup_secondary_supers_table_stubs[Klass::SECONDARY_SUPERS_TABLE_SIZE] = { nullptr };\n+\n+\n@@ -202,3 +209,3 @@\n-void UnsafeCopyMemory::create_table(int max_size) {\n-  UnsafeCopyMemory::_table = new UnsafeCopyMemory[max_size];\n-  UnsafeCopyMemory::_table_max_length = max_size;\n+void UnsafeMemoryAccess::create_table(int max_size) {\n+  UnsafeMemoryAccess::_table = new UnsafeMemoryAccess[max_size];\n+  UnsafeMemoryAccess::_table_max_length = max_size;\n@@ -207,3 +214,3 @@\n-bool UnsafeCopyMemory::contains_pc(address pc) {\n-  for (int i = 0; i < UnsafeCopyMemory::_table_length; i++) {\n-    UnsafeCopyMemory* entry = &UnsafeCopyMemory::_table[i];\n+bool UnsafeMemoryAccess::contains_pc(address pc) {\n+  for (int i = 0; i < UnsafeMemoryAccess::_table_length; i++) {\n+    UnsafeMemoryAccess* entry = &UnsafeMemoryAccess::_table[i];\n@@ -217,3 +224,3 @@\n-address UnsafeCopyMemory::page_error_continue_pc(address pc) {\n-  for (int i = 0; i < UnsafeCopyMemory::_table_length; i++) {\n-    UnsafeCopyMemory* entry = &UnsafeCopyMemory::_table[i];\n+address UnsafeMemoryAccess::page_error_continue_pc(address pc) {\n+  for (int i = 0; i < UnsafeMemoryAccess::_table_length; i++) {\n+    UnsafeMemoryAccess* entry = &UnsafeMemoryAccess::_table[i];\n@@ -519,1 +526,1 @@\n-UnsafeCopyMemoryMark::UnsafeCopyMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc) {\n+UnsafeMemoryAccessMark::UnsafeMemoryAccessMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc) {\n@@ -525,1 +532,1 @@\n-      err_exit_pc = error_exit_pc != nullptr ? error_exit_pc : UnsafeCopyMemory::common_exit_stub_pc();\n+      err_exit_pc = error_exit_pc != nullptr ? error_exit_pc : UnsafeMemoryAccess::common_exit_stub_pc();\n@@ -528,1 +535,1 @@\n-    _ucm_entry = UnsafeCopyMemory::add_to_table(_cgen->assembler()->pc(), nullptr, err_exit_pc);\n+    _ucm_entry = UnsafeMemoryAccess::add_to_table(_cgen->assembler()->pc(), nullptr, err_exit_pc);\n@@ -532,1 +539,1 @@\n-UnsafeCopyMemoryMark::~UnsafeCopyMemoryMark() {\n+UnsafeMemoryAccessMark::~UnsafeMemoryAccessMark() {\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-class UnsafeCopyMemory : public CHeapObj<mtCode> {\n+class UnsafeMemoryAccess : public CHeapObj<mtCode> {\n@@ -86,1 +86,1 @@\n-  static UnsafeCopyMemory* _table;\n+  static UnsafeMemoryAccess* _table;\n@@ -89,1 +89,1 @@\n-  UnsafeCopyMemory() : _start_pc(nullptr), _end_pc(nullptr), _error_exit_pc(nullptr) {}\n+  UnsafeMemoryAccess() : _start_pc(nullptr), _end_pc(nullptr), _error_exit_pc(nullptr) {}\n@@ -100,3 +100,3 @@\n-  static UnsafeCopyMemory* add_to_table(address start_pc, address end_pc, address error_exit_pc) {\n-    guarantee(_table_length < _table_max_length, \"Incorrect UnsafeCopyMemory::_table_max_length\");\n-    UnsafeCopyMemory* entry = &_table[_table_length];\n+  static UnsafeMemoryAccess* add_to_table(address start_pc, address end_pc, address error_exit_pc) {\n+    guarantee(_table_length < _table_max_length, \"Incorrect UnsafeMemoryAccess::_table_max_length\");\n+    UnsafeMemoryAccess* entry = &_table[_table_length];\n@@ -116,1 +116,1 @@\n-class UnsafeCopyMemoryMark : public StackObj {\n+class UnsafeMemoryAccessMark : public StackObj {\n@@ -118,1 +118,1 @@\n-  UnsafeCopyMemory*  _ucm_entry;\n+  UnsafeMemoryAccess*  _ucm_entry;\n@@ -121,2 +121,2 @@\n-  UnsafeCopyMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc = nullptr);\n-  ~UnsafeCopyMemoryMark();\n+  UnsafeMemoryAccessMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc = nullptr);\n+  ~UnsafeMemoryAccessMark();\n@@ -196,0 +196,2 @@\n+  static address _unsafe_setmemory;\n+\n@@ -277,0 +279,3 @@\n+  static address _lookup_secondary_supers_table_stubs[];\n+  static address _lookup_secondary_supers_table_slow_path_stub;\n+\n@@ -384,0 +389,5 @@\n+  static address unsafe_setmemory()     { return _unsafe_setmemory; }\n+\n+  typedef void (*UnsafeSetMemoryStub)(const void* src, size_t count, char byte);\n+  static UnsafeSetMemoryStub UnsafeSetMemory_stub()         { return CAST_TO_FN_PTR(UnsafeSetMemoryStub,  _unsafe_setmemory); }\n+\n@@ -482,0 +492,11 @@\n+  static address lookup_secondary_supers_table_stub(u1 slot) {\n+    assert(slot < Klass::SECONDARY_SUPERS_TABLE_SIZE, \"out of bounds\");\n+    assert(_lookup_secondary_supers_table_stubs[slot] != nullptr, \"not implemented\");\n+    return _lookup_secondary_supers_table_stubs[slot];\n+  }\n+\n+  static address lookup_secondary_supers_table_slow_path_stub() {\n+    assert(_lookup_secondary_supers_table_slow_path_stub != nullptr, \"not implemented\");\n+    return _lookup_secondary_supers_table_slow_path_stub;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -836,4 +836,4 @@\n-\/\/ vm_exit() when the program calls System.exit() to return a value or when\n-\/\/ there is a serious error in VM. The two shutdown paths are not exactly\n-\/\/ the same, but they share Shutdown.shutdown() at Java level and before_exit()\n-\/\/ and VM_Exit op at VM level.\n+\/\/ vm_exit(), when the program calls System.exit() to return a value, or when\n+\/\/ there is a serious error in VM.\n+\/\/ These two separate shutdown paths are not exactly the same, but they share\n+\/\/ Shutdown.shutdown() at Java level and before_exit() and VM_Exit op at VM level.\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-  template(VirtualThreadGetCurrentLocation)       \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-  nonstatic_field(HeapBlock::Header,           _length,                                       size_t)                                \\\n+  nonstatic_field(HeapBlock::Header,           _length,                                       uint32_t)                              \\\n@@ -553,1 +553,1 @@\n-  nonstatic_field(CodeBlob,                    _header_size,                                  int)                                   \\\n+  nonstatic_field(CodeBlob,                    _header_size,                                  u2)                                    \\\n@@ -557,1 +557,1 @@\n-  nonstatic_field(CodeBlob,                    _frame_complete_offset,                        int)                                   \\\n+  nonstatic_field(CodeBlob,                    _frame_complete_offset,                        int16_t)                               \\\n@@ -578,3 +578,2 @@\n-  nonstatic_field(nmethod,                     _consts_offset,                                int)                                   \\\n-  nonstatic_field(nmethod,                     _oops_offset,                                  int)                                   \\\n-  nonstatic_field(nmethod,                     _metadata_offset,                              int)                                   \\\n+  nonstatic_field(nmethod,                     _metadata_offset,                              u2)                                    \\\n+  nonstatic_field(nmethod,                     _scopes_pcs_offset,                            u2)                                    \\\n@@ -582,2 +581,1 @@\n-  nonstatic_field(nmethod,                     _scopes_pcs_offset,                            int)                                   \\\n-  nonstatic_field(nmethod,                     _dependencies_offset,                          int)                                   \\\n+  nonstatic_field(nmethod,                     _dependencies_offset,                          u2)                                    \\\n@@ -586,3 +584,2 @@\n-  nonstatic_field(nmethod,                     _nmethod_end_offset,                           int)                                   \\\n-  nonstatic_field(nmethod,                     _entry_point,                                  address)                               \\\n-  nonstatic_field(nmethod,                     _verified_entry_point,                         address)                               \\\n+  nonstatic_field(nmethod,                     _entry_offset,                                 u2)                                    \\\n+  nonstatic_field(nmethod,                     _verified_entry_offset,                        u2)                                    \\\n@@ -1134,0 +1131,1 @@\n+  declare_integer_type(int16_t)                                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-bool VMThread::handshake_alot() {\n+bool VMThread::handshake_or_safepoint_alot() {\n@@ -314,1 +314,1 @@\n-  if (!HandshakeALot) {\n+  if (!HandshakeALot && !SafepointALot) {\n@@ -317,1 +317,1 @@\n-  static jlong last_halot_ms = 0;\n+  static jlong last_alot_ms = 0;\n@@ -319,2 +319,3 @@\n-  \/\/ If only HandshakeALot is set, but GuaranteedSafepointInterval is 0,\n-  \/\/ we emit a handshake if it's been more than a second since the last one.\n+  \/\/ If HandshakeALot or SafepointALot are set, but GuaranteedSafepointInterval is explicitly\n+  \/\/ set to 0 on the command line, we emit the operation if it's been more than a second\n+  \/\/ since the last one.\n@@ -322,1 +323,1 @@\n-  jlong deadline_ms = interval + last_halot_ms;\n+  jlong deadline_ms = interval + last_alot_ms;\n@@ -324,1 +325,1 @@\n-    last_halot_ms = now_ms;\n+    last_alot_ms = now_ms;\n@@ -330,15 +331,0 @@\n-void VMThread::setup_periodic_safepoint_if_needed() {\n-  assert(_cur_vm_operation  == nullptr, \"Already have an op\");\n-  assert(_next_vm_operation == nullptr, \"Already have an op\");\n-  \/\/ Check for a cleanup before SafepointALot to keep stats correct.\n-  jlong interval_ms = SafepointTracing::time_since_last_safepoint_ms();\n-  bool max_time_exceeded = GuaranteedSafepointInterval != 0 &&\n-                           (interval_ms >= GuaranteedSafepointInterval);\n-  if (!max_time_exceeded) {\n-    return;\n-  }\n-  if (SafepointALot) {\n-    _next_vm_operation = &safepointALot_op;\n-  }\n-}\n-\n@@ -468,2 +454,2 @@\n-    if (handshake_alot()) {\n-      {\n+    if (handshake_or_safepoint_alot()) {\n+      if (HandshakeALot) {\n@@ -478,0 +464,4 @@\n+      if (SafepointALot) {\n+        _next_vm_operation = &safepointALot_op;\n+        return;\n+      }\n@@ -482,5 +472,0 @@\n-    setup_periodic_safepoint_if_needed();\n-    if (_next_vm_operation != nullptr) {\n-      return;\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":14,"deletions":29,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,2 +73,1 @@\n-  static bool handshake_alot();\n-  static void setup_periodic_safepoint_if_needed();\n+  static bool handshake_or_safepoint_alot();\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Google and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-#if defined(TARGET_COMPILER_gcc) || defined(TARGET_COMPILER_xlc)\n+#if defined(TARGET_COMPILER_gcc)\n","filename":"src\/hotspot\/share\/utilities\/byteswap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_COMPILERWARNINGS_XLC_HPP\n-#define SHARE_UTILITIES_COMPILERWARNINGS_XLC_HPP\n-\n-\/\/ Nothing here yet.\n-\n-#endif \/\/ SHARE_UTILITIES_COMPILERWARNINGS_XLC_HPP\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_xlc.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,2 +214,2 @@\n-  address dst = (address) to;\n-  uintptr_t bits = (uintptr_t) to | (uintptr_t) size;\n+  address dst = (address)to;\n+  uintptr_t bits = (uintptr_t)to | (uintptr_t)size;\n@@ -217,1 +217,1 @@\n-    jlong fill = (julong)( (jubyte)value ); \/\/ zero-extend\n+    jlong fill = (julong)((jubyte)value);  \/\/ zero-extend\n@@ -223,1 +223,1 @@\n-    \/\/Copy::fill_to_jlongs_atomic((jlong*) dst, size \/ sizeof(jlong));\n+    \/\/ Copy::fill_to_jlongs_atomic((jlong*) dst, size \/ sizeof(jlong));\n@@ -228,1 +228,1 @@\n-    jint fill = (juint)( (jubyte)value ); \/\/ zero-extend\n+    jint fill = (juint)((jubyte)value);  \/\/ zero-extend\n@@ -233,1 +233,1 @@\n-    \/\/Copy::fill_to_jints_atomic((jint*) dst, size \/ sizeof(jint));\n+    \/\/ Copy::fill_to_jints_atomic((jint*) dst, size \/ sizeof(jint));\n@@ -238,1 +238,1 @@\n-    jshort fill = (jushort)( (jubyte)value ); \/\/ zero-extend\n+    jshort fill = (jushort)((jubyte)value);  \/\/ zero-extend\n@@ -240,1 +240,1 @@\n-    \/\/Copy::fill_to_jshorts_atomic((jshort*) dst, size \/ sizeof(jshort));\n+    \/\/ Copy::fill_to_jshorts_atomic((jshort*) dst, size \/ sizeof(jshort));\n@@ -247,3 +247,4 @@\n-    \/\/ This code is used by Unsafe and may hit the next page after truncation of mapped memory.\n-    \/\/ Therefore, we use volatile to prevent compilers from replacing the loop by memset which\n-    \/\/ may not trigger SIGBUS as needed (observed on Alpine Linux x86_64)\n+    \/\/ This code is used by Unsafe and may hit the next page after truncation\n+    \/\/ of mapped memory. Therefore, we use volatile to prevent compilers from\n+    \/\/ replacing the loop by memset which may not trigger SIGBUS as needed\n+    \/\/ (observed on Alpine Linux x86_64)\n","filename":"src\/hotspot\/share\/utilities\/copy.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,31 +126,0 @@\n-\/*****************************************************************************\n- * IBM XL C\/C++\n- *****************************************************************************\/\n-#elif defined(TARGET_COMPILER_xlc)\n-\n-#include <builtins.h>\n-\n-template <typename T> struct CountLeadingZerosImpl<T, 1> {\n-  static unsigned doit(T v) {\n-    return __cntlz4((uint32_t)v & 0xFF) - 24u;\n-  }\n-};\n-\n-template <typename T> struct CountLeadingZerosImpl<T, 2> {\n-  static unsigned doit(T v) {\n-    return __cntlz4((uint32_t)v & 0xFFFF) - 16u;\n-  }\n-};\n-\n-template <typename T> struct CountLeadingZerosImpl<T, 4> {\n-  static unsigned doit(T v) {\n-    return __cntlz4(v);\n-  }\n-};\n-\n-template <typename T> struct CountLeadingZerosImpl<T, 8> {\n-  static unsigned doit(T v) {\n-    return __cntlz8(v);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/utilities\/count_leading_zeros.hpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,15 +87,0 @@\n-\/*****************************************************************************\n- * IBM XL C\/C++\n- *****************************************************************************\/\n-#elif defined(TARGET_COMPILER_xlc)\n-\n-#include <builtins.h>\n-\n-inline unsigned count_trailing_zeros_32(uint32_t x) {\n-  return __cnttz4(x);\n-}\n-\n-inline unsigned count_trailing_zeros_64(uint64_t x) {\n-  return __cnttz8(x);\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/count_trailing_zeros.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-#if defined(TARGET_COMPILER_gcc) || defined(TARGET_COMPILER_xlc)\n+#if defined(TARGET_COMPILER_gcc)\n","filename":"src\/hotspot\/share\/utilities\/debug.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+StringEventLog* Events::_memprotect_messages = nullptr;\n+StringEventLog* Events::_nmethod_flush_messages = nullptr;\n@@ -100,0 +102,2 @@\n+    _nmethod_flush_messages = new StringEventLog(\"Nmethod flushes\", \"nmethodflushes\");\n+    _memprotect_messages = new StringEventLog(\"Memory protections\", \"memprotects\");\n","filename":"src\/hotspot\/share\/utilities\/events.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,0 +223,6 @@\n+  \/\/ A log for memory protection related messages\n+  static StringEventLog* _memprotect_messages;\n+\n+  \/\/ A log for nmethod flush operations\n+  static StringEventLog* _nmethod_flush_messages;\n+\n@@ -262,0 +268,4 @@\n+  static void log_memprotect(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);\n+\n+  static void log_nmethod_flush(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);\n+\n@@ -293,0 +303,18 @@\n+inline void Events::log_memprotect(Thread* thread, const char* format, ...) {\n+  if (LogEvents && _memprotect_messages != nullptr) {\n+    va_list ap;\n+    va_start(ap, format);\n+    _memprotect_messages->logv(thread, format, ap);\n+    va_end(ap);\n+  }\n+}\n+\n+inline void Events::log_nmethod_flush(Thread* thread, const char* format, ...) {\n+  if (LogEvents && _nmethod_flush_messages != nullptr) {\n+    va_list ap;\n+    va_start(ap, format);\n+    _nmethod_flush_messages->logv(thread, format, ap);\n+    va_end(ap);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-  Symbol* detail_message = java_lang_Throwable::detail_message(exception());\n+  const char* detail_message = java_lang_Throwable::message_as_utf8(exception());\n@@ -573,1 +573,1 @@\n-                         detail_message->as_C_string(),\n+                         detail_message,\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,0 +153,5 @@\n+#ifdef _LP64\n+#define UINTX_FORMAT_X_0         \"0x%016\"     PRIxPTR\n+#else\n+#define UINTX_FORMAT_X_0         \"0x%08\"      PRIxPTR\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,8 @@\n+\/\/ In stdlib.h on AIX malloc is defined as a macro causing\n+\/\/ compiler errors when resolving them in different depths as it\n+\/\/ happens in the log tags. This avoids the macro.\n+#if (defined(__VEC__) || defined(__AIXVEC)) && defined(AIX) \\\n+    && defined(__open_xl_version__) && __open_xl_version__ >= 17\n+  #undef malloc\n+  extern void *malloc(size_t) asm(\"vec_malloc\");\n+#endif\n@@ -53,1 +61,1 @@\n-#if defined(LINUX) || defined(_ALLBSD_SOURCE)\n+#if defined(LINUX) || defined(_ALLBSD_SOURCE) || defined(_AIX)\n@@ -86,1 +94,1 @@\n-#elif defined(LINUX) || defined(_ALLBSD_SOURCE)\n+#elif defined(LINUX) || defined(_ALLBSD_SOURCE) || defined(_AIX)\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_GLOBALDEFINITIONS_XLC_HPP\n-#define SHARE_UTILITIES_GLOBALDEFINITIONS_XLC_HPP\n-\n-#include \"jni.h\"\n-\n-\/\/ This file holds compiler-dependent includes,\n-\/\/ globally used constants & types, class (forward)\n-\/\/ declarations and a few frequently used utility functions.\n-\n-#include <alloca.h>\n-#include <ctype.h>\n-#include <string.h>\n-#include <stdarg.h>\n-#include <stddef.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-\/\/ In stdlib.h on AIX malloc is defined as a macro causing\n-\/\/ compiler errors when resolving them in different depths as it\n-\/\/ happens in the log tags. This avoids the macro.\n-#if (defined(__VEC__) || defined(__AIXVEC)) && defined(AIX) \\\n-    && defined(__open_xl_version__) && __open_xl_version__ >= 17\n-  #undef malloc\n-  extern void *malloc(size_t) asm(\"vec_malloc\");\n-#endif\n-\n-#include <wchar.h>\n-\n-#include <math.h>\n-#include <time.h>\n-#include <fcntl.h>\n-#include <dlfcn.h>\n-#include <pthread.h>\n-\n-#include <limits.h>\n-#include <errno.h>\n-\n-#include <stdint.h>\n-\n-#if defined(__open_xl_version__)\n-  #if __open_xl_version__ < 17\n-  #error \"open xlc < 17 not supported\"\n-  #endif\n-#else\n-  #error \"xlc version not supported, macro __open_xl_version__ not found\"\n-#endif\n-\n-#ifndef _AIX\n-#error \"missing AIX-specific definition _AIX\"\n-#endif\n-\n-\/\/ Use XLC compiler builtins instead of inline assembler\n-#define USE_XLC_BUILTINS\n-\n-#ifdef USE_XLC_BUILTINS\n-#include <builtins.h>\n-\/\/ XLC V10 and higher provide the prototype for __dcbtst (void *);\n-#endif \/\/ USE_XLC_BUILTINS\n-\n-\/\/ NULL vs NULL_WORD:\n-\/\/ Some platform\/tool-chain combinations can't assign NULL to an integer\n-\/\/ type so we define NULL_WORD to use in those contexts.\n-#define NULL_WORD  0L\n-\n-\/\/ checking for nanness\n-inline int g_isnan(float  f) { return isnan(f); }\n-inline int g_isnan(double f) { return isnan(f); }\n-\n-\/\/ Checking for finiteness\n-inline int g_isfinite(jfloat  f)                 { return finite(f); }\n-inline int g_isfinite(jdouble f)                 { return finite(f); }\n-\n-\/\/ Formatting.\n-#ifdef _LP64\n-#define FORMAT64_MODIFIER \"l\"\n-#else \/\/ !_LP64\n-#define FORMAT64_MODIFIER \"ll\"\n-#endif \/\/ _LP64\n-\n-\/\/ Cannot use xlc's offsetof as implementation of hotspot's\n-\/\/ offset_of(), because xlc warns about applying offsetof() to non-POD\n-\/\/ object and xlc cannot compile the expression offsetof(DataLayout,\n-\/\/ _cells[index]) in DataLayout::cell_offset() .  Therefore we define\n-\/\/ offset_of as it is defined for gcc.\n-#define offset_of(klass,field) (size_t)((intx)&(((klass*)16)->field) - 16)\n-\n-#define THREAD_LOCAL __thread\n-\n-\/\/ Inlining support\n-\/\/\n-\/\/ Be aware that for function\/method declarations, xlC only supports the following\n-\/\/ syntax (i.e. the attribute must be placed AFTER the function\/method declarator):\n-\/\/\n-\/\/   void* operator new(size_t size) throw() NOINLINE;\n-\/\/\n-\/\/ For function\/method definitions, the more common placement BEFORE the\n-\/\/ function\/method declarator seems to be supported as well:\n-\/\/\n-\/\/   NOINLINE void* CHeapObj<F>::operator new(size_t size) throw() {...}\n-\n-#define NOINLINE     __attribute__((__noinline__))\n-#define ALWAYSINLINE inline __attribute__((__always_inline__))\n-\n-#endif \/\/ SHARE_UTILITIES_GLOBALDEFINITIONS_XLC_HPP\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_xlc.hpp","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_ROTATE_BITS_HPP\n+#define SHARE_UTILITIES_ROTATE_BITS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+inline uint32_t rotate_right_32(uint32_t x, int distance) {\n+  distance = distance & 0x1F;\n+  if (distance > 0) {\n+    return (x >> distance) | (x << (32 - distance));\n+  } else {\n+    return x;\n+  }\n+}\n+\n+inline uint64_t rotate_right_64(uint64_t x, int distance) {\n+  distance = distance & 0x3F;\n+  if (distance > 0) {\n+    return (x >> distance) | (x << (64 - distance));\n+  } else {\n+    return x;\n+  }\n+}\n+\n+template<typename T,\n+    ENABLE_IF(std::is_integral<T>::value),\n+ENABLE_IF(sizeof(T) <= sizeof(uint64_t))>\n+inline T rotate_right(T x, int dist) {\n+  return (sizeof(x) <= sizeof(uint32_t)) ?\n+         rotate_right_32(static_cast<uint32_t>(x), dist) :\n+         rotate_right_64(static_cast<uint64_t>(x), dist);\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_ROTATE_BITS_HPP\n","filename":"src\/hotspot\/share\/utilities\/rotate_bits.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+enum class CompileCommandEnum : int;\n","filename":"src\/hotspot\/share\/utilities\/vmEnums.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package jdk.internal.loader;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+\n+class ClassLoaderHelper {\n+\n+    private ClassLoaderHelper() {}\n+\n+    \/**\n+     * Shared objects may be loaded from .a archive object on AIX and .so may not exist.\n+     * This method returns false so that loading of shared library continues if\n+     * libname.so is not present.\n+     *\/\n+    static boolean loadLibraryOnlyIfPresent() {\n+        return false;\n+    }\n+\n+    \/**\n+     * AIX implementation of JVM_LoadLibrary handles the alternate path name mapping.\n+     * If loading of the given library name with \".so\" suffix fails, it will attempt\n+     * to load the library of the same name with \".a\" suffix as the alternate name.\n+     * This method simply returns null.  It could implement the alternate name\n+     * converting \".so\" with \".a\" suffix but redundant.\n+     *\/\n+    static File mapAlternativeName(File lib) {\n+        return null;\n+    }\n+\n+    \/**\n+     * Parse a PATH env variable.\n+     *\n+     * Empty elements will be replaced by dot.\n+     *\/\n+    static String[] parsePath(String ldPath) {\n+        char ps = File.pathSeparatorChar;\n+        ArrayList<String> paths = new ArrayList<>();\n+        int pathStart = 0;\n+        int pathEnd;\n+        while ((pathEnd = ldPath.indexOf(ps, pathStart)) >= 0) {\n+            paths.add((pathStart < pathEnd) ?\n+                    ldPath.substring(pathStart, pathEnd) : \".\");\n+            pathStart = pathEnd + 1;\n+        }\n+        int ldLen = ldPath.length();\n+        paths.add((pathStart < ldLen) ?\n+                ldPath.substring(pathStart, ldLen) : \".\");\n+        return paths.toArray(new String[paths.size()]);\n+    }\n+}\n+\n","filename":"src\/java.base\/aix\/classes\/jdk\/internal\/loader\/ClassLoaderHelper.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-                long comp = Blocker.begin(blocking);\n+                boolean attempted = Blocker.begin(blocking);\n@@ -123,1 +123,1 @@\n-                    Blocker.end(comp);\n+                    Blocker.end(attempted);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-\/**\n+\/*\n","filename":"src\/java.base\/macosx\/classes\/apple\/security\/AppleProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Enumeration;\n+import java.io.IOException;\n+\n@@ -40,5 +45,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Enumeration;\n-import java.io.IOException;\n-\n","filename":"src\/java.base\/macosx\/classes\/java\/net\/DefaultInterface.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-                long comp = Blocker.begin(blocking);\n+                boolean attempted = Blocker.begin(blocking);\n@@ -127,1 +127,1 @@\n-                    Blocker.end(comp);\n+                    Blocker.end(attempted);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueueSelectorImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.misc.Blocker;\n-\n@@ -72,7 +70,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return clonefile0(srcBuffer.address(), dstBuffer.address(),\n-                                  flags);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return clonefile0(srcBuffer.address(), dstBuffer.address(), flags);\n@@ -93,7 +85,2 @@\n-            long comp = Blocker.begin();\n-            try {\n-                setattrlist0(buffer.address(), commonattr, modTime, accTime,\n-                             createTime, options);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            setattrlist0(buffer.address(), commonattr, modTime, accTime,\n+                         createTime, options);\n@@ -115,7 +102,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            fsetattrlist0(fd, commonattr, modTime, accTime,\n-                          createTime, options);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        fsetattrlist0(fd, commonattr, modTime, accTime, createTime, options);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-\/**\n+\/*\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +210,1 @@\n-        long comp = Blocker.begin();\n+        boolean attempted = Blocker.begin();\n@@ -214,1 +214,1 @@\n-            Blocker.end(comp);\n+            Blocker.end(attempted);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -213,6 +212,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            open0(name);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        open0(name);\n@@ -231,6 +225,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return read0();\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return read0();\n@@ -263,6 +252,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return readBytes(b, 0, b.length);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return readBytes(b, 0, b.length);\n@@ -287,6 +271,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return readBytes(b, off, len);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return readBytes(b, off, len);\n@@ -399,6 +378,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return length0();\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return length0();\n@@ -409,6 +383,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return position0();\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return position0();\n@@ -444,6 +413,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return skip0(n);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return skip0(n);\n@@ -473,6 +437,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return available0();\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return available0();\n@@ -569,2 +528,2 @@\n-                    this.channel = fc = FileChannelImpl.open(fd, path, true,\n-                        false, false, this);\n+                    fc = FileChannelImpl.open(fd, path, true, false, false, false, this);\n+                    this.channel = fc;\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":11,"deletions":52,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -289,6 +288,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            open0(name, append);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        open0(name, append);\n@@ -316,6 +310,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            write(b, append);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        write(b, append);\n@@ -346,6 +335,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            writeBytes(b, 0, b.length, append);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        writeBytes(b, 0, b.length, append);\n@@ -367,6 +351,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            writeBytes(b, off, len, append);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        writeBytes(b, off, len, append);\n@@ -463,2 +442,2 @@\n-                    this.channel = fc = FileChannelImpl.open(fd, path, false,\n-                        true, false, this);\n+                    fc = FileChannelImpl.open(fd, path, false, true, false, false, this);\n+                    this.channel = fc;\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":7,"deletions":28,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1234,3 +1234,0 @@\n-    \/**\n-     * @serialData \"permissions\" field (a Vector containing the FilePermissions).\n-     *\/\n@@ -1240,0 +1237,1 @@\n+     * @serialData \"permissions\" field (a Vector containing the FilePermissions).\n","filename":"src\/java.base\/share\/classes\/java\/io\/FilePermission.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-    \/******************************************************\/\n+    \/* ****************************************************\/\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamConstants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+    private final boolean sync;  \/\/ O_SYNC or O_DSYNC\n@@ -232,0 +233,1 @@\n+        boolean sync = false;\n@@ -238,1 +240,1 @@\n-                if (mode.equals(\"rws\"))\n+                if (mode.equals(\"rws\")) {\n@@ -240,1 +242,2 @@\n-                else if (mode.equals(\"rwd\"))\n+                    sync = true;\n+                } else if (mode.equals(\"rwd\")) {\n@@ -242,1 +245,2 @@\n-                else\n+                    sync = true;\n+                } else\n@@ -247,0 +251,1 @@\n+        this.sync = sync;\n@@ -311,2 +316,2 @@\n-                    this.channel = fc = FileChannelImpl.open(fd, path, true,\n-                        rw, false, this);\n+                    fc = FileChannelImpl.open(fd, path, true, rw, sync, false, this);\n+                    this.channel = fc;\n@@ -353,6 +358,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            open0(name, mode);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        open0(name, mode);\n@@ -379,6 +379,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return read0();\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return read0();\n@@ -397,6 +392,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return readBytes0(b, off, len);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return readBytes0(b, off, len);\n@@ -550,1 +540,1 @@\n-        long comp = Blocker.begin();\n+        boolean attempted = Blocker.begin(sync);\n@@ -554,1 +544,1 @@\n-            Blocker.end(comp);\n+            Blocker.end(attempted);\n@@ -569,1 +559,1 @@\n-        long comp = Blocker.begin();\n+        boolean attempted = Blocker.begin(sync);\n@@ -573,1 +563,1 @@\n-            Blocker.end(comp);\n+            Blocker.end(attempted);\n@@ -633,6 +623,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            seek0(pos);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        seek0(pos);\n@@ -650,6 +635,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return length0();\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return length0();\n@@ -687,6 +667,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            setLength0(newLength);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        setLength0(newLength);\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":20,"deletions":45,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,1 +373,7 @@\n-        long comp = Blocker.begin();\n+        if (!Thread.currentThread().isVirtual()) {\n+            wait0(timeoutMillis);\n+            return;\n+        }\n+\n+        \/\/ virtual thread waiting\n+        boolean attempted = Blocker.begin();\n@@ -377,3 +383,2 @@\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual())\n-                thread.getAndClearInterrupt();\n+            \/\/ virtual thread's interrupt status needs to be cleared\n+            Thread.currentThread().getAndClearInterrupt();\n@@ -382,1 +387,1 @@\n-            Blocker.end(comp);\n+            Blocker.end(attempted);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Blocker;\n@@ -842,0 +843,69 @@\n+\n+        @Override\n+        public int read() throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                return super.read();\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+\n+        @Override\n+        public int read(byte[] b) throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                return super.read(b);\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                return super.read(b, off, len);\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * An output stream for a subprocess pipe.\n+     *\/\n+    static class PipeOutputStream extends FileOutputStream {\n+        PipeOutputStream(FileDescriptor fd) {\n+            super(fd);\n+        }\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                super.write(b);\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+\n+        @Override\n+        public void write(byte[] b) throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                super.write(b);\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                super.write(b, off, len);\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.util.FormatConcatItem;\n@@ -130,14 +128,0 @@\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static long mix(long lengthCoder, FormatConcatItem value) {\n-        lengthCoder = value.mix(lengthCoder);\n-        return checkOverflow(lengthCoder);\n-    }\n-\n@@ -347,42 +331,0 @@\n-    \/**\n-     * Prepends the stringly representation of FormatConcatItem value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      String value to encode\n-     * @return           updated index (coder value retained)\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static long prepend(long indexCoder, byte[] buf, FormatConcatItem value) {\n-        try {\n-            return value.prepend(indexCoder, buf);\n-        } catch (Error ex) {\n-            throw ex;\n-        } catch (Throwable ex) {\n-            throw new AssertionError(\"FormatConcatItem prepend error\", ex);\n-        }\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static long prepend(long indexCoder, byte[] buf,\n-                        FormatConcatItem value, String prefix) {\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n-    }\n-\n@@ -520,65 +462,0 @@\n-    \/*\n-     * Initialize after phase1.\n-     *\/\n-    private static class LateInit {\n-        static final MethodHandle GETCHAR_LATIN1_MH;\n-\n-        static final MethodHandle GETCHAR_UTF16_MH;\n-\n-        static final MethodHandle PUTCHAR_LATIN1_MH;\n-\n-        static final MethodHandle PUTCHAR_UTF16_MH;\n-\n-        static {\n-            MethodType getCharMT =\n-                MethodType.methodType(char.class,\n-                        byte[].class, int.class);\n-            MethodType putCharMT =\n-                MethodType.methodType(void.class,\n-                        byte[].class, int.class, int.class);\n-            GETCHAR_LATIN1_MH = lookupStatic(\"getCharLatin1\", getCharMT);\n-            GETCHAR_UTF16_MH = lookupStatic(\"getCharUTF16\", getCharMT);\n-            PUTCHAR_LATIN1_MH = lookupStatic(\"putCharLatin1\", putCharMT);\n-            PUTCHAR_UTF16_MH = lookupStatic(\"putCharUTF16\", putCharMT);\n-        }\n-\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static char getCharLatin1(byte[] buffer, int index) {\n-        return (char)buffer[index];\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static char getCharUTF16(byte[] buffer, int index) {\n-        return StringUTF16.getChar(buffer, index);\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static void putCharLatin1(byte[] buffer, int index, int ch) {\n-        buffer[index] = (byte)ch;\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static void putCharUTF16(byte[] buffer, int index, int ch) {\n-        StringUTF16.putChar(buffer, index, ch);\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static MethodHandle selectGetChar(long indexCoder) {\n-        return indexCoder < UTF16 ? LateInit.GETCHAR_LATIN1_MH :\n-                                    LateInit.GETCHAR_UTF16_MH;\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static MethodHandle selectPutChar(long indexCoder) {\n-        return indexCoder < UTF16 ? LateInit.PUTCHAR_LATIN1_MH :\n-                                    LateInit.PUTCHAR_UTF16_MH;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -1,622 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.FormatProcessor;\n-import java.util.function.Function;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.access.JavaTemplateAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * {@link StringTemplate} is the run-time representation of a string template or\n- * text block template in a template expression.\n- * <p>\n- * In the source code of a Java program, a string template or text block template\n- * contains an interleaved succession of <em>fragment literals<\/em> and <em>embedded\n- * expressions<\/em>. The {@link StringTemplate#fragments()} method returns the\n- * fragment literals, and the {@link StringTemplate#values()} method returns the\n- * results of evaluating the embedded expressions. {@link StringTemplate} does not\n- * provide access to the source code of the embedded expressions themselves; it is\n- * not a compile-time representation of a string template or text block template.\n- * <p>\n- * {@link StringTemplate} is primarily used in conjunction with a template processor\n- * to produce a string or other meaningful value. Evaluation of a template expression\n- * first produces an instance of {@link StringTemplate}, representing the right hand side\n- * of the template expression, and then passes the instance to the template processor\n- * given by the template expression.\n- * <p>\n- * For example, the following code contains a template expression that uses the template\n- * processor {@code RAW}, which simply yields the {@link StringTemplate} passed to it:\n- * {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n- * List<String> fragments = st.fragments();\n- * List<Object> values = st.values();\n- * }\n- * {@code fragments} will be equivalent to {@code List.of(\"\", \" + \", \" = \", \"\")},\n- * which includes the empty first and last fragments. {@code values} will be the\n- * equivalent of {@code List.of(10, 20, 30)}.\n- * <p>\n- * The following code contains a template expression with the same template but with a\n- * different template processor, {@code STR}:\n- * {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * String s = STR.\"\\{x} + \\{y} = \\{x + y}\";\n- * }\n- * When the template expression is evaluated, an instance of {@link StringTemplate} is\n- * produced that returns the same lists from {@link StringTemplate#fragments()} and\n- * {@link StringTemplate#values()} as shown above. The {@link StringTemplate#STR} template\n- * processor uses these lists to yield an interpolated string. The value of {@code s} will\n- * be equivalent to {@code \"10 + 20 = 30\"}.\n- * <p>\n- * The {@code interpolate()} method provides a direct way to perform string interpolation\n- * of a {@link StringTemplate}. Template processors can use the following code pattern:\n- * {@snippet :\n- * List<String> fragments = st.fragments();\n- * List<Object> values    = st.values();\n- * ... check or manipulate the fragments and\/or values ...\n- * String result = StringTemplate.interpolate(fragments, values);\n- * }\n- * The {@link StringTemplate#process(Processor)} method, in conjunction with\n- * the {@link StringTemplate#RAW} processor, may be used to defer processing of a\n- * {@link StringTemplate}.\n- * {@snippet :\n- * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n- * ...other steps...\n- * String result = st.process(STR);\n- * }\n- * The factory methods {@link StringTemplate#of(String)} and\n- * {@link StringTemplate#of(List, List)} can be used to construct a {@link StringTemplate}.\n- *\n- * @see Processor\n- * @see java.util.FormatProcessor\n- *\n- * @implNote Implementations of {@link StringTemplate} must minimally implement the\n- * methods {@link StringTemplate#fragments()} and {@link StringTemplate#values()}.\n- * Instances of {@link StringTemplate} are considered immutable. To preserve the\n- * semantics of string templates and text block templates, the list returned by\n- * {@link StringTemplate#fragments()} must be one element larger than the list returned\n- * by {@link StringTemplate#values()}.\n- *\n- * @since 21\n- *\n- * @jls 15.8.6 Process Template Expressions\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-public interface StringTemplate {\n-    \/**\n-     * Returns a list of fragment literals for this {@link StringTemplate}.\n-     * The fragment literals are the character sequences preceding each of the embedded\n-     * expressions in source code, plus the character sequence following the last\n-     * embedded expression. Such character sequences may be zero-length if an embedded\n-     * expression appears at the beginning or end of a template, or if two embedded\n-     * expressions are directly adjacent in a template.\n-     * In the example: {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * List<String> fragments = st.fragments(); \/\/ @highlight substring=\"fragments()\"\n-     * }\n-     * {@code fragments} will be equivalent to\n-     * {@code List.of(\"The student \", \" is in \", \"'s classroom.\")}\n-     *\n-     * @return list of string fragments\n-     *\n-     * @implSpec the list returned is immutable\n-     *\/\n-    List<String> fragments();\n-\n-    \/**\n-     * Returns a list of embedded expression results for this {@link StringTemplate}.\n-     * In the example:\n-     * {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * List<Object> values = st.values(); \/\/ @highlight substring=\"values()\"\n-     * }\n-     * {@code values} will be equivalent to {@code List.of(student, teacher)}\n-     *\n-     * @return list of expression values\n-     *\n-     * @implSpec the list returned is immutable\n-     *\/\n-    List<Object> values();\n-\n-    \/**\n-     * Returns the string interpolation of the fragments and values for this\n-     * {@link StringTemplate}.\n-     * @apiNote For better visibility and when practical, it is recommended to use the\n-     * {@link StringTemplate#STR} processor instead of invoking the\n-     * {@link StringTemplate#interpolate()} method.\n-     * {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * String result = st.interpolate(); \/\/ @highlight substring=\"interpolate()\"\n-     * }\n-     * In the above example, the value of  {@code result} will be\n-     * {@code \"The student Mary is in Johnson's classroom.\"}. This is\n-     * produced by the interleaving concatenation of fragments and values from the supplied\n-     * {@link StringTemplate}. To accommodate concatenation, values are converted to strings\n-     * as if invoking {@link String#valueOf(Object)}.\n-     *\n-     * @return interpolation of this {@link StringTemplate}\n-     *\n-     * @implSpec The default implementation returns the result of invoking\n-     * {@code StringTemplate.interpolate(this.fragments(), this.values())}.\n-     *\/\n-    default String interpolate() {\n-        return StringTemplate.interpolate(fragments(), values());\n-    }\n-\n-    \/**\n-     * Returns the result of applying the specified processor to this {@link StringTemplate}.\n-     * This method can be used as an alternative to string template expressions. For example,\n-     * {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * String result1 = STR.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * String result2 = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\".process(STR); \/\/ @highlight substring=\"process\"\n-     * }\n-     * Produces an equivalent result for both {@code result1} and {@code result2}.\n-     *\n-     * @param processor the {@link Processor} instance to process\n-     *\n-     * @param <R>  Processor's process result type.\n-     * @param <E>  Exception thrown type.\n-     *\n-     * @return constructed object of type {@code R}\n-     *\n-     * @throws E exception thrown by the template processor when validation fails\n-     * @throws NullPointerException if processor is null\n-     *\n-     * @implSpec The default implementation returns the result of invoking\n-     * {@code processor.process(this)}. If the invocation throws an exception that\n-     * exception is forwarded to the caller.\n-     *\/\n-    default <R, E extends Throwable> R\n-    process(Processor<? extends R, ? extends E> processor) throws E {\n-        Objects.requireNonNull(processor, \"processor should not be null\");\n-\n-        return processor.process(this);\n-    }\n-\n-    \/**\n-     * Produces a diagnostic string that describes the fragments and values of the supplied\n-     * {@link StringTemplate}.\n-     *\n-     * @param stringTemplate  the {@link StringTemplate} to represent\n-     *\n-     * @return diagnostic string representing the supplied string template\n-     *\n-     * @throws NullPointerException if stringTemplate is null\n-     *\/\n-    static String toString(StringTemplate stringTemplate) {\n-        Objects.requireNonNull(stringTemplate, \"stringTemplate should not be null\");\n-        return \"StringTemplate{ fragments = [ \\\"\" +\n-                String.join(\"\\\", \\\"\", stringTemplate.fragments()) +\n-                \"\\\" ], values = \" +\n-                stringTemplate.values() +\n-                \" }\";\n-    }\n-\n-    \/**\n-     * Returns a {@link StringTemplate} as if constructed by invoking\n-     * {@code StringTemplate.of(List.of(string), List.of())}. That is, a {@link StringTemplate}\n-     * with one fragment and no values.\n-     *\n-     * @param string  single string fragment\n-     *\n-     * @return StringTemplate composed from string\n-     *\n-     * @throws NullPointerException if string is null\n-     *\/\n-    static StringTemplate of(String string) {\n-        Objects.requireNonNull(string, \"string must not be null\");\n-        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-        return JTA.of(List.of(string), List.of());\n-    }\n-\n-    \/**\n-     * Returns a StringTemplate with the given fragments and values.\n-     *\n-     * @implSpec The {@code fragments} list size must be one more that the\n-     * {@code values} list size.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    list of expression values\n-     *\n-     * @return StringTemplate composed from string\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n-     *\n-     * @implNote Contents of both lists are copied to construct immutable lists.\n-     *\/\n-    static StringTemplate of(List<String> fragments, List<?> values) {\n-        Objects.requireNonNull(fragments, \"fragments must not be null\");\n-        Objects.requireNonNull(values, \"values must not be null\");\n-        if (values.size() + 1 != fragments.size()) {\n-            throw new IllegalArgumentException(\n-                    \"fragments list size is not one more than values list size\");\n-        }\n-        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-        return JTA.of(fragments, values);\n-    }\n-\n-    \/**\n-     * Creates a string that interleaves the elements of values between the\n-     * elements of fragments. To accommodate interpolation, values are converted to strings\n-     * as if invoking {@link String#valueOf(Object)}.\n-     *\n-     * @param fragments  list of String fragments\n-     * @param values     list of expression values\n-     *\n-     * @return String interpolation of fragments and values\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException fragments or values is null or if any of the fragments is null\n-     *\/\n-    static String interpolate(List<String> fragments, List<?> values) {\n-        Objects.requireNonNull(fragments, \"fragments must not be null\");\n-        Objects.requireNonNull(values, \"values must not be null\");\n-        int fragmentsSize = fragments.size();\n-        int valuesSize = values.size();\n-        if (fragmentsSize != valuesSize + 1) {\n-            throw new IllegalArgumentException(\"fragments must have one more element than values\");\n-        }\n-        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-        return JTA.interpolate(fragments, values);\n-    }\n-\n-    \/**\n-     * Combine zero or more {@link StringTemplate StringTemplates} into a single\n-     * {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\");\n-     * assert st.interpolate().equals(STR.\"\\{a}\\{b}\\{c}\");\n-     * }\n-     * Fragment lists from the {@link StringTemplate StringTemplates} are combined end to\n-     * end with the last fragment from each {@link StringTemplate} concatenated with the\n-     * first fragment of the next. To demonstrate, if we were to take two strings and we\n-     * combined them as follows: {@snippet lang = \"java\":\n-     * String s1 = \"abc\";\n-     * String s2 = \"xyz\";\n-     * String sc = s1 + s2;\n-     * assert Objects.equals(sc, \"abcxyz\");\n-     * }\n-     * the last character {@code \"c\"} from the first string is juxtaposed with the first\n-     * character {@code \"x\"} of the second string. The same would be true of combining\n-     * {@link StringTemplate StringTemplates}.\n-     * {@snippet lang =\"java\":\n-     * StringTemplate st1 = RAW.\"a\\{}b\\{}c\";\n-     * StringTemplate st2 = RAW.\"x\\{}y\\{}z\";\n-     * StringTemplate st3 = RAW.\"a\\{}b\\{}cx\\{}y\\{}z\";\n-     * StringTemplate stc = StringTemplate.combine(st1, st2);\n-     *\n-     * assert Objects.equals(st1.fragments(), List.of(\"a\", \"b\", \"c\"));\n-     * assert Objects.equals(st2.fragments(), List.of(\"x\", \"y\", \"z\"));\n-     * assert Objects.equals(st3.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * assert Objects.equals(stc.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * }\n-     * Values lists are simply concatenated to produce a single values list.\n-     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n-     * n is the total of number of values across all the supplied\n-     * {@link StringTemplate StringTemplates}.\n-     *\n-     * @param stringTemplates  zero or more {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if stringTemplates is null or if any of the\n-     * {@code stringTemplates} are null\n-     *\n-     * @implNote If zero {@link StringTemplate} arguments are provided then a\n-     * {@link StringTemplate} with an empty fragment and no values is returned, as if invoking\n-     * <code>StringTemplate.of(\"\")<\/code> . If only one {@link StringTemplate} argument is provided\n-     * then it is returned unchanged.\n-     *\/\n-    static StringTemplate combine(StringTemplate... stringTemplates) {\n-        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-        return JTA.combine(stringTemplates);\n-    }\n-\n-    \/**\n-     * Combine a list of {@link StringTemplate StringTemplates} into a single\n-     * {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(List.of(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\"));\n-     * assert st.interpolate().equals(STR.\"\\{a}\\{b}\\{c}\");\n-     * }\n-     * Fragment lists from the {@link StringTemplate StringTemplates} are combined end to\n-     * end with the last fragment from each {@link StringTemplate} concatenated with the\n-     * first fragment of the next. To demonstrate, if we were to take two strings and we\n-     * combined them as follows: {@snippet lang = \"java\":\n-     * String s1 = \"abc\";\n-     * String s2 = \"xyz\";\n-     * String sc = s1 + s2;\n-     * assert Objects.equals(sc, \"abcxyz\");\n-     * }\n-     * the last character {@code \"c\"} from the first string is juxtaposed with the first\n-     * character {@code \"x\"} of the second string. The same would be true of combining\n-     * {@link StringTemplate StringTemplates}.\n-     * {@snippet lang =\"java\":\n-     * StringTemplate st1 = RAW.\"a\\{}b\\{}c\";\n-     * StringTemplate st2 = RAW.\"x\\{}y\\{}z\";\n-     * StringTemplate st3 = RAW.\"a\\{}b\\{}cx\\{}y\\{}z\";\n-     * StringTemplate stc = StringTemplate.combine(List.of(st1, st2));\n-     *\n-     * assert Objects.equals(st1.fragments(), List.of(\"a\", \"b\", \"c\"));\n-     * assert Objects.equals(st2.fragments(), List.of(\"x\", \"y\", \"z\"));\n-     * assert Objects.equals(st3.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * assert Objects.equals(stc.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * }\n-     * Values lists are simply concatenated to produce a single values list.\n-     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n-     * n is the total of number of values across all the supplied\n-     * {@link StringTemplate StringTemplates}.\n-     *\n-     * @param stringTemplates  list of {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if stringTemplates is null or if any of the\n-     * its elements are null\n-     *\n-     * @implNote If {@code stringTemplates.size() == 0} then a {@link StringTemplate} with\n-     * an empty fragment and no values is returned, as if invoking\n-     * <code>StringTemplate.of(\"\")<\/code> . If {@code stringTemplates.size() == 1}\n-     * then the first element of the list is returned unchanged.\n-     *\/\n-    static StringTemplate combine(List<StringTemplate> stringTemplates) {\n-        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-        return JTA.combine(stringTemplates.toArray(new StringTemplate[0]));\n-    }\n-\n-    \/**\n-     * This {@link Processor} instance is conventionally used for the string interpolation\n-     * of a supplied {@link StringTemplate}.\n-     * <p>\n-     * For better visibility and when practical, it is recommended that users use the\n-     * {@link StringTemplate#STR} processor instead of invoking the\n-     * {@link StringTemplate#interpolate()} method.\n-     * Example: {@snippet :\n-     * int x = 10;\n-     * int y = 20;\n-     * String result = STR.\"\\{x} + \\{y} = \\{x + y}\"; \/\/ @highlight substring=\"STR\"\n-     * }\n-     * In the above example, the value of {@code result} will be {@code \"10 + 20 = 30\"}. This is\n-     * produced by the interleaving concatenation of fragments and values from the supplied\n-     * {@link StringTemplate}. To accommodate concatenation, values are converted to strings\n-     * as if invoking {@link String#valueOf(Object)}.\n-     * @apiNote {@link StringTemplate#STR} is statically imported implicitly into every\n-     * Java compilation unit.\n-     *\/\n-    Processor<String, RuntimeException> STR = StringTemplate::interpolate;\n-\n-    \/**\n-     * This {@link Processor} instance is conventionally used to indicate that the\n-     * processing of the {@link StringTemplate} is to be deferred to a later time. Deferred\n-     * processing can be resumed by invoking the\n-     * {@link StringTemplate#process(Processor)} or\n-     * {@link Processor#process(StringTemplate)} methods.\n-     * {@snippet :\n-     * import static java.lang.StringTemplate.RAW;\n-     * ...\n-     * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-     * ...other steps...\n-     * String result = STR.process(st);\n-     * }\n-     * @implNote Unlike {@link StringTemplate#STR}, {@link StringTemplate#RAW} must be\n-     * statically imported explicitly.\n-     *\/\n-    Processor<StringTemplate, RuntimeException> RAW = st -> st;\n-\n-    \/**\n-     * This interface describes the methods provided by a generalized string template processor. The\n-     * primary method {@link Processor#process(StringTemplate)} is used to validate\n-     * and compose a result using a {@link StringTemplate StringTemplate's} fragments and values lists.\n-     * <p>\n-     * For example:\n-     * {@snippet :\n-     * class MyProcessor implements Processor<String, IllegalArgumentException> {\n-     *     @Override\n-     *     public String process(StringTemplate st) throws IllegalArgumentException {\n-     *          StringBuilder sb = new StringBuilder();\n-     *          Iterator<String> fragmentsIter = st.fragments().iterator();\n-     *\n-     *          for (Object value : st.values()) {\n-     *              sb.append(fragmentsIter.next());\n-     *\n-     *              if (value instanceof Boolean) {\n-     *                  throw new IllegalArgumentException(\"I don't like Booleans\");\n-     *              }\n-     *\n-     *              sb.append(value);\n-     *          }\n-     *\n-     *          sb.append(fragmentsIter.next());\n-     *\n-     *          return sb.toString();\n-     *     }\n-     * }\n-     *\n-     * MyProcessor myProcessor = new MyProcessor();\n-     * try {\n-     *     int x = 10;\n-     *     int y = 20;\n-     *     String result = myProcessor.\"\\{x} + \\{y} = \\{x + y}\";\n-     *     ...\n-     * } catch (IllegalArgumentException ex) {\n-     *     ...\n-     * }\n-     * }\n-     * Implementations of this interface may provide, but are not limited to, validating\n-     * inputs, composing inputs into a result, and transforming an intermediate string\n-     * result to a non-string value before delivering the final result.\n-     * <p>\n-     * The user has the option of validating inputs used in composition. For example an SQL\n-     * processor could prevent injection vulnerabilities by sanitizing inputs or throwing an\n-     * exception of type {@code E} if an SQL statement is a potential vulnerability.\n-     * <p>\n-     * Composing allows user control over how the result is assembled. Most often, a\n-     * user will construct a new string from the string template, with placeholders\n-     * replaced by string representations of value list elements. These string\n-     * representations are created as if invoking {@link String#valueOf}.\n-     * <p>\n-     * Transforming allows the processor to return something other than a string. For\n-     * instance, a JSON processor could return a JSON object, by parsing the string created\n-     * by composition, instead of the composed string.\n-     * <p>\n-     * {@link Processor} is a {@link FunctionalInterface}. This permits\n-     * declaration of a processor using lambda expressions;\n-     * {@snippet :\n-     * Processor<String, RuntimeException> processor = st -> {\n-     *     List<String> fragments = st.fragments();\n-     *     List<Object> values = st.values();\n-     *     \/\/ check or manipulate the fragments and\/or values\n-     *     ...\n-     *     return StringTemplate.interpolate(fragments, values);\n-     * };\n-     * }\n-     * The {@link StringTemplate#interpolate()} method is available for those processors\n-     * that just need to work with the string interpolation;\n-     * {@snippet :\n-     * Processor<String, RuntimeException> processor = StringTemplate::interpolate;\n-     * }\n-     * or simply transform the string interpolation into something other than\n-     * {@link String};\n-     * {@snippet :\n-     * Processor<JSONObject, RuntimeException> jsonProcessor = st -> new JSONObject(st.interpolate());\n-     * }\n-     * @implNote The Java compiler automatically imports {@link StringTemplate#STR}\n-     *\n-     * @param <R>  Processor's process result type\n-     * @param <E>  Exception thrown type\n-     *\n-     * @see StringTemplate\n-     * @see java.util.FormatProcessor\n-     *\n-     * @since 21\n-     *\n-     * @jls 15.8.6 Process Template Expressions\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    @FunctionalInterface\n-    public interface Processor<R, E extends Throwable> {\n-\n-        \/**\n-         * Constructs a result based on the template fragments and values in the\n-         * supplied {@link StringTemplate stringTemplate} object.\n-         * @apiNote Processing of a {@link StringTemplate} may include validation according to the particular facts relating\n-         * to each situation. The {@code E} type parameter indicates the type of checked exception that is thrown by\n-         * {@link #process} if validation fails, ex. {@code java.sql.SQLException}. If no checked exception is expected\n-         * then {@link RuntimeException} may be used. Note that unchecked exceptions, such as {@link RuntimeException},\n-         * {@link NullPointerException} or {@link IllegalArgumentException} may be thrown as part of the normal\n-         * method arguments processing. Details of which exceptions are thrown will be found in the documentation\n-         * of the specific implementation.\n-         *\n-         * @param stringTemplate  a {@link StringTemplate} instance\n-         *\n-         * @return constructed object of type R\n-         *\n-         * @throws E exception thrown by the template processor when validation fails\n-         *\/\n-        R process(StringTemplate stringTemplate) throws E;\n-\n-        \/**\n-         * This factory method can be used to create a {@link Processor} containing a\n-         * {@link Processor#process} method derived from a lambda expression. As an example;\n-         * {@snippet :\n-         * Processor<String, RuntimeException> mySTR = Processor.of(StringTemplate::interpolate);\n-         * int x = 10;\n-         * int y = 20;\n-         * String str = mySTR.\"\\{x} + \\{y} = \\{x + y}\";\n-         * }\n-         * The result type of the constructed {@link Processor} may be derived from\n-         * the lambda expression, thus this method may be used in a var\n-         * statement. For example, {@code mySTR} from above can also be declared using;\n-         * {@snippet :\n-         * var mySTR = Processor.of(StringTemplate::interpolate);\n-         * }\n-         * {@link RuntimeException} is the assumed exception thrown type.\n-         *\n-         * @param process a function that takes a {@link StringTemplate} as an argument\n-         *                and returns the inferred result type\n-         *\n-         * @return a {@link Processor}\n-         *\n-         * @param <T>  Processor's process result type\n-         *\/\n-        static <T> Processor<T, RuntimeException> of(Function<? super StringTemplate, ? extends T> process) {\n-            return process::apply;\n-        }\n-\n-        \/**\n-         * Built-in policies using this additional interface have the flexibility to\n-         * specialize the composition of the templated string by returning a customized\n-         * {@link MethodHandle} from {@link Linkage#linkage linkage}.\n-         * These specializations are typically implemented to improve performance;\n-         * specializing value types or avoiding boxing and vararg arrays.\n-         *\n-         * @implNote This interface is sealed to only allow standard processors.\n-         *\n-         * @sealedGraph\n-         * @since 21\n-         *\/\n-        @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-        public sealed interface Linkage permits FormatProcessor {\n-            \/**\n-             * This method creates a {@link MethodHandle} that when invoked with arguments of\n-             * those specified in {@code type} returns a result that equals that returned by\n-             * the template processor's process method. The difference being that this method\n-             * can preview the template's fragments and value types in advance of usage and\n-             * thereby has the opportunity to produce a specialized implementation.\n-             *\n-             * @param fragments  string template fragments\n-             * @param type       method type, includes the StringTemplate receiver as\n-             * well as the value types\n-             *\n-             * @return {@link MethodHandle} for the processor applied to template\n-             *\n-             * @throws NullPointerException if any of the arguments are null\n-             *\/\n-            MethodHandle linkage(List<String> fragments, MethodType type);\n-        }\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringTemplate.java","additions":0,"deletions":622,"binary":false,"changes":622,"status":"deleted"},{"patch":"@@ -74,0 +74,1 @@\n+import jdk.internal.misc.Blocker;\n@@ -83,1 +84,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -2194,3 +2194,3 @@\n-        FileInputStream fdIn = new FileInputStream(FileDescriptor.in);\n-        FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);\n-        FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);\n+        FileInputStream fdIn = new In(FileDescriptor.in);\n+        FileOutputStream fdOut = new Out(FileDescriptor.out);\n+        FileOutputStream fdErr = new Out(FileDescriptor.err);\n@@ -2221,0 +2221,77 @@\n+    \/**\n+     * System.in.\n+     *\/\n+    private static class In extends FileInputStream {\n+        In(FileDescriptor fd) {\n+            super(fd);\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                return super.read();\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+\n+        @Override\n+        public int read(byte[] b) throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                return super.read(b);\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                return super.read(b, off, len);\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * System.out\/System.err wrap this output stream.\n+     *\/\n+    private static class Out extends FileOutputStream {\n+        Out(FileDescriptor fd) {\n+            super(fd);\n+        }\n+\n+        public void write(int b) throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                super.write(b);\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+\n+        @Override\n+        public void write(byte[] b) throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                super.write(b);\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            boolean attempted = Blocker.begin();\n+            try {\n+                super.write(b, off, len);\n+            } finally {\n+                Blocker.end(attempted);\n+            }\n+        }\n+    }\n+\n@@ -2493,0 +2570,3 @@\n+            public void putCharUTF16(byte[] bytes, int index, int ch) {\n+                StringUTF16.putChar(bytes, index, ch);\n+            }\n@@ -2533,0 +2613,4 @@\n+            public long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value) {\n+                return StringConcatHelper.prepend(indexCoder, buf, value);\n+            }\n+\n@@ -2541,3 +2625,6 @@\n-            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-            public long stringConcatCoder(char value) {\n-                return StringConcatHelper.coder(value);\n+            public long stringConcatMix(long lengthCoder, char value) {\n+                return StringConcatHelper.mix(lengthCoder, value);\n+            }\n+\n+            public int stringSize(long i) {\n+                return Long.stringSize(i);\n@@ -2546,4 +2633,2 @@\n-            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-            public long stringBuilderConcatMix(long lengthCoder,\n-                                               StringBuilder sb) {\n-                return sb.mix(lengthCoder);\n+            public int getCharsLatin1(long i, int index, byte[] buf) {\n+                return StringLatin1.getChars(i, index, buf);\n@@ -2552,4 +2637,2 @@\n-            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-            public long stringBuilderConcatPrepend(long lengthCoder, byte[] buf,\n-                                                   StringBuilder sb) {\n-                return sb.prepend(lengthCoder, buf);\n+            public int getCharsUTF16(long i, int index, byte[] buf) {\n+                return StringUTF16.getChars(i, index, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":98,"deletions":15,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -463,0 +463,5 @@\n+        \/\/ re-adjust parallelism if the virtual thread yielded when compensating\n+        if (currentThread() instanceof CarrierThread ct) {\n+            ct.endBlocking();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1478,1 +1478,4 @@\n-    \/** 67 *\/\n+    \/**\n+     * The class major version of JAVA_23.\n+     * @since 23\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#ARRAY_LOAD}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayLoadInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#ARRAY_STORE}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayStoreInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#BRANCH}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/BranchInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,0 +134,2 @@\n+     * @throws IllegalArgumentException if the opcode does not represent a constant\n+     *                                  with implicit value\n@@ -148,0 +150,2 @@\n+     * @throws IllegalArgumentException if the opcode is not {@link Opcode#BIPUSH}\n+     *                                  or {@link Opcode#SIPUSH}\n@@ -162,0 +166,2 @@\n+     * @throws IllegalArgumentException if the opcode is not {@link Opcode#LDC},\n+     *                                  {@link Opcode#LDC_W}, or {@link Opcode#LDC2_W}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ConstantInstruction.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#CONVERT}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ConvertInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+         * @throws IllegalArgumentException if the opcode kind is not\n+         *         {@link Opcode.Kind#DISCONTINUED_JSR}.\n@@ -112,0 +114,2 @@\n+         * @throws IllegalArgumentException if the opcode kind is not\n+         *         {@link Opcode.Kind#DISCONTINUED_RET}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,0 +92,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#FIELD_ACCESS}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/FieldInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#INVOKE}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/InvokeInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#LOAD}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LoadInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#MONITOR}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/MonitorInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+     * @throws IllegalArgumentException when the {@code typeKind} is not a legal\n+     *                                  primitive array component type\n@@ -56,0 +58,4 @@\n+        \/\/ Implicit null-check:\n+        if (typeKind.newarraycode() < 0) {\n+            throw new IllegalArgumentException(\"Illegal component type: \" + typeKind.typeName());\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewPrimitiveArrayInstruction.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#OPERATOR}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/OperatorInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#RETURN}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ReturnInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#STACK}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/StackInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#STORE}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/StoreInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#TYPE_CHECK}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/TypeCheckInstruction.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,0 +241,6 @@\n+ * <p>\n+ * Unless otherwise noted, passing a {@code null} argument to a constructor\n+ * or method of any Class-File API class or interface will cause a {@link\n+ * java.lang.NullPointerException NullPointerException} to be thrown. Additionally,\n+ * invoking a method with an array or collection containing a {@code null} element\n+ * will cause a {@code NullPointerException}, unless otherwise specified. <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n- *     linker.defaultLookup().find(\"strlen\").orElseThrow(),\n+ *     linker.defaultLookup().findOrThrow(\"strlen\"),\n@@ -309,1 +309,1 @@\n- *     linker.defaultLookup().find(\"qsort\").orElseThrow(),\n+ *     linker.defaultLookup().findOrThrow(\"qsort\"),\n@@ -400,1 +400,1 @@\n- *     linker.defaultLookup().find(\"malloc\").orElseThrow(),\n+ *     linker.defaultLookup().findOrThrow(\"malloc\"),\n@@ -405,1 +405,1 @@\n- *     linker.defaultLookup().find(\"free\").orElseThrow(),\n+ *     linker.defaultLookup().findOrThrow(\"free\"),\n@@ -533,1 +533,1 @@\n- *     linker.defaultLookup().find(\"printf\").orElseThrow(),\n+ *     linker.defaultLookup().findOrThrow(\"printf\"),\n@@ -601,1 +601,1 @@\n-     * linker.downcallHandle(function).bindTo(symbol);\n+     * linker.downcallHandle(function, options).bindTo(address);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -98,0 +97,5 @@\n+ * Every memory segment has a {@linkplain #maxByteAlignment() maximum byte alignment},\n+ * expressed as a {@code long} value. The maximum alignment is always a power of two,\n+ * derived from the segment address, and the segment type, as explained in more detail\n+ * <a href=\"#segment-alignment\">below<\/a>.\n+ * <p>\n@@ -397,0 +401,8 @@\n+ * Clients can use the {@linkplain MemorySegment#maxByteAlignment()} method to check if\n+ * a memory segment supports the alignment constraint of a memory layout, as follows:\n+ * {@snippet lang=java:\n+ * MemoryLayout layout = ...\n+ * MemorySegment segment = ...\n+ * boolean isAligned = segment.maxByteAlignment() >= layout.byteAlignment();\n+ * }\n+ *\n@@ -592,0 +604,20 @@\n+    \/**\n+     * {@return the <a href=\"#segment-alignment\">maximum byte alignment<\/a>\n+     * associated with this memory segment}\n+     * <p>\n+     * The returned alignment is always a power of two and is derived from\n+     * the segment {@linkplain #address() address()} and, if it is a heap segment,\n+     * the type of the {@linkplain #heapBase() backing heap storage}.\n+     * <p>\n+     * This method can be used to ensure that a segment is sufficiently aligned\n+     * with a layout:\n+     * {@snippet lang=java:\n+     * MemoryLayout layout = ...\n+     * MemorySegment segment = ...\n+     * if (segment.maxByteAlignment() < layout.byteAlignment()) {\n+     *     \/\/ Take action (e.g. throw an Exception)\n+     * }\n+     * }\n+     *\/\n+    long maxByteAlignment();\n+\n@@ -1427,0 +1459,3 @@\n+     * <p>\n+     * The {@linkplain MemorySegment#maxByteAlignment() maximum byte alignment} for\n+     * the {@code NULL} segment is of 2<sup>62<\/sup>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.NoSuchElementException;\n@@ -82,1 +83,1 @@\n- *     MemorySegment glGetString = libGL.find(\"glGetString\").orElseThrow();\n+ *     MemorySegment glGetString = libGL.findOrThrow(\"glGetString\");\n@@ -96,1 +97,1 @@\n- * MemorySegment glGetString = libGL.find(\"glGetString\").orElseThrow();\n+ * MemorySegment glGetString = libGL.findOrThrow(\"glGetString\");\n@@ -133,1 +134,1 @@\n- * MemorySegment malloc = stdlib.find(\"malloc\").orElseThrow();\n+ * MemorySegment malloc = stdlib.findOrThrow(\"malloc\");\n@@ -147,0 +148,1 @@\n+     * @see #findOrThrow(String)\n@@ -150,0 +152,30 @@\n+    \/**\n+     * Returns the address of the symbol with the given name or throws an exception.\n+     *<p>\n+     * This is equivalent to the following code, but is more efficient:\n+     * to:\n+     * {@snippet lang= java :\n+     *    String name = ...\n+     *    MemorySegment address = lookup.find(name)\n+     *        .orElseThrow(() -> new NoSuchElementException(\"Symbol not found: \" + name));\n+     * }\n+     *\n+     * @param name the symbol name\n+     * @return a zero-length memory segment whose address indicates the address of\n+     *         the symbol\n+     * @throws NoSuchElementException if no symbol address can be found for the\n+     *         given name\n+     * @see #find(String)\n+     *\n+     * @since 23\n+     *\/\n+    default MemorySegment findOrThrow(String name) {\n+        Objects.requireNonNull(name);\n+        Optional<MemorySegment> address = find(name);\n+        \/\/ Avoid lambda capturing\n+        if (address.isPresent()) {\n+            return address.get();\n+        }\n+        throw new NoSuchElementException(\"Symbol not found: \" + name);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -449,2 +449,1 @@\n-     * (platform-dependent) byte alignment set to {@code ADDRESS.byteSize()},\n-     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -462,2 +461,1 @@\n-     * (platform-dependent) byte alignment set to {@code ADDRESS.byteSize()},\n-     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n- *     stdlib.find(\"strlen\").orElseThrow(),\n+ *     stdlib.findOrThrow(\"strlen\"),\n@@ -114,1 +114,1 @@\n- * and we use it to {@linkplain java.lang.foreign.SymbolLookup#find(java.lang.String) look up}\n+ * and we use it to {@linkplain java.lang.foreign.SymbolLookup#findOrThrow(java.lang.String) look up}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                    linker.defaultLookup().find(\"strlen\").orElseThrow(),\n+                    linker.defaultLookup().findOrThrow(\"strlen\"),\n@@ -180,1 +180,1 @@\n-                    linker.defaultLookup().find(\"qsort\").orElseThrow(),\n+                    linker.defaultLookup().findOrThrow(\"qsort\"),\n@@ -211,1 +211,1 @@\n-                    linker.defaultLookup().find(\"malloc\").orElseThrow(),\n+                    linker.defaultLookup().findOrThrow(\"malloc\"),\n@@ -216,1 +216,1 @@\n-                    linker.defaultLookup().find(\"free\").orElseThrow(),\n+                    linker.defaultLookup().findOrThrow(\"free\"),\n@@ -285,1 +285,1 @@\n-                    linker.defaultLookup().find(\"printf\").orElseThrow(),\n+                    linker.defaultLookup().findOrThrow(\"printf\"),\n@@ -571,1 +571,1 @@\n-                    stdlib.find(\"strlen\").orElseThrow(),\n+                    stdlib.findOrThrow(\"strlen\"),\n@@ -629,1 +629,1 @@\n-                MemorySegment glGetString = libGL.find(\"glGetString\").orElseThrow();\n+                MemorySegment glGetString = libGL.findOrThrow(\"glGetString\");\n@@ -636,1 +636,1 @@\n-            MemorySegment glGetString = libGL.find(\"glGetString\").orElseThrow();\n+            MemorySegment glGetString = libGL.findOrThrow(\"glGetString\");\n@@ -650,1 +650,1 @@\n-            MemorySegment malloc = stdlib.find(\"malloc\").orElseThrow();\n+            MemorySegment malloc = stdlib.findOrThrow(\"malloc\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/snippet-files\/Snippets.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,0 +148,3 @@\n+                } else if (isObjectMethodsBootstrapBSM(bsmType)) {\n+                    MethodHandle[] mhs = Arrays.copyOfRange(argv, 2, argv.length, MethodHandle[].class);\n+                    result = bootstrapMethod.invokeExact(caller, name, (TypeDescriptor)type, (Class<?>)argv[0], (String)argv[1], mhs);\n@@ -192,1 +195,0 @@\n-\n@@ -250,0 +252,3 @@\n+    private static final MethodType OBJECT_METHODS_MT = MethodType.methodType(Object.class,\n+            Lookup.class, String.class, TypeDescriptor.class, Class.class, String.class, MethodHandle[].class);\n+\n@@ -292,0 +297,9 @@\n+    \/**\n+     * @return true iff the BSM method type exactly matches\n+     *         {@link java.lang.runtime.ObjectMethods#bootstrap(\n+     *          MethodHandles.Lookup,String,TypeDescriptor,Class,String,MethodHandle[])}\n+     *\/\n+    private static boolean isObjectMethodsBootstrapBSM(MethodType bsmType) {\n+        return bsmType == OBJECT_METHODS_MT;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BootstrapMethodInvoker.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -178,4 +178,5 @@\n-        \/\/ lambda class has no access to the resolved method. Instead, we need\n-        \/\/ to pass the live implementation method handle to the proxy class\n-        \/\/ to invoke directly. (javac prefers to avoid this situation by\n-        \/\/ generating bridges in the target class)\n+        \/\/ lambda class has no access to the resolved method, or does\n+        \/\/ 'invokestatic' on a hidden class which cannot be resolved by name.\n+        \/\/ Instead, we need to pass the live implementation method handle to\n+        \/\/ the proxy class to invoke directly. (javac prefers to avoid this\n+        \/\/ situation by generating bridges in the target class)\n@@ -184,1 +185,2 @@\n-                               implKind == H_INVOKESPECIAL;\n+                               implKind == H_INVOKESPECIAL ||\n+                               implKind == H_INVOKESTATIC && implClass.isHidden();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -574,1 +574,1 @@\n-    \/** Invoke this form on the given arguments. *\/\n+    \/\/ \/** Invoke this form on the given arguments. *\/\n@@ -926,0 +926,1 @@\n+    \/** Interpretively invoke this form on the given arguments. *\/\n@@ -928,1 +929,0 @@\n-    \/** Interpretively invoke this form on the given arguments. *\/\n@@ -943,0 +943,1 @@\n+    \/** Evaluate a single Name within this form, applying its function to its arguments. *\/\n@@ -945,1 +946,0 @@\n-    \/** Evaluate a single Name within this form, applying its function to its arguments. *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.util.FormatConcatItem;\n@@ -118,2 +117,0 @@\n-     *\n-     * @since 21\n@@ -121,5 +118,1 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    public static final int MAX_INDY_CONCAT_ARG_SLOTS;\n-    \/\/ Use static initialize block to avoid MAX_INDY_CONCAT_ARG_SLOTS being treating\n-    \/\/ as a constant for constant folding.\n-    static { MAX_INDY_CONCAT_ARG_SLOTS = 200; }\n+    private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;\n@@ -715,3 +708,0 @@\n-            if (idx == STRING_CONCAT_ITEM) {\n-                cl = FormatConcatItem.class;\n-            }\n@@ -729,3 +719,0 @@\n-            if (idx == STRING_CONCAT_ITEM) {\n-                cl = FormatConcatItem.class;\n-            }\n@@ -744,2 +731,1 @@\n-            STRING_CONCAT_ITEM = 5,\n-            TYPE_COUNT = 6;\n+            TYPE_COUNT = 5;\n@@ -752,1 +738,0 @@\n-        if (FormatConcatItem.class.isAssignableFrom(cl)) return STRING_CONCAT_ITEM;\n@@ -1050,299 +1035,0 @@\n-    \/**\n-     * Simplified concatenation method to facilitate {@link StringTemplate}\n-     * concatenation. This method returns a single concatenation method that\n-     * interleaves fragments and values. fragment|value|fragment|value|...|value|fragment.\n-     * The number of fragments must be one more that the number of ptypes.\n-     * The total number of slots used by the ptypes must be less than or equal\n-     * to {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n-     *\n-     * @param fragments list of string fragments\n-     * @param ptypes    list of expression types\n-     *\n-     * @return the {@link MethodHandle} for concatenation\n-     *\n-     * @throws StringConcatException If any of the linkage invariants are violated.\n-     * @throws NullPointerException If any of the incoming arguments is null.\n-     * @throws IllegalArgumentException If the number of value slots exceed {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n-     *\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    public static MethodHandle makeConcatWithTemplate(\n-            List<String> fragments,\n-            List<Class<?>> ptypes)\n-            throws StringConcatException\n-    {\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-        Objects.requireNonNull(ptypes, \"ptypes is null\");\n-        ptypes = List.copyOf(ptypes);\n-\n-        if (fragments.size() != ptypes.size() + 1) {\n-            throw new IllegalArgumentException(\"fragments size not equal ptypes size plus one\");\n-        }\n-\n-        if (ptypes.isEmpty()) {\n-            return MethodHandles.constant(String.class, fragments.get(0));\n-        }\n-\n-        Class<?>[] ttypes = new Class<?>[ptypes.size()];\n-        MethodHandle[] filters = new MethodHandle[ptypes.size()];\n-        int slots = 0;\n-\n-        int pos = 0;\n-        for (Class<?> ptype : ptypes) {\n-            slots += ptype == long.class || ptype == double.class ? 2 : 1;\n-\n-            if (MAX_INDY_CONCAT_ARG_SLOTS < slots) {\n-                throw new StringConcatException(\"Too many concat argument slots: \" +\n-                        slots + \", can only accept \" + MAX_INDY_CONCAT_ARG_SLOTS);\n-            }\n-\n-            boolean isSpecialized = ptype.isPrimitive();\n-            boolean isFormatConcatItem = FormatConcatItem.class.isAssignableFrom(ptype);\n-            Class<?> ttype = isSpecialized ? promoteToIntType(ptype) :\n-                             isFormatConcatItem ? FormatConcatItem.class : Object.class;\n-            MethodHandle filter = isFormatConcatItem ? null : stringifierFor(ttype);\n-\n-            if (filter != null) {\n-                filters[pos] = filter;\n-                ttype = String.class;\n-            }\n-\n-            ttypes[pos++] = ttype;\n-        }\n-\n-        MethodHandle mh = MethodHandles.dropArguments(newString(), 2, ttypes);\n-\n-        long initialLengthCoder = INITIAL_CODER;\n-        pos = 0;\n-        for (String fragment : fragments) {\n-            initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, fragment);\n-\n-            if (ttypes.length <= pos) {\n-                break;\n-            }\n-\n-            Class<?> ttype = ttypes[pos];\n-            \/\/ (long,byte[],ttype) -> long\n-            MethodHandle prepender = prepender(fragment, ttype);\n-            \/\/ (byte[],long,ttypes...) -> String (unchanged)\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepender,1, 0, 2 + pos);\n-\n-            pos++;\n-        }\n-\n-        String lastFragment = fragments.getLast();\n-        initialLengthCoder -= lastFragment.length();\n-        MethodHandle newArrayCombinator = lastFragment.isEmpty() ? newArray() :\n-                newArrayWithSuffix(lastFragment);\n-        \/\/ (long,ttypes...) -> String\n-        mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,\n-                1 \/\/ index\n-        );\n-\n-        pos = 0;\n-        for (Class<?> ttype : ttypes) {\n-            \/\/ (long,ttype) -> long\n-            MethodHandle mix = mixer(ttypes[pos]);\n-            boolean lastPType = pos == ttypes.length - 1;\n-\n-            if (lastPType) {\n-                \/\/ (ttype) -> long\n-                mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);\n-                \/\/ (ttypes...) -> String\n-                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                        1 + pos \/\/ selected argument\n-                );\n-            } else {\n-                \/\/ (long,ttypes...) -> String\n-                mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,\n-                        0, \/\/ old-index\n-                        1 + pos \/\/ selected argument\n-                );\n-            }\n-\n-            pos++;\n-        }\n-\n-        mh = MethodHandles.filterArguments(mh, 0, filters);\n-        MethodType mt = MethodType.methodType(String.class, ptypes);\n-        mh = mh.viewAsType(mt, true);\n-\n-        return mh;\n-    }\n-\n-    \/**\n-     * This method breaks up large concatenations into separate\n-     * {@link MethodHandle MethodHandles} based on the number of slots required\n-     * per {@link MethodHandle}. Each {@link MethodHandle} after the first will\n-     * have an extra {@link String} slot for the result from the previous\n-     * {@link MethodHandle}.\n-     * {@link #makeConcatWithTemplate}\n-     * is used to construct the {@link MethodHandle MethodHandles}. The total\n-     * number of slots used by the ptypes is open ended. However, care must\n-     * be given when combining the {@link MethodHandle MethodHandles} so that\n-     * the combine total does not exceed the 255 slot limit.\n-     *\n-     * @param fragments list of string fragments\n-     * @param ptypes    list of expression types\n-     * @param maxSlots  maximum number of slots per {@link MethodHandle}.\n-     *\n-     * @return List of {@link MethodHandle MethodHandles}\n-     *\n-     * @throws IllegalArgumentException If maxSlots is not between 1 and\n-     *                                  MAX_INDY_CONCAT_ARG_SLOTS.\n-     * @throws StringConcatException If any of the linkage invariants are violated.\n-     * @throws NullPointerException If any of the incoming arguments is null.\n-     * @throws IllegalArgumentException If the number of value slots exceed {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n-     *\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    public static List<MethodHandle> makeConcatWithTemplateCluster(\n-            List<String> fragments,\n-            List<Class<?>> ptypes,\n-            int maxSlots)\n-            throws StringConcatException\n-    {\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-        Objects.requireNonNull(ptypes, \"ptypes is null\");\n-\n-        if (fragments.size() != ptypes.size() + 1) {\n-            throw new StringConcatException(\"fragments size not equal ptypes size plus one\");\n-        }\n-\n-        if (maxSlots < 1 || MAX_INDY_CONCAT_ARG_SLOTS < maxSlots) {\n-            throw new IllegalArgumentException(\"maxSlots must be between 1 and \" +\n-                    MAX_INDY_CONCAT_ARG_SLOTS);\n-\n-        }\n-\n-        if (ptypes.isEmpty()) {\n-            return List.of(MethodHandles.constant(String.class, fragments.get(0)));\n-        }\n-\n-        List<MethodHandle> mhs = new ArrayList<>();\n-        List<String> fragmentsSection = new ArrayList<>();\n-        List<Class<?>> ptypeSection = new ArrayList<>();\n-        int slots = 0;\n-\n-        int pos = 0;\n-        for (Class<?> ptype : ptypes) {\n-            boolean lastPType = pos == ptypes.size() - 1;\n-            fragmentsSection.add(fragments.get(pos));\n-            ptypeSection.add(ptype);\n-\n-            slots += ptype == long.class || ptype == double.class ? 2 : 1;\n-\n-            if (maxSlots <= slots || lastPType) {\n-                fragmentsSection.add(lastPType ? fragments.get(pos + 1) : \"\");\n-                MethodHandle mh = makeConcatWithTemplate(fragmentsSection,\n-                        ptypeSection);\n-                mhs.add(mh);\n-                fragmentsSection.clear();\n-                fragmentsSection.add(\"\");\n-                ptypeSection.clear();\n-                ptypeSection.add(String.class);\n-                slots = 1;\n-            }\n-\n-            pos++;\n-        }\n-\n-        return mhs;\n-    }\n-\n-    \/**\n-     * This method creates a {@link MethodHandle} expecting one input, the\n-     * receiver of the supplied getters. This method uses\n-     * {@link #makeConcatWithTemplateCluster}\n-     * to create the intermediate {@link MethodHandle MethodHandles}.\n-     *\n-     * @param fragments list of string fragments\n-     * @param getters   list of getter {@link MethodHandle MethodHandles}\n-     * @param maxSlots  maximum number of slots per {@link MethodHandle} in\n-     *                  cluster.\n-     *\n-     * @return the {@link MethodHandle} for concatenation\n-     *\n-     * @throws IllegalArgumentException If maxSlots is not between 1 and\n-     *                                  MAX_INDY_CONCAT_ARG_SLOTS or if the\n-     *                                  getters don't use the same argument type\n-     * @throws StringConcatException If any of the linkage invariants are violated\n-     * @throws NullPointerException If any of the incoming arguments is null\n-     * @throws IllegalArgumentException If the number of value slots exceed {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n-     *\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    public static MethodHandle makeConcatWithTemplateGetters(\n-            List<String> fragments,\n-            List<MethodHandle> getters,\n-            int maxSlots)\n-            throws StringConcatException\n-    {\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-        Objects.requireNonNull(getters, \"getters is null\");\n-\n-        if (fragments.size() != getters.size() + 1) {\n-            throw new StringConcatException(\"fragments size not equal getters size plus one\");\n-        }\n-\n-        if (maxSlots < 1 || MAX_INDY_CONCAT_ARG_SLOTS < maxSlots) {\n-            throw new IllegalArgumentException(\"maxSlots must be between 1 and \" +\n-                    MAX_INDY_CONCAT_ARG_SLOTS);\n-\n-        }\n-\n-        if (getters.size() == 0) {\n-            throw new StringConcatException(\"no getters supplied\");\n-        }\n-\n-        Class<?> receiverType = null;\n-        List<Class<?>> ptypes = new ArrayList<>();\n-\n-        for (MethodHandle getter : getters) {\n-            MethodType mt = getter.type();\n-            Class<?> returnType = mt.returnType();\n-\n-            if (returnType == void.class || mt.parameterCount() != 1) {\n-                throw new StringConcatException(\"not a getter \" + mt);\n-            }\n-\n-            if (receiverType == null) {\n-                receiverType = mt.parameterType(0);\n-            } else if (receiverType != mt.parameterType(0)) {\n-                throw new StringConcatException(\"not the same receiever type \" +\n-                        mt + \" needs \" + receiverType);\n-            }\n-\n-            ptypes.add(returnType);\n-        }\n-\n-        MethodType resultType = MethodType.methodType(String.class, receiverType);\n-        List<MethodHandle> clusters = makeConcatWithTemplateCluster(fragments, ptypes,\n-                maxSlots);\n-\n-        MethodHandle mh = null;\n-        Iterator<MethodHandle> getterIterator = getters.iterator();\n-\n-        for (MethodHandle cluster : clusters) {\n-            MethodType mt = cluster.type();\n-            MethodHandle[] filters = new MethodHandle[mt.parameterCount()];\n-            int pos = 0;\n-\n-            if (mh != null) {\n-                filters[pos++] = mh;\n-            }\n-\n-            while (pos < filters.length) {\n-                filters[pos++] = getterIterator.next();\n-            }\n-\n-            cluster = MethodHandles.filterArguments(cluster, 0, filters);\n-            mh = MethodHandles.permuteArguments(cluster, resultType,\n-                    new int[filters.length]);\n-        }\n-\n-        return mh;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":2,"deletions":316,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.util.List;\n-import java.util.Objects;\n-\n-\/**\n- * This class implements specialized {@link StringTemplate StringTemplates} produced by\n- * string template bootstrap method callsites generated by the compiler. Instances of this\n- * class are produced by {@link StringTemplateImplFactory}.\n- * <p>\n- * Values are stored by subclassing {@link Carriers.CarrierObject}. This allows specializations\n- * and sharing of value shapes without creating a new class for each shape.\n- * <p>\n- * {@link StringTemplate} fragments are shared via binding to the\n- * {@link java.lang.invoke.CallSite CallSite's} {@link MethodHandle}.\n- * <p>\n- * The {@link StringTemplateImpl} instance also carries\n- * specialized {@link MethodHandle MethodHandles} for producing the values list and interpolation.\n- * These {@link MethodHandle MethodHandles} are  also shared by binding to the\n- * {@link java.lang.invoke.CallSite CallSite}.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-final class StringTemplateImpl extends Carriers.CarrierObject implements StringTemplate {\n-    \/**\n-     * List of string fragments for the string template. This value of this list is shared by\n-     * all instances created at the {@link java.lang.invoke.CallSite CallSite}.\n-     *\/\n-    private final List<String> fragments;\n-\n-    \/**\n-     * Specialized {@link MethodHandle} used to implement the {@link StringTemplate StringTemplate's}\n-     * {@code values} method. This {@link MethodHandle} is shared by all instances created at the\n-     * {@link java.lang.invoke.CallSite CallSite}.\n-     *\/\n-    private final MethodHandle valuesMH;\n-\n-    \/**\n-     * Specialized {@link MethodHandle} used to implement the {@link StringTemplate StringTemplate's}\n-     * {@code interpolate} method. This {@link MethodHandle} is shared by all instances created at the\n-     * {@link java.lang.invoke.CallSite CallSite}.\n-     *\/\n-    private final MethodHandle interpolateMH;\n-\n-    \/**\n-     * Constructor.\n-     *\n-     * @param primitiveCount  number of primitive slots required (bound at callsite)\n-     * @param objectCount     number of object slots required (bound at callsite)\n-     * @param fragments       list of string fragments (bound in (bound at callsite)\n-     * @param valuesMH        {@link MethodHandle} to produce list of values (bound at callsite)\n-     * @param interpolateMH   {@link MethodHandle} to produce interpolation (bound at callsite)\n-     *\/\n-    StringTemplateImpl(int primitiveCount, int objectCount,\n-                       List<String> fragments, MethodHandle valuesMH, MethodHandle interpolateMH) {\n-        super(primitiveCount, objectCount);\n-        this.fragments = fragments;\n-        this.valuesMH = valuesMH;\n-        this.interpolateMH = interpolateMH;\n-    }\n-\n-    @Override\n-    public List<String> fragments() {\n-        return fragments;\n-    }\n-\n-    @Override\n-    public List<Object> values() {\n-        try {\n-            return (List<Object>)valuesMH.invokeExact(this);\n-        } catch (RuntimeException | Error ex) {\n-            throw ex;\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(\"string template values failure\", ex);\n-        }\n-    }\n-\n-    @Override\n-    public String interpolate() {\n-        try {\n-            return (String)interpolateMH.invokeExact(this);\n-        } catch (RuntimeException | Error ex) {\n-            throw ex;\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(\"string template interpolate failure\", ex);\n-        }\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        return other instanceof StringTemplate st &&\n-                Objects.equals(fragments(), st.fragments()) &&\n-                Objects.equals(values(), st.values());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(fragments(), values());\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return StringTemplate.toString(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/StringTemplateImpl.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.StringConcatException;\n-import java.lang.invoke.StringConcatFactory;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-\/**\n- * This class synthesizes {@link StringTemplate StringTemplates} based on\n- * fragments and bootstrap method type. Usage is primarily from\n- * {@link java.lang.runtime.TemplateRuntime}.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-final class StringTemplateImplFactory {\n-\n-    \/**\n-     * Private constructor.\n-     *\/\n-    StringTemplateImplFactory() {\n-        throw new AssertionError(\"private constructor\");\n-    }\n-\n-    \/*\n-     * {@link StringTemplateImpl} constructor MethodHandle.\n-     *\/\n-    private static final MethodHandle CONSTRUCTOR;\n-\n-\n-    \/*\n-     * Frequently used method types.\n-     *\/\n-    private static final MethodType MT_STRING_STIMPL =\n-            MethodType.methodType(String.class, StringTemplateImpl.class);\n-    private static final MethodType MT_LIST_STIMPL =\n-            MethodType.methodType(List.class, StringTemplateImpl.class);\n-\n-    \/**\n-     * List (for nullable) of MethodHandle;\n-     *\/\n-    private static final MethodHandle TO_LIST;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-            MethodType mt = MethodType.methodType(void.class, int.class, int.class, List.class,\n-                    MethodHandle.class, MethodHandle.class);\n-            CONSTRUCTOR = lookup.findConstructor(StringTemplateImpl.class, mt)\n-                    .asType(mt.changeReturnType(Carriers.CarrierObject.class));\n-\n-            mt = MethodType.methodType(List.class, Object[].class);\n-            TO_LIST = lookup.findStatic(StringTemplateImplFactory.class, \"toList\", mt);\n-        } catch(ReflectiveOperationException ex) {\n-            throw new AssertionError(\"carrier static init fail\", ex);\n-        }\n-    }\n-\n-    \/**\n-     * Create a new {@link StringTemplateImpl} constructor.\n-     *\n-     * @param fragments  string template fragments\n-     * @param type       values types with StringTemplate return\n-     *\n-     * @return {@link MethodHandle} that can construct a {@link StringTemplateImpl} with arguments\n-     * used as values.\n-     *\/\n-    static MethodHandle createStringTemplateImplMH(List<String> fragments, MethodType type) {\n-        Carriers.CarrierElements elements = Carriers.CarrierFactory.of(type);\n-        MethodHandle[] components = elements\n-                .components()\n-                .stream()\n-                .map(c -> c.asType(c.type().changeParameterType(0, StringTemplateImpl.class)))\n-                .toArray(MethodHandle[]::new);\n-        Class<?>[] ptypes = elements\n-                .components()\n-                .stream()\n-                .map(c -> c.type().returnType())\n-                .toArray(Class<?>[]::new);\n-        int[] permute = new int[ptypes.length];\n-\n-        MethodHandle interpolateMH;\n-        MethodType mt;\n-        try {\n-            interpolateMH = StringConcatFactory.makeConcatWithTemplate(fragments, List.of(ptypes));\n-        } catch (StringConcatException ex) {\n-            throw new RuntimeException(\"constructing internal string template\", ex);\n-        }\n-        interpolateMH = MethodHandles.filterArguments(interpolateMH, 0, components);\n-        interpolateMH = MethodHandles.permuteArguments(interpolateMH, MT_STRING_STIMPL, permute);\n-\n-        mt = MethodType.methodType(List.class, ptypes);\n-        MethodHandle valuesMH = TO_LIST.asCollector(Object[].class, components.length).asType(mt);\n-        valuesMH = MethodHandles.filterArguments(valuesMH, 0, components);\n-        valuesMH = MethodHandles.permuteArguments(valuesMH, MT_LIST_STIMPL, permute);\n-\n-        MethodHandle constructor = MethodHandles.insertArguments(CONSTRUCTOR, 0,\n-                elements.primitiveCount(), elements.objectCount(),\n-                fragments, valuesMH, interpolateMH);\n-        constructor = MethodHandles.foldArguments(elements.initializer(), 0, constructor);\n-\n-        mt = MethodType.methodType(StringTemplate.class, ptypes);\n-        constructor = constructor.asType(mt);\n-\n-        return constructor;\n-    }\n-\n-    \/**\n-     * Generic {@link StringTemplate}.\n-     *\n-     * @param fragments  immutable list of string fragments from string template\n-     * @param values     immutable list of expression values\n-     *\/\n-    private record SimpleStringTemplate(List<String> fragments, List<Object> values)\n-            implements StringTemplate {\n-        @Override\n-        public String toString() {\n-            return StringTemplate.toString(this);\n-        }\n-    }\n-\n-    \/**\n-     * Returns a new StringTemplate composed from fragments and values.\n-     *\n-     * @param fragments array of string fragments\n-     * @param values    array of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\/\n-    static StringTemplate newTrustedStringTemplate(String[] fragments, Object[] values) {\n-        return new SimpleStringTemplate(List.of(fragments), toList(values));\n-    }\n-\n-    \/**\n-     * Returns a new StringTemplate composed from fragments and values.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    array of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\/\n-    static StringTemplate newTrustedStringTemplate(List<String> fragments, Object[] values) {\n-        return new SimpleStringTemplate(List.copyOf(fragments), toList(values));\n-    }\n-\n-    \/**\n-     * Returns a new StringTemplate composed from fragments and values.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    list of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\/\n-\n-    static StringTemplate newStringTemplate(List<String> fragments, List<?> values) {\n-        @SuppressWarnings(\"unchecked\")\n-        List<Object> copy = (List<Object>)values.stream().toList();\n-        return new SimpleStringTemplate(List.copyOf(fragments), copy);\n-    }\n-\n-    \/**\n-     * Collect nullable elements from an array into a unmodifiable list.\n-     * Elements are guaranteed to be safe.\n-     *\n-     * @param elements  elements to place in list\n-     *\n-     * @return unmodifiable list.\n-     *\/\n-    private static List<Object> toList(Object[] elements) {\n-        return Arrays.stream(elements).toList();\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/StringTemplateImplFactory.java","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -85,2 +85,0 @@\n-    private static final Map<TypePairs, String> typePairToName;\n-\n@@ -102,1 +100,0 @@\n-        typePairToName = TypePairs.initialize();\n@@ -510,1 +507,1 @@\n-                            String methodName = typePairToName.get(typePair);\n+                            String methodName = TypePairs.typePairToName.get(typePair);\n@@ -687,0 +684,3 @@\n+\n+        private static final Map<TypePairs, String> typePairToName = initialize();\n+\n@@ -694,0 +694,11 @@\n+        public int hashCode() {\n+            return 31 * from.hashCode() + to.hashCode();\n+        }\n+\n+        public boolean equals(Object other) {\n+            if (other instanceof TypePairs otherPair) {\n+                return otherPair.from == from && otherPair.to == to;\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.ConstantCallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.StringTemplate.Processor;\n-import java.lang.StringTemplate.Processor.Linkage;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.access.JavaTemplateAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * Manages string template bootstrap methods. These methods may be used, for example,\n- * by Java compiler implementations to create {@link StringTemplate} instances. For example,\n- * the java compiler will translate the following code;\n- * {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n- * }\n- * to byte code that invokes the {@link java.lang.runtime.TemplateRuntime#newStringTemplate}\n- * bootstrap method to construct a {@link CallSite} that accepts two integers and produces a new\n- * {@link StringTemplate} instance.\n- * {@snippet :\n- * MethodHandles.Lookup lookup = MethodHandles.lookup();\n- * MethodType mt = MethodType.methodType(StringTemplate.class, int.class, int.class);\n- * CallSite cs = TemplateRuntime.newStringTemplate(lookup, \"\", mt, \"\", \" + \", \" = \", \"\");\n- * ...\n- * int x = 10;\n- * int y = 20;\n- * StringTemplate st = (StringTemplate)cs.getTarget().invokeExact(x, y);\n- * }\n- * If the string template requires more than\n- * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS} value slots,\n- * then the java compiler will use the\n- * {@link java.lang.runtime.TemplateRuntime#newLargeStringTemplate} bootstrap method\n- * instead. For example, the java compiler will translate the following code;\n- * {@snippet :\n- * int[] a = new int[1000], b = new int[1000];\n- * ...\n- * StringTemplate st = \"\"\"\n- *      \\{a[0]} - \\{b[0]}\n- *      \\{a[1]} - \\{b[1]}\n- *      ...\n- *      \\{a[999]} - \\{b[999]}\n- *      \"\"\";\n- * }\n- * to byte code that invokes the {@link java.lang.runtime.TemplateRuntime#newLargeStringTemplate}\n- * bootstrap method to construct a {@link CallSite} that accepts an array of integers and produces a new\n- * {@link StringTemplate} instance.\n- * {@snippet :\n- * MethodType mt = MethodType.methodType(StringTemplate.class, String[].class, Object[].class);\n- * CallSite cs = TemplateRuntime.newStringTemplate(lookup, \"\", mt);\n- * ...\n- * int[] a = new int[1000], b = new int[1000];\n- * ...\n- * StringTemplate st = (StringTemplate)cs.getTarget().invokeExact(\n- *         new String[] { \"\", \" - \", \"\\n\", \" - \", \"\\n\", ... \" - \", \"\\n\" },\n- *         new Object[] { a[0], b[0], a[1], b[1], ..., a[999], b[999]}\n- *         );\n- * }\n- *\n- * @since 21\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-public final class TemplateRuntime {\n-    private static final JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-\n-    \/**\n-     * {@link MethodHandle} to {@link TemplateRuntime#defaultProcess}.\n-     *\/\n-    private static final MethodHandle DEFAULT_PROCESS_MH;\n-\n-    \/**\n-     * {@link MethodHandle} to {@link TemplateRuntime#newTrustedStringTemplate}.\n-     *\/\n-    private static final MethodHandle NEW_TRUSTED_STRING_TEMPLATE;\n-\n-    \/**\n-     * Initialize {@link MethodHandle MethodHandles}.\n-     *\/\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-            MethodType mt = MethodType.methodType(Object.class,\n-                    List.class, Processor.class, Object[].class);\n-            DEFAULT_PROCESS_MH =\n-                lookup.findStatic(TemplateRuntime.class, \"defaultProcess\", mt);\n-\n-            mt = MethodType.methodType(StringTemplate.class, String[].class, Object[].class);\n-            NEW_TRUSTED_STRING_TEMPLATE =\n-                lookup.findStatic(StringTemplateImplFactory.class, \"newTrustedStringTemplate\", mt);\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(\"string bootstrap fail\", ex);\n-        }\n-    }\n-\n-    \/**\n-     * Private constructor.\n-     *\/\n-    private TemplateRuntime() {\n-        throw new AssertionError(\"private constructor\");\n-    }\n-\n-    \/**\n-     * String template bootstrap method for creating string templates.\n-     * The static arguments include the fragments list.\n-     * The non-static arguments are the values.\n-     *\n-     * @param lookup          method lookup from call site\n-     * @param name            method name - not used\n-     * @param type            method type\n-     *                        (ptypes...) -> StringTemplate\n-     * @param fragments       fragment array for string template\n-     *\n-     * @return {@link CallSite} to handle create string template\n-     *\n-     * @throws NullPointerException if any of the arguments is null\n-     * @throws Throwable            if linkage fails\n-     *\/\n-    public static CallSite newStringTemplate(MethodHandles.Lookup lookup,\n-                                             String name,\n-                                             MethodType type,\n-                                             String... fragments) throws Throwable {\n-        Objects.requireNonNull(lookup, \"lookup is null\");\n-        Objects.requireNonNull(name, \"name is null\");\n-        Objects.requireNonNull(type, \"type is null\");\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-\n-        MethodHandle mh = StringTemplateImplFactory\n-                .createStringTemplateImplMH(List.of(fragments), type).asType(type);\n-\n-        return new ConstantCallSite(mh);\n-    }\n-\n-    \/**\n-     * String template bootstrap method for creating large string templates,\n-     * i.e., when the number of value slots exceeds\n-     * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS}.\n-     * The non-static arguments are the fragments array and values array.\n-     *\n-     * @param lookup          method lookup from call site\n-     * @param name            method name - not used\n-     * @param type            method type\n-     *                        (String[], Object[]) -> StringTemplate\n-     *\n-     * @return {@link CallSite} to handle create large string template\n-     *\n-     * @throws NullPointerException if any of the arguments is null\n-     * @throws Throwable            if linkage fails\n-     *\/\n-    public static CallSite newLargeStringTemplate(MethodHandles.Lookup lookup,\n-                                                  String name,\n-                                                  MethodType type) throws Throwable {\n-        Objects.requireNonNull(lookup, \"lookup is null\");\n-        Objects.requireNonNull(name, \"name is null\");\n-        Objects.requireNonNull(type, \"type is null\");\n-\n-        return new ConstantCallSite(NEW_TRUSTED_STRING_TEMPLATE.asType(type));\n-    }\n-\n-    \/**\n-     * String template bootstrap method for static final processors.\n-     * The static arguments include the fragments array  and a {@link MethodHandle}\n-     * to retrieve the value of the static final processor.\n-     * The non-static arguments are the values.\n-     *\n-     * @param lookup          method lookup from call site\n-     * @param name            method name - not used\n-     * @param type            method type\n-     *                        (ptypes...) -> Object\n-     * @param processorGetter {@link MethodHandle} to get static final processor\n-     * @param fragments       fragments from string template\n-     *\n-     * @return {@link CallSite} to handle string template processing\n-     *\n-     * @throws NullPointerException if any of the arguments is null\n-     * @throws Throwable            if linkage fails\n-     *\n-     * @implNote this method is likely to be revamped before exiting preview.\n-     *\/\n-    public static CallSite processStringTemplate(MethodHandles.Lookup lookup,\n-                                                 String name,\n-                                                 MethodType type,\n-                                                 MethodHandle processorGetter,\n-                                                 String... fragments) throws Throwable {\n-        Objects.requireNonNull(lookup, \"lookup is null\");\n-        Objects.requireNonNull(name, \"name is null\");\n-        Objects.requireNonNull(type, \"type is null\");\n-        Objects.requireNonNull(processorGetter, \"processorGetter is null\");\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-\n-        Processor<?, ?> processor = (Processor<?, ?>)processorGetter.invoke();\n-        MethodHandle mh = processor instanceof Linkage linkage\n-                ? linkage.linkage(List.of(fragments), type)\n-                : defaultProcessMethodHandle(type, processor, List.of(fragments));\n-\n-        return new ConstantCallSite(mh);\n-    }\n-\n-    \/**\n-     * Creates a simple {@link StringTemplate} and then invokes the processor's process method.\n-     *\n-     * @param fragments fragments from string template\n-     * @param processor {@link Processor} to process\n-     * @param values    array of expression values\n-     *\n-     * @return result of processing the string template\n-     *\n-     * @throws Throwable when {@link Processor#process(StringTemplate)} throws\n-     *\/\n-    private static Object defaultProcess(\n-            List<String> fragments,\n-            Processor<?, ?> processor,\n-            Object[] values\n-    ) throws Throwable {\n-        return processor.process(StringTemplate.of(fragments, Arrays.stream(values).toList()));\n-    }\n-\n-    \/**\n-     * Generate a {@link MethodHandle} which is effectively invokes\n-     * {@code processor.process(new StringTemplate(fragments, values...)}.\n-     *\n-     * @return default process {@link MethodHandle}\n-     *\/\n-    private static MethodHandle defaultProcessMethodHandle(\n-            MethodType type,\n-            Processor<?, ?> processor,\n-            List<String> fragments\n-    ) {\n-        MethodHandle mh = MethodHandles.insertArguments(DEFAULT_PROCESS_MH, 0, fragments, processor);\n-        return mh.asCollector(Object[].class, type.parameterCount()).asType(type);\n-    }\n-}\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateRuntime.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaTemplateAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/**\n- * This class provides runtime support for string templates. The methods within\n- * are intended for internal use only.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-final class TemplateSupport implements JavaTemplateAccess {\n-\n-    \/**\n-     * Private constructor.\n-     *\/\n-    private TemplateSupport() {\n-    }\n-\n-    static {\n-        SharedSecrets.setJavaTemplateAccess(new TemplateSupport());\n-    }\n-\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    \/**\n-     * Returns a StringTemplate composed from fragments and values.\n-     *\n-     * @implSpec The {@code fragments} list size must be one more that the\n-     * {@code values} list size.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    list of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n-     *\n-     * @implNote Contents of both lists are copied to construct immutable lists.\n-     *\/\n-    @Override\n-    public StringTemplate of(List<String> fragments, List<?> values) {\n-        return StringTemplateImplFactory.newStringTemplate(fragments, values);\n-    }\n-\n-    \/**\n-     * Creates a string that interleaves the elements of values between the\n-     * elements of fragments.\n-     *\n-     * @param fragments  list of String fragments\n-     * @param values     list of expression values\n-     *\n-     * @return String interpolation of fragments and values\n-     *\/\n-    @Override\n-    public String interpolate(List<String> fragments, List<?> values) {\n-        int fragmentsSize = fragments.size();\n-        int valuesSize = values.size();\n-        if (fragmentsSize == 1) {\n-            return fragments.get(0);\n-        }\n-        int size = fragmentsSize + valuesSize;\n-        String[] strings = new String[size];\n-        int i = 0, j = 0;\n-        for (; j < valuesSize; j++) {\n-            strings[i++] = fragments.get(j);\n-            strings[i++] = String.valueOf(values.get(j));\n-        }\n-        strings[i] = fragments.get(j);\n-        return JLA.join(\"\", \"\", \"\", strings, size);\n-    }\n-\n-    \/**\n-     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n-     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n-     * }\n-     *\n-     * @param sts  zero or more {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if sts is null or if any element of sts is null\n-     *\/\n-    @Override\n-    public StringTemplate combine(StringTemplate... sts) {\n-        Objects.requireNonNull(sts, \"sts must not be null\");\n-        if (sts.length == 0) {\n-            return StringTemplate.of(\"\");\n-        } else if (sts.length == 1) {\n-            return Objects.requireNonNull(sts[0], \"string templates should not be null\");\n-        }\n-        int size = 0;\n-        for (StringTemplate st : sts) {\n-            Objects.requireNonNull(st, \"string templates should not be null\");\n-            size += st.values().size();\n-        }\n-        String[] combinedFragments = new String[size + 1];\n-        Object[] combinedValues = new Object[size];\n-        combinedFragments[0] = \"\";\n-        int fragmentIndex = 1;\n-        int valueIndex = 0;\n-        for (StringTemplate st : sts) {\n-            Iterator<String> iterator = st.fragments().iterator();\n-            combinedFragments[fragmentIndex - 1] += iterator.next();\n-            while (iterator.hasNext()) {\n-                combinedFragments[fragmentIndex++] = iterator.next();\n-            }\n-            for (Object value : st.values()) {\n-                combinedValues[valueIndex++] = value;\n-            }\n-        }\n-        return StringTemplateImplFactory.newTrustedStringTemplate(combinedFragments, combinedValues);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateSupport.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -4846,1 +4846,1 @@\n-    \/**\n+    \/*\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import static java.math.BigDecimal.INFLATED;\n+import static java.math.BigInteger.LONG_MASK;\n+import java.util.Arrays;\n+\n@@ -45,4 +49,0 @@\n-import static java.math.BigDecimal.INFLATED;\n-import static java.math.BigInteger.LONG_MASK;\n-import java.util.Arrays;\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-    \/**\n+    \/*\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpURLConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1219,1 +1219,1 @@\n-            long comp = Blocker.begin();\n+            boolean attempted = Blocker.begin();\n@@ -1223,1 +1223,1 @@\n-                Blocker.end(comp);\n+                Blocker.end(attempted);\n@@ -1233,1 +1233,1 @@\n-            long comp = Blocker.begin();\n+            boolean attempted = Blocker.begin();\n@@ -1237,1 +1237,1 @@\n-                Blocker.end(comp);\n+                Blocker.end(attempted);\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-            long comp = Blocker.begin();\n+            boolean attempted = Blocker.begin();\n@@ -107,1 +107,1 @@\n-                Blocker.end(comp);\n+                Blocker.end(attempted);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedMemoryUtils.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-     * direction is computes using the Unicode Bidirectional Algorithm, defaulting to left-to-right\n+     * direction is computed using the Unicode Bidirectional Algorithm, defaulting to left-to-right\n","filename":"src\/java.base\/share\/classes\/java\/text\/Bidi.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -588,0 +588,12 @@\n+\n+    @Override\n+    public boolean isStrict() {\n+        throw new UnsupportedOperationException(\n+                \"ChoiceFormat does not utilize leniency when parsing\");\n+    }\n+\n+    @Override\n+    public void setStrict(boolean strict) {\n+        throw new UnsupportedOperationException(\n+                \"ChoiceFormat does not utilize leniency when parsing\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,5 +50,5 @@\n- * that formats a decimal number in its compact form.\n- *\n- * The compact number formatting is designed for the environment where the space\n- * is limited, and the formatted string can be displayed in that limited space.\n- * It is defined by LDML's specification for\n+ * that formats a decimal number in a localized compact form.\n+ * Compact number formatting is designed for an environment with limited space.\n+ * For example, displaying the formatted number {@code 7M} instead of {@code\n+ * 7,000,000.00} in the {@link java.util.Locale#US US locale}. The {@code\n+ * CompactNumberFormat} class is defined by LDML's specification for\n@@ -56,3 +56,1 @@\n- * Compact Number Formats<\/a>. A compact number formatting refers\n- * to the representation of a number in a shorter form, based on the patterns\n- * provided for a given locale.\n+ * Compact Number Formats<\/a>.\n@@ -60,8 +58,22 @@\n- * <p>\n- * For example:\n- * <br>In the {@link java.util.Locale#US US locale}, {@code 1000} can be formatted\n- * as {@code \"1K\"}, and {@code 1000000} as {@code \"1M\"}, depending upon the\n- * {@linkplain ##compact_number_style style} used.\n- * <br>In the {@code \"hi_IN\"} locale, {@code 1000} can be formatted as\n- * \"1 \\u0939\\u091C\\u093C\\u093E\\u0930\", and {@code 50000000} as \"5 \\u0915.\",\n- * depending upon the {@linkplain ##compact_number_style style} used.\n+ * <h2>Getting a CompactNumberFormat<\/h2>\n+ * To get a compact number format, use one of the ways listed below.\n+ * <ul>\n+ * <li> Use the factory method {@link NumberFormat#getCompactNumberInstance()}\n+ * to obtain a format for the default locale with\n+ * {@link NumberFormat.Style#SHORT SHORT} style.\n+ * <li> Use the factory methood {@link NumberFormat#getCompactNumberInstance(Locale, Style)}\n+ * to obtain a format for a different locale\n+ * and to control the {@linkplain ##compact_number_style Style}.\n+ * <li> Use one of the {@code CompactNumberFormat} constructors, for example, {@link\n+ * CompactNumberFormat#CompactNumberFormat(String, DecimalFormatSymbols, String[])\n+ * CompactNumberFormat(decimalPattern, symbols, compactPatterns)}, to obtain a\n+ * {@code CompactNumberFormat} with further customization.\n+ * <\/ul>\n+ * <p>If a standard compact format for a given locale and {@link\n+ * ##compact_number_style style} is desired, it is recommended to use one of the\n+ * NumberFormat factory methods listed above. To use an instance method\n+ * defined by {@code CompactNumberFormat}, the {@code NumberFormat} returned by\n+ * these factory methods should be type checked before converted to {@code CompactNumberFormat}.\n+ * If the installed locale-sensitive service implementation does not support\n+ * the given {@code Locale}, the parent locale chain will be looked up, and\n+ * a {@code Locale} used that is supported.\n@@ -69,5 +81,8 @@\n- * <p>\n- * To obtain a {@code CompactNumberFormat} for a locale, use one\n- * of the factory methods given by {@code NumberFormat} for compact number\n- * formatting. For example,\n- * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.\n+ * <h2><a id=\"compact_number_style\">Style<\/a><\/h2>\n+ * When using {@link NumberFormat#getCompactNumberInstance(Locale, Style)}, a\n+ * compact form can be retrieved with either a {@link NumberFormat.Style#SHORT\n+ * SHORT} or {@link NumberFormat.Style#LONG LONG} style.\n+ * For example, a {@link NumberFormat.Style#SHORT SHORT} style compact number instance in\n+ * the {@link java.util.Locale#US US locale} formats {@code 10000} as {@code\n+ * \"10K\"}. However, a {@link NumberFormat.Style#LONG LONG} style instance in\n+ * the same locale formats {@code 10000} as {@code \"10 thousand\"}.\n@@ -75,5 +90,2 @@\n- * <blockquote>{@snippet lang=java :\n- * NumberFormat fmt = NumberFormat.getCompactNumberInstance(\n- *                             Locale.forLanguageTag(\"hi-IN\"), NumberFormat.Style.SHORT);\n- * String result = fmt.format(1000);\n- * }<\/blockquote>\n+ * <h2>Using CompactNumberFormat<\/h2>\n+ * The following is an example of formatting and parsing in a localized manner,\n@@ -81,14 +93,31 @@\n- * <h2><a id=\"compact_number_style\">Style<\/a><\/h2>\n- * <p>\n- * A number can be formatted in the compact forms with two different\n- * styles, {@link NumberFormat.Style#SHORT SHORT}\n- * and {@link NumberFormat.Style#LONG LONG}. Use\n- * {@link NumberFormat#getCompactNumberInstance(Locale, Style)} for formatting and\n- * parsing a number in {@link NumberFormat.Style#SHORT SHORT} or\n- * {@link NumberFormat.Style#LONG LONG} compact form,\n- * where the given {@code Style} parameter requests the desired\n- * format. A {@link NumberFormat.Style#SHORT SHORT} style\n- * compact number instance in the {@link java.util.Locale#US US locale} formats\n- * {@code 10000} as {@code \"10K\"}. However, a\n- * {@link NumberFormat.Style#LONG LONG} style instance in same locale\n- * formats {@code 10000} as {@code \"10 thousand\"}.\n+ * {@snippet lang=java :\n+ * NumberFormat compactFormat = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n+ * compactFormat.format(1000); \/\/ returns \"1K\"\n+ * compactFormat.parse(\"1K\"); \/\/ returns 1000\n+ * }\n+ *\n+ * <h2 id=\"formatting\">Formatting<\/h2>\n+ * The default formatting behavior returns a formatted string with no fractional\n+ * digits, however users can use the {@link #setMinimumFractionDigits(int)}\n+ * method to include the fractional part.\n+ * The number {@code 1000.0} or {@code 1000} is formatted as {@code \"1K\"}\n+ * not {@code \"1.00K\"} (in the {@link java.util.Locale#US US locale}). For this\n+ * reason, the patterns provided for formatting contain only the minimum\n+ * integer digits, prefix and\/or suffix, but no fractional part.\n+ * For example, patterns used are {@code {\"\", \"\", \"\", 0K, 00K, ...}}. If the pattern\n+ * selected for formatting a number is {@code \"0\"} (special pattern),\n+ * either explicit or defaulted, then the general number formatting provided by\n+ * {@link java.text.DecimalFormat DecimalFormat}\n+ * for the specified locale is used.\n+ *\n+ * <h3>Rounding<\/h3>\n+ * {@code CompactNumberFormat} provides rounding modes defined in\n+ * {@link java.math.RoundingMode} for formatting.  By default, it uses\n+ * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n+ *\n+ * <h2>Parsing<\/h2>\n+ * The default parsing behavior does not allow a grouping separator until\n+ * grouping used is set to {@code true} by using\n+ * {@link #setGroupingUsed(boolean)}. The parsing of the fractional part\n+ * depends on the {@link #isParseIntegerOnly()}. For example, if the\n+ * parse integer only is set to true, then the fractional part is skipped.\n@@ -98,3 +127,7 @@\n- * The compact number patterns are represented in a series of patterns where each\n- * pattern is used to format a range of numbers. An example of\n- * {@link NumberFormat.Style#SHORT SHORT} styled compact number patterns\n+ * The {@code compactPatterns} in {@link\n+ * CompactNumberFormat#CompactNumberFormat(String, DecimalFormatSymbols, String[])\n+ * CompactNumberFormat(decimalPattern, symbols, compactPatterns)} are represented\n+ * as a series of strings, where each string is a {@link ##compact_number_syntax\n+ * pattern} that is used to format a range of numbers.\n+ *\n+ * <p> An example of the {@link NumberFormat.Style#SHORT SHORT} styled compact number patterns\n@@ -106,5 +139,5 @@\n- * For example, in the above patterns, pattern at index 3\n- * ({@code \"0K\"}) is used for formatting {@code number >= 1000 and number < 10000},\n- * pattern at index 4 ({@code \"00K\"}) is used for formatting\n- * {@code number >= 10000 and number < 100000} and so on. In most of the locales,\n- * patterns with the range\n+ * For example, in the above patterns, the pattern at index 3\n+ * ({@code \"0K\"}) is used for formatting a number in the range: {@code 1000 <= number < 10000},\n+ * index 4 ({@code \"00K\"}) for formatting a number the range: {@code 10000 <=\n+ * number < 100000}, and so forth.\n+ * <p>In most locales, patterns with the range\n@@ -117,1 +150,1 @@\n- * <p>\n+ * <h3>Negative Subpatterns<\/h3>\n@@ -119,1 +152,1 @@\n- * separated by a subpattern boundary character {@code ';' (U+003B)},\n+ * separated by a subpattern boundary character {@code ';'},\n@@ -123,1 +156,1 @@\n- * minus sign ({@code '-' U+002D HYPHEN-MINUS}) is used as the negative\n+ * minus sign {@code '-' (U+002D HYPHEN-MINUS)} is used as the negative\n@@ -131,1 +164,1 @@\n- * <p>\n+ * <h4>Escaping Special Characters<\/h4>\n@@ -136,1 +169,1 @@\n- * characters. They must be quoted, using single quote {@code ' (U+0027)}\n+ * characters. These characters must be quoted using single quotes {@code ' (U+0027)}\n@@ -141,0 +174,8 @@\n+ * <p> {@code CompactNumberFormat} support patterns for both singular and plural\n+ * compact forms. For the plural form, the {@code Pattern} should consist\n+ * of {@code PluralPattern}(s) separated by a space ' ' (U+0020) that are enumerated\n+ * within a pair of curly brackets '{' (U+007B) and '}' (U+007D).\n+ * In this format, each {@code PluralPattern} consists of its {@code count},\n+ * followed by a single colon {@code ':' (U+003A)} and a {@code SimplePattern}.\n+ * As a space is reserved for separating subsequent {@code PluralPattern}s, it must\n+ * be quoted to be used literally in either the {@code prefix} or {@code suffix}.\n@@ -142,6 +183,5 @@\n- * In case some localization requires compact number patterns to be different for\n- * plurals, each singular and plural pattern can be enumerated within a pair of\n- * curly brackets <code>'{' (U+007B)<\/code> and <code>'}' (U+007D)<\/code>, separated\n- * by a space {@code ' ' (U+0020)}. If this format is used, each pattern needs to be\n- * prepended by its {@code count}, followed by a single colon {@code ':' (U+003A)}.\n- * If the pattern includes spaces literally, they must be quoted.\n+ * For example, while the pattern representing millions ({@code 10}<sup>{@code 6}\n+ * <\/sup>) in the US locale can be specified as the SimplePattern: {@code \"0 Million\"}, for the\n+ * German locale it can be specified as the PluralPattern:\n+ * {@code \"{one:0' 'Million other:0' 'Millionen}\"}.\n+ *\n@@ -149,3 +189,2 @@\n- * For example, the compact number pattern representing millions in German locale can be\n- * specified as {@code \"{one:0' 'Million other:0' 'Millionen}\"}. The {@code count}\n- * follows LDML's\n+ * <a id=\"compact_number_syntax\">A compact pattern has the following syntax, with {@code count}<\/a>\n+ * following LDML's\n@@ -153,3 +192,1 @@\n- * Language Plural Rules<\/a>.\n- * <p>\n- * A compact pattern has the following syntax:\n+ * Language Plural Rules<\/a>:\n@@ -182,26 +219,0 @@\n- * <h2>Formatting<\/h2>\n- * The default formatting behavior returns a formatted string with no fractional\n- * digits, however users can use the {@link #setMinimumFractionDigits(int)}\n- * method to include the fractional part.\n- * The number {@code 1000.0} or {@code 1000} is formatted as {@code \"1K\"}\n- * not {@code \"1.00K\"} (in the {@link java.util.Locale#US US locale}). For this\n- * reason, the patterns provided for formatting contain only the minimum\n- * integer digits, prefix and\/or suffix, but no fractional part.\n- * For example, patterns used are {@code {\"\", \"\", \"\", 0K, 00K, ...}}. If the pattern\n- * selected for formatting a number is {@code \"0\"} (special pattern),\n- * either explicit or defaulted, then the general number formatting provided by\n- * {@link java.text.DecimalFormat DecimalFormat}\n- * for the specified locale is used.\n- *\n- * <h2>Parsing<\/h2>\n- * The default parsing behavior does not allow a grouping separator until\n- * grouping used is set to {@code true} by using\n- * {@link #setGroupingUsed(boolean)}. The parsing of the fractional part\n- * depends on the {@link #isParseIntegerOnly()}. For example, if the\n- * parse integer only is set to true, then the fractional part is skipped.\n- *\n- * <h2>Rounding<\/h2>\n- * {@code CompactNumberFormat} provides rounding modes defined in\n- * {@link java.math.RoundingMode} for formatting.  By default, it uses\n- * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n- *\n@@ -213,0 +224,1 @@\n+ * @see Locale\n@@ -351,0 +363,9 @@\n+    \/**\n+     * True if this {@code CompactNumberFormat} will parse numbers with strict\n+     * leniency.\n+     *\n+     * @serial\n+     * @since 23\n+     *\/\n+    private boolean parseStrict = false;\n+\n@@ -383,2 +404,3 @@\n-     * {@code NumberFormat} for compact number formatting. For example,\n-     * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.\n+     * {@code NumberFormat} for compact number formatting.\n+     *\n+     * <p>Below is an example of using the constructor,\n@@ -386,1 +408,9 @@\n-     * @param decimalPattern a decimal pattern for general number formatting\n+     * {@snippet lang=java :\n+     * String[] compactPatterns = {\"\", \"\", \"\", \"a lot\"};\n+     * NumberFormat fmt = new CompactNumberFormat(\"00\", DecimalFormatSymbols.getInstance(Locale.US), compactPatterns);\n+     * fmt.format(1); \/\/ returns \"01\"\n+     * fmt.format(1000); \/\/ returns \"a lot\"\n+     * }\n+     *\n+     * @param decimalPattern a {@linkplain DecimalFormat##patterns decimal pattern}\n+     *                       for general number formatting\n@@ -413,1 +443,2 @@\n-     * @param decimalPattern a decimal pattern for general number formatting\n+     * @param decimalPattern a {@linkplain DecimalFormat##patterns decimal pattern}\n+     *                      for general number formatting\n@@ -1501,12 +1532,1 @@\n-     * Parses a compact number from a string to produce a {@code Number}.\n-     * <p>\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and {@code null} is returned.\n+     * {@inheritDoc NumberFormat}\n@@ -1514,1 +1534,1 @@\n-     * The value is the numeric part in the given text multiplied\n+     * The returned value is the numeric part in the given text multiplied\n@@ -1517,0 +1537,29 @@\n+     * <p>\n+     * A {@code CompactNumberFormat} can match\n+     * the default prefix\/suffix to a compact prefix\/suffix interchangeably.\n+     * <p>\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n+     * <p>\n+     * Parsing fails when <b>lenient<\/b>, if the prefix and\/or suffix are non-empty\n+     * and cannot be found due to parsing ending early, or the first character\n+     * after the prefix cannot be parsed.\n+     * <p>\n+     * Parsing fails when <b>strict<\/b>, if in {@code text},\n+     * <ul>\n+     *   <li> The default or a compact prefix is not found. For example, the {@code\n+     *   Locale.US} currency format prefix: \"{@code $}\"\n+     *   <li> The default or a compact suffix is not found. For example, a {@code Locale.US}\n+     *   {@link NumberFormat.Style#SHORT} compact suffix: \"{@code K}\"\n+     *   <li> {@link #isGroupingUsed()} returns {@code false}, and the grouping\n+     *   symbol is found\n+     *   <li> {@link #isGroupingUsed()} returns {@code true}, and {@link\n+     *   #getGroupingSize()} is not adhered to\n+     *   <li> {@link #isParseIntegerOnly()} returns {@code true}, and the decimal\n+     *   separator is found\n+     *   <li> {@link #isGroupingUsed()} returns {@code true} and {@link\n+     *   #isParseIntegerOnly()} returns {@code false}, and the grouping\n+     *   symbol occurs after the decimal separator\n+     *   <li> Any other characters are found, that are not the expected symbols,\n+     *   and are not digits that occur within the numerical portion\n+     * <\/ul>\n+     * <p>\n@@ -1556,1 +1605,0 @@\n-     *\n@@ -1664,0 +1712,7 @@\n+        } else {\n+            \/\/ Neither prefix match, should fail now (strict or lenient), before\n+            \/\/ position is incremented by subparseNumber(). Otherwise, an empty\n+            \/\/ prefix could pass through here, position gets incremented by the\n+            \/\/ numerical portion, and return a faulty errorIndex and index later.\n+            pos.errorIndex = position;\n+            return null;\n@@ -1708,0 +1763,5 @@\n+            if (parseStrict) {\n+                \/\/ When strict, if -1L was returned, index should be\n+                \/\/ reset to the original index to ensure failure\n+                pos.index = oldStart;\n+            }\n@@ -1889,1 +1949,4 @@\n-            return matchAffix(text, position, suffix, defaultSuffix, matchedSuffix);\n+            \/\/ Suffix must match exactly when strict\n+            return parseStrict ? matchAffix(text, position, suffix, defaultSuffix, matchedSuffix)\n+                    && text.length() == position + suffix.length()\n+                    : matchAffix(text, position, suffix, defaultSuffix, matchedSuffix);\n@@ -1927,1 +1990,1 @@\n-            \/\/ Do not break if a match occur; there is a possibility that the\n+            \/\/ When lenient, do not break if a match occurs; there is a possibility that the\n@@ -1929,2 +1992,3 @@\n-            \/\/ string.\n-            \/\/ For example, matching \"3Mdx\" with \"M\", \"Md\" should match with \"Md\"\n+            \/\/ string. For example, matching \"3Mdx\" with \"M\", \"Md\" should match\n+            \/\/ with \"Md\". However, when strict, break as the match should be exact,\n+            \/\/ and thus no need to check for a longer suffix.\n@@ -1938,0 +2002,4 @@\n+                if (parseStrict) {\n+                    \/\/ when strict, exit early with exact match, same for negative\n+                    break;\n+                }\n@@ -1947,0 +2015,3 @@\n+                if (parseStrict) {\n+                    break;\n+                }\n@@ -1952,0 +2023,1 @@\n+        \/\/ When strict, text must end with the default suffix\n@@ -1955,2 +2027,5 @@\n-            if (text.regionMatches(position, positiveSuffix, 0,\n-                    positiveSuffix.length())) {\n+            boolean containsPosSuffix = text.regionMatches(position,\n+                    positiveSuffix, 0, positiveSuffix.length());\n+            boolean endsWithPosSuffix = containsPosSuffix && text.length() ==\n+                    position + positiveSuffix.length();\n+            if (parseStrict ? endsWithPosSuffix : containsPosSuffix) {\n@@ -1961,2 +2036,5 @@\n-            if (text.regionMatches(position, negativeSuffix, 0,\n-                    negativeSuffix.length())) {\n+            boolean containsNegSuffix = text.regionMatches(position,\n+                    negativeSuffix, 0, negativeSuffix.length());\n+            boolean endsWithNegSuffix = containsNegSuffix && text.length() ==\n+                    position + negativeSuffix.length();\n+            if (parseStrict ? endsWithNegSuffix : containsNegSuffix) {\n@@ -1969,1 +2047,1 @@\n-        \/\/ If both matches, take the longest one\n+        \/\/ If both match, take the longest one\n@@ -2080,0 +2158,1 @@\n+        decimalFormat.setStrict(parseStrict);\n@@ -2319,0 +2398,25 @@\n+    \/**\n+     * {@inheritDoc NumberFormat}\n+     *\n+     * @see #setStrict(boolean)\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public boolean isStrict() {\n+        return parseStrict;\n+    }\n+\n+    \/**\n+     * {@inheritDoc NumberFormat}\n+     *\n+     * @see #isStrict()\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public void setStrict(boolean strict) {\n+        decimalFormat.setStrict(strict);\n+        parseStrict = strict; \/\/ don't call super, default is UOE\n+    }\n+\n@@ -2376,1 +2480,2 @@\n-                && parseBigDecimal == other.parseBigDecimal;\n+                && parseBigDecimal == other.parseBigDecimal\n+                && parseStrict == other.parseStrict;\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":224,"deletions":119,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+\n@@ -58,4 +59,4 @@\n- * {@code NumberFormat} that formats decimal numbers. It has a variety of\n- * features designed to make it possible to parse and format numbers in any\n- * locale, including support for Western, Arabic, and Indic digits.  It also\n- * supports different kinds of numbers, including integers (123), fixed-point\n+ * {@code NumberFormat} that formats decimal numbers in a localized manner.\n+ * It has a variety of features designed to make it possible to parse and format\n+ * numbers in any locale, including support for Western, Arabic, and Indic digits.\n+ * It also supports different kinds of numbers, including integers (123), fixed-point\n@@ -63,1 +64,14 @@\n- * currency amounts ($123).  All of these can be localized.\n+ * currency amounts ($123).\n+ *\n+ * <h2>Getting a DecimalFormat<\/h2>\n+ *\n+ * To obtain a standard decimal format for a specific locale, including the default locale,\n+ * it is recommended to call one of the {@code NumberFormat}\n+ * {@link NumberFormat##factory_methods factory methods}, such as {@link NumberFormat#getInstance()}.\n+ * These factory methods may not always return a {@code DecimalFormat}\n+ * depending on the locale-service provider implementation\n+ * installed. Thus, to use an instance method defined by {@code DecimalFormat},\n+ * the {@code NumberFormat} returned by the factory method should be\n+ * type checked before converted to {@code DecimalFormat}. If the installed locale-sensitive\n+ * service implementation does not support the given {@code Locale}, the parent\n+ * locale chain will be looked up, and a {@code Locale} used that is supported.\n@@ -65,7 +79,3 @@\n- * <p>To obtain a {@code NumberFormat} for a specific locale, including the\n- * default locale, call one of {@code NumberFormat}'s factory methods, such\n- * as {@code getInstance()}.  In general, do not call the\n- * {@code DecimalFormat} constructors directly, since the\n- * {@code NumberFormat} factory methods may return subclasses other than\n- * {@code DecimalFormat}. If you need to customize the format object, do\n- * something like this:\n+ * <p>If the factory methods are not desired, use one of the constructors such\n+ * as {@link #DecimalFormat(String) DecimalFormat(String pattern)}. See the {@link\n+ * ##patterns Pattern} section for more information on the {@code pattern} parameter.\n@@ -73,4 +83,10 @@\n- * <blockquote>{@snippet lang=java :\n- * NumberFormat numFormat = NumberFormat.getInstance(loc);\n- * if (numFormat instanceof DecimalFormat decFormat) {\n- *     decFormat.setDecimalSeparatorAlwaysShown(true);\n+ * <h2>Using DecimalFormat<\/h2>\n+ * The following is an example of formatting and parsing,\n+ * {@snippet lang=java :\n+ * NumberFormat nFmt = NumberFormat.getCurrencyInstance(Locale.US);\n+ * if (nFmt instanceof DecimalFormat dFmt) {\n+ *     \/\/ pattern match to DecimalFormat to use setPositiveSuffix(String)\n+ *     dFmt.setPositiveSuffix(\" dollars\");\n+ *     dFmt.format(100000); \/\/ returns \"$100,000.00 dollars\"\n+ *     dFmt.parse(\"$100,000.00 dollars\"); \/\/ returns 100000\n+ * }\n@@ -78,1 +94,0 @@\n- * }<\/blockquote>\n@@ -80,6 +95,0 @@\n- * <p>A {@code DecimalFormat} comprises a <em>pattern<\/em> and a set of\n- * <em>symbols<\/em>.  The pattern may be set directly using\n- * {@code applyPattern()}, or indirectly using the API methods.  The\n- * symbols are stored in a {@code DecimalFormatSymbols} object.  When using\n- * the {@code NumberFormat} factory methods, the pattern and symbols are\n- * read from localized {@code ResourceBundle}s.\n@@ -87,1 +96,2 @@\n- * <h2 id=\"patterns\">Patterns<\/h2>\n+ * <h2 id=\"formatting\">Formatting and Parsing<\/h2>\n+ * <h3 id=\"rounding\">Rounding<\/h3>\n@@ -89,8 +99,58 @@\n- * Note: For any given {@code DecimalFormat} pattern, if the pattern is not\n- * in scientific notation, the maximum number of integer digits will not be\n- * derived from the pattern, and instead set to {@link Integer#MAX_VALUE}.\n- * Otherwise, if the pattern is in scientific notation, the maximum number of\n- * integer digits will be derived from the pattern. This derivation is detailed\n- * in the {@link ##scientific_notation Scientific Notation} section. This behavior\n- * is the typical end-user desire; {@link #setMaximumIntegerDigits(int)} can be\n- * used to manually adjust the maximum integer digits.\n+ * When formatting, {@code DecimalFormat} can adjust its rounding using {@link\n+ * #setRoundingMode(RoundingMode)}. By default, it uses\n+ * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n+ *\n+ * <h3>Digits<\/h3>\n+ *\n+ * When formatting, {@code DecimalFormat} uses the ten consecutive\n+ * characters starting with the localized zero digit defined in the\n+ * {@code DecimalFormatSymbols} object as digits.\n+ * <p>When parsing, these digits as well as all Unicode decimal digits, as\n+ * defined by {@link Character#digit Character.digit}, are recognized.\n+ *\n+ * <h3 id=\"digit_limits\"> Integer and Fraction Digit Limits <\/h3>\n+ * @implSpec\n+ * When formatting a {@code Number} other than {@code BigInteger} and\n+ * {@code BigDecimal}, {@code 309} is used as the upper limit for integer digits,\n+ * and {@code 340} as the upper limit for fraction digits. This occurs, even if\n+ * one of the {@code DecimalFormat} getter methods, for example, {@link #getMinimumFractionDigits()}\n+ * returns a numerically greater value.\n+ *\n+ * <h3>Special Values<\/h3>\n+ * <ul>\n+ * <li><p><b>Not a Number<\/b> ({@code NaN}) is formatted as a string,\n+ * which is typically given as \"NaN\". This string is determined by {@link\n+ * DecimalFormatSymbols#getNaN()}. This is the only value for which the prefixes\n+ * and suffixes are not attached.\n+ *\n+ * <li><p><b>Infinity<\/b> is formatted as a string, which is typically given as\n+ * \"&#8734;\" ({@code U+221E}), with the positive or negative prefixes and suffixes\n+ * attached. This string is determined by {@link DecimalFormatSymbols#getInfinity()}.\n+ *\n+ * <li><p><b>Negative zero<\/b> ({@code \"-0\"}) parses to\n+ * <ul>\n+ * <li>{@code BigDecimal(0)} if {@code isParseBigDecimal()} is\n+ * true\n+ * <li>{@code Long(0)} if {@code isParseBigDecimal()} is false\n+ *     and {@code isParseIntegerOnly()} is true\n+ * <li>{@code Double(-0.0)} if both {@code isParseBigDecimal()}\n+ * and {@code isParseIntegerOnly()} are false\n+ * <\/ul>\n+ * <\/ul>\n+ *\n+ * <h2><a id=\"synchronization\">Synchronization<\/a><\/h2>\n+ *\n+ * <p>\n+ * Decimal formats are generally not synchronized.\n+ * It is recommended to create separate format instances for each thread.\n+ * If multiple threads access a format concurrently, it must be synchronized\n+ * externally.\n+ *\n+ * <h2 id=\"patterns\">DecimalFormat Pattern<\/h2>\n+ *\n+ * A {@code DecimalFormat} comprises a <em>pattern<\/em> and a set of\n+ * <em>symbols<\/em>. The pattern may be set directly using {@code applyPattern()},\n+ * or indirectly using the various API methods. The symbols are stored in a {@code\n+ * DecimalFormatSymbols} object. When using the {@code NumberFormat} factory\n+ * methods, the pattern and symbols are created from the locale-sensitive service\n+ * implementation installed.\n@@ -137,31 +197,0 @@\n- * <p>A {@code DecimalFormat} pattern contains a positive and negative\n- * subpattern, for example, {@code \"#,##0.00;(#,##0.00)\"}.  Each\n- * subpattern has a prefix, numeric part, and suffix. The negative subpattern\n- * is optional; if absent, then the positive subpattern prefixed with the\n- * minus sign ({@code '-' U+002D HYPHEN-MINUS}) is used as the\n- * negative subpattern. That is, {@code \"0.00\"} alone is equivalent to\n- * {@code \"0.00;-0.00\"}.  If there is an explicit negative subpattern, it\n- * serves only to specify the negative prefix and suffix; the number of digits,\n- * minimal digits, and other characteristics are all the same as the positive\n- * pattern. That means that {@code \"#,##0.0#;(#)\"} produces precisely\n- * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}.\n- *\n- * <p>The prefixes, suffixes, and various symbols used for infinity, digits,\n- * grouping separators, decimal separators, etc. may be set to arbitrary\n- * values, and they will appear properly during formatting.  However, care must\n- * be taken that the symbols and strings do not conflict, or parsing will be\n- * unreliable.  For example, either the positive and negative prefixes or the\n- * suffixes must be distinct for {@code DecimalFormat.parse()} to be able\n- * to distinguish positive from negative values.  (If they are identical, then\n- * {@code DecimalFormat} will behave as if no negative subpattern was\n- * specified.)  Another example is that the decimal separator and grouping\n- * separator should be distinct characters, or parsing will be impossible.\n- *\n- * <p>The grouping separator is commonly used for thousands, but in some\n- * countries it separates ten-thousands. The grouping size is a constant number\n- * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for\n- * 1,0000,0000.  If you supply a pattern with multiple grouping characters, the\n- * interval between the last one and the end of the integer is the one that is\n- * used. So {@code \"#,##,###,####\"} == {@code \"######,####\"} ==\n- * {@code \"##,####,####\"}.\n- *\n@@ -170,3 +199,2 @@\n- * <p>Many characters in a pattern are taken literally; they are matched during\n- * parsing and output unchanged during formatting.  Special characters, on the\n- * other hand, stand for other characters, strings, or classes of characters.\n+ * <p>The special characters in the table below are interpreted syntactically when\n+ * used in the DecimalFormat pattern.\n@@ -176,5 +204,8 @@\n- * <p>The characters listed here are used in non-localized patterns.  Localized\n- * patterns use the corresponding characters taken from this formatter's\n- * {@code DecimalFormatSymbols} object instead, and these characters lose\n- * their special status.  Two exceptions are the currency sign and quote, which\n- * are not localized.\n+ * <p> The characters in the {@code Symbol} column are used in non-localized\n+ * patterns. The corresponding characters in the {@code Localized Symbol} column are used\n+ * in localized patterns, with the characters in {@code Symbol} losing their\n+ * syntactical meaning. Two exceptions are the currency sign ({@code U+00A4}) and\n+ * quote ({@code U+0027}), which are not localized.\n+ * <p>\n+ * Non-localized patterns should be used when calling {@link #applyPattern(String)}.\n+ * Localized patterns should be used when calling {@link #applyLocalizedPattern(String)}.\n@@ -188,0 +219,1 @@\n+ *          <th scope=\"col\" style=\"text-align:left\">Localized Symbol\n@@ -189,2 +221,1 @@\n- *          <th scope=\"col\" style=\"text-align:left\">Localized?\n- *          <th scope=\"col\" style=\"text-align:left\">Meaning\n+ *          <th scope=\"col\" style=\"text-align:left;width:50%\">Meaning\n@@ -193,1 +224,1 @@\n- *     <tr style=\"vertical-align:top\">\n+ *     <tr>\n@@ -195,0 +226,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getZeroDigit()}\n@@ -196,1 +228,0 @@\n- *          <td>Yes\n@@ -198,1 +229,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -200,0 +231,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getDigit()}\n@@ -201,1 +233,0 @@\n- *          <td>Yes\n@@ -203,1 +234,1 @@\n- *     <tr style=\"vertical-align:top\">\n+ *     <tr>\n@@ -205,0 +236,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getDecimalSeparator()}\n@@ -206,1 +238,0 @@\n- *          <td>Yes\n@@ -208,2 +239,3 @@\n- *     <tr style=\"vertical-align: top\">\n- *          <th scope=\"row\">{@code -}\n+ *     <tr>\n+ *          <th scope=\"row\">{@code - (U+002D)}\n+ *          <td>{@link DecimalFormatSymbols#getMinusSign()}\n@@ -211,1 +243,0 @@\n- *          <td>Yes\n@@ -213,1 +244,1 @@\n- *     <tr style=\"vertical-align:top\">\n+ *     <tr>\n@@ -215,0 +246,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getGroupingSeparator()}\n@@ -216,1 +248,0 @@\n- *          <td>Yes\n@@ -218,1 +249,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -220,0 +251,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getExponentSeparator()}\n@@ -221,4 +253,3 @@\n- *          <td>Yes\n- *          <td>Separates mantissa and exponent in scientific notation.\n- *              <em>Need not be quoted in prefix or suffix.<\/em>\n- *     <tr style=\"vertical-align:top\">\n+ *          <td>Separates mantissa and exponent in scientific notation. This value\n+ *              is case sensistive. <em>Need not be quoted in prefix or suffix.<\/em>\n+ *     <tr>\n@@ -226,0 +257,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getPatternSeparator()}\n@@ -227,1 +259,0 @@\n- *          <td>Yes\n@@ -229,1 +260,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -231,0 +262,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getPercent()}\n@@ -232,1 +264,0 @@\n- *          <td>Yes\n@@ -234,2 +265,3 @@\n- *     <tr style=\"vertical-align:top\">\n- *          <th scope=\"row\">{@code U+2030}\n+ *     <tr>\n+ *          <th scope=\"row\">&permil; ({@code U+2030})\n+ *          <td>{@link DecimalFormatSymbols#getPerMill()}\n@@ -237,1 +269,0 @@\n- *          <td>Yes\n@@ -239,1 +270,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -241,0 +272,1 @@\n+ *          <td> n\/a (not localized)\n@@ -242,1 +274,0 @@\n- *          <td>No\n@@ -247,2 +278,3 @@\n- *     <tr style=\"vertical-align:top\">\n- *          <th scope=\"row\">{@code '}\n+ *     <tr>\n+ *          <th scope=\"row\">{@code ' (U+0027)}\n+ *          <td> n\/a (not localized)\n@@ -250,1 +282,0 @@\n- *          <td>No\n@@ -259,0 +290,43 @@\n+ * <h3>Maximum Digits Derivation<\/h3>\n+ * For any given {@code DecimalFormat} pattern, if the pattern is not\n+ * in scientific notation, the maximum number of integer digits will not be\n+ * derived from the pattern, and instead set to {@link Integer#MAX_VALUE}.\n+ * Otherwise, if the pattern is in scientific notation, the maximum number of\n+ * integer digits will be derived from the pattern. This derivation is detailed\n+ * in the {@link ##scientific_notation Scientific Notation} section. {@link\n+ * #setMaximumIntegerDigits(int)} can be used to manually adjust the maximum\n+ * integer digits.\n+ *\n+ * <h3>Negative Subpatterns<\/h3>\n+ * A {@code DecimalFormat} pattern contains a positive and negative\n+ * subpattern, for example, {@code \"#,##0.00;(#,##0.00)\"}.  Each\n+ * subpattern has a prefix, numeric part, and suffix. The negative subpattern\n+ * is optional; if absent, then the positive subpattern prefixed with the\n+ * minus sign {@code '-' (U+002D HYPHEN-MINUS)} is used as the\n+ * negative subpattern. That is, {@code \"0.00\"} alone is equivalent to\n+ * {@code \"0.00;-0.00\"}.  If there is an explicit negative subpattern, it\n+ * serves only to specify the negative prefix and suffix; the number of digits,\n+ * minimal digits, and other characteristics are all the same as the positive\n+ * pattern. That means that {@code \"#,##0.0#;(#)\"} produces precisely\n+ * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}.\n+ *\n+ * <p>The prefixes, suffixes, and various symbols used for infinity, digits,\n+ * grouping separators, decimal separators, etc. may be set to arbitrary\n+ * values, and they will appear properly during formatting.  However, care must\n+ * be taken that the symbols and strings do not conflict, or parsing will be\n+ * unreliable.  For example, either the positive and negative prefixes or the\n+ * suffixes must be distinct for {@code DecimalFormat.parse()} to be able\n+ * to distinguish positive from negative values.  (If they are identical, then\n+ * {@code DecimalFormat} will behave as if no negative subpattern was\n+ * specified.)  Another example is that the decimal separator and grouping\n+ * separator should be distinct characters, or parsing will be impossible.\n+ *\n+ * <h3>Grouping Separator<\/h3>\n+ * <p>The grouping separator is commonly used for thousands, but in some\n+ * locales it separates ten-thousands. The grouping size is a constant number\n+ * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for\n+ * 1,0000,0000. If you supply a pattern with multiple grouping characters, the\n+ * interval between the last one and the end of the integer is the one that is\n+ * used. For example, {@code \"#,##,###,####\"} == {@code \"######,####\"} ==\n+ * {@code \"##,####,####\"}.\n+ *\n@@ -341,85 +415,2 @@\n- * <h3>Rounding<\/h3>\n- *\n- * {@code DecimalFormat} provides rounding modes defined in\n- * {@link java.math.RoundingMode} for formatting.  By default, it uses\n- * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n- *\n- * <h3>Digits<\/h3>\n- *\n- * For formatting, {@code DecimalFormat} uses the ten consecutive\n- * characters starting with the localized zero digit defined in the\n- * {@code DecimalFormatSymbols} object as digits. For parsing, these\n- * digits as well as all Unicode decimal digits, as defined by\n- * {@link Character#digit Character.digit}, are recognized.\n- *\n- * <h3 id=\"digit_limits\"> Integer and Fraction Digit Limits <\/h3>\n- *\n- * @implSpec\n- * When formatting a {@code Number} other than {@code BigInteger} and\n- * {@code BigDecimal}, {@code 309} is used as the upper limit for integer digits,\n- * and {@code 340} as the upper limit for fraction digits. This occurs, even if\n- * one of the {@code DecimalFormat} getter methods, for example, {@link #getMinimumFractionDigits()}\n- * returns a numerically greater value.\n- *\n- * <h4>Special Values<\/h4>\n- *\n- * <p>Not a Number({@code NaN}) is formatted as a string, which typically has a\n- * single character {@code U+FFFD}.  This string is determined by the\n- * {@code DecimalFormatSymbols} object.  This is the only value for which\n- * the prefixes and suffixes are not used.\n- *\n- * <p>Infinity is formatted as a string, which typically has a single character\n- * {@code U+221E}, with the positive or negative prefixes and suffixes\n- * applied.  The infinity string is determined by the\n- * {@code DecimalFormatSymbols} object.\n- *\n- * <p>Negative zero ({@code \"-0\"}) parses to\n- * <ul>\n- * <li>{@code BigDecimal(0)} if {@code isParseBigDecimal()} is\n- * true,\n- * <li>{@code Long(0)} if {@code isParseBigDecimal()} is false\n- *     and {@code isParseIntegerOnly()} is true,\n- * <li>{@code Double(-0.0)} if both {@code isParseBigDecimal()}\n- * and {@code isParseIntegerOnly()} are false.\n- * <\/ul>\n- *\n- * <h3><a id=\"synchronization\">Synchronization<\/a><\/h3>\n- *\n- * <p>\n- * Decimal formats are generally not synchronized.\n- * It is recommended to create separate format instances for each thread.\n- * If multiple threads access a format concurrently, it must be synchronized\n- * externally.\n- *\n- * <h3>Example<\/h3>\n- *\n- * <blockquote>{@snippet lang=java :\n- * \/\/ Print out a number using the localized number, integer, currency,\n- * \/\/ and percent format for each locale\n- * Locale[] locales = NumberFormat.getAvailableLocales();\n- * double myNumber = -1234.56;\n- * NumberFormat form;\n- * for (int j = 0; j < 4; ++j) {\n- *     System.out.println(\"FORMAT\");\n- *     for (Locale locale : locales) {\n- *         if (locale.getCountry().length() == 0) {\n- *             continue; \/\/ Skip language-only locales\n- *         }\n- *         System.out.print(locale.getDisplayName());\n- *         form = switch (j) {\n- *             case 0 -> NumberFormat.getInstance(locale);\n- *             case 1 -> NumberFormat.getIntegerInstance(locale);\n- *             case 2 -> NumberFormat.getCurrencyInstance(locale);\n- *             default -> NumberFormat.getPercentInstance(locale);\n- *         };\n- *         if (form instanceof DecimalFormat decForm) {\n- *             System.out.print(\": \" + decForm.toPattern());\n- *         }\n- *         System.out.print(\" -> \" + form.format(myNumber));\n- *         try {\n- *             System.out.println(\" -> \" + form.parse(form.format(myNumber)));\n- *         } catch (ParseException e) {}\n- *     }\n- * }\n- * }<\/blockquote>\n- *\n+ * @spec         https:\/\/www.unicode.org\/reports\/tr35\n+ *               Unicode Locale Data Markup Language (LDML)\n@@ -430,0 +421,1 @@\n+ * @see          Locale\n@@ -2143,1 +2135,1 @@\n-     * Parses text from a string to produce a {@code Number}.\n+     * {@inheritDoc NumberFormat}\n@@ -2145,10 +2137,24 @@\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and null is returned.\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n+     * <p>\n+     * Parsing fails when <b>lenient<\/b>, if the prefix and\/or suffix are non-empty\n+     * and cannot be found due to parsing ending early, or the first character\n+     * after the prefix cannot be parsed.\n+     * <p>\n+     * Parsing fails when <b>strict<\/b>, if in {@code text},\n+     * <ul>\n+     *   <li> The prefix is not found. For example, a {@code Locale.US} currency\n+     *   format prefix: \"{@code $}\"\n+     *   <li> The suffix is not found. For example, a {@code Locale.US} percent\n+     *   format suffix: \"{@code %}\"\n+     *   <li> {@link #isGroupingUsed()} returns {@code true}, and {@link\n+     *   #getGroupingSize()} is not adhered to\n+     *   <li> {@link #isGroupingUsed()} returns {@code false}, and the grouping\n+     *   symbol is found\n+     *   <li> {@link #isParseIntegerOnly()} returns {@code true}, and the decimal\n+     *   separator is found\n+     *   <li> {@link #isGroupingUsed()} returns {@code true} and {@link\n+     *   #isParseIntegerOnly()} returns {@code false}, and the grouping\n+     *   symbol occurs after the decimal separator\n+     *   <li> Any other characters are found, that are not the expected symbols,\n+     *   and are not digits that occur within the numerical portion\n+     * <\/ul>\n@@ -2374,0 +2380,2 @@\n+        \/\/ position will serve as new index when success, otherwise it will\n+        \/\/ serve as errorIndex when failure\n@@ -2375,0 +2383,3 @@\n+\n+        \/\/ First character after the prefix was un-parseable, should\n+        \/\/ fail regardless if lenient or strict.\n@@ -2381,1 +2392,2 @@\n-        \/\/ Check for suffix\n+        \/\/ When strict, text should end with the suffix.\n+        \/\/ When lenient, text only needs to contain the suffix.\n@@ -2384,2 +2396,5 @@\n-                gotPositive = text.regionMatches(position,positiveSuffix,0,\n-                        positiveSuffix.length());\n+                boolean containsPosSuffix =\n+                        text.regionMatches(position, positiveSuffix, 0, positiveSuffix.length());\n+                boolean endsWithPosSuffix =\n+                        containsPosSuffix && text.length() == position + positiveSuffix.length();\n+                gotPositive = parseStrict ? endsWithPosSuffix : containsPosSuffix;\n@@ -2388,2 +2403,5 @@\n-                gotNegative = text.regionMatches(position,negativeSuffix,0,\n-                        negativeSuffix.length());\n+                boolean containsNegSuffix =\n+                        text.regionMatches(position, negativeSuffix, 0, negativeSuffix.length());\n+                boolean endsWithNegSuffix =\n+                        containsNegSuffix && text.length() == position + negativeSuffix.length();\n+                gotNegative = parseStrict ? endsWithNegSuffix : containsNegSuffix;\n@@ -2407,0 +2425,1 @@\n+            \/\/ No failures, thus increment the index by the suffix\n@@ -2408,1 +2427,1 @@\n-                    (gotPositive ? positiveSuffix.length() : negativeSuffix.length()); \/\/ mark success!\n+                    (gotPositive ? positiveSuffix.length() : negativeSuffix.length());\n@@ -2423,1 +2442,1 @@\n-     * beginning at position, until an unparseable character is seen.\n+     * beginning at {@code position}, until an unparseable character is seen.\n@@ -2441,1 +2460,1 @@\n-        if (!isExponent && text.regionMatches(position,symbols.getInfinity(),0,\n+        if (!isExponent && text.regionMatches(position, symbols.getInfinity(), 0,\n@@ -2470,0 +2489,2 @@\n+            int prevSeparatorIndex = -groupingSize;\n+            int startPos = position; \/\/ Rely on startPos as index after prefix\n@@ -2491,0 +2512,7 @@\n+                \/\/ Enforce the grouping size on the first group\n+                if (parseStrict && isGroupingUsed() && position == startPos + groupingSize\n+                        && prevSeparatorIndex == -groupingSize && !sawDecimal\n+                        && digit >= 0 && digit <= 9) {\n+                    return position;\n+                }\n+\n@@ -2520,0 +2548,4 @@\n+                    \/\/ Check grouping size on decimal separator\n+                    if (parseStrict && isGroupingViolation(position, prevSeparatorIndex)) {\n+                        return groupingViolationIndex(position, prevSeparatorIndex);\n+                    }\n@@ -2528,2 +2560,17 @@\n-                    if (sawDecimal) {\n-                        break;\n+                    if (parseStrict) {\n+                        \/\/ text should not start with grouping when strict\n+                        if (position == startPos) {\n+                            return startPos;\n+                        }\n+                        \/\/ when strict, fail if grouping occurs after decimal OR\n+                        \/\/ current group violates grouping size\n+                        if (sawDecimal || (isGroupingViolation(position, prevSeparatorIndex))) {\n+                            return groupingViolationIndex(position, prevSeparatorIndex);\n+                        }\n+                        prevSeparatorIndex = position; \/\/ track previous\n+                    } else {\n+                        \/\/ when lenient, only exit if grouping occurs after decimal\n+                        \/\/ subsequent grouping symbols are allowed when lenient\n+                        if (sawDecimal) {\n+                            break;\n+                        }\n@@ -2557,0 +2604,17 @@\n+            \/\/ (When strict), within the loop we enforce grouping when encountering\n+            \/\/ decimal\/grouping symbols. Once outside loop, we need to check\n+            \/\/ the final grouping, ex: \"1,234\". Only check the final grouping\n+            \/\/ if we have not seen a decimal separator, to prevent a non needed check,\n+            \/\/ for ex: \"1,234.\", \"1,234.12\"\n+            if (parseStrict) {\n+                if (!sawDecimal && isGroupingViolation(position, prevSeparatorIndex)) {\n+                    \/\/ -1, since position is incremented by one too many when loop is finished\n+                    \/\/ \"1,234%\" and \"1,234\" both end with pos = 5, since '%' breaks\n+                    \/\/ the loop before incrementing position. In both cases, check\n+                    \/\/ should be done at pos = 4\n+                    return groupingViolationIndex(position - 1, prevSeparatorIndex);\n+                }\n+            }\n+\n+            \/\/ If a grouping symbol is not followed by a digit, it must be\n+            \/\/ backed up to either exit early or fail depending on leniency\n@@ -2578,0 +2642,1 @@\n+    }\n@@ -2579,0 +2644,22 @@\n+    \/\/ Checks to make sure grouping size is not violated. Used when strict.\n+    private boolean isGroupingViolation(int pos, int prevGroupingPos) {\n+        assert parseStrict : \"Grouping violations should only occur when strict\";\n+        return isGroupingUsed() && \/\/ Only violates if using grouping\n+                \/\/ Checks if a previous grouping symbol was seen.\n+                prevGroupingPos != -groupingSize &&\n+                \/\/ The check itself, - 1 to account for grouping\/decimal symbol\n+                pos - 1 != prevGroupingPos + groupingSize;\n+    }\n+\n+    \/\/ Calculates the index that violated the grouping size\n+    \/\/ Violation can be over or under the grouping size\n+    \/\/ under - Current group has a grouping size of less than the expected\n+    \/\/ over - Current group has a grouping size of more than the expected\n+    private int groupingViolationIndex(int pos, int prevGroupingPos) {\n+        \/\/ Both examples assume grouping size of 3 and 0 indexed\n+        \/\/ under ex: \"1,23,4\". (4) OR \"1,,2\". (2) When under, violating char is grouping symbol\n+        \/\/ over ex: \"1,2345,6. (5) When over, violating char is the excess digit\n+        \/\/ This method is only evaluated when a grouping symbol is found, thus\n+        \/\/ we can take the minimum of either the current pos, or where we expect\n+        \/\/ the current group to have ended\n+        return Math.min(pos, prevGroupingPos + groupingSize + 1);\n@@ -2891,0 +2978,24 @@\n+    \/**\n+     * {@inheritDoc NumberFormat}\n+     *\n+     * @see #setStrict(boolean)\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public boolean isStrict() {\n+        return parseStrict;\n+    }\n+\n+    \/**\n+     * {@inheritDoc NumberFormat}\n+     *\n+     * @see #isStrict()\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public void setStrict(boolean strict) {\n+        parseStrict = strict;\n+    }\n+\n@@ -2994,1 +3105,2 @@\n-            && symbols.equals(other.symbols);\n+            && symbols.equals(other.symbols)\n+            && parseStrict == other.parseStrict;\n@@ -4179,0 +4291,9 @@\n+    \/**\n+     * True if this {@code DecimalFormat} will parse numbers with strict\n+     * leniency.\n+     *\n+     * @serial\n+     * @since 23\n+     *\/\n+    private boolean parseStrict = false;\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":328,"deletions":207,"binary":false,"changes":535,"status":"modified"},{"patch":"@@ -109,0 +109,3 @@\n+ * <p> Subclasses may also consider implementing leniency when parsing.\n+ * The definition of leniency should be delegated to the subclass.\n+ *\n@@ -213,1 +216,1 @@\n-     * Parses text from a string to produce an object.\n+     * Parses text from the given string to produce an object.\n@@ -215,3 +218,2 @@\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n+     * This method attempts to parse text starting at the index given by\n+     * {@code pos}. If parsing succeeds, then the index of {@code pos} is updated\n@@ -224,1 +226,1 @@\n-     * the character where the error occurred, and null is returned.\n+     * the character where the error occurred, and {@code null} is returned.\n@@ -226,1 +228,1 @@\n-     * @param source A {@code String}, part of which should be parsed.\n+     * @param source the {@code String} to parse\n@@ -230,2 +232,3 @@\n-     *         error, returns null.\n-     * @throws NullPointerException if {@code source} or {@code pos} is null.\n+     *         error, returns {@code null}.\n+     * @throws NullPointerException if {@code source} or {@code pos} is\n+     *         {@code null}.\n@@ -237,1 +240,1 @@\n-     * The method may not use the entire text of the given string.\n+     * This method may not use the entire text of the given string.\n@@ -239,1 +242,1 @@\n-     * @param source A {@code String} whose beginning should be parsed.\n+     * @param source A {@code String}, to be parsed from the beginning.\n@@ -241,3 +244,2 @@\n-     * @throws    ParseException if the beginning of the specified string\n-     *            cannot be parsed.\n-     * @throws NullPointerException if {@code source} is null.\n+     * @throws ParseException if parsing fails\n+     * @throws NullPointerException if {@code source} is {@code null}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.io.InvalidObjectException;\n@@ -43,0 +42,1 @@\n+import java.io.InvalidObjectException;\n@@ -55,0 +55,1 @@\n+\n@@ -61,2 +62,6 @@\n- * numbers. {@code NumberFormat} also provides methods for determining\n- * which locales have number formats, and what their names are.\n+ * numbers in a localized manner. This enables code that can be completely\n+ * independent of the locale conventions for decimal points, thousands-separators,\n+ * the particular decimal digits used, or whether the number format is even\n+ * decimal. For example, this class could be used within an application to\n+ * produce a number in a currency format according to the conventions of the desired\n+ * locale.\n@@ -64,5 +69,17 @@\n- * <p>\n- * {@code NumberFormat} helps you to format and parse numbers for any locale.\n- * Your code can be completely independent of the locale conventions for\n- * decimal points, thousands-separators, or even the particular decimal\n- * digits used, or whether the number format is even decimal.\n+ * <h2 id=\"factory_methods\">Getting a NumberFormat<\/h2>\n+ * To get a {@code NumberFormat} for the default Locale, use one of the static\n+ * factory methods that return a concrete subclass of {@code NumberFormat}.\n+ * The following formats all provide an example of formatting the {@code Number}\n+ * \"2000.50\" with the {@link java.util.Locale#US US} locale as the default locale.\n+ * <ul>\n+ * <li> Use {@link #getInstance()} or {@link #getNumberInstance()} to get\n+ * a decimal format. For example, {@code \"2,000.5\"}.\n+ * <li> Use {@link #getIntegerInstance()} to get an integer number format.\n+ * For example, {@code \"2,000\"}.\n+ * <li> Use {@link #getCurrencyInstance} to get a currency number format.\n+ * For example, {@code \"$2,000.50\"}.\n+ * <li> Use {@link #getCompactNumberInstance} to get a compact number format.\n+ * For example, {@code \"2K\"}.\n+ * <li> Use {@link #getPercentInstance} to get a format for displaying percentages.\n+ * For example, {@code \"200,050%\"}.\n+ * <\/ul>\n@@ -70,27 +87,5 @@\n- * <p>\n- * To format a number for the current Locale, use one of the factory\n- * class methods:\n- * <blockquote>\n- * {@snippet lang=java :\n- * myString = NumberFormat.getInstance().format(myNumber);\n- * }\n- * <\/blockquote>\n- * If you are formatting multiple numbers, it is\n- * more efficient to get the format and use it multiple times so that\n- * the system doesn't have to fetch the information about the local\n- * language and country conventions multiple times.\n- * <blockquote>\n- * {@snippet lang=java :\n- * NumberFormat nf = NumberFormat.getInstance();\n- * for (var myNumber : numbers) {\n- *     output.println(nf.format(myNumber) + \"; \");\n- * }\n- * }\n- * <\/blockquote>\n- * To format a number for a different Locale, specify it in the\n- * call to {@code getInstance}.\n- * <blockquote>\n- * {@snippet lang=java :\n- * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);\n- * }\n- * <\/blockquote>\n+ * Alternatively, if a {@code NumberFormat} for a different locale is required, use\n+ * one of the overloaded factory methods that take {@code Locale} as a parameter,\n+ * for example, {@link #getIntegerInstance(Locale)}. If the installed locale-sensitive\n+ * service implementation does not support the given {@code Locale}, the parent\n+ * locale chain will be looked up, and a {@code Locale} used that is supported.\n@@ -98,1 +93,2 @@\n- * <p>If the locale contains \"nu\" (numbers) and\/or \"rg\" (region override)\n+ * <h3>Locale Extensions<\/h3>\n+ * Formatting behavior can be changed when using a locale that contains any of the following\n@@ -100,1 +96,12 @@\n- * the decimal digits, and\/or the country used for formatting are overridden.\n+ * <ul>\n+ * <li> \"nu\"\n+ * (<a href=\"https:\/\/unicode.org\/reports\/tr35\/#UnicodeNumberSystemIdentifier\">\n+ * Numbering System<\/a>) - Overrides the decimal digits used\n+ * <li> \"rg\"\n+ * (<a href=\"https:\/\/unicode.org\/reports\/tr35\/#RegionOverride\">\n+ * Region Override<\/a>) - Overrides the country used\n+ * <li> \"cf\"\n+ * (<a href=\"https:\/\/www.unicode.org\/reports\/tr35\/tr35.html#UnicodeCurrencyFormatIdentifier\">\n+ * Currency Format style<\/a>) - Overrides the Currency Format style used\n+ * <\/ul>\n+ * <p>\n@@ -103,0 +110,8 @@\n+ * Although <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>\n+ * defines various keys and values, actual locale-sensitive service implementations\n+ * in a Java Runtime Environment might not support any particular Unicode locale\n+ * attributes or key\/type pairs.\n+ * <p>Below is an example of a \"US\" locale currency format with accounting style,\n+ * <blockquote>{@code NumberFormat.getCurrencyInstance(Locale.forLanguageTag(\"en-US-u-cf-account\"));}<\/blockquote>\n+ * With this style, a negative value is formatted enclosed in parentheses, instead\n+ * of being prepended with a minus sign.\n@@ -104,2 +119,2 @@\n- * <p>You can also use a {@code NumberFormat} to parse numbers:\n- * <blockquote>\n+ * <h2>Using NumberFormat<\/h2>\n+ * The following is an example of formatting and parsing in a localized fashion,\n@@ -107,1 +122,3 @@\n- * myNumber = nf.parse(myString);\n+ * NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(Locale.US);\n+ * currencyFormat.format(100000); \/\/ returns \"$100,000.00\"\n+ * currencyFormat.parse(\"$100,000.00\"); \/\/ returns 100000\n@@ -109,10 +126,0 @@\n- * <\/blockquote>\n- * Use {@code getInstance} or {@code getNumberInstance} to get the\n- * normal number format. Use {@code getIntegerInstance} to get an\n- * integer number format. Use {@code getCurrencyInstance} to get the\n- * currency number format. Use {@code getCompactNumberInstance} to get the\n- * compact number format to format a number in shorter form. For example,\n- * {@code 2000} can be formatted as {@code \"2K\"} in\n- * {@link java.util.Locale#US US locale}. Use {@code getPercentInstance}\n- * to get a format for displaying percentages. With this format, a fraction\n- * like 0.53 is displayed as 53%.\n@@ -120,10 +127,15 @@\n- * <p>\n- * You can also control the display of numbers with such methods as\n- * {@code setMinimumFractionDigits}.\n- * If you want even more control over the format or parsing,\n- * or want to give your users more control,\n- * you can try casting the {@code NumberFormat} you get from the factory methods\n- * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on\n- * the factory method used. This will work for the vast majority of locales;\n- * just remember to put it in a {@code try} block in case you encounter\n- * an unusual one.\n+ * <h2>Customizing NumberFormat<\/h2>\n+ * {@code NumberFormat} provides API to customize formatting and parsing behavior,\n+ * <ul>\n+ * <li> {@link #setParseIntegerOnly(boolean)}; when {@code true}, will only return the\n+ * integer portion of the number parsed from the String.\n+ * <li> {@link #setMinimumFractionDigits(int)}; Use to adjust the expected digits when\n+ * formatting. Use any of the other minimum\/maximum or fraction\/integer setter methods\n+ * in the same manner.\n+ * <li> {@link #setGroupingUsed(boolean)}; when {@code true}, formatted numbers will be displayed\n+ * with grouping separators. Additionally, when {@code false}, parsing will not expect\n+ * grouping separators in the parsed String.\n+ * <li> {@link #setStrict(boolean)}; when {@code true}, parsing will be done strictly.\n+ * The behavior of strict parsing should be referred to in the implementing\n+ * {@code NumberFormat} subclass.\n+ * <\/ul>\n@@ -132,18 +144,14 @@\n- * NumberFormat and DecimalFormat are designed such that some controls\n- * work for formatting and others work for parsing.  The following is\n- * the detailed description for each these control methods,\n- * <p>\n- * setParseIntegerOnly : only affects parsing, e.g.\n- * if true,  \"3456.78\" &rarr; 3456 (and leaves the parse position just after index 6)\n- * if false, \"3456.78\" &rarr; 3456.78 (and leaves the parse position just after index 8)\n- * This is independent of formatting.  If you want to not show a decimal point\n- * where there might be no digits after the decimal point, use\n- * setDecimalSeparatorAlwaysShown.\n- * <p>\n- * setDecimalSeparatorAlwaysShown : only affects formatting, and only where\n- * there might be no digits after the decimal point, such as with a pattern\n- * like \"#,##0.##\", e.g.,\n- * if true,  3456.00 &rarr; \"3,456.\"\n- * if false, 3456.00 &rarr; \"3456\"\n- * This is independent of parsing.  If you want parsing to stop at the decimal\n- * point, use setParseIntegerOnly.\n+ * To provide more control over formatting or parsing behavior, type checking can\n+ * be done to safely convert to an implementing subclass of {@code NumberFormat}; this\n+ * provides additional methods defined by the subclass.\n+ * For example,\n+ * {@snippet lang=java :\n+ * NumberFormat nFmt = NumberFormat.getInstance(Locale.US);\n+ * if (nFmt instanceof DecimalFormat dFmt) {\n+ *     dFmt.setDecimalSeparatorAlwaysShown(true);\n+ *     dFmt.format(100); \/\/ returns \"100.\"\n+ * }\n+ * }\n+ * The {@code NumberFormat} subclass returned by the factory methods is dependent\n+ * on the locale-service provider implementation installed, and may not always\n+ * be {@link DecimalFormat} or {@link CompactNumberFormat}.\n@@ -156,2 +164,2 @@\n- * <li> progressively parse through pieces of a string\n- * <li> align the decimal point and other areas\n+ * <li> Progressively parse through pieces of a string\n+ * <li> Align the decimal point and other areas\n@@ -178,2 +186,10 @@\n- * <h2><a id=\"synchronization\">Synchronization<\/a><\/h2>\n- *\n+ * <h2><a id=\"leniency\">Leniency<\/a><\/h2>\n+ * {@code NumberFormat} by default, parses leniently. Subclasses may consider\n+ * implementing strict parsing and as such, overriding and providing\n+ * implementations for the optional {@link #isStrict()} and {@link\n+ * #setStrict(boolean)} methods.\n+ * <p>\n+ * Lenient parsing should be used when attempting to parse a number\n+ * out of a String that contains non-numerical or non-format related values.\n+ * For example, using a {@link Locale#US} currency format to parse the number\n+ * {@code 1000} out of the String \"$1,000.00 was paid\".\n@@ -181,0 +197,6 @@\n+ * Strict parsing should be used when attempting to ensure a String adheres exactly\n+ * to a locale's conventions, and can thus serve to validate input. For example, successfully\n+ * parsing the number {@code 1000.55} out of the String \"1.000,55\" confirms the String\n+ * exactly adhered to the {@link Locale#GERMANY} numerical conventions.\n+ *\n+ * <h2><a id=\"synchronization\">Synchronization<\/a><\/h2>\n@@ -186,1 +208,4 @@\n- * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},\n+ * @implSpec\n+ * Null Parameter Handling\n+ * <ul>\n+ * <li> The {@link #format(double, StringBuffer, FieldPosition)},\n@@ -192,0 +217,1 @@\n+ * <\/ul>\n@@ -193,2 +219,3 @@\n- * <p>\n- * The default implementation provides rounding modes defined\n+ * Default RoundingMode\n+ * <ul>\n+ * <li> The default implementation provides rounding modes defined\n@@ -203,0 +230,1 @@\n+ * <\/ul>\n@@ -204,0 +232,2 @@\n+ * @spec         https:\/\/www.unicode.org\/reports\/tr35\n+ *               Unicode Locale Data Markup Language (LDML)\n@@ -207,0 +237,1 @@\n+ * @see          Locale\n@@ -288,15 +319,1 @@\n-     * Parses text from a string to produce a {@code Number}.\n-     * <p>\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and null is returned.\n-     * <p>\n-     * See the {@link #parse(String, ParsePosition)} method for more information\n-     * on number parsing.\n+     * {@inheritDoc Format}\n@@ -304,1 +321,3 @@\n-     * @param source A {@code String}, part of which should be parsed.\n+     * @implSpec This implementation is equivalent to calling {@code parse(source,\n+     *           pos)}.\n+     * @param source the {@code String} to parse\n@@ -402,1 +421,14 @@\n-     * Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,\n+     * Parses text from the beginning of the given string to produce a {@code Number}.\n+     * <p>\n+     * This method attempts to parse text starting at the index given by the\n+     * {@code ParsePosition}. If parsing succeeds, then the index of the {@code\n+     * ParsePosition} is updated to the index after the last character used\n+     * (parsing does not necessarily use all characters up to the end of the\n+     * string), and the parsed number is returned. The updated {@code\n+     * ParsePosition} can be used to indicate the starting\n+     * point for the next call to this method. If an error occurs, then the\n+     * index of the {@code ParsePosition} is not changed, the error index of the\n+     * {@code ParsePosition} is set to the index of the character where the error\n+     * occurred, and {@code null} is returned.\n+     * <p>\n+     * This method will return a Long if possible (e.g., within the range [Long.MIN_VALUE,\n@@ -404,11 +436,9 @@\n-     * If IntegerOnly is set, will stop at a decimal\n-     * point (or equivalent; e.g., for rational numbers \"1 2\/3\", will stop\n-     * after the 1).\n-     * Does not throw an exception; if no object can be parsed, index is\n-     * unchanged!\n-     *\n-     * @param source the String to parse\n-     * @param parsePosition the parse position\n-     * @return the parsed value\n-     * @see java.text.NumberFormat#isParseIntegerOnly\n-     * @see java.text.Format#parseObject\n+     *\n+     * @param source the {@code String} to parse\n+     * @param parsePosition A {@code ParsePosition} object with index and error\n+     *            index information as described above.\n+     * @return A {@code Number} parsed from the string. In case of\n+     *         failure, returns {@code null}.\n+     * @throws NullPointerException if {@code source} or {@code ParsePosition}\n+     *         is {@code null}.\n+     * @see #isStrict()\n@@ -419,2 +449,1 @@\n-     * Parses text from the beginning of the given string to produce a number.\n-     * The method may not use the entire text of the given string.\n+     * Parses text from the beginning of the given string to produce a {@code Number}.\n@@ -422,2 +451,2 @@\n-     * See the {@link #parse(String, ParsePosition)} method for more information\n-     * on number parsing.\n+     * This method will return a Long if possible (e.g., within the range [Long.MIN_VALUE,\n+     * Long.MAX_VALUE] and with no decimals), otherwise a Double.\n@@ -425,1 +454,1 @@\n-     * @param source A {@code String} whose beginning should be parsed.\n+     * @param source A {@code String}, to be parsed from the beginning.\n@@ -427,2 +456,3 @@\n-     * @throws    ParseException if the beginning of the specified string\n-     *            cannot be parsed.\n+     * @throws ParseException if parsing fails\n+     * @throws NullPointerException if {@code source} is {@code null}.\n+     * @see #isStrict()\n@@ -466,0 +496,38 @@\n+    \/**\n+     * {@return {@code true} if this format will parse numbers strictly;\n+     * {@code false} otherwise}\n+     *\n+     * @implSpec The default implementation always throws {@code\n+     * UnsupportedOperationException}. Subclasses should override this method\n+     * when implementing strict parsing.\n+     * @throws    UnsupportedOperationException if the implementation of this\n+     *            method does not support this operation\n+     * @see ##leniency Leniency Section\n+     * @see #setStrict(boolean)\n+     * @since 23\n+     *\/\n+    public boolean isStrict() {\n+        throw new UnsupportedOperationException(\"Subclasses should override this \" +\n+                \"method when implementing strict parsing\");\n+    }\n+\n+    \/**\n+     * Change the leniency value for parsing. Parsing can either be strict or lenient,\n+     * by default it is lenient.\n+     *\n+     * @implSpec The default implementation always throws {@code\n+     * UnsupportedOperationException}. Subclasses should override this method\n+     * when implementing strict parsing.\n+     * @param strict {@code true} if parsing should be done strictly;\n+     *               {@code false} otherwise\n+     * @throws    UnsupportedOperationException if the implementation of this\n+     *            method does not support this operation\n+     * @see ##leniency Leniency Section\n+     * @see #isStrict()\n+     * @since 23\n+     *\/\n+    public void setStrict(boolean strict) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this \" +\n+                \"method when implementing strict parsing\");\n+    }\n+\n@@ -762,1 +830,1 @@\n-        return (maximumIntegerDigits == other.maximumIntegerDigits\n+        return maximumIntegerDigits == other.maximumIntegerDigits\n@@ -767,1 +835,1 @@\n-            && parseIntegerOnly == other.parseIntegerOnly);\n+            && parseIntegerOnly == other.parseIntegerOnly;\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":190,"deletions":122,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -589,0 +589,3 @@\n+     * <p>\n+     * Range of InstantSeconds is between {@link Instant#MIN} and {@link Instant#MAX}\n+     * {@linkplain Instant#getEpochSecond() epoch second}, both inclusive.\n@@ -590,1 +593,1 @@\n-    INSTANT_SECONDS(\"InstantSeconds\", SECONDS, FOREVER, ValueRange.of(Long.MIN_VALUE, Long.MAX_VALUE)),\n+    INSTANT_SECONDS(\"InstantSeconds\", SECONDS, FOREVER, ValueRange.of(Instant.MIN.getEpochSecond(), Instant.MAX.getEpochSecond())),\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/ChronoField.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,540 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.util;\n-\n-import java.io.IOException;\n-import java.lang.invoke.*;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.nio.ByteOrder;\n-import java.nio.charset.StandardCharsets;\n-import java.text.DecimalFormatSymbols;\n-import java.util.Formatter.FormatSpecifier;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.util.FormatConcatItem;\n-import jdk.internal.util.DecimalDigits;\n-import jdk.internal.util.HexDigits;\n-import jdk.internal.util.OctalDigits;\n-\n-import static java.lang.invoke.MethodType.methodType;\n-\n-\/**\n- * A specialized objects used by FormatterBuilder that knows how to insert\n- * themselves into a concatenation performed by StringConcatFactory.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-class FormatItem {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    private static final MethodHandle CHAR_MIX =\n-            JLA.stringConcatHelper(\"mix\",\n-                    MethodType.methodType(long.class, long.class,char.class));\n-\n-    private static final MethodHandle STRING_PREPEND =\n-            JLA.stringConcatHelper(\"prepend\",\n-                    MethodType.methodType(long.class, long.class, byte[].class,\n-                            String.class));\n-\n-    private static final MethodHandle SELECT_GETCHAR_MH =\n-            JLA.stringConcatHelper(\"selectGetChar\",\n-                    MethodType.methodType(MethodHandle.class, long.class));\n-\n-    private static final MethodHandle SELECT_PUTCHAR_MH =\n-            JLA.stringConcatHelper(\"selectPutChar\",\n-                    MethodType.methodType(MethodHandle.class, long.class));\n-\n-    private static long charMix(long lengthCoder, char value) {\n-        try {\n-            return (long)CHAR_MIX.invokeExact(lengthCoder, value);\n-        } catch (Error | RuntimeException ex) {\n-            throw ex;\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(ex);\n-        }\n-    }\n-\n-    private static long stringMix(long lengthCoder, String value) {\n-        return JLA.stringConcatMix(lengthCoder, value);\n-    }\n-\n-    private static long stringPrepend(long lengthCoder, byte[] buffer,\n-                                            String value) throws Throwable {\n-        return (long)STRING_PREPEND.invokeExact(lengthCoder, buffer, value);\n-    }\n-\n-    private static MethodHandle selectGetChar(long indexCoder) throws Throwable {\n-        return (MethodHandle)SELECT_GETCHAR_MH.invokeExact(indexCoder);\n-    }\n-\n-    private static MethodHandle selectPutChar(long indexCoder) throws Throwable {\n-        return (MethodHandle)SELECT_PUTCHAR_MH.invokeExact(indexCoder);\n-    }\n-\n-    private static final MethodHandle PUT_CHAR_DIGIT;\n-\n-    static {\n-        try {\n-            Lookup lookup = MethodHandles.lookup();\n-            PUT_CHAR_DIGIT = lookup.findStatic(FormatItem.class, \"putByte\",\n-                    MethodType.methodType(void.class,\n-                            byte[].class, int.class, int.class));\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(\"putByte lookup failed\", ex);\n-        }\n-    }\n-\n-    private static void putByte(byte[] buffer, int index, int ch) {\n-        buffer[index] = (byte)ch;\n-    }\n-\n-    private FormatItem() {\n-        throw new AssertionError(\"private constructor\");\n-    }\n-\n-    \/**\n-     * Decimal value format item.\n-     *\/\n-    static final class FormatItemDecimal implements FormatConcatItem {\n-        private final char groupingSeparator;\n-        private final char zeroDigit;\n-        private final char minusSign;\n-        private final int digitOffset;\n-        private final byte[] digits;\n-        private final int length;\n-        private final boolean isNegative;\n-        private final int width;\n-        private final byte prefixSign;\n-        private final int groupSize;\n-        private final long value;\n-        private final boolean parentheses;\n-\n-        FormatItemDecimal(DecimalFormatSymbols dfs, int width, char sign,\n-                          boolean parentheses, int groupSize, long value) throws Throwable {\n-            this.groupingSeparator = dfs.getGroupingSeparator();\n-            this.zeroDigit = dfs.getZeroDigit();\n-            this.minusSign = dfs.getMinusSign();\n-            this.digitOffset = this.zeroDigit - '0';\n-            int length = DecimalDigits.INSTANCE.size(value);\n-            this.digits = new byte[length];\n-            DecimalDigits.INSTANCE.digits(value, this.digits, length, PUT_CHAR_DIGIT);\n-            this.isNegative = value < 0L;\n-            this.length = this.isNegative ? length - 1 : length;\n-            this.width = width;\n-            this.groupSize = groupSize;\n-            this.value = value;\n-            this.parentheses = parentheses && isNegative;\n-            this.prefixSign = (byte)(isNegative ? (parentheses ? '\\0' : minusSign) : sign);\n-        }\n-\n-        private int signLength() {\n-            return (prefixSign != '\\0' ? 1 : 0) + (parentheses ? 2 : 0);\n-        }\n-\n-        private int groupLength() {\n-            return 0 < groupSize ? (length - 1) \/ groupSize : 0;\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return JLA.stringConcatCoder(zeroDigit) |\n-                    (lengthCoder +\n-                     Integer.max(length + signLength() + groupLength(), width));\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            if (parentheses) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)')');\n-            }\n-\n-            if (0 < groupSize) {\n-                int groupIndex = groupSize;\n-\n-                for (int i = 1; i <= length; i++) {\n-                    if (groupIndex-- == 0) {\n-                        putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                                (int)groupingSeparator);\n-                        groupIndex = groupSize - 1;\n-                    }\n-\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n-                }\n-            } else {\n-                for (int i = 1; i <= length; i++) {\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n-                }\n-            }\n-\n-            for (int i = length + signLength() + groupLength(); i < width; i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n-            }\n-\n-            if (parentheses) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'(');\n-            }\n-            if (prefixSign != '\\0') {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)prefixSign);\n-            }\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-    \/**\n-     * Hexadecimal format item.\n-     *\/\n-    static final class FormatItemHexadecimal implements FormatConcatItem {\n-        private final int width;\n-        private final boolean hasPrefix;\n-        private final long value;\n-        private final int length;\n-\n-        FormatItemHexadecimal(int width, boolean hasPrefix, long value) {\n-            this.width = width;\n-            this.hasPrefix = hasPrefix;\n-            this.value = value;\n-            this.length = HexDigits.INSTANCE.size(value);\n-        }\n-\n-        private int prefixLength() {\n-            return hasPrefix ? 2 : 0;\n-        }\n-\n-        private int zeroesLength() {\n-            return Integer.max(0, width - length - prefixLength());\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return lengthCoder + length + prefixLength() + zeroesLength();\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            HexDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n-            lengthCoder -= length;\n-\n-            for (int i = 0; i < zeroesLength(); i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n-            }\n-\n-            if (hasPrefix) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'x');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n-            }\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-    \/**\n-     * Hexadecimal format item.\n-     *\/\n-    static final class FormatItemOctal implements FormatConcatItem {\n-        private final int width;\n-        private final boolean hasPrefix;\n-        private final long value;\n-        private final int length;\n-\n-        FormatItemOctal(int width, boolean hasPrefix, long value) {\n-            this.width = width;\n-            this.hasPrefix = hasPrefix;\n-            this.value = value;\n-            this.length = OctalDigits.INSTANCE.size(value);\n-        }\n-\n-        private int prefixLength() {\n-            return hasPrefix && value != 0 ? 1 : 0;\n-        }\n-\n-        private int zeroesLength() {\n-            return Integer.max(0, width - length - prefixLength());\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return lengthCoder + length + prefixLength() + zeroesLength();\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            OctalDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n-            lengthCoder -= length;\n-\n-            for (int i = 0; i < zeroesLength(); i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n-            }\n-\n-            if (hasPrefix && value != 0) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n-            }\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-    \/**\n-     * Boolean format item.\n-     *\/\n-    static final class FormatItemBoolean implements FormatConcatItem {\n-        private final boolean value;\n-\n-        FormatItemBoolean(boolean value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return lengthCoder + (value ? \"true\".length() : \"false\".length());\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            if (value) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'r');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'t');\n-            } else {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'s');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'a');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'f');\n-            }\n-\n-            return lengthCoder;\n-         }\n-    }\n-\n-    \/**\n-     * Character format item.\n-     *\/\n-    static final class FormatItemCharacter implements FormatConcatItem {\n-        private final char value;\n-\n-        FormatItemCharacter(char value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return charMix(lengthCoder, value);\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)value);\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-    \/**\n-     * String format item.\n-     *\/\n-    static final class FormatItemString implements FormatConcatItem {\n-        private String value;\n-\n-        FormatItemString(String value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return stringMix(lengthCoder, value);\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            return stringPrepend(lengthCoder, buffer, value);\n-        }\n-    }\n-\n-    \/**\n-     * FormatSpecifier format item.\n-     *\/\n-    static final class FormatItemFormatSpecifier implements FormatConcatItem {\n-        private StringBuilder sb;\n-\n-        FormatItemFormatSpecifier(FormatSpecifier fs, Locale locale, Object value) {\n-            this.sb = new StringBuilder(64);\n-            Formatter formatter = new Formatter(this.sb, locale);\n-\n-            try {\n-                fs.print(formatter, value, locale);\n-            } catch (IOException ex) {\n-                throw new AssertionError(\"FormatItemFormatSpecifier IOException\", ex);\n-            }\n-        }\n-\n-        FormatItemFormatSpecifier(Locale locale,\n-                                  int flags, int width, int precision,\n-                                  Formattable formattable) {\n-            this.sb = new StringBuilder(64);\n-            Formatter formatter = new Formatter(this.sb, locale);\n-            formattable.formatTo(formatter, flags, width, precision);\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return JLA.stringBuilderConcatMix(lengthCoder, sb);\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            return JLA.stringBuilderConcatPrepend(lengthCoder, buffer, sb);\n-        }\n-    }\n-\n-    abstract static sealed class FormatItemModifier implements FormatConcatItem\n-        permits FormatItemFillLeft,\n-                FormatItemFillRight\n-    {\n-        private final long itemLengthCoder;\n-        protected final FormatConcatItem item;\n-\n-        FormatItemModifier(FormatConcatItem item) {\n-            this.itemLengthCoder = item.mix(0L);\n-            this.item = item;\n-        }\n-\n-        int length() {\n-            return (int)itemLengthCoder;\n-        }\n-\n-        long coder() {\n-            return itemLengthCoder & ~Integer.MAX_VALUE;\n-        }\n-\n-        @Override\n-        public abstract long mix(long lengthCoder);\n-\n-        @Override\n-        public abstract long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n-    }\n-\n-    \/**\n-     * Fill left format item.\n-     *\/\n-    static final class FormatItemFillLeft extends FormatItemModifier\n-            implements FormatConcatItem {\n-        private final int width;\n-\n-        FormatItemFillLeft(int width, FormatConcatItem item) {\n-            super(item);\n-            this.width = Integer.max(length(), width);\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return (lengthCoder | coder()) + width;\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            lengthCoder = item.prepend(lengthCoder, buffer);\n-\n-            for (int i = length(); i < width; i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n-            }\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-    \/**\n-     * Fill right format item.\n-     *\/\n-    static final class FormatItemFillRight extends FormatItemModifier\n-            implements FormatConcatItem {\n-        private final int width;\n-\n-        FormatItemFillRight(int width, FormatConcatItem item) {\n-            super(item);\n-            this.width = Integer.max(length(), width);\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return (lengthCoder | coder()) + width;\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            for (int i = length(); i < width; i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n-            }\n-\n-            lengthCoder = item.prepend(lengthCoder, buffer);\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-\n-    \/**\n-     * Null format item.\n-     *\/\n-    static final class FormatItemNull implements FormatConcatItem {\n-        FormatItemNull() {\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return lengthCoder + \"null\".length();\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'n');\n-\n-            return lengthCoder;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":0,"deletions":540,"binary":false,"changes":540,"status":"deleted"},{"patch":"@@ -1,299 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Alibaba Group Holding Limited. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.util;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.StringTemplate.Processor;\n-import java.lang.StringTemplate.Processor.Linkage;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * This {@link Processor} constructs a {@link String} result using\n- * {@link Formatter} specifications and values found in the {@link StringTemplate}.\n- * Unlike {@link Formatter}, {@link FormatProcessor} uses the value from the\n- * embedded expression that immediately follows, without whitespace, the\n- * <a href=\"..\/util\/Formatter.html#syntax\">format specifier<\/a>.\n- * For example:\n- * {@snippet :\n- * FormatProcessor fmt = FormatProcessor.create(Locale.ROOT);\n- * int x = 10;\n- * int y = 20;\n- * String result = fmt.\"%05d\\{x} + %05d\\{y} = %05d\\{x + y}\";\n- * }\n- * In the above example, the value of {@code result} will be {@code \"00010 + 00020 = 00030\"}.\n- * <p>\n- * Embedded expressions without a preceeding format specifier, use {@code %s}\n- * by default.\n- * {@snippet :\n- * FormatProcessor fmt = FormatProcessor.create(Locale.ROOT);\n- * int x = 10;\n- * int y = 20;\n- * String result1 = fmt.\"\\{x} + \\{y} = \\{x + y}\";\n- * String result2 = fmt.\"%s\\{x} + %s\\{y} = %s\\{x + y}\";\n- * }\n- * In the above example, the value of {@code result1} and {@code result2} will\n- * both be {@code \"10 + 20 = 30\"}.\n- * <p>\n- * The {@link FormatProcessor} format specification used and exceptions thrown are the\n- * same as those of {@link Formatter}.\n- * <p>\n- * However, there are two significant differences related to the position of arguments.\n- * An explict {@code n$} and relative {@code <} index will cause an exception due to\n- * a missing argument list.\n- * Whitespace appearing between the specification and the embedded expression will\n- * also cause an exception.\n- * <p>\n- * {@link FormatProcessor} allows the use of different locales. For example:\n- * {@snippet :\n- * Locale locale = Locale.forLanguageTag(\"th-TH-u-nu-thai\");\n- * FormatProcessor thaiFMT = FormatProcessor.create(locale);\n- * int x = 10;\n- * int y = 20;\n- * String result = thaiFMT.\"%4d\\{x} + %4d\\{y} = %5d\\{x + y}\";\n- * }\n- * In the above example, the value of {@code result} will be\n- * {@code \"  \\u0E51\\u0E50 +   \\u0E52\\u0E50 =    \\u0E53\\u0E50\"}.\n- * <p>\n- * For day to day use, the predefined {@link FormatProcessor#FMT} {@link FormatProcessor}\n- * is available. {@link FormatProcessor#FMT} is defined using the {@link Locale#ROOT}.\n- * Example: {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * String result = FMT.\"0x%04x\\{x} + 0x%04x\\{y} = 0x%04x\\{x + y}\"; \/\/ @highlight substring=\"FMT\"\n- * }\n- * In the above example, the value of {@code result} will be {@code \"0x000a + 0x0014 = 0x001E\"}.\n- *\n- * @since 21\n- *\n- * @see Processor\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-public final class FormatProcessor implements Processor<String, RuntimeException>, Linkage {\n-    \/**\n-     * {@link Locale} used to format\n-     *\/\n-    private final Locale locale;\n-\n-    \/**\n-     * Constructor.\n-     *\n-     * @param locale  {@link Locale} used to format\n-     *\/\n-    private FormatProcessor(Locale locale) {\n-        this.locale = locale;\n-    }\n-\n-    \/**\n-     * Create a new {@link FormatProcessor} using the specified locale.\n-     *\n-     * @param locale {@link Locale} used to format\n-     *\n-     * @return a new instance of {@link FormatProcessor}\n-     *\n-     * @throws java.lang.NullPointerException if locale is null\n-     *\/\n-    public static FormatProcessor create(Locale locale) {\n-        Objects.requireNonNull(locale);\n-        return new FormatProcessor(locale);\n-    }\n-\n-    \/**\n-     * Constructs a {@link String} based on the fragments, format\n-     * specifications found in the fragments and values in the\n-     * supplied {@link StringTemplate} object. This method constructs a\n-     * format string from the fragments, gathers up the values and\n-     * evaluates the expression asif evaulating\n-     * {@code new Formatter(locale).format(format, values).toString()}.\n-     * <p>\n-     * If an embedded expression is not immediately preceded by a\n-     * specifier then a {@code %s} is inserted in the format.\n-     *\n-     * @param stringTemplate  a {@link StringTemplate} instance\n-     *\n-     * @return constructed {@link String}\n-\n-     * @throws  IllegalFormatException\n-     *          If a format specifier contains an illegal syntax, a format\n-     *          specifier that is incompatible with the given arguments,\n-     *          a specifier not followed immediately by an embedded expression or\n-     *          other illegal conditions. For specification of all possible\n-     *          formatting errors, see the\n-     *          <a href=\"..\/util\/Formatter.html#detail\">details<\/a>\n-     *          section of the formatter class specification.\n-     * @throws NullPointerException if stringTemplate is null\n-     *\n-     * @see java.util.Formatter\n-     *\/\n-    @Override\n-    public final String process(StringTemplate stringTemplate) {\n-        Objects.requireNonNull(stringTemplate);\n-        String format = stringTemplateFormat(stringTemplate.fragments());\n-        Object[] values = stringTemplate.values().toArray();\n-\n-        return new Formatter(locale).format(format, values).toString();\n-    }\n-\n-    \/**\n-     * Constructs a {@link MethodHandle} that when supplied with the values from\n-     * a {@link StringTemplate} will produce a result equivalent to that provided by\n-     * {@link FormatProcessor#process(StringTemplate)}. This {@link MethodHandle}\n-     * is used by {@link FormatProcessor#FMT} and the ilk to perform a more\n-     * specialized composition of a result. This specialization is done by\n-     * prescanning the fragments and value types of a {@link StringTemplate}.\n-     * <p>\n-     * Process template expressions can be specialized  when the processor is\n-     * of type {@link Linkage} and fetched from a static constant as is\n-     * {@link FormatProcessor#FMT} ({@code static final FormatProcessor}).\n-     * <p>\n-     * Other {@link FormatProcessor FormatProcessors} can be specialized when stored in a static\n-     * final.\n-     * For example:\n-     * {@snippet :\n-     * FormatProcessor THAI_FMT = FormatProcessor.create(Locale.forLanguageTag(\"th-TH-u-nu-thai\"));\n-     * }\n-     * {@code THAI_FMT} will now produce specialized {@link MethodHandle MethodHandles} by way\n-     * of {@link FormatProcessor#linkage(List, MethodType)}.\n-     *\n-     * See {@link FormatProcessor#process(StringTemplate)} for more information.\n-     *\n-     * @throws  IllegalFormatException\n-     *          If a format specifier contains an illegal syntax, a format\n-     *          specifier that is incompatible with the given arguments,\n-     *          a specifier not followed immediately by an embedded expression or\n-     *          other illegal conditions. For specification of all possible\n-     *          formatting errors, see the\n-     *          <a href=\"..\/util\/Formatter.html#detail\">details<\/a>\n-     *          section of the formatter class specification.\n-     * @throws NullPointerException if fragments or type is null\n-     *\n-     * @see java.util.Formatter\n-     *\/\n-    @Override\n-    public MethodHandle linkage(List<String> fragments, MethodType type) {\n-        Objects.requireNonNull(fragments);\n-        Objects.requireNonNull(type);\n-        String format = stringTemplateFormat(fragments);\n-        Class<?>[] ptypes = type.dropParameterTypes(0, 1).parameterArray();\n-        MethodHandle mh = new FormatterBuilder(format, locale, ptypes).build();\n-        mh = MethodHandles.dropArguments(mh, 0, type.parameterType(0));\n-\n-        return mh;\n-    }\n-\n-    \/**\n-     * Find a format specification at the end of a fragment.\n-     *\n-     * @param fragment  fragment to check\n-     * @param needed    if the specification is needed\n-     *\n-     * @return true if the specification is found and needed\n-     *\n-     * @throws MissingFormatArgumentException if not at end or found and not needed\n-     *\/\n-    private static boolean findFormat(String fragment, boolean needed) {\n-        int max = fragment.length();\n-        for (int i = 0; i < max;) {\n-            int n = fragment.indexOf('%', i);\n-            if (n < 0) {\n-                return false;\n-            }\n-\n-            i = n + 1;\n-            if (i >= max) {\n-                return false;\n-            }\n-\n-            char c = fragment.charAt(i);\n-            if (c == '%' || c == 'n') {\n-                i++;\n-                continue;\n-            }\n-            int off = new Formatter.FormatSpecifierParser(null, c, i, fragment, max)\n-                    .parse();\n-            if (off == 0) {\n-                return false;\n-            }\n-            if (i + off == max && needed) {\n-                return true;\n-            }\n-            throw new MissingFormatArgumentException(\n-                    fragment.substring(i - 1, i + off)\n-                    + \" is not immediately followed by an embedded expression\");\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Convert {@link StringTemplate} fragments, containing format specifications,\n-     * to a form that can be passed on to {@link Formatter}. The method scans each fragment,\n-     * matching up formatter specifications with the following expression. If no\n-     * specification is found, the method inserts \"%s\".\n-     *\n-     * @param fragments  string template fragments\n-     *\n-     * @return  format string\n-     *\/\n-    private static String stringTemplateFormat(List<String> fragments) {\n-        StringBuilder sb = new StringBuilder();\n-        int lastIndex = fragments.size() - 1;\n-        List<String> formats = fragments.subList(0, lastIndex);\n-        String last = fragments.get(lastIndex);\n-\n-        for (String format : formats) {\n-            if (findFormat(format, true)) {\n-                sb.append(format);\n-            } else {\n-                sb.append(format);\n-                sb.append(\"%s\");\n-            }\n-        }\n-\n-        if (!findFormat(last, false)) {\n-            sb.append(last);\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-    \/**\n-     * This predefined {@link FormatProcessor} instance constructs a {@link String} result using\n-     * the Locale.ROOT {@link Locale}. See {@link FormatProcessor} for more details.\n-     * Example: {@snippet :\n-     * int x = 10;\n-     * int y = 20;\n-     * String result = FMT.\"0x%04x\\{x} + 0x%04x\\{y} = 0x%04x\\{x + y}\"; \/\/ @highlight substring=\"FMT\"\n-     * }\n-     * In the above example, the value of {@code result} will be {@code \"0x000a + 0x0014 = 0x001E\"}.\n-     *\n-     * @see java.util.FormatProcessor\n-     *\/\n-    public static final FormatProcessor FMT = FormatProcessor.create(Locale.ROOT);\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":0,"deletions":299,"binary":false,"changes":299,"status":"deleted"},{"patch":"@@ -64,1 +64,0 @@\n-import jdk.internal.javac.PreviewFeature;\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,489 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.util;\n-\n-import java.io.IOException;\n-import java.lang.invoke.*;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.text.DecimalFormat;\n-import java.text.DecimalFormatSymbols;\n-import java.text.NumberFormat;\n-import java.text.spi.NumberFormatProvider;\n-import java.util.FormatItem.*;\n-import java.util.Formatter.*;\n-\n-import jdk.internal.util.FormatConcatItem;\n-\n-import sun.invoke.util.Wrapper;\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-import sun.util.locale.provider.ResourceBundleBasedAdapter;\n-\n-import static java.util.Formatter.Conversion.*;\n-import static java.util.Formatter.Flags.*;\n-import static java.lang.invoke.MethodHandles.*;\n-import static java.lang.invoke.MethodType.*;\n-\n-\/**\n- * This package private class supports the construction of the {@link MethodHandle}\n- * used by {@link FormatProcessor}.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-final class FormatterBuilder {\n-    private static final Lookup LOOKUP = lookup();\n-\n-    private final String format;\n-    private final Locale locale;\n-    private final Class<?>[] ptypes;\n-    private final DecimalFormatSymbols dfs;\n-    private final boolean isGenericDFS;\n-\n-    FormatterBuilder(String format, Locale locale, Class<?>[] ptypes) {\n-        this.format = format;\n-        this.locale = locale;\n-        this.ptypes = ptypes;\n-        this.dfs = DecimalFormatSymbols.getInstance(locale);\n-        this.isGenericDFS = isGenericDFS(this.dfs);\n-    }\n-\n-    private static boolean isGenericDFS(DecimalFormatSymbols dfs) {\n-        return dfs.getZeroDigit() == '0' &&\n-               dfs.getDecimalSeparator() == '.' &&\n-               dfs.getGroupingSeparator() == ',' &&\n-               dfs.getMinusSign() == '-';\n-    }\n-\n-    private static Class<?> mapType(Class<?> type) {\n-        return type.isPrimitive() || type == String.class ? type : Object.class;\n-    }\n-\n-    private static MethodHandle findStringConcatItemConstructor(Class<?> cls,\n-                                          Class<?>... ptypes) {\n-        MethodType methodType = methodType(void.class, ptypes);\n-\n-        try {\n-            MethodHandle mh = LOOKUP.findConstructor(cls, methodType);\n-\n-            return mh.asType(mh.type().changeReturnType(FormatConcatItem.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new AssertionError(\"Missing constructor in \" +\n-                    cls + \": \" + methodType);\n-        }\n-    }\n-\n-    private static MethodHandle findMethod(Class<?> cls, String name,\n-                                           Class<?> rType, Class<?>... ptypes) {\n-        MethodType methodType = methodType(rType, ptypes);\n-\n-        try {\n-            return LOOKUP.findVirtual(cls, name, methodType);\n-        } catch (ReflectiveOperationException e) {\n-            throw new AssertionError(\"Missing method in \" +\n-                    cls + \": \" + name + \" \" + methodType);\n-        }\n-    }\n-\n-    private static MethodHandle findStaticMethod(Class<?> cls, String name,\n-                                                 Class<?> rType, Class<?>... ptypes) {\n-        MethodType methodType = methodType(rType, ptypes);\n-\n-        try {\n-            return LOOKUP.findStatic(cls, name, methodType);\n-        } catch (ReflectiveOperationException e) {\n-            throw new AssertionError(\"Missing static method in \" +\n-                    cls + \": \" + name + \" \" + methodType);\n-        }\n-    }\n-\n-    private static final MethodHandle FIDecimal_MH =\n-            findStringConcatItemConstructor(FormatItemDecimal.class,\n-                    DecimalFormatSymbols.class, int.class, char.class, boolean.class,\n-                    int.class, long.class);\n-\n-    private static final MethodHandle FIHexadecimal_MH =\n-            findStringConcatItemConstructor(FormatItemHexadecimal.class,\n-                    int.class, boolean.class, long.class);\n-\n-    private static final MethodHandle FIOctal_MH =\n-            findStringConcatItemConstructor(FormatItemOctal.class,\n-                    int.class, boolean.class, long.class);\n-\n-    private static final MethodHandle FIBoolean_MH =\n-            findStringConcatItemConstructor(FormatItemBoolean.class,\n-                    boolean.class);\n-\n-    private static final MethodHandle FICharacter_MH =\n-            findStringConcatItemConstructor(FormatItemCharacter.class,\n-                    char.class);\n-\n-    private static final MethodHandle FIString_MH =\n-            findStringConcatItemConstructor(FormatItemString.class,\n-                    String.class);\n-\n-    private static final MethodHandle FIFormatSpecifier_MH =\n-            findStringConcatItemConstructor(FormatItemFormatSpecifier.class,\n-                    FormatSpecifier.class, Locale.class, Object.class);\n-\n-    private static final MethodHandle FIFormattable_MH =\n-            findStringConcatItemConstructor(FormatItemFormatSpecifier.class,\n-                    Locale.class, int.class, int.class, int.class,\n-                    Formattable.class);\n-\n-    private static final MethodHandle FIFillLeft_MH =\n-             findStringConcatItemConstructor(FormatItemFillLeft.class,\n-                    int.class, FormatConcatItem.class);\n-\n-    private static final MethodHandle FIFillRight_MH =\n-            findStringConcatItemConstructor(FormatItemFillRight.class,\n-                     int.class, FormatConcatItem.class);\n-\n-    private static final MethodHandle FINull_MH =\n-            findStringConcatItemConstructor(FormatItemNull.class);\n-\n-    private static final MethodHandle NullCheck_MH =\n-            findStaticMethod(FormatterBuilder.class, \"nullCheck\", boolean.class,\n-                    Object.class);\n-\n-    private static final MethodHandle FormattableCheck_MH =\n-            findStaticMethod(FormatterBuilder.class, \"formattableCheck\", boolean.class,\n-                    Object.class);\n-\n-    private static final MethodHandle ToLong_MH =\n-            findStaticMethod(java.util.FormatterBuilder.class, \"toLong\", long.class,\n-                    int.class);\n-\n-    private static final MethodHandle ToString_MH =\n-            findStaticMethod(String.class, \"valueOf\", String.class,\n-                    Object.class);\n-\n-    private static final MethodHandle HashCode_MH =\n-            findStaticMethod(Objects.class, \"hashCode\", int.class,\n-                    Object.class);\n-\n-    private static boolean nullCheck(Object object) {\n-        return object == null;\n-    }\n-\n-    private static boolean formattableCheck(Object object) {\n-        return Formattable.class.isAssignableFrom(object.getClass());\n-    }\n-\n-    private static long toLong(int value) {\n-        return (long)value & 0xFFFFFFFFL;\n-    }\n-\n-    private static boolean isFlag(int value, int flags) {\n-        return (value & flags) != 0;\n-    }\n-\n-    private static boolean validFlags(int value, int flags) {\n-        return (value & ~flags) == 0;\n-    }\n-\n-    private static int groupSize(Locale locale, DecimalFormatSymbols dfs) {\n-        if (isGenericDFS(dfs)) {\n-            return 3;\n-        }\n-\n-        DecimalFormat df;\n-        NumberFormat nf = NumberFormat.getNumberInstance(locale);\n-\n-        if (nf instanceof DecimalFormat) {\n-            df = (DecimalFormat)nf;\n-        } else {\n-            LocaleProviderAdapter adapter = LocaleProviderAdapter\n-                    .getAdapter(NumberFormatProvider.class, locale);\n-\n-            if (!(adapter instanceof ResourceBundleBasedAdapter)) {\n-                adapter = LocaleProviderAdapter.getResourceBundleBased();\n-            }\n-\n-            String[] all = adapter.getLocaleResources(locale)\n-                    .getNumberPatterns();\n-\n-            df = new DecimalFormat(all[0], dfs);\n-        }\n-\n-        return df.isGroupingUsed() ? df.getGroupingSize() : 0;\n-    }\n-\n-    private MethodHandle formatSpecifier(FormatSpecifier fs, Class<?> ptype) {\n-        boolean isPrimitive = ptype.isPrimitive();\n-        MethodHandle mh = identity(ptype);\n-        MethodType mt = mh.type();\n-\n-\/\/cannot cast to primitive types as it breaks null values formatting\n-\/\/        if (ptype == byte.class || ptype == short.class ||\n-\/\/            ptype == Byte.class || ptype == Short.class ||\n-\/\/            ptype == Integer.class) {\n-\/\/            mt = mt.changeReturnType(int.class);\n-\/\/        } else if (ptype == Long.class) {\n-\/\/            mt = mt.changeReturnType(long.class);\n-\/\/        } else if (ptype == float.class || ptype == Float.class ||\n-\/\/                   ptype == Double.class) {\n-\/\/            mt = mt.changeReturnType(double.class);\n-\/\/        } else if (ptype == Boolean.class) {\n-\/\/            mt = mt.changeReturnType(boolean.class);\n-\/\/        } else if (ptype == Character.class) {\n-\/\/            mt = mt.changeReturnType(char.class);\n-\/\/        }\n-\n-        Class<?> itype = mt.returnType();\n-\n-        if (itype != ptype) {\n-            mh = explicitCastArguments(mh, mt);\n-        }\n-\n-        boolean handled = false;\n-        int flags = fs.flags;\n-        int width = fs.width;\n-        int precision = fs.precision;\n-        Character conv = fs.dt ? 't' : fs.c;\n-\n-        switch (Character.toLowerCase(conv)) {\n-            case BOOLEAN -> {\n-                if (itype == boolean.class && precision == -1) {\n-                    if (flags == 0 && width == -1 && isPrimitive) {\n-                        return null;\n-                    }\n-\n-                    if (validFlags(flags, LEFT_JUSTIFY)) {\n-                        handled = true;\n-                        mh = filterReturnValue(mh, FIBoolean_MH);\n-                    }\n-                }\n-            }\n-            case STRING -> {\n-                if (flags == 0 && width == -1 && precision == -1) {\n-                    if (isPrimitive || ptype == String.class) {\n-                        return null;\n-                    } else if (itype.isPrimitive()) {\n-                        return mh;\n-                    }\n-                }\n-\n-                if (validFlags(flags, LEFT_JUSTIFY) && precision == -1) {\n-                    if (itype == String.class) {\n-                        handled = true;\n-                        mh = filterReturnValue(mh, FIString_MH);\n-                    } else if (!itype.isPrimitive()) {\n-                        handled = true;\n-                        MethodHandle test = FormattableCheck_MH;\n-                        test = test.asType(test.type().changeParameterType(0, ptype));\n-                        MethodHandle pass = insertArguments(FIFormattable_MH,\n-                                0, locale, flags, width, precision);\n-                        pass = pass.asType(pass.type().changeParameterType(0, ptype));\n-                        MethodHandle fail = ToString_MH;\n-                        fail = filterReturnValue(fail, FIString_MH);\n-                        fail = fail.asType(fail.type().changeParameterType(0, ptype));\n-                        mh = guardWithTest(test, pass, fail);\n-                    }\n-                }\n-            }\n-            case CHARACTER -> {\n-                if (itype == char.class && precision == -1) {\n-                    if (flags == 0 && width == -1) {\n-                        return isPrimitive ? null : mh;\n-                    }\n-\n-                    if (validFlags(flags, LEFT_JUSTIFY)) {\n-                        handled = true;\n-                        mh = filterReturnValue(mh, FICharacter_MH);\n-                    }\n-                }\n-            }\n-            case DECIMAL_INTEGER -> {\n-                if ((itype == int.class || itype == long.class) && precision == -1) {\n-                    if (itype == int.class) {\n-                        mh = explicitCastArguments(mh,\n-                                mh.type().changeReturnType(long.class));\n-                    }\n-\n-                    if (flags == 0 && isGenericDFS && width == -1) {\n-                        return mh;\n-                    } else if (validFlags(flags, PLUS | LEADING_SPACE |\n-                                                 ZERO_PAD | GROUP |\n-                                                 PARENTHESES)) {\n-                        handled = true;\n-                        int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n-                        char sign = isFlag(flags, PLUS)          ? '+' :\n-                                    isFlag(flags, LEADING_SPACE) ? ' ' : '\\0';\n-                        boolean parentheses = isFlag(flags, PARENTHESES);\n-                        int groupSize = isFlag(flags, GROUP) ?\n-                                groupSize(locale, dfs) : 0;\n-                        mh = filterReturnValue(mh,\n-                                insertArguments(FIDecimal_MH, 0, dfs, zeroPad,\n-                                        sign, parentheses, groupSize));\n-                    }\n-                }\n-            }\n-            case OCTAL_INTEGER -> {\n-                if ((itype == int.class || itype == long.class) &&\n-                         precision == -1 &&\n-                         validFlags(flags, ZERO_PAD | ALTERNATE)) {\n-                    handled = true;\n-\n-                    if (itype == int.class) {\n-                        mh = filterReturnValue(mh, ToLong_MH);\n-                    }\n-\n-                    int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n-                    boolean hasPrefix = isFlag(flags, ALTERNATE);\n-                    mh = filterReturnValue(mh,\n-                            insertArguments(FIOctal_MH, 0, zeroPad, hasPrefix));\n-                }\n-            }\n-            case HEXADECIMAL_INTEGER -> {\n-                if ((itype == int.class || itype == long.class) &&\n-                        precision == -1 &&\n-                        validFlags(flags, ZERO_PAD | ALTERNATE)) {\n-                    handled = true;\n-\n-                    if (itype == int.class) {\n-                        mh = filterReturnValue(mh, ToLong_MH);\n-                    }\n-\n-                    int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n-                    boolean hasPrefix = isFlag(flags, ALTERNATE);\n-                    mh = filterReturnValue(mh,\n-                            insertArguments(FIHexadecimal_MH, 0, zeroPad, hasPrefix));\n-                }\n-            }\n-            default -> {\n-                \/\/ pass thru\n-            }\n-        }\n-\n-        if (handled) {\n-            if (!isPrimitive) {\n-                MethodHandle test = NullCheck_MH.asType(\n-                        NullCheck_MH.type().changeParameterType(0, ptype));\n-                MethodHandle pass = dropArguments(FINull_MH, 0, ptype);\n-                mh = guardWithTest(test, pass, mh);\n-            }\n-\n-            if (0 < width) {\n-                if (isFlag(flags, LEFT_JUSTIFY)) {\n-                    mh = filterReturnValue(mh,\n-                            insertArguments(FIFillRight_MH, 0, width));\n-                } else {\n-                    mh = filterReturnValue(mh,\n-                            insertArguments(FIFillLeft_MH, 0, width));\n-                }\n-            }\n-\n-            if (!isFlag(flags, UPPERCASE)) {\n-                return mh;\n-            }\n-        }\n-\n-        mh = insertArguments(FIFormatSpecifier_MH, 0, fs, locale);\n-        mh = mh.asType(mh.type().changeParameterType(0, ptype));\n-\n-        return mh;\n-    }\n-\n-    \/**\n-     * Construct concat {@link MethodHandle} for based on format.\n-     *\n-     * @param fsa  list of specifiers\n-     *\n-     * @return concat {@link MethodHandle} for based on format\n-     *\/\n-    private MethodHandle buildFilters(List<FormatString> fsa,\n-                                      List<String> segments,\n-                                      MethodHandle[] filters) {\n-        MethodHandle mh = null;\n-        int iParam = 0;\n-        StringBuilder segment = new StringBuilder();\n-\n-        for (FormatString fs : fsa) {\n-            int index = fs.index();\n-\n-            switch (index) {\n-                case -2:  \/\/ fixed string, \"%n\", or \"%%\"\n-                    String string = fs.toString();\n-\n-                    if (\"%%\".equals(string)) {\n-                        segment.append('%');\n-                    } else if (\"%n\".equals(string)) {\n-                        segment.append(System.lineSeparator());\n-                    } else {\n-                        segment.append(string);\n-                    }\n-                    break;\n-                case 0:  \/\/ ordinary index\n-                    segments.add(segment.toString());\n-                    segment.setLength(0);\n-\n-                    if (iParam < ptypes.length) {\n-                        Class<?> ptype = ptypes[iParam];\n-                        filters[iParam++] = formatSpecifier((FormatSpecifier)fs, ptype);\n-                    } else {\n-                        throw new MissingFormatArgumentException(fs.toString());\n-                    }\n-                    break;\n-                case -1:  \/\/ relative index\n-                default:  \/\/ explicit index\n-                    throw new IllegalFormatFlagsException(\"Indexing not allowed: \" + fs.toString());\n-            }\n-        }\n-\n-        segments.add(segment.toString());\n-\n-        return mh;\n-    }\n-\n-    \/**\n-     * Build a {@link MethodHandle} to format arguments.\n-     *\n-     * @return new {@link MethodHandle} to format arguments\n-     *\/\n-    MethodHandle build() {\n-        List<String> segments = new ArrayList<>();\n-        MethodHandle[] filters = new MethodHandle[ptypes.length];\n-        buildFilters(Formatter.parse(format), segments, filters);\n-        Class<?>[] ftypes = new Class<?>[filters.length];\n-\n-        for (int i = 0; i < filters.length; i++) {\n-            MethodHandle filter = filters[i];\n-            ftypes[i] = filter == null ? ptypes[i] : filter.type().returnType();\n-        }\n-\n-        try {\n-            MethodHandle mh = StringConcatFactory.makeConcatWithTemplate(segments,\n-                    List.of(ftypes));\n-            mh = filterArguments(mh, 0, filters);\n-\n-            return mh;\n-        } catch (StringConcatException ex) {\n-            throw new AssertionError(\"concat fail\", ex);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatterBuilder.java","additions":0,"deletions":489,"binary":false,"changes":489,"status":"deleted"},{"patch":"@@ -998,5 +998,5 @@\n-        return switch (key) {\n-            case BaseLocale base -> new Locale(base, null);\n-            case LocaleKey lk -> new Locale(lk.base, lk.exts);\n-            default -> throw new InternalError(\"should not happen\");\n-        };\n+        if (key instanceof BaseLocale base) {\n+            return new Locale(base, null);\n+        }\n+        LocaleKey lk = (LocaleKey)key;\n+        return new Locale(lk.base, lk.exts);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2228,1 +2228,1 @@\n-    \/**\n+    \/*\n@@ -2285,1 +2285,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -2289,0 +2288,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n@@ -2412,1 +2412,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -2416,0 +2415,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n@@ -3325,1 +3325,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -3329,0 +3328,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n@@ -3367,1 +3367,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -3372,0 +3371,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n@@ -3711,1 +3711,1 @@\n-    \/**\n+    \/*\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -436,0 +436,14 @@\n+    \/**\n+     * Returns whether any of the stages in the (entire) pipeline is short-circuiting\n+     * or not.\n+     * @return {@code true} if any stage in this pipeline is short-circuiting,\n+     *         {@code false} if not.\n+     *\/\n+    protected final boolean isShortCircuitingPipeline() {\n+        for (var u = sourceStage.nextStage; u != null; u = u.nextStage) {\n+            if (StreamOpFlag.SHORT_CIRCUIT.isKnown(u.combinedFlags))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/AbstractPipeline.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import java.util.function.IntConsumer;\n@@ -266,3 +267,8 @@\n-                return new Sink.ChainedDouble<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n+                final DoubleConsumer fastPath =\n+                        isShortCircuitingPipeline()\n+                                ? null\n+                                : (sink instanceof DoubleConsumer dc)\n+                                ? dc\n+                                : sink::accept;\n+                final class FlatMap implements Sink.OfDouble, DoublePredicate {\n+                    boolean cancel;\n@@ -270,2 +276,2 @@\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    DoubleConsumer downstreamAsDouble = downstream::accept;\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -274,7 +280,2 @@\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n-\n-                    @Override\n-                    public void accept(double t) {\n-                        try (DoubleStream result = mapper.apply(t)) {\n+                    public void accept(double e) {\n+                        try (DoubleStream result = mapper.apply(e)) {\n@@ -282,7 +283,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsDouble);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsDouble));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -295,6 +293,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -302,1 +295,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(double output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/DoublePipeline.java","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import java.util.Comparator;\n-import java.util.Iterator;\n-import java.util.Optional;\n@@ -38,1 +35,0 @@\n-import java.util.function.BiFunction;\n@@ -43,1 +39,0 @@\n-import java.util.function.Predicate;\n@@ -45,3 +40,0 @@\n-import java.util.function.ToDoubleFunction;\n-import java.util.function.ToIntFunction;\n-import java.util.function.ToLongFunction;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/GathererOp.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -300,11 +300,11 @@\n-                return new Sink.ChainedInt<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    IntConsumer downstreamAsInt = downstream::accept;\n-\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                final IntConsumer fastPath =\n+                        isShortCircuitingPipeline()\n+                                ? null\n+                                : (sink instanceof IntConsumer ic)\n+                                ? ic\n+                                : sink::accept;\n+                final class FlatMap implements Sink.OfInt, IntPredicate {\n+                    boolean cancel;\n+\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -313,2 +313,2 @@\n-                    public void accept(int t) {\n-                        try (IntStream result = mapper.apply(t)) {\n+                    public void accept(int e) {\n+                        try (IntStream result = mapper.apply(e)) {\n@@ -316,7 +316,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsInt);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsInt));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -329,6 +326,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -336,1 +328,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(int output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/IntPipeline.java","additions":31,"deletions":28,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.function.IntConsumer;\n@@ -282,11 +283,11 @@\n-                return new Sink.ChainedLong<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    LongConsumer downstreamAsLong = downstream::accept;\n-\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                final LongConsumer fastPath =\n+                        isShortCircuitingPipeline()\n+                                ? null\n+                                : (sink instanceof LongConsumer lc)\n+                                ? lc\n+                                : sink::accept;\n+                final class FlatMap implements Sink.OfLong, LongPredicate {\n+                    boolean cancel;\n+\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -295,2 +296,2 @@\n-                    public void accept(long t) {\n-                        try (LongStream result = mapper.apply(t)) {\n+                    public void accept(long e) {\n+                        try (LongStream result = mapper.apply(e)) {\n@@ -298,7 +299,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsLong);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsLong));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -311,6 +309,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -318,1 +311,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(long output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/LongPipeline.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.function.DoublePredicate;\n@@ -42,0 +43,1 @@\n+import java.util.function.IntPredicate;\n@@ -43,0 +45,1 @@\n+import java.util.function.LongPredicate;\n@@ -277,3 +280,3 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n+                boolean shorts = isShortCircuitingPipeline();\n+                final class FlatMap implements Sink<P_OUT>, Predicate<R> {\n+                    boolean cancel;\n@@ -281,4 +284,2 @@\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -287,2 +288,2 @@\n-                    public void accept(P_OUT u) {\n-                        try (Stream<? extends R> result = mapper.apply(u)) {\n+                    public void accept(P_OUT e) {\n+                        try (Stream<? extends R> result = mapper.apply(e)) {\n@@ -290,7 +291,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstream);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstream));\n-                                }\n+                                if (shorts)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(sink);\n@@ -303,6 +301,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -310,1 +303,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(R output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n@@ -322,6 +326,11 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    IntConsumer downstreamAsInt = downstream::accept;\n+                IntConsumer fastPath =\n+                    isShortCircuitingPipeline()\n+                        ? null\n+                        : (sink instanceof IntConsumer ic)\n+                            ? ic\n+                            : sink::accept;\n+                final class FlatMap implements Sink<P_OUT>, IntPredicate {\n+                    boolean cancel;\n+\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -330,7 +339,2 @@\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n-\n-                    @Override\n-                    public void accept(P_OUT u) {\n-                        try (IntStream result = mapper.apply(u)) {\n+                    public void accept(P_OUT e) {\n+                        try (IntStream result = mapper.apply(e)) {\n@@ -338,7 +342,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsInt);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsInt));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -351,2 +352,1 @@\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -354,1 +354,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(int output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n@@ -366,6 +377,11 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    DoubleConsumer downstreamAsDouble = downstream::accept;\n+                DoubleConsumer fastPath =\n+                    isShortCircuitingPipeline()\n+                        ? null\n+                        : (sink instanceof DoubleConsumer dc)\n+                            ? dc\n+                            : sink::accept;\n+                final class FlatMap implements Sink<P_OUT>, DoublePredicate {\n+                    boolean cancel;\n+\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -374,7 +390,2 @@\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n-\n-                    @Override\n-                    public void accept(P_OUT u) {\n-                        try (DoubleStream result = mapper.apply(u)) {\n+                    public void accept(P_OUT e) {\n+                        try (DoubleStream result = mapper.apply(e)) {\n@@ -382,7 +393,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsDouble);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsDouble));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -395,2 +403,1 @@\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -398,1 +405,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(double output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n@@ -411,11 +429,11 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    LongConsumer downstreamAsLong = downstream::accept;\n-\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                LongConsumer fastPath =\n+                    isShortCircuitingPipeline()\n+                        ? null\n+                        : (sink instanceof LongConsumer lc)\n+                            ? lc\n+                            : sink::accept;\n+                final class FlatMap implements Sink<P_OUT>, LongPredicate {\n+                    boolean cancel;\n+\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -424,2 +442,2 @@\n-                    public void accept(P_OUT u) {\n-                        try (LongStream result = mapper.apply(u)) {\n+                    public void accept(P_OUT e) {\n+                        try (LongStream result = mapper.apply(e)) {\n@@ -427,7 +445,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsLong);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsLong));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -440,2 +455,1 @@\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -443,1 +457,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(long output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ReferencePipeline.java","additions":118,"deletions":93,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,2 +87,2 @@\n-       engine. the size 512 bytes is somewhat randomly chosen *\/\n-    private final byte[] ibuffer = new byte[512];\n+       engine. *\/\n+    private final byte[] ibuffer = new byte[8192];\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/CipherInputStream.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+package jdk.internal.access;\n+\n@@ -30,2 +32,0 @@\n-package jdk.internal.access;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaAWTFontAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -367,0 +367,9 @@\n+    \/**\n+     * Put the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     *\/\n+    void putCharUTF16(byte[] bytes, int index, int ch);\n+\n@@ -420,0 +429,6 @@\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\/\n+    long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value);\n+\n@@ -430,10 +445,0 @@\n-   \/**\n-    * Get the coder for the supplied character.\n-    *\/\n-   long stringConcatCoder(char value);\n-\n-   \/**\n-    * Update lengthCoder for StringBuilder.\n-    *\/\n-   long stringBuilderConcatMix(long lengthCoder, StringBuilder sb);\n-\n@@ -441,3 +446,3 @@\n-     * Prepend StringBuilder content.\n-    *\/\n-   long stringBuilderConcatPrepend(long lengthCoder, byte[] buf, StringBuilder sb);\n+     * Mix value length and coder into current length and coder.\n+     *\/\n+    long stringConcatMix(long lengthCoder, char value);\n@@ -457,0 +462,6 @@\n+    int stringSize(long i);\n+\n+    int getCharsLatin1(long i, int index, byte[] buf);\n+\n+    int getCharsUTF16(long i, int index, byte[] buf);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.access;\n-\n-import java.util.List;\n-\n-public interface JavaTemplateAccess {\n-\n-    \/**\n-     * Returns a StringTemplate composed from fragments and values.\n-     *\n-     * @implSpec The {@code fragments} list size must be one more that the\n-     * {@code values} list size.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    list of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n-     *\n-     * @implNote Contents of both lists are copied to construct immutable lists.\n-     *\/\n-    StringTemplate of(List<String> fragments, List<?> values);\n-\n-    \/**\n-     * Creates a string that interleaves the elements of values between the\n-     * elements of fragments.\n-     *\n-     * @param fragments  list of String fragments\n-     * @param values     list of expression values\n-     *\n-     * @return String interpolation of fragments and values\n-     *\/\n-    String interpolate(List<String> fragments, List<?> values);\n-\n-    \/**\n-     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n-     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n-     * }\n-     *\n-     * @param sts  zero or more {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if sts is null or if any element of sts is null\n-     *\/\n-    StringTemplate combine(StringTemplate... sts);\n-\n-}\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaTemplateAccess.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -94,1 +94,0 @@\n-    private static JavaTemplateAccess javaTemplateAccess;\n@@ -535,15 +534,0 @@\n-    public static void setJavaTemplateAccess(JavaTemplateAccess jta) {\n-        javaTemplateAccess = jta;\n-    }\n-\n-    public static JavaTemplateAccess getJavaTemplateAccess() {\n-        var access = javaTemplateAccess;\n-        if (access == null) {\n-            try {\n-                Class.forName(\"java.lang.runtime.TemplateSupport\", true, null);\n-                access = javaTemplateAccess;\n-            } catch (ClassNotFoundException e) {}\n-        }\n-        return access;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.util.stream.Collectors;\n@@ -48,0 +50,1 @@\n+                buf.thisClass().asSymbol(),\n@@ -59,0 +62,1 @@\n+    private final ClassDesc thisClass;\n@@ -61,0 +65,2 @@\n+    private final boolean isStatic;\n+    private final ByteBuffer bytecode;\n@@ -94,0 +100,1 @@\n+                     ClassDesc thisClass,\n@@ -100,0 +107,1 @@\n+        this.thisClass = thisClass;\n@@ -102,0 +110,2 @@\n+        this.isStatic = isStatic;\n+        this.bytecode = bytecode;\n@@ -250,1 +260,1 @@\n-                                error(\"low must be less than or equal to high in tableswitch\");\n+                                throw error(\"low must be less than or equal to high in tableswitch\");\n@@ -254,1 +264,1 @@\n-                                error(\"too many keys in tableswitch\");\n+                                throw error(\"too many keys in tableswitch\");\n@@ -260,1 +270,1 @@\n-                                error(\"number of keys in lookupswitch less than 0\");\n+                                throw error(\"number of keys in lookupswitch less than 0\");\n@@ -267,1 +277,1 @@\n-                                    error(\"Bad lookupswitch instruction\");\n+                                    throw error(\"Bad lookupswitch instruction\");\n@@ -329,1 +339,1 @@\n-                        error(String.format(\"Bad instruction: %02x\", opcode));\n+                        throw error(String.format(\"Bad instruction: %02x\", opcode));\n@@ -363,1 +373,1 @@\n-                error(\"CP entry #%d %s is not loadable constant\".formatted(index, cp.entryByIndex(index).tag()));\n+                throw error(\"CP entry #%d %s is not loadable constant\".formatted(index, cp.entryByIndex(index).tag()));\n@@ -367,2 +377,2 @@\n-    private void error(String msg) {\n-        throw new IllegalArgumentException(\"%s at bytecode offset %d of method %s(%s)\".formatted(\n+    private IllegalArgumentException error(String msg) {\n+        var sb = new StringBuilder(\"%s at bytecode offset %d of method %s(%s)\".formatted(\n@@ -372,1 +382,3 @@\n-                methodDesc.displayDescriptor()));\n+                methodDesc.parameterList().stream().map(ClassDesc::displayName).collect(Collectors.joining(\",\"))));\n+        Util.dumpMethod(cp, thisClass, methodName, methodDesc, isStatic ? ACC_STATIC : 0, bytecode, sb::append);\n+        return new IllegalArgumentException(sb.toString());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-import java.lang.classfile.components.ClassPrinter;\n-import java.lang.classfile.attribute.CodeAttribute;\n@@ -839,30 +837,1 @@\n-        \/\/try to attach debug info about corrupted bytecode to the message\n-        try {\n-            var cc = ClassFile.of();\n-            var clm = cc.parse(cc.build(cp.classEntry(thisType.sym()), cp, clb ->\n-                    clb.withMethod(methodName, methodDesc, isStatic ? ACC_STATIC : 0, mb ->\n-                            ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n-                                @Override\n-                                public void writeBody(BufWriter b) {\n-                                    b.writeU2(-1);\/\/max stack\n-                                    b.writeU2(-1);\/\/max locals\n-                                    b.writeInt(bytecode.limit());\n-                                    b.writeBytes(bytecode.array(), 0, bytecode.limit());\n-                                    b.writeU2(0);\/\/exception handlers\n-                                    b.writeU2(0);\/\/attributes\n-                                }\n-                    }))));\n-            ClassPrinter.toYaml(clm.methods().get(0).code().get(), ClassPrinter.Verbosity.TRACE_ALL, sb::append);\n-        } catch (Error | Exception suppresed) {\n-            \/\/fallback to bytecode hex dump\n-            bytecode.rewind();\n-            while (bytecode.position() < bytecode.limit()) {\n-                sb.append(\"%n%04x:\".formatted(bytecode.position()));\n-                for (int i = 0; i < 16 && bytecode.position() < bytecode.limit(); i++) {\n-                    sb.append(\" %02x\".formatted(bytecode.get()));\n-                }\n-            }\n-            var err = new IllegalArgumentException(sb.toString());\n-            err.addSuppressed(suppresed);\n-            return err;\n-        }\n+        Util.dumpMethod(cp, thisType.sym(), methodName, methodDesc, isStatic ? ACC_STATIC : 0, bytecode, sb::append);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.BufWriter;\n@@ -46,0 +48,5 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n@@ -196,0 +203,37 @@\n+\n+    public static void dumpMethod(SplitConstantPool cp,\n+                                  ClassDesc cls,\n+                                  String methodName,\n+                                  MethodTypeDesc methodDesc,\n+                                  int acc,\n+                                  ByteBuffer bytecode,\n+                                  Consumer<String> dump) {\n+\n+        \/\/ try to dump debug info about corrupted bytecode\n+        try {\n+            var cc = ClassFile.of();\n+            var clm = cc.parse(cc.build(cp.classEntry(cls), cp, clb ->\n+                    clb.withMethod(methodName, methodDesc, acc, mb ->\n+                            ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n+                                @Override\n+                                public void writeBody(BufWriter b) {\n+                                    b.writeU2(-1);\/\/max stack\n+                                    b.writeU2(-1);\/\/max locals\n+                                    b.writeInt(bytecode.limit());\n+                                    b.writeBytes(bytecode.array(), 0, bytecode.limit());\n+                                    b.writeU2(0);\/\/exception handlers\n+                                    b.writeU2(0);\/\/attributes\n+                                }\n+                    }))));\n+            ClassPrinter.toYaml(clm.methods().get(0).code().get(), ClassPrinter.Verbosity.TRACE_ALL, dump);\n+        } catch (Error | Exception _) {\n+            \/\/ fallback to bytecode hex dump\n+            bytecode.rewind();\n+            while (bytecode.position() < bytecode.limit()) {\n+                dump.accept(\"%n%04x:\".formatted(bytecode.position()));\n+                for (int i = 0; i < 16 && bytecode.position() < bytecode.limit(); i++) {\n+                    dump.accept(\" %02x\".formatted(bytecode.get()));\n+                }\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,7 @@\n+    @Override\n+    public final long maxByteAlignment() {\n+        return address() == 0\n+            ? maxAlignMask()\n+            : Math.min(maxAlignMask(), Long.lowestOneBit(address()));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -64,0 +63,6 @@\n+    public final long maxByteAlignment() {\n+        return address() == 0\n+                ? 1L << 62\n+                : Long.lowestOneBit(address());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-            MemorySegment funcs = fallbackLibLookup.find(\"funcs\").orElseThrow()\n+            MemorySegment funcs = fallbackLibLookup.findOrThrow(\"funcs\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,3 +144,0 @@\n-    \/** {@return byte order used by this linker} *\/\n-    protected abstract ByteOrder linkerByteOrder();\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,5 +72,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.LITTLE_ENDIAN;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,5 +72,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.LITTLE_ENDIAN;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,5 +68,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.LITTLE_ENDIAN;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -126,5 +126,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.nativeOrder();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-            if (vl.order() != linkerByteOrder()) {\n+            if (vl.order() != ByteOrder.BIG_ENDIAN) {\n@@ -86,5 +86,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.BIG_ENDIAN;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/aix\/AixPPC64Linker.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,5 +68,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.BIG_ENDIAN;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64Linker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,5 +68,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.LITTLE_ENDIAN;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64leLinker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,5 +70,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.LITTLE_ENDIAN;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,5 +67,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.BIG_ENDIAN;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/LinuxS390Linker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,5 +70,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.LITTLE_ENDIAN;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,5 +69,0 @@\n-    @Override\n-    protected ByteOrder linkerByteOrder() {\n-        return ByteOrder.LITTLE_ENDIAN;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-\/**\n+\/*\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/icu\/lang\/UCharacter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2412,1 +2412,1 @@\n-    \/*********************************************************************\/\n+    \/* *******************************************************************\/\n@@ -2414,1 +2414,1 @@\n-    \/*********************************************************************\/\n+    \/* *******************************************************************\/\n@@ -2425,1 +2425,1 @@\n-    \/*********************************************************************\/\n+    \/* *******************************************************************\/\n@@ -2427,1 +2427,1 @@\n-    \/*********************************************************************\/\n+    \/* *******************************************************************\/\n@@ -2450,1 +2450,1 @@\n-    \/*********************************************************************\/\n+    \/* *******************************************************************\/\n@@ -2513,1 +2513,1 @@\n-    \/*********************************************************************\/\n+    \/* *******************************************************************\/\n@@ -2515,1 +2515,1 @@\n-    \/*********************************************************************\/\n+    \/* *******************************************************************\/\n@@ -2528,1 +2528,1 @@\n-    \/*********************************************************************\/\n+    \/* *******************************************************************\/\n@@ -2530,1 +2530,1 @@\n-    \/*********************************************************************\/\n+    \/* *******************************************************************\/\n@@ -2547,1 +2547,1 @@\n-    \/*********************************************************************\/\n+    \/* *******************************************************************\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/icu\/text\/BidiBase.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/**\n+\/*\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/icu\/text\/UTF16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.concurrent.ForkJoinPool;\n@@ -30,1 +29,0 @@\n-import jdk.internal.access.JavaUtilConcurrentFJPAccess;\n@@ -37,1 +35,1 @@\n- *     long comp = Blocker.begin();\n+ *     boolean attempted = Blocker.begin();\n@@ -41,1 +39,1 @@\n- *         Blocker.end(comp);\n+ *         Blocker.end(attempted);\n@@ -65,2 +63,2 @@\n-     * Marks the beginning of a possibly blocking operation.\n-     * @return the return value from the attempt to compensate or -1 if not attempted\n+     * Marks the beginning of a blocking operation.\n+     * @return true if tryCompensate attempted\n@@ -68,1 +66,1 @@\n-    public static long begin() {\n+    public static boolean begin() {\n@@ -70,13 +68,3 @@\n-                && currentCarrierThread() instanceof CarrierThread ct && !ct.inBlocking()) {\n-            ct.beginBlocking();\n-            boolean completed = false;\n-            try {\n-                long comp = ForkJoinPools.beginCompensatedBlock(ct.getPool());\n-                assert currentCarrierThread() == ct;\n-                completed = true;\n-                return comp;\n-            } finally {\n-                if (!completed) {\n-                    ct.endBlocking();\n-                }\n-            }\n+                && Thread.currentThread().isVirtual()\n+                && currentCarrierThread() instanceof CarrierThread ct) {\n+            return ct.beginBlocking();\n@@ -84,1 +72,1 @@\n-        return -1;\n+        return false;\n@@ -90,2 +78,1 @@\n-     * @return the return value from the attempt to compensate, -1 if not attempted\n-     * or blocking is false\n+     * @return true if tryCompensate attempted\n@@ -93,2 +80,2 @@\n-    public static long begin(boolean blocking) {\n-        return (blocking) ? begin() : -1;\n+    public static boolean begin(boolean blocking) {\n+        return (blocking) ? begin() : false;\n@@ -99,1 +86,1 @@\n-     * @param compensateReturn the value returned by the begin method\n+     * @param attempted if tryCompensate attempted\n@@ -101,3 +88,2 @@\n-    public static void end(long compensateReturn) {\n-        if (compensateReturn >= 0) {\n-            assert currentCarrierThread() instanceof CarrierThread ct && ct.inBlocking();\n+    public static void end(boolean attempted) {\n+        if (attempted) {\n@@ -105,1 +91,0 @@\n-            ForkJoinPools.endCompensatedBlock(ct.getPool(), compensateReturn);\n@@ -109,16 +94,0 @@\n-\n-    \/**\n-     * Defines static methods to invoke non-public ForkJoinPool methods via the\n-     * shared secret support.\n-     *\/\n-    private static class ForkJoinPools {\n-        private static final JavaUtilConcurrentFJPAccess FJP_ACCESS =\n-                SharedSecrets.getJavaUtilConcurrentFJPAccess();\n-        static long beginCompensatedBlock(ForkJoinPool pool) {\n-            return FJP_ACCESS.beginCompensatedBlock(pool);\n-        }\n-        static void endCompensatedBlock(ForkJoinPool pool, long post) {\n-            FJP_ACCESS.endCompensatedBlock(pool, post);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Blocker.java","additions":16,"deletions":47,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.internal.access.JavaUtilConcurrentFJPAccess;\n@@ -36,0 +37,1 @@\n+import jdk.internal.vm.Continuation;\n@@ -52,1 +54,8 @@\n-    private boolean blocking;    \/\/ true if in blocking op\n+    \/\/ compensating state\n+    private static final int NOT_COMPENSATING = 0;\n+    private static final int COMPENSATE_IN_PROGRESS = 1;\n+    private static final int COMPENSATING = 2;\n+    private int compensating;\n+\n+    \/\/ FJP value to adjust release counts\n+    private long compensateValue;\n@@ -63,1 +72,1 @@\n-     * For use by {@link Blocker} to test if the thread is in a blocking operation.\n+     * Mark the start of a blocking operation.\n@@ -65,4 +74,3 @@\n-    boolean inBlocking() {\n-        \/\/assert JLA.currentCarrierThread() == this;\n-        return blocking;\n-    }\n+    public boolean beginBlocking() {\n+        assert Thread.currentThread().isVirtual() && JLA.currentCarrierThread() == this;\n+        assert compensating == NOT_COMPENSATING || compensating == COMPENSATING;\n@@ -70,6 +78,20 @@\n-    \/**\n-     * For use by {@link Blocker} to mark the start of a blocking operation.\n-     *\/\n-    void beginBlocking() {\n-        \/\/assert JLA.currentCarrierThread() == this && !blocking;\n-        blocking = true;\n+        if (compensating == NOT_COMPENSATING) {\n+            \/\/ don't preempt when attempting to compensate\n+            Continuation.pin();\n+            try {\n+                compensating = COMPENSATE_IN_PROGRESS;\n+\n+                \/\/ Uses FJP.tryCompensate to start or re-activate a spare thread\n+                compensateValue = ForkJoinPools.beginCompensatedBlock(getPool());\n+                compensating = COMPENSATING;\n+                return true;\n+            } catch (Throwable e) {\n+                \/\/ exception starting spare thread\n+                compensating = NOT_COMPENSATING;\n+                throw e;\n+            } finally {\n+                Continuation.unpin();\n+            }\n+        } else {\n+            return false;\n+        }\n@@ -79,1 +101,1 @@\n-     * For use by {@link Blocker} to mark the end of a blocking operation.\n+     * Mark the end of a blocking operation.\n@@ -81,3 +103,7 @@\n-    void endBlocking() {\n-        \/\/assert JLA.currentCarrierThread() == this && blocking;\n-        blocking = false;\n+    public void endBlocking() {\n+        assert Thread.currentThread() == this || JLA.currentCarrierThread() == this;\n+        if (compensating == COMPENSATING) {\n+            ForkJoinPools.endCompensatedBlock(getPool(), compensateValue);\n+            compensating = NOT_COMPENSATING;\n+            compensateValue = 0;\n+        }\n@@ -98,1 +124,1 @@\n-    private static final ThreadGroup carrierThreadGroup() {\n+    private static ThreadGroup carrierThreadGroup() {\n@@ -120,0 +146,15 @@\n+    \/**\n+     * Defines static methods to invoke non-public ForkJoinPool methods via the\n+     * shared secret support.\n+     *\/\n+    private static class ForkJoinPools {\n+        private static final JavaUtilConcurrentFJPAccess FJP_ACCESS =\n+                SharedSecrets.getJavaUtilConcurrentFJPAccess();\n+        static long beginCompensatedBlock(ForkJoinPool pool) {\n+            return FJP_ACCESS.beginCompensatedBlock(pool);\n+        }\n+        static void endCompensatedBlock(ForkJoinPool pool, long post) {\n+            FJP_ACCESS.endCompensatedBlock(pool, post);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CarrierThread.java","additions":59,"deletions":18,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -3827,0 +3827,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    \/*****************************************************************\n+    \/* ***************************************************************\n@@ -126,1 +126,1 @@\n-    \/*****************************************************************\n+    \/* ***************************************************************\n@@ -218,1 +218,1 @@\n-    \/*****************************************************************\n+    \/* ***************************************************************\n@@ -274,1 +274,1 @@\n-    \/*****************************************************************\n+    \/* ***************************************************************\n@@ -355,1 +355,1 @@\n-    \/*****************************************************************\n+    \/* ***************************************************************\n@@ -376,1 +376,1 @@\n-    \/*****************************************************************\n+    \/* ***************************************************************\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.invoke.MethodHandle;\n-\n@@ -37,1 +35,1 @@\n-public final class DecimalDigits implements Digits {\n+public final class DecimalDigits {\n@@ -75,5 +73,0 @@\n-    \/**\n-     * Singleton instance of DecimalDigits.\n-     *\/\n-    public static final Digits INSTANCE = new DecimalDigits();\n-\n@@ -86,68 +79,0 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n-        boolean negative = value < 0;\n-        if (!negative) {\n-            value = -value;\n-        }\n-\n-        long q;\n-        int r;\n-        while (value <= Integer.MIN_VALUE) {\n-            q = value \/ 100;\n-            r = (int)((q * 100) - value);\n-            value = q;\n-            int digits = DIGITS[r];\n-\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-        }\n-\n-        int iq, ivalue = (int)value;\n-        while (ivalue <= -100) {\n-            iq = ivalue \/ 100;\n-            r = (iq * 100) - ivalue;\n-            ivalue = iq;\n-            int digits = DIGITS[r];\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-        }\n-\n-        if (ivalue < 0) {\n-            ivalue = -ivalue;\n-        }\n-\n-        int digits = DIGITS[ivalue];\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n-\n-        if (9 < ivalue) {\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-        }\n-\n-        if (negative) {\n-            putCharMH.invokeExact(buffer, --index, (int)'-');\n-        }\n-\n-        return index;\n-    }\n-\n-    @Override\n-    public int size(long value) {\n-        boolean negative = value < 0;\n-        int sign = negative ? 1 : 0;\n-\n-        if (!negative) {\n-            value = -value;\n-        }\n-\n-        long precision = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (value > precision)\n-                return i + sign;\n-\n-            precision = 10 * precision;\n-        }\n-\n-        return 19 + sign;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":1,"deletions":76,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * Digits provides a fast methodology for converting integers and longs to\n- * ASCII strings.\n- *\n- * @since 21\n- *\/\n-public sealed interface Digits permits DecimalDigits, HexDigits, OctalDigits {\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param buffer     byte buffer to copy into\n-     * @param index      insert point + 1\n-     * @param putCharMH  method to put character\n-     *\n-     * @return the last index used\n-     *\n-     * @throws Throwable if putCharMH fails (unusual).\n-     *\/\n-    int digits(long value, byte[] buffer, int index,\n-               MethodHandle putCharMH) throws Throwable;\n-\n-    \/**\n-     * Calculate the number of digits required to represent the long.\n-     *\n-     * @param value value to convert\n-     *\n-     * @return number of digits\n-     *\/\n-    int size(long value);\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Digits.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util;\n-\n-\/**\n- * Implementations of this class provide information necessary to\n- * assist {@link java.lang.invoke.StringConcatFactory} perform optimal\n- * insertion.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-public interface FormatConcatItem {\n-    \/**\n-     * Calculate the length of the insertion.\n-     *\n-     * @param lengthCoder current value of the length + coder\n-     * @return adjusted value of the length + coder\n-     *\/\n-    long mix(long lengthCoder);\n-\n-    \/**\n-     * Insert content into buffer prior to the current length.\n-     *\n-     * @param lengthCoder current value of the length + coder\n-     * @param buffer      buffer to append to\n-     *\n-     * @return adjusted value of the length + coder\n-     *\n-     * @throws Throwable if fails to prepend value (unusual).\n-     *\/\n-    long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/FormatConcatItem.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -28,2 +28,2 @@\n-import java.lang.invoke.MethodHandle;\n-\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,1 +33,2 @@\n- * Digits class for hexadecimal digits.\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * hexadecimal digits ASCII strings.\n@@ -37,1 +38,3 @@\n-public final class HexDigits implements Digits {\n+public final class HexDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -68,5 +71,0 @@\n-    \/**\n-     * Singleton instance of HexDigits.\n-     *\/\n-    public static final Digits INSTANCE = new HexDigits();\n-\n@@ -139,3 +137,10 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer) {\n@@ -143,1 +148,3 @@\n-            int digits = DIGITS[(int) (value & 0xFF)];\n+            short pair = DIGITS[((int) value) & 0xFF];\n+            buffer[--index] = (byte)(pair >> 8);\n+            buffer[--index] = (byte)(pair);\n@@ -145,2 +152,0 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -150,1 +155,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        buffer[--index] = (byte) (digits >> 8);\n@@ -153,1 +158,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -159,2 +164,35 @@\n-    @Override\n-    public int size(long value) {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer) {\n+        while ((value & ~0xFF) != 0) {\n+            int pair = (int) DIGITS[((int) value) & 0xFF];\n+            JLA.putCharUTF16(buffer, --index, pair >> 8);\n+            JLA.putCharUTF16(buffer, --index, pair & 0xFF);\n+            value >>>= 8;\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0xFF)];\n+        JLA.putCharUTF16(buffer, --index, (byte) (digits >> 8));\n+\n+        if (0xF < value) {\n+            JLA.putCharUTF16(buffer, --index, (byte) (digits & 0xFF));\n+        }\n+\n+        return index;\n+    }\n+\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":57,"deletions":19,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import java.lang.invoke.MethodHandle;\n-\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -37,1 +37,3 @@\n-public final class OctalDigits implements Digits {\n+public final class OctalDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -41,5 +43,0 @@\n-    \/**\n-     * Singleton instance of OctalDigits.\n-     *\/\n-    public static final Digits INSTANCE = new OctalDigits();\n-\n@@ -67,3 +64,39 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer){\n+        while ((value & ~0x3F) != 0) {\n+            int digits = DIGITS[((int) value) & 0x3F];\n+            value >>>= 6;\n+            buffer[--index] = (byte) (digits >> 8);\n+            buffer[--index] = (byte) (digits & 0xFF);\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0x3F)];\n+        buffer[--index] = (byte) (digits >> 8);\n+\n+        if (7 < value) {\n+            buffer[--index] = (byte) (digits & 0xFF);\n+        }\n+\n+        return index;\n+    }\n+\n+\n+    \/**\n+     * This is a variant of {@link OctalDigits#getCharsLatin1(long, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer){\n@@ -71,1 +104,3 @@\n-            int digits = DIGITS[(int) (value & 0x3F)];\n+            int pair = (int) DIGITS[((int) value) & 0x3F];\n+            JLA.putCharUTF16(buffer, --index, pair >> 8);\n+            JLA.putCharUTF16(buffer, --index, pair & 0xFF);\n@@ -73,2 +108,0 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -78,1 +111,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        JLA.putCharUTF16(buffer, --index, digits >> 8);\n@@ -81,1 +114,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            JLA.putCharUTF16(buffer, --index, digits & 0xFF);\n@@ -87,3 +120,9 @@\n-    @Override\n-    public int size(long value) {\n-        return (66 - Long.numberOfLeadingZeros(value)) \/ 3;\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n+        return value == 0 ? 1 : ((66 - Long.numberOfLeadingZeros(value)) \/ 3);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OctalDigits.java","additions":58,"deletions":19,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-\/**\n- * Plain text file handler.\n- * @author  Steven B. Byrne\n- *\/\n@@ -35,0 +31,4 @@\n+\/**\n+ * Plain text file handler.\n+ * @author  Steven B. Byrne\n+ *\/\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/content\/text\/plain.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -392,1 +392,1 @@\n-        if ((obj instanceof KeepAliveKey) == false)\n+        if (!(obj instanceof KeepAliveKey kae))\n@@ -394,1 +394,1 @@\n-        KeepAliveKey kae = (KeepAliveKey)obj;\n+\n@@ -408,1 +408,1 @@\n-        return this.obj == null? str.hashCode() :\n+        return this.obj == null ? str.hashCode() :\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,6 +26,0 @@\n-\/**\n- * Open an file input stream given a URL.\n- * @author      James Gosling\n- * @author      Steven B. Byrne\n- *\/\n-\n@@ -43,0 +37,5 @@\n+\/**\n+ * Open a file input stream given a URL.\n+ * @author      James Gosling\n+ * @author      Steven B. Byrne\n+ *\/\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/file\/FileURLConnection.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/**\n+\/*\n@@ -68,1 +68,1 @@\n-    \/**\n+    \/*\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/AbstractDelegateHttpsURLConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -576,0 +576,1 @@\n+            ensureOpen();\n@@ -854,0 +855,1 @@\n+            ensureOpen();\n@@ -1042,0 +1044,1 @@\n+            ensureOpen();\n@@ -1072,0 +1075,1 @@\n+            ensureOpen();\n@@ -1155,0 +1159,1 @@\n+            ensureOpen();\n@@ -1185,0 +1190,1 @@\n+            ensureOpen();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+    private final boolean sync;  \/\/ O_SYNC or O_DSYNC\n@@ -125,1 +126,2 @@\n-                            boolean writable, boolean direct, Closeable parent)\n+                            boolean writable, boolean sync, boolean direct,\n+                            Closeable parent)\n@@ -131,0 +133,1 @@\n+        this.sync = sync;\n@@ -153,1 +156,1 @@\n-                                   boolean direct, Closeable parent)\n+                                   boolean sync, boolean direct, Closeable parent)\n@@ -155,1 +158,1 @@\n-        return new FileChannelImpl(fd, path, readable, writable, direct, parent);\n+        return new FileChannelImpl(fd, path, readable, writable, sync, direct, parent);\n@@ -233,1 +236,1 @@\n-                    long comp = Blocker.begin();\n+                    boolean attempted = Blocker.begin(direct);\n@@ -237,1 +240,1 @@\n-                        Blocker.end(comp);\n+                        Blocker.end(attempted);\n@@ -268,1 +271,1 @@\n-                    long comp = Blocker.begin();\n+                    boolean attempted = Blocker.begin(direct);\n@@ -272,1 +275,1 @@\n-                        Blocker.end(comp);\n+                        Blocker.end(attempted);\n@@ -301,1 +304,1 @@\n-                    long comp = Blocker.begin();\n+                    boolean attempted = Blocker.begin(sync || direct);\n@@ -305,1 +308,1 @@\n-                        Blocker.end(comp);\n+                        Blocker.end(attempted);\n@@ -337,1 +340,1 @@\n-                    long comp = Blocker.begin();\n+                    boolean attempted = Blocker.begin(sync || direct);\n@@ -341,1 +344,1 @@\n-                        Blocker.end(comp);\n+                        Blocker.end(attempted);\n@@ -368,7 +371,2 @@\n-                    long comp = Blocker.begin();\n-                    try {\n-                        \/\/ in append-mode then position is advanced to end before writing\n-                        p = (append) ? nd.size(fd) : nd.seek(fd, -1);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n+                    \/\/ in append-mode then position is advanced to end before writing\n+                    p = (append) ? nd.size(fd) : nd.seek(fd, -1);\n@@ -399,6 +397,1 @@\n-                    long comp = Blocker.begin();\n-                    try {\n-                        p = nd.seek(fd, newPosition);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n+                    p = nd.seek(fd, newPosition);\n@@ -427,6 +420,1 @@\n-                    long comp = Blocker.begin();\n-                    try {\n-                        s = nd.size(fd);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n+                    s = nd.size(fd);\n@@ -464,6 +452,1 @@\n-                    long comp = Blocker.begin();\n-                    try {\n-                        size = nd.size(fd);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n+                    size = nd.size(fd);\n@@ -476,6 +459,1 @@\n-                    long comp = Blocker.begin();\n-                    try {\n-                        p = nd.seek(fd, -1);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n+                    p = nd.seek(fd, -1);\n@@ -490,6 +468,1 @@\n-                        long comp = Blocker.begin();\n-                        try {\n-                            rv = nd.truncate(fd, newSize);\n-                        } finally {\n-                            Blocker.end(comp);\n-                        }\n+                        rv = nd.truncate(fd, newSize);\n@@ -505,6 +478,1 @@\n-                    long comp = Blocker.begin();\n-                    try {\n-                        rp = nd.seek(fd, p);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n+                    rp = nd.seek(fd, p);\n@@ -532,1 +500,1 @@\n-                long comp = Blocker.begin();\n+                boolean attempted = Blocker.begin();\n@@ -536,1 +504,1 @@\n-                    Blocker.end(comp);\n+                    Blocker.end(attempted);\n@@ -627,6 +595,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                n = nd.transferTo(fd, position, count, targetFD, append);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            n = nd.transferTo(fd, position, count, targetFD, append);\n@@ -898,6 +861,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                n = nd.transferFrom(srcFD, fd, position, count, append);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            n = nd.transferFrom(srcFD, fd, position, count, append);\n@@ -1091,1 +1049,1 @@\n-                long comp = Blocker.begin();\n+                boolean attempted = Blocker.begin(direct);\n@@ -1095,1 +1053,1 @@\n-                    Blocker.end(comp);\n+                    Blocker.end(attempted);\n@@ -1136,1 +1094,1 @@\n-                long comp = Blocker.begin();\n+                boolean attempted = Blocker.begin(sync || direct);\n@@ -1140,1 +1098,1 @@\n-                    Blocker.end(comp);\n+                    Blocker.end(attempted);\n@@ -1365,6 +1323,1 @@\n-                    long comp = Blocker.begin();\n-                    try {\n-                        filesize = nd.size(fd);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n+                    filesize = nd.size(fd);\n@@ -1382,6 +1335,1 @@\n-                        long comp = Blocker.begin();\n-                        try {\n-                            rv = nd.truncate(fd, position + size);\n-                        } finally {\n-                            Blocker.end(comp);\n-                        }\n+                        rv = nd.truncate(fd, position + size);\n@@ -1578,1 +1526,1 @@\n-                long comp = Blocker.begin();\n+                boolean attempted = Blocker.begin();\n@@ -1582,1 +1530,1 @@\n-                    Blocker.end(comp);\n+                    Blocker.end(attempted);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":34,"deletions":86,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+package sun.nio.ch;\n+\n@@ -30,2 +32,0 @@\n-package sun.nio.ch;\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Interruptible.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -395,0 +395,1 @@\n+            ensureOpen();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -958,0 +958,1 @@\n+                    ensureOpen();\n@@ -1056,0 +1057,1 @@\n+                    ensureOpen();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,4 @@\n+package sun.security.pkcs;\n+\n+import java.io.IOException;\n+\n@@ -31,5 +35,0 @@\n-\n-package sun.security.pkcs;\n-\n-import java.io.IOException;\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/ParsingException.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,11 @@\n+import java.security.*;\n+import java.io.*;\n+import java.util.Properties;\n+import java.util.Enumeration;\n+import java.net.*;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Random;\n+import sun.security.util.Debug;\n+\n@@ -69,11 +80,0 @@\n-import java.security.*;\n-import java.io.*;\n-import java.util.Properties;\n-import java.util.Enumeration;\n-import java.net.*;\n-import java.nio.file.DirectoryStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Random;\n-import sun.security.util.Debug;\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SeedGenerator.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -304,8 +304,0 @@\n-    \/\/ return a string representation of this key for debugging\n-    @Override\n-    public String toString() {\n-        return \"SunRsaSign \" + type.keyAlgo + \" private CRT key, \"\n-               + n.bitLength() + \" bits\" + \"\\n  params: \" + keyParams\n-               + \"\\n  modulus: \" + n + \"\\n  private exponent: \" + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -141,8 +141,0 @@\n-    \/\/ return a string representation of this key for debugging\n-    @Override\n-    public String toString() {\n-        return \"Sun \" + type.keyAlgo + \" private key, \" + n.bitLength()\n-               + \" bits\" + \"\\n  params: \" + keyParams + \"\\n  modulus: \" + n\n-               + \"\\n  private exponent: \" + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+package sun.security.util;\n+\n+import java.util.Comparator;\n@@ -34,4 +37,0 @@\n-package sun.security.util;\n-\n-import java.util.Comparator;\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ByteArrayTagOrder.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-\/**\n- * IOUtils: A collection of IO-related public static methods.\n- *\/\n-\n@@ -36,0 +32,3 @@\n+\/**\n+ * IOUtils: A collection of IO-related public static methods.\n+ *\/\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/IOUtils.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -164,6 +163,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return canonicalize0(path);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return canonicalize0(path);\n@@ -179,7 +173,1 @@\n-        int rv;\n-        long comp = Blocker.begin();\n-        try {\n-            rv = getBooleanAttributes0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        int rv = getBooleanAttributes0(f);\n@@ -191,7 +179,1 @@\n-        int rv;\n-        long comp = Blocker.begin();\n-        try {\n-            rv = getBooleanAttributes0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        int rv = getBooleanAttributes0(f);\n@@ -210,6 +192,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return checkAccess0(f, access);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return checkAccess0(f, access);\n@@ -221,6 +198,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return getLastModifiedTime0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return getLastModifiedTime0(f);\n@@ -232,6 +204,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return getLength0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return getLength0(f);\n@@ -243,6 +210,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return setPermission0(f, access, enable, owneronly);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return setPermission0(f, access, enable, owneronly);\n@@ -256,6 +218,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return createFileExclusively0(path);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return createFileExclusively0(path);\n@@ -267,6 +224,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return delete0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return delete0(f);\n@@ -278,6 +230,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return list0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return list0(f);\n@@ -289,6 +236,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return createDirectory0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return createDirectory0(f);\n@@ -300,6 +242,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return rename0(f1, f2);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return rename0(f1, f2);\n@@ -311,6 +248,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return setLastModifiedTime0(f, time);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return setLastModifiedTime0(f, time);\n@@ -322,6 +254,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return setReadOnly0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return setReadOnly0(f);\n@@ -351,6 +278,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return getSpace0(f, t);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return getSpace0(f, t);\n","filename":"src\/java.base\/unix\/classes\/java\/io\/UnixFileSystem.java","additions":16,"deletions":94,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -629,1 +629,1 @@\n-            super(new FileOutputStream(newFileDescriptor(fd)));\n+            super(new PipeOutputStream(newFileDescriptor(fd)));\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-                long comp = Blocker.begin();\n+                boolean attempted = Blocker.begin(blocking);\n@@ -118,1 +118,1 @@\n-                    Blocker.end(comp);\n+                    Blocker.end(attempted);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/PollSelectorImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -309,0 +309,1 @@\n+            ensureOpen();\n@@ -337,0 +338,1 @@\n+            ensureOpen();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,0 +309,1 @@\n+            ensureOpen();\n@@ -337,0 +338,1 @@\n+            ensureOpen();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,2 +134,2 @@\n-        return FileChannelImpl.open(fdObj, path.toString(), flags.read,\n-                flags.write, flags.direct, null);\n+        return FileChannelImpl.open(fdObj, path.toString(), flags.read, flags.write,\n+                (flags.sync || flags.dsync), flags.direct, null);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixChannelFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -685,1 +684,0 @@\n-                    long comp = Blocker.begin();\n@@ -695,2 +693,0 @@\n-                    } finally {\n-                        Blocker.end(comp);\n@@ -706,1 +702,0 @@\n-                        long comp = Blocker.begin();\n@@ -712,2 +707,0 @@\n-                        } finally {\n-                            Blocker.end(comp);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -70,6 +69,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return open0(buffer.address(), flags, mode);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return open0(buffer.address(), flags, mode);\n@@ -86,6 +80,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return openat0(dfd, buffer.address(), flags, mode);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return openat0(dfd, buffer.address(), flags, mode);\n@@ -141,6 +130,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                link0(existingBuffer.address(), newBuffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            link0(existingBuffer.address(), newBuffer.address());\n@@ -157,6 +141,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                unlink0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            unlink0(buffer.address());\n@@ -172,6 +151,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                unlinkat0(dfd, buffer.address(), flag);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            unlinkat0(dfd, buffer.address(), flag);\n@@ -188,6 +162,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                mknod0(buffer.address(), mode, dev);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            mknod0(buffer.address(), mode, dev);\n@@ -205,6 +174,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                rename0(fromBuffer.address(), toBuffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            rename0(fromBuffer.address(), toBuffer.address());\n@@ -222,6 +186,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                renameat0(fromfd, fromBuffer.address(), tofd, toBuffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            renameat0(fromfd, fromBuffer.address(), tofd, toBuffer.address());\n@@ -238,6 +197,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                mkdir0(buffer.address(), mode);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            mkdir0(buffer.address(), mode);\n@@ -253,6 +207,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                rmdir0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            rmdir0(buffer.address());\n@@ -270,6 +219,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return readlink0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return readlink0(buffer.address());\n@@ -287,6 +231,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return realpath0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return realpath0(buffer.address());\n@@ -303,6 +242,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                symlink0(targetBuffer.address(), linkBuffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            symlink0(targetBuffer.address(), linkBuffer.address());\n@@ -319,8 +253,3 @@\n-            long comp = Blocker.begin();\n-            try {\n-                int errno = stat0(buffer.address(), attrs);\n-                if (errno != 0) {\n-                    throw new UnixException(errno);\n-                }\n-            } finally {\n-                Blocker.end(comp);\n+            int errno = stat0(buffer.address(), attrs);\n+            if (errno != 0) {\n+                throw new UnixException(errno);\n@@ -333,6 +262,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return stat0(buffer.address(), attrs);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return stat0(buffer.address(), attrs);\n@@ -349,6 +273,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                lstat0(buffer.address(), attrs);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            lstat0(buffer.address(), attrs);\n@@ -364,6 +283,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            fstat0(fd, attrs);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        fstat0(fd, attrs);\n@@ -381,6 +295,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                fstatat0(dfd, buffer.address(), flag, attrs);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            fstatat0(dfd, buffer.address(), flag, attrs);\n@@ -397,6 +306,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                chown0(buffer.address(), uid, gid);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            chown0(buffer.address(), uid, gid);\n@@ -413,6 +317,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                lchown0(buffer.address(), uid, gid);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            lchown0(buffer.address(), uid, gid);\n@@ -428,6 +327,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            fchown0(fd, uid, gid);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        fchown0(fd, uid, gid);\n@@ -442,6 +336,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                chmod0(buffer.address(), mode);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            chmod0(buffer.address(), mode);\n@@ -457,6 +346,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            fchmod0(fd, mode);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        fchmod0(fd, mode);\n@@ -473,6 +357,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                utimes0(buffer.address(), times0, times1);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            utimes0(buffer.address(), times0, times1);\n@@ -488,6 +367,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            futimes0(fd, times0, times1);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        futimes0(fd, times0, times1);\n@@ -502,6 +376,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            futimens0(fd, times0, times1);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        futimens0(fd, times0, times1);\n@@ -519,6 +388,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                lutimes0(buffer.address(), times0, times1);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            lutimes0(buffer.address(), times0, times1);\n@@ -535,6 +399,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return opendir0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return opendir0(buffer.address());\n@@ -562,6 +421,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return readdir0(dir);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return readdir0(dir);\n@@ -575,6 +429,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return read0(fildes, buf, nbyte);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return read0(fildes, buf, nbyte);\n@@ -588,6 +437,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return write0(fildes, buf, nbyte);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return write0(fildes, buf, nbyte);\n@@ -602,6 +446,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return access0(buffer.address(), amode);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return access0(buffer.address(), amode);\n@@ -633,6 +472,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return getpwnam0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return getpwnam0(buffer.address());\n@@ -650,6 +484,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return getgrnam0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return getgrnam0(buffer.address());\n@@ -667,6 +496,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                statvfs0(buffer.address(), attrs);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            statvfs0(buffer.address(), attrs);\n@@ -690,6 +514,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return fgetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return fgetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n@@ -709,6 +528,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                fsetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            fsetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n@@ -726,6 +540,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                fremovexattr0(filedes, buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            fremovexattr0(filedes, buffer.address());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":41,"deletions":232,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -494,6 +493,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return canonicalize0(path);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return canonicalize0(path);\n@@ -510,6 +504,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return getBooleanAttributes0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return getBooleanAttributes0(f);\n@@ -521,6 +510,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return checkAccess0(f, access);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return checkAccess0(f, access);\n@@ -532,6 +516,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return getLastModifiedTime0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return getLastModifiedTime0(f);\n@@ -543,6 +522,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return getLength0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return getLength0(f);\n@@ -554,6 +528,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return setPermission0(f, access, enable, owneronly);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return setPermission0(f, access, enable, owneronly);\n@@ -567,6 +536,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return createFileExclusively0(path);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return createFileExclusively0(path);\n@@ -578,6 +542,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return list0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return list0(f);\n@@ -589,6 +548,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return createDirectory0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return createDirectory0(f);\n@@ -600,6 +554,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return setLastModifiedTime0(f, time);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return setLastModifiedTime0(f, time);\n@@ -611,6 +560,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return setReadOnly0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return setReadOnly0(f);\n@@ -622,6 +566,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return delete0(f);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return delete0(f);\n@@ -633,6 +572,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return rename0(f1, f2);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return rename0(f1, f2);\n","filename":"src\/java.base\/windows\/classes\/java\/io\/WinNTFileSystem.java","additions":14,"deletions":80,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -518,1 +518,1 @@\n-                    new FileOutputStream(stdin_fd));\n+                    new PipeOutputStream(stdin_fd));\n@@ -567,1 +567,1 @@\n-        long comp = Blocker.begin();\n+        boolean attempted = Blocker.begin();\n@@ -571,1 +571,1 @@\n-            Blocker.end(comp);\n+            Blocker.end(attempted);\n@@ -596,1 +596,1 @@\n-            long comp = Blocker.begin();\n+            boolean attempted = Blocker.begin();\n@@ -600,1 +600,1 @@\n-                Blocker.end(comp);\n+                Blocker.end(attempted);\n","filename":"src\/java.base\/windows\/classes\/java\/lang\/ProcessImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-            long comp = Blocker.begin(blocking);\n+            boolean attempted = Blocker.begin(blocking);\n@@ -116,1 +116,1 @@\n-                Blocker.end(comp);\n+                Blocker.end(attempted);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WEPollSelectorImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,2 +169,2 @@\n-        return FileChannelImpl.open(fdObj, pathForWindows, flags.read,\n-                flags.write, flags.direct, null);\n+        return FileChannelImpl.open(fdObj, pathForWindows, flags.read, flags.write,\n+                (flags.sync || flags.dsync), flags.direct, null);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsChannelFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -71,11 +70,6 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return CreateFile0(buffer.address(),\n-                                   dwDesiredAccess,\n-                                   dwShareMode,\n-                                   lpSecurityAttributes,\n-                                   dwCreationDisposition,\n-                                   dwFlagsAndAttributes);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return CreateFile0(buffer.address(),\n+                               dwDesiredAccess,\n+                               dwShareMode,\n+                               lpSecurityAttributes,\n+                               dwCreationDisposition,\n+                               dwFlagsAndAttributes);\n@@ -116,6 +110,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                DeleteFile0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            DeleteFile0(buffer.address());\n@@ -135,6 +124,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                CreateDirectory0(buffer.address(), lpSecurityAttributes);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            CreateDirectory0(buffer.address(), lpSecurityAttributes);\n@@ -153,6 +137,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                RemoveDirectory0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            RemoveDirectory0(buffer.address());\n@@ -203,6 +182,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                FindFirstFile0(buffer.address(), data);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            FindFirstFile0(buffer.address(), data);\n@@ -233,6 +207,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return FindFirstFile1(buffer.address(), address);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return FindFirstFile1(buffer.address(), address);\n@@ -253,6 +222,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return FindNextFile0(handle, address);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return FindNextFile0(handle, address);\n@@ -274,6 +238,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                FindFirstStream0(buffer.address(), data);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            FindFirstStream0(buffer.address(), data);\n@@ -303,6 +262,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return FindNextStream0(handle);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return FindNextStream0(handle);\n@@ -328,6 +282,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            GetFileInformationByHandle0(handle, address);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        GetFileInformationByHandle0(handle, address);\n@@ -354,7 +303,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                CopyFileEx0(sourceBuffer.address(), targetBuffer.address(), flags,\n-                        addressToPollForCancel);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            CopyFileEx0(sourceBuffer.address(), targetBuffer.address(), flags, addressToPollForCancel);\n@@ -378,6 +321,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                MoveFileEx0(sourceBuffer.address(), targetBuffer.address(), flags);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            MoveFileEx0(sourceBuffer.address(), targetBuffer.address(), flags);\n@@ -396,6 +334,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                return GetFileAttributes0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return GetFileAttributes0(buffer.address());\n@@ -416,6 +349,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                SetFileAttributes0(buffer.address(), dwFileAttributes);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            SetFileAttributes0(buffer.address(), dwFileAttributes);\n@@ -436,6 +364,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                GetFileAttributesEx0(buffer.address(), address);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            GetFileAttributesEx0(buffer.address(), address);\n@@ -458,6 +381,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            SetFileTime0(handle, createTime, lastAccessTime, lastWriteTime);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        SetFileTime0(handle, createTime, lastAccessTime, lastWriteTime);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsNativeDispatcher.java","additions":22,"deletions":104,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -43,2 +43,4 @@\n- * @see <a href=\"AbstractAnnotationValueVisitor6.html#note_for_subclasses\">\n- * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see javax.lang.model.util##expectedEvolution\n+ * <strong>Expected visitor evolution<\/strong>\n+ * @see AbstractAnnotationValueVisitor6##note_for_subclasses\n+ * <strong>Compatibility note for subclasses<\/strong>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitorPreview.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,2 +48,4 @@\n- * @see <a href=\"AbstractElementVisitor6.html#note_for_subclasses\">\n- * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see javax.lang.model.util##expectedEvolution\n+ * <strong>Expected visitor evolution<\/strong>\n+ * @see AbstractAnnotationValueVisitor6##note_for_subclasses\n+ * <strong>Compatibility note for subclasses<\/strong>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitorPreview.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,2 +46,4 @@\n- * @see <a href=\"AbstractTypeVisitor6.html#note_for_subclasses\">\n- * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see javax.lang.model.util##expectedEvolution\n+ * <strong>Expected visitor evolution<\/strong>\n+ * @see AbstractAnnotationValueVisitor6##note_for_subclasses\n+ * <strong>Compatibility note for subclasses<\/strong>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitorPreview.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,2 +60,4 @@\n- * @see <a href=\"ElementKindVisitor6.html#note_for_subclasses\">\n- * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see javax.lang.model.util##expectedEvolution\n+ * <strong>Expected visitor evolution<\/strong>\n+ * @see AbstractAnnotationValueVisitor6##note_for_subclasses\n+ * <strong>Compatibility note for subclasses<\/strong>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitorPreview.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,1 +77,4 @@\n- * @see <a href=\"ElementScanner6.html#note_for_subclasses\"><strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see javax.lang.model.util##expectedEvolution\n+ * <strong>Expected visitor evolution<\/strong>\n+ * @see AbstractAnnotationValueVisitor6##note_for_subclasses\n+ * <strong>Compatibility note for subclasses<\/strong>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScannerPreview.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,2 +51,4 @@\n- * @see <a href=\"SimpleAnnotationValueVisitor6.html#note_for_subclasses\">\n- * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see javax.lang.model.util##expectedEvolution\n+ * <strong>Expected visitor evolution<\/strong>\n+ * @see AbstractAnnotationValueVisitor6##note_for_subclasses\n+ * <strong>Compatibility note for subclasses<\/strong>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitorPreview.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,2 +56,4 @@\n- * @see <a href=\"SimpleElementVisitor6.html#note_for_subclasses\">\n- * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see javax.lang.model.util##expectedEvolution\n+ * <strong>Expected visitor evolution<\/strong>\n+ * @see AbstractAnnotationValueVisitor6##note_for_subclasses\n+ * <strong>Compatibility note for subclasses<\/strong>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitorPreview.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,2 +55,4 @@\n- * @see <a href=\"SimpleTypeVisitor6.html#note_for_subclasses\">\n- * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see javax.lang.model.util##expectedEvolution\n+ * <strong>Expected visitor evolution<\/strong>\n+ * @see AbstractAnnotationValueVisitor6##note_for_subclasses\n+ * <strong>Compatibility note for subclasses<\/strong>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitorPreview.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,2 +59,4 @@\n- * @see <a href=\"TypeKindVisitor6.html#note_for_subclasses\">\n- * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see javax.lang.model.util##expectedEvolution\n+ * <strong>Expected visitor evolution<\/strong>\n+ * @see AbstractAnnotationValueVisitor6##note_for_subclasses\n+ * <strong>Compatibility note for subclasses<\/strong>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitorPreview.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,270 @@\n+ * @apiNote\n+ *\n+ * <h2 id=expectedEvolution>Expected visitor evolution<\/h2>\n+ *\n+ * As the Java programming language evolves, the visitor interfaces of\n+ * the language model also evolve as do the concrete visitors in this\n+ * package. A <a href=\"https:\/\/openjdk.org\/jeps\/12\">preview language\n+ * feature<\/a> in JDK <i>N<\/i> may have API elements added in the set\n+ * of visitors for the preview language level. Such new elements are\n+ * marked as reflective preview API. Any existing methods whose\n+ * specification is updated to support the preview feature are\n+ * <em>not<\/em> marked as preview.\n+ *\n+ * <p>The remainder of this note will show two examples of the API\n+ * changes in the model and visitors that can be added to support a\n+ * language feature. The examples will use additions to the elements\n+ * portion of the language model, but the updates to visitors for\n+ * types or annotation values would be analogous.\n+ *\n+ * Two distinct cases are:\n+ * <ul>\n+ *\n+ * <li>the preview language construct has a corresponding new modeling\n+ * interface and a concomitant new kind constant, such as a new {@link\n+ * javax.lang.model.element.ElementKind} constant\n+ *\n+ * <li>the preview language construct only triggers the introduction\n+ * of a new kind <em>without<\/em> a new modeling interface\n+ *\n+ * <\/ul>\n+ *\n+ * If a preview language feature is withdrawn rather than evolving to\n+ * a permanent platform feature, the API elements associated with the\n+ * feature are expected to be removed. The examples below outline the\n+ * API changes expected when a preview feature becomes a permanent\n+ * feature.\n+ *\n+ * <h3 id=topLevelLangConstruct>Adding visitor support for a\n+ * top-level language construct<\/h3>\n+ *\n+ * Consider a new language feature, preview feature 1, in JDK <i>N<\/i>. This\n+ * feature has a top-level element interface to model it:\n+ *\n+ * <pre>\n+ * package javax.lang.model.element;\n+ * \/**\n+ *  * Represents a preview feature 1.\n+ *  *\n+ *  * &commat;since N\n+ *  *&sol;\n+ *  public interface PreviewFeature1Element extends Element {\n+ *  \/\/ Methods to retrieve information specific to the preview feature...\n+ *  }\n+ * <\/pre>\n+ * A new element kind would also be introduced to model such a feature:\n+ *\n+ * <pre>\n+ *  \/\/  Sample diff of ElementKind.java\n+ *  +    \/**\n+ *  +     * A preview feature 1.\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +     PREVIEW_FEATURE_1,\n+ * <\/pre>\n+ *\n+ * A {@code default} method is added to {@code ElementVisitor} to accommodate the new construct:\n+ * <pre>\n+ * \/\/  Sample diff for ElementVisitor.java\n+ *  +    \/**\n+ *  +     * Visits a preview feature 1.\n+ *  +     *\n+ *  +     * &commat;implSpec The default implementation visits a {&commat;code\n+ *  +     * PreviewFeature1Element} by calling {&commat;code visitUnknown(e, p)}.\n+ *  +     *\n+ *  +     * &commat;param e  the element to visit\n+ *  +     * &commat;param p  a visitor-specified parameter\n+ *  +     * &commat;return a visitor-specified result\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    default R visitPreviewFeature1(PreviewFeature1Element e, P p) {\n+ *  +        return visitUnknown(e, p);\n+ *  +    }\n+ * <\/pre>\n+ *\n+ * Given the {@code default} method on the visitor interface, the\n+ * preview visitor classes need to override this method and take an\n+ * action appropriate for the visitor's semantics:\n+ *\n+ * <pre>\n+ * \/\/  Sample diff for AbstractElementVisitorPreview.java\n+ * \/\/  Re-abstract visitPreviewFeature1.\n+ *  +    \/**\n+ *  +     * {&commat;inheritDoc ElementVisitor}\n+ *  +     *\n+ *  +     * &commat;implSpec Visits a {&commat;code PreviewFeature1Element} in a manner\n+ *  +     * defined by a subclass.\n+ *  +     *\n+ *  +     * &commat;param e {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;param p {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;return a visitor-specified result\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    @Override\n+ *  +    public abstract R visitPreviewFeature1(PreviewFeature1Element e, P p);\n+ *\n+ * \/\/  Sample diff for ElementKindVisitorPreview.java\n+ * \/\/  Take the default action for a preview feature 1.\n+ *  +\n+ *  +    \/**\n+ *  +     * {&commat;inheritDoc ElementVisitor}\n+ *  +     *\n+ *  +     * &commat;implSpec This implementation calls {&commat;code defaultAction}.\n+ *  +     *\n+ *  +     * &commat;param e {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;param p {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;return  the result of {&commat;code defaultAction}\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    @Override\n+ *  +    public R visitPreviewFeature1(PreviewFeature1Element e, P p) {\n+ *  +        return defaultAction(e, p);\n+ *  +    }\n+ *\n+ * \/\/  Sample diff for ElementScannerPreview.java\n+ * \/\/  Scan the enclosed elements of a preview feature 1.\n+ *  +\n+ *  +    \/**\n+ *  +     * {&commat;inheritDoc ElementVisitor}\n+ *  +     *\n+ *  +     * &commat;implSpec This implementation scans the enclosed elements.\n+ *  +     *\n+ *  +     * &commat;param e {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;param p {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;return  {&commat;inheritDoc ElementScanner6}\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    @Override\n+ *  +    public R visitPreviewFeature1(PreviewFeature1Element e, P p) {\n+ *  +        return scan(e.getEnclosedElements(), p);\n+ *  +    }\n+ *\n+ * \/\/  Sample diff for SimpleElementVisitorPreview.java\n+ * \/\/  Take the default action for a preview feature 1.\n+ *  +    \/**\n+ *  +     * {&commat;inheritDoc ElementVisitor}\n+ *  +     *\n+ *  +     * &commat;implSpec Visits a {&commat;code PreviewFeature1Element} by calling\n+ *  +     * {@code defaultAction}.\n+ *  +     *\n+ *  +     * &commat;param e {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;param p {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;return  {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    @Override\n+ *  +    public R visitPreviewFeature1(PreviewFeature1Element e, P p) {\n+ *  +        return defaultAction(e, p);\n+ *  +    }\n+ * <\/pre>\n+ *\n+ * When preview feature 1 exits preview in JDK (<i>N+k<\/i>), a set of\n+ * visitors for language level (<i>N+k<\/i>) would be added. The\n+ * methods operating over the feature would be moved from the preview\n+ * visitors to the new language level (<i>N+k<\/i>) visitors. Each\n+ * preview visitor would then have its direct superclass changed to\n+ * the new corresponding (<i>N+k<\/i>) visitor.\n+ *\n+ * <h3 id=newKindLangConstruct>Adding visitor support for a language\n+ * construct that is a new kind of an existing construct<\/h3>\n+ *\n+ * Consider a new language feature, preview feature 2, in JDK\n+ * <i>N<\/i>. This feature has a new element kind <em>without<\/em> a\n+ * new top-level element interface needed to model it. Concretely,\n+ * assume a preview feature 2 is a new kind of variable; the changes\n+ * would be analogous if the feature were a new kind of executable\n+ * instead or new kind of another existing top-level construct. In\n+ * that case, the API changes are more limited:\n+ *\n+ * <pre>\n+ *  \/\/  Sample diff for ElementKind.java\n+ *  +    \/**\n+ *  +     * A preview feature 2.\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +     PREVIEW_FEATURE_2,\n+ *  ...\n+ *  \/\/ Update existing methods as needed\n+ *       public boolean isVariable() {\n+ *           return switch(this) {\n+ *           case ENUM_CONSTANT, FIELD, PARAMETER,\n+ *                LOCAL_VARIABLE, EXCEPTION_PARAMETER, RESOURCE_VARIABLE,\n+ *  -             BINDING_VARIABLE -> true;\n+ *  +             BINDING_VARIABLE, PREVIEW_FEATURE_2 -> true;\n+ *           default -> false;\n+ *           };\n+ *       }\n+ * <\/pre>\n+ *\n+ * The kind visitors need support for the new variety of element:\n+ * <pre>\n+ * \/\/ Update visitVariable in ElementKindVisitor6:\n+ *        ...\n+ *        * &commat;implSpec This implementation dispatches to the visit method for\n+ *        * the specific {&commat;linkplain ElementKind kind} of variable, {&commat;code\n+ *        * ENUM_CONSTANT}, {&commat;code EXCEPTION_PARAMETER}, {&commat;code FIELD},\n+ *  -     * {&commat;code LOCAL_VARIABLE}, {&commat;code PARAMETER}, or {&commat;code RESOURCE_VARIABLE}.\n+ *  +     * {&commat;code LOCAL_VARIABLE}, {&commat;code PARAMETER}, {&commat;code RESOURCE_VARIABLE},\n+ *  +     * or {&commat;code PREVIEW_FEATURE_2}.\n+ *        *\n+ *        * &commat;param e {&commat;inheritDoc ElementVisitor}\n+ *        * &commat;param p {&commat;inheritDoc ElementVisitor}\n+ *        * &commat;return  the result of the kind-specific visit method\n+ *        *&sol;\n+ *        &commat;Override\n+ *        public R visitVariable(VariableElement e, P p) {\n+ *        ...\n+ *           case BINDING_VARIABLE:\n+ *               return visitVariableAsBindingVariable(e, p);\n+ *\n+ *  +        case PREVIEW_FEATURE_2:\n+ *  +            return visitVariableAsPreviewFeature2(e, p);\n+ *  +\n+ *           default:\n+ *               throw new AssertionError(\"Bad kind \" + k + \" for VariableElement\" + e);\n+ *        ...\n+ *  +    \/**\n+ *  +     * Visits a {&commat;code PREVIEW_FEATURE_2} variable element.\n+ *  +     *\n+ *  +     * &commat;implSpec This implementation calls {&commat;code visitUnknown}.\n+ *  +     *\n+ *  +     * &commat;param e the element to visit\n+ *  +     * &commat;param p a visitor-specified parameter\n+ *  +     * &commat;return  the result of {&commat;code visitUnknown}\n+ *  +     *\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    public R visitVariableAsPreviewFeature2(VariableElement e, P p) {\n+ *  +        return visitUnknown(e, p);\n+ *  +    }\n+ * <\/pre>\n+ *\n+ * The preview element kind visitor in turn overrides {@code\n+ * visitVariableAsPreviewFeature2}:\n+ * <pre>\n+ * \/\/ Sample diff for ElementKindVisitorPreview:\n+ *  +    \/**\n+ *  +     * {&commat;inheritDoc ElementKindVisitor6}\n+ *  +     *\n+ *  +     * &commat;implSpec This implementation calls {&commat;code defaultAction}.\n+ *  +     *\n+ *  +     * &commat;param e {&commat;inheritDoc ElementKindVisitor6}\n+ *  +     * &commat;param p {&commat;inheritDoc ElementKindVisitor6}\n+ *  +     * &commat;return  the result of {&commat;code defaultAction}\n+ *  +     *\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    @Override\n+ *  +    public R visitVariableAsPreviewFeature2(VariableElement e, P p) {\n+ *  +        return defaultAction(e, p);\n+ *  +    }\n+ * <\/pre>\n+ *\n+ * As in the case where a new interface is introduced, when preview\n+ * feature 2 exits preview in JDK (<i>N+k<\/i>), a set of visitors for\n+ * language level (<i>N+k<\/i>) would be added. The methods operating\n+ * over the new feature in the kind visitors would be moved from the\n+ * preview visitors to new language level (<i>N+k<\/i>) visitors. Each\n+ * preview visitor would then have its direct superclass changed to\n+ * the new corresponding (<i>N+k<\/i>) visitor.\n+ *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/package-info.java","additions":271,"deletions":1,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,2 @@\n+         *\n+         * @since 18\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/DocumentationTool.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-            result.setRect(0, 0, -1, -1);\n+            result.setRect(0, 0, 0, 0);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CStrike.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1023,1 +1023,17 @@\n-}\n\\ No newline at end of file\n+    int MAX_SIZE = 1 << 30;\n+    if (bboxes) {\n+        for (int i = 0; i < count; i++) {\n+           if (bboxes[i].origin.x > (double)MAX_SIZE) bboxes[i].origin.x = 0;\n+           if (bboxes[i].origin.y > (double)MAX_SIZE) bboxes[i].origin.y = 0;\n+           if (bboxes[i].size.width > (double)MAX_SIZE) bboxes[i].size.width = 0;\n+           if (bboxes[i].size.height > (double)MAX_SIZE) bboxes[i].size.height = 0;\n+        }\n+    }\n+    if (advances) {\n+        for (int i = 0; i < count; i++) {\n+           if (advances[i].width > (double)MAX_SIZE) advances[i].width = 0;\n+           if (advances[i].height > (double)MAX_SIZE) advances[i].height = 0;\n+        }\n+    }\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CGGlyphImages.m","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,9 +606,5 @@\n-        if (!SwingUtilities2.isPrinting(g)) {\n-            Graphics bsg = backingStoreImage.getGraphics();\n-            bsg.setColor(g.getColor());\n-            bsg.setFont(g.getFont());\n-            bsg.setClip(g.getClipBounds());\n-            return bsg;\n-        } else {\n-            return g;\n-        }\n+        Graphics bsg = backingStoreImage.getGraphics();\n+        bsg.setColor(g.getColor());\n+        bsg.setFont(g.getFont());\n+        bsg.setClip(g.getClipBounds());\n+        return bsg;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JViewport.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.java2d.pipe.OutlineTextRenderer;\n@@ -110,0 +111,1 @@\n+    static final int MAX_IMAGE_SIZE = OutlineTextRenderer.THRESHHOLD;\n@@ -700,0 +702,14 @@\n+        if (intPtSize > MAX_IMAGE_SIZE) {\n+            Rectangle.Float obds = getGlyphOutlineBounds(glyphCode);\n+            if (obds.isEmpty()) {\n+                Rectangle bds = getGlyphOutline(glyphCode, pt.x, pt.y).getBounds();\n+                result.setBounds(bds);\n+            } else {\n+                result.x = (int)Math.floor(pt.x + obds.getX() + 0.5f);\n+                result.y = (int)Math.floor(pt.y + obds.getY() + 0.5f);\n+                result.width = (int)Math.floor(obds.getWidth() + 0.5f);\n+                result.height = (int)Math.floor(obds.getHeight() + 0.5f);\n+            }\n+            return;\n+        }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FileFontStrike.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-        Optional<MemorySegment> malloc_symbol = SYM_LOOKUP.find(\"malloc\");\n+        MemorySegment malloc_symbol = SYM_LOOKUP.findOrThrow(\"malloc\");\n@@ -173,1 +173,1 @@\n-        MethodHandle tmp1 = LINKER.downcallHandle(malloc_symbol.get(), mallocDescriptor);\n+        MethodHandle tmp1 = LINKER.downcallHandle(malloc_symbol, mallocDescriptor);\n@@ -178,1 +178,1 @@\n-        Optional<MemorySegment> create_face_symbol = SYM_LOOKUP.find(\"HBCreateFace\");\n+        MemorySegment create_face_symbol = SYM_LOOKUP.findOrThrow(\"HBCreateFace\");\n@@ -180,1 +180,1 @@\n-        MethodHandle tmp2 = LINKER.downcallHandle(create_face_symbol.get(), createFaceDescriptor);\n+        MethodHandle tmp2 = LINKER.downcallHandle(create_face_symbol, createFaceDescriptor);\n@@ -184,1 +184,1 @@\n-        Optional<MemorySegment> dispose_face_symbol = SYM_LOOKUP.find(\"HBDisposeFace\");\n+        MemorySegment dispose_face_symbol = SYM_LOOKUP.findOrThrow(\"HBDisposeFace\");\n@@ -186,1 +186,1 @@\n-        MethodHandle tmp3 = LINKER.downcallHandle(dispose_face_symbol.get(), disposeFaceDescriptor);\n+        MethodHandle tmp3 = LINKER.downcallHandle(dispose_face_symbol, disposeFaceDescriptor);\n@@ -207,1 +207,1 @@\n-        Optional<MemorySegment> shape_sym = SYM_LOOKUP.find(\"jdk_hb_shape\");\n+        MemorySegment shape_sym = SYM_LOOKUP.findOrThrow(\"jdk_hb_shape\");\n@@ -209,1 +209,1 @@\n-        MethodHandle tmp4 = LINKER.downcallHandle(shape_sym.get(), shapeDesc);\n+        MethodHandle tmp4 = LINKER.downcallHandle(shape_sym, shapeDesc);\n@@ -263,1 +263,1 @@\n-        Optional<MemorySegment> create_font_funcs_symbol = SYM_LOOKUP.find(\"HBCreateFontFuncs\");\n+        MemorySegment create_font_funcs_symbol = SYM_LOOKUP.findOrThrow(\"HBCreateFontFuncs\");\n@@ -266,1 +266,1 @@\n-            LINKER.downcallHandle(create_font_funcs_symbol.get(), createFontFuncsDescriptor);\n+            LINKER.downcallHandle(create_font_funcs_symbol, createFontFuncsDescriptor);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/HBShaper.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+import java.awt.image.MultiResolutionImage;\n@@ -1135,0 +1136,3 @@\n+        } else if (img instanceof MultiResolutionImage) {\n+            return convertToBufferedImage((MultiResolutionImage) img,\n+                                           img.getWidth(null), img.getHeight(null));\n@@ -1145,0 +1149,12 @@\n+    protected BufferedImage convertToBufferedImage(MultiResolutionImage multiResolutionImage,\n+                                                       double width, double height ) {\n+        Image resolutionImage = multiResolutionImage.getResolutionVariant(width, height);\n+        BufferedImage bufferedImage = new BufferedImage(resolutionImage.getWidth(null),\n+                                                        resolutionImage.getHeight(null),\n+                                                        BufferedImage.TYPE_INT_ARGB);\n+        Graphics2D g2d = bufferedImage.createGraphics();\n+        g2d.drawImage(resolutionImage, 0, 0, (int) width, (int) height, null);\n+        g2d.dispose();\n+        return bufferedImage;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PathGraphics.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1320,1 +1320,1 @@\n-    public static boolean isPrinting(Graphics g) {\n+    static boolean isPrinting(Graphics g) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/SwingUtilities2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -507,0 +507,2 @@\n+#define TOO_LARGE(a, b) (abs((int)(a \/ b)) > 32766)\n+\n@@ -518,0 +520,1 @@\n+        free(context);\n@@ -527,0 +530,4 @@\n+    if (ptsz > 16384) {\n+        ptsz = 16384;    \/\/ far enough from 32767\n+        fm = TEXT_FM_ON; \/\/ avoids calculations which might overflow\n+    }\n@@ -528,0 +535,7 @@\n+    if (TOO_LARGE(dmat[0], ptsz) || TOO_LARGE(dmat[1], ptsz) ||\n+        TOO_LARGE(dmat[2], ptsz) || TOO_LARGE(dmat[3], ptsz))\n+    {\n+        free(context);\n+        return (jlong)0;\n+    }\n+\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/freetypeScaler.c","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,2 +103,2 @@\n-    private static Long openThemeImpl(String widget, int dpi) {\n-       Long theme;\n+    private static long openThemeImpl(String widget, int dpi) {\n+       long theme;\n@@ -110,1 +110,1 @@\n-           theme = openTheme(widget.substring(i + 2), dpi);\n+           theme = getOpenThemeValue(widget.substring(i + 2), dpi);\n@@ -113,1 +113,1 @@\n-           theme = openTheme(widget, dpi);\n+           theme = getOpenThemeValue(widget, dpi);\n@@ -118,0 +118,9 @@\n+    private static long getOpenThemeValue(String widget, int dpi) {\n+        long theme;\n+        theme = openTheme(widget, dpi);\n+        if (theme == 0) {\n+            theme = openTheme(widget, defaultDPI);\n+        }\n+        return theme;\n+    }\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/ThemeReader.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,11 +122,0 @@\n-\/\/ Some macros from awt.h, because it is not included in release\n-#ifndef IS_WIN2000\n-#define IS_WIN2000 (LOBYTE(LOWORD(::GetVersion())) >= 5)\n-#endif\n-#ifndef IS_WINXP\n-#define IS_WINXP ((IS_WIN2000 && HIBYTE(LOWORD(::GetVersion())) >= 1) || LOBYTE(LOWORD(::GetVersion())) > 5)\n-#endif\n-#ifndef IS_WINVISTA\n-#define IS_WINVISTA (!(::GetVersion() & 0x80000000) && LOBYTE(LOWORD(::GetVersion())) >= 6)\n-#endif\n-\n@@ -1093,6 +1082,4 @@\n-                if (IS_WINXP) {\n-                    for (int i = 0; i < nBits; i++) {\n-                        if ((colorBits[i] & 0xff000000) != 0) {\n-                            hasAlpha = TRUE;\n-                            break;\n-                        }\n+                for (int i = 0; i < nBits; i++) {\n+                    if ((colorBits[i] & 0xff000000) != 0) {\n+                        hasAlpha = TRUE;\n+                        break;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/ShellFolder2.cpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,0 @@\n-            proxyAddress = req.proxy();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AuthenticationFilter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,8 +111,4 @@\n-                if (destination.getHostName() != null) {\n-                    if (!destination.getHostName().equalsIgnoreCase(\n-                            other.destination.getHostName())) {\n-                        return false;\n-                    }\n-                } else {\n-                    if (other.destination.getHostName() != null)\n-                        return false;\n+                String hostString = destination.getHostString();\n+                if (hostString == null || !hostString.equalsIgnoreCase(\n+                        other.destination.getHostString())) {\n+                    return false;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,1 +412,1 @@\n-        if (keepAlive && checkOpen()) {\n+        if (keepAlive && isOpen()) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1727,1 +1727,2 @@\n-            STREAM_STATE = MethodHandles.lookup()\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            STREAM_STATE = lookup\n@@ -1729,1 +1730,1 @@\n-            DEREGISTERED = MethodHandles.lookup()\n+            DEREGISTERED = lookup\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,0 @@\n-    static String cacheName;\n-\n@@ -108,3 +106,1 @@\n-    public static String cacheName() {\n-        return cacheName;\n-    }\n+    public abstract String cacheName();\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/ccache\/CredentialsCache.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    implements FileCCacheConstants {\n+        implements FileCCacheConstants {\n@@ -75,0 +75,2 @@\n+    private final String localCacheName;\n+\n@@ -78,1 +80,1 @@\n-            FileCredentialsCache fcc = new FileCredentialsCache();\n+            String cacheName;\n@@ -88,0 +90,1 @@\n+            FileCredentialsCache fcc = new FileCredentialsCache(cacheName);\n@@ -91,1 +94,1 @@\n-            fcc.load(cacheName);\n+            fcc.load();\n@@ -109,2 +112,1 @@\n-            FileCredentialsCache fcc = new FileCredentialsCache();\n-            cacheName = FileCredentialsCache.checkValidation(name);\n+            String cacheName = FileCredentialsCache.checkValidation(name);\n@@ -112,1 +114,1 @@\n-                \/\/ invalid cache name or the file doesn't exist\n+                \/\/ invalid cache name\n@@ -115,1 +117,2 @@\n-            fcc.init(principal, cacheName);\n+            FileCredentialsCache fcc = new FileCredentialsCache(cacheName);\n+            fcc.init(principal);\n@@ -125,3 +128,3 @@\n-            FileCredentialsCache fcc = new FileCredentialsCache();\n-            cacheName = FileCredentialsCache.getDefaultCacheName();\n-            fcc.init(principal, cacheName);\n+            String cacheName = FileCredentialsCache.getDefaultCacheName();\n+            FileCredentialsCache fcc = new FileCredentialsCache(cacheName);\n+            fcc.init(principal);\n@@ -138,1 +141,2 @@\n-    private FileCredentialsCache() {\n+    private FileCredentialsCache(String cacheName) {\n+        localCacheName = cacheName;\n@@ -141,3 +145,3 @@\n-    boolean exists(String cache) {\n-        File file = new File(cache);\n-        return file.exists();\n+    @Override\n+    public String cacheName() {\n+        return localCacheName;\n@@ -146,2 +150,2 @@\n-    synchronized void init(PrincipalName principal, String name)\n-        throws IOException, KrbException {\n+    synchronized void init(PrincipalName principal)\n+            throws IOException, KrbException {\n@@ -149,1 +153,1 @@\n-        try (FileOutputStream fos = new FileOutputStream(name);\n+        try (FileOutputStream fos = new FileOutputStream(localCacheName);\n@@ -154,1 +158,1 @@\n-        load(name);\n+        load();\n@@ -157,4 +161,3 @@\n-    synchronized void load(String name) throws IOException, KrbException {\n-        PrincipalName p;\n-        try (FileInputStream fis = new FileInputStream(name);\n-             CCacheInputStream cis = new CCacheInputStream(fis)) {\n+    synchronized void load() throws IOException, KrbException {\n+        try (FileInputStream fis = new FileInputStream(localCacheName);\n+                CCacheInputStream cis = new CCacheInputStream(fis)) {\n@@ -170,1 +173,1 @@\n-            p = cis.readPrincipal(version);\n+            PrincipalName p = cis.readPrincipal(version);\n@@ -176,1 +179,1 @@\n-            } else\n+            } else {\n@@ -178,0 +181,1 @@\n+            }\n@@ -248,2 +252,2 @@\n-        try (FileOutputStream fos = new FileOutputStream(cacheName);\n-             CCacheOutputStream cos = new CCacheOutputStream(fos)) {\n+        try (FileOutputStream fos = new FileOutputStream(localCacheName);\n+                CCacheOutputStream cos = new CCacheOutputStream(fos)) {\n@@ -536,1 +540,1 @@\n-                if (!(temp.isDirectory()))\n+                if (!(temp.isDirectory())) {\n@@ -538,1 +542,1 @@\n-                temp = null;\n+                }\n@@ -540,2 +544,0 @@\n-            fCheck = null;\n-\n@@ -557,1 +559,0 @@\n-\n@@ -585,1 +586,1 @@\n-                            (\"KRB5CCNAME=\")) {\n+                                (\"KRB5CCNAME=\")) {\n@@ -591,1 +592,3 @@\n-            } else     s1 = commandResult.readLine();\n+            } else {\n+                s1 = commandResult.readLine();\n+            }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/ccache\/FileCredentialsCache.java","additions":36,"deletions":33,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\n- *  (C) Copyright IBM Corp. 1999 All Rights Reserved.\n- *  Copyright 1997 The Open Group Research Institute.  All rights reserved.\n- *\/\n-\n-package sun.security.krb5.internal.ccache;\n-\n-import sun.security.krb5.KrbException;\n-import sun.security.krb5.PrincipalName;\n-\n-import java.io.File;\n-import java.io.IOException;\n-\n-\/\/Windows supports the \"API: cache\" type, which is a shared memory cache.  This is\n-\/\/implemented by krbcc32.dll as part of the MIT Kerberos for Win32 distribution.\n-\/\/MemoryCredentialsCache will provide future functions to access shared memory cache on\n-\/\/Windows platform. Native code implementation may be necessary.\n-\/**\n- * This class extends CredentialsCache. It is used for accessing data in shared memory\n- * cache on Windows platforms.\n- *\n- * @author Yanni Zhang\n- *\/\n-public abstract class MemoryCredentialsCache extends CredentialsCache {\n-\n-    private static CredentialsCache getCCacheInstance(PrincipalName p) {\n-        return null;\n-    }\n-\n-    private static CredentialsCache getCCacheInstance(PrincipalName p, File cacheFile) {\n-        return null;\n-    }\n-\n-\n-    public abstract boolean exists(String cache);\n-\n-    public abstract void update(Credentials c);\n-\n-    public abstract void save() throws IOException, KrbException;\n-\n-    public abstract Credentials[] getCredsList();\n-\n-    public abstract Credentials getCreds(PrincipalName sname) ;\n-\n-    public abstract PrincipalName getPrimaryPrincipal();\n-\n-}\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/ccache\/MemoryCredentialsCache.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -147,3 +147,4 @@\n-                target = CredentialsCache.getInstance();\n-                name = CredentialsCache.cacheName();\n-            } else\n+                CredentialsCache cc = CredentialsCache.getInstance();\n+                target = cc;\n+                name = cc.cacheName();\n+            } else {\n@@ -151,1 +152,1 @@\n-\n+            }\n@@ -175,2 +176,3 @@\n-                target = CredentialsCache.getInstance();\n-                name = CredentialsCache.cacheName();\n+                CredentialsCache cc = CredentialsCache.getInstance();\n+                target = cc;\n+                name = cc.cacheName();\n","filename":"src\/java.security.jgss\/windows\/classes\/sun\/security\/krb5\/internal\/tools\/Klist.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.source.tree;\n-\n-import java.util.List;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * A tree node for a string template expression.\n- *\n- * @since 21\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-public interface StringTemplateTree extends ExpressionTree {\n-    \/**\n-     * Returns templated string processor (may be qualified) or null.\n-     *\n-     * @return templated string processor\n-     *\/\n-    ExpressionTree getProcessor();\n-\n-    \/**\n-     * Returns string fragments.\n-     *\n-     * @return string fragments\n-     *\/\n-    List<String> getFragments();\n-\n-    \/**\n-     * Returns list of expressions.\n-     *\n-     * @return list of expressions\n-     *\/\n-    List<? extends ExpressionTree> getExpressions();\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/StringTemplateTree.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -178,7 +176,0 @@\n-        \/**\n-         * Used for instances of {@link StringTemplateTree}.\n-         * @since 21\n-         *\/\n-        @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-        TEMPLATE(StringTemplateTree.class),\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -262,10 +260,0 @@\n-    \/**\n-     * Visits a StringTemplateTree node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-    R visitStringTemplate(StringTemplateTree node, P p);\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -631,14 +630,0 @@\n-    \/**\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     * @since 21\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-    public R visitStringTemplate(StringTemplateTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -778,18 +777,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     * @since 21\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-    public R visitStringTemplate(StringTemplateTree node, P p) {\n-        R r = scan(node.getProcessor(), p);\n-        r = scanAndReduce(node.getExpressions(), p, r);\n-        return r;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n@@ -281,1 +281,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n@@ -458,1 +458,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    \/*****************************************\n+    \/* ***************************************\n@@ -281,1 +281,1 @@\n-    \/**\n+    \/*\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -210,1 +210,0 @@\n-            case STRING_TEMPLATES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    \/** 1.0 had no inner classes, and so could not pass the JCK. *\/\n+    \/* 1.0 had no inner classes, and so could not pass the JCK. *\/\n@@ -53,1 +53,1 @@\n-    \/** 1.1 did not have strictfp, and so could not pass the JCK. *\/\n+    \/* 1.1 did not have strictfp, and so could not pass the JCK. *\/\n@@ -253,1 +253,0 @@\n-        STRING_TEMPLATES(JDK21, Fragments.FeatureStringTemplates, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,6 +245,0 @@\n-    \/\/ For string templates\n-    public final Type stringTemplateType;\n-    public final Type templateRuntimeType;\n-    public final Type processorType;\n-    public final Type linkageType;\n-\n@@ -644,6 +638,0 @@\n-        \/\/ For string templates\n-        stringTemplateType = enterClass(\"java.lang.StringTemplate\");\n-        templateRuntimeType = enterClass(\"java.lang.runtime.TemplateRuntime\");\n-        processorType = enterClass(\"java.lang.StringTemplate$Processor\");\n-        linkageType = enterClass(\"java.lang.StringTemplate$Processor$Linkage\");\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-    \/** Navigation methods, these will work for classes, type variables,\n+    \/* Navigation methods, these will work for classes, type variables,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1018,1 +1018,1 @@\n-    \/********************\n+    \/* ******************\n@@ -1171,1 +1171,1 @@\n-    \/*********************\n+    \/* *******************\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4995,26 +4995,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        JCExpression processor = tree.processor;\n-        Type processorType = attribTree(processor, env, new ResultInfo(KindSelector.VAL, Type.noType));\n-        chk.checkProcessorType(processor, processorType, env);\n-        Type processMethodType = getProcessMethodType(tree, processorType);\n-        tree.processMethodType = processMethodType;\n-        Type resultType = processMethodType.getReturnType();\n-\n-        Env<AttrContext> localEnv = env.dup(tree, env.info.dup());\n-\n-        for (JCExpression arg : tree.expressions) {\n-            chk.checkNonVoid(arg.pos(), attribExpr(arg, localEnv));\n-        }\n-\n-        tree.type = resultType;\n-        result = resultType;\n-        check(tree, resultType, KindSelector.VAL, resultInfo);\n-    }\n-\n-    private Type getProcessMethodType(JCStringTemplate tree, Type processorType) {\n-        MethodSymbol processSymbol = rs.resolveInternalMethod(tree.pos(),\n-                env, types.skipTypeVars(processorType, false),\n-                names.process, List.of(syms.stringTemplateType), List.nil());\n-        return types.memberType(processorType, processSymbol);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4478,20 +4478,0 @@\n-    public Type checkProcessorType(JCExpression processor, Type resultType, Env<AttrContext> env) {\n-        Type processorType = processor.type;\n-        Type interfaceType = types.asSuper(processorType, syms.processorType.tsym);\n-\n-        if (interfaceType != null) {\n-            List<Type> typeArguments = interfaceType.getTypeArguments();\n-\n-            if (typeArguments.size() == 2) {\n-                resultType = typeArguments.head;\n-            } else {\n-                resultType = syms.objectType;\n-            }\n-        } else {\n-            log.error(DiagnosticFlag.RESOLVE_ERROR, processor.pos,\n-                    Errors.NotAProcessorType(processorType.tsym));\n-        }\n-\n-        return resultType;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -62,5 +62,4 @@\n-        TRANSLITERALS(7),\n-        TRANSPATTERNS(8),\n-        UNLAMBDA(9),\n-        LOWER(10),\n-        GENERATE(11);\n+        TRANSPATTERNS(7),\n+        UNLAMBDA(8),\n+        LOWER(9),\n+        GENERATE(10);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-        new ThisEscapeAnalyzer(names, syms, types, log, lint).analyzeTree(env);\n+        new ThisEscapeAnalyzer(names, syms, types, rs, log, lint).analyzeTree(env);\n@@ -484,1 +484,0 @@\n-        \/\/ Note: This method also sends nested class definitions to the handler.\n@@ -493,0 +492,5 @@\n+\n+                    \/\/ Don't recurse into nested classes\n+                    if (def.hasTag(CLASSDEF))\n+                        continue;\n+\n@@ -525,1 +529,1 @@\n-    \/*************************************************************************\n+    \/* ***********************************************************************\n@@ -569,0 +573,7 @@\n+                \/\/ process all the nested classes\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(CLASSDEF)) {\n+                        scan(l.head);\n+                    }\n+                }\n+\n@@ -1322,1 +1333,1 @@\n-    \/**************************************************************************\n+    \/* ************************************************************************\n@@ -1438,1 +1449,1 @@\n-    \/*************************************************************************\n+    \/* ***********************************************************************\n@@ -1462,0 +1473,7 @@\n+                \/\/ process all the nested classes\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(CLASSDEF)) {\n+                        scan(l.head);\n+                    }\n+                }\n+\n@@ -1747,9 +1765,0 @@\n-        @Override\n-        public void visitStringTemplate(JCStringTemplate tree) {\n-            for (Type thrown : tree.processMethodType.getThrownTypes()) {\n-                markThrown(tree, thrown);\n-            }\n-\n-            scan(tree.expressions);\n-        }\n-\n@@ -1908,1 +1917,1 @@\n-    \/**************************************************************************\n+    \/* ************************************************************************\n@@ -2180,9 +2189,1 @@\n-            if (!isConstructor) {\n-                inits.inclRange(returnadr, nextadr);\n-            } else {\n-                for (int address = returnadr; address < nextadr; address++) {\n-                    if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {\n-                        inits.incl(address);\n-                    }\n-                }\n-            }\n+            inits.inclRange(returnadr, nextadr);\n@@ -2210,4 +2211,0 @@\n-        boolean isFinalUninitializedStaticField(VarSymbol sym) {\n-            return isFinalUninitializedField(sym) && sym.isStatic();\n-        }\n-\n@@ -2432,1 +2429,1 @@\n-                    \/\/ verify all static final fields got initailized\n+                    \/\/ verify all static final fields got initialized\n@@ -2460,0 +2457,7 @@\n+\n+                    \/\/ process all the nested classes\n+                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                        if (l.head.hasTag(CLASSDEF)) {\n+                            scan(l.head);\n+                        }\n+                    }\n@@ -3222,1 +3226,1 @@\n-    \/**************************************************************************\n+    \/* ************************************************************************\n@@ -3341,1 +3345,1 @@\n-    \/*************************************************************************\n+    \/* ***********************************************************************\n@@ -3460,1 +3464,1 @@\n-    \/**************************************************************************\n+    \/* ************************************************************************\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":36,"deletions":32,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -799,1 +799,1 @@\n-        \/****\n+        \/* **\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -650,1 +650,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -787,1 +787,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -941,1 +941,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -1516,1 +1516,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -1953,1 +1953,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -2012,1 +2012,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -2081,1 +2081,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -2175,1 +2175,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -4443,1 +4443,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.EnumSet;\n@@ -42,0 +43,2 @@\n+import java.util.function.Predicate;\n+import java.util.stream.Collector;\n@@ -75,3 +78,10 @@\n- * A 'this' escape is when a constructor invokes a method that could be overridden in a\n- * subclass, in which case the method will execute before the subclass constructor has\n- * finished initializing the instance.\n+ * A 'this' escape occurs in the following scenario:\n+ * <ul>\n+ *  <li>There is some class {@code A} and some subclass {@code B} that extends it\n+ *  <li>{@code A} defines an instance method {@code m()} which is overridden in {@code B}\n+ *  <li>Some constructor {@code B()} invokes some superclass constructor {@code A()}\n+ *  <li>At some point during the execution of {@code A()}, method {@code m()} is invoked and the\n+ *      reciever for the instance method is the new instance being constructed by {@code B()}\n+ * <\/ul>\n+ * This represents a problem because the method {@code B.m()} will execute before the constructor\n+ * {@code B()} has performed any of its own initialization.\n@@ -86,3 +96,10 @@\n- * As we analyze constructors and the methods they invoke, we track the various things in scope\n- * that could possibly reference the 'this' instance we are following. Such references are\n- * represented by {@link Ref} instances, of which there are these varieties:\n+ * As we analyze constructors and the methods they invoke, we track the various object references that\n+ * might reference the 'this' instance we are watching (i.e., the one under construction). Such object\n+ * references are represented by the {@link Ref} class hierarchy, which models the various ways in which,\n+ * at any point during the execution of a constructor or some other method or constructor that it invokes,\n+ * there can live references to the object under construction lying around. In a nutshell, the analyzer\n+ * keeps track of these references and watches what happens to them as the code executes so it can catch\n+ * them in the act of trying to \"escape\".\n+ *\n+ * <p>\n+ * The {@link Ref} sub-types are:\n@@ -90,6 +107,5 @@\n- *  <li>The current 'this' reference; see {@link ThisRef}\n- *  <li>The current outer 'this' reference; see {@link OuterRef}\n- *  <li>Local variables and method parameters; see {@link VarRef}\n- *  <li>The current expression being evaluated, i.e.,what's on top of the Java stack; see {@link ExprRef}\n- *  <li>The current switch expressions's yield value; see {@link YieldRef}\n- *  <li>The current method's return value; see {@link ReturnRef}\n+ *  <li>{@link ThisRef} - The current 'this' instance of the (instance) method being analyzed\n+ *  <li>{@link ExprRef} - The current expression being evaluated, i.e., what's on top of the Java stack\n+ *  <li>{@link VarRef} - Local variables and method parameters currently in scope\n+ *  <li>{@link YieldRef} - The current switch expression's yield value(s)\n+ *  <li>{@link ReturnRef} - The current method's return value(s)\n@@ -99,4 +115,1 @@\n- * For each type of reference, we distinguish between <i>direct<\/i> and <i>indirect<\/i> references.\n- * A direct reference means the reference directly refers to the 'this' instance we are tracking.\n- * An indirect reference means the reference refers to the 'this' instance we are tracking through\n- * at least one level of indirection.\n+ * Currently we don't attempt to explicitly track references stored in fields (for future study).\n@@ -105,1 +118,3 @@\n- * Currently we do not attempt to explicitly track references stored in fields (for future study).\n+ * For each object reference represented by a {@link Ref}, we track up to three distinct ways in which\n+ * it might refer to the new 'this' instance: the reference can be direct, indirect, or via an associated\n+ * enclosing instance (see {@link Indirection}).\n@@ -110,4 +125,6 @@\n- *  <li>We \"execute\" constructors and track where the 'this' reference goes as the constructor executes.\n- *  <li>We use a very simplified flow analysis that you might call a \"flood analysis\", where the union\n- *      of every possible code branch is taken.\n- *  <li>A \"leak\" is defined as the possible passing of a subclassed 'this' reference to code defined\n+ *  <li>We \"execute\" constructors and track how the {@link Ref}'s evolve as the constructor executes.\n+ *  <li>We use a simplified \"flooding\" flow analysis where every possible code branch is taken and\n+ *      we take the union of the resulting {@link Ref}'s that are generated.\n+ *  <li>Loops are repeated until the set of {@link Ref}'s stabilizes; the maximum number of iterations\n+ *      possible is proportional to the number of variables in scope.\n+ *  <li>An \"escape\" is defined as the possible passing of a subclassed 'this' reference to code defined\n@@ -134,0 +151,1 @@\n+    private final Resolve rs;\n@@ -139,0 +157,4 @@\n+    \/** Environment for symbol lookup.\n+     *\/\n+    private Env<AttrContext> attrEnv;\n+\n@@ -147,0 +169,4 @@\n+    \/** Contains classes whose outer instance (if any) is non-public.\n+     *\/\n+    private final Set<ClassSymbol> nonPublicOuters = new HashSet<>();\n+\n@@ -192,1 +218,1 @@\n-    ThisEscapeAnalyzer(Names names, Symtab syms, Types types, Log log, Lint lint) {\n+    ThisEscapeAnalyzer(Names names, Symtab syms, Types types, Resolve rs, Log log, Lint lint) {\n@@ -196,0 +222,1 @@\n+        this.rs = rs;\n@@ -224,10 +251,0 @@\n-        \/\/ Build a set of symbols for classes declared in this file\n-        final Set<Symbol> classSyms = new HashSet<>();\n-        new TreeScanner() {\n-            @Override\n-            public void visitClassDef(JCClassDecl tree) {\n-                classSyms.add(tree.sym);\n-                super.visitClassDef(tree);\n-            }\n-        }.scan(env.tree);\n-\n@@ -237,0 +254,1 @@\n+        \/\/ Record classes whose outer instance (if any) is non-public.\n@@ -251,0 +269,2 @@\n+\n+                    \/\/ Track which clases have non-public outer instances\n@@ -253,0 +273,2 @@\n+                    if (nonPublicOuter)\n+                        nonPublicOuters.add(currentClass.sym);\n@@ -338,1 +360,1 @@\n-                    visitTopLevel(klass, () -> {\n+                    visitTopLevel(env, klass, () -> {\n@@ -347,1 +369,1 @@\n-                    visitTopLevel(klass, () -> analyzeStatements(block.stats));\n+                    visitTopLevel(env, klass, () -> analyzeStatements(block.stats));\n@@ -357,1 +379,1 @@\n-            visitTopLevel(methodInfo.declaringClass(),\n+            visitTopLevel(env, methodInfo.declaringClass(),\n@@ -483,0 +505,4 @@\n+        visitVarDef(tree.sym, tree.init);\n+    }\n+\n+    private void visitVarDef(VarSymbol sym, JCExpression expr) {\n@@ -485,1 +511,1 @@\n-        if (suppressed.contains(tree.sym))\n+        if (suppressed.contains(sym))\n@@ -489,3 +515,3 @@\n-        scan(tree.init);\n-        if (isParamOrVar(tree.sym))\n-            refs.replaceExprs(depth, direct -> new VarRef(tree.sym, direct));\n+        scan(expr);\n+        if (isParamOrVar(sym))\n+            refs.replaceExprs(depth, ref -> new VarRef(sym, ref));\n@@ -511,1 +537,1 @@\n-        \/\/ Recurse on method expression\n+        \/\/ Recurse on method expression and gather references from the method itself (if non-static)\n@@ -513,4 +539,0 @@\n-        boolean direct = refs.remove(ExprRef.direct(depth));\n-        boolean indirect = refs.remove(ExprRef.indirect(depth));\n-\n-        \/\/ Determine if method receiver represents a possible reference\n@@ -519,5 +541,5 @@\n-            if (direct)\n-                receiverRefs.add(ThisRef.direct());\n-            if (indirect)\n-                receiverRefs.add(ThisRef.indirect());\n-        }\n+            refs.removeExprs(depth)\n+              .map(ThisRef::new)\n+              .forEach(receiverRefs::add);\n+        } else\n+            refs.discardExprs(depth);\n@@ -533,1 +555,1 @@\n-    private void invoke(JCTree site, Symbol sym, List<JCExpression> args, RefSet<?> receiverRefs) {\n+    private void invoke(JCTree site, Symbol sym, List<JCExpression> args, RefSet<ThisRef> receiverRefs) {\n@@ -547,1 +569,1 @@\n-        \/\/ Analyze method if possible, otherwise assume nothing\n+        \/\/ See if this method is known because it's declared somewhere in our file\n@@ -549,0 +571,24 @@\n+\n+        \/\/ If the method is not matched exactly, look a little harder. This especially helps\n+        \/\/ with anonymous interface classes, where the method symbols won't match.\n+        \/\/\n+        \/\/ For example:\n+        \/\/\n+        \/\/  public Leaker() {\n+        \/\/      Runnable r = new Runnable() {\n+        \/\/          public void run() {\n+        \/\/              Leaker.this.mightLeak();\n+        \/\/          }\n+        \/\/      };\n+        \/\/      r.run();    \/\/ \"r\" has type Runnable, but we know it's really a Leaker$1\n+        \/\/  }\n+        \/\/\n+        if (methodInfo == null && receiverRefs.size() == 1) {\n+            ThisRef receiverRef = receiverRefs.iterator().next();\n+            methodInfo = methodMap.values().stream()\n+              .filter(info -> isTargetMethod(info, sym, receiverRef.tsym))\n+              .findFirst()\n+              .orElse(null);\n+        }\n+\n+        \/\/ Analyze method if possible, otherwise assume nothing\n@@ -555,0 +601,10 @@\n+    \/\/ Can we conclude that \"info\" represents the actual method invoked?\n+    private boolean isTargetMethod(MethodInfo info, Symbol method, TypeSymbol receiverType) {\n+        return method.kind == MTH &&                                            \/\/ not an error symbol, etc.\n+          info.declaration.name == method.name &&                               \/\/ method name matches\n+          info.declaringClass.sym == receiverType &&                            \/\/ same class as receiver\n+          !info.declaration.sym.isConstructor() &&                              \/\/ not a constructor\n+          (info.declaration.sym.flags() & Flags.STATIC) == 0 &&                 \/\/ not a static method\n+          info.declaration.sym.overrides(method, receiverType, types, false);   \/\/ method overrides\n+    }\n+\n@@ -557,1 +613,1 @@\n-        RefSet<?> receiverRefs, MethodInfo methodInfo) {\n+            RefSet<ThisRef> receiverRefs, MethodInfo methodInfo) {\n@@ -567,1 +623,3 @@\n-            refs.removeExprs(depth, direct -> paramRefs.add(new VarRef(sym, direct)));\n+            refs.removeExprs(depth)\n+              .map(ref -> new VarRef(sym, ref))\n+              .forEach(paramRefs::add);\n@@ -604,2 +662,11 @@\n-            \/\/ \"Return\" any references from method return value\n-            refs.mapInto(refsPrev, ReturnRef.class, direct -> new ExprRef(depthPrev, direct));\n+            \/\/ Constructors \"return\" their new instances\n+            if (TreeInfo.isConstructor(methodInfo.declaration)) {\n+                refs.remove(ThisRef.class)\n+                  .map(ReturnRef::new)\n+                  .forEach(refs::add);\n+            }\n+\n+            \/\/ \"Return\" any references from method return statements\n+            refs.remove(ReturnRef.class)\n+              .map(ref -> new ExprRef(depthPrev, ref))\n+              .forEach(refsPrev::add);\n@@ -614,2 +681,2 @@\n-    \/\/ Handle invocation of an unknown or overridable method or constructor\n-    private void invokeUnknown(JCTree invoke, List<JCExpression> args, RefSet<?> receiverRefs) {\n+    \/\/ Handle invocation of an unknown or overridable method or constructor.\n+    private void invokeUnknown(JCTree invoke, List<JCExpression> args, RefSet<ThisRef> receiverRefs) {\n@@ -618,1 +685,1 @@\n-        if (!receiverRefs.isEmpty())\n+        if (receiverRefs.stream().anyMatch(this::triggersUnknownInvokeLeak))\n@@ -621,1 +688,1 @@\n-        \/\/ Detect leaks via method parameters\n+        \/\/ Detect leaks via method parameters (except via non-public outer instance)\n@@ -624,1 +691,1 @@\n-            if (refs.discardExprs(depth))\n+            if (refs.removeExprs(depth).anyMatch(this::triggersUnknownInvokeLeak))\n@@ -627,0 +694,14 @@\n+\n+        \/\/ Constructors \"return\" their new instance, so we should return the receiver refs\n+        if (invoke.hasTag(NEWCLASS)) {\n+            receiverRefs.stream()\n+              .map(ref -> new ExprRef(depth, ref))\n+              .forEach(refs::add);\n+        }\n+    }\n+\n+    \/\/ Determine if a reference should qualify as a leak if it's passed to an unknown method.\n+    \/\/ To avoid false positives, we exclude references from non-public outer instances.\n+    private boolean triggersUnknownInvokeLeak(Ref ref) {\n+        return !nonPublicOuters.contains(ref.tsym) ||\n+          ref.indirections.stream().anyMatch(i -> i != Indirection.OUTER);\n@@ -636,0 +717,6 @@\n+        TypeSymbol tsym = tree.def != null ? tree.def.sym : tree.clazz.type.tsym;\n+\n+        \/\/ Gather 'this' reference that the new instance itself will have\n+        RefSet<ThisRef> receiverRefs = receiverRefsForConstructor(tree.encl, tsym);\n+\n+        \/\/ \"Invoke\" the constructor\n@@ -637,1 +724,1 @@\n-            invokeInvokable(tree, tree.args, outerThisRefs(tree.encl, tree.clazz.type), methodInfo);\n+            invokeInvokable(tree, tree.args, receiverRefs, methodInfo);\n@@ -639,1 +726,1 @@\n-            invokeUnknown(tree, tree.args, outerThisRefs(tree.encl, tree.clazz.type));\n+            invokeUnknown(tree, tree.args, receiverRefs);\n@@ -642,3 +729,4 @@\n-    \/\/ Determine 'this' references passed to a constructor via the outer 'this' instance\n-    private RefSet<OuterRef> outerThisRefs(JCExpression explicitOuterThis, Type type) {\n-        RefSet<OuterRef> outerRefs = RefSet.newEmpty();\n+    \/\/ Determine the references a constructor will inherit from its outer 'this' instance, if any\n+    private RefSet<ThisRef> receiverRefsForConstructor(JCExpression explicitOuterThis, TypeSymbol tsym) {\n+\n+        \/\/ Create references based on explicit outer instance, if any\n@@ -647,3 +735,12 @@\n-            refs.removeExprs(depth, direct -> outerRefs.add(new OuterRef(direct)));\n-        } else if (type.tsym != methodClass.sym && type.tsym.isEnclosedBy(methodClass.sym)) {\n-            refs.mapInto(outerRefs, ThisRef.class, OuterRef::new);\n+            return refs.removeExprs(depth)\n+              .map(ref -> ref.toOuter(explicitOuterThis.type.tsym))\n+              .flatMap(Optional::stream)\n+              .collect(RefSet.collector());\n+        }\n+\n+        \/\/ Create references based on current outer instance, if any\n+        if (hasImplicitOuterInstance(tsym)) {\n+            return refs.find(ThisRef.class)\n+              .map(ref -> ref.toOuter(tsym))\n+              .flatMap(Optional::stream)\n+              .collect(RefSet.collector());\n@@ -651,1 +748,10 @@\n-        return outerRefs;\n+\n+        \/\/ None\n+        return RefSet.newEmpty();\n+    }\n+\n+    \/\/ Determine if an unqualified \"new Foo()\" constructor gets 'this' as an implicit outer instance\n+    private boolean hasImplicitOuterInstance(TypeSymbol tsym) {\n+        return tsym != methodClass.sym\n+          && tsym.hasOuterInstance()\n+          && tsym.isEnclosedBy(methodClass.sym);\n@@ -681,0 +787,28 @@\n+\n+        \/\/ Check for loop on array\n+        Type elemType = types.elemtype(tree.expr.type);\n+\n+        \/\/ If not array, resolve the Iterable and Iterator methods\n+        record ForeachMethods(MethodSymbol iterator, MethodSymbol hasNext, MethodSymbol next) { };\n+        MethodSymbol iterator = null;\n+        MethodSymbol hasNext = null;\n+        MethodSymbol next = null;\n+        if (elemType == null) {\n+            Symbol iteratorSym = rs.resolveQualifiedMethod(tree.expr.pos(), attrEnv,\n+              tree.expr.type, names.iterator, List.nil(), List.nil());\n+            if (iteratorSym instanceof MethodSymbol) {\n+                iterator = (MethodSymbol)iteratorSym;\n+                Symbol hasNextSym = rs.resolveQualifiedMethod(tree.expr.pos(), attrEnv,\n+                  iterator.getReturnType(), names.hasNext, List.nil(), List.nil());\n+                Symbol nextSym = rs.resolveQualifiedMethod(tree.expr.pos(), attrEnv,\n+                  iterator.getReturnType(), names.next, List.nil(), List.nil());\n+                if (hasNextSym instanceof MethodSymbol)\n+                    hasNext = (MethodSymbol)hasNextSym;\n+                if (nextSym instanceof MethodSymbol)\n+                    next = (MethodSymbol)nextSym;\n+            }\n+        }\n+        ForeachMethods foreachMethods = iterator != null && hasNext != null && next != null ?\n+          new ForeachMethods(iterator, hasNext, next) : null;\n+\n+        \/\/ Iterate loop\n@@ -682,0 +816,2 @@\n+\n+            \/\/ Scan iteration target\n@@ -683,1 +819,34 @@\n-            refs.discardExprs(depth);       \/\/ we don't handle iterator() yet\n+            if (elemType != null) {                     \/\/ array iteration\n+                if (isParamOrVar(foreach.var.sym)) {\n+                    refs.removeExprs(depth)\n+                      .map(ref -> ref.toIndirect(elemType.tsym))\n+                      .flatMap(Optional::stream)\n+                      .map(ref -> new VarRef(foreach.var.sym, ref))\n+                      .forEach(refs::add);\n+                } else\n+                    refs.discardExprs(depth);           \/\/ we don't track fields yet\n+            } else if (foreachMethods != null) {        \/\/ Iterable iteration\n+\n+                \/\/ \"Invoke\" the iterator() method\n+                RefSet<ThisRef> receiverRefs = refs.removeExprs(depth)\n+                  .map(ThisRef::new)\n+                  .collect(RefSet.collector());\n+                invoke(foreach.expr, foreachMethods.iterator, List.nil(), receiverRefs);\n+\n+                \/\/ \"Invoke\" the hasNext() method\n+                receiverRefs = refs.removeExprs(depth)\n+                  .map(ThisRef::new)\n+                  .collect(RefSet.collector());\n+                invoke(foreach.expr, foreachMethods.hasNext, List.nil(), receiverRefs);\n+                refs.discardExprs(depth);\n+\n+                \/\/ \"Invoke\" the next() method\n+                invoke(foreach.expr, foreachMethods.next, List.nil(), receiverRefs);\n+                if (isParamOrVar(foreach.var.sym))\n+                    refs.replaceExprs(depth, ref -> new VarRef(foreach.var.sym, ref));\n+                else\n+                    refs.discardExprs(depth);           \/\/ we don't track fields yet\n+            } else                                      \/\/ what is it???\n+                refs.discardExprs(depth);\n+\n+            \/\/ Scan loop body\n@@ -702,1 +871,1 @@\n-            RefSet<ExprRef> combinedRefs = new RefSet<>();\n+            RefSet<ExprRef> combinedRefs = RefSet.newEmpty();\n@@ -705,2 +874,5 @@\n-                refs.replace(YieldRef.class, direct -> new ExprRef(depth, direct));\n-                combinedRefs.addAll(refs.removeExprs(depth));\n+                refs.remove(YieldRef.class)\n+                  .map(ref -> new ExprRef(depth, ref))\n+                  .forEach(combinedRefs::add);\n+                refs.removeExprs(depth)\n+                  .forEach(combinedRefs::add);\n@@ -736,4 +908,1 @@\n-        visitDeferred(() -> visitScoped(false, () -> {\n-            scan(lambda.body);\n-            refs.discardExprs(depth);       \/\/ needed in case body is a JCExpression\n-        }));\n+        visitDeferred(() -> visitScoped(true, () -> scan(lambda.body)));\n@@ -744,0 +913,1 @@\n+        VarSymbol sym = (VarSymbol)TreeInfo.symbolFor(tree.lhs);\n@@ -747,1 +917,0 @@\n-        VarSymbol sym = (VarSymbol)TreeInfo.symbolFor(tree.lhs);\n@@ -749,1 +918,1 @@\n-            refs.replaceExprs(depth, direct -> new VarRef(sym, direct));\n+            refs.replaceExprs(depth, ref -> new VarRef(sym, ref));\n@@ -756,3 +925,0 @@\n-        scan(tree.indexed);\n-        refs.remove(ExprRef.direct(depth));\n-        boolean indirectRef = refs.remove(ExprRef.indirect(depth));\n@@ -761,4 +927,5 @@\n-        if (indirectRef) {\n-            refs.add(ExprRef.direct(depth));\n-            refs.add(ExprRef.indirect(depth));\n-        }\n+        scan(tree.indexed);\n+        refs.removeExprs(depth)\n+          .map(ref -> ref.toDirect(tree.type.tsym))\n+          .flatMap(Optional::stream)\n+          .forEach(refs::add);\n@@ -770,1 +937,1 @@\n-        \/\/ Scan the selected thing\n+        \/\/ Scan the selection target (i.e., the method)\n@@ -772,2 +939,1 @@\n-        boolean selectedDirectRef = refs.remove(ExprRef.direct(depth));\n-        boolean selectedIndirectRef = refs.remove(ExprRef.indirect(depth));\n+        Stream<ExprRef> methodRefs = refs.removeExprs(depth);\n@@ -775,1 +941,1 @@\n-        \/\/ Explicit 'this' reference?\n+        \/\/ Explicit 'this' reference? The expression references whatever 'this' references\n@@ -777,2 +943,4 @@\n-        if (isExplicitThisReference(types, currentClassType, tree)) {\n-            refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n+        if (TreeInfo.isExplicitThisReference(types, currentClassType, tree)) {\n+            refs.find(ThisRef.class)\n+              .map(ref -> new ExprRef(depth, ref))\n+              .forEach(refs::add);\n@@ -782,22 +950,6 @@\n-        \/\/ Explicit outer 'this' reference?\n-        Type selectedType = types.erasure(tree.selected.type);\n-        if (selectedType.hasTag(CLASS)) {\n-            ClassSymbol currentClassSym = (ClassSymbol)currentClassType.tsym;\n-            ClassSymbol selectedTypeSym = (ClassSymbol)selectedType.tsym;\n-            if (tree.name == names._this &&\n-                    selectedTypeSym != currentClassSym &&\n-                    currentClassSym.isEnclosedBy(selectedTypeSym)) {\n-                refs.mapInto(refs, OuterRef.class, direct -> new ExprRef(depth, direct));\n-                return;\n-            }\n-        }\n-\n-        \/\/ Methods - the \"value\" of a non-static method is a reference to its instance\n-        Symbol sym = tree.sym;\n-        if (sym.kind == MTH) {\n-            if ((sym.flags() & Flags.STATIC) == 0) {\n-                if (selectedDirectRef)\n-                    refs.add(ExprRef.direct(depth));\n-                if (selectedIndirectRef)\n-                    refs.add(ExprRef.indirect(depth));\n-            }\n+        \/\/ Explicit outer 'this' reference? The expression references whatever the outer 'this' references\n+        if (isExplicitOuterThisReference(types, currentClassType, tree)) {\n+            refs.find(ThisRef.class)\n+              .map(ref -> ref.fromOuter(depth))\n+              .flatMap(Optional::stream)\n+              .forEach(refs::add);\n@@ -807,2 +959,3 @@\n-        \/\/ Unknown\n-        return;\n+        \/\/ For regular non-static methods, our expression \"value\" is the method's target instance\n+        if (tree.sym.kind == MTH && (tree.sym.flags() & Flags.STATIC) == 0)\n+            methodRefs.forEach(refs::add);\n@@ -820,2 +973,0 @@\n-        boolean direct = refs.remove(ExprRef.direct(depth));\n-        boolean indirect = refs.remove(ExprRef.indirect(depth));\n@@ -824,1 +975,1 @@\n-        RefSet<Ref> receiverRefs = RefSet.newEmpty();\n+        RefSet<ThisRef> receiverRefs = RefSet.newEmpty();\n@@ -830,0 +981,1 @@\n+            refs.discardExprs(depth);\n@@ -832,2 +984,0 @@\n-            refs.mapInto(receiverRefs, ThisRef.class, ThisRef::new);\n-            break;\n@@ -835,4 +985,3 @@\n-            if (direct)\n-                receiverRefs.add(ThisRef.direct());\n-            if (indirect)\n-                receiverRefs.add(ThisRef.indirect());\n+            refs.removeExprs(depth)\n+              .map(ThisRef::new)\n+              .forEach(receiverRefs::add);\n@@ -841,1 +990,2 @@\n-            receiverRefs.addAll(outerThisRefs(null, tree.expr.type));\n+            receiverRefsForConstructor(null, tree.expr.type.tsym)\n+              .forEach(receiverRefs::add);\n@@ -854,1 +1004,1 @@\n-        \/\/ Reference to this?\n+        \/\/ Explicit 'this' reference? The expression references whatever 'this' references\n@@ -856,1 +1006,3 @@\n-            refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n+            refs.find(ThisRef.class)\n+              .map(ref -> new ExprRef(depth, ref))\n+              .forEach(refs::add);\n@@ -860,1 +1012,1 @@\n-        \/\/ Parameter or local variable?\n+        \/\/ Parameter or local variable? The expression references whatever the variable references\n@@ -863,4 +1015,3 @@\n-            if (refs.contains(VarRef.direct(sym)))\n-                refs.add(ExprRef.direct(depth));\n-            if (refs.contains(VarRef.indirect(sym)))\n-                refs.add(ExprRef.indirect(depth));\n+            refs.find(VarRef.class, ref -> ref.sym == sym)\n+              .map(ref -> new ExprRef(depth, ref))\n+              .forEach(refs::add);\n@@ -871,1 +1022,1 @@\n-        \/\/ The \"value\" of a non-static method is a reference to its instance.\n+        \/\/ The expression \"value\" of a non-static method is a reference to its target instance.\n@@ -878,1 +1029,3 @@\n-                refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n+                refs.find(ThisRef.class)\n+                  .map(ref -> new ExprRef(depth, ref))\n+                  .forEach(refs::add);\n@@ -884,1 +1037,4 @@\n-                refs.mapInto(refs, OuterRef.class, direct -> new ExprRef(depth, direct));\n+                refs.find(ThisRef.class)\n+                  .map(ref -> ref.fromOuter(depth))\n+                  .flatMap(Optional::stream)\n+                  .forEach(refs::add);\n@@ -908,1 +1064,1 @@\n-        RefSet<ExprRef> combinedRefs = new RefSet<>();\n+        RefSet<ExprRef> combinedRefs = RefSet.newEmpty();\n@@ -910,1 +1066,2 @@\n-        combinedRefs.addAll(refs.removeExprs(depth));\n+        refs.removeExprs(depth)\n+          .forEach(combinedRefs::add);\n@@ -912,1 +1069,2 @@\n-        combinedRefs.addAll(refs.removeExprs(depth));\n+        refs.removeExprs(depth)\n+          .forEach(combinedRefs::add);\n@@ -947,1 +1105,1 @@\n-        boolean ref = false;\n+        RefSet<ExprRef> combinedRefs = RefSet.newEmpty();\n@@ -951,1 +1109,4 @@\n-                ref |= refs.discardExprs(depth);\n+                refs.removeExprs(depth)\n+                  .map(ref -> ref.toIndirect(tree.type.tsym))\n+                  .flatMap(Optional::stream)\n+                  .forEach(combinedRefs::add);\n@@ -954,2 +1115,2 @@\n-        if (ref)\n-            refs.add(ExprRef.indirect(depth));\n+        combinedRefs.stream()\n+          .forEach(refs::add);\n@@ -961,0 +1122,1 @@\n+        refs.replaceExprs(depth, ref -> ref.withType(tree.expr.type.tsym));\n@@ -1049,1 +1211,2 @@\n-    private void visitTopLevel(JCClassDecl klass, Runnable action) {\n+    private void visitTopLevel(Env<AttrContext> env, JCClassDecl klass, Runnable action) {\n+        Assert.check(attrEnv == null);\n@@ -1054,0 +1217,1 @@\n+        attrEnv = env;\n@@ -1060,1 +1224,1 @@\n-            refs.add(ThisRef.direct());\n+            refs.add(new ThisRef(targetClass.sym, EnumSet.of(Indirection.DIRECT)));\n@@ -1066,0 +1230,1 @@\n+            attrEnv = null;\n@@ -1078,1 +1243,1 @@\n-    private <T extends JCTree> void visitDeferred(Runnable recurse) {\n+    private <T extends JCTree> void visitDeferred(Runnable deferredCode) {\n@@ -1084,1 +1249,1 @@\n-            recurse.run();\n+            deferredCode.run();\n@@ -1086,0 +1251,4 @@\n+\n+            \/\/ There can be ExprRef's if the deferred code returns something.\n+            \/\/ Don't let them escape unnoticed.\n+            deferredCodeLeaks |= refs.discardExprs(depth);\n@@ -1091,1 +1260,1 @@\n-            refs.add(ExprRef.indirect(depth));\n+            refs.add(new ExprRef(depth, syms.objectType.tsym, EnumSet.of(Indirection.INDIRECT)));\n@@ -1119,1 +1288,3 @@\n-                refs.removeExprs(depth, direct -> refs.add(new ExprRef(depth - 1, direct)));\n+                refs.removeExprs(depth)\n+                  .map(ref -> new ExprRef(depth - 1, ref))\n+                  .forEach(refs::add);\n@@ -1132,0 +1303,1 @@\n+        refs.discardExprs(depth);\n@@ -1133,1 +1305,0 @@\n-        refs.removeIf(ref -> ref.getDepth() > depth);\n@@ -1165,6 +1336,3 @@\n-    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n-     *  class currently being compiled. This is true if tree is:\n-     *  - An unqualified 'this' identifier\n-     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n-     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n-     *    but also NOT an enclosing outer class of 'currentClass'.\n+    \/** Check if the given tree is an explicit reference to the outer 'this' instance of the\n+     *  class currently being compiled. This is true if tree is 'Foo.this' where 'Foo' is\n+     *  the immediately enclosing class of the current class.\n@@ -1172,27 +1340,9 @@\n-    private boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n-        switch (tree.getTag()) {\n-            case PARENS:\n-                return isExplicitThisReference(types, currentClass, TreeInfo.skipParens(tree));\n-            case IDENT:\n-            {\n-                JCIdent ident = (JCIdent)tree;\n-                Names names = ident.name.table.names;\n-                return ident.name == names._this;\n-            }\n-            case SELECT:\n-            {\n-                JCFieldAccess select = (JCFieldAccess)tree;\n-                Type selectedType = types.erasure(select.selected.type);\n-                if (!selectedType.hasTag(CLASS))\n-                    return false;\n-                ClassSymbol currentClassSym = (ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n-                ClassSymbol selectedClassSym = (ClassSymbol)((Type.ClassType)selectedType).tsym;\n-                Names names = select.name.table.names;\n-                return currentClassSym.isSubClass(selectedClassSym, types) &&\n-                        (select.name == names._super ||\n-                        (select.name == names._this &&\n-                            (currentClassSym == selectedClassSym ||\n-                            !currentClassSym.isEnclosedBy(selectedClassSym))));\n-            }\n-            default:\n-                return false;\n+    private boolean isExplicitOuterThisReference(Types types, Type.ClassType currentClass, JCFieldAccess select) {\n+        Type selectedType = types.erasure(select.selected.type);\n+        if (selectedType.hasTag(CLASS)) {\n+            ClassSymbol currentClassSym = (ClassSymbol)currentClass.tsym;\n+            ClassSymbol selectedTypeSym = (ClassSymbol)selectedType.tsym;\n+            if (select.name == names._this &&\n+                    currentClassSym.hasOuterInstance() &&\n+                    currentClassSym.owner.enclClass() == selectedTypeSym)\n+                return true;\n@@ -1200,0 +1350,1 @@\n+        return false;\n@@ -1219,3 +1370,2 @@\n-            Assert.check(refs.stream().noneMatch(ref -> ref.getDepth() > depth));\n-            Assert.check(allowExpr || !refs.contains(ExprRef.direct(depth)));\n-            Assert.check(allowExpr || !refs.contains(ExprRef.indirect(depth)));\n+            Assert.check(refs.find(ExprRef.class)\n+              .allMatch(ref -> allowExpr && ref.depth <= depth));\n@@ -1235,4 +1385,16 @@\n-    \/** Represents a location that could possibly hold a 'this' reference.\n-     *\n-     *  <p>\n-     *  If not \"direct\", the reference is found through at least one indirection.\n+    \/** Describes how the 'this' we care about is referenced by a {@link Ref} that is being tracked.\n+     *\/\n+    enum Indirection {\n+\n+        \/** The {@link Ref} directly references 'this'. *\/\n+        DIRECT,\n+\n+        \/** The {@link Ref} references 'this' via its outer instance. *\/\n+        OUTER,\n+\n+        \/** The {@link Ref} references 'this' indirectly somehow through\n+            at least one level of indirection. *\/\n+        INDIRECT;\n+    }\n+\n+    \/** Represents an object reference that could refer to the 'this' we care about.\n@@ -1242,2 +1404,2 @@\n-        private final int depth;\n-        private final boolean direct;\n+        final TypeSymbol tsym;\n+        final EnumSet<Indirection> indirections;\n@@ -1245,3 +1407,2 @@\n-        Ref(int depth, boolean direct) {\n-            this.depth = depth;\n-            this.direct = direct;\n+        Ref(Ref ref) {\n+            this(ref.tsym, ref.indirections);\n@@ -1250,2 +1411,5 @@\n-        public int getDepth() {\n-            return depth;\n+        Ref(TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            Assert.check(tsym != null);\n+            Assert.check(indirections != null);\n+            this.tsym = tsym;\n+            this.indirections = EnumSet.copyOf(indirections);\n@@ -1254,3 +1418,1 @@\n-        public boolean isDirect() {\n-            return direct;\n-        }\n+        public abstract Ref withType(TypeSymbol tsym);\n@@ -1261,2 +1423,2 @@\n-                ^ Integer.hashCode(depth)\n-                ^ Boolean.hashCode(direct);\n+                ^ tsym.hashCode()\n+                ^ indirections.hashCode();\n@@ -1272,2 +1434,2 @@\n-            return depth == that.depth\n-              && direct == that.direct;\n+            return tsym == that.tsym\n+              && indirections.equals(that.indirections);\n@@ -1277,1 +1439,1 @@\n-        public String toString() {\n+        public final String toString() {\n@@ -1279,0 +1441,1 @@\n+            properties.add(\"tsym=\" + tsym);\n@@ -1280,0 +1443,3 @@\n+            properties.add(indirections.stream()\n+              .map(Indirection::name)\n+              .collect(Collectors.joining(\",\")));\n@@ -1285,2 +1451,22 @@\n-            properties.add(\"depth=\" + depth);\n-            properties.add(direct ? \"direct\" : \"indirect\");\n+        }\n+\n+        \/\/ Return a modified copy of this Ref's Indirections. The modified set must not be empty.\n+        public EnumSet<Indirection> modifiedIndirections(Consumer<? super EnumSet<Indirection>> modifier) {\n+            EnumSet<Indirection> newIndirections = EnumSet.copyOf(indirections);\n+            modifier.accept(newIndirections);\n+            Assert.check(!newIndirections.isEmpty());\n+            return newIndirections;\n+        }\n+\n+        \/\/ Add one level of indirection through an outer instance\n+        \/\/  - DIRECT references become OUTER\n+        \/\/  - OUTER references disappear (we don't try to track indirect outer 'this' references)\n+        \/\/  - INDIRECT references disappear (we don't try to track outer indirect 'this' references)\n+        public Optional<ThisRef> toOuter(TypeSymbol tsym) {\n+            return Optional.of(this)\n+              .filter(ref -> ref.indirections.contains(Indirection.DIRECT))\n+              .map(ref -> new ThisRef(tsym, ref.modifiedIndirections(indirections -> {\n+                indirections.remove(Indirection.DIRECT);\n+                indirections.remove(Indirection.INDIRECT);\n+                indirections.add(Indirection.OUTER);\n+              })));\n@@ -1290,1 +1476,1 @@\n-    \/** A reference from the current 'this' instance.\n+    \/** A reference originating from the current 'this' instance.\n@@ -1294,2 +1480,2 @@\n-        ThisRef(boolean direct) {\n-            super(0, direct);\n+        ThisRef(Ref ref) {\n+            super(ref);\n@@ -1298,2 +1484,2 @@\n-        public static ThisRef direct() {\n-            return new ThisRef(true);\n+        ThisRef(TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            super(tsym, indirections);\n@@ -1302,2 +1488,3 @@\n-        public static ThisRef indirect() {\n-            return new ThisRef(false);\n+        @Override\n+        public ThisRef withType(TypeSymbol tsym) {\n+            return new ThisRef(tsym, indirections);\n@@ -1305,5 +1492,0 @@\n-    }\n-\n-    \/** A reference from the current outer 'this' instance.\n-     *\/\n-    private static class OuterRef extends Ref {\n@@ -1311,2 +1493,17 @@\n-        OuterRef(boolean direct) {\n-            super(0, direct);\n+        \/\/ Remove one level of indirection through the outer instance\n+        \/\/  - DIRECT references disappear\n+        \/\/  - OUTER references become DIRECT\n+        \/\/  - INDIRECT references disappear\n+        public Optional<ExprRef> fromOuter(int depth) {\n+            ClassSymbol outerType = Optional.of(tsym.owner)\n+              .map(Symbol::enclClass)\n+              .orElse(null);\n+            if (outerType == null)\n+                return Optional.empty();        \/\/ weird\n+            return Optional.of(this)\n+              .filter(ref -> ref.indirections.contains(Indirection.OUTER))\n+              .map(ref -> new ExprRef(depth, outerType, ref.modifiedIndirections(indirections -> {\n+                indirections.remove(Indirection.OUTER);\n+                indirections.remove(Indirection.INDIRECT);\n+                indirections.add(Indirection.DIRECT);\n+              })));\n@@ -1316,1 +1513,1 @@\n-    \/** A reference from the expression that was just evaluated.\n+    \/** A reference originating from the expression that was just evaluated.\n@@ -1321,2 +1518,5 @@\n-        ExprRef(int depth, boolean direct) {\n-            super(depth, direct);\n+        final int depth;\n+\n+        ExprRef(int depth, Ref ref) {\n+            super(ref);\n+            this.depth = depth;\n@@ -1325,2 +1525,52 @@\n-        public static ExprRef direct(int depth) {\n-            return new ExprRef(depth, true);\n+        ExprRef(int depth, TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            super(tsym, indirections);\n+            this.depth = depth;\n+        }\n+\n+        @Override\n+        public ExprRef withType(TypeSymbol tsym) {\n+            return new ExprRef(depth, tsym, indirections);\n+        }\n+\n+        \/\/ Add one level of indirection\n+        \/\/  - DIRECT references convert to INDIRECT\n+        \/\/  - OUTER references disappear (we don't try to track indirect outer 'this' references)\n+        \/\/  - INDIRECT references stay INDIRECT\n+        public Optional<ExprRef> toIndirect(TypeSymbol indirectType) {\n+            return Optional.of(this)\n+              .filter(ref -> ref.indirections.contains(Indirection.DIRECT) ||\n+                             ref.indirections.contains(Indirection.INDIRECT))\n+              .map(ref -> new ExprRef(depth, indirectType, ref.modifiedIndirections(indirections -> {\n+                indirections.remove(Indirection.DIRECT);\n+                indirections.remove(Indirection.OUTER);\n+                indirections.add(Indirection.INDIRECT);\n+              })));\n+        }\n+\n+        \/\/ Remove one level of indirection\n+        \/\/  - DIRECT references disappear\n+        \/\/  - OUTER references disappear\n+        \/\/  - INDIRECT references become both DIRECT and INDIRECT\n+        public Optional<ExprRef> toDirect(TypeSymbol directType) {\n+            return Optional.of(this)\n+              .filter(ref -> ref.indirections.contains(Indirection.INDIRECT))\n+              .map(ref -> new ExprRef(depth, directType, ref.modifiedIndirections(indirections -> {\n+                indirections.remove(Indirection.OUTER);\n+                indirections.add(Indirection.DIRECT);\n+              })));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return super.hashCode()\n+                ^ Integer.hashCode(depth);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this)\n+                return true;\n+            if (!super.equals(obj))\n+                return false;\n+            ExprRef that = (ExprRef)obj;\n+            return depth == that.depth;\n@@ -1329,2 +1579,4 @@\n-        public static ExprRef indirect(int depth) {\n-            return new ExprRef(depth, false);\n+        @Override\n+        protected void addProperties(ArrayList<String> properties) {\n+            super.addProperties(properties);\n+            properties.add(\"depth=\" + depth);\n@@ -1338,2 +1590,11 @@\n-        ReturnRef(boolean direct) {\n-            super(0, direct);\n+        ReturnRef(Ref ref) {\n+            super(ref);\n+        }\n+\n+        ReturnRef(TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            super(tsym, indirections);\n+        }\n+\n+        @Override\n+        public ReturnRef withType(TypeSymbol tsym) {\n+            return new ReturnRef(tsym, indirections);\n@@ -1347,2 +1608,11 @@\n-        YieldRef(boolean direct) {\n-            super(0, direct);\n+        YieldRef(Ref ref) {\n+            super(ref);\n+        }\n+\n+        YieldRef(TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            super(tsym, indirections);\n+        }\n+\n+        @Override\n+        public YieldRef withType(TypeSymbol tsym) {\n+            return new YieldRef(tsym, indirections);\n@@ -1356,1 +1626,1 @@\n-        private final VarSymbol sym;\n+        final VarSymbol sym;\n@@ -1358,2 +1628,2 @@\n-        VarRef(VarSymbol sym, boolean direct) {\n-            super(0, direct);\n+        VarRef(VarSymbol sym, Ref ref) {\n+            super(ref);\n@@ -1363,6 +1633,3 @@\n-        public VarSymbol getSymbol() {\n-            return sym;\n-        }\n-\n-        public static VarRef direct(VarSymbol sym) {\n-            return new VarRef(sym, true);\n+        VarRef(VarSymbol sym, TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            super(tsym, indirections);\n+            this.sym = sym;\n@@ -1371,2 +1638,3 @@\n-        public static VarRef indirect(VarSymbol sym) {\n-            return new VarRef(sym, false);\n+        @Override\n+        public VarRef withType(TypeSymbol tsym) {\n+            return new VarRef(sym, tsym, indirections);\n@@ -1401,0 +1669,1 @@\n+     *  All methods that return Stream return a copy to avoid ConcurrentModificationException.\n@@ -1405,0 +1674,4 @@\n+        private RefSet() {\n+            super(8);\n+        }\n+\n@@ -1409,3 +1682,1 @@\n-        \/**\n-         * Discard any {@link ExprRef}'s at the specified depth.\n-         * Do this when discarding whatever is on top of the stack.\n+        \/** Find all {@link Ref}'s of the given type.\n@@ -1413,2 +1684,2 @@\n-        public boolean discardExprs(int depth) {\n-            return remove(ExprRef.direct(depth)) | remove(ExprRef.indirect(depth));\n+        public <T extends Ref> Stream<T> find(Class<T> refType) {\n+            return find(refType, ref -> true);\n@@ -1417,2 +1688,1 @@\n-        \/**\n-         * Extract any {@link ExprRef}'s at the specified depth.\n+        \/** Find all {@link Ref}'s of the given type and matching the given predicate.\n@@ -1420,4 +1690,7 @@\n-        public RefSet<ExprRef> removeExprs(int depth) {\n-            return Stream.of(ExprRef.direct(depth), ExprRef.indirect(depth))\n-              .filter(this::remove)\n-              .collect(Collectors.toCollection(RefSet::new));\n+        public <T extends Ref> Stream<T> find(Class<T> refType, Predicate<? super T> filter) {\n+            return stream()\n+              .filter(refType::isInstance)\n+              .map(refType::cast)\n+              .filter(filter)\n+              .collect(Collectors.toList())         \/\/ avoid ConcurrentModificationException\n+              .stream();\n@@ -1426,2 +1699,1 @@\n-        \/**\n-         * Extract any {@link ExprRef}'s at the specified depth and do something with them.\n+        \/** Find the {@link ExprRef} at the given depth, if any.\n@@ -1429,5 +1701,2 @@\n-        public void removeExprs(int depth, Consumer<? super Boolean> handler) {\n-            Stream.of(ExprRef.direct(depth), ExprRef.indirect(depth))\n-              .filter(this::remove)\n-              .map(ExprRef::isDirect)\n-              .forEach(handler);\n+        public Stream<ExprRef> findExprs(int depth) {\n+            return find(ExprRef.class, ref -> ref.depth == depth);\n@@ -1436,2 +1705,1 @@\n-        \/**\n-         * Replace any references of the given type.\n+        \/** Extract (i.e., find and remove) all {@link Ref}'s of the given type.\n@@ -1439,9 +1707,2 @@\n-        public void replace(Class<? extends Ref> type, Function<Boolean, ? extends T> mapper) {\n-            final List<Ref> oldRefs = this.stream()\n-              .filter(type::isInstance)\n-              .collect(List.collector());             \/\/ avoid ConcurrentModificationException\n-            this.removeAll(oldRefs);\n-            oldRefs.stream()\n-              .map(Ref::isDirect)\n-              .map(mapper)\n-              .forEach(this::add);\n+        public <T extends Ref> Stream<T> remove(Class<T> refType) {\n+            return remove(refType, ref -> true);\n@@ -1450,2 +1711,2 @@\n-        \/**\n-         * Replace any {@link ExprRef}'s at the specified depth.\n+        \/** Extract (i.e., find and remove) all {@link Ref}'s of the given type\n+         *  and matching the given predicate.\n@@ -1453,2 +1714,8 @@\n-        public void replaceExprs(int depth, Function<Boolean, ? extends T> mapper) {\n-            removeExprs(depth, direct -> add(mapper.apply(direct)));\n+        public <T extends Ref> Stream<T> remove(Class<T> refType, Predicate<? super T> filter) {\n+            ArrayList<T> list = stream()\n+              .filter(refType::isInstance)\n+              .map(refType::cast)\n+              .filter(filter)\n+              .collect(Collectors.toCollection(ArrayList::new)); \/\/ avoid ConcurrentModificationException\n+            removeAll(list);\n+            return list.stream();\n@@ -1457,2 +1724,1 @@\n-        \/**\n-         * Find references of the given type, map them, and add them to {@code dest}.\n+        \/** Extract (i.e., find and remove) all {@link ExprRef}'s at the given depth.\n@@ -1460,5 +1726,14 @@\n-        public <S extends Ref> void mapInto(RefSet<S> dest, Class<? extends Ref> type,\n-                Function<Boolean, ? extends S> mapper) {\n-            final List<S> newRefs = this.stream()\n-              .filter(type::isInstance)\n-              .map(Ref::isDirect)\n+        public Stream<ExprRef> removeExprs(int depth) {\n+            return remove(ExprRef.class, ref -> ref.depth == depth);\n+        }\n+\n+        \/** Discard all {@link ExprRef}'s at the given depth.\n+         *\/\n+        public boolean discardExprs(int depth) {\n+            return removeIf(ref -> ref instanceof ExprRef exprRef && exprRef.depth == depth);\n+        }\n+\n+        \/** Replace all {@link ExprRef}'s at the given depth after mapping them somehow.\n+         *\/\n+        public void replaceExprs(int depth, Function<? super ExprRef, ? extends T> mapper) {\n+            removeExprs(depth)\n@@ -1466,2 +1741,1 @@\n-              .collect(List.collector());             \/\/ avoid ConcurrentModificationException\n-            dest.addAll(newRefs);\n+              .forEach(this::add);\n@@ -1475,0 +1749,5 @@\n+\n+        \/\/ Return a collector that builds a RefSet\n+        public static <T extends Ref> Collector<T, ?, RefSet<T>> collector() {\n+            return Collectors.toCollection(RefSet::new);\n+        }\n@@ -1485,0 +1764,9 @@\n+\n+        @Override\n+        public String toString() {\n+            return \"MethodInfo\"\n+              + \"[method=\" + declaringClass.sym.flatname + \".\" + declaration.sym\n+              + \",analyzable=\" + analyzable\n+              + \",invokable=\" + invokable\n+              + \"]\";\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":573,"deletions":285,"binary":false,"changes":858,"status":"modified"},{"patch":"@@ -1,348 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.comp;\n-\n-import com.sun.tools.javac.code.Flags;\n-import com.sun.tools.javac.code.Symbol;\n-import com.sun.tools.javac.code.Symbol.ClassSymbol;\n-import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;\n-import com.sun.tools.javac.code.Symbol.MethodSymbol;\n-import com.sun.tools.javac.code.Symbol.VarSymbol;\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.code.Type;\n-import com.sun.tools.javac.code.Type.*;\n-import com.sun.tools.javac.code.Types;\n-import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.*;\n-import com.sun.tools.javac.tree.TreeInfo;\n-import com.sun.tools.javac.tree.TreeMaker;\n-import com.sun.tools.javac.tree.TreeTranslator;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.List;\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.javac.util.Names;\n-\n-import java.util.Iterator;\n-\n-\/** This pass translates constructed literals (string templates, ...) to conventional Java.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public final class TransLiterals extends TreeTranslator {\n-    \/**\n-     * The context key for the TransTypes phase.\n-     *\/\n-    protected static final Context.Key<TransLiterals> transLiteralsKey = new Context.Key<>();\n-\n-    \/**\n-     * Get the instance for this context.\n-     *\/\n-    public static TransLiterals instance(Context context) {\n-        TransLiterals instance = context.get(transLiteralsKey);\n-        if (instance == null)\n-            instance = new TransLiterals(context);\n-        return instance;\n-    }\n-\n-    private final Symtab syms;\n-    private final Resolve rs;\n-    private final Types types;\n-    private final Operators operators;\n-    private final Names names;\n-    private TreeMaker make = null;\n-    private Env<AttrContext> env = null;\n-    private ClassSymbol currentClass = null;\n-    private MethodSymbol currentMethodSym = null;\n-\n-    protected TransLiterals(Context context) {\n-        context.put(transLiteralsKey, this);\n-        syms = Symtab.instance(context);\n-        rs = Resolve.instance(context);\n-        make = TreeMaker.instance(context);\n-        types = Types.instance(context);\n-        operators = Operators.instance(context);\n-        names = Names.instance(context);\n-    }\n-\n-    JCExpression makeLit(Type type, Object value) {\n-        return make.Literal(type.getTag(), value).setType(type.constType(value));\n-    }\n-\n-    JCExpression makeString(String string) {\n-        return makeLit(syms.stringType, string);\n-    }\n-\n-    List<JCExpression> makeStringList(List<String> strings) {\n-        List<JCExpression> exprs = List.nil();\n-        for (String string : strings) {\n-            exprs = exprs.append(makeString(string));\n-        }\n-        return exprs;\n-    }\n-\n-    JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {\n-        JCBinary tree = make.Binary(optag, lhs, rhs);\n-        tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);\n-        tree.type = tree.operator.type.getReturnType();\n-        return tree;\n-    }\n-\n-    MethodSymbol lookupMethod(DiagnosticPosition pos, Name name, Type qual, List<Type> args) {\n-        return rs.resolveInternalMethod(pos, env, qual, name, args, List.nil());\n-    }\n-\n-    @Override\n-    public void visitClassDef(JCClassDecl tree) {\n-        ClassSymbol prevCurrentClass = currentClass;\n-        try {\n-            currentClass = tree.sym;\n-            super.visitClassDef(tree);\n-        } finally {\n-            currentClass = prevCurrentClass;\n-        }\n-    }\n-\n-    @Override\n-    public void visitMethodDef(JCMethodDecl tree) {\n-        MethodSymbol prevMethodSym = currentMethodSym;\n-        try {\n-            currentMethodSym = tree.sym;\n-            super.visitMethodDef(tree);\n-        } finally {\n-            currentMethodSym = prevMethodSym;\n-        }\n-    }\n-\n-    final class TransStringTemplate {\n-        final JCStringTemplate tree;\n-        final JCExpression processor;\n-        final List<String> fragments;\n-        final List<JCExpression> expressions;\n-        final List<Type> expressionTypes;\n-        final boolean useValuesList;\n-\n-        TransStringTemplate(JCStringTemplate tree) {\n-            this.tree = tree;\n-            this.processor = tree.processor;\n-            this.fragments = tree.fragments;\n-            this.expressions = translate(tree.expressions);\n-            this.expressionTypes = expressions.stream()\n-                    .map(arg -> arg.type == syms.botType ? syms.objectType : arg.type)\n-                    .collect(List.collector());\n-            int slots = expressionTypes.stream()\n-                    .mapToInt(t -> types.isSameType(t, syms.longType) ||\n-                            types.isSameType(t, syms.doubleType) ? 2 : 1).sum();\n-            this.useValuesList = 200 < slots; \/\/ StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS\n-         }\n-\n-        JCExpression concatExpression(List<String> fragments, List<JCExpression> expressions) {\n-            JCExpression expr = null;\n-            Iterator<JCExpression> iterator = expressions.iterator();\n-            for (String fragment : fragments) {\n-                expr = expr == null ? makeString(fragment)\n-                        : makeBinary(Tag.PLUS, expr, makeString(fragment));\n-                if (iterator.hasNext()) {\n-                    JCExpression expression = iterator.next();\n-                    Type expressionType = expression.type;\n-                    expr = makeBinary(Tag.PLUS, expr, expression.setType(expressionType));\n-                }\n-            }\n-            return expr;\n-        }\n-\n-        JCExpression bsmCall(Name name, Name bootstrapName, Type type,\n-                             List<JCExpression> args,\n-                             List<Type> argTypes,\n-                             List<LoadableConstant> staticArgValues,\n-                             List<Type> staticArgsTypes) {\n-            Symbol bsm = rs.resolveQualifiedMethod(tree.pos(), env,\n-                    syms.templateRuntimeType, bootstrapName, staticArgsTypes, List.nil());\n-            MethodType indyType = new MethodType(argTypes, type, List.nil(), syms.methodClass);\n-            DynamicMethodSymbol dynSym = new DynamicMethodSymbol(\n-                    name,\n-                    syms.noSymbol,\n-                    ((MethodSymbol)bsm).asHandle(),\n-                    indyType,\n-                    staticArgValues.toArray(new LoadableConstant[0])\n-            );\n-            JCFieldAccess qualifier = make.Select(make.Type(syms.processorType), dynSym.name);\n-            qualifier.sym = dynSym;\n-            qualifier.type = type;\n-            JCMethodInvocation apply = make.Apply(List.nil(), qualifier, args);\n-            apply.type = type;\n-            return apply;\n-        }\n-\n-        JCExpression processCall(JCExpression stringTemplate) {\n-            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.process,\n-                    syms.processorType, List.of(syms.stringTemplateType));\n-            JCExpression applySelect = make.Select(processor, appyMeth);\n-            JCExpression process = make.Apply(null, applySelect, List.of(stringTemplate))\n-                    .setType(syms.objectType);\n-            JCTypeCast cast = make.TypeCast(tree.type, process);\n-            return cast;\n-        }\n-\n-        JCExpression newStringTemplate() {\n-            List<LoadableConstant> staticArgValues = List.nil();\n-            List<Type> staticArgsTypes =\n-                    List.of(syms.methodHandleLookupType, syms.stringType,\n-                            syms.methodTypeType);\n-            if (useValuesList) {\n-                JCNewArray fragmentArray = make.NewArray(make.Type(syms.stringType),\n-                        List.nil(), makeStringList(fragments));\n-                fragmentArray.type = new ArrayType(syms.stringType, syms.arrayClass);\n-                JCNewArray valuesArray = make.NewArray(make.Type(syms.objectType),\n-                        List.nil(), expressions);\n-                valuesArray.type = new ArrayType(syms.objectType, syms.arrayClass);\n-                return bsmCall(names.process, names.newLargeStringTemplate, syms.stringTemplateType,\n-                        List.of(fragmentArray, valuesArray),\n-                        List.of(fragmentArray.type, valuesArray.type),\n-                        staticArgValues, staticArgsTypes);\n-            } else {\n-                for (String fragment : fragments) {\n-                    staticArgValues = staticArgValues.append(LoadableConstant.String(fragment));\n-                    staticArgsTypes = staticArgsTypes.append(syms.stringType);\n-                }\n-                return bsmCall(names.process, names.newStringTemplate, syms.stringTemplateType,\n-                        expressions, expressionTypes, staticArgValues, staticArgsTypes);\n-            }\n-        }\n-\n-        JCExpression bsmProcessCall() {\n-            List<JCExpression> args = expressions.prepend(processor);\n-            List<Type> argTypes = expressionTypes.prepend(processor.type);\n-            VarSymbol processorSym = (VarSymbol)TreeInfo.symbol(processor);\n-            List<LoadableConstant> staticArgValues = List.of(processorSym.asMethodHandle(true));\n-            List<Type> staticArgsTypes =\n-                    List.of(syms.methodHandleLookupType, syms.stringType,\n-                            syms.methodTypeType, syms.methodHandleType);\n-            for (String fragment : fragments) {\n-                staticArgValues = staticArgValues.append(LoadableConstant.String(fragment));\n-                staticArgsTypes = staticArgsTypes.append(syms.stringType);\n-            }\n-            return bsmCall(names.process, names.processStringTemplate, tree.type,\n-                    args, argTypes, staticArgValues, staticArgsTypes);\n-        }\n-\n-        boolean isNamedProcessor(Name name) {\n-            Symbol sym = switch (processor) {\n-                case JCIdent ident -> ident.sym;\n-                case JCFieldAccess access -> access.sym;\n-                default -> null;\n-            };\n-            if (sym instanceof VarSymbol varSym) {\n-                if (varSym.flags() == (Flags.PUBLIC | Flags.FINAL | Flags.STATIC) &&\n-                        varSym.name == name &&\n-                        types.isSameType(varSym.owner.type, syms.stringTemplateType)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        boolean isLinkageProcessor() {\n-            return !useValuesList &&\n-                   types.isSubtype(processor.type, syms.linkageType) &&\n-                   processor.type.isFinal() &&\n-                   TreeInfo.symbol(processor) instanceof VarSymbol varSymbol &&\n-                   varSymbol.isStatic() &&\n-                   varSymbol.isFinal();\n-        }\n-\n-        JCExpression visit() {\n-            JCExpression result;\n-            make.at(tree.pos);\n-\n-            if (isNamedProcessor(names.RAW)) {\n-                result = newStringTemplate();\n-            } else if (isNamedProcessor(names.STR)) {\n-                result = concatExpression(fragments, expressions);\n-            } else if (isLinkageProcessor()) {\n-                result = bsmProcessCall();\n-            } else {\n-                result = processCall(newStringTemplate());\n-            }\n-\n-            return result;\n-        }\n-    }\n-\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        int prevPos = make.pos;\n-        try {\n-            tree.processor = translate(tree.processor);\n-            tree.expressions = translate(tree.expressions);\n-\n-            TransStringTemplate transStringTemplate = new TransStringTemplate(tree);\n-\n-            result = transStringTemplate.visit();\n-        } catch (Throwable ex) {\n-            ex.printStackTrace();\n-            throw ex;\n-        } finally {\n-            make.at(prevPos);\n-        }\n-    }\n-\n-    public void visitVarDef(JCVariableDecl tree) {\n-        MethodSymbol prevMethodSym = currentMethodSym;\n-        try {\n-            tree.mods = translate(tree.mods);\n-            tree.vartype = translate(tree.vartype);\n-            if (currentMethodSym == null) {\n-                \/\/ A class or instance field initializer.\n-                currentMethodSym =\n-                        new MethodSymbol((tree.mods.flags& Flags.STATIC) | Flags.BLOCK,\n-                                names.empty, null,\n-                                currentClass);\n-            }\n-            if (tree.init != null) tree.init = translate(tree.init);\n-            result = tree;\n-        } finally {\n-            currentMethodSym = prevMethodSym;\n-        }\n-    }\n-\n-    public JCTree translateTopLevelClass(Env<AttrContext> env, JCTree cdef, TreeMaker make) {\n-        try {\n-            this.make = make;\n-            this.env = env;\n-            translate(cdef);\n-        } finally {\n-            this.make = null;\n-            this.env = null;\n-        }\n-\n-        return cdef;\n-    }\n-\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransLiterals.java","additions":0,"deletions":348,"binary":false,"changes":348,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -840,8 +840,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        tree.processor = translate(tree.processor, erasure(tree.processor.type));\n-        tree.expressions = tree.expressions.stream()\n-                .map(e -> translate(e, erasure(e.type))).collect(List.collector());\n-        tree.type = erasure(tree.type);\n-        result = tree;\n-    }\n-\n@@ -908,1 +900,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -916,1 +908,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -343,23 +343,0 @@\n-        private void staticImports(JCCompilationUnit tree, Env<AttrContext> env, ImportFilter staticImportFilter) {\n-             if (preview.isEnabled() && preview.isPreview(Feature.STRING_TEMPLATES)) {\n-                Lint prevLint = chk.setLint(lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));\n-                boolean prevPreviewCheck = chk.disablePreviewCheck;\n-\n-                try {\n-                    chk.disablePreviewCheck = true;\n-                    String autoImports = \"\"\"\n-                            import static java.lang.StringTemplate.STR;\n-                            \"\"\";\n-                    Parser parser = parserFactory.newParser(autoImports, false, false, false, false);\n-                    JCCompilationUnit importTree = parser.parseCompilationUnit();\n-\n-                    for (JCImport imp : importTree.getImports()) {\n-                        doImport(imp);\n-                    }\n-                } finally {\n-                    chk.setLint(prevLint);\n-                    chk.disablePreviewCheck = prevPreviewCheck;\n-                }\n-            }\n-        }\n-\n@@ -389,1 +366,0 @@\n-                staticImports(tree, env, staticImportFilter);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n@@ -341,1 +341,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n@@ -381,1 +381,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n@@ -440,1 +440,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n@@ -794,1 +794,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n@@ -1465,1 +1465,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n@@ -2582,1 +2582,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n@@ -3125,1 +3125,1 @@\n-\/************************************************************************\n+\/* **********************************************************************\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-\/******************************************************************\n+\/* ****************************************************************\n@@ -240,1 +240,1 @@\n-\/******************************************************************\n+\/* ****************************************************************\n@@ -262,1 +262,1 @@\n-\/******************************************************************\n+\/* ****************************************************************\n@@ -280,1 +280,1 @@\n-\/******************************************************************\n+\/* ****************************************************************\n@@ -483,1 +483,1 @@\n-\/**********************************************************************\n+\/* ********************************************************************\n@@ -744,1 +744,1 @@\n-\/**********************************************************************\n+\/* ********************************************************************\n@@ -826,1 +826,1 @@\n-\/**********************************************************************\n+\/* ********************************************************************\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1222,1 +1222,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -1397,1 +1397,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n@@ -2241,1 +2241,1 @@\n-\/**************************************************************************\n+\/* ************************************************************************\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1077,0 +1077,5 @@\n+        \/* this method is heavily invoked, as expected, for deeply nested blocks, if blocks doesn't happen to have\n+         * patterns there will be an unnecessary tax on memory consumption every time this method is executed, for this\n+         * reason we have created helper methods and here at a higher level we just discriminate depending on the\n+         * presence, or not, of patterns in a given block\n+         *\/\n@@ -1078,16 +1083,1 @@\n-            Set<JCMethodInvocation> prevInvocationsWithPatternMatchingCatch = invocationsWithPatternMatchingCatch;\n-            ListBuffer<int[]> prevRanges = patternMatchingInvocationRanges;\n-            State startState = code.state.dup();\n-            try {\n-                invocationsWithPatternMatchingCatch = tree.patternMatchingCatch.calls2Handle();\n-                patternMatchingInvocationRanges = new ListBuffer<>();\n-                doVisitBlock(tree);\n-            } finally {\n-                Chain skipCatch = code.branch(goto_);\n-                JCCatch handler = tree.patternMatchingCatch.handler();\n-                code.entryPoint(startState, handler.param.sym.type);\n-                genPatternMatchingCatch(handler, env, patternMatchingInvocationRanges.toList());\n-                code.resolve(skipCatch);\n-                invocationsWithPatternMatchingCatch = prevInvocationsWithPatternMatchingCatch;\n-                patternMatchingInvocationRanges = prevRanges;\n-            }\n+            visitBlockWithPatterns(tree);\n@@ -1095,1 +1085,20 @@\n-            doVisitBlock(tree);\n+            internalVisitBlock(tree);\n+        }\n+    }\n+\n+    private void visitBlockWithPatterns(JCBlock tree) {\n+        Set<JCMethodInvocation> prevInvocationsWithPatternMatchingCatch = invocationsWithPatternMatchingCatch;\n+        ListBuffer<int[]> prevRanges = patternMatchingInvocationRanges;\n+        State startState = code.state.dup();\n+        try {\n+            invocationsWithPatternMatchingCatch = tree.patternMatchingCatch.calls2Handle();\n+            patternMatchingInvocationRanges = new ListBuffer<>();\n+            internalVisitBlock(tree);\n+        } finally {\n+            Chain skipCatch = code.branch(goto_);\n+            JCCatch handler = tree.patternMatchingCatch.handler();\n+            code.entryPoint(startState, handler.param.sym.type);\n+            genPatternMatchingCatch(handler, env, patternMatchingInvocationRanges.toList());\n+            code.resolve(skipCatch);\n+            invocationsWithPatternMatchingCatch = prevInvocationsWithPatternMatchingCatch;\n+            patternMatchingInvocationRanges = prevRanges;\n@@ -1099,1 +1108,1 @@\n-    private void doVisitBlock(JCBlock tree) {\n+    private void internalVisitBlock(JCBlock tree) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1615,6 +1615,0 @@\n-            if (shouldStop(CompileState.TRANSLITERALS))\n-                return;\n-\n-            env.tree = TransLiterals.instance(context).translateTopLevelClass(env, env.tree, localMake);\n-            compileStates.put(env, CompileState.TRANSLITERALS);\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,10 +102,0 @@\n-    \/**\n-     * Tokens pending to be read from string template embedded expressions.\n-     *\/\n-    protected List<Token> pendingTokens;\n-\n-    \/**\n-     * String template fragment ranges; end-endPos pairs.\n-     *\/\n-    protected List<Integer> fragmentRanges;\n-\n@@ -142,10 +132,0 @@\n-    \/**\n-     * true if contains templated string escape sequences, set by nextToken().\n-     *\/\n-    protected boolean isStringTemplate;\n-\n-    \/**\n-     * true if errors are pending from embedded expressions.\n-     *\/\n-    protected boolean hasStringTemplateErrors;\n-\n@@ -186,2 +166,0 @@\n-        this.pendingTokens = List.nil();\n-        this.fragmentRanges = List.nil();\n@@ -342,80 +320,0 @@\n-    \/**\n-     * Scan the content of a string template expression.\n-     *\n-     * @param pos     start of literal\n-     * @param endPos  start of embedded expression\n-     *\/\n-    private void scanEmbeddedExpression(int pos, int endPos) {\n-        \/\/ If first embedded expression.\n-        if (!isStringTemplate) {\n-            checkSourceLevel(pos, Feature.STRING_TEMPLATES);\n-            fragmentRanges = fragmentRanges.append(pos);\n-            isStringTemplate = true;\n-        }\n-        \/\/ Track end of previous fragment.\n-        fragmentRanges = fragmentRanges.append(endPos);\n-        \/\/ Keep backslash and add rest of placeholder.\n-        sb.append(\"{}\");\n-\n-        \/\/ Separate tokenizer for the embedded expression.\n-        JavaTokenizer tokenizer = new JavaTokenizer(fac, buffer(), length());\n-        tokenizer.reset(position());\n-\n-        \/\/ Track brace depth.\n-        int braceCount = 0;\n-\n-        \/\/ Accumulate tokens.\n-        List<Token> tokens = List.nil();\n-\n-        \/\/ Stash first left brace.\n-        Token token = tokenizer.readToken();\n-        tokens = tokens.append(token);\n-\n-        while (isAvailable()) {\n-            \/\/ Read and stash next token.\n-            token = tokenizer.readToken();\n-            tokens = tokens.append(token);\n-\n-            \/\/ Intercept errors\n-            if (token.kind == TokenKind.ERROR) {\n-                \/\/ Track start of next fragment.\n-                if (isTextBlock) {\n-                    reset(length());\n-                } else {\n-                    skipToEOLN();\n-                }\n-                hasStringTemplateErrors = true;\n-                return;\n-            }\n-\n-            if (token.kind == TokenKind.RBRACE) {\n-                \/\/ Potential closing brace.\n-                if (braceCount == 0) {\n-                    break;\n-                }\n-\n-                braceCount--;\n-            } else if (token.kind == TokenKind.LBRACE) {\n-                \/\/ Nesting deeper.\n-                braceCount++;\n-            } else if (token.kind == TokenKind.STRINGFRAGMENT) {\n-                tokens = tokens.appendList(tokenizer.pendingTokens);\n-                tokenizer.pendingTokens = List.nil();\n-            } else if (token.kind == TokenKind.EOF) {\n-                break;\n-            }\n-        }\n-\n-        \/\/ If no closing brace will be picked up as an unterminated string.\n-\n-        \/\/ Set main tokenizer to continue at next position.\n-        int position = tokenizer.position();\n-        reset(position);\n-\n-        \/\/ Track start of next fragment.\n-        fragmentRanges = fragmentRanges.append(position);\n-\n-        \/\/ Pend the expression tokens after the STRINGFRAGMENT.\n-        pendingTokens = pendingTokens.appendList(tokens);\n-    }\n-\n@@ -483,11 +381,0 @@\n-                case '{':\n-                    if (isString) {\n-                        scanEmbeddedExpression(pos, backslash);\n-                        if (hasStringTemplateErrors) {\n-                            return;\n-                        }\n-                    } else {\n-                        lexError(position(), Errors.IllegalEscChar);\n-                    }\n-                    break;\n-\n@@ -533,7 +420,1 @@\n-                if (hasStringTemplateErrors) {\n-                    break;\n-                } else if (accept(\"\\\"\\\"\\\"\")) {\n-                    if (isStringTemplate && tk == TokenKind.STRINGLITERAL) {\n-                        tk = TokenKind.STRINGFRAGMENT;\n-                    }\n-\n+                if (accept(\"\\\"\\\"\\\"\")) {\n@@ -563,6 +444,1 @@\n-                if (hasStringTemplateErrors) {\n-                    break;\n-                } else if (accept('\\\"')) {\n-                    if (isStringTemplate && tk == TokenKind.STRINGLITERAL) {\n-                        tk = TokenKind.STRINGFRAGMENT;\n-                    }\n+                if (accept('\\\"')) {\n@@ -583,10 +459,3 @@\n-        \/\/ String ended without close delimiter sequence or has embedded expression errors.\n-        if (isStringTemplate) {\n-            lexError(pos, isTextBlock ? Errors.TextBlockTemplateIsNotWellFormed\n-                                      : Errors.StringTemplateIsNotWellFormed);\n-            fragmentRanges = List.nil();\n-            pendingTokens = List.nil();\n-        } else {\n-            lexError(pos, isTextBlock ? Errors.UnclosedTextBlock\n-                                      : Errors.UnclosedStrLit);\n-        }\n+        \/\/ String ended without close delimiter sequence.\n+        lexError(pos, isTextBlock ? Errors.UnclosedTextBlock\n+                                  : Errors.UnclosedStrLit);\n@@ -594,1 +463,1 @@\n-        if (!hasStringTemplateErrors && firstEOLN  != NOT_FOUND) {\n+        if (firstEOLN  != NOT_FOUND) {\n@@ -909,6 +778,0 @@\n-        if (pendingTokens.nonEmpty()) {\n-            Token token = pendingTokens.head;\n-            pendingTokens = pendingTokens.tail;\n-            return token;\n-        }\n-\n@@ -920,3 +783,0 @@\n-        isStringTemplate = false;\n-        hasStringTemplateErrors = false;\n-        fragmentRanges = List.nil();\n@@ -1137,1 +997,0 @@\n-\n@@ -1184,5 +1043,0 @@\n-            \/\/ Track end of final fragment.\n-            if (isStringTemplate) {\n-                fragmentRanges = fragmentRanges.append(endPos);\n-            }\n-\n@@ -1220,5 +1074,0 @@\n-                if (isStringTemplate) {\n-                    \/\/ Break string into fragments and then return the first of the framents.\n-                    return getFragments(string, comments);\n-                }\n-\n@@ -1254,60 +1103,0 @@\n-    \/**\n-     * Convert the string into a list of pending tokens to precede embedded\n-     * expressions.\n-     *\n-     * @param string    string to fragment\n-     * @param comments  comments for first token\n-     *\n-     * @return first pending token.\n-     *\/\n-    private Token getFragments(String string, List<Comment> comments) {\n-        List<Token> tokens = List.nil();\n-        Iterator<Integer> rangeIter = fragmentRanges.iterator();\n-        for (String fragment : fragment(string)) {\n-            fragment = fragment.translateEscapes();\n-            int fragmentPos = rangeIter.next();\n-            int fragmentEndPos = rangeIter.next();\n-            Token token = new StringToken(TokenKind.STRINGFRAGMENT,\n-                    fragmentPos, fragmentEndPos, fragment, comments);\n-            comments = null;\n-            tokens = tokens.append(token);\n-        }\n-        pendingTokens = tokens.appendList(pendingTokens);\n-        Token first = pendingTokens.head;\n-        pendingTokens = pendingTokens.tail;\n-        return first;\n-    }\n-\n-    \/**\n-     * Break string template up into fragments. \"\\{}\" indicates where\n-     * embedded expressions occur.\n-     *\n-     * @param string string template\n-     *\n-     * @return list of fragment strings\n-     *\/\n-    List<String> fragment(String string) {\n-        List<String> fragments = List.nil();\n-        StringBuilder sb = new StringBuilder();\n-        int length = string.length();\n-        for (int i = 0; i < length; i++) {\n-            char ch = string.charAt(i);\n-            if (ch != '\\\\') {\n-                sb.append(ch);\n-            } else if (i + 2 < length && string.charAt(i + 1) == '{'\n-                    && string.charAt(i + 2) == '}') {\n-                fragments = fragments.append(sb.toString());\n-                sb.setLength(0);\n-                i += 2;\n-            } else if (i + 1 < length){\n-                sb.append('\\\\');\n-                sb.append(string.charAt(i + 1));\n-                i++;\n-            } else {\n-                \/\/ Error already reported.\n-            }\n-        }\n-        fragments = fragments.append(sb.toString());\n-        return fragments;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":6,"deletions":217,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -695,53 +695,0 @@\n-    \/**\n-     * StringTemplate =\n-     *    [STRINGFRAGMENT] [EmbeddedExpression]\n-     *  | STRINGLITERAL\n-     *\n-     * EmbeddedExpression =\n-     *  LBRACE term RBRACE\n-     *\/\n-    JCExpression stringTemplate(JCExpression processor) {\n-        checkSourceLevel(Feature.STRING_TEMPLATES);\n-        \/\/ Disable standalone string templates\n-        if (processor == null) {\n-            log.error(DiagnosticFlag.SYNTAX, token.pos,\n-                    Errors.ProcessorMissingFromStringTemplateExpression);\n-        }\n-        int oldmode = mode;\n-        selectExprMode();\n-        Token stringToken = token;\n-        int pos = stringToken.pos;\n-        int endPos = stringToken.endPos;\n-        TokenKind kind = stringToken.kind;\n-        String string = token.stringVal();\n-        List<String> fragments = List.of(string);\n-        List<JCExpression> expressions = List.nil();\n-        nextToken();\n-        if (kind != STRINGLITERAL) {\n-            while (token.kind == STRINGFRAGMENT) {\n-                stringToken = token;\n-                endPos = stringToken.endPos;\n-                string = stringToken.stringVal();\n-                fragments = fragments.append(string);\n-                nextToken();\n-             }\n-            while (token.pos < endPos && token.kind != DEFAULT && token.kind != ERROR) {\n-                accept(LBRACE);\n-                JCExpression expression = token.kind == RBRACE ? F.at(pos).Literal(TypeTag.BOT, null)\n-                                                               : term(EXPR);\n-                expressions = expressions.append(expression);\n-                if (token.kind != ERROR) {\n-                    accept(RBRACE);\n-                }\n-            }\n-            \/\/ clean up remaining expression tokens if error\n-            while (token.pos < endPos && token.kind != DEFAULT) {\n-                nextToken();\n-            }\n-            S.setPrevToken(stringToken);\n-        }\n-        JCExpression t = toP(F.at(pos).StringTemplate(processor, fragments, expressions));\n-        setMode(oldmode);\n-        return t;\n-    }\n-\n@@ -1425,8 +1372,0 @@\n-         case STRINGFRAGMENT:\n-             if (typeArgs == null && isMode(EXPR)) {\n-                 selectExprMode();\n-                 t = stringTemplate(null);\n-             } else {\n-                 return illegal();\n-             }\n-             break;\n@@ -1563,6 +1502,0 @@\n-                            case STRINGFRAGMENT:\n-                            case STRINGLITERAL:\n-                                if (typeArgs != null) return illegal();\n-                                t = stringTemplate(t);\n-                                typeArgs = null;\n-                                break loop;\n@@ -1792,6 +1725,0 @@\n-                } else if (token.kind == TokenKind.STRINGFRAGMENT ||\n-                           token.kind == TokenKind.STRINGLITERAL) {\n-                    if (typeArgs != null) {\n-                        return illegal();\n-                    }\n-                    t = stringTemplate(t);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1364,13 +1364,0 @@\n-compiler.err.string.template.is.not.well.formed=\\\n-    string template is not well formed\n-\n-compiler.err.text.block.template.is.not.well.formed=\\\n-    text block template is not well formed\n-\n-compiler.err.processor.missing.from.string.template.expression=\\\n-    processor missing from string template expression\n-\n-# 0: symbol\n-compiler.err.not.a.processor.type=\\\n-    not a processor type: {0}\n-\n@@ -3222,3 +3209,0 @@\n-compiler.misc.feature.string.templates=\\\n-    string templates\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,4 +272,0 @@\n-        \/** String template expression.\n-         *\/\n-        STRING_TEMPLATE,\n-\n@@ -2484,53 +2480,0 @@\n-    \/**\n-     * String template expression.\n-     *\/\n-    public static class JCStringTemplate extends JCExpression implements StringTemplateTree {\n-        public JCExpression processor;\n-        public List<String> fragments;\n-        public List<JCExpression> expressions;\n-        public Type processMethodType;\n-\n-        protected JCStringTemplate(JCExpression processor,\n-                                   List<String> fragments,\n-                                   List<JCExpression> expressions) {\n-            this.processor = processor;\n-            this.fragments = fragments;\n-            this.expressions = expressions;\n-        }\n-\n-        @Override\n-        public ExpressionTree getProcessor() {\n-            return processor;\n-        }\n-\n-        @Override\n-        public List<String> getFragments() {\n-            return fragments;\n-        }\n-\n-        @Override\n-        public List<? extends ExpressionTree> getExpressions() {\n-            return expressions;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() {\n-            return Kind.TEMPLATE;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Tag getTag() {\n-            return STRING_TEMPLATE;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public void accept(Visitor v) {\n-            v.visitStringTemplate(this);\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n-            return v.visitStringTemplate(this, d);\n-        }\n-    }\n-\n@@ -3516,3 +3459,0 @@\n-        JCStringTemplate StringTemplate(JCExpression processor,\n-                                        List<String> fragments,\n-                                        List<JCExpression> expressions);\n@@ -3590,1 +3530,0 @@\n-        public void visitStringTemplate(JCStringTemplate that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":62,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -420,1 +420,1 @@\n-    \/**************************************************************************\n+    \/* ************************************************************************\n@@ -1479,15 +1479,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        try {\n-            JCExpression processor = tree.processor;\n-            print(\"[\");\n-            printExpr(processor);\n-            print(\"]\");\n-            print(\"\\\"\" + tree.fragments.stream().collect(Collectors.joining(\"\\\\{}\")) + \"\\\"\");\n-            print(\"(\");\n-            printExprs(tree.expressions);\n-            print(\")\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -287,8 +287,0 @@\n-    public JCTree visitStringTemplate(StringTemplateTree node, P p) {\n-        JCStringTemplate t = (JCStringTemplate) node;\n-        JCExpression processor = copy(t.processor, p);\n-        List<JCExpression> expressions = copy(t.expressions, p);\n-        return M.at(t.pos).StringTemplate(processor, t.fragments, expressions);\n-    }\n-\n-    @DefinedBy(Api.COMPILER_TREE)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -185,0 +185,35 @@\n+    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n+     *  class currently being compiled. This is true if tree is:\n+     *  - An unqualified 'this' identifier\n+     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *    but also NOT an enclosing outer class of 'currentClass'.\n+     *\/\n+    public static boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isExplicitThisReference(types, currentClass, skipParens(tree));\n+            case IDENT: {\n+                JCIdent ident = (JCIdent)tree;\n+                Names names = ident.name.table.names;\n+                return ident.name == names._this || ident.name == names._super;\n+            }\n+            case SELECT: {\n+                JCFieldAccess select = (JCFieldAccess)tree;\n+                Type selectedType = types.erasure(select.selected.type);\n+                if (!selectedType.hasTag(TypeTag.CLASS))\n+                    return false;\n+                Symbol.ClassSymbol currentClassSym = (Symbol.ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n+                Symbol.ClassSymbol selectedClassSym = (Symbol.ClassSymbol)((Type.ClassType)selectedType).tsym;\n+                Names names = select.name.table.names;\n+                return currentClassSym.isSubClass(selectedClassSym, types) &&\n+                        (select.name == names._super ||\n+                        (select.name == names._this &&\n+                            (currentClassSym == selectedClassSym ||\n+                            !currentClassSym.isEnclosedBy(selectedClassSym))));\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n@@ -374,1 +409,0 @@\n-            case STRING_TEMPLATE:\n@@ -590,4 +624,0 @@\n-            case STRING_TEMPLATE: {\n-                JCStringTemplate node = (JCStringTemplate) tree;\n-                return node.processor == null ? node.pos : getStartPos(node.processor);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -551,8 +551,0 @@\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n-    public JCStringTemplate StringTemplate(JCExpression processor,\n-                                           List<String> fragments,\n-                                           List<JCExpression> expressions) {\n-        JCStringTemplate tree = new JCStringTemplate(processor, fragments, expressions);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -356,5 +356,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        scan(tree.processor);\n-        scan(tree.expressions);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,7 +412,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        tree.processor = translate(tree.processor);\n-        tree.expressions = translate(tree.expressions);\n-\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -822,1 +822,1 @@\n-\/***************************************************************************\n+\/* *************************************************************************\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,8 +230,0 @@\n-    \/\/ templated string\n-    public final Name process;\n-    public final Name STR;\n-    public final Name RAW;\n-    public final Name newStringTemplate;\n-    public final Name newLargeStringTemplate;\n-    public final Name processStringTemplate;\n-\n@@ -416,7 +408,0 @@\n-        \/\/ templated string\n-        process = fromString(\"process\");\n-        STR = fromString(\"STR\");\n-        RAW = fromString(\"RAW\");\n-        newStringTemplate = fromString(\"newStringTemplate\");\n-        newLargeStringTemplate = fromString(\"newLargeStringTemplate\");\n-        processStringTemplate = fromString(\"processStringTemplate\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-            if (rv == CKR_OK) {\n+            if (rv == CKR_OK && interface != NULL) {\n@@ -213,3 +213,0 @@\n-        if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3) {\n-            moduleData->ckFunctionList30Ptr = interface->pFunctionList;\n-        }\n@@ -221,1 +218,2 @@\n-    if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3) {\n+    if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3 &&\n+            interface != NULL) {\n","filename":"src\/jdk.crypto.cryptoki\/unix\/native\/libj2pkcs11\/p11_md.c","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,1 +189,1 @@\n-            if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {\n+            if (rv == CKR_OK && interface != NULL) {\n@@ -237,1 +237,2 @@\n-    if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3) {\n+    if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3 &&\n+            interface != NULL) {\n","filename":"src\/jdk.crypto.cryptoki\/windows\/native\/libj2pkcs11\/p11_md.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -79,1 +79,4 @@\n-    protected CKey(String algorithm, NativeHandles handles, int keyLength) {\n+    private final boolean isPublic;\n+\n+    protected CKey(String algorithm, NativeHandles handles, int keyLength,\n+            boolean isPublic) {\n@@ -83,0 +86,1 @@\n+        this.isPublic = isPublic;\n@@ -105,0 +109,12 @@\n+    public String toString() {\n+        String typeStr;\n+        if (handles.hCryptKey != 0) {\n+            typeStr = getKeyType(handles.hCryptKey) + \", container=\" +\n+                    getContainerName(handles.hCryptProv);\n+        } else {\n+            typeStr = \"CNG\";\n+        }\n+        return algorithm + \" \" + (isPublic ? \"PublicKey\" : \"PrivateKey\") +\n+                \" [size=\" + keyLength + \" bits, type=\" + typeStr + \"]\";\n+    }\n+\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CKey.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        super(alg, handles, keyLength);\n+        super(alg, handles, keyLength, false);\n@@ -68,10 +68,0 @@\n-    public String toString() {\n-        if (handles.hCryptKey != 0) {\n-            return algorithm + \"PrivateKey [size=\" + keyLength + \" bits, type=\" +\n-                    getKeyType(handles.hCryptKey) + \", container=\" +\n-                    getContainerName(handles.hCryptProv) + \"]\";\n-        } else {\n-            return algorithm + \"PrivateKey [size=\" + keyLength + \" bits, type=CNG]\";\n-        }\n-    }\n-\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CPrivateKey.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -117,3 +117,2 @@\n-            StringBuffer sb = new StringBuffer();\n-            sb.append(algorithm).append(\"PublicKey [size=\").append(keyLength)\n-                    .append(\"]\\n  ECPoint: \").append(getW())\n+            StringBuffer sb = new StringBuffer(super.toString());\n+            sb.append(\"\\n ECPoint: \").append(getW())\n@@ -138,10 +137,2 @@\n-            StringBuffer sb = new StringBuffer();\n-            sb.append(algorithm).append(\"PublicKey [size=\").append(keyLength)\n-                    .append(\" bits, type=\");\n-            if (handles.hCryptKey != 0) {\n-                sb.append(getKeyType(handles.hCryptKey))\n-                        .append(\", container=\").append(getContainerName(handles.hCryptProv));\n-            } else {\n-                sb.append(\"CNG\");\n-            }\n-            sb.append(\"]\\n  modulus: \").append(getModulus())\n+            StringBuffer sb = new StringBuffer(super.toString());\n+            sb.append(\"\\n  modulus: \").append(getModulus())\n@@ -218,1 +209,1 @@\n-        super(alg, handles, keyLength);\n+        super(alg, handles, keyLength, true);\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CPublicKey.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -90,1 +90,7 @@\n-By default symbols are also located using <b>PATH<\/b>. However, there are also Java properties that can be used to specify both the location of the binaries, and also separately the location of symbols. Use <b>sun.jvm.hotspot.debugger.windbg.imagePath<\/b> for the location of binaries, and use <b>sun.jvm.hotspot.debugger.windbg.symbolPath<\/b> for the location of symbols. <b>imagePath<\/b> defaults to <b>PATH<\/b> if not set, and <b>symbolPath<\/b> defaults to <b>imagePath<\/b>. The advantage of using these propeties is that you don't need to change your <b>PATH<\/b> setting, and they allow for binaries to be located separately from symbols.\n+By default symbols are also located using <b>PATH<\/b>. However, there are also Java properties that\n+can be used to specify both the location of the binaries, and also separately the location of\n+symbols. Use <b>sun.jvm.hotspot.debugger.windbg.imagePath<\/b> for the location of binaries, and use\n+<b>sun.jvm.hotspot.debugger.windbg.symbolPath<\/b> for the location of symbols. <b>imagePath<\/b>\n+defaults to <b>PATH<\/b> if not set, and <b>symbolPath<\/b> defaults to <b>imagePath<\/b>. The\n+advantage of using these propeties is that you don't need to change your <b>PATH<\/b> setting, and\n+they allow for binaries to be located separately from symbols.\n@@ -94,1 +100,2 @@\n-How you set these properties will depend on the SA tool being used. The following example demonstrates how to set one of the properties when launching the clhsdb tool:\n+How you set these properties will depend on the SA tool being used. The following example\n+demonstrates how to set one of the properties when launching the clhsdb tool:\n@@ -101,1 +108,4 @@\n-<p>If you are not seeing symbols for Windows libraries, try setting <b>sun.jvm.hotspot.debugger.windbg.symbolPath<\/b> to include \"<b>srv*https:\/\/msdl.microsoft.com\/download\/symbols<\/b>\". Also include <b>PATH<\/b> so SA will still find your JVM and JNI symbols. For example:\n+<p>If you are not seeing symbols for Windows libraries, try setting\n+<b>sun.jvm.hotspot.debugger.windbg.symbolPath<\/b> to include\n+\"<b>srv*https:\/\/msdl.microsoft.com\/download\/symbols<\/b>\". Also include <b>PATH<\/b> so SA will still\n+find your JVM and JNI symbols. For example:\n@@ -120,2 +130,2 @@\n- used for locating the JDK libraries, but it needs to specify the full path to the libraries. SA will\n- not automatically search subdirs such as <b>lib\/server<\/b> as it does for <b>JAVA_HOME<\/b>.\n+ used for locating the JDK libraries, but it needs to specify the full path to the libraries. SA\n+ will not automatically search subdirs such as <b>lib\/server<\/b> as it does for <b>JAVA_HOME<\/b>.\n@@ -126,1 +136,1 @@\n- except it does not use it to map all the subdirs. It just appends <b>SA_ALTROOT<\/b> to the\n+ except it does not use it to map all the subdirs. It just prepends <b>SA_ALTROOT<\/b> to the\n","filename":"src\/jdk.hotspot.agent\/doc\/transported_core.html","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.jvm.hotspot.oops.CIntField;\n@@ -32,0 +33,1 @@\n+import sun.jvm.hotspot.types.JShortField;\n@@ -44,1 +46,0 @@\n-  private static CIntegerField headerSizeField;\n@@ -46,0 +47,1 @@\n+  private static CIntField     headerSizeField;\n@@ -48,1 +50,1 @@\n-  private static CIntegerField frameCompleteOffsetField;\n+  private static CIntField     frameCompleteOffsetField;\n@@ -64,1 +66,0 @@\n-    headerSizeField          = type.getCIntegerField(\"_header_size\");\n@@ -66,0 +67,1 @@\n+    headerSizeField          = new CIntField(type.getCIntegerField(\"_header_size\"), 0);\n@@ -68,1 +70,1 @@\n-    frameCompleteOffsetField = type.getCIntegerField(\"_frame_complete_offset\");\n+    frameCompleteOffsetField = new CIntField(type.getCIntegerField(\"_frame_complete_offset\"), 0);\n@@ -106,1 +108,1 @@\n-  public int getCodeOffset()      { return (int) codeOffsetField   .getValue(addr); }\n+  public int getCodeOffset()      { return (int) codeOffsetField.getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeBlob.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,2 +52,3 @@\n-  private static CIntegerField oopsOffsetField;\n-  private static CIntegerField metadataOffsetField;\n+  private static CIntField     metadataOffsetField;\n+  private static CIntField     dependenciesOffsetField;\n+  private static CIntField     scopesPCsOffsetField;\n@@ -55,2 +56,0 @@\n-  private static CIntegerField scopesPCsOffsetField;\n-  private static CIntegerField dependenciesOffsetField;\n@@ -59,1 +58,0 @@\n-  private static CIntegerField nmethodEndOffsetField;\n@@ -63,1 +61,1 @@\n-  private static AddressField  entryPointField;\n+  private static CIntField  entryOffsetField;\n@@ -65,1 +63,1 @@\n-  private static AddressField  verifiedEntryPointField;\n+  private static CIntField  verifiedEntryOffsetField;\n@@ -71,1 +69,1 @@\n-  private static CIntegerField compLevelField;\n+  private static CIntField compLevelField;\n@@ -93,2 +91,3 @@\n-    oopsOffsetField             = type.getCIntegerField(\"_oops_offset\");\n-    metadataOffsetField         = type.getCIntegerField(\"_metadata_offset\");\n+    metadataOffsetField         = new CIntField(type.getCIntegerField(\"_metadata_offset\"), 0);\n+    dependenciesOffsetField     = new CIntField(type.getCIntegerField(\"_dependencies_offset\"), 0);\n+    scopesPCsOffsetField        = new CIntField(type.getCIntegerField(\"_scopes_pcs_offset\"), 0);\n@@ -96,2 +95,0 @@\n-    scopesPCsOffsetField        = type.getCIntegerField(\"_scopes_pcs_offset\");\n-    dependenciesOffsetField     = type.getCIntegerField(\"_dependencies_offset\");\n@@ -100,3 +97,2 @@\n-    nmethodEndOffsetField       = type.getCIntegerField(\"_nmethod_end_offset\");\n-    entryPointField             = type.getAddressField(\"_entry_point\");\n-    verifiedEntryPointField     = type.getAddressField(\"_verified_entry_point\");\n+    entryOffsetField            = new CIntField(type.getCIntegerField(\"_entry_offset\"), 0);\n+    verifiedEntryOffsetField    = new CIntField(type.getCIntegerField(\"_verified_entry_offset\"), 0);\n@@ -104,1 +100,1 @@\n-    compLevelField              = type.getCIntegerField(\"_comp_level\");\n+    compLevelField              = new CIntField(type.getCIntegerField(\"_comp_level\"), 0);\n@@ -129,1 +125,1 @@\n-  public Address constantsEnd()         { return getEntryPoint();                                    }\n+  public Address constantsEnd()         { return codeBegin();                                        }\n@@ -136,15 +132,15 @@\n-  public Address stubEnd()              { return headerBegin().addOffsetTo(getOopsOffset());         }\n-  public Address oopsBegin()            { return headerBegin().addOffsetTo(getOopsOffset());         }\n-  public Address oopsEnd()              { return headerBegin().addOffsetTo(getMetadataOffset());     }\n-  public Address metadataBegin()        { return headerBegin().addOffsetTo(getMetadataOffset());     }\n-  public Address metadataEnd()          { return headerBegin().addOffsetTo(getScopesDataOffset());   }\n-  public Address scopesDataBegin()      { return headerBegin().addOffsetTo(getScopesDataOffset());   }\n-  public Address scopesDataEnd()        { return headerBegin().addOffsetTo(getScopesPCsOffset());    }\n-  public Address scopesPCsBegin()       { return headerBegin().addOffsetTo(getScopesPCsOffset());    }\n-  public Address scopesPCsEnd()         { return headerBegin().addOffsetTo(getDependenciesOffset()); }\n-  public Address dependenciesBegin()    { return headerBegin().addOffsetTo(getDependenciesOffset()); }\n-  public Address dependenciesEnd()      { return headerBegin().addOffsetTo(getHandlerTableOffset()); }\n-  public Address handlerTableBegin()    { return headerBegin().addOffsetTo(getHandlerTableOffset()); }\n-  public Address handlerTableEnd()      { return headerBegin().addOffsetTo(getNulChkTableOffset());  }\n-  public Address nulChkTableBegin()     { return headerBegin().addOffsetTo(getNulChkTableOffset());  }\n-  public Address nulChkTableEnd()       { return headerBegin().addOffsetTo(getNMethodEndOffset());   }\n+  public Address stubEnd()              { return dataBegin();                                        }\n+  public Address oopsBegin()            { return dataBegin();                                        }\n+  public Address oopsEnd()              { return dataBegin().addOffsetTo(getMetadataOffset());       }\n+  public Address metadataBegin()        { return dataBegin().addOffsetTo(getMetadataOffset());       }\n+  public Address metadataEnd()          { return dataBegin().addOffsetTo(getDependenciesOffset());   }\n+  public Address dependenciesBegin()    { return dataBegin().addOffsetTo(getDependenciesOffset());   }\n+  public Address dependenciesEnd()      { return dataBegin().addOffsetTo(getScopesDataOffset());     }\n+  public Address scopesDataBegin()      { return dataBegin().addOffsetTo(getScopesDataOffset());     }\n+  public Address scopesDataEnd()        { return dataBegin().addOffsetTo(getScopesPCsOffset());      }\n+  public Address scopesPCsBegin()       { return dataBegin().addOffsetTo(getScopesPCsOffset());      }\n+  public Address scopesPCsEnd()         { return dataBegin().addOffsetTo(getHandlerTableOffset());   }\n+  public Address handlerTableBegin()    { return dataBegin().addOffsetTo(getHandlerTableOffset());   }\n+  public Address handlerTableEnd()      { return dataBegin().addOffsetTo(getNulChkTableOffset());    }\n+  public Address nulChkTableBegin()     { return dataBegin().addOffsetTo(getNulChkTableOffset());    }\n+  public Address nulChkTableEnd()       { return dataEnd();                                          }\n@@ -190,2 +186,2 @@\n-  public Address getEntryPoint()         { return entryPointField.getValue(addr);         }\n-  public Address getVerifiedEntryPoint() { return verifiedEntryPointField.getValue(addr); }\n+  public Address getEntryPoint()         { return codeBegin().addOffsetTo(getEntryPointOffset());         }\n+  public Address getVerifiedEntryPoint() { return codeBegin().addOffsetTo(getVerifiedEntryPointOffset()); }\n@@ -435,5 +431,5 @@\n-  public static int getEntryPointOffset()            { return (int) entryPointField.getOffset();            }\n-  public static int getVerifiedEntryPointOffset()    { return (int) verifiedEntryPointField.getOffset();    }\n-  public static int getOSREntryPointOffset()         { return (int) osrEntryPointField.getOffset();         }\n-  public static int getEntryBCIOffset()              { return (int) entryBCIField.getOffset();              }\n-  public static int getMethodOffset()                { return (int) methodField.getOffset();                }\n+  public int getEntryPointOffset()            { return (int) entryOffsetField.getValue(addr);        }\n+  public int getVerifiedEntryPointOffset()    { return (int) verifiedEntryOffsetField.getValue(addr);}\n+  public static int getOSREntryPointOffset()  { return (int) osrEntryPointField.getOffset();         }\n+  public static int getEntryBCIOffset()       { return (int) entryBCIField.getOffset();              }\n+  public static int getMethodOffset()         { return (int) methodField.getOffset();                }\n@@ -520,1 +516,0 @@\n-  private int getOopsOffset()         { return (int) oopsOffsetField        .getValue(addr); }\n@@ -527,1 +522,0 @@\n-  private int getNMethodEndOffset()   { return (int) nmethodEndOffsetField  .getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":35,"deletions":41,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.shared;\n-\n-import sun.jvm.hotspot.debugger.*;\n-\n-\/** No additional functionality for now *\/\n-\n-public class TenuredSpace extends ContiguousSpace {\n-  public TenuredSpace(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/TenuredSpace.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -27,2 +27,2 @@\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.oops.ConstantPoolCache;\n+import sun.jvm.hotspot.oops.Method;\n@@ -40,6 +40,1 @@\n-      int index = getIndexU4();\n-      if (ConstantPool.isInvokedynamicIndex(index)) {\n-        return ConstantPool.decodeInvokedynamicIndex(index);\n-      } else {\n-        return index;\n-      }\n+      return getIndexU4();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeWithCPIndex.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -309,12 +309,0 @@\n-  public static boolean isInvokedynamicIndex(int i) { return (i < 0); }\n-\n-  public static int  decodeInvokedynamicIndex(int i) { Assert.that(isInvokedynamicIndex(i),  \"\"); return ~i; }\n-\n-  \/\/ The invokedynamic points at a CP cache entry.  This entry points back\n-  \/\/ at the original CP entry (CONSTANT_InvokeDynamic) and also (via f2) at an entry\n-  \/\/ in the resolved_references array (which provides the appendix argument).\n-  public int invokedynamicCPCacheIndex(int index) {\n-    Assert.that(isInvokedynamicIndex(index), \"should be a invokedynamic index\");\n-    return decodeInvokedynamicIndex(index);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPool.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,4 +27,0 @@\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.interpreter.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.runtime.*;\n@@ -34,0 +30,8 @@\n+import sun.jvm.hotspot.interpreter.Bytecodes;\n+import sun.jvm.hotspot.oops.ConstantPool;\n+import sun.jvm.hotspot.oops.ConstantPoolCache;\n+import sun.jvm.hotspot.oops.Method;\n+import sun.jvm.hotspot.runtime.Bytes;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.utilities.Assert;\n+\n@@ -136,2 +140,2 @@\n-                    int cpci = method.getNativeIntArg(bci + 1);\n-                    cpoolIndex = (short) cpCache.getIndyEntryAt(~cpci).getConstantPoolIndex();\n+                    int indy_index = method.getNativeIntArg(bci + 1);\n+                    cpoolIndex = (short) cpCache.getIndyEntryAt(indy_index).getConstantPoolIndex();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ByteCodeRewriter.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -896,0 +896,6 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte128Mask.class, a, offset, indexMap, mapOffset, (Byte128Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -928,0 +928,6 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte256Mask.class, a, offset, indexMap, mapOffset, (Byte256Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -992,0 +992,6 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte512Mask.class, a, offset, indexMap, mapOffset, (Byte512Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -880,0 +880,6 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte64Mask.class, a, offset, indexMap, mapOffset, (Byte64Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -866,0 +866,6 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Byte> m) {\n+        return super.fromArray0Template(ByteMaxMask.class, a, offset, indexMap, mapOffset, (ByteMaxMask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3052,1 +3052,29 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+        Objects.requireNonNull(a);\n+        Objects.requireNonNull(indexMap);\n+        Class<? extends ByteVector> vectorType = vsp.vectorType();\n+\n+\n+        \/\/ Constant folding should sweep out following conditonal logic.\n+        VectorSpecies<Integer> lsp;\n+        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {\n+            lsp = IntVector.SPECIES_PREFERRED;\n+        } else {\n+            lsp = isp;\n+        }\n+\n+        \/\/ Check indices are within array bounds.\n+        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n+            IntVector vix = IntVector\n+                .fromArray(lsp, indexMap, mapOffset + i)\n+                .add(offset);\n+            VectorIntrinsics.checkIndex(vix, a.length);\n+        }\n+\n+        return VectorSupport.loadWithMap(\n+            vectorType, null, byte.class, vsp.laneCount(),\n+            lsp.vectorType(),\n+            a, ARRAY_BASE, null, null,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(n -> c[idx + iMap[idy+n]]));\n@@ -3097,2 +3125,7 @@\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        if (m.allTrue()) {\n+            return fromArray(species, a, offset, indexMap, mapOffset);\n+        }\n+        else {\n+            ByteSpecies vsp = (ByteSpecies) species;\n+            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+        }\n@@ -3763,0 +3796,43 @@\n+    \/*package-private*\/\n+    abstract\n+    ByteVector fromArray0(byte[] a, int offset,\n+                                    int[] indexMap, int mapOffset,\n+                                    VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector fromArray0Template(Class<M> maskClass, byte[] a, int offset,\n+                                            int[] indexMap, int mapOffset, M m) {\n+        ByteSpecies vsp = vspecies();\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+        Objects.requireNonNull(a);\n+        Objects.requireNonNull(indexMap);\n+        m.check(vsp);\n+        Class<? extends ByteVector> vectorType = vsp.vectorType();\n+\n+\n+        \/\/ Constant folding should sweep out following conditonal logic.\n+        VectorSpecies<Integer> lsp;\n+        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {\n+            lsp = IntVector.SPECIES_PREFERRED;\n+        } else {\n+            lsp = isp;\n+        }\n+\n+        \/\/ Check indices are within array bounds.\n+        \/\/ FIXME: Check index under mask controlling.\n+        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n+            IntVector vix = IntVector\n+                .fromArray(lsp, indexMap, mapOffset + i)\n+                .add(offset);\n+            VectorIntrinsics.checkIndex(vix, a.length);\n+        }\n+\n+        return VectorSupport.loadWithMap(\n+            vectorType, maskClass, byte.class, vsp.laneCount(),\n+            lsp.vectorType(),\n+            a, ARRAY_BASE, null, m,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":79,"deletions":3,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -880,0 +880,6 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short128Mask.class, a, offset, indexMap, mapOffset, (Short128Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -896,0 +896,6 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short256Mask.class, a, offset, indexMap, mapOffset, (Short256Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -928,0 +928,6 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short512Mask.class, a, offset, indexMap, mapOffset, (Short512Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -872,0 +872,6 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short64Mask.class, a, offset, indexMap, mapOffset, (Short64Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -866,0 +866,6 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Short> m) {\n+        return super.fromArray0Template(ShortMaxMask.class, a, offset, indexMap, mapOffset, (ShortMaxMask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3053,1 +3053,29 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+        Objects.requireNonNull(a);\n+        Objects.requireNonNull(indexMap);\n+        Class<? extends ShortVector> vectorType = vsp.vectorType();\n+\n+\n+        \/\/ Constant folding should sweep out following conditonal logic.\n+        VectorSpecies<Integer> lsp;\n+        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {\n+            lsp = IntVector.SPECIES_PREFERRED;\n+        } else {\n+            lsp = isp;\n+        }\n+\n+        \/\/ Check indices are within array bounds.\n+        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n+            IntVector vix = IntVector\n+                .fromArray(lsp, indexMap, mapOffset + i)\n+                .add(offset);\n+            VectorIntrinsics.checkIndex(vix, a.length);\n+        }\n+\n+        return VectorSupport.loadWithMap(\n+            vectorType, null, short.class, vsp.laneCount(),\n+            lsp.vectorType(),\n+            a, ARRAY_BASE, null, null,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(n -> c[idx + iMap[idy+n]]));\n@@ -3098,2 +3126,7 @@\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        if (m.allTrue()) {\n+            return fromArray(species, a, offset, indexMap, mapOffset);\n+        }\n+        else {\n+            ShortSpecies vsp = (ShortSpecies) species;\n+            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+        }\n@@ -3749,0 +3782,43 @@\n+    \/*package-private*\/\n+    abstract\n+    ShortVector fromArray0(short[] a, int offset,\n+                                    int[] indexMap, int mapOffset,\n+                                    VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector fromArray0Template(Class<M> maskClass, short[] a, int offset,\n+                                            int[] indexMap, int mapOffset, M m) {\n+        ShortSpecies vsp = vspecies();\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+        Objects.requireNonNull(a);\n+        Objects.requireNonNull(indexMap);\n+        m.check(vsp);\n+        Class<? extends ShortVector> vectorType = vsp.vectorType();\n+\n+\n+        \/\/ Constant folding should sweep out following conditonal logic.\n+        VectorSpecies<Integer> lsp;\n+        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {\n+            lsp = IntVector.SPECIES_PREFERRED;\n+        } else {\n+            lsp = isp;\n+        }\n+\n+        \/\/ Check indices are within array bounds.\n+        \/\/ FIXME: Check index under mask controlling.\n+        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n+            IntVector vix = IntVector\n+                .fromArray(lsp, indexMap, mapOffset + i)\n+                .add(offset);\n+            VectorIntrinsics.checkIndex(vix, a.length);\n+        }\n+\n+        return VectorSupport.loadWithMap(\n+            vectorType, maskClass, short.class, vsp.laneCount(),\n+            lsp.vectorType(),\n+            a, ARRAY_BASE, null, m,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":79,"deletions":3,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -3625,1 +3625,29 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+        Objects.requireNonNull(a);\n+        Objects.requireNonNull(indexMap);\n+        Class<? extends $abstractvectortype$> vectorType = vsp.vectorType();\n+\n+\n+        \/\/ Constant folding should sweep out following conditonal logic.\n+        VectorSpecies<Integer> lsp;\n+        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {\n+            lsp = IntVector.SPECIES_PREFERRED;\n+        } else {\n+            lsp = isp;\n+        }\n+\n+        \/\/ Check indices are within array bounds.\n+        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n+            IntVector vix = IntVector\n+                .fromArray(lsp, indexMap, mapOffset + i)\n+                .add(offset);\n+            VectorIntrinsics.checkIndex(vix, a.length);\n+        }\n+\n+        return VectorSupport.loadWithMap(\n+            vectorType, null, $type$.class, vsp.laneCount(),\n+            lsp.vectorType(),\n+            a, ARRAY_BASE, null, null,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(n -> c[idx + iMap[idy+n]]));\n@@ -3717,11 +3745,0 @@\n-#if[byteOrShort]\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromArray(VectorSpecies<$Boxtype$> species,\n-                                   $type$[] a, int offset,\n-                                   int[] indexMap, int mapOffset,\n-                                   VectorMask<$Boxtype$> m) {\n-        $Type$Species vsp = ($Type$Species) species;\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n-    }\n-#else[byteOrShort]\n@@ -3742,1 +3759,0 @@\n-#end[byteOrShort]\n@@ -4796,1 +4812,0 @@\n-#if[!byteOrShort]\n@@ -4802,0 +4817,40 @@\n+#if[byteOrShort]\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $abstractvectortype$ fromArray0Template(Class<M> maskClass, $type$[] a, int offset,\n+                                            int[] indexMap, int mapOffset, M m) {\n+        $Type$Species vsp = vspecies();\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+        Objects.requireNonNull(a);\n+        Objects.requireNonNull(indexMap);\n+        m.check(vsp);\n+        Class<? extends $abstractvectortype$> vectorType = vsp.vectorType();\n+\n+\n+        \/\/ Constant folding should sweep out following conditonal logic.\n+        VectorSpecies<Integer> lsp;\n+        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {\n+            lsp = IntVector.SPECIES_PREFERRED;\n+        } else {\n+            lsp = isp;\n+        }\n+\n+        \/\/ Check indices are within array bounds.\n+        \/\/ FIXME: Check index under mask controlling.\n+        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n+            IntVector vix = IntVector\n+                .fromArray(lsp, indexMap, mapOffset + i)\n+                .add(offset);\n+            VectorIntrinsics.checkIndex(vix, a.length);\n+        }\n+\n+        return VectorSupport.loadWithMap(\n+            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            lsp.vectorType(),\n+            a, ARRAY_BASE, null, m,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+    }\n+#else[byteOrShort]\n@@ -4855,1 +4910,1 @@\n-#end[!byteOrShort]\n+#end[byteOrShort]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":70,"deletions":15,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -1154,1 +1154,0 @@\n-#if[!byteOrShort]\n@@ -1161,1 +1160,0 @@\n-#end[!byteOrShort]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,4 +153,4 @@\n-    ws.ws_row = env->GetIntField(data, ws_row);\n-    ws.ws_col = env->GetIntField(data, ws_col);\n-    ws.ws_xpixel = env->GetIntField(data, ws_xpixel);\n-    ws.ws_ypixel = env->GetIntField(data, ws_ypixel);\n+    ws.ws_row = env->GetShortField(data, ws_row);\n+    ws.ws_col = env->GetShortField(data, ws_col);\n+    ws.ws_xpixel = env->GetShortField(data, ws_xpixel);\n+    ws.ws_ypixel = env->GetShortField(data, ws_ypixel);\n@@ -163,4 +163,4 @@\n-    env->SetIntField(data, ws_row, ws.ws_row);\n-    env->SetIntField(data, ws_col, ws.ws_col);\n-    env->SetIntField(data, ws_xpixel, ws.ws_xpixel);\n-    env->SetIntField(data, ws_ypixel, ws.ws_ypixel);\n+    env->SetShortField(data, ws_row, ws.ws_row);\n+    env->SetShortField(data, ws_col, ws.ws_col);\n+    env->SetShortField(data, ws_xpixel, ws.ws_xpixel);\n+    env->SetShortField(data, ws_ypixel, ws.ws_ypixel);\n","filename":"src\/jdk.internal.le\/linux\/native\/lible\/CLibrary.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -157,4 +157,4 @@\n-    ws.ws_row = env->GetIntField(data, ws_row);\n-    ws.ws_col = env->GetIntField(data, ws_col);\n-    ws.ws_xpixel = env->GetIntField(data, ws_xpixel);\n-    ws.ws_ypixel = env->GetIntField(data, ws_ypixel);\n+    ws.ws_row = env->GetShortField(data, ws_row);\n+    ws.ws_col = env->GetShortField(data, ws_col);\n+    ws.ws_xpixel = env->GetShortField(data, ws_xpixel);\n+    ws.ws_ypixel = env->GetShortField(data, ws_ypixel);\n@@ -167,4 +167,4 @@\n-    env->SetIntField(data, ws_row, ws.ws_row);\n-    env->SetIntField(data, ws_col, ws.ws_col);\n-    env->SetIntField(data, ws_xpixel, ws.ws_xpixel);\n-    env->SetIntField(data, ws_ypixel, ws.ws_ypixel);\n+    env->SetShortField(data, ws_row, ws.ws_row);\n+    env->SetShortField(data, ws_col, ws.ws_col);\n+    env->SetShortField(data, ws_xpixel, ws.ws_xpixel);\n+    env->SetShortField(data, ws_ypixel, ws.ws_ypixel);\n","filename":"src\/jdk.internal.le\/macosx\/native\/lible\/CLibrary.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import static jdk.vm.ci.common.InitTimer.timer;\n-import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;\n-\n@@ -38,0 +35,1 @@\n+import static jdk.vm.ci.common.InitTimer.timer;\n@@ -40,0 +38,1 @@\n+import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;\n@@ -432,1 +431,1 @@\n-     * Converts the encoded indy index operand of an invokedynamic instruction\n+     * Converts the indy index operand of an invokedynamic instruction\n@@ -436,1 +435,0 @@\n-     * @throws IllegalArgumentException if {@code encoded_indy_index} is not an encoded indy index\n@@ -538,2 +536,2 @@\n-    int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi) {\n-        return isResolvedInvokeHandleInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi, int opcode) {\n+        return isResolvedInvokeHandleInPool(constantPool, constantPool.getConstantPoolPointer(), cpi, opcode);\n@@ -542,1 +540,1 @@\n-    private native int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi, int opcode);\n@@ -599,2 +597,2 @@\n-    HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, int which) {\n-        return lookupAppendixInPool(constantPool, constantPool.getConstantPoolPointer(), which);\n+    HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, int which, int opcode) {\n+        return lookupAppendixInPool(constantPool, constantPool.getConstantPoolPointer(), which, opcode);\n@@ -603,1 +601,1 @@\n-    private native HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which);\n+    private native HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which, int opcode);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,5 +25,0 @@\n-import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;\n-import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;\n-import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;\n-import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;\n-\n@@ -31,2 +26,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n@@ -38,0 +31,4 @@\n+import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;\n+import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;\n+import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;\n+import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;\n@@ -262,7 +259,0 @@\n-    \/**\n-     * See {@code ConstantPool::is_invokedynamic_index}.\n-     *\/\n-    private static boolean isInvokedynamicIndex(int index) {\n-        return index < 0;\n-    }\n-\n@@ -711,9 +701,1 @@\n-\n-        if (opcode == Bytecodes.INVOKEDYNAMIC) {\n-          if (!isInvokedynamicIndex(rawIndex)) {\n-              throw new IllegalArgumentException(\"expected a raw index for INVOKEDYNAMIC but got \" + rawIndex);\n-          }\n-          return compilerToVM().lookupAppendixInPool(this, rawIndex);\n-        } else {\n-          return compilerToVM().lookupAppendixInPool(this, rawIndex);\n-        }\n+        return compilerToVM().lookupAppendixInPool(this, rawIndex, opcode);\n@@ -738,10 +720,1 @@\n-        int which; \/\/ interpretation depends on opcode\n-        if (opcode == Bytecodes.INVOKEDYNAMIC) {\n-            if (!isInvokedynamicIndex(rawIndex)) {\n-                throw new IllegalArgumentException(\"expected a raw index for INVOKEDYNAMIC but got \" + rawIndex);\n-            }\n-            which = rawIndex;\n-        } else {\n-            which = rawIndex;\n-        }\n-        final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, which, (byte) opcode, (HotSpotResolvedJavaMethodImpl) caller);\n+        final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, rawIndex, (byte) opcode, (HotSpotResolvedJavaMethodImpl) caller);\n@@ -752,2 +725,2 @@\n-            String name = compilerToVM().lookupNameInPool(this, which, opcode);\n-            HotSpotSignature signature = new HotSpotSignature(runtime(), compilerToVM().lookupSignatureInPool(this, which, opcode));\n+            String name = compilerToVM().lookupNameInPool(this, rawIndex, opcode);\n+            HotSpotSignature signature = new HotSpotSignature(runtime(), compilerToVM().lookupSignatureInPool(this, rawIndex, opcode));\n@@ -757,1 +730,1 @@\n-                final int klassIndex = getKlassRefIndexAt(which, opcode);\n+                final int klassIndex = getKlassRefIndexAt(rawIndex, opcode);\n@@ -856,7 +829,2 @@\n-        if (isInvokedynamicIndex(rawIndex)) {\n-            if (opcode != Bytecodes.INVOKEDYNAMIC) {\n-                throw new IllegalArgumentException(\"expected INVOKEDYNAMIC at \" + rawIndex + \", got \" + opcode);\n-            }\n-            return compilerToVM().decodeIndyIndexToCPIndex(this, rawIndex, false);\n-        } else {\n-          throw new IllegalArgumentException(\"expected a raw index for INVOKEDYNAMIC but got \" + rawIndex);\n+        if (opcode != Bytecodes.INVOKEDYNAMIC) {\n+            throw new IllegalArgumentException(\"expected INVOKEDYNAMIC at \" + rawIndex + \", got \" + opcode);\n@@ -864,0 +832,1 @@\n+        return compilerToVM().decodeIndyIndexToCPIndex(this, rawIndex, false);\n@@ -887,4 +856,0 @@\n-                \/\/ invokedynamic indices are different from constant pool cache indices\n-                if (!isInvokedynamicIndex(rawIndex)) {\n-                    throw new IllegalArgumentException(\"must use invokedynamic index but got \" + rawIndex);\n-                }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":12,"deletions":47,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,2 @@\n+     *\n+     * @since 15\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/doclet\/Taglet.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,10909 +0,0 @@\n-\/*!\n- * jQuery JavaScript Library v3.6.1\n- * https:\/\/jquery.com\/\n- *\n- * Includes Sizzle.js\n- * https:\/\/sizzlejs.com\/\n- *\n- * Copyright OpenJS Foundation and other contributors\n- * Released under the MIT license\n- * https:\/\/jquery.org\/license\n- *\n- * Date: 2022-08-26T17:52Z\n- *\/\n-( function( global, factory ) {\n-\n-\t\"use strict\";\n-\n-\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n-\n-\t\t\/\/ For CommonJS and CommonJS-like environments where a proper `window`\n-\t\t\/\/ is present, execute the factory and get jQuery.\n-\t\t\/\/ For environments that do not have a `window` with a `document`\n-\t\t\/\/ (such as Node.js), expose a factory as module.exports.\n-\t\t\/\/ This accentuates the need for the creation of a real `window`.\n-\t\t\/\/ e.g. var jQuery = require(\"jquery\")(window);\n-\t\t\/\/ See ticket trac-14549 for more info.\n-\t\tmodule.exports = global.document ?\n-\t\t\tfactory( global, true ) :\n-\t\t\tfunction( w ) {\n-\t\t\t\tif ( !w.document ) {\n-\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n-\t\t\t\t}\n-\t\t\t\treturn factory( w );\n-\t\t\t};\n-\t} else {\n-\t\tfactory( global );\n-\t}\n-\n-\/\/ Pass this if window is not defined yet\n-} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n-\n-\/\/ Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n-\/\/ throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n-\/\/ arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n-\/\/ enough that all such attempts are guarded in a try block.\n-\"use strict\";\n-\n-var arr = [];\n-\n-var getProto = Object.getPrototypeOf;\n-\n-var slice = arr.slice;\n-\n-var flat = arr.flat ? function( array ) {\n-\treturn arr.flat.call( array );\n-} : function( array ) {\n-\treturn arr.concat.apply( [], array );\n-};\n-\n-\n-var push = arr.push;\n-\n-var indexOf = arr.indexOf;\n-\n-var class2type = {};\n-\n-var toString = class2type.toString;\n-\n-var hasOwn = class2type.hasOwnProperty;\n-\n-var fnToString = hasOwn.toString;\n-\n-var ObjectFunctionString = fnToString.call( Object );\n-\n-var support = {};\n-\n-var isFunction = function isFunction( obj ) {\n-\n-\t\t\/\/ Support: Chrome <=57, Firefox <=52\n-\t\t\/\/ In some browsers, typeof returns \"function\" for HTML <object> elements\n-\t\t\/\/ (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n-\t\t\/\/ We don't want to classify *any* DOM node as a function.\n-\t\t\/\/ Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n-\t\t\/\/ Plus for old WebKit, typeof returns \"function\" for HTML collections\n-\t\t\/\/ (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n-\t\treturn typeof obj === \"function\" && typeof obj.nodeType !== \"number\" &&\n-\t\t\ttypeof obj.item !== \"function\";\n-\t};\n-\n-\n-var isWindow = function isWindow( obj ) {\n-\t\treturn obj != null && obj === obj.window;\n-\t};\n-\n-\n-var document = window.document;\n-\n-\n-\n-\tvar preservedScriptAttributes = {\n-\t\ttype: true,\n-\t\tsrc: true,\n-\t\tnonce: true,\n-\t\tnoModule: true\n-\t};\n-\n-\tfunction DOMEval( code, node, doc ) {\n-\t\tdoc = doc || document;\n-\n-\t\tvar i, val,\n-\t\t\tscript = doc.createElement( \"script\" );\n-\n-\t\tscript.text = code;\n-\t\tif ( node ) {\n-\t\t\tfor ( i in preservedScriptAttributes ) {\n-\n-\t\t\t\t\/\/ Support: Firefox 64+, Edge 18+\n-\t\t\t\t\/\/ Some browsers don't support the \"nonce\" property on scripts.\n-\t\t\t\t\/\/ On the other hand, just using `getAttribute` is not enough as\n-\t\t\t\t\/\/ the `nonce` attribute is reset to an empty string whenever it\n-\t\t\t\t\/\/ becomes browsing-context connected.\n-\t\t\t\t\/\/ See https:\/\/github.com\/whatwg\/html\/issues\/2369\n-\t\t\t\t\/\/ See https:\/\/html.spec.whatwg.org\/#nonce-attributes\n-\t\t\t\t\/\/ The `node.getAttribute` check was added for the sake of\n-\t\t\t\t\/\/ `jQuery.globalEval` so that it can fake a nonce-containing node\n-\t\t\t\t\/\/ via an object.\n-\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n-\t\t\t\tif ( val ) {\n-\t\t\t\t\tscript.setAttribute( i, val );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n-\t}\n-\n-\n-function toType( obj ) {\n-\tif ( obj == null ) {\n-\t\treturn obj + \"\";\n-\t}\n-\n-\t\/\/ Support: Android <=2.3 only (functionish RegExp)\n-\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n-\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n-\t\ttypeof obj;\n-}\n-\/* global Symbol *\/\n-\/\/ Defining this global in .eslintrc.json would create a danger of using the global\n-\/\/ unguarded in another place, it seems safer to define global only for this module\n-\n-\n-\n-var\n-\tversion = \"3.6.1\",\n-\n-\t\/\/ Define a local copy of jQuery\n-\tjQuery = function( selector, context ) {\n-\n-\t\t\/\/ The jQuery object is actually just the init constructor 'enhanced'\n-\t\t\/\/ Need init if jQuery is called (just allow error to be thrown if not included)\n-\t\treturn new jQuery.fn.init( selector, context );\n-\t};\n-\n-jQuery.fn = jQuery.prototype = {\n-\n-\t\/\/ The current version of jQuery being used\n-\tjquery: version,\n-\n-\tconstructor: jQuery,\n-\n-\t\/\/ The default length of a jQuery object is 0\n-\tlength: 0,\n-\n-\ttoArray: function() {\n-\t\treturn slice.call( this );\n-\t},\n-\n-\t\/\/ Get the Nth element in the matched element set OR\n-\t\/\/ Get the whole matched element set as a clean array\n-\tget: function( num ) {\n-\n-\t\t\/\/ Return all the elements in a clean array\n-\t\tif ( num == null ) {\n-\t\t\treturn slice.call( this );\n-\t\t}\n-\n-\t\t\/\/ Return just the one element from the set\n-\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n-\t},\n-\n-\t\/\/ Take an array of elements and push it onto the stack\n-\t\/\/ (returning the new matched element set)\n-\tpushStack: function( elems ) {\n-\n-\t\t\/\/ Build a new jQuery matched element set\n-\t\tvar ret = jQuery.merge( this.constructor(), elems );\n-\n-\t\t\/\/ Add the old object onto the stack (as a reference)\n-\t\tret.prevObject = this;\n-\n-\t\t\/\/ Return the newly-formed element set\n-\t\treturn ret;\n-\t},\n-\n-\t\/\/ Execute a callback for every element in the matched set.\n-\teach: function( callback ) {\n-\t\treturn jQuery.each( this, callback );\n-\t},\n-\n-\tmap: function( callback ) {\n-\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n-\t\t\treturn callback.call( elem, i, elem );\n-\t\t} ) );\n-\t},\n-\n-\tslice: function() {\n-\t\treturn this.pushStack( slice.apply( this, arguments ) );\n-\t},\n-\n-\tfirst: function() {\n-\t\treturn this.eq( 0 );\n-\t},\n-\n-\tlast: function() {\n-\t\treturn this.eq( -1 );\n-\t},\n-\n-\teven: function() {\n-\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n-\t\t\treturn ( i + 1 ) % 2;\n-\t\t} ) );\n-\t},\n-\n-\todd: function() {\n-\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n-\t\t\treturn i % 2;\n-\t\t} ) );\n-\t},\n-\n-\teq: function( i ) {\n-\t\tvar len = this.length,\n-\t\t\tj = +i + ( i < 0 ? len : 0 );\n-\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n-\t},\n-\n-\tend: function() {\n-\t\treturn this.prevObject || this.constructor();\n-\t},\n-\n-\t\/\/ For internal use only.\n-\t\/\/ Behaves like an Array's method, not like a jQuery method.\n-\tpush: push,\n-\tsort: arr.sort,\n-\tsplice: arr.splice\n-};\n-\n-jQuery.extend = jQuery.fn.extend = function() {\n-\tvar options, name, src, copy, copyIsArray, clone,\n-\t\ttarget = arguments[ 0 ] || {},\n-\t\ti = 1,\n-\t\tlength = arguments.length,\n-\t\tdeep = false;\n-\n-\t\/\/ Handle a deep copy situation\n-\tif ( typeof target === \"boolean\" ) {\n-\t\tdeep = target;\n-\n-\t\t\/\/ Skip the boolean and the target\n-\t\ttarget = arguments[ i ] || {};\n-\t\ti++;\n-\t}\n-\n-\t\/\/ Handle case when target is a string or something (possible in deep copy)\n-\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n-\t\ttarget = {};\n-\t}\n-\n-\t\/\/ Extend jQuery itself if only one argument is passed\n-\tif ( i === length ) {\n-\t\ttarget = this;\n-\t\ti--;\n-\t}\n-\n-\tfor ( ; i < length; i++ ) {\n-\n-\t\t\/\/ Only deal with non-null\/undefined values\n-\t\tif ( ( options = arguments[ i ] ) != null ) {\n-\n-\t\t\t\/\/ Extend the base object\n-\t\t\tfor ( name in options ) {\n-\t\t\t\tcopy = options[ name ];\n-\n-\t\t\t\t\/\/ Prevent Object.prototype pollution\n-\t\t\t\t\/\/ Prevent never-ending loop\n-\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Recurse if we're merging plain objects or arrays\n-\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n-\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n-\t\t\t\t\tsrc = target[ name ];\n-\n-\t\t\t\t\t\/\/ Ensure proper type for the source value\n-\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n-\t\t\t\t\t\tclone = [];\n-\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n-\t\t\t\t\t\tclone = {};\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tclone = src;\n-\t\t\t\t\t}\n-\t\t\t\t\tcopyIsArray = false;\n-\n-\t\t\t\t\t\/\/ Never move original objects, clone them\n-\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n-\n-\t\t\t\t\/\/ Don't bring in undefined values\n-\t\t\t\t} else if ( copy !== undefined ) {\n-\t\t\t\t\ttarget[ name ] = copy;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t\/\/ Return the modified object\n-\treturn target;\n-};\n-\n-jQuery.extend( {\n-\n-\t\/\/ Unique for each copy of jQuery on the page\n-\texpando: \"jQuery\" + ( version + Math.random() ).replace( \/\\D\/g, \"\" ),\n-\n-\t\/\/ Assume jQuery is ready without the ready module\n-\tisReady: true,\n-\n-\terror: function( msg ) {\n-\t\tthrow new Error( msg );\n-\t},\n-\n-\tnoop: function() {},\n-\n-\tisPlainObject: function( obj ) {\n-\t\tvar proto, Ctor;\n-\n-\t\t\/\/ Detect obvious negatives\n-\t\t\/\/ Use toString instead of jQuery.type to catch host objects\n-\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tproto = getProto( obj );\n-\n-\t\t\/\/ Objects with no prototype (e.g., `Object.create( null )`) are plain\n-\t\tif ( !proto ) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\t\/\/ Objects with prototype are plain iff they were constructed by a global Object function\n-\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n-\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n-\t},\n-\n-\tisEmptyObject: function( obj ) {\n-\t\tvar name;\n-\n-\t\tfor ( name in obj ) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t},\n-\n-\t\/\/ Evaluates a script in a provided context; falls back to the global one\n-\t\/\/ if not specified.\n-\tglobalEval: function( code, options, doc ) {\n-\t\tDOMEval( code, { nonce: options && options.nonce }, doc );\n-\t},\n-\n-\teach: function( obj, callback ) {\n-\t\tvar length, i = 0;\n-\n-\t\tif ( isArrayLike( obj ) ) {\n-\t\t\tlength = obj.length;\n-\t\t\tfor ( ; i < length; i++ ) {\n-\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tfor ( i in obj ) {\n-\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn obj;\n-\t},\n-\n-\t\/\/ results is for internal usage only\n-\tmakeArray: function( arr, results ) {\n-\t\tvar ret = results || [];\n-\n-\t\tif ( arr != null ) {\n-\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n-\t\t\t\tjQuery.merge( ret,\n-\t\t\t\t\ttypeof arr === \"string\" ?\n-\t\t\t\t\t\t[ arr ] : arr\n-\t\t\t\t);\n-\t\t\t} else {\n-\t\t\t\tpush.call( ret, arr );\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn ret;\n-\t},\n-\n-\tinArray: function( elem, arr, i ) {\n-\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n-\t},\n-\n-\t\/\/ Support: Android <=4.0 only, PhantomJS 1 only\n-\t\/\/ push.apply(_, arraylike) throws on ancient WebKit\n-\tmerge: function( first, second ) {\n-\t\tvar len = +second.length,\n-\t\t\tj = 0,\n-\t\t\ti = first.length;\n-\n-\t\tfor ( ; j < len; j++ ) {\n-\t\t\tfirst[ i++ ] = second[ j ];\n-\t\t}\n-\n-\t\tfirst.length = i;\n-\n-\t\treturn first;\n-\t},\n-\n-\tgrep: function( elems, callback, invert ) {\n-\t\tvar callbackInverse,\n-\t\t\tmatches = [],\n-\t\t\ti = 0,\n-\t\t\tlength = elems.length,\n-\t\t\tcallbackExpect = !invert;\n-\n-\t\t\/\/ Go through the array, only saving the items\n-\t\t\/\/ that pass the validator function\n-\t\tfor ( ; i < length; i++ ) {\n-\t\t\tcallbackInverse = !callback( elems[ i ], i );\n-\t\t\tif ( callbackInverse !== callbackExpect ) {\n-\t\t\t\tmatches.push( elems[ i ] );\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn matches;\n-\t},\n-\n-\t\/\/ arg is for internal usage only\n-\tmap: function( elems, callback, arg ) {\n-\t\tvar length, value,\n-\t\t\ti = 0,\n-\t\t\tret = [];\n-\n-\t\t\/\/ Go through the array, translating each of the items to their new values\n-\t\tif ( isArrayLike( elems ) ) {\n-\t\t\tlength = elems.length;\n-\t\t\tfor ( ; i < length; i++ ) {\n-\t\t\t\tvalue = callback( elems[ i ], i, arg );\n-\n-\t\t\t\tif ( value != null ) {\n-\t\t\t\t\tret.push( value );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\/\/ Go through every key on the object,\n-\t\t} else {\n-\t\t\tfor ( i in elems ) {\n-\t\t\t\tvalue = callback( elems[ i ], i, arg );\n-\n-\t\t\t\tif ( value != null ) {\n-\t\t\t\t\tret.push( value );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Flatten any nested arrays\n-\t\treturn flat( ret );\n-\t},\n-\n-\t\/\/ A global GUID counter for objects\n-\tguid: 1,\n-\n-\t\/\/ jQuery.support is not used in Core but other projects attach their\n-\t\/\/ properties to it so it needs to exist.\n-\tsupport: support\n-} );\n-\n-if ( typeof Symbol === \"function\" ) {\n-\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n-}\n-\n-\/\/ Populate the class2type map\n-jQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n-\tfunction( _i, name ) {\n-\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n-\t} );\n-\n-function isArrayLike( obj ) {\n-\n-\t\/\/ Support: real iOS 8.2 only (not reproducible in simulator)\n-\t\/\/ `in` check used to prevent JIT error (gh-2145)\n-\t\/\/ hasOwn isn't used here due to false negatives\n-\t\/\/ regarding Nodelist length in IE\n-\tvar length = !!obj && \"length\" in obj && obj.length,\n-\t\ttype = toType( obj );\n-\n-\tif ( isFunction( obj ) || isWindow( obj ) ) {\n-\t\treturn false;\n-\t}\n-\n-\treturn type === \"array\" || length === 0 ||\n-\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n-}\n-var Sizzle =\n-\/*!\n- * Sizzle CSS Selector Engine v2.3.6\n- * https:\/\/sizzlejs.com\/\n- *\n- * Copyright JS Foundation and other contributors\n- * Released under the MIT license\n- * https:\/\/js.foundation\/\n- *\n- * Date: 2021-02-16\n- *\/\n-( function( window ) {\n-var i,\n-\tsupport,\n-\tExpr,\n-\tgetText,\n-\tisXML,\n-\ttokenize,\n-\tcompile,\n-\tselect,\n-\toutermostContext,\n-\tsortInput,\n-\thasDuplicate,\n-\n-\t\/\/ Local document vars\n-\tsetDocument,\n-\tdocument,\n-\tdocElem,\n-\tdocumentIsHTML,\n-\trbuggyQSA,\n-\trbuggyMatches,\n-\tmatches,\n-\tcontains,\n-\n-\t\/\/ Instance-specific data\n-\texpando = \"sizzle\" + 1 * new Date(),\n-\tpreferredDoc = window.document,\n-\tdirruns = 0,\n-\tdone = 0,\n-\tclassCache = createCache(),\n-\ttokenCache = createCache(),\n-\tcompilerCache = createCache(),\n-\tnonnativeSelectorCache = createCache(),\n-\tsortOrder = function( a, b ) {\n-\t\tif ( a === b ) {\n-\t\t\thasDuplicate = true;\n-\t\t}\n-\t\treturn 0;\n-\t},\n-\n-\t\/\/ Instance methods\n-\thasOwn = ( {} ).hasOwnProperty,\n-\tarr = [],\n-\tpop = arr.pop,\n-\tpushNative = arr.push,\n-\tpush = arr.push,\n-\tslice = arr.slice,\n-\n-\t\/\/ Use a stripped-down indexOf as it's faster than native\n-\t\/\/ https:\/\/jsperf.com\/thor-indexof-vs-for\/5\n-\tindexOf = function( list, elem ) {\n-\t\tvar i = 0,\n-\t\t\tlen = list.length;\n-\t\tfor ( ; i < len; i++ ) {\n-\t\t\tif ( list[ i ] === elem ) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\treturn -1;\n-\t},\n-\n-\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" +\n-\t\t\"ismap|loop|multiple|open|readonly|required|scoped\",\n-\n-\t\/\/ Regular expressions\n-\n-\t\/\/ http:\/\/www.w3.org\/TR\/css3-selectors\/#whitespace\n-\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n-\n-\t\/\/ https:\/\/www.w3.org\/TR\/css-syntax-3\/#ident-token-diagram\n-\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n-\t\t\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n-\n-\t\/\/ Attribute selectors: http:\/\/www.w3.org\/TR\/selectors\/#attribute-selectors\n-\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n-\n-\t\t\/\/ Operator (capture 2)\n-\t\t\"*([*^$|!~]?=)\" + whitespace +\n-\n-\t\t\/\/ \"Attribute values must be CSS identifiers [capture 5]\n-\t\t\/\/ or strings [capture 3 or capture 4]\"\n-\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" +\n-\t\twhitespace + \"*\\\\]\",\n-\n-\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n-\n-\t\t\/\/ To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n-\t\t\/\/ 1. quoted (capture 3; capture 4 or capture 5)\n-\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n-\n-\t\t\/\/ 2. simple (capture 6)\n-\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n-\n-\t\t\/\/ 3. anything else (capture 2)\n-\t\t\".*\" +\n-\t\t\")\\\\)|)\",\n-\n-\t\/\/ Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n-\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n-\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" +\n-\t\twhitespace + \"+$\", \"g\" ),\n-\n-\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n-\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace +\n-\t\t\"*\" ),\n-\trdescend = new RegExp( whitespace + \"|>\" ),\n-\n-\trpseudo = new RegExp( pseudos ),\n-\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n-\n-\tmatchExpr = {\n-\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n-\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n-\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n-\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n-\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n-\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n-\t\t\twhitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" +\n-\t\t\twhitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n-\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n-\n-\t\t\/\/ For use in libraries implementing .is()\n-\t\t\/\/ We use this for POS matching in `select`\n-\t\t\"needsContext\": new RegExp( \"^\" + whitespace +\n-\t\t\t\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace +\n-\t\t\t\"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n-\t},\n-\n-\trhtml = \/HTML$\/i,\n-\trinputs = \/^(?:input|select|textarea|button)$\/i,\n-\trheader = \/^h\\d$\/i,\n-\n-\trnative = \/^[^{]+\\{\\s*\\[native \\w\/,\n-\n-\t\/\/ Easily-parseable\/retrievable ID or TAG or CLASS selectors\n-\trquickExpr = \/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$\/,\n-\n-\trsibling = \/[+~]\/,\n-\n-\t\/\/ CSS escapes\n-\t\/\/ http:\/\/www.w3.org\/TR\/CSS21\/syndata.html#escaped-characters\n-\trunescape = new RegExp( \"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\" ),\n-\tfunescape = function( escape, nonHex ) {\n-\t\tvar high = \"0x\" + escape.slice( 1 ) - 0x10000;\n-\n-\t\treturn nonHex ?\n-\n-\t\t\t\/\/ Strip the backslash prefix from a non-hex escape sequence\n-\t\t\tnonHex :\n-\n-\t\t\t\/\/ Replace a hexadecimal escape sequence with the encoded Unicode code point\n-\t\t\t\/\/ Support: IE <=11+\n-\t\t\t\/\/ For values outside the Basic Multilingual Plane (BMP), manually construct a\n-\t\t\t\/\/ surrogate pair\n-\t\t\thigh < 0 ?\n-\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n-\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n-\t},\n-\n-\t\/\/ CSS string\/identifier serialization\n-\t\/\/ https:\/\/drafts.csswg.org\/cssom\/#common-serializing-idioms\n-\trcssescape = \/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]\/g,\n-\tfcssescape = function( ch, asCodePoint ) {\n-\t\tif ( asCodePoint ) {\n-\n-\t\t\t\/\/ U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n-\t\t\tif ( ch === \"\\0\" ) {\n-\t\t\t\treturn \"\\uFFFD\";\n-\t\t\t}\n-\n-\t\t\t\/\/ Control characters and (dependent upon position) numbers get escaped as code points\n-\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" +\n-\t\t\t\tch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n-\t\t}\n-\n-\t\t\/\/ Other potentially-special ASCII characters get backslash-escaped\n-\t\treturn \"\\\\\" + ch;\n-\t},\n-\n-\t\/\/ Used for iframes\n-\t\/\/ See setDocument()\n-\t\/\/ Removing the function wrapper causes a \"Permission Denied\"\n-\t\/\/ error in IE\n-\tunloadHandler = function() {\n-\t\tsetDocument();\n-\t},\n-\n-\tinDisabledFieldset = addCombinator(\n-\t\tfunction( elem ) {\n-\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n-\t\t},\n-\t\t{ dir: \"parentNode\", next: \"legend\" }\n-\t);\n-\n-\/\/ Optimize for push.apply( _, NodeList )\n-try {\n-\tpush.apply(\n-\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n-\t\tpreferredDoc.childNodes\n-\t);\n-\n-\t\/\/ Support: Android<4.0\n-\t\/\/ Detect silently failing push.apply\n-\t\/\/ eslint-disable-next-line no-unused-expressions\n-\tarr[ preferredDoc.childNodes.length ].nodeType;\n-} catch ( e ) {\n-\tpush = { apply: arr.length ?\n-\n-\t\t\/\/ Leverage slice if possible\n-\t\tfunction( target, els ) {\n-\t\t\tpushNative.apply( target, slice.call( els ) );\n-\t\t} :\n-\n-\t\t\/\/ Support: IE<9\n-\t\t\/\/ Otherwise append directly\n-\t\tfunction( target, els ) {\n-\t\t\tvar j = target.length,\n-\t\t\t\ti = 0;\n-\n-\t\t\t\/\/ Can't trust NodeList.length\n-\t\t\twhile ( ( target[ j++ ] = els[ i++ ] ) ) {}\n-\t\t\ttarget.length = j - 1;\n-\t\t}\n-\t};\n-}\n-\n-function Sizzle( selector, context, results, seed ) {\n-\tvar m, i, elem, nid, match, groups, newSelector,\n-\t\tnewContext = context && context.ownerDocument,\n-\n-\t\t\/\/ nodeType defaults to 9, since context defaults to document\n-\t\tnodeType = context ? context.nodeType : 9;\n-\n-\tresults = results || [];\n-\n-\t\/\/ Return early from calls with invalid selector or context\n-\tif ( typeof selector !== \"string\" || !selector ||\n-\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n-\n-\t\treturn results;\n-\t}\n-\n-\t\/\/ Try to shortcut find operations (as opposed to filters) in HTML documents\n-\tif ( !seed ) {\n-\t\tsetDocument( context );\n-\t\tcontext = context || document;\n-\n-\t\tif ( documentIsHTML ) {\n-\n-\t\t\t\/\/ If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n-\t\t\t\/\/ (excepting DocumentFragment context, where the methods don't exist)\n-\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n-\n-\t\t\t\t\/\/ ID selector\n-\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n-\n-\t\t\t\t\t\/\/ Document context\n-\t\t\t\t\tif ( nodeType === 9 ) {\n-\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n-\n-\t\t\t\t\t\t\t\/\/ Support: IE, Opera, Webkit\n-\t\t\t\t\t\t\t\/\/ TODO: identify versions\n-\t\t\t\t\t\t\t\/\/ getElementById can match elements by name instead of ID\n-\t\t\t\t\t\t\tif ( elem.id === m ) {\n-\t\t\t\t\t\t\t\tresults.push( elem );\n-\t\t\t\t\t\t\t\treturn results;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\treturn results;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\/\/ Element context\n-\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\/\/ Support: IE, Opera, Webkit\n-\t\t\t\t\t\t\/\/ TODO: identify versions\n-\t\t\t\t\t\t\/\/ getElementById can match elements by name instead of ID\n-\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n-\t\t\t\t\t\t\tcontains( context, elem ) &&\n-\t\t\t\t\t\t\telem.id === m ) {\n-\n-\t\t\t\t\t\t\tresults.push( elem );\n-\t\t\t\t\t\t\treturn results;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\/\/ Type selector\n-\t\t\t\t} else if ( match[ 2 ] ) {\n-\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n-\t\t\t\t\treturn results;\n-\n-\t\t\t\t\/\/ Class selector\n-\t\t\t\t} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&\n-\t\t\t\t\tcontext.getElementsByClassName ) {\n-\n-\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n-\t\t\t\t\treturn results;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t\/\/ Take advantage of querySelectorAll\n-\t\t\tif ( support.qsa &&\n-\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n-\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&\n-\n-\t\t\t\t\/\/ Support: IE 8 only\n-\t\t\t\t\/\/ Exclude object elements\n-\t\t\t\t( nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\" ) ) {\n-\n-\t\t\t\tnewSelector = selector;\n-\t\t\t\tnewContext = context;\n-\n-\t\t\t\t\/\/ qSA considers elements outside a scoping root when evaluating child or\n-\t\t\t\t\/\/ descendant combinators, which is not what we want.\n-\t\t\t\t\/\/ In such cases, we work around the behavior by prefixing every selector in the\n-\t\t\t\t\/\/ list with an ID selector referencing the scope context.\n-\t\t\t\t\/\/ The technique has to be used as well when a leading combinator is used\n-\t\t\t\t\/\/ as such selectors are not recognized by querySelectorAll.\n-\t\t\t\t\/\/ Thanks to Andrew Dupont for this technique.\n-\t\t\t\tif ( nodeType === 1 &&\n-\t\t\t\t\t( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {\n-\n-\t\t\t\t\t\/\/ Expand context for sibling selectors\n-\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n-\t\t\t\t\t\tcontext;\n-\n-\t\t\t\t\t\/\/ We can use :scope instead of the ID hack if the browser\n-\t\t\t\t\t\/\/ supports it & if we're not changing the context.\n-\t\t\t\t\tif ( newContext !== context || !support.scope ) {\n-\n-\t\t\t\t\t\t\/\/ Capture the context ID, setting it first if necessary\n-\t\t\t\t\t\tif ( ( nid = context.getAttribute( \"id\" ) ) ) {\n-\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tcontext.setAttribute( \"id\", ( nid = expando ) );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t\/\/ Prefix every selector in the list\n-\t\t\t\t\tgroups = tokenize( selector );\n-\t\t\t\t\ti = groups.length;\n-\t\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\t\tgroups[ i ] = ( nid ? \"#\" + nid : \":scope\" ) + \" \" +\n-\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n-\t\t\t\t\t}\n-\t\t\t\t\tnewSelector = groups.join( \",\" );\n-\t\t\t\t}\n-\n-\t\t\t\ttry {\n-\t\t\t\t\tpush.apply( results,\n-\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n-\t\t\t\t\t);\n-\t\t\t\t\treturn results;\n-\t\t\t\t} catch ( qsaError ) {\n-\t\t\t\t\tnonnativeSelectorCache( selector, true );\n-\t\t\t\t} finally {\n-\t\t\t\t\tif ( nid === expando ) {\n-\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t\/\/ All others\n-\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n-}\n-\n-\/**\n- * Create key-value caches of limited size\n- * @returns {function(string, object)} Returns the Object data after storing it on itself with\n- *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n- *\tdeleting the oldest entry\n- *\/\n-function createCache() {\n-\tvar keys = [];\n-\n-\tfunction cache( key, value ) {\n-\n-\t\t\/\/ Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n-\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n-\n-\t\t\t\/\/ Only keep the most recent entries\n-\t\t\tdelete cache[ keys.shift() ];\n-\t\t}\n-\t\treturn ( cache[ key + \" \" ] = value );\n-\t}\n-\treturn cache;\n-}\n-\n-\/**\n- * Mark a function for special use by Sizzle\n- * @param {Function} fn The function to mark\n- *\/\n-function markFunction( fn ) {\n-\tfn[ expando ] = true;\n-\treturn fn;\n-}\n-\n-\/**\n- * Support testing using an element\n- * @param {Function} fn Passed the created element and returns a boolean result\n- *\/\n-function assert( fn ) {\n-\tvar el = document.createElement( \"fieldset\" );\n-\n-\ttry {\n-\t\treturn !!fn( el );\n-\t} catch ( e ) {\n-\t\treturn false;\n-\t} finally {\n-\n-\t\t\/\/ Remove from its parent by default\n-\t\tif ( el.parentNode ) {\n-\t\t\tel.parentNode.removeChild( el );\n-\t\t}\n-\n-\t\t\/\/ release memory in IE\n-\t\tel = null;\n-\t}\n-}\n-\n-\/**\n- * Adds the same handler for all of the specified attrs\n- * @param {String} attrs Pipe-separated list of attributes\n- * @param {Function} handler The method that will be applied\n- *\/\n-function addHandle( attrs, handler ) {\n-\tvar arr = attrs.split( \"|\" ),\n-\t\ti = arr.length;\n-\n-\twhile ( i-- ) {\n-\t\tExpr.attrHandle[ arr[ i ] ] = handler;\n-\t}\n-}\n-\n-\/**\n- * Checks document order of two siblings\n- * @param {Element} a\n- * @param {Element} b\n- * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n- *\/\n-function siblingCheck( a, b ) {\n-\tvar cur = b && a,\n-\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n-\t\t\ta.sourceIndex - b.sourceIndex;\n-\n-\t\/\/ Use IE sourceIndex if available on both nodes\n-\tif ( diff ) {\n-\t\treturn diff;\n-\t}\n-\n-\t\/\/ Check if b follows a\n-\tif ( cur ) {\n-\t\twhile ( ( cur = cur.nextSibling ) ) {\n-\t\t\tif ( cur === b ) {\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn a ? 1 : -1;\n-}\n-\n-\/**\n- * Returns a function to use in pseudos for input types\n- * @param {String} type\n- *\/\n-function createInputPseudo( type ) {\n-\treturn function( elem ) {\n-\t\tvar name = elem.nodeName.toLowerCase();\n-\t\treturn name === \"input\" && elem.type === type;\n-\t};\n-}\n-\n-\/**\n- * Returns a function to use in pseudos for buttons\n- * @param {String} type\n- *\/\n-function createButtonPseudo( type ) {\n-\treturn function( elem ) {\n-\t\tvar name = elem.nodeName.toLowerCase();\n-\t\treturn ( name === \"input\" || name === \"button\" ) && elem.type === type;\n-\t};\n-}\n-\n-\/**\n- * Returns a function to use in pseudos for :enabled\/:disabled\n- * @param {Boolean} disabled true for :disabled; false for :enabled\n- *\/\n-function createDisabledPseudo( disabled ) {\n-\n-\t\/\/ Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n-\treturn function( elem ) {\n-\n-\t\t\/\/ Only certain elements can match :enabled or :disabled\n-\t\t\/\/ https:\/\/html.spec.whatwg.org\/multipage\/scripting.html#selector-enabled\n-\t\t\/\/ https:\/\/html.spec.whatwg.org\/multipage\/scripting.html#selector-disabled\n-\t\tif ( \"form\" in elem ) {\n-\n-\t\t\t\/\/ Check for inherited disabledness on relevant non-disabled elements:\n-\t\t\t\/\/ * listed form-associated elements in a disabled fieldset\n-\t\t\t\/\/   https:\/\/html.spec.whatwg.org\/multipage\/forms.html#category-listed\n-\t\t\t\/\/   https:\/\/html.spec.whatwg.org\/multipage\/forms.html#concept-fe-disabled\n-\t\t\t\/\/ * option elements in a disabled optgroup\n-\t\t\t\/\/   https:\/\/html.spec.whatwg.org\/multipage\/forms.html#concept-option-disabled\n-\t\t\t\/\/ All such elements have a \"form\" property.\n-\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n-\n-\t\t\t\t\/\/ Option elements defer to a parent optgroup if present\n-\t\t\t\tif ( \"label\" in elem ) {\n-\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n-\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treturn elem.disabled === disabled;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Support: IE 6 - 11\n-\t\t\t\t\/\/ Use the isDisabled shortcut property to check for disabled fieldset ancestors\n-\t\t\t\treturn elem.isDisabled === disabled ||\n-\n-\t\t\t\t\t\/\/ Where there is no isDisabled, check manually\n-\t\t\t\t\t\/* jshint -W018 *\/\n-\t\t\t\t\telem.isDisabled !== !disabled &&\n-\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n-\t\t\t}\n-\n-\t\t\treturn elem.disabled === disabled;\n-\n-\t\t\/\/ Try to winnow out elements that can't be disabled before trusting the disabled property.\n-\t\t\/\/ Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n-\t\t\/\/ even exist on them, let alone have a boolean value.\n-\t\t} else if ( \"label\" in elem ) {\n-\t\t\treturn elem.disabled === disabled;\n-\t\t}\n-\n-\t\t\/\/ Remaining elements are neither :enabled nor :disabled\n-\t\treturn false;\n-\t};\n-}\n-\n-\/**\n- * Returns a function to use in pseudos for positionals\n- * @param {Function} fn\n- *\/\n-function createPositionalPseudo( fn ) {\n-\treturn markFunction( function( argument ) {\n-\t\targument = +argument;\n-\t\treturn markFunction( function( seed, matches ) {\n-\t\t\tvar j,\n-\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n-\t\t\t\ti = matchIndexes.length;\n-\n-\t\t\t\/\/ Match elements found at the specified indexes\n-\t\t\twhile ( i-- ) {\n-\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n-\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} );\n-\t} );\n-}\n-\n-\/**\n- * Checks a node for validity as a Sizzle context\n- * @param {Element|Object=} context\n- * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n- *\/\n-function testContext( context ) {\n-\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n-}\n-\n-\/\/ Expose support vars for convenience\n-support = Sizzle.support = {};\n-\n-\/**\n- * Detects XML nodes\n- * @param {Element|Object} elem An element or a document\n- * @returns {Boolean} True iff elem is a non-HTML XML node\n- *\/\n-isXML = Sizzle.isXML = function( elem ) {\n-\tvar namespace = elem && elem.namespaceURI,\n-\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n-\n-\t\/\/ Support: IE <=8\n-\t\/\/ Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n-\t\/\/ https:\/\/bugs.jquery.com\/ticket\/4833\n-\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n-};\n-\n-\/**\n- * Sets document-related variables once based on the current document\n- * @param {Element|Object} [doc] An element or document object to use to set the document\n- * @returns {Object} Returns the current document\n- *\/\n-setDocument = Sizzle.setDocument = function( node ) {\n-\tvar hasCompare, subWindow,\n-\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n-\n-\t\/\/ Return early if doc is invalid or already selected\n-\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\/\/ two documents; shallow comparisons work.\n-\t\/\/ eslint-disable-next-line eqeqeq\n-\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n-\t\treturn document;\n-\t}\n-\n-\t\/\/ Update global variables\n-\tdocument = doc;\n-\tdocElem = document.documentElement;\n-\tdocumentIsHTML = !isXML( document );\n-\n-\t\/\/ Support: IE 9 - 11+, Edge 12 - 18+\n-\t\/\/ Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n-\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\/\/ two documents; shallow comparisons work.\n-\t\/\/ eslint-disable-next-line eqeqeq\n-\tif ( preferredDoc != document &&\n-\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n-\n-\t\t\/\/ Support: IE 11, Edge\n-\t\tif ( subWindow.addEventListener ) {\n-\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n-\n-\t\t\/\/ Support: IE 9 - 10 only\n-\t\t} else if ( subWindow.attachEvent ) {\n-\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n-\t\t}\n-\t}\n-\n-\t\/\/ Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n-\t\/\/ Safari 4 - 5 only, Opera <=11.6 - 12.x only\n-\t\/\/ IE\/Edge & older browsers don't support the :scope pseudo-class.\n-\t\/\/ Support: Safari 6.0 only\n-\t\/\/ Safari 6.0 supports :scope but it's an alias of :root there.\n-\tsupport.scope = assert( function( el ) {\n-\t\tdocElem.appendChild( el ).appendChild( document.createElement( \"div\" ) );\n-\t\treturn typeof el.querySelectorAll !== \"undefined\" &&\n-\t\t\t!el.querySelectorAll( \":scope fieldset div\" ).length;\n-\t} );\n-\n-\t\/* Attributes\n-\t---------------------------------------------------------------------- *\/\n-\n-\t\/\/ Support: IE<8\n-\t\/\/ Verify that getAttribute really returns attributes and not properties\n-\t\/\/ (excepting IE8 booleans)\n-\tsupport.attributes = assert( function( el ) {\n-\t\tel.className = \"i\";\n-\t\treturn !el.getAttribute( \"className\" );\n-\t} );\n-\n-\t\/* getElement(s)By*\n-\t---------------------------------------------------------------------- *\/\n-\n-\t\/\/ Check if getElementsByTagName(\"*\") returns only elements\n-\tsupport.getElementsByTagName = assert( function( el ) {\n-\t\tel.appendChild( document.createComment( \"\" ) );\n-\t\treturn !el.getElementsByTagName( \"*\" ).length;\n-\t} );\n-\n-\t\/\/ Support: IE<9\n-\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n-\n-\t\/\/ Support: IE<10\n-\t\/\/ Check if getElementById returns elements by name\n-\t\/\/ The broken getElementById methods don't pick up programmatically-set names,\n-\t\/\/ so use a roundabout getElementsByName test\n-\tsupport.getById = assert( function( el ) {\n-\t\tdocElem.appendChild( el ).id = expando;\n-\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n-\t} );\n-\n-\t\/\/ ID filter and find\n-\tif ( support.getById ) {\n-\t\tExpr.filter[ \"ID\" ] = function( id ) {\n-\t\t\tvar attrId = id.replace( runescape, funescape );\n-\t\t\treturn function( elem ) {\n-\t\t\t\treturn elem.getAttribute( \"id\" ) === attrId;\n-\t\t\t};\n-\t\t};\n-\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n-\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n-\t\t\t\tvar elem = context.getElementById( id );\n-\t\t\t\treturn elem ? [ elem ] : [];\n-\t\t\t}\n-\t\t};\n-\t} else {\n-\t\tExpr.filter[ \"ID\" ] =  function( id ) {\n-\t\t\tvar attrId = id.replace( runescape, funescape );\n-\t\t\treturn function( elem ) {\n-\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n-\t\t\t\t\telem.getAttributeNode( \"id\" );\n-\t\t\t\treturn node && node.value === attrId;\n-\t\t\t};\n-\t\t};\n-\n-\t\t\/\/ Support: IE 6 - 7 only\n-\t\t\/\/ getElementById is not reliable as a find shortcut\n-\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n-\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n-\t\t\t\tvar node, i, elems,\n-\t\t\t\t\telem = context.getElementById( id );\n-\n-\t\t\t\tif ( elem ) {\n-\n-\t\t\t\t\t\/\/ Verify the id attribute\n-\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n-\t\t\t\t\tif ( node && node.value === id ) {\n-\t\t\t\t\t\treturn [ elem ];\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t\/\/ Fall back on getElementsByName\n-\t\t\t\t\telems = context.getElementsByName( id );\n-\t\t\t\t\ti = 0;\n-\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n-\t\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n-\t\t\t\t\t\tif ( node && node.value === id ) {\n-\t\t\t\t\t\t\treturn [ elem ];\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\treturn [];\n-\t\t\t}\n-\t\t};\n-\t}\n-\n-\t\/\/ Tag\n-\tExpr.find[ \"TAG\" ] = support.getElementsByTagName ?\n-\t\tfunction( tag, context ) {\n-\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n-\t\t\t\treturn context.getElementsByTagName( tag );\n-\n-\t\t\t\/\/ DocumentFragment nodes don't have gEBTN\n-\t\t\t} else if ( support.qsa ) {\n-\t\t\t\treturn context.querySelectorAll( tag );\n-\t\t\t}\n-\t\t} :\n-\n-\t\tfunction( tag, context ) {\n-\t\t\tvar elem,\n-\t\t\t\ttmp = [],\n-\t\t\t\ti = 0,\n-\n-\t\t\t\t\/\/ By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n-\t\t\t\tresults = context.getElementsByTagName( tag );\n-\n-\t\t\t\/\/ Filter out possible comments\n-\t\t\tif ( tag === \"*\" ) {\n-\t\t\t\twhile ( ( elem = results[ i++ ] ) ) {\n-\t\t\t\t\tif ( elem.nodeType === 1 ) {\n-\t\t\t\t\t\ttmp.push( elem );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\treturn tmp;\n-\t\t\t}\n-\t\t\treturn results;\n-\t\t};\n-\n-\t\/\/ Class\n-\tExpr.find[ \"CLASS\" ] = support.getElementsByClassName && function( className, context ) {\n-\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n-\t\t\treturn context.getElementsByClassName( className );\n-\t\t}\n-\t};\n-\n-\t\/* QSA\/matchesSelector\n-\t---------------------------------------------------------------------- *\/\n-\n-\t\/\/ QSA and matchesSelector support\n-\n-\t\/\/ matchesSelector(:active) reports false when true (IE9\/Opera 11.5)\n-\trbuggyMatches = [];\n-\n-\t\/\/ qSa(:focus) reports false when true (Chrome 21)\n-\t\/\/ We allow this because of a bug in IE8\/9 that throws an error\n-\t\/\/ whenever `document.activeElement` is accessed on an iframe\n-\t\/\/ So, we allow :focus to pass through QSA all the time to avoid the IE error\n-\t\/\/ See https:\/\/bugs.jquery.com\/ticket\/13378\n-\trbuggyQSA = [];\n-\n-\tif ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {\n-\n-\t\t\/\/ Build QSA regex\n-\t\t\/\/ Regex strategy adopted from Diego Perini\n-\t\tassert( function( el ) {\n-\n-\t\t\tvar input;\n-\n-\t\t\t\/\/ Select is set to empty string on purpose\n-\t\t\t\/\/ This is to test IE's treatment of not explicitly\n-\t\t\t\/\/ setting a boolean content attribute,\n-\t\t\t\/\/ since its presence should be enough\n-\t\t\t\/\/ https:\/\/bugs.jquery.com\/ticket\/12359\n-\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'><\/a>\" +\n-\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n-\t\t\t\t\"<option selected=''><\/option><\/select>\";\n-\n-\t\t\t\/\/ Support: IE8, Opera 11-12.16\n-\t\t\t\/\/ Nothing should be selected when empty strings follow ^= or $= or *=\n-\t\t\t\/\/ The test attribute must be unknown in Opera but \"safe\" for WinRT\n-\t\t\t\/\/ https:\/\/msdn.microsoft.com\/en-us\/library\/ie\/hh465388.aspx#attribute_section\n-\t\t\tif ( el.querySelectorAll( \"[msallowcapture^='']\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ Support: IE8\n-\t\t\t\/\/ Boolean attributes and \"value\" are not treated correctly\n-\t\t\tif ( !el.querySelectorAll( \"[selected]\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n-\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \"~=\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ Support: IE 11+, Edge 15 - 18+\n-\t\t\t\/\/ IE 11\/Edge don't find elements on a `[name='']` query in some cases.\n-\t\t\t\/\/ Adding a temporary attribute to the document before the selection works\n-\t\t\t\/\/ around the issue.\n-\t\t\t\/\/ Interestingly, IE 10 & older don't seem to have the issue.\n-\t\t\tinput = document.createElement( \"input\" );\n-\t\t\tinput.setAttribute( \"name\", \"\" );\n-\t\t\tel.appendChild( input );\n-\t\t\tif ( !el.querySelectorAll( \"[name='']\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" +\n-\t\t\t\t\twhitespace + \"*(?:''|\\\"\\\")\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ Webkit\/Opera - :checked should return selected option elements\n-\t\t\t\/\/ http:\/\/www.w3.org\/TR\/2011\/REC-css3-selectors-20110929\/#checked\n-\t\t\t\/\/ IE8 throws error here and will not see later tests\n-\t\t\tif ( !el.querySelectorAll( \":checked\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \":checked\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ Support: Safari 8+, iOS 8+\n-\t\t\t\/\/ https:\/\/bugs.webkit.org\/show_bug.cgi?id=136851\n-\t\t\t\/\/ In-page `selector#id sibling-combinator selector` fails\n-\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \".#.+[+~]\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ Support: Firefox <=3.6 - 5 only\n-\t\t\t\/\/ Old Firefox doesn't throw on a badly-escaped identifier.\n-\t\t\tel.querySelectorAll( \"\\\\\\f\" );\n-\t\t\trbuggyQSA.push( \"[\\\\r\\\\n\\\\f]\" );\n-\t\t} );\n-\n-\t\tassert( function( el ) {\n-\t\t\tel.innerHTML = \"<a href='' disabled='disabled'><\/a>\" +\n-\t\t\t\t\"<select disabled='disabled'><option\/><\/select>\";\n-\n-\t\t\t\/\/ Support: Windows 8 Native Apps\n-\t\t\t\/\/ The type and name attributes are restricted during .innerHTML assignment\n-\t\t\tvar input = document.createElement( \"input\" );\n-\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n-\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n-\n-\t\t\t\/\/ Support: IE8\n-\t\t\t\/\/ Enforce case-sensitivity of name attribute\n-\t\t\tif ( el.querySelectorAll( \"[name=d]\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ FF 3.5 - :enabled\/:disabled and hidden elements (hidden elements are still enabled)\n-\t\t\t\/\/ IE8 throws error here and will not see later tests\n-\t\t\tif ( el.querySelectorAll( \":enabled\" ).length !== 2 ) {\n-\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ Support: IE9-11+\n-\t\t\t\/\/ IE's :disabled selector does not pick up the children of disabled fieldsets\n-\t\t\tdocElem.appendChild( el ).disabled = true;\n-\t\t\tif ( el.querySelectorAll( \":disabled\" ).length !== 2 ) {\n-\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ Support: Opera 10 - 11 only\n-\t\t\t\/\/ Opera 10-11 does not throw on post-comma invalid pseudos\n-\t\t\tel.querySelectorAll( \"*,:x\" );\n-\t\t\trbuggyQSA.push( \",.*:\" );\n-\t\t} );\n-\t}\n-\n-\tif ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||\n-\t\tdocElem.webkitMatchesSelector ||\n-\t\tdocElem.mozMatchesSelector ||\n-\t\tdocElem.oMatchesSelector ||\n-\t\tdocElem.msMatchesSelector ) ) ) ) {\n-\n-\t\tassert( function( el ) {\n-\n-\t\t\t\/\/ Check to see if it's possible to do matchesSelector\n-\t\t\t\/\/ on a disconnected node (IE 9)\n-\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n-\n-\t\t\t\/\/ This should fail with an exception\n-\t\t\t\/\/ Gecko does not error, returns false instead\n-\t\t\tmatches.call( el, \"[s!='']:x\" );\n-\t\t\trbuggyMatches.push( \"!=\", pseudos );\n-\t\t} );\n-\t}\n-\n-\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \"|\" ) );\n-\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( \"|\" ) );\n-\n-\t\/* Contains\n-\t---------------------------------------------------------------------- *\/\n-\thasCompare = rnative.test( docElem.compareDocumentPosition );\n-\n-\t\/\/ Element contains another\n-\t\/\/ Purposefully self-exclusive\n-\t\/\/ As in, an element does not contain itself\n-\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n-\t\tfunction( a, b ) {\n-\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n-\t\t\t\tbup = b && b.parentNode;\n-\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n-\t\t\t\tadown.contains ?\n-\t\t\t\t\tadown.contains( bup ) :\n-\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n-\t\t\t) );\n-\t\t} :\n-\t\tfunction( a, b ) {\n-\t\t\tif ( b ) {\n-\t\t\t\twhile ( ( b = b.parentNode ) ) {\n-\t\t\t\t\tif ( b === a ) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t};\n-\n-\t\/* Sorting\n-\t---------------------------------------------------------------------- *\/\n-\n-\t\/\/ Document order sorting\n-\tsortOrder = hasCompare ?\n-\tfunction( a, b ) {\n-\n-\t\t\/\/ Flag for duplicate removal\n-\t\tif ( a === b ) {\n-\t\t\thasDuplicate = true;\n-\t\t\treturn 0;\n-\t\t}\n-\n-\t\t\/\/ Sort on method existence if only one input has compareDocumentPosition\n-\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n-\t\tif ( compare ) {\n-\t\t\treturn compare;\n-\t\t}\n-\n-\t\t\/\/ Calculate position if both inputs belong to the same document\n-\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\/\/ two documents; shallow comparisons work.\n-\t\t\/\/ eslint-disable-next-line eqeqeq\n-\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n-\t\t\ta.compareDocumentPosition( b ) :\n-\n-\t\t\t\/\/ Otherwise we know they are disconnected\n-\t\t\t1;\n-\n-\t\t\/\/ Disconnected nodes\n-\t\tif ( compare & 1 ||\n-\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n-\n-\t\t\t\/\/ Choose the first element that is related to our preferred document\n-\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t\/\/ two documents; shallow comparisons work.\n-\t\t\t\/\/ eslint-disable-next-line eqeqeq\n-\t\t\tif ( a == document || a.ownerDocument == preferredDoc &&\n-\t\t\t\tcontains( preferredDoc, a ) ) {\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\n-\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t\/\/ two documents; shallow comparisons work.\n-\t\t\t\/\/ eslint-disable-next-line eqeqeq\n-\t\t\tif ( b == document || b.ownerDocument == preferredDoc &&\n-\t\t\t\tcontains( preferredDoc, b ) ) {\n-\t\t\t\treturn 1;\n-\t\t\t}\n-\n-\t\t\t\/\/ Maintain original order\n-\t\t\treturn sortInput ?\n-\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n-\t\t\t\t0;\n-\t\t}\n-\n-\t\treturn compare & 4 ? -1 : 1;\n-\t} :\n-\tfunction( a, b ) {\n-\n-\t\t\/\/ Exit early if the nodes are identical\n-\t\tif ( a === b ) {\n-\t\t\thasDuplicate = true;\n-\t\t\treturn 0;\n-\t\t}\n-\n-\t\tvar cur,\n-\t\t\ti = 0,\n-\t\t\taup = a.parentNode,\n-\t\t\tbup = b.parentNode,\n-\t\t\tap = [ a ],\n-\t\t\tbp = [ b ];\n-\n-\t\t\/\/ Parentless nodes are either documents or disconnected\n-\t\tif ( !aup || !bup ) {\n-\n-\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t\/\/ two documents; shallow comparisons work.\n-\t\t\t\/* eslint-disable eqeqeq *\/\n-\t\t\treturn a == document ? -1 :\n-\t\t\t\tb == document ? 1 :\n-\t\t\t\t\/* eslint-enable eqeqeq *\/\n-\t\t\t\taup ? -1 :\n-\t\t\t\tbup ? 1 :\n-\t\t\t\tsortInput ?\n-\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n-\t\t\t\t0;\n-\n-\t\t\/\/ If the nodes are siblings, we can do a quick check\n-\t\t} else if ( aup === bup ) {\n-\t\t\treturn siblingCheck( a, b );\n-\t\t}\n-\n-\t\t\/\/ Otherwise we need full lists of their ancestors for comparison\n-\t\tcur = a;\n-\t\twhile ( ( cur = cur.parentNode ) ) {\n-\t\t\tap.unshift( cur );\n-\t\t}\n-\t\tcur = b;\n-\t\twhile ( ( cur = cur.parentNode ) ) {\n-\t\t\tbp.unshift( cur );\n-\t\t}\n-\n-\t\t\/\/ Walk down the tree looking for a discrepancy\n-\t\twhile ( ap[ i ] === bp[ i ] ) {\n-\t\t\ti++;\n-\t\t}\n-\n-\t\treturn i ?\n-\n-\t\t\t\/\/ Do a sibling check if the nodes have a common ancestor\n-\t\t\tsiblingCheck( ap[ i ], bp[ i ] ) :\n-\n-\t\t\t\/\/ Otherwise nodes in our document sort first\n-\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t\/\/ two documents; shallow comparisons work.\n-\t\t\t\/* eslint-disable eqeqeq *\/\n-\t\t\tap[ i ] == preferredDoc ? -1 :\n-\t\t\tbp[ i ] == preferredDoc ? 1 :\n-\t\t\t\/* eslint-enable eqeqeq *\/\n-\t\t\t0;\n-\t};\n-\n-\treturn document;\n-};\n-\n-Sizzle.matches = function( expr, elements ) {\n-\treturn Sizzle( expr, null, null, elements );\n-};\n-\n-Sizzle.matchesSelector = function( elem, expr ) {\n-\tsetDocument( elem );\n-\n-\tif ( support.matchesSelector && documentIsHTML &&\n-\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n-\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n-\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n-\n-\t\ttry {\n-\t\t\tvar ret = matches.call( elem, expr );\n-\n-\t\t\t\/\/ IE 9's matchesSelector returns false on disconnected nodes\n-\t\t\tif ( ret || support.disconnectedMatch ||\n-\n-\t\t\t\t\/\/ As well, disconnected nodes are said to be in a document\n-\t\t\t\t\/\/ fragment in IE 9\n-\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n-\t\t\t\treturn ret;\n-\t\t\t}\n-\t\t} catch ( e ) {\n-\t\t\tnonnativeSelectorCache( expr, true );\n-\t\t}\n-\t}\n-\n-\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n-};\n-\n-Sizzle.contains = function( context, elem ) {\n-\n-\t\/\/ Set document vars if needed\n-\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\/\/ two documents; shallow comparisons work.\n-\t\/\/ eslint-disable-next-line eqeqeq\n-\tif ( ( context.ownerDocument || context ) != document ) {\n-\t\tsetDocument( context );\n-\t}\n-\treturn contains( context, elem );\n-};\n-\n-Sizzle.attr = function( elem, name ) {\n-\n-\t\/\/ Set document vars if needed\n-\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\/\/ two documents; shallow comparisons work.\n-\t\/\/ eslint-disable-next-line eqeqeq\n-\tif ( ( elem.ownerDocument || elem ) != document ) {\n-\t\tsetDocument( elem );\n-\t}\n-\n-\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n-\n-\t\t\/\/ Don't get fooled by Object.prototype properties (jQuery #13807)\n-\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n-\t\t\tfn( elem, name, !documentIsHTML ) :\n-\t\t\tundefined;\n-\n-\treturn val !== undefined ?\n-\t\tval :\n-\t\tsupport.attributes || !documentIsHTML ?\n-\t\t\telem.getAttribute( name ) :\n-\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n-\t\t\t\tval.value :\n-\t\t\t\tnull;\n-};\n-\n-Sizzle.escape = function( sel ) {\n-\treturn ( sel + \"\" ).replace( rcssescape, fcssescape );\n-};\n-\n-Sizzle.error = function( msg ) {\n-\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n-};\n-\n-\/**\n- * Document sorting and removing duplicates\n- * @param {ArrayLike} results\n- *\/\n-Sizzle.uniqueSort = function( results ) {\n-\tvar elem,\n-\t\tduplicates = [],\n-\t\tj = 0,\n-\t\ti = 0;\n-\n-\t\/\/ Unless we *know* we can detect duplicates, assume their presence\n-\thasDuplicate = !support.detectDuplicates;\n-\tsortInput = !support.sortStable && results.slice( 0 );\n-\tresults.sort( sortOrder );\n-\n-\tif ( hasDuplicate ) {\n-\t\twhile ( ( elem = results[ i++ ] ) ) {\n-\t\t\tif ( elem === results[ i ] ) {\n-\t\t\t\tj = duplicates.push( i );\n-\t\t\t}\n-\t\t}\n-\t\twhile ( j-- ) {\n-\t\t\tresults.splice( duplicates[ j ], 1 );\n-\t\t}\n-\t}\n-\n-\t\/\/ Clear input after sorting to release objects\n-\t\/\/ See https:\/\/github.com\/jquery\/sizzle\/pull\/225\n-\tsortInput = null;\n-\n-\treturn results;\n-};\n-\n-\/**\n- * Utility function for retrieving the text value of an array of DOM nodes\n- * @param {Array|Element} elem\n- *\/\n-getText = Sizzle.getText = function( elem ) {\n-\tvar node,\n-\t\tret = \"\",\n-\t\ti = 0,\n-\t\tnodeType = elem.nodeType;\n-\n-\tif ( !nodeType ) {\n-\n-\t\t\/\/ If no nodeType, this is expected to be an array\n-\t\twhile ( ( node = elem[ i++ ] ) ) {\n-\n-\t\t\t\/\/ Do not traverse comment nodes\n-\t\t\tret += getText( node );\n-\t\t}\n-\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n-\n-\t\t\/\/ Use textContent for elements\n-\t\t\/\/ innerText usage removed for consistency of new lines (jQuery #11153)\n-\t\tif ( typeof elem.textContent === \"string\" ) {\n-\t\t\treturn elem.textContent;\n-\t\t} else {\n-\n-\t\t\t\/\/ Traverse its children\n-\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n-\t\t\t\tret += getText( elem );\n-\t\t\t}\n-\t\t}\n-\t} else if ( nodeType === 3 || nodeType === 4 ) {\n-\t\treturn elem.nodeValue;\n-\t}\n-\n-\t\/\/ Do not include comment or processing instruction nodes\n-\n-\treturn ret;\n-};\n-\n-Expr = Sizzle.selectors = {\n-\n-\t\/\/ Can be adjusted by the user\n-\tcacheLength: 50,\n-\n-\tcreatePseudo: markFunction,\n-\n-\tmatch: matchExpr,\n-\n-\tattrHandle: {},\n-\n-\tfind: {},\n-\n-\trelative: {\n-\t\t\">\": { dir: \"parentNode\", first: true },\n-\t\t\" \": { dir: \"parentNode\" },\n-\t\t\"+\": { dir: \"previousSibling\", first: true },\n-\t\t\"~\": { dir: \"previousSibling\" }\n-\t},\n-\n-\tpreFilter: {\n-\t\t\"ATTR\": function( match ) {\n-\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n-\n-\t\t\t\/\/ Move the given value to match[3] whether quoted or unquoted\n-\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] ||\n-\t\t\t\tmatch[ 5 ] || \"\" ).replace( runescape, funescape );\n-\n-\t\t\tif ( match[ 2 ] === \"~=\" ) {\n-\t\t\t\tmatch[ 3 ] = \" \" + match[ 3 ] + \" \";\n-\t\t\t}\n-\n-\t\t\treturn match.slice( 0, 4 );\n-\t\t},\n-\n-\t\t\"CHILD\": function( match ) {\n-\n-\t\t\t\/* matches from matchExpr[\"CHILD\"]\n-\t\t\t\t1 type (only|nth|...)\n-\t\t\t\t2 what (child|of-type)\n-\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n-\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n-\t\t\t\t5 sign of xn-component\n-\t\t\t\t6 x of xn-component\n-\t\t\t\t7 sign of y-component\n-\t\t\t\t8 y of y-component\n-\t\t\t*\/\n-\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n-\n-\t\t\tif ( match[ 1 ].slice( 0, 3 ) === \"nth\" ) {\n-\n-\t\t\t\t\/\/ nth-* requires argument\n-\t\t\t\tif ( !match[ 3 ] ) {\n-\t\t\t\t\tSizzle.error( match[ 0 ] );\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ numeric x and y parameters for Expr.filter.CHILD\n-\t\t\t\t\/\/ remember that false\/true cast respectively to 0\/1\n-\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n-\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n-\t\t\t\t\t2 * ( match[ 3 ] === \"even\" || match[ 3 ] === \"odd\" ) );\n-\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \"odd\" );\n-\n-\t\t\t\t\/\/ other types prohibit arguments\n-\t\t\t} else if ( match[ 3 ] ) {\n-\t\t\t\tSizzle.error( match[ 0 ] );\n-\t\t\t}\n-\n-\t\t\treturn match;\n-\t\t},\n-\n-\t\t\"PSEUDO\": function( match ) {\n-\t\t\tvar excess,\n-\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n-\n-\t\t\tif ( matchExpr[ \"CHILD\" ].test( match[ 0 ] ) ) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\t\/\/ Accept quoted arguments as-is\n-\t\t\tif ( match[ 3 ] ) {\n-\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \"\";\n-\n-\t\t\t\/\/ Strip excess characters from unquoted arguments\n-\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n-\n-\t\t\t\t\/\/ Get excess from tokenize (recursively)\n-\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n-\n-\t\t\t\t\/\/ advance to the next closing parenthesis\n-\t\t\t\t( excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length ) ) {\n-\n-\t\t\t\t\/\/ excess is a negative index\n-\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n-\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n-\t\t\t}\n-\n-\t\t\t\/\/ Return only captures needed by the pseudo filter method (type and argument)\n-\t\t\treturn match.slice( 0, 3 );\n-\t\t}\n-\t},\n-\n-\tfilter: {\n-\n-\t\t\"TAG\": function( nodeNameSelector ) {\n-\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n-\t\t\treturn nodeNameSelector === \"*\" ?\n-\t\t\t\tfunction() {\n-\t\t\t\t\treturn true;\n-\t\t\t\t} :\n-\t\t\t\tfunction( elem ) {\n-\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n-\t\t\t\t};\n-\t\t},\n-\n-\t\t\"CLASS\": function( className ) {\n-\t\t\tvar pattern = classCache[ className + \" \" ];\n-\n-\t\t\treturn pattern ||\n-\t\t\t\t( pattern = new RegExp( \"(^|\" + whitespace +\n-\t\t\t\t\t\")\" + className + \"(\" + whitespace + \"|$)\" ) ) && classCache(\n-\t\t\t\t\t\tclassName, function( elem ) {\n-\t\t\t\t\t\t\treturn pattern.test(\n-\t\t\t\t\t\t\t\ttypeof elem.className === \"string\" && elem.className ||\n-\t\t\t\t\t\t\t\ttypeof elem.getAttribute !== \"undefined\" &&\n-\t\t\t\t\t\t\t\t\telem.getAttribute( \"class\" ) ||\n-\t\t\t\t\t\t\t\t\"\"\n-\t\t\t\t\t\t\t);\n-\t\t\t\t} );\n-\t\t},\n-\n-\t\t\"ATTR\": function( name, operator, check ) {\n-\t\t\treturn function( elem ) {\n-\t\t\t\tvar result = Sizzle.attr( elem, name );\n-\n-\t\t\t\tif ( result == null ) {\n-\t\t\t\t\treturn operator === \"!=\";\n-\t\t\t\t}\n-\t\t\t\tif ( !operator ) {\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\n-\t\t\t\tresult += \"\";\n-\n-\t\t\t\t\/* eslint-disable max-len *\/\n-\n-\t\t\t\treturn operator === \"=\" ? result === check :\n-\t\t\t\t\toperator === \"!=\" ? result !== check :\n-\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n-\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n-\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n-\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n-\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n-\t\t\t\t\tfalse;\n-\t\t\t\t\/* eslint-enable max-len *\/\n-\n-\t\t\t};\n-\t\t},\n-\n-\t\t\"CHILD\": function( type, what, _argument, first, last ) {\n-\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n-\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n-\t\t\t\tofType = what === \"of-type\";\n-\n-\t\t\treturn first === 1 && last === 0 ?\n-\n-\t\t\t\t\/\/ Shortcut for :nth-*(n)\n-\t\t\t\tfunction( elem ) {\n-\t\t\t\t\treturn !!elem.parentNode;\n-\t\t\t\t} :\n-\n-\t\t\t\tfunction( elem, _context, xml ) {\n-\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n-\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n-\t\t\t\t\t\tparent = elem.parentNode,\n-\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n-\t\t\t\t\t\tuseCache = !xml && !ofType,\n-\t\t\t\t\t\tdiff = false;\n-\n-\t\t\t\t\tif ( parent ) {\n-\n-\t\t\t\t\t\t\/\/ :(first|last|only)-(child|of-type)\n-\t\t\t\t\t\tif ( simple ) {\n-\t\t\t\t\t\t\twhile ( dir ) {\n-\t\t\t\t\t\t\t\tnode = elem;\n-\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n-\t\t\t\t\t\t\t\t\tif ( ofType ?\n-\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n-\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n-\n-\t\t\t\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\/\/ Reverse direction for :only-* (if we haven't yet done so)\n-\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n-\n-\t\t\t\t\t\t\/\/ non-xml :nth-child(...) stores cache data on `parent`\n-\t\t\t\t\t\tif ( forward && useCache ) {\n-\n-\t\t\t\t\t\t\t\/\/ Seek `elem` from a previously-cached index\n-\n-\t\t\t\t\t\t\t\/\/ ...in a gzip-friendly way\n-\t\t\t\t\t\t\tnode = parent;\n-\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n-\n-\t\t\t\t\t\t\t\/\/ Support: IE <9 only\n-\t\t\t\t\t\t\t\/\/ Defend against cloned attroperties (jQuery gh-1709)\n-\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n-\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n-\n-\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n-\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n-\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n-\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n-\n-\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n-\n-\t\t\t\t\t\t\t\t\/\/ Fallback to seeking `elem` from the start\n-\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n-\n-\t\t\t\t\t\t\t\t\/\/ When found, cache indexes on `parent` and break\n-\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n-\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t\/\/ Use previously-cached element index if available\n-\t\t\t\t\t\t\tif ( useCache ) {\n-\n-\t\t\t\t\t\t\t\t\/\/ ...in a gzip-friendly way\n-\t\t\t\t\t\t\t\tnode = elem;\n-\t\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n-\n-\t\t\t\t\t\t\t\t\/\/ Support: IE <9 only\n-\t\t\t\t\t\t\t\t\/\/ Defend against cloned attroperties (jQuery gh-1709)\n-\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n-\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n-\n-\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n-\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n-\t\t\t\t\t\t\t\tdiff = nodeIndex;\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\/\/ xml :nth-child(...)\n-\t\t\t\t\t\t\t\/\/ or :nth-last-child(...) or :nth(-last)?-of-type(...)\n-\t\t\t\t\t\t\tif ( diff === false ) {\n-\n-\t\t\t\t\t\t\t\t\/\/ Use the same loop as above to seek `elem` from the start\n-\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n-\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n-\n-\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n-\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n-\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n-\t\t\t\t\t\t\t\t\t\t++diff ) {\n-\n-\t\t\t\t\t\t\t\t\t\t\/\/ Cache the index of each encountered element\n-\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n-\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n-\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n-\n-\t\t\t\t\t\t\t\t\t\t\t\/\/ Support: IE <9 only\n-\t\t\t\t\t\t\t\t\t\t\t\/\/ Defend against cloned attroperties (jQuery gh-1709)\n-\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n-\t\t\t\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n-\n-\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n-\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n-\t\t\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\/\/ Incorporate the offset, then check against cycle size\n-\t\t\t\t\t\tdiff -= last;\n-\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff \/ first >= 0 );\n-\t\t\t\t\t}\n-\t\t\t\t};\n-\t\t},\n-\n-\t\t\"PSEUDO\": function( pseudo, argument ) {\n-\n-\t\t\t\/\/ pseudo-class names are case-insensitive\n-\t\t\t\/\/ http:\/\/www.w3.org\/TR\/selectors\/#pseudo-classes\n-\t\t\t\/\/ Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n-\t\t\t\/\/ Remember that setFilters inherits from pseudos\n-\t\t\tvar args,\n-\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n-\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n-\n-\t\t\t\/\/ The user may use createPseudo to indicate that\n-\t\t\t\/\/ arguments are needed to create the filter function\n-\t\t\t\/\/ just as Sizzle does\n-\t\t\tif ( fn[ expando ] ) {\n-\t\t\t\treturn fn( argument );\n-\t\t\t}\n-\n-\t\t\t\/\/ But maintain support for old signatures\n-\t\t\tif ( fn.length > 1 ) {\n-\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n-\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n-\t\t\t\t\tmarkFunction( function( seed, matches ) {\n-\t\t\t\t\t\tvar idx,\n-\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n-\t\t\t\t\t\t\ti = matched.length;\n-\t\t\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\t\t\tidx = indexOf( seed, matched[ i ] );\n-\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} ) :\n-\t\t\t\t\tfunction( elem ) {\n-\t\t\t\t\t\treturn fn( elem, 0, args );\n-\t\t\t\t\t};\n-\t\t\t}\n-\n-\t\t\treturn fn;\n-\t\t}\n-\t},\n-\n-\tpseudos: {\n-\n-\t\t\/\/ Potentially complex pseudos\n-\t\t\"not\": markFunction( function( selector ) {\n-\n-\t\t\t\/\/ Trim the selector passed to compile\n-\t\t\t\/\/ to avoid treating leading and trailing\n-\t\t\t\/\/ spaces as combinators\n-\t\t\tvar input = [],\n-\t\t\t\tresults = [],\n-\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n-\n-\t\t\treturn matcher[ expando ] ?\n-\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n-\t\t\t\t\tvar elem,\n-\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n-\t\t\t\t\t\ti = seed.length;\n-\n-\t\t\t\t\t\/\/ Match elements unmatched by `matcher`\n-\t\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n-\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} ) :\n-\t\t\t\tfunction( elem, _context, xml ) {\n-\t\t\t\t\tinput[ 0 ] = elem;\n-\t\t\t\t\tmatcher( input, null, xml, results );\n-\n-\t\t\t\t\t\/\/ Don't keep the element (issue #299)\n-\t\t\t\t\tinput[ 0 ] = null;\n-\t\t\t\t\treturn !results.pop();\n-\t\t\t\t};\n-\t\t} ),\n-\n-\t\t\"has\": markFunction( function( selector ) {\n-\t\t\treturn function( elem ) {\n-\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n-\t\t\t};\n-\t\t} ),\n-\n-\t\t\"contains\": markFunction( function( text ) {\n-\t\t\ttext = text.replace( runescape, funescape );\n-\t\t\treturn function( elem ) {\n-\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n-\t\t\t};\n-\t\t} ),\n-\n-\t\t\/\/ \"Whether an element is represented by a :lang() selector\n-\t\t\/\/ is based solely on the element's language value\n-\t\t\/\/ being equal to the identifier C,\n-\t\t\/\/ or beginning with the identifier C immediately followed by \"-\".\n-\t\t\/\/ The matching of C against the element's language value is performed case-insensitively.\n-\t\t\/\/ The identifier C does not have to be a valid language name.\"\n-\t\t\/\/ http:\/\/www.w3.org\/TR\/selectors\/#lang-pseudo\n-\t\t\"lang\": markFunction( function( lang ) {\n-\n-\t\t\t\/\/ lang value must be a valid identifier\n-\t\t\tif ( !ridentifier.test( lang || \"\" ) ) {\n-\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n-\t\t\t}\n-\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n-\t\t\treturn function( elem ) {\n-\t\t\t\tvar elemLang;\n-\t\t\t\tdo {\n-\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n-\t\t\t\t\t\telem.lang :\n-\t\t\t\t\t\telem.getAttribute( \"xml:lang\" ) || elem.getAttribute( \"lang\" ) ) ) {\n-\n-\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n-\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n-\t\t\t\t\t}\n-\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n-\t\t\t\treturn false;\n-\t\t\t};\n-\t\t} ),\n-\n-\t\t\/\/ Miscellaneous\n-\t\t\"target\": function( elem ) {\n-\t\t\tvar hash = window.location && window.location.hash;\n-\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n-\t\t},\n-\n-\t\t\"root\": function( elem ) {\n-\t\t\treturn elem === docElem;\n-\t\t},\n-\n-\t\t\"focus\": function( elem ) {\n-\t\t\treturn elem === document.activeElement &&\n-\t\t\t\t( !document.hasFocus || document.hasFocus() ) &&\n-\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n-\t\t},\n-\n-\t\t\/\/ Boolean properties\n-\t\t\"enabled\": createDisabledPseudo( false ),\n-\t\t\"disabled\": createDisabledPseudo( true ),\n-\n-\t\t\"checked\": function( elem ) {\n-\n-\t\t\t\/\/ In CSS3, :checked should return both checked and selected elements\n-\t\t\t\/\/ http:\/\/www.w3.org\/TR\/2011\/REC-css3-selectors-20110929\/#checked\n-\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n-\t\t\treturn ( nodeName === \"input\" && !!elem.checked ) ||\n-\t\t\t\t( nodeName === \"option\" && !!elem.selected );\n-\t\t},\n-\n-\t\t\"selected\": function( elem ) {\n-\n-\t\t\t\/\/ Accessing this property makes selected-by-default\n-\t\t\t\/\/ options in Safari work properly\n-\t\t\tif ( elem.parentNode ) {\n-\t\t\t\t\/\/ eslint-disable-next-line no-unused-expressions\n-\t\t\t\telem.parentNode.selectedIndex;\n-\t\t\t}\n-\n-\t\t\treturn elem.selected === true;\n-\t\t},\n-\n-\t\t\/\/ Contents\n-\t\t\"empty\": function( elem ) {\n-\n-\t\t\t\/\/ http:\/\/www.w3.org\/TR\/selectors\/#empty-pseudo\n-\t\t\t\/\/ :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n-\t\t\t\/\/   but not by others (comment: 8; processing instruction: 7; etc.)\n-\t\t\t\/\/ nodeType < 6 works because attributes (2) do not appear as children\n-\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n-\t\t\t\tif ( elem.nodeType < 6 ) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn true;\n-\t\t},\n-\n-\t\t\"parent\": function( elem ) {\n-\t\t\treturn !Expr.pseudos[ \"empty\" ]( elem );\n-\t\t},\n-\n-\t\t\/\/ Element\/input types\n-\t\t\"header\": function( elem ) {\n-\t\t\treturn rheader.test( elem.nodeName );\n-\t\t},\n-\n-\t\t\"input\": function( elem ) {\n-\t\t\treturn rinputs.test( elem.nodeName );\n-\t\t},\n-\n-\t\t\"button\": function( elem ) {\n-\t\t\tvar name = elem.nodeName.toLowerCase();\n-\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n-\t\t},\n-\n-\t\t\"text\": function( elem ) {\n-\t\t\tvar attr;\n-\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n-\t\t\t\telem.type === \"text\" &&\n-\n-\t\t\t\t\/\/ Support: IE<8\n-\t\t\t\t\/\/ New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n-\t\t\t\t( ( attr = elem.getAttribute( \"type\" ) ) == null ||\n-\t\t\t\t\tattr.toLowerCase() === \"text\" );\n-\t\t},\n-\n-\t\t\/\/ Position-in-collection\n-\t\t\"first\": createPositionalPseudo( function() {\n-\t\t\treturn [ 0 ];\n-\t\t} ),\n-\n-\t\t\"last\": createPositionalPseudo( function( _matchIndexes, length ) {\n-\t\t\treturn [ length - 1 ];\n-\t\t} ),\n-\n-\t\t\"eq\": createPositionalPseudo( function( _matchIndexes, length, argument ) {\n-\t\t\treturn [ argument < 0 ? argument + length : argument ];\n-\t\t} ),\n-\n-\t\t\"even\": createPositionalPseudo( function( matchIndexes, length ) {\n-\t\t\tvar i = 0;\n-\t\t\tfor ( ; i < length; i += 2 ) {\n-\t\t\t\tmatchIndexes.push( i );\n-\t\t\t}\n-\t\t\treturn matchIndexes;\n-\t\t} ),\n-\n-\t\t\"odd\": createPositionalPseudo( function( matchIndexes, length ) {\n-\t\t\tvar i = 1;\n-\t\t\tfor ( ; i < length; i += 2 ) {\n-\t\t\t\tmatchIndexes.push( i );\n-\t\t\t}\n-\t\t\treturn matchIndexes;\n-\t\t} ),\n-\n-\t\t\"lt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n-\t\t\tvar i = argument < 0 ?\n-\t\t\t\targument + length :\n-\t\t\t\targument > length ?\n-\t\t\t\t\tlength :\n-\t\t\t\t\targument;\n-\t\t\tfor ( ; --i >= 0; ) {\n-\t\t\t\tmatchIndexes.push( i );\n-\t\t\t}\n-\t\t\treturn matchIndexes;\n-\t\t} ),\n-\n-\t\t\"gt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n-\t\t\tvar i = argument < 0 ? argument + length : argument;\n-\t\t\tfor ( ; ++i < length; ) {\n-\t\t\t\tmatchIndexes.push( i );\n-\t\t\t}\n-\t\t\treturn matchIndexes;\n-\t\t} )\n-\t}\n-};\n-\n-Expr.pseudos[ \"nth\" ] = Expr.pseudos[ \"eq\" ];\n-\n-\/\/ Add button\/input type pseudos\n-for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n-\tExpr.pseudos[ i ] = createInputPseudo( i );\n-}\n-for ( i in { submit: true, reset: true } ) {\n-\tExpr.pseudos[ i ] = createButtonPseudo( i );\n-}\n-\n-\/\/ Easy API for creating new setFilters\n-function setFilters() {}\n-setFilters.prototype = Expr.filters = Expr.pseudos;\n-Expr.setFilters = new setFilters();\n-\n-tokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n-\tvar matched, match, tokens, type,\n-\t\tsoFar, groups, preFilters,\n-\t\tcached = tokenCache[ selector + \" \" ];\n-\n-\tif ( cached ) {\n-\t\treturn parseOnly ? 0 : cached.slice( 0 );\n-\t}\n-\n-\tsoFar = selector;\n-\tgroups = [];\n-\tpreFilters = Expr.preFilter;\n-\n-\twhile ( soFar ) {\n-\n-\t\t\/\/ Comma and first run\n-\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n-\t\t\tif ( match ) {\n-\n-\t\t\t\t\/\/ Don't consume trailing commas as valid\n-\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n-\t\t\t}\n-\t\t\tgroups.push( ( tokens = [] ) );\n-\t\t}\n-\n-\t\tmatched = false;\n-\n-\t\t\/\/ Combinators\n-\t\tif ( ( match = rcombinators.exec( soFar ) ) ) {\n-\t\t\tmatched = match.shift();\n-\t\t\ttokens.push( {\n-\t\t\t\tvalue: matched,\n-\n-\t\t\t\t\/\/ Cast descendant combinators to space\n-\t\t\t\ttype: match[ 0 ].replace( rtrim, \" \" )\n-\t\t\t} );\n-\t\t\tsoFar = soFar.slice( matched.length );\n-\t\t}\n-\n-\t\t\/\/ Filters\n-\t\tfor ( type in Expr.filter ) {\n-\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n-\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n-\t\t\t\tmatched = match.shift();\n-\t\t\t\ttokens.push( {\n-\t\t\t\t\tvalue: matched,\n-\t\t\t\t\ttype: type,\n-\t\t\t\t\tmatches: match\n-\t\t\t\t} );\n-\t\t\t\tsoFar = soFar.slice( matched.length );\n-\t\t\t}\n-\t\t}\n-\n-\t\tif ( !matched ) {\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\n-\t\/\/ Return the length of the invalid excess\n-\t\/\/ if we're just parsing\n-\t\/\/ Otherwise, throw an error or return tokens\n-\treturn parseOnly ?\n-\t\tsoFar.length :\n-\t\tsoFar ?\n-\t\t\tSizzle.error( selector ) :\n-\n-\t\t\t\/\/ Cache the tokens\n-\t\t\ttokenCache( selector, groups ).slice( 0 );\n-};\n-\n-function toSelector( tokens ) {\n-\tvar i = 0,\n-\t\tlen = tokens.length,\n-\t\tselector = \"\";\n-\tfor ( ; i < len; i++ ) {\n-\t\tselector += tokens[ i ].value;\n-\t}\n-\treturn selector;\n-}\n-\n-function addCombinator( matcher, combinator, base ) {\n-\tvar dir = combinator.dir,\n-\t\tskip = combinator.next,\n-\t\tkey = skip || dir,\n-\t\tcheckNonElements = base && key === \"parentNode\",\n-\t\tdoneName = done++;\n-\n-\treturn combinator.first ?\n-\n-\t\t\/\/ Check against closest ancestor\/preceding element\n-\t\tfunction( elem, context, xml ) {\n-\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n-\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n-\t\t\t\t\treturn matcher( elem, context, xml );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t} :\n-\n-\t\t\/\/ Check against all ancestor\/preceding elements\n-\t\tfunction( elem, context, xml ) {\n-\t\t\tvar oldCache, uniqueCache, outerCache,\n-\t\t\t\tnewCache = [ dirruns, doneName ];\n-\n-\t\t\t\/\/ We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n-\t\t\tif ( xml ) {\n-\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n-\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n-\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n-\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n-\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n-\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n-\n-\t\t\t\t\t\t\/\/ Support: IE <9 only\n-\t\t\t\t\t\t\/\/ Defend against cloned attroperties (jQuery gh-1709)\n-\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] ||\n-\t\t\t\t\t\t\t( outerCache[ elem.uniqueID ] = {} );\n-\n-\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n-\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n-\t\t\t\t\t\t} else if ( ( oldCache = uniqueCache[ key ] ) &&\n-\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n-\n-\t\t\t\t\t\t\t\/\/ Assign to newCache so results back-propagate to previous elements\n-\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n-\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t\/\/ Reuse newcache so results back-propagate to previous elements\n-\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n-\n-\t\t\t\t\t\t\t\/\/ A match means we're done; a fail means we have to keep checking\n-\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n-\t\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t};\n-}\n-\n-function elementMatcher( matchers ) {\n-\treturn matchers.length > 1 ?\n-\t\tfunction( elem, context, xml ) {\n-\t\t\tvar i = matchers.length;\n-\t\t\twhile ( i-- ) {\n-\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn true;\n-\t\t} :\n-\t\tmatchers[ 0 ];\n-}\n-\n-function multipleContexts( selector, contexts, results ) {\n-\tvar i = 0,\n-\t\tlen = contexts.length;\n-\tfor ( ; i < len; i++ ) {\n-\t\tSizzle( selector, contexts[ i ], results );\n-\t}\n-\treturn results;\n-}\n-\n-function condense( unmatched, map, filter, context, xml ) {\n-\tvar elem,\n-\t\tnewUnmatched = [],\n-\t\ti = 0,\n-\t\tlen = unmatched.length,\n-\t\tmapped = map != null;\n-\n-\tfor ( ; i < len; i++ ) {\n-\t\tif ( ( elem = unmatched[ i ] ) ) {\n-\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n-\t\t\t\tnewUnmatched.push( elem );\n-\t\t\t\tif ( mapped ) {\n-\t\t\t\t\tmap.push( i );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn newUnmatched;\n-}\n-\n-function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n-\tif ( postFilter && !postFilter[ expando ] ) {\n-\t\tpostFilter = setMatcher( postFilter );\n-\t}\n-\tif ( postFinder && !postFinder[ expando ] ) {\n-\t\tpostFinder = setMatcher( postFinder, postSelector );\n-\t}\n-\treturn markFunction( function( seed, results, context, xml ) {\n-\t\tvar temp, i, elem,\n-\t\t\tpreMap = [],\n-\t\t\tpostMap = [],\n-\t\t\tpreexisting = results.length,\n-\n-\t\t\t\/\/ Get initial elements from seed or context\n-\t\t\telems = seed || multipleContexts(\n-\t\t\t\tselector || \"*\",\n-\t\t\t\tcontext.nodeType ? [ context ] : context,\n-\t\t\t\t[]\n-\t\t\t),\n-\n-\t\t\t\/\/ Prefilter to get matcher input, preserving a map for seed-results synchronization\n-\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n-\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n-\t\t\t\telems,\n-\n-\t\t\tmatcherOut = matcher ?\n-\n-\t\t\t\t\/\/ If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n-\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n-\n-\t\t\t\t\t\/\/ ...intermediate processing is necessary\n-\t\t\t\t\t[] :\n-\n-\t\t\t\t\t\/\/ ...otherwise use results directly\n-\t\t\t\t\tresults :\n-\t\t\t\tmatcherIn;\n-\n-\t\t\/\/ Find primary matches\n-\t\tif ( matcher ) {\n-\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n-\t\t}\n-\n-\t\t\/\/ Apply postFilter\n-\t\tif ( postFilter ) {\n-\t\t\ttemp = condense( matcherOut, postMap );\n-\t\t\tpostFilter( temp, [], context, xml );\n-\n-\t\t\t\/\/ Un-match failing elements by moving them back to matcherIn\n-\t\t\ti = temp.length;\n-\t\t\twhile ( i-- ) {\n-\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n-\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif ( seed ) {\n-\t\t\tif ( postFinder || preFilter ) {\n-\t\t\t\tif ( postFinder ) {\n-\n-\t\t\t\t\t\/\/ Get the final matcherOut by condensing this intermediate into postFinder contexts\n-\t\t\t\t\ttemp = [];\n-\t\t\t\t\ti = matcherOut.length;\n-\t\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n-\n-\t\t\t\t\t\t\t\/\/ Restore matcherIn since elem is not yet a final match\n-\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Move matched elements from seed to results to keep them synchronized\n-\t\t\t\ti = matcherOut.length;\n-\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n-\t\t\t\t\t\t( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {\n-\n-\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\/\/ Add elements to results, through postFinder if defined\n-\t\t} else {\n-\t\t\tmatcherOut = condense(\n-\t\t\t\tmatcherOut === results ?\n-\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n-\t\t\t\t\tmatcherOut\n-\t\t\t);\n-\t\t\tif ( postFinder ) {\n-\t\t\t\tpostFinder( null, results, matcherOut, xml );\n-\t\t\t} else {\n-\t\t\t\tpush.apply( results, matcherOut );\n-\t\t\t}\n-\t\t}\n-\t} );\n-}\n-\n-function matcherFromTokens( tokens ) {\n-\tvar checkContext, matcher, j,\n-\t\tlen = tokens.length,\n-\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n-\t\timplicitRelative = leadingRelative || Expr.relative[ \" \" ],\n-\t\ti = leadingRelative ? 1 : 0,\n-\n-\t\t\/\/ The foundational matcher ensures that elements are reachable from top-level context(s)\n-\t\tmatchContext = addCombinator( function( elem ) {\n-\t\t\treturn elem === checkContext;\n-\t\t}, implicitRelative, true ),\n-\t\tmatchAnyContext = addCombinator( function( elem ) {\n-\t\t\treturn indexOf( checkContext, elem ) > -1;\n-\t\t}, implicitRelative, true ),\n-\t\tmatchers = [ function( elem, context, xml ) {\n-\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n-\t\t\t\t( checkContext = context ).nodeType ?\n-\t\t\t\t\tmatchContext( elem, context, xml ) :\n-\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n-\n-\t\t\t\/\/ Avoid hanging onto element (issue #299)\n-\t\t\tcheckContext = null;\n-\t\t\treturn ret;\n-\t\t} ];\n-\n-\tfor ( ; i < len; i++ ) {\n-\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n-\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n-\t\t} else {\n-\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n-\n-\t\t\t\/\/ Return special upon seeing a positional matcher\n-\t\t\tif ( matcher[ expando ] ) {\n-\n-\t\t\t\t\/\/ Find the next relative operator (if any) for proper handling\n-\t\t\t\tj = ++i;\n-\t\t\t\tfor ( ; j < len; j++ ) {\n-\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn setMatcher(\n-\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n-\t\t\t\t\ti > 1 && toSelector(\n-\n-\t\t\t\t\t\/\/ If the preceding token was a descendant combinator, insert an implicit any-element `*`\n-\t\t\t\t\ttokens\n-\t\t\t\t\t\t.slice( 0, i - 1 )\n-\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" } )\n-\t\t\t\t\t).replace( rtrim, \"$1\" ),\n-\t\t\t\t\tmatcher,\n-\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n-\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n-\t\t\t\t\tj < len && toSelector( tokens )\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\tmatchers.push( matcher );\n-\t\t}\n-\t}\n-\n-\treturn elementMatcher( matchers );\n-}\n-\n-function matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n-\tvar bySet = setMatchers.length > 0,\n-\t\tbyElement = elementMatchers.length > 0,\n-\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n-\t\t\tvar elem, j, matcher,\n-\t\t\t\tmatchedCount = 0,\n-\t\t\t\ti = \"0\",\n-\t\t\t\tunmatched = seed && [],\n-\t\t\t\tsetMatched = [],\n-\t\t\t\tcontextBackup = outermostContext,\n-\n-\t\t\t\t\/\/ We must always have either seed elements or outermost context\n-\t\t\t\telems = seed || byElement && Expr.find[ \"TAG\" ]( \"*\", outermost ),\n-\n-\t\t\t\t\/\/ Use integer dirruns iff this is the outermost matcher\n-\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n-\t\t\t\tlen = elems.length;\n-\n-\t\t\tif ( outermost ) {\n-\n-\t\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t\t\/\/ two documents; shallow comparisons work.\n-\t\t\t\t\/\/ eslint-disable-next-line eqeqeq\n-\t\t\t\toutermostContext = context == document || context || outermost;\n-\t\t\t}\n-\n-\t\t\t\/\/ Add elements passing elementMatchers directly to results\n-\t\t\t\/\/ Support: IE<9, Safari\n-\t\t\t\/\/ Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n-\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n-\t\t\t\tif ( byElement && elem ) {\n-\t\t\t\t\tj = 0;\n-\n-\t\t\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n-\t\t\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t\t\t\/\/ two documents; shallow comparisons work.\n-\t\t\t\t\t\/\/ eslint-disable-next-line eqeqeq\n-\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n-\t\t\t\t\t\tsetDocument( elem );\n-\t\t\t\t\t\txml = !documentIsHTML;\n-\t\t\t\t\t}\n-\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n-\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n-\t\t\t\t\t\t\tresults.push( elem );\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif ( outermost ) {\n-\t\t\t\t\t\tdirruns = dirrunsUnique;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Track unmatched elements for set filters\n-\t\t\t\tif ( bySet ) {\n-\n-\t\t\t\t\t\/\/ They will have gone through all possible matchers\n-\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n-\t\t\t\t\t\tmatchedCount--;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t\/\/ Lengthen the array for every element, matched or not\n-\t\t\t\t\tif ( seed ) {\n-\t\t\t\t\t\tunmatched.push( elem );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t\/\/ `i` is now the count of elements visited above, and adding it to `matchedCount`\n-\t\t\t\/\/ makes the latter nonnegative.\n-\t\t\tmatchedCount += i;\n-\n-\t\t\t\/\/ Apply set filters to unmatched elements\n-\t\t\t\/\/ NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n-\t\t\t\/\/ equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n-\t\t\t\/\/ no element matchers and no seed.\n-\t\t\t\/\/ Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n-\t\t\t\/\/ case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n-\t\t\t\/\/ numerically zero.\n-\t\t\tif ( bySet && i !== matchedCount ) {\n-\t\t\t\tj = 0;\n-\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n-\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n-\t\t\t\t}\n-\n-\t\t\t\tif ( seed ) {\n-\n-\t\t\t\t\t\/\/ Reintegrate element matches to eliminate the need for sorting\n-\t\t\t\t\tif ( matchedCount > 0 ) {\n-\t\t\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n-\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t\/\/ Discard index placeholder values to get only actual matches\n-\t\t\t\t\tsetMatched = condense( setMatched );\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Add matches to results\n-\t\t\t\tpush.apply( results, setMatched );\n-\n-\t\t\t\t\/\/ Seedless set matches succeeding multiple successful matchers stipulate sorting\n-\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n-\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n-\n-\t\t\t\t\tSizzle.uniqueSort( results );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t\/\/ Override manipulation of globals by nested matchers\n-\t\t\tif ( outermost ) {\n-\t\t\t\tdirruns = dirrunsUnique;\n-\t\t\t\toutermostContext = contextBackup;\n-\t\t\t}\n-\n-\t\t\treturn unmatched;\n-\t\t};\n-\n-\treturn bySet ?\n-\t\tmarkFunction( superMatcher ) :\n-\t\tsuperMatcher;\n-}\n-\n-compile = Sizzle.compile = function( selector, match \/* Internal Use Only *\/ ) {\n-\tvar i,\n-\t\tsetMatchers = [],\n-\t\telementMatchers = [],\n-\t\tcached = compilerCache[ selector + \" \" ];\n-\n-\tif ( !cached ) {\n-\n-\t\t\/\/ Generate a function of recursive functions that can be used to check each element\n-\t\tif ( !match ) {\n-\t\t\tmatch = tokenize( selector );\n-\t\t}\n-\t\ti = match.length;\n-\t\twhile ( i-- ) {\n-\t\t\tcached = matcherFromTokens( match[ i ] );\n-\t\t\tif ( cached[ expando ] ) {\n-\t\t\t\tsetMatchers.push( cached );\n-\t\t\t} else {\n-\t\t\t\telementMatchers.push( cached );\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Cache the compiled function\n-\t\tcached = compilerCache(\n-\t\t\tselector,\n-\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers )\n-\t\t);\n-\n-\t\t\/\/ Save selector and tokenization\n-\t\tcached.selector = selector;\n-\t}\n-\treturn cached;\n-};\n-\n-\/**\n- * A low-level selection function that works with Sizzle's compiled\n- *  selector functions\n- * @param {String|Function} selector A selector or a pre-compiled\n- *  selector function built with Sizzle.compile\n- * @param {Element} context\n- * @param {Array} [results]\n- * @param {Array} [seed] A set of elements to match against\n- *\/\n-select = Sizzle.select = function( selector, context, results, seed ) {\n-\tvar i, tokens, token, type, find,\n-\t\tcompiled = typeof selector === \"function\" && selector,\n-\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n-\n-\tresults = results || [];\n-\n-\t\/\/ Try to minimize operations if there is only one selector in the list and no seed\n-\t\/\/ (the latter of which guarantees us context)\n-\tif ( match.length === 1 ) {\n-\n-\t\t\/\/ Reduce context if the leading compound selector is an ID\n-\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n-\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n-\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n-\n-\t\t\tcontext = ( Expr.find[ \"ID\" ]( token.matches[ 0 ]\n-\t\t\t\t.replace( runescape, funescape ), context ) || [] )[ 0 ];\n-\t\t\tif ( !context ) {\n-\t\t\t\treturn results;\n-\n-\t\t\t\/\/ Precompiled matchers will still verify ancestry, so step up a level\n-\t\t\t} else if ( compiled ) {\n-\t\t\t\tcontext = context.parentNode;\n-\t\t\t}\n-\n-\t\t\tselector = selector.slice( tokens.shift().value.length );\n-\t\t}\n-\n-\t\t\/\/ Fetch a seed set for right-to-left matching\n-\t\ti = matchExpr[ \"needsContext\" ].test( selector ) ? 0 : tokens.length;\n-\t\twhile ( i-- ) {\n-\t\t\ttoken = tokens[ i ];\n-\n-\t\t\t\/\/ Abort if we hit a combinator\n-\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n-\n-\t\t\t\t\/\/ Search, expanding context for leading sibling combinators\n-\t\t\t\tif ( ( seed = find(\n-\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n-\t\t\t\t\trsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||\n-\t\t\t\t\t\tcontext\n-\t\t\t\t) ) ) {\n-\n-\t\t\t\t\t\/\/ If seed is empty or no tokens remain, we can return early\n-\t\t\t\t\ttokens.splice( i, 1 );\n-\t\t\t\t\tselector = seed.length && toSelector( tokens );\n-\t\t\t\t\tif ( !selector ) {\n-\t\t\t\t\t\tpush.apply( results, seed );\n-\t\t\t\t\t\treturn results;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t\/\/ Compile and execute a filtering function if one is not provided\n-\t\/\/ Provide `match` to avoid retokenization if we modified the selector above\n-\t( compiled || compile( selector, match ) )(\n-\t\tseed,\n-\t\tcontext,\n-\t\t!documentIsHTML,\n-\t\tresults,\n-\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n-\t);\n-\treturn results;\n-};\n-\n-\/\/ One-time assignments\n-\n-\/\/ Sort stability\n-support.sortStable = expando.split( \"\" ).sort( sortOrder ).join( \"\" ) === expando;\n-\n-\/\/ Support: Chrome 14-35+\n-\/\/ Always assume duplicates if they aren't passed to the comparison function\n-support.detectDuplicates = !!hasDuplicate;\n-\n-\/\/ Initialize against the default document\n-setDocument();\n-\n-\/\/ Support: Webkit<537.32 - Safari 6.0.3\/Chrome 25 (fixed in Chrome 27)\n-\/\/ Detached nodes confoundingly follow *each other*\n-support.sortDetached = assert( function( el ) {\n-\n-\t\/\/ Should return 1, but returns 4 (following)\n-\treturn el.compareDocumentPosition( document.createElement( \"fieldset\" ) ) & 1;\n-} );\n-\n-\/\/ Support: IE<8\n-\/\/ Prevent attribute\/property \"interpolation\"\n-\/\/ https:\/\/msdn.microsoft.com\/en-us\/library\/ms536429%28VS.85%29.aspx\n-if ( !assert( function( el ) {\n-\tel.innerHTML = \"<a href='#'><\/a>\";\n-\treturn el.firstChild.getAttribute( \"href\" ) === \"#\";\n-} ) ) {\n-\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n-\t\tif ( !isXML ) {\n-\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n-\t\t}\n-\t} );\n-}\n-\n-\/\/ Support: IE<9\n-\/\/ Use defaultValue in place of getAttribute(\"value\")\n-if ( !support.attributes || !assert( function( el ) {\n-\tel.innerHTML = \"<input\/>\";\n-\tel.firstChild.setAttribute( \"value\", \"\" );\n-\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n-} ) ) {\n-\taddHandle( \"value\", function( elem, _name, isXML ) {\n-\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n-\t\t\treturn elem.defaultValue;\n-\t\t}\n-\t} );\n-}\n-\n-\/\/ Support: IE<9\n-\/\/ Use getAttributeNode to fetch booleans when getAttribute lies\n-if ( !assert( function( el ) {\n-\treturn el.getAttribute( \"disabled\" ) == null;\n-} ) ) {\n-\taddHandle( booleans, function( elem, name, isXML ) {\n-\t\tvar val;\n-\t\tif ( !isXML ) {\n-\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n-\t\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n-\t\t\t\t\tval.value :\n-\t\t\t\t\tnull;\n-\t\t}\n-\t} );\n-}\n-\n-return Sizzle;\n-\n-} )( window );\n-\n-\n-\n-jQuery.find = Sizzle;\n-jQuery.expr = Sizzle.selectors;\n-\n-\/\/ Deprecated\n-jQuery.expr[ \":\" ] = jQuery.expr.pseudos;\n-jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n-jQuery.text = Sizzle.getText;\n-jQuery.isXMLDoc = Sizzle.isXML;\n-jQuery.contains = Sizzle.contains;\n-jQuery.escapeSelector = Sizzle.escape;\n-\n-\n-\n-\n-var dir = function( elem, dir, until ) {\n-\tvar matched = [],\n-\t\ttruncate = until !== undefined;\n-\n-\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n-\t\tif ( elem.nodeType === 1 ) {\n-\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tmatched.push( elem );\n-\t\t}\n-\t}\n-\treturn matched;\n-};\n-\n-\n-var siblings = function( n, elem ) {\n-\tvar matched = [];\n-\n-\tfor ( ; n; n = n.nextSibling ) {\n-\t\tif ( n.nodeType === 1 && n !== elem ) {\n-\t\t\tmatched.push( n );\n-\t\t}\n-\t}\n-\n-\treturn matched;\n-};\n-\n-\n-var rneedsContext = jQuery.expr.match.needsContext;\n-\n-\n-\n-function nodeName( elem, name ) {\n-\n-\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n-\n-}\n-var rsingleTag = ( \/^<([a-z][^\\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\\/?>(?:<\\\/\\1>|)$\/i );\n-\n-\n-\n-\/\/ Implement the identical functionality for filter and not\n-function winnow( elements, qualifier, not ) {\n-\tif ( isFunction( qualifier ) ) {\n-\t\treturn jQuery.grep( elements, function( elem, i ) {\n-\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n-\t\t} );\n-\t}\n-\n-\t\/\/ Single element\n-\tif ( qualifier.nodeType ) {\n-\t\treturn jQuery.grep( elements, function( elem ) {\n-\t\t\treturn ( elem === qualifier ) !== not;\n-\t\t} );\n-\t}\n-\n-\t\/\/ Arraylike of elements (jQuery, arguments, Array)\n-\tif ( typeof qualifier !== \"string\" ) {\n-\t\treturn jQuery.grep( elements, function( elem ) {\n-\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n-\t\t} );\n-\t}\n-\n-\t\/\/ Filtered directly for both simple and complex selectors\n-\treturn jQuery.filter( qualifier, elements, not );\n-}\n-\n-jQuery.filter = function( expr, elems, not ) {\n-\tvar elem = elems[ 0 ];\n-\n-\tif ( not ) {\n-\t\texpr = \":not(\" + expr + \")\";\n-\t}\n-\n-\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n-\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n-\t}\n-\n-\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n-\t\treturn elem.nodeType === 1;\n-\t} ) );\n-};\n-\n-jQuery.fn.extend( {\n-\tfind: function( selector ) {\n-\t\tvar i, ret,\n-\t\t\tlen = this.length,\n-\t\t\tself = this;\n-\n-\t\tif ( typeof selector !== \"string\" ) {\n-\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n-\t\t\t\tfor ( i = 0; i < len; i++ ) {\n-\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} ) );\n-\t\t}\n-\n-\t\tret = this.pushStack( [] );\n-\n-\t\tfor ( i = 0; i < len; i++ ) {\n-\t\t\tjQuery.find( selector, self[ i ], ret );\n-\t\t}\n-\n-\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n-\t},\n-\tfilter: function( selector ) {\n-\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n-\t},\n-\tnot: function( selector ) {\n-\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n-\t},\n-\tis: function( selector ) {\n-\t\treturn !!winnow(\n-\t\t\tthis,\n-\n-\t\t\t\/\/ If this is a positional\/relative selector, check membership in the returned set\n-\t\t\t\/\/ so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n-\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n-\t\t\t\tjQuery( selector ) :\n-\t\t\t\tselector || [],\n-\t\t\tfalse\n-\t\t).length;\n-\t}\n-} );\n-\n-\n-\/\/ Initialize a jQuery object\n-\n-\n-\/\/ A central reference to the root jQuery(document)\n-var rootjQuery,\n-\n-\t\/\/ A simple way to check for HTML strings\n-\t\/\/ Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n-\t\/\/ Strict HTML recognition (trac-11290: must start with <)\n-\t\/\/ Shortcut simple #id case for speed\n-\trquickExpr = \/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$\/,\n-\n-\tinit = jQuery.fn.init = function( selector, context, root ) {\n-\t\tvar match, elem;\n-\n-\t\t\/\/ HANDLE: $(\"\"), $(null), $(undefined), $(false)\n-\t\tif ( !selector ) {\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t\/\/ Method init() accepts an alternate rootjQuery\n-\t\t\/\/ so migrate can support jQuery.sub (gh-2101)\n-\t\troot = root || rootjQuery;\n-\n-\t\t\/\/ Handle HTML strings\n-\t\tif ( typeof selector === \"string\" ) {\n-\t\t\tif ( selector[ 0 ] === \"<\" &&\n-\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n-\t\t\t\tselector.length >= 3 ) {\n-\n-\t\t\t\t\/\/ Assume that strings that start and end with <> are HTML and skip the regex check\n-\t\t\t\tmatch = [ null, selector, null ];\n-\n-\t\t\t} else {\n-\t\t\t\tmatch = rquickExpr.exec( selector );\n-\t\t\t}\n-\n-\t\t\t\/\/ Match html or make sure no context is specified for #id\n-\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n-\n-\t\t\t\t\/\/ HANDLE: $(html) -> $(array)\n-\t\t\t\tif ( match[ 1 ] ) {\n-\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n-\n-\t\t\t\t\t\/\/ Option to run scripts is true for back-compat\n-\t\t\t\t\t\/\/ Intentionally let the error be thrown if parseHTML is not present\n-\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n-\t\t\t\t\t\tmatch[ 1 ],\n-\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n-\t\t\t\t\t\ttrue\n-\t\t\t\t\t) );\n-\n-\t\t\t\t\t\/\/ HANDLE: $(html, props)\n-\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n-\t\t\t\t\t\tfor ( match in context ) {\n-\n-\t\t\t\t\t\t\t\/\/ Properties of context are called as methods if possible\n-\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n-\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n-\n-\t\t\t\t\t\t\t\/\/ ...and otherwise set as attributes\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\treturn this;\n-\n-\t\t\t\t\/\/ HANDLE: $(#id)\n-\t\t\t\t} else {\n-\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n-\n-\t\t\t\t\tif ( elem ) {\n-\n-\t\t\t\t\t\t\/\/ Inject the element directly into the jQuery object\n-\t\t\t\t\t\tthis[ 0 ] = elem;\n-\t\t\t\t\t\tthis.length = 1;\n-\t\t\t\t\t}\n-\t\t\t\t\treturn this;\n-\t\t\t\t}\n-\n-\t\t\t\/\/ HANDLE: $(expr, $(...))\n-\t\t\t} else if ( !context || context.jquery ) {\n-\t\t\t\treturn ( context || root ).find( selector );\n-\n-\t\t\t\/\/ HANDLE: $(expr, context)\n-\t\t\t\/\/ (which is just equivalent to: $(context).find(expr)\n-\t\t\t} else {\n-\t\t\t\treturn this.constructor( context ).find( selector );\n-\t\t\t}\n-\n-\t\t\/\/ HANDLE: $(DOMElement)\n-\t\t} else if ( selector.nodeType ) {\n-\t\t\tthis[ 0 ] = selector;\n-\t\t\tthis.length = 1;\n-\t\t\treturn this;\n-\n-\t\t\/\/ HANDLE: $(function)\n-\t\t\/\/ Shortcut for document ready\n-\t\t} else if ( isFunction( selector ) ) {\n-\t\t\treturn root.ready !== undefined ?\n-\t\t\t\troot.ready( selector ) :\n-\n-\t\t\t\t\/\/ Execute immediately if ready is not present\n-\t\t\t\tselector( jQuery );\n-\t\t}\n-\n-\t\treturn jQuery.makeArray( selector, this );\n-\t};\n-\n-\/\/ Give the init function the jQuery prototype for later instantiation\n-init.prototype = jQuery.fn;\n-\n-\/\/ Initialize central reference\n-rootjQuery = jQuery( document );\n-\n-\n-var rparentsprev = \/^(?:parents|prev(?:Until|All))\/,\n-\n-\t\/\/ Methods guaranteed to produce a unique set when starting from a unique set\n-\tguaranteedUnique = {\n-\t\tchildren: true,\n-\t\tcontents: true,\n-\t\tnext: true,\n-\t\tprev: true\n-\t};\n-\n-jQuery.fn.extend( {\n-\thas: function( target ) {\n-\t\tvar targets = jQuery( target, this ),\n-\t\t\tl = targets.length;\n-\n-\t\treturn this.filter( function() {\n-\t\t\tvar i = 0;\n-\t\t\tfor ( ; i < l; i++ ) {\n-\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tclosest: function( selectors, context ) {\n-\t\tvar cur,\n-\t\t\ti = 0,\n-\t\t\tl = this.length,\n-\t\t\tmatched = [],\n-\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n-\n-\t\t\/\/ Positional selectors never match, since there's no _selection_ context\n-\t\tif ( !rneedsContext.test( selectors ) ) {\n-\t\t\tfor ( ; i < l; i++ ) {\n-\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n-\n-\t\t\t\t\t\/\/ Always skip document fragments\n-\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n-\t\t\t\t\t\ttargets.index( cur ) > -1 :\n-\n-\t\t\t\t\t\t\/\/ Don't pass non-elements to Sizzle\n-\t\t\t\t\t\tcur.nodeType === 1 &&\n-\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n-\n-\t\t\t\t\t\tmatched.push( cur );\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n-\t},\n-\n-\t\/\/ Determine the position of an element within the set\n-\tindex: function( elem ) {\n-\n-\t\t\/\/ No argument, return index in parent\n-\t\tif ( !elem ) {\n-\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n-\t\t}\n-\n-\t\t\/\/ Index in selector\n-\t\tif ( typeof elem === \"string\" ) {\n-\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n-\t\t}\n-\n-\t\t\/\/ Locate the position of the desired element\n-\t\treturn indexOf.call( this,\n-\n-\t\t\t\/\/ If it receives a jQuery object, the first element is used\n-\t\t\telem.jquery ? elem[ 0 ] : elem\n-\t\t);\n-\t},\n-\n-\tadd: function( selector, context ) {\n-\t\treturn this.pushStack(\n-\t\t\tjQuery.uniqueSort(\n-\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n-\t\t\t)\n-\t\t);\n-\t},\n-\n-\taddBack: function( selector ) {\n-\t\treturn this.add( selector == null ?\n-\t\t\tthis.prevObject : this.prevObject.filter( selector )\n-\t\t);\n-\t}\n-} );\n-\n-function sibling( cur, dir ) {\n-\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n-\treturn cur;\n-}\n-\n-jQuery.each( {\n-\tparent: function( elem ) {\n-\t\tvar parent = elem.parentNode;\n-\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n-\t},\n-\tparents: function( elem ) {\n-\t\treturn dir( elem, \"parentNode\" );\n-\t},\n-\tparentsUntil: function( elem, _i, until ) {\n-\t\treturn dir( elem, \"parentNode\", until );\n-\t},\n-\tnext: function( elem ) {\n-\t\treturn sibling( elem, \"nextSibling\" );\n-\t},\n-\tprev: function( elem ) {\n-\t\treturn sibling( elem, \"previousSibling\" );\n-\t},\n-\tnextAll: function( elem ) {\n-\t\treturn dir( elem, \"nextSibling\" );\n-\t},\n-\tprevAll: function( elem ) {\n-\t\treturn dir( elem, \"previousSibling\" );\n-\t},\n-\tnextUntil: function( elem, _i, until ) {\n-\t\treturn dir( elem, \"nextSibling\", until );\n-\t},\n-\tprevUntil: function( elem, _i, until ) {\n-\t\treturn dir( elem, \"previousSibling\", until );\n-\t},\n-\tsiblings: function( elem ) {\n-\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n-\t},\n-\tchildren: function( elem ) {\n-\t\treturn siblings( elem.firstChild );\n-\t},\n-\tcontents: function( elem ) {\n-\t\tif ( elem.contentDocument != null &&\n-\n-\t\t\t\/\/ Support: IE 11+\n-\t\t\t\/\/ <object> elements with no `data` attribute has an object\n-\t\t\t\/\/ `contentDocument` with a `null` prototype.\n-\t\t\tgetProto( elem.contentDocument ) ) {\n-\n-\t\t\treturn elem.contentDocument;\n-\t\t}\n-\n-\t\t\/\/ Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n-\t\t\/\/ Treat the template element as a regular one in browsers that\n-\t\t\/\/ don't support it.\n-\t\tif ( nodeName( elem, \"template\" ) ) {\n-\t\t\telem = elem.content || elem;\n-\t\t}\n-\n-\t\treturn jQuery.merge( [], elem.childNodes );\n-\t}\n-}, function( name, fn ) {\n-\tjQuery.fn[ name ] = function( until, selector ) {\n-\t\tvar matched = jQuery.map( this, fn, until );\n-\n-\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n-\t\t\tselector = until;\n-\t\t}\n-\n-\t\tif ( selector && typeof selector === \"string\" ) {\n-\t\t\tmatched = jQuery.filter( selector, matched );\n-\t\t}\n-\n-\t\tif ( this.length > 1 ) {\n-\n-\t\t\t\/\/ Remove duplicates\n-\t\t\tif ( !guaranteedUnique[ name ] ) {\n-\t\t\t\tjQuery.uniqueSort( matched );\n-\t\t\t}\n-\n-\t\t\t\/\/ Reverse order for parents* and prev-derivatives\n-\t\t\tif ( rparentsprev.test( name ) ) {\n-\t\t\t\tmatched.reverse();\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn this.pushStack( matched );\n-\t};\n-} );\n-var rnothtmlwhite = ( \/[^\\x20\\t\\r\\n\\f]+\/g );\n-\n-\n-\n-\/\/ Convert String-formatted options into Object-formatted ones\n-function createOptions( options ) {\n-\tvar object = {};\n-\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n-\t\tobject[ flag ] = true;\n-\t} );\n-\treturn object;\n-}\n-\n-\/*\n- * Create a callback list using the following parameters:\n- *\n- *\toptions: an optional list of space-separated options that will change how\n- *\t\t\tthe callback list behaves or a more traditional option object\n- *\n- * By default a callback list will act like an event callback list and can be\n- * \"fired\" multiple times.\n- *\n- * Possible options:\n- *\n- *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n- *\n- *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n- *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n- *\t\t\t\t\tvalues (like a Deferred)\n- *\n- *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n- *\n- *\tstopOnFalse:\tinterrupt callings when a callback returns false\n- *\n- *\/\n-jQuery.Callbacks = function( options ) {\n-\n-\t\/\/ Convert options from String-formatted to Object-formatted if needed\n-\t\/\/ (we check in cache first)\n-\toptions = typeof options === \"string\" ?\n-\t\tcreateOptions( options ) :\n-\t\tjQuery.extend( {}, options );\n-\n-\tvar \/\/ Flag to know if list is currently firing\n-\t\tfiring,\n-\n-\t\t\/\/ Last fire value for non-forgettable lists\n-\t\tmemory,\n-\n-\t\t\/\/ Flag to know if list was already fired\n-\t\tfired,\n-\n-\t\t\/\/ Flag to prevent firing\n-\t\tlocked,\n-\n-\t\t\/\/ Actual callback list\n-\t\tlist = [],\n-\n-\t\t\/\/ Queue of execution data for repeatable lists\n-\t\tqueue = [],\n-\n-\t\t\/\/ Index of currently firing callback (modified by add\/remove as needed)\n-\t\tfiringIndex = -1,\n-\n-\t\t\/\/ Fire callbacks\n-\t\tfire = function() {\n-\n-\t\t\t\/\/ Enforce single-firing\n-\t\t\tlocked = locked || options.once;\n-\n-\t\t\t\/\/ Execute callbacks for all pending executions,\n-\t\t\t\/\/ respecting firingIndex overrides and runtime changes\n-\t\t\tfired = firing = true;\n-\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n-\t\t\t\tmemory = queue.shift();\n-\t\t\t\twhile ( ++firingIndex < list.length ) {\n-\n-\t\t\t\t\t\/\/ Run callback and check for early termination\n-\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n-\t\t\t\t\t\toptions.stopOnFalse ) {\n-\n-\t\t\t\t\t\t\/\/ Jump to end and forget the data so .add doesn't re-fire\n-\t\t\t\t\t\tfiringIndex = list.length;\n-\t\t\t\t\t\tmemory = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t\/\/ Forget the data if we're done with it\n-\t\t\tif ( !options.memory ) {\n-\t\t\t\tmemory = false;\n-\t\t\t}\n-\n-\t\t\tfiring = false;\n-\n-\t\t\t\/\/ Clean up if we're done firing for good\n-\t\t\tif ( locked ) {\n-\n-\t\t\t\t\/\/ Keep an empty list if we have data for future add calls\n-\t\t\t\tif ( memory ) {\n-\t\t\t\t\tlist = [];\n-\n-\t\t\t\t\/\/ Otherwise, this object is spent\n-\t\t\t\t} else {\n-\t\t\t\t\tlist = \"\";\n-\t\t\t\t}\n-\t\t\t}\n-\t\t},\n-\n-\t\t\/\/ Actual Callbacks object\n-\t\tself = {\n-\n-\t\t\t\/\/ Add a callback or a collection of callbacks to the list\n-\t\t\tadd: function() {\n-\t\t\t\tif ( list ) {\n-\n-\t\t\t\t\t\/\/ If we have memory from a past run, we should fire after adding\n-\t\t\t\t\tif ( memory && !firing ) {\n-\t\t\t\t\t\tfiringIndex = list.length - 1;\n-\t\t\t\t\t\tqueue.push( memory );\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t( function add( args ) {\n-\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n-\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n-\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n-\t\t\t\t\t\t\t\t\tlist.push( arg );\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n-\n-\t\t\t\t\t\t\t\t\/\/ Inspect recursively\n-\t\t\t\t\t\t\t\tadd( arg );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} );\n-\t\t\t\t\t} )( arguments );\n-\n-\t\t\t\t\tif ( memory && !firing ) {\n-\t\t\t\t\t\tfire();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn this;\n-\t\t\t},\n-\n-\t\t\t\/\/ Remove a callback from the list\n-\t\t\tremove: function() {\n-\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n-\t\t\t\t\tvar index;\n-\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n-\t\t\t\t\t\tlist.splice( index, 1 );\n-\n-\t\t\t\t\t\t\/\/ Handle firing indexes\n-\t\t\t\t\t\tif ( index <= firingIndex ) {\n-\t\t\t\t\t\t\tfiringIndex--;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} );\n-\t\t\t\treturn this;\n-\t\t\t},\n-\n-\t\t\t\/\/ Check if a given callback is in the list.\n-\t\t\t\/\/ If no argument is given, return whether or not list has callbacks attached.\n-\t\t\thas: function( fn ) {\n-\t\t\t\treturn fn ?\n-\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n-\t\t\t\t\tlist.length > 0;\n-\t\t\t},\n-\n-\t\t\t\/\/ Remove all callbacks from the list\n-\t\t\tempty: function() {\n-\t\t\t\tif ( list ) {\n-\t\t\t\t\tlist = [];\n-\t\t\t\t}\n-\t\t\t\treturn this;\n-\t\t\t},\n-\n-\t\t\t\/\/ Disable .fire and .add\n-\t\t\t\/\/ Abort any current\/pending executions\n-\t\t\t\/\/ Clear all callbacks and values\n-\t\t\tdisable: function() {\n-\t\t\t\tlocked = queue = [];\n-\t\t\t\tlist = memory = \"\";\n-\t\t\t\treturn this;\n-\t\t\t},\n-\t\t\tdisabled: function() {\n-\t\t\t\treturn !list;\n-\t\t\t},\n-\n-\t\t\t\/\/ Disable .fire\n-\t\t\t\/\/ Also disable .add unless we have memory (since it would have no effect)\n-\t\t\t\/\/ Abort any pending executions\n-\t\t\tlock: function() {\n-\t\t\t\tlocked = queue = [];\n-\t\t\t\tif ( !memory && !firing ) {\n-\t\t\t\t\tlist = memory = \"\";\n-\t\t\t\t}\n-\t\t\t\treturn this;\n-\t\t\t},\n-\t\t\tlocked: function() {\n-\t\t\t\treturn !!locked;\n-\t\t\t},\n-\n-\t\t\t\/\/ Call all callbacks with the given context and arguments\n-\t\t\tfireWith: function( context, args ) {\n-\t\t\t\tif ( !locked ) {\n-\t\t\t\t\targs = args || [];\n-\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n-\t\t\t\t\tqueue.push( args );\n-\t\t\t\t\tif ( !firing ) {\n-\t\t\t\t\t\tfire();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn this;\n-\t\t\t},\n-\n-\t\t\t\/\/ Call all the callbacks with the given arguments\n-\t\t\tfire: function() {\n-\t\t\t\tself.fireWith( this, arguments );\n-\t\t\t\treturn this;\n-\t\t\t},\n-\n-\t\t\t\/\/ To know if the callbacks have already been called at least once\n-\t\t\tfired: function() {\n-\t\t\t\treturn !!fired;\n-\t\t\t}\n-\t\t};\n-\n-\treturn self;\n-};\n-\n-\n-function Identity( v ) {\n-\treturn v;\n-}\n-function Thrower( ex ) {\n-\tthrow ex;\n-}\n-\n-function adoptValue( value, resolve, reject, noValue ) {\n-\tvar method;\n-\n-\ttry {\n-\n-\t\t\/\/ Check for promise aspect first to privilege synchronous behavior\n-\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n-\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n-\n-\t\t\/\/ Other thenables\n-\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n-\t\t\tmethod.call( value, resolve, reject );\n-\n-\t\t\/\/ Other non-thenables\n-\t\t} else {\n-\n-\t\t\t\/\/ Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n-\t\t\t\/\/ * false: [ value ].slice( 0 ) => resolve( value )\n-\t\t\t\/\/ * true: [ value ].slice( 1 ) => resolve()\n-\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n-\t\t}\n-\n-\t\/\/ For Promises\/A+, convert exceptions into rejections\n-\t\/\/ Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n-\t\/\/ Deferred#then to conditionally suppress rejection.\n-\t} catch ( value ) {\n-\n-\t\t\/\/ Support: Android 4.0 only\n-\t\t\/\/ Strict mode functions invoked without .call\/.apply get global-object context\n-\t\treject.apply( undefined, [ value ] );\n-\t}\n-}\n-\n-jQuery.extend( {\n-\n-\tDeferred: function( func ) {\n-\t\tvar tuples = [\n-\n-\t\t\t\t\/\/ action, add listener, callbacks,\n-\t\t\t\t\/\/ ... .then handlers, argument index, [final state]\n-\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n-\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n-\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n-\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n-\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n-\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n-\t\t\t],\n-\t\t\tstate = \"pending\",\n-\t\t\tpromise = {\n-\t\t\t\tstate: function() {\n-\t\t\t\t\treturn state;\n-\t\t\t\t},\n-\t\t\t\talways: function() {\n-\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n-\t\t\t\t\treturn this;\n-\t\t\t\t},\n-\t\t\t\t\"catch\": function( fn ) {\n-\t\t\t\t\treturn promise.then( null, fn );\n-\t\t\t\t},\n-\n-\t\t\t\t\/\/ Keep pipe for back-compat\n-\t\t\t\tpipe: function( \/* fnDone, fnFail, fnProgress *\/ ) {\n-\t\t\t\t\tvar fns = arguments;\n-\n-\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n-\t\t\t\t\t\tjQuery.each( tuples, function( _i, tuple ) {\n-\n-\t\t\t\t\t\t\t\/\/ Map tuples (progress, done, fail) to arguments (done, fail, progress)\n-\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n-\n-\t\t\t\t\t\t\t\/\/ deferred.progress(function() { bind to newDefer or newDefer.notify })\n-\t\t\t\t\t\t\t\/\/ deferred.done(function() { bind to newDefer or newDefer.resolve })\n-\t\t\t\t\t\t\t\/\/ deferred.fail(function() { bind to newDefer or newDefer.reject })\n-\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n-\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n-\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n-\t\t\t\t\t\t\t\t\treturned.promise()\n-\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n-\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n-\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n-\t\t\t\t\t\t\t\t\t\tthis,\n-\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n-\t\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} );\n-\t\t\t\t\t\t} );\n-\t\t\t\t\t\tfns = null;\n-\t\t\t\t\t} ).promise();\n-\t\t\t\t},\n-\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n-\t\t\t\t\tvar maxDepth = 0;\n-\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n-\t\t\t\t\t\treturn function() {\n-\t\t\t\t\t\t\tvar that = this,\n-\t\t\t\t\t\t\t\targs = arguments,\n-\t\t\t\t\t\t\t\tmightThrow = function() {\n-\t\t\t\t\t\t\t\t\tvar returned, then;\n-\n-\t\t\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ section 2.3.3.3.3\n-\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-59\n-\t\t\t\t\t\t\t\t\t\/\/ Ignore double-resolution attempts\n-\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n-\t\t\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n-\n-\t\t\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ section 2.3.1\n-\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-48\n-\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n-\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n-\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ sections 2.3.3.1, 3.5\n-\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-54\n-\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-75\n-\t\t\t\t\t\t\t\t\t\/\/ Retrieve `then` only once\n-\t\t\t\t\t\t\t\t\tthen = returned &&\n-\n-\t\t\t\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ section 2.3.4\n-\t\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-64\n-\t\t\t\t\t\t\t\t\t\t\/\/ Only check objects and functions for thenability\n-\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n-\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n-\t\t\t\t\t\t\t\t\t\treturned.then;\n-\n-\t\t\t\t\t\t\t\t\t\/\/ Handle a returned thenable\n-\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n-\n-\t\t\t\t\t\t\t\t\t\t\/\/ Special processors (notify) just wait for resolution\n-\t\t\t\t\t\t\t\t\t\tif ( special ) {\n-\t\t\t\t\t\t\t\t\t\t\tthen.call(\n-\t\t\t\t\t\t\t\t\t\t\t\treturned,\n-\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n-\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n-\t\t\t\t\t\t\t\t\t\t\t);\n-\n-\t\t\t\t\t\t\t\t\t\t\/\/ Normal processors (resolve) also hook into progress\n-\t\t\t\t\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t\t\t\t\t\/\/ ...and disregard older resolution values\n-\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n-\n-\t\t\t\t\t\t\t\t\t\t\tthen.call(\n-\t\t\t\t\t\t\t\t\t\t\t\treturned,\n-\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n-\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n-\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n-\t\t\t\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\/\/ Handle all other returned values\n-\t\t\t\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t\t\t\t\/\/ Only substitute handlers pass on context\n-\t\t\t\t\t\t\t\t\t\t\/\/ and multiple values (non-spec behavior)\n-\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n-\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n-\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n-\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\/\/ Process the value(s)\n-\t\t\t\t\t\t\t\t\t\t\/\/ Default process is resolve\n-\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t},\n-\n-\t\t\t\t\t\t\t\t\/\/ Only normal processors (resolve) catch and reject exceptions\n-\t\t\t\t\t\t\t\tprocess = special ?\n-\t\t\t\t\t\t\t\t\tmightThrow :\n-\t\t\t\t\t\t\t\t\tfunction() {\n-\t\t\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n-\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n-\n-\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n-\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ section 2.3.3.3.4.1\n-\t\t\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-61\n-\t\t\t\t\t\t\t\t\t\t\t\/\/ Ignore post-resolution exceptions\n-\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n-\n-\t\t\t\t\t\t\t\t\t\t\t\t\/\/ Only substitute handlers pass on context\n-\t\t\t\t\t\t\t\t\t\t\t\t\/\/ and multiple values (non-spec behavior)\n-\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n-\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n-\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t};\n-\n-\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ section 2.3.3.3.1\n-\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-57\n-\t\t\t\t\t\t\t\/\/ Re-resolve promises immediately to dodge false rejection from\n-\t\t\t\t\t\t\t\/\/ subsequent errors\n-\t\t\t\t\t\t\tif ( depth ) {\n-\t\t\t\t\t\t\t\tprocess();\n-\t\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t\t\/\/ Call an optional hook to record the stack, in case of exception\n-\t\t\t\t\t\t\t\t\/\/ since it's otherwise lost when execution goes async\n-\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n-\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\twindow.setTimeout( process );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t};\n-\t\t\t\t\t}\n-\n-\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n-\n-\t\t\t\t\t\t\/\/ progress_handlers.add( ... )\n-\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n-\t\t\t\t\t\t\tresolve(\n-\t\t\t\t\t\t\t\t0,\n-\t\t\t\t\t\t\t\tnewDefer,\n-\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n-\t\t\t\t\t\t\t\t\tonProgress :\n-\t\t\t\t\t\t\t\t\tIdentity,\n-\t\t\t\t\t\t\t\tnewDefer.notifyWith\n-\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t);\n-\n-\t\t\t\t\t\t\/\/ fulfilled_handlers.add( ... )\n-\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n-\t\t\t\t\t\t\tresolve(\n-\t\t\t\t\t\t\t\t0,\n-\t\t\t\t\t\t\t\tnewDefer,\n-\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n-\t\t\t\t\t\t\t\t\tonFulfilled :\n-\t\t\t\t\t\t\t\t\tIdentity\n-\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t);\n-\n-\t\t\t\t\t\t\/\/ rejected_handlers.add( ... )\n-\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n-\t\t\t\t\t\t\tresolve(\n-\t\t\t\t\t\t\t\t0,\n-\t\t\t\t\t\t\t\tnewDefer,\n-\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n-\t\t\t\t\t\t\t\t\tonRejected :\n-\t\t\t\t\t\t\t\t\tThrower\n-\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t);\n-\t\t\t\t\t} ).promise();\n-\t\t\t\t},\n-\n-\t\t\t\t\/\/ Get a promise for this deferred\n-\t\t\t\t\/\/ If obj is provided, the promise aspect is added to the object\n-\t\t\t\tpromise: function( obj ) {\n-\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n-\t\t\t\t}\n-\t\t\t},\n-\t\t\tdeferred = {};\n-\n-\t\t\/\/ Add list-specific methods\n-\t\tjQuery.each( tuples, function( i, tuple ) {\n-\t\t\tvar list = tuple[ 2 ],\n-\t\t\t\tstateString = tuple[ 5 ];\n-\n-\t\t\t\/\/ promise.progress = list.add\n-\t\t\t\/\/ promise.done = list.add\n-\t\t\t\/\/ promise.fail = list.add\n-\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n-\n-\t\t\t\/\/ Handle state\n-\t\t\tif ( stateString ) {\n-\t\t\t\tlist.add(\n-\t\t\t\t\tfunction() {\n-\n-\t\t\t\t\t\t\/\/ state = \"resolved\" (i.e., fulfilled)\n-\t\t\t\t\t\t\/\/ state = \"rejected\"\n-\t\t\t\t\t\tstate = stateString;\n-\t\t\t\t\t},\n-\n-\t\t\t\t\t\/\/ rejected_callbacks.disable\n-\t\t\t\t\t\/\/ fulfilled_callbacks.disable\n-\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n-\n-\t\t\t\t\t\/\/ rejected_handlers.disable\n-\t\t\t\t\t\/\/ fulfilled_handlers.disable\n-\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n-\n-\t\t\t\t\t\/\/ progress_callbacks.lock\n-\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n-\n-\t\t\t\t\t\/\/ progress_handlers.lock\n-\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n-\t\t\t\t);\n-\t\t\t}\n-\n-\t\t\t\/\/ progress_handlers.fire\n-\t\t\t\/\/ fulfilled_handlers.fire\n-\t\t\t\/\/ rejected_handlers.fire\n-\t\t\tlist.add( tuple[ 3 ].fire );\n-\n-\t\t\t\/\/ deferred.notify = function() { deferred.notifyWith(...) }\n-\t\t\t\/\/ deferred.resolve = function() { deferred.resolveWith(...) }\n-\t\t\t\/\/ deferred.reject = function() { deferred.rejectWith(...) }\n-\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n-\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n-\t\t\t\treturn this;\n-\t\t\t};\n-\n-\t\t\t\/\/ deferred.notifyWith = list.fireWith\n-\t\t\t\/\/ deferred.resolveWith = list.fireWith\n-\t\t\t\/\/ deferred.rejectWith = list.fireWith\n-\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n-\t\t} );\n-\n-\t\t\/\/ Make the deferred a promise\n-\t\tpromise.promise( deferred );\n-\n-\t\t\/\/ Call given func if any\n-\t\tif ( func ) {\n-\t\t\tfunc.call( deferred, deferred );\n-\t\t}\n-\n-\t\t\/\/ All done!\n-\t\treturn deferred;\n-\t},\n-\n-\t\/\/ Deferred helper\n-\twhen: function( singleValue ) {\n-\t\tvar\n-\n-\t\t\t\/\/ count of uncompleted subordinates\n-\t\t\tremaining = arguments.length,\n-\n-\t\t\t\/\/ count of unprocessed arguments\n-\t\t\ti = remaining,\n-\n-\t\t\t\/\/ subordinate fulfillment data\n-\t\t\tresolveContexts = Array( i ),\n-\t\t\tresolveValues = slice.call( arguments ),\n-\n-\t\t\t\/\/ the primary Deferred\n-\t\t\tprimary = jQuery.Deferred(),\n-\n-\t\t\t\/\/ subordinate callback factory\n-\t\t\tupdateFunc = function( i ) {\n-\t\t\t\treturn function( value ) {\n-\t\t\t\t\tresolveContexts[ i ] = this;\n-\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n-\t\t\t\t\tif ( !( --remaining ) ) {\n-\t\t\t\t\t\tprimary.resolveWith( resolveContexts, resolveValues );\n-\t\t\t\t\t}\n-\t\t\t\t};\n-\t\t\t};\n-\n-\t\t\/\/ Single- and empty arguments are adopted like Promise.resolve\n-\t\tif ( remaining <= 1 ) {\n-\t\t\tadoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,\n-\t\t\t\t!remaining );\n-\n-\t\t\t\/\/ Use .then() to unwrap secondary thenables (cf. gh-3000)\n-\t\t\tif ( primary.state() === \"pending\" ||\n-\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n-\n-\t\t\t\treturn primary.then();\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Multiple arguments are aggregated like Promise.all array elements\n-\t\twhile ( i-- ) {\n-\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );\n-\t\t}\n-\n-\t\treturn primary.promise();\n-\t}\n-} );\n-\n-\n-\/\/ These usually indicate a programmer mistake during development,\n-\/\/ warn about them ASAP rather than swallowing them by default.\n-var rerrorNames = \/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$\/;\n-\n-jQuery.Deferred.exceptionHook = function( error, stack ) {\n-\n-\t\/\/ Support: IE 8 - 9 only\n-\t\/\/ Console exists when dev tools are open, which can happen at any time\n-\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n-\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n-\t}\n-};\n-\n-\n-\n-\n-jQuery.readyException = function( error ) {\n-\twindow.setTimeout( function() {\n-\t\tthrow error;\n-\t} );\n-};\n-\n-\n-\n-\n-\/\/ The deferred used on DOM ready\n-var readyList = jQuery.Deferred();\n-\n-jQuery.fn.ready = function( fn ) {\n-\n-\treadyList\n-\t\t.then( fn )\n-\n-\t\t\/\/ Wrap jQuery.readyException in a function so that the lookup\n-\t\t\/\/ happens at the time of error handling instead of callback\n-\t\t\/\/ registration.\n-\t\t.catch( function( error ) {\n-\t\t\tjQuery.readyException( error );\n-\t\t} );\n-\n-\treturn this;\n-};\n-\n-jQuery.extend( {\n-\n-\t\/\/ Is the DOM ready to be used? Set to true once it occurs.\n-\tisReady: false,\n-\n-\t\/\/ A counter to track how many items to wait for before\n-\t\/\/ the ready event fires. See trac-6781\n-\treadyWait: 1,\n-\n-\t\/\/ Handle when the DOM is ready\n-\tready: function( wait ) {\n-\n-\t\t\/\/ Abort if there are pending holds or we're already ready\n-\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t\/\/ Remember that the DOM is ready\n-\t\tjQuery.isReady = true;\n-\n-\t\t\/\/ If a normal DOM Ready event fired, decrement, and wait if need be\n-\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t\/\/ If there are functions bound, to execute\n-\t\treadyList.resolveWith( document, [ jQuery ] );\n-\t}\n-} );\n-\n-jQuery.ready.then = readyList.then;\n-\n-\/\/ The ready event handler and self cleanup method\n-function completed() {\n-\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n-\twindow.removeEventListener( \"load\", completed );\n-\tjQuery.ready();\n-}\n-\n-\/\/ Catch cases where $(document).ready() is called\n-\/\/ after the browser event has already occurred.\n-\/\/ Support: IE <=9 - 10 only\n-\/\/ Older IE sometimes signals \"interactive\" too soon\n-if ( document.readyState === \"complete\" ||\n-\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n-\n-\t\/\/ Handle it asynchronously to allow scripts the opportunity to delay ready\n-\twindow.setTimeout( jQuery.ready );\n-\n-} else {\n-\n-\t\/\/ Use the handy event callback\n-\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n-\n-\t\/\/ A fallback to window.onload, that will always work\n-\twindow.addEventListener( \"load\", completed );\n-}\n-\n-\n-\n-\n-\/\/ Multifunctional method to get and set values of a collection\n-\/\/ The value\/s can optionally be executed if it's a function\n-var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n-\tvar i = 0,\n-\t\tlen = elems.length,\n-\t\tbulk = key == null;\n-\n-\t\/\/ Sets many values\n-\tif ( toType( key ) === \"object\" ) {\n-\t\tchainable = true;\n-\t\tfor ( i in key ) {\n-\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n-\t\t}\n-\n-\t\/\/ Sets one value\n-\t} else if ( value !== undefined ) {\n-\t\tchainable = true;\n-\n-\t\tif ( !isFunction( value ) ) {\n-\t\t\traw = true;\n-\t\t}\n-\n-\t\tif ( bulk ) {\n-\n-\t\t\t\/\/ Bulk operations run against the entire set\n-\t\t\tif ( raw ) {\n-\t\t\t\tfn.call( elems, value );\n-\t\t\t\tfn = null;\n-\n-\t\t\t\/\/ ...except when executing function values\n-\t\t\t} else {\n-\t\t\t\tbulk = fn;\n-\t\t\t\tfn = function( elem, _key, value ) {\n-\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n-\t\t\t\t};\n-\t\t\t}\n-\t\t}\n-\n-\t\tif ( fn ) {\n-\t\t\tfor ( ; i < len; i++ ) {\n-\t\t\t\tfn(\n-\t\t\t\t\telems[ i ], key, raw ?\n-\t\t\t\t\t\tvalue :\n-\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n-\t\t\t\t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif ( chainable ) {\n-\t\treturn elems;\n-\t}\n-\n-\t\/\/ Gets\n-\tif ( bulk ) {\n-\t\treturn fn.call( elems );\n-\t}\n-\n-\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n-};\n-\n-\n-\/\/ Matches dashed string for camelizing\n-var rmsPrefix = \/^-ms-\/,\n-\trdashAlpha = \/-([a-z])\/g;\n-\n-\/\/ Used by camelCase as callback to replace()\n-function fcamelCase( _all, letter ) {\n-\treturn letter.toUpperCase();\n-}\n-\n-\/\/ Convert dashed to camelCase; used by the css and data modules\n-\/\/ Support: IE <=9 - 11, Edge 12 - 15\n-\/\/ Microsoft forgot to hump their vendor prefix (trac-9572)\n-function camelCase( string ) {\n-\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n-}\n-var acceptData = function( owner ) {\n-\n-\t\/\/ Accepts only:\n-\t\/\/  - Node\n-\t\/\/    - Node.ELEMENT_NODE\n-\t\/\/    - Node.DOCUMENT_NODE\n-\t\/\/  - Object\n-\t\/\/    - Any\n-\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n-};\n-\n-\n-\n-\n-function Data() {\n-\tthis.expando = jQuery.expando + Data.uid++;\n-}\n-\n-Data.uid = 1;\n-\n-Data.prototype = {\n-\n-\tcache: function( owner ) {\n-\n-\t\t\/\/ Check if the owner object already has a cache\n-\t\tvar value = owner[ this.expando ];\n-\n-\t\t\/\/ If not, create one\n-\t\tif ( !value ) {\n-\t\t\tvalue = {};\n-\n-\t\t\t\/\/ We can accept data for non-element nodes in modern browsers,\n-\t\t\t\/\/ but we should not, see trac-8335.\n-\t\t\t\/\/ Always return an empty object.\n-\t\t\tif ( acceptData( owner ) ) {\n-\n-\t\t\t\t\/\/ If it is a node unlikely to be stringify-ed or looped over\n-\t\t\t\t\/\/ use plain assignment\n-\t\t\t\tif ( owner.nodeType ) {\n-\t\t\t\t\towner[ this.expando ] = value;\n-\n-\t\t\t\t\/\/ Otherwise secure it in a non-enumerable property\n-\t\t\t\t\/\/ configurable must be true to allow the property to be\n-\t\t\t\t\/\/ deleted when data is removed\n-\t\t\t\t} else {\n-\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n-\t\t\t\t\t\tvalue: value,\n-\t\t\t\t\t\tconfigurable: true\n-\t\t\t\t\t} );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn value;\n-\t},\n-\tset: function( owner, data, value ) {\n-\t\tvar prop,\n-\t\t\tcache = this.cache( owner );\n-\n-\t\t\/\/ Handle: [ owner, key, value ] args\n-\t\t\/\/ Always use camelCase key (gh-2257)\n-\t\tif ( typeof data === \"string\" ) {\n-\t\t\tcache[ camelCase( data ) ] = value;\n-\n-\t\t\/\/ Handle: [ owner, { properties } ] args\n-\t\t} else {\n-\n-\t\t\t\/\/ Copy the properties one-by-one to the cache object\n-\t\t\tfor ( prop in data ) {\n-\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n-\t\t\t}\n-\t\t}\n-\t\treturn cache;\n-\t},\n-\tget: function( owner, key ) {\n-\t\treturn key === undefined ?\n-\t\t\tthis.cache( owner ) :\n-\n-\t\t\t\/\/ Always use camelCase key (gh-2257)\n-\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n-\t},\n-\taccess: function( owner, key, value ) {\n-\n-\t\t\/\/ In cases where either:\n-\t\t\/\/\n-\t\t\/\/   1. No key was specified\n-\t\t\/\/   2. A string key was specified, but no value provided\n-\t\t\/\/\n-\t\t\/\/ Take the \"read\" path and allow the get method to determine\n-\t\t\/\/ which value to return, respectively either:\n-\t\t\/\/\n-\t\t\/\/   1. The entire cache object\n-\t\t\/\/   2. The data stored at the key\n-\t\t\/\/\n-\t\tif ( key === undefined ||\n-\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n-\n-\t\t\treturn this.get( owner, key );\n-\t\t}\n-\n-\t\t\/\/ When the key is not a string, or both a key and value\n-\t\t\/\/ are specified, set or extend (existing objects) with either:\n-\t\t\/\/\n-\t\t\/\/   1. An object of properties\n-\t\t\/\/   2. A key and value\n-\t\t\/\/\n-\t\tthis.set( owner, key, value );\n-\n-\t\t\/\/ Since the \"set\" path can have two possible entry points\n-\t\t\/\/ return the expected data based on which path was taken[*]\n-\t\treturn value !== undefined ? value : key;\n-\t},\n-\tremove: function( owner, key ) {\n-\t\tvar i,\n-\t\t\tcache = owner[ this.expando ];\n-\n-\t\tif ( cache === undefined ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif ( key !== undefined ) {\n-\n-\t\t\t\/\/ Support array or space separated string of keys\n-\t\t\tif ( Array.isArray( key ) ) {\n-\n-\t\t\t\t\/\/ If key is an array of keys...\n-\t\t\t\t\/\/ We always set camelCase keys, so remove that.\n-\t\t\t\tkey = key.map( camelCase );\n-\t\t\t} else {\n-\t\t\t\tkey = camelCase( key );\n-\n-\t\t\t\t\/\/ If a key with the spaces exists, use it.\n-\t\t\t\t\/\/ Otherwise, create an array by matching non-whitespace\n-\t\t\t\tkey = key in cache ?\n-\t\t\t\t\t[ key ] :\n-\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n-\t\t\t}\n-\n-\t\t\ti = key.length;\n-\n-\t\t\twhile ( i-- ) {\n-\t\t\t\tdelete cache[ key[ i ] ];\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Remove the expando if there's no more data\n-\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n-\n-\t\t\t\/\/ Support: Chrome <=35 - 45\n-\t\t\t\/\/ Webkit & Blink performance suffers when deleting properties\n-\t\t\t\/\/ from DOM nodes, so set to undefined instead\n-\t\t\t\/\/ https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=378607 (bug restricted)\n-\t\t\tif ( owner.nodeType ) {\n-\t\t\t\towner[ this.expando ] = undefined;\n-\t\t\t} else {\n-\t\t\t\tdelete owner[ this.expando ];\n-\t\t\t}\n-\t\t}\n-\t},\n-\thasData: function( owner ) {\n-\t\tvar cache = owner[ this.expando ];\n-\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n-\t}\n-};\n-var dataPriv = new Data();\n-\n-var dataUser = new Data();\n-\n-\n-\n-\/\/\tImplementation Summary\n-\/\/\n-\/\/\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n-\/\/\t2. Improve the module's maintainability by reducing the storage\n-\/\/\t\tpaths to a single mechanism.\n-\/\/\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n-\/\/\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n-\/\/\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n-\/\/\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n-\n-var rbrace = \/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$\/,\n-\trmultiDash = \/[A-Z]\/g;\n-\n-function getData( data ) {\n-\tif ( data === \"true\" ) {\n-\t\treturn true;\n-\t}\n-\n-\tif ( data === \"false\" ) {\n-\t\treturn false;\n-\t}\n-\n-\tif ( data === \"null\" ) {\n-\t\treturn null;\n-\t}\n-\n-\t\/\/ Only convert to a number if it doesn't change the string\n-\tif ( data === +data + \"\" ) {\n-\t\treturn +data;\n-\t}\n-\n-\tif ( rbrace.test( data ) ) {\n-\t\treturn JSON.parse( data );\n-\t}\n-\n-\treturn data;\n-}\n-\n-function dataAttr( elem, key, data ) {\n-\tvar name;\n-\n-\t\/\/ If nothing was found internally, try to fetch any\n-\t\/\/ data from the HTML5 data-* attribute\n-\tif ( data === undefined && elem.nodeType === 1 ) {\n-\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n-\t\tdata = elem.getAttribute( name );\n-\n-\t\tif ( typeof data === \"string\" ) {\n-\t\t\ttry {\n-\t\t\t\tdata = getData( data );\n-\t\t\t} catch ( e ) {}\n-\n-\t\t\t\/\/ Make sure we set the data so it isn't changed later\n-\t\t\tdataUser.set( elem, key, data );\n-\t\t} else {\n-\t\t\tdata = undefined;\n-\t\t}\n-\t}\n-\treturn data;\n-}\n-\n-jQuery.extend( {\n-\thasData: function( elem ) {\n-\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n-\t},\n-\n-\tdata: function( elem, name, data ) {\n-\t\treturn dataUser.access( elem, name, data );\n-\t},\n-\n-\tremoveData: function( elem, name ) {\n-\t\tdataUser.remove( elem, name );\n-\t},\n-\n-\t\/\/ TODO: Now that all calls to _data and _removeData have been replaced\n-\t\/\/ with direct calls to dataPriv methods, these can be deprecated.\n-\t_data: function( elem, name, data ) {\n-\t\treturn dataPriv.access( elem, name, data );\n-\t},\n-\n-\t_removeData: function( elem, name ) {\n-\t\tdataPriv.remove( elem, name );\n-\t}\n-} );\n-\n-jQuery.fn.extend( {\n-\tdata: function( key, value ) {\n-\t\tvar i, name, data,\n-\t\t\telem = this[ 0 ],\n-\t\t\tattrs = elem && elem.attributes;\n-\n-\t\t\/\/ Gets all values\n-\t\tif ( key === undefined ) {\n-\t\t\tif ( this.length ) {\n-\t\t\t\tdata = dataUser.get( elem );\n-\n-\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n-\t\t\t\t\ti = attrs.length;\n-\t\t\t\t\twhile ( i-- ) {\n-\n-\t\t\t\t\t\t\/\/ Support: IE 11 only\n-\t\t\t\t\t\t\/\/ The attrs elements can be null (trac-14894)\n-\t\t\t\t\t\tif ( attrs[ i ] ) {\n-\t\t\t\t\t\t\tname = attrs[ i ].name;\n-\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n-\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n-\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\treturn data;\n-\t\t}\n-\n-\t\t\/\/ Sets multiple values\n-\t\tif ( typeof key === \"object\" ) {\n-\t\t\treturn this.each( function() {\n-\t\t\t\tdataUser.set( this, key );\n-\t\t\t} );\n-\t\t}\n-\n-\t\treturn access( this, function( value ) {\n-\t\t\tvar data;\n-\n-\t\t\t\/\/ The calling jQuery object (element matches) is not empty\n-\t\t\t\/\/ (and therefore has an element appears at this[ 0 ]) and the\n-\t\t\t\/\/ `value` parameter was not undefined. An empty jQuery object\n-\t\t\t\/\/ will result in `undefined` for elem = this[ 0 ] which will\n-\t\t\t\/\/ throw an exception if an attempt to read a data cache is made.\n-\t\t\tif ( elem && value === undefined ) {\n-\n-\t\t\t\t\/\/ Attempt to get data from the cache\n-\t\t\t\t\/\/ The key will always be camelCased in Data\n-\t\t\t\tdata = dataUser.get( elem, key );\n-\t\t\t\tif ( data !== undefined ) {\n-\t\t\t\t\treturn data;\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Attempt to \"discover\" the data in\n-\t\t\t\t\/\/ HTML5 custom data-* attrs\n-\t\t\t\tdata = dataAttr( elem, key );\n-\t\t\t\tif ( data !== undefined ) {\n-\t\t\t\t\treturn data;\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ We tried really hard, but the data doesn't exist.\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t\/\/ Set the data...\n-\t\t\tthis.each( function() {\n-\n-\t\t\t\t\/\/ We always store the camelCased key\n-\t\t\t\tdataUser.set( this, key, value );\n-\t\t\t} );\n-\t\t}, null, value, arguments.length > 1, null, true );\n-\t},\n-\n-\tremoveData: function( key ) {\n-\t\treturn this.each( function() {\n-\t\t\tdataUser.remove( this, key );\n-\t\t} );\n-\t}\n-} );\n-\n-\n-jQuery.extend( {\n-\tqueue: function( elem, type, data ) {\n-\t\tvar queue;\n-\n-\t\tif ( elem ) {\n-\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n-\t\t\tqueue = dataPriv.get( elem, type );\n-\n-\t\t\t\/\/ Speed up dequeue by getting out quickly if this is just a lookup\n-\t\t\tif ( data ) {\n-\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n-\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n-\t\t\t\t} else {\n-\t\t\t\t\tqueue.push( data );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn queue || [];\n-\t\t}\n-\t},\n-\n-\tdequeue: function( elem, type ) {\n-\t\ttype = type || \"fx\";\n-\n-\t\tvar queue = jQuery.queue( elem, type ),\n-\t\t\tstartLength = queue.length,\n-\t\t\tfn = queue.shift(),\n-\t\t\thooks = jQuery._queueHooks( elem, type ),\n-\t\t\tnext = function() {\n-\t\t\t\tjQuery.dequeue( elem, type );\n-\t\t\t};\n-\n-\t\t\/\/ If the fx queue is dequeued, always remove the progress sentinel\n-\t\tif ( fn === \"inprogress\" ) {\n-\t\t\tfn = queue.shift();\n-\t\t\tstartLength--;\n-\t\t}\n-\n-\t\tif ( fn ) {\n-\n-\t\t\t\/\/ Add a progress sentinel to prevent the fx queue from being\n-\t\t\t\/\/ automatically dequeued\n-\t\t\tif ( type === \"fx\" ) {\n-\t\t\t\tqueue.unshift( \"inprogress\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ Clear up the last queue stop function\n-\t\t\tdelete hooks.stop;\n-\t\t\tfn.call( elem, next, hooks );\n-\t\t}\n-\n-\t\tif ( !startLength && hooks ) {\n-\t\t\thooks.empty.fire();\n-\t\t}\n-\t},\n-\n-\t\/\/ Not public - generate a queueHooks object, or return the current one\n-\t_queueHooks: function( elem, type ) {\n-\t\tvar key = type + \"queueHooks\";\n-\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n-\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n-\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n-\t\t\t} )\n-\t\t} );\n-\t}\n-} );\n-\n-jQuery.fn.extend( {\n-\tqueue: function( type, data ) {\n-\t\tvar setter = 2;\n-\n-\t\tif ( typeof type !== \"string\" ) {\n-\t\t\tdata = type;\n-\t\t\ttype = \"fx\";\n-\t\t\tsetter--;\n-\t\t}\n-\n-\t\tif ( arguments.length < setter ) {\n-\t\t\treturn jQuery.queue( this[ 0 ], type );\n-\t\t}\n-\n-\t\treturn data === undefined ?\n-\t\t\tthis :\n-\t\t\tthis.each( function() {\n-\t\t\t\tvar queue = jQuery.queue( this, type, data );\n-\n-\t\t\t\t\/\/ Ensure a hooks for this queue\n-\t\t\t\tjQuery._queueHooks( this, type );\n-\n-\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n-\t\t\t\t\tjQuery.dequeue( this, type );\n-\t\t\t\t}\n-\t\t\t} );\n-\t},\n-\tdequeue: function( type ) {\n-\t\treturn this.each( function() {\n-\t\t\tjQuery.dequeue( this, type );\n-\t\t} );\n-\t},\n-\tclearQueue: function( type ) {\n-\t\treturn this.queue( type || \"fx\", [] );\n-\t},\n-\n-\t\/\/ Get a promise resolved when queues of a certain type\n-\t\/\/ are emptied (fx is the type by default)\n-\tpromise: function( type, obj ) {\n-\t\tvar tmp,\n-\t\t\tcount = 1,\n-\t\t\tdefer = jQuery.Deferred(),\n-\t\t\telements = this,\n-\t\t\ti = this.length,\n-\t\t\tresolve = function() {\n-\t\t\t\tif ( !( --count ) ) {\n-\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\tif ( typeof type !== \"string\" ) {\n-\t\t\tobj = type;\n-\t\t\ttype = undefined;\n-\t\t}\n-\t\ttype = type || \"fx\";\n-\n-\t\twhile ( i-- ) {\n-\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n-\t\t\tif ( tmp && tmp.empty ) {\n-\t\t\t\tcount++;\n-\t\t\t\ttmp.empty.add( resolve );\n-\t\t\t}\n-\t\t}\n-\t\tresolve();\n-\t\treturn defer.promise( obj );\n-\t}\n-} );\n-var pnum = ( \/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)\/ ).source;\n-\n-var rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n-\n-\n-var cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n-\n-var documentElement = document.documentElement;\n-\n-\n-\n-\tvar isAttached = function( elem ) {\n-\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n-\t\t},\n-\t\tcomposed = { composed: true };\n-\n-\t\/\/ Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n-\t\/\/ Check attachment across shadow DOM boundaries when possible (gh-3504)\n-\t\/\/ Support: iOS 10.0-10.2 only\n-\t\/\/ Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n-\t\/\/ leading to errors. We need to check for `getRootNode`.\n-\tif ( documentElement.getRootNode ) {\n-\t\tisAttached = function( elem ) {\n-\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n-\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n-\t\t};\n-\t}\n-var isHiddenWithinTree = function( elem, el ) {\n-\n-\t\t\/\/ isHiddenWithinTree might be called from jQuery#filter function;\n-\t\t\/\/ in that case, element will be second argument\n-\t\telem = el || elem;\n-\n-\t\t\/\/ Inline style trumps all\n-\t\treturn elem.style.display === \"none\" ||\n-\t\t\telem.style.display === \"\" &&\n-\n-\t\t\t\/\/ Otherwise, check computed style\n-\t\t\t\/\/ Support: Firefox <=43 - 45\n-\t\t\t\/\/ Disconnected elements can have computed display: none, so first confirm that elem is\n-\t\t\t\/\/ in the document.\n-\t\t\tisAttached( elem ) &&\n-\n-\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n-\t};\n-\n-\n-\n-function adjustCSS( elem, prop, valueParts, tween ) {\n-\tvar adjusted, scale,\n-\t\tmaxIterations = 20,\n-\t\tcurrentValue = tween ?\n-\t\t\tfunction() {\n-\t\t\t\treturn tween.cur();\n-\t\t\t} :\n-\t\t\tfunction() {\n-\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n-\t\t\t},\n-\t\tinitial = currentValue(),\n-\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n-\n-\t\t\/\/ Starting value computation is required for potential unit mismatches\n-\t\tinitialInUnit = elem.nodeType &&\n-\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n-\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n-\n-\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n-\n-\t\t\/\/ Support: Firefox <=54\n-\t\t\/\/ Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n-\t\tinitial = initial \/ 2;\n-\n-\t\t\/\/ Trust units reported by jQuery.css\n-\t\tunit = unit || initialInUnit[ 3 ];\n-\n-\t\t\/\/ Iteratively approximate from a nonzero starting point\n-\t\tinitialInUnit = +initial || 1;\n-\n-\t\twhile ( maxIterations-- ) {\n-\n-\t\t\t\/\/ Evaluate and update our best guess (doubling guesses that zero out).\n-\t\t\t\/\/ Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n-\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n-\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() \/ initial || 0.5 ) ) <= 0 ) {\n-\t\t\t\tmaxIterations = 0;\n-\t\t\t}\n-\t\t\tinitialInUnit = initialInUnit \/ scale;\n-\n-\t\t}\n-\n-\t\tinitialInUnit = initialInUnit * 2;\n-\t\tjQuery.style( elem, prop, initialInUnit + unit );\n-\n-\t\t\/\/ Make sure we update the tween properties later on\n-\t\tvalueParts = valueParts || [];\n-\t}\n-\n-\tif ( valueParts ) {\n-\t\tinitialInUnit = +initialInUnit || +initial || 0;\n-\n-\t\t\/\/ Apply relative offset (+=\/-=) if specified\n-\t\tadjusted = valueParts[ 1 ] ?\n-\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n-\t\t\t+valueParts[ 2 ];\n-\t\tif ( tween ) {\n-\t\t\ttween.unit = unit;\n-\t\t\ttween.start = initialInUnit;\n-\t\t\ttween.end = adjusted;\n-\t\t}\n-\t}\n-\treturn adjusted;\n-}\n-\n-\n-var defaultDisplayMap = {};\n-\n-function getDefaultDisplay( elem ) {\n-\tvar temp,\n-\t\tdoc = elem.ownerDocument,\n-\t\tnodeName = elem.nodeName,\n-\t\tdisplay = defaultDisplayMap[ nodeName ];\n-\n-\tif ( display ) {\n-\t\treturn display;\n-\t}\n-\n-\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n-\tdisplay = jQuery.css( temp, \"display\" );\n-\n-\ttemp.parentNode.removeChild( temp );\n-\n-\tif ( display === \"none\" ) {\n-\t\tdisplay = \"block\";\n-\t}\n-\tdefaultDisplayMap[ nodeName ] = display;\n-\n-\treturn display;\n-}\n-\n-function showHide( elements, show ) {\n-\tvar display, elem,\n-\t\tvalues = [],\n-\t\tindex = 0,\n-\t\tlength = elements.length;\n-\n-\t\/\/ Determine new display value for elements that need to change\n-\tfor ( ; index < length; index++ ) {\n-\t\telem = elements[ index ];\n-\t\tif ( !elem.style ) {\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tdisplay = elem.style.display;\n-\t\tif ( show ) {\n-\n-\t\t\t\/\/ Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n-\t\t\t\/\/ check is required in this first loop unless we have a nonempty display value (either\n-\t\t\t\/\/ inline or about-to-be-restored)\n-\t\t\tif ( display === \"none\" ) {\n-\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n-\t\t\t\tif ( !values[ index ] ) {\n-\t\t\t\t\telem.style.display = \"\";\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n-\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif ( display !== \"none\" ) {\n-\t\t\t\tvalues[ index ] = \"none\";\n-\n-\t\t\t\t\/\/ Remember what we're overwriting\n-\t\t\t\tdataPriv.set( elem, \"display\", display );\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t\/\/ Set the display of the elements in a second loop to avoid constant reflow\n-\tfor ( index = 0; index < length; index++ ) {\n-\t\tif ( values[ index ] != null ) {\n-\t\t\telements[ index ].style.display = values[ index ];\n-\t\t}\n-\t}\n-\n-\treturn elements;\n-}\n-\n-jQuery.fn.extend( {\n-\tshow: function() {\n-\t\treturn showHide( this, true );\n-\t},\n-\thide: function() {\n-\t\treturn showHide( this );\n-\t},\n-\ttoggle: function( state ) {\n-\t\tif ( typeof state === \"boolean\" ) {\n-\t\t\treturn state ? this.show() : this.hide();\n-\t\t}\n-\n-\t\treturn this.each( function() {\n-\t\t\tif ( isHiddenWithinTree( this ) ) {\n-\t\t\t\tjQuery( this ).show();\n-\t\t\t} else {\n-\t\t\t\tjQuery( this ).hide();\n-\t\t\t}\n-\t\t} );\n-\t}\n-} );\n-var rcheckableType = ( \/^(?:checkbox|radio)$\/i );\n-\n-var rtagName = ( \/<([a-z][^\\\/\\0>\\x20\\t\\r\\n\\f]*)\/i );\n-\n-var rscriptType = ( \/^$|^module$|\\\/(?:java|ecma)script\/i );\n-\n-\n-\n-( function() {\n-\tvar fragment = document.createDocumentFragment(),\n-\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n-\t\tinput = document.createElement( \"input\" );\n-\n-\t\/\/ Support: Android 4.0 - 4.3 only\n-\t\/\/ Check state lost if the name is set (trac-11217)\n-\t\/\/ Support: Windows Web Apps (WWA)\n-\t\/\/ `name` and `type` must use .setAttribute for WWA (trac-14901)\n-\tinput.setAttribute( \"type\", \"radio\" );\n-\tinput.setAttribute( \"checked\", \"checked\" );\n-\tinput.setAttribute( \"name\", \"t\" );\n-\n-\tdiv.appendChild( input );\n-\n-\t\/\/ Support: Android <=4.1 only\n-\t\/\/ Older WebKit doesn't clone checked state correctly in fragments\n-\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n-\n-\t\/\/ Support: IE <=11 only\n-\t\/\/ Make sure textarea (and checkbox) defaultValue is properly cloned\n-\tdiv.innerHTML = \"<textarea>x<\/textarea>\";\n-\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n-\n-\t\/\/ Support: IE <=9 only\n-\t\/\/ IE <=9 replaces <option> tags with their contents when inserted outside of\n-\t\/\/ the select element.\n-\tdiv.innerHTML = \"<option><\/option>\";\n-\tsupport.option = !!div.lastChild;\n-} )();\n-\n-\n-\/\/ We have to close these tags to support XHTML (trac-13200)\n-var wrapMap = {\n-\n-\t\/\/ XHTML parsers do not magically insert elements in the\n-\t\/\/ same way that tag soup parsers do. So we cannot shorten\n-\t\/\/ this by omitting <tbody> or other required elements.\n-\tthead: [ 1, \"<table>\", \"<\/table>\" ],\n-\tcol: [ 2, \"<table><colgroup>\", \"<\/colgroup><\/table>\" ],\n-\ttr: [ 2, \"<table><tbody>\", \"<\/tbody><\/table>\" ],\n-\ttd: [ 3, \"<table><tbody><tr>\", \"<\/tr><\/tbody><\/table>\" ],\n-\n-\t_default: [ 0, \"\", \"\" ]\n-};\n-\n-wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n-wrapMap.th = wrapMap.td;\n-\n-\/\/ Support: IE <=9 only\n-if ( !support.option ) {\n-\twrapMap.optgroup = wrapMap.option = [ 1, \"<select multiple='multiple'>\", \"<\/select>\" ];\n-}\n-\n-\n-function getAll( context, tag ) {\n-\n-\t\/\/ Support: IE <=9 - 11 only\n-\t\/\/ Use typeof to avoid zero-argument method invocation on host objects (trac-15151)\n-\tvar ret;\n-\n-\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n-\t\tret = context.getElementsByTagName( tag || \"*\" );\n-\n-\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n-\t\tret = context.querySelectorAll( tag || \"*\" );\n-\n-\t} else {\n-\t\tret = [];\n-\t}\n-\n-\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n-\t\treturn jQuery.merge( [ context ], ret );\n-\t}\n-\n-\treturn ret;\n-}\n-\n-\n-\/\/ Mark scripts as having already been evaluated\n-function setGlobalEval( elems, refElements ) {\n-\tvar i = 0,\n-\t\tl = elems.length;\n-\n-\tfor ( ; i < l; i++ ) {\n-\t\tdataPriv.set(\n-\t\t\telems[ i ],\n-\t\t\t\"globalEval\",\n-\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n-\t\t);\n-\t}\n-}\n-\n-\n-var rhtml = \/<|&#?\\w+;\/;\n-\n-function buildFragment( elems, context, scripts, selection, ignored ) {\n-\tvar elem, tmp, tag, wrap, attached, j,\n-\t\tfragment = context.createDocumentFragment(),\n-\t\tnodes = [],\n-\t\ti = 0,\n-\t\tl = elems.length;\n-\n-\tfor ( ; i < l; i++ ) {\n-\t\telem = elems[ i ];\n-\n-\t\tif ( elem || elem === 0 ) {\n-\n-\t\t\t\/\/ Add nodes directly\n-\t\t\tif ( toType( elem ) === \"object\" ) {\n-\n-\t\t\t\t\/\/ Support: Android <=4.0 only, PhantomJS 1 only\n-\t\t\t\t\/\/ push.apply(_, arraylike) throws on ancient WebKit\n-\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n-\n-\t\t\t\/\/ Convert non-html into a text node\n-\t\t\t} else if ( !rhtml.test( elem ) ) {\n-\t\t\t\tnodes.push( context.createTextNode( elem ) );\n-\n-\t\t\t\/\/ Convert html into DOM nodes\n-\t\t\t} else {\n-\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n-\n-\t\t\t\t\/\/ Deserialize a standard representation\n-\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n-\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n-\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n-\n-\t\t\t\t\/\/ Descend through wrappers to the right content\n-\t\t\t\tj = wrap[ 0 ];\n-\t\t\t\twhile ( j-- ) {\n-\t\t\t\t\ttmp = tmp.lastChild;\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Support: Android <=4.0 only, PhantomJS 1 only\n-\t\t\t\t\/\/ push.apply(_, arraylike) throws on ancient WebKit\n-\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n-\n-\t\t\t\t\/\/ Remember the top-level container\n-\t\t\t\ttmp = fragment.firstChild;\n-\n-\t\t\t\t\/\/ Ensure the created nodes are orphaned (trac-12392)\n-\t\t\t\ttmp.textContent = \"\";\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t\/\/ Remove wrapper from fragment\n-\tfragment.textContent = \"\";\n-\n-\ti = 0;\n-\twhile ( ( elem = nodes[ i++ ] ) ) {\n-\n-\t\t\/\/ Skip elements already in the context collection (trac-4087)\n-\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n-\t\t\tif ( ignored ) {\n-\t\t\t\tignored.push( elem );\n-\t\t\t}\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tattached = isAttached( elem );\n-\n-\t\t\/\/ Append to fragment\n-\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n-\n-\t\t\/\/ Preserve script evaluation history\n-\t\tif ( attached ) {\n-\t\t\tsetGlobalEval( tmp );\n-\t\t}\n-\n-\t\t\/\/ Capture executables\n-\t\tif ( scripts ) {\n-\t\t\tj = 0;\n-\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n-\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n-\t\t\t\t\tscripts.push( elem );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn fragment;\n-}\n-\n-\n-var rtypenamespace = \/^([^.]*)(?:\\.(.+)|)\/;\n-\n-function returnTrue() {\n-\treturn true;\n-}\n-\n-function returnFalse() {\n-\treturn false;\n-}\n-\n-\/\/ Support: IE <=9 - 11+\n-\/\/ focus() and blur() are asynchronous, except when they are no-op.\n-\/\/ So expect focus to be synchronous when the element is already active,\n-\/\/ and blur to be synchronous when the element is not already active.\n-\/\/ (focus and blur are always synchronous in other supported browsers,\n-\/\/ this just defines when we can count on it).\n-function expectSync( elem, type ) {\n-\treturn ( elem === safeActiveElement() ) === ( type === \"focus\" );\n-}\n-\n-\/\/ Support: IE <=9 only\n-\/\/ Accessing document.activeElement can throw unexpectedly\n-\/\/ https:\/\/bugs.jquery.com\/ticket\/13393\n-function safeActiveElement() {\n-\ttry {\n-\t\treturn document.activeElement;\n-\t} catch ( err ) { }\n-}\n-\n-function on( elem, types, selector, data, fn, one ) {\n-\tvar origFn, type;\n-\n-\t\/\/ Types can be a map of types\/handlers\n-\tif ( typeof types === \"object\" ) {\n-\n-\t\t\/\/ ( types-Object, selector, data )\n-\t\tif ( typeof selector !== \"string\" ) {\n-\n-\t\t\t\/\/ ( types-Object, data )\n-\t\t\tdata = data || selector;\n-\t\t\tselector = undefined;\n-\t\t}\n-\t\tfor ( type in types ) {\n-\t\t\ton( elem, type, selector, data, types[ type ], one );\n-\t\t}\n-\t\treturn elem;\n-\t}\n-\n-\tif ( data == null && fn == null ) {\n-\n-\t\t\/\/ ( types, fn )\n-\t\tfn = selector;\n-\t\tdata = selector = undefined;\n-\t} else if ( fn == null ) {\n-\t\tif ( typeof selector === \"string\" ) {\n-\n-\t\t\t\/\/ ( types, selector, fn )\n-\t\t\tfn = data;\n-\t\t\tdata = undefined;\n-\t\t} else {\n-\n-\t\t\t\/\/ ( types, data, fn )\n-\t\t\tfn = data;\n-\t\t\tdata = selector;\n-\t\t\tselector = undefined;\n-\t\t}\n-\t}\n-\tif ( fn === false ) {\n-\t\tfn = returnFalse;\n-\t} else if ( !fn ) {\n-\t\treturn elem;\n-\t}\n-\n-\tif ( one === 1 ) {\n-\t\torigFn = fn;\n-\t\tfn = function( event ) {\n-\n-\t\t\t\/\/ Can use an empty set, since event contains the info\n-\t\t\tjQuery().off( event );\n-\t\t\treturn origFn.apply( this, arguments );\n-\t\t};\n-\n-\t\t\/\/ Use same guid so caller can remove using origFn\n-\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n-\t}\n-\treturn elem.each( function() {\n-\t\tjQuery.event.add( this, types, fn, data, selector );\n-\t} );\n-}\n-\n-\/*\n- * Helper functions for managing events -- not part of the public interface.\n- * Props to Dean Edwards' addEvent library for many of the ideas.\n- *\/\n-jQuery.event = {\n-\n-\tglobal: {},\n-\n-\tadd: function( elem, types, handler, data, selector ) {\n-\n-\t\tvar handleObjIn, eventHandle, tmp,\n-\t\t\tevents, t, handleObj,\n-\t\t\tspecial, handlers, type, namespaces, origType,\n-\t\t\telemData = dataPriv.get( elem );\n-\n-\t\t\/\/ Only attach events to objects that accept data\n-\t\tif ( !acceptData( elem ) ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t\/\/ Caller can pass in an object of custom data in lieu of the handler\n-\t\tif ( handler.handler ) {\n-\t\t\thandleObjIn = handler;\n-\t\t\thandler = handleObjIn.handler;\n-\t\t\tselector = handleObjIn.selector;\n-\t\t}\n-\n-\t\t\/\/ Ensure that invalid selectors throw exceptions at attach time\n-\t\t\/\/ Evaluate against documentElement in case elem is a non-element node (e.g., document)\n-\t\tif ( selector ) {\n-\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n-\t\t}\n-\n-\t\t\/\/ Make sure that the handler has a unique ID, used to find\/remove it later\n-\t\tif ( !handler.guid ) {\n-\t\t\thandler.guid = jQuery.guid++;\n-\t\t}\n-\n-\t\t\/\/ Init the element's event structure and main handler, if this is the first\n-\t\tif ( !( events = elemData.events ) ) {\n-\t\t\tevents = elemData.events = Object.create( null );\n-\t\t}\n-\t\tif ( !( eventHandle = elemData.handle ) ) {\n-\t\t\teventHandle = elemData.handle = function( e ) {\n-\n-\t\t\t\t\/\/ Discard the second event of a jQuery.event.trigger() and\n-\t\t\t\t\/\/ when an event is called after a page has unloaded\n-\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n-\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n-\t\t\t};\n-\t\t}\n-\n-\t\t\/\/ Handle multiple events separated by a space\n-\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n-\t\tt = types.length;\n-\t\twhile ( t-- ) {\n-\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n-\t\t\ttype = origType = tmp[ 1 ];\n-\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n-\n-\t\t\t\/\/ There *must* be a type, no attaching namespace-only handlers\n-\t\t\tif ( !type ) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t\/\/ If event changes its type, use the special event handlers for the changed type\n-\t\t\tspecial = jQuery.event.special[ type ] || {};\n-\n-\t\t\t\/\/ If selector defined, determine special event api type, otherwise given type\n-\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n-\n-\t\t\t\/\/ Update special based on newly reset type\n-\t\t\tspecial = jQuery.event.special[ type ] || {};\n-\n-\t\t\t\/\/ handleObj is passed to all event handlers\n-\t\t\thandleObj = jQuery.extend( {\n-\t\t\t\ttype: type,\n-\t\t\t\torigType: origType,\n-\t\t\t\tdata: data,\n-\t\t\t\thandler: handler,\n-\t\t\t\tguid: handler.guid,\n-\t\t\t\tselector: selector,\n-\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n-\t\t\t\tnamespace: namespaces.join( \".\" )\n-\t\t\t}, handleObjIn );\n-\n-\t\t\t\/\/ Init the event handler queue if we're the first\n-\t\t\tif ( !( handlers = events[ type ] ) ) {\n-\t\t\t\thandlers = events[ type ] = [];\n-\t\t\t\thandlers.delegateCount = 0;\n-\n-\t\t\t\t\/\/ Only use addEventListener if the special events handler returns false\n-\t\t\t\tif ( !special.setup ||\n-\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n-\n-\t\t\t\t\tif ( elem.addEventListener ) {\n-\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif ( special.add ) {\n-\t\t\t\tspecial.add.call( elem, handleObj );\n-\n-\t\t\t\tif ( !handleObj.handler.guid ) {\n-\t\t\t\t\thandleObj.handler.guid = handler.guid;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t\/\/ Add to the element's handler list, delegates in front\n-\t\t\tif ( selector ) {\n-\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n-\t\t\t} else {\n-\t\t\t\thandlers.push( handleObj );\n-\t\t\t}\n-\n-\t\t\t\/\/ Keep track of which events have ever been used, for event optimization\n-\t\t\tjQuery.event.global[ type ] = true;\n-\t\t}\n-\n-\t},\n-\n-\t\/\/ Detach an event or set of events from an element\n-\tremove: function( elem, types, handler, selector, mappedTypes ) {\n-\n-\t\tvar j, origCount, tmp,\n-\t\t\tevents, t, handleObj,\n-\t\t\tspecial, handlers, type, namespaces, origType,\n-\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n-\n-\t\tif ( !elemData || !( events = elemData.events ) ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t\/\/ Once for each type.namespace in types; type may be omitted\n-\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n-\t\tt = types.length;\n-\t\twhile ( t-- ) {\n-\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n-\t\t\ttype = origType = tmp[ 1 ];\n-\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n-\n-\t\t\t\/\/ Unbind all events (on this namespace, if provided) for the element\n-\t\t\tif ( !type ) {\n-\t\t\t\tfor ( type in events ) {\n-\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n-\t\t\t\t}\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tspecial = jQuery.event.special[ type ] || {};\n-\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n-\t\t\thandlers = events[ type ] || [];\n-\t\t\ttmp = tmp[ 2 ] &&\n-\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n-\n-\t\t\t\/\/ Remove matching events\n-\t\t\torigCount = j = handlers.length;\n-\t\t\twhile ( j-- ) {\n-\t\t\t\thandleObj = handlers[ j ];\n-\n-\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n-\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n-\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n-\t\t\t\t\t( !selector || selector === handleObj.selector ||\n-\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n-\t\t\t\t\thandlers.splice( j, 1 );\n-\n-\t\t\t\t\tif ( handleObj.selector ) {\n-\t\t\t\t\t\thandlers.delegateCount--;\n-\t\t\t\t\t}\n-\t\t\t\t\tif ( special.remove ) {\n-\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t\/\/ Remove generic event handler if we removed something and no more handlers exist\n-\t\t\t\/\/ (avoids potential for endless recursion during removal of special event handlers)\n-\t\t\tif ( origCount && !handlers.length ) {\n-\t\t\t\tif ( !special.teardown ||\n-\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n-\n-\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n-\t\t\t\t}\n-\n-\t\t\t\tdelete events[ type ];\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Remove data and the expando if it's no longer used\n-\t\tif ( jQuery.isEmptyObject( events ) ) {\n-\t\t\tdataPriv.remove( elem, \"handle events\" );\n-\t\t}\n-\t},\n-\n-\tdispatch: function( nativeEvent ) {\n-\n-\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n-\t\t\targs = new Array( arguments.length ),\n-\n-\t\t\t\/\/ Make a writable jQuery.Event from the native event object\n-\t\t\tevent = jQuery.event.fix( nativeEvent ),\n-\n-\t\t\thandlers = (\n-\t\t\t\tdataPriv.get( this, \"events\" ) || Object.create( null )\n-\t\t\t)[ event.type ] || [],\n-\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n-\n-\t\t\/\/ Use the fix-ed jQuery.Event rather than the (read-only) native event\n-\t\targs[ 0 ] = event;\n-\n-\t\tfor ( i = 1; i < arguments.length; i++ ) {\n-\t\t\targs[ i ] = arguments[ i ];\n-\t\t}\n-\n-\t\tevent.delegateTarget = this;\n-\n-\t\t\/\/ Call the preDispatch hook for the mapped type, and let it bail if desired\n-\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t\/\/ Determine handlers\n-\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n-\n-\t\t\/\/ Run delegates first; they may want to stop propagation beneath us\n-\t\ti = 0;\n-\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n-\t\t\tevent.currentTarget = matched.elem;\n-\n-\t\t\tj = 0;\n-\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n-\t\t\t\t!event.isImmediatePropagationStopped() ) {\n-\n-\t\t\t\t\/\/ If the event is namespaced, then each handler is only invoked if it is\n-\t\t\t\t\/\/ specially universal or its namespaces are a superset of the event's.\n-\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n-\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n-\n-\t\t\t\t\tevent.handleObj = handleObj;\n-\t\t\t\t\tevent.data = handleObj.data;\n-\n-\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n-\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n-\n-\t\t\t\t\tif ( ret !== undefined ) {\n-\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n-\t\t\t\t\t\t\tevent.preventDefault();\n-\t\t\t\t\t\t\tevent.stopPropagation();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Call the postDispatch hook for the mapped type\n-\t\tif ( special.postDispatch ) {\n-\t\t\tspecial.postDispatch.call( this, event );\n-\t\t}\n-\n-\t\treturn event.result;\n-\t},\n-\n-\thandlers: function( event, handlers ) {\n-\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n-\t\t\thandlerQueue = [],\n-\t\t\tdelegateCount = handlers.delegateCount,\n-\t\t\tcur = event.target;\n-\n-\t\t\/\/ Find delegate handlers\n-\t\tif ( delegateCount &&\n-\n-\t\t\t\/\/ Support: IE <=9\n-\t\t\t\/\/ Black-hole SVG <use> instance trees (trac-13180)\n-\t\t\tcur.nodeType &&\n-\n-\t\t\t\/\/ Support: Firefox <=42\n-\t\t\t\/\/ Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n-\t\t\t\/\/ https:\/\/www.w3.org\/TR\/DOM-Level-3-Events\/#event-type-click\n-\t\t\t\/\/ Support: IE 11 only\n-\t\t\t\/\/ ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n-\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n-\n-\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n-\n-\t\t\t\t\/\/ Don't check non-elements (trac-13208)\n-\t\t\t\t\/\/ Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n-\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n-\t\t\t\t\tmatchedHandlers = [];\n-\t\t\t\t\tmatchedSelectors = {};\n-\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n-\t\t\t\t\t\thandleObj = handlers[ i ];\n-\n-\t\t\t\t\t\t\/\/ Don't conflict with Object.prototype properties (trac-13203)\n-\t\t\t\t\t\tsel = handleObj.selector + \" \";\n-\n-\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n-\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n-\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n-\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n-\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif ( matchedHandlers.length ) {\n-\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Add the remaining (directly-bound) handlers\n-\t\tcur = this;\n-\t\tif ( delegateCount < handlers.length ) {\n-\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n-\t\t}\n-\n-\t\treturn handlerQueue;\n-\t},\n-\n-\taddProp: function( name, hook ) {\n-\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n-\t\t\tenumerable: true,\n-\t\t\tconfigurable: true,\n-\n-\t\t\tget: isFunction( hook ) ?\n-\t\t\t\tfunction() {\n-\t\t\t\t\tif ( this.originalEvent ) {\n-\t\t\t\t\t\treturn hook( this.originalEvent );\n-\t\t\t\t\t}\n-\t\t\t\t} :\n-\t\t\t\tfunction() {\n-\t\t\t\t\tif ( this.originalEvent ) {\n-\t\t\t\t\t\treturn this.originalEvent[ name ];\n-\t\t\t\t\t}\n-\t\t\t\t},\n-\n-\t\t\tset: function( value ) {\n-\t\t\t\tObject.defineProperty( this, name, {\n-\t\t\t\t\tenumerable: true,\n-\t\t\t\t\tconfigurable: true,\n-\t\t\t\t\twritable: true,\n-\t\t\t\t\tvalue: value\n-\t\t\t\t} );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tfix: function( originalEvent ) {\n-\t\treturn originalEvent[ jQuery.expando ] ?\n-\t\t\toriginalEvent :\n-\t\t\tnew jQuery.Event( originalEvent );\n-\t},\n-\n-\tspecial: {\n-\t\tload: {\n-\n-\t\t\t\/\/ Prevent triggered image.load events from bubbling to window.load\n-\t\t\tnoBubble: true\n-\t\t},\n-\t\tclick: {\n-\n-\t\t\t\/\/ Utilize native event to ensure correct state for checkable inputs\n-\t\t\tsetup: function( data ) {\n-\n-\t\t\t\t\/\/ For mutual compressibility with _default, replace `this` access with a local var.\n-\t\t\t\t\/\/ `|| data` is dead code meant only to preserve the variable through minification.\n-\t\t\t\tvar el = this || data;\n-\n-\t\t\t\t\/\/ Claim the first handler\n-\t\t\t\tif ( rcheckableType.test( el.type ) &&\n-\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n-\n-\t\t\t\t\t\/\/ dataPriv.set( el, \"click\", ... )\n-\t\t\t\t\tleverageNative( el, \"click\", returnTrue );\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Return false to allow normal processing in the caller\n-\t\t\t\treturn false;\n-\t\t\t},\n-\t\t\ttrigger: function( data ) {\n-\n-\t\t\t\t\/\/ For mutual compressibility with _default, replace `this` access with a local var.\n-\t\t\t\t\/\/ `|| data` is dead code meant only to preserve the variable through minification.\n-\t\t\t\tvar el = this || data;\n-\n-\t\t\t\t\/\/ Force setup before triggering a click\n-\t\t\t\tif ( rcheckableType.test( el.type ) &&\n-\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n-\n-\t\t\t\t\tleverageNative( el, \"click\" );\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Return non-false to allow normal event-path propagation\n-\t\t\t\treturn true;\n-\t\t\t},\n-\n-\t\t\t\/\/ For cross-browser consistency, suppress native .click() on links\n-\t\t\t\/\/ Also prevent it if we're currently inside a leveraged native-event stack\n-\t\t\t_default: function( event ) {\n-\t\t\t\tvar target = event.target;\n-\t\t\t\treturn rcheckableType.test( target.type ) &&\n-\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n-\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n-\t\t\t\t\tnodeName( target, \"a\" );\n-\t\t\t}\n-\t\t},\n-\n-\t\tbeforeunload: {\n-\t\t\tpostDispatch: function( event ) {\n-\n-\t\t\t\t\/\/ Support: Firefox 20+\n-\t\t\t\t\/\/ Firefox doesn't alert if the returnValue field is not set.\n-\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n-\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-};\n-\n-\/\/ Ensure the presence of an event listener that handles manually-triggered\n-\/\/ synthetic events by interrupting progress until reinvoked in response to\n-\/\/ *native* events that it fires directly, ensuring that state changes have\n-\/\/ already occurred before other listeners are invoked.\n-function leverageNative( el, type, expectSync ) {\n-\n-\t\/\/ Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n-\tif ( !expectSync ) {\n-\t\tif ( dataPriv.get( el, type ) === undefined ) {\n-\t\t\tjQuery.event.add( el, type, returnTrue );\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\t\/\/ Register the controller as a special universal handler for all event namespaces\n-\tdataPriv.set( el, type, false );\n-\tjQuery.event.add( el, type, {\n-\t\tnamespace: false,\n-\t\thandler: function( event ) {\n-\t\t\tvar notAsync, result,\n-\t\t\t\tsaved = dataPriv.get( this, type );\n-\n-\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n-\n-\t\t\t\t\/\/ Interrupt processing of the outer synthetic .trigger()ed event\n-\t\t\t\t\/\/ Saved data should be false in such cases, but might be a leftover capture object\n-\t\t\t\t\/\/ from an async native handler (gh-4350)\n-\t\t\t\tif ( !saved.length ) {\n-\n-\t\t\t\t\t\/\/ Store arguments for use when handling the inner native event\n-\t\t\t\t\t\/\/ There will always be at least one argument (an event object), so this array\n-\t\t\t\t\t\/\/ will not be confused with a leftover capture object.\n-\t\t\t\t\tsaved = slice.call( arguments );\n-\t\t\t\t\tdataPriv.set( this, type, saved );\n-\n-\t\t\t\t\t\/\/ Trigger the native event and capture its result\n-\t\t\t\t\t\/\/ Support: IE <=9 - 11+\n-\t\t\t\t\t\/\/ focus() and blur() are asynchronous\n-\t\t\t\t\tnotAsync = expectSync( this, type );\n-\t\t\t\t\tthis[ type ]();\n-\t\t\t\t\tresult = dataPriv.get( this, type );\n-\t\t\t\t\tif ( saved !== result || notAsync ) {\n-\t\t\t\t\t\tdataPriv.set( this, type, false );\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tresult = {};\n-\t\t\t\t\t}\n-\t\t\t\t\tif ( saved !== result ) {\n-\n-\t\t\t\t\t\t\/\/ Cancel the outer synthetic event\n-\t\t\t\t\t\tevent.stopImmediatePropagation();\n-\t\t\t\t\t\tevent.preventDefault();\n-\n-\t\t\t\t\t\t\/\/ Support: Chrome 86+\n-\t\t\t\t\t\t\/\/ In Chrome, if an element having a focusout handler is blurred by\n-\t\t\t\t\t\t\/\/ clicking outside of it, it invokes the handler synchronously. If\n-\t\t\t\t\t\t\/\/ that handler calls `.remove()` on the element, the data is cleared,\n-\t\t\t\t\t\t\/\/ leaving `result` undefined. We need to guard against this.\n-\t\t\t\t\t\treturn result && result.value;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\/\/ If this is an inner synthetic event for an event with a bubbling surrogate\n-\t\t\t\t\/\/ (focus or blur), assume that the surrogate already propagated from triggering the\n-\t\t\t\t\/\/ native event and prevent that from happening again here.\n-\t\t\t\t\/\/ This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n-\t\t\t\t\/\/ bubbling surrogate propagates *after* the non-bubbling base), but that seems\n-\t\t\t\t\/\/ less bad than duplication.\n-\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n-\t\t\t\t\tevent.stopPropagation();\n-\t\t\t\t}\n-\n-\t\t\t\/\/ If this is a native event triggered above, everything is now in order\n-\t\t\t\/\/ Fire an inner synthetic event with the original arguments\n-\t\t\t} else if ( saved.length ) {\n-\n-\t\t\t\t\/\/ ...and capture the result\n-\t\t\t\tdataPriv.set( this, type, {\n-\t\t\t\t\tvalue: jQuery.event.trigger(\n-\n-\t\t\t\t\t\t\/\/ Support: IE <=9 - 11+\n-\t\t\t\t\t\t\/\/ Extend with the prototype to reset the above stopImmediatePropagation()\n-\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n-\t\t\t\t\t\tsaved.slice( 1 ),\n-\t\t\t\t\t\tthis\n-\t\t\t\t\t)\n-\t\t\t\t} );\n-\n-\t\t\t\t\/\/ Abort handling of the native event\n-\t\t\t\tevent.stopImmediatePropagation();\n-\t\t\t}\n-\t\t}\n-\t} );\n-}\n-\n-jQuery.removeEvent = function( elem, type, handle ) {\n-\n-\t\/\/ This \"if\" is needed for plain objects\n-\tif ( elem.removeEventListener ) {\n-\t\telem.removeEventListener( type, handle );\n-\t}\n-};\n-\n-jQuery.Event = function( src, props ) {\n-\n-\t\/\/ Allow instantiation without the 'new' keyword\n-\tif ( !( this instanceof jQuery.Event ) ) {\n-\t\treturn new jQuery.Event( src, props );\n-\t}\n-\n-\t\/\/ Event object\n-\tif ( src && src.type ) {\n-\t\tthis.originalEvent = src;\n-\t\tthis.type = src.type;\n-\n-\t\t\/\/ Events bubbling up the document may have been marked as prevented\n-\t\t\/\/ by a handler lower down the tree; reflect the correct value.\n-\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n-\t\t\t\tsrc.defaultPrevented === undefined &&\n-\n-\t\t\t\t\/\/ Support: Android <=2.3 only\n-\t\t\t\tsrc.returnValue === false ?\n-\t\t\treturnTrue :\n-\t\t\treturnFalse;\n-\n-\t\t\/\/ Create target properties\n-\t\t\/\/ Support: Safari <=6 - 7 only\n-\t\t\/\/ Target should not be a text node (trac-504, trac-13143)\n-\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n-\t\t\tsrc.target.parentNode :\n-\t\t\tsrc.target;\n-\n-\t\tthis.currentTarget = src.currentTarget;\n-\t\tthis.relatedTarget = src.relatedTarget;\n-\n-\t\/\/ Event type\n-\t} else {\n-\t\tthis.type = src;\n-\t}\n-\n-\t\/\/ Put explicitly provided properties onto the event object\n-\tif ( props ) {\n-\t\tjQuery.extend( this, props );\n-\t}\n-\n-\t\/\/ Create a timestamp if incoming event doesn't have one\n-\tthis.timeStamp = src && src.timeStamp || Date.now();\n-\n-\t\/\/ Mark it as fixed\n-\tthis[ jQuery.expando ] = true;\n-};\n-\n-\/\/ jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n-\/\/ https:\/\/www.w3.org\/TR\/2003\/WD-DOM-Level-3-Events-20030331\/ecma-script-binding.html\n-jQuery.Event.prototype = {\n-\tconstructor: jQuery.Event,\n-\tisDefaultPrevented: returnFalse,\n-\tisPropagationStopped: returnFalse,\n-\tisImmediatePropagationStopped: returnFalse,\n-\tisSimulated: false,\n-\n-\tpreventDefault: function() {\n-\t\tvar e = this.originalEvent;\n-\n-\t\tthis.isDefaultPrevented = returnTrue;\n-\n-\t\tif ( e && !this.isSimulated ) {\n-\t\t\te.preventDefault();\n-\t\t}\n-\t},\n-\tstopPropagation: function() {\n-\t\tvar e = this.originalEvent;\n-\n-\t\tthis.isPropagationStopped = returnTrue;\n-\n-\t\tif ( e && !this.isSimulated ) {\n-\t\t\te.stopPropagation();\n-\t\t}\n-\t},\n-\tstopImmediatePropagation: function() {\n-\t\tvar e = this.originalEvent;\n-\n-\t\tthis.isImmediatePropagationStopped = returnTrue;\n-\n-\t\tif ( e && !this.isSimulated ) {\n-\t\t\te.stopImmediatePropagation();\n-\t\t}\n-\n-\t\tthis.stopPropagation();\n-\t}\n-};\n-\n-\/\/ Includes all common event props including KeyEvent and MouseEvent specific props\n-jQuery.each( {\n-\taltKey: true,\n-\tbubbles: true,\n-\tcancelable: true,\n-\tchangedTouches: true,\n-\tctrlKey: true,\n-\tdetail: true,\n-\teventPhase: true,\n-\tmetaKey: true,\n-\tpageX: true,\n-\tpageY: true,\n-\tshiftKey: true,\n-\tview: true,\n-\t\"char\": true,\n-\tcode: true,\n-\tcharCode: true,\n-\tkey: true,\n-\tkeyCode: true,\n-\tbutton: true,\n-\tbuttons: true,\n-\tclientX: true,\n-\tclientY: true,\n-\toffsetX: true,\n-\toffsetY: true,\n-\tpointerId: true,\n-\tpointerType: true,\n-\tscreenX: true,\n-\tscreenY: true,\n-\ttargetTouches: true,\n-\ttoElement: true,\n-\ttouches: true,\n-\twhich: true\n-}, jQuery.event.addProp );\n-\n-jQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n-\tjQuery.event.special[ type ] = {\n-\n-\t\t\/\/ Utilize native event if possible so blur\/focus sequence is correct\n-\t\tsetup: function() {\n-\n-\t\t\t\/\/ Claim the first handler\n-\t\t\t\/\/ dataPriv.set( this, \"focus\", ... )\n-\t\t\t\/\/ dataPriv.set( this, \"blur\", ... )\n-\t\t\tleverageNative( this, type, expectSync );\n-\n-\t\t\t\/\/ Return false to allow normal processing in the caller\n-\t\t\treturn false;\n-\t\t},\n-\t\ttrigger: function() {\n-\n-\t\t\t\/\/ Force setup before trigger\n-\t\t\tleverageNative( this, type );\n-\n-\t\t\t\/\/ Return non-false to allow normal event-path propagation\n-\t\t\treturn true;\n-\t\t},\n-\n-\t\t\/\/ Suppress native focus or blur if we're currently inside\n-\t\t\/\/ a leveraged native-event stack\n-\t\t_default: function( event ) {\n-\t\t\treturn dataPriv.get( event.target, type );\n-\t\t},\n-\n-\t\tdelegateType: delegateType\n-\t};\n-} );\n-\n-\/\/ Create mouseenter\/leave events using mouseover\/out and event-time checks\n-\/\/ so that event delegation works in jQuery.\n-\/\/ Do the same for pointerenter\/pointerleave and pointerover\/pointerout\n-\/\/\n-\/\/ Support: Safari 7 only\n-\/\/ Safari sends mouseenter too often; see:\n-\/\/ https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=470258\n-\/\/ for the description of the bug (it existed in older Chrome versions as well).\n-jQuery.each( {\n-\tmouseenter: \"mouseover\",\n-\tmouseleave: \"mouseout\",\n-\tpointerenter: \"pointerover\",\n-\tpointerleave: \"pointerout\"\n-}, function( orig, fix ) {\n-\tjQuery.event.special[ orig ] = {\n-\t\tdelegateType: fix,\n-\t\tbindType: fix,\n-\n-\t\thandle: function( event ) {\n-\t\t\tvar ret,\n-\t\t\t\ttarget = this,\n-\t\t\t\trelated = event.relatedTarget,\n-\t\t\t\thandleObj = event.handleObj;\n-\n-\t\t\t\/\/ For mouseenter\/leave call the handler if related is outside the target.\n-\t\t\t\/\/ NB: No relatedTarget if the mouse left\/entered the browser window\n-\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n-\t\t\t\tevent.type = handleObj.origType;\n-\t\t\t\tret = handleObj.handler.apply( this, arguments );\n-\t\t\t\tevent.type = fix;\n-\t\t\t}\n-\t\t\treturn ret;\n-\t\t}\n-\t};\n-} );\n-\n-jQuery.fn.extend( {\n-\n-\ton: function( types, selector, data, fn ) {\n-\t\treturn on( this, types, selector, data, fn );\n-\t},\n-\tone: function( types, selector, data, fn ) {\n-\t\treturn on( this, types, selector, data, fn, 1 );\n-\t},\n-\toff: function( types, selector, fn ) {\n-\t\tvar handleObj, type;\n-\t\tif ( types && types.preventDefault && types.handleObj ) {\n-\n-\t\t\t\/\/ ( event )  dispatched jQuery.Event\n-\t\t\thandleObj = types.handleObj;\n-\t\t\tjQuery( types.delegateTarget ).off(\n-\t\t\t\thandleObj.namespace ?\n-\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n-\t\t\t\t\thandleObj.origType,\n-\t\t\t\thandleObj.selector,\n-\t\t\t\thandleObj.handler\n-\t\t\t);\n-\t\t\treturn this;\n-\t\t}\n-\t\tif ( typeof types === \"object\" ) {\n-\n-\t\t\t\/\/ ( types-object [, selector] )\n-\t\t\tfor ( type in types ) {\n-\t\t\t\tthis.off( type, selector, types[ type ] );\n-\t\t\t}\n-\t\t\treturn this;\n-\t\t}\n-\t\tif ( selector === false || typeof selector === \"function\" ) {\n-\n-\t\t\t\/\/ ( types [, fn] )\n-\t\t\tfn = selector;\n-\t\t\tselector = undefined;\n-\t\t}\n-\t\tif ( fn === false ) {\n-\t\t\tfn = returnFalse;\n-\t\t}\n-\t\treturn this.each( function() {\n-\t\t\tjQuery.event.remove( this, types, fn, selector );\n-\t\t} );\n-\t}\n-} );\n-\n-\n-var\n-\n-\t\/\/ Support: IE <=10 - 11, Edge 12 - 13 only\n-\t\/\/ In IE\/Edge using regex groups here causes severe slowdowns.\n-\t\/\/ See https:\/\/connect.microsoft.com\/IE\/feedback\/details\/1736512\/\n-\trnoInnerhtml = \/<script|<style|<link\/i,\n-\n-\t\/\/ checked=\"checked\" or checked\n-\trchecked = \/checked\\s*(?:[^=]|=\\s*.checked.)\/i,\n-\n-\trcleanScript = \/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$\/g;\n-\n-\/\/ Prefer a tbody over its parent table for containing new rows\n-function manipulationTarget( elem, content ) {\n-\tif ( nodeName( elem, \"table\" ) &&\n-\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n-\n-\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n-\t}\n-\n-\treturn elem;\n-}\n-\n-\/\/ Replace\/restore the type attribute of script elements for safe DOM manipulation\n-function disableScript( elem ) {\n-\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"\/\" + elem.type;\n-\treturn elem;\n-}\n-function restoreScript( elem ) {\n-\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true\/\" ) {\n-\t\telem.type = elem.type.slice( 5 );\n-\t} else {\n-\t\telem.removeAttribute( \"type\" );\n-\t}\n-\n-\treturn elem;\n-}\n-\n-function cloneCopyEvent( src, dest ) {\n-\tvar i, l, type, pdataOld, udataOld, udataCur, events;\n-\n-\tif ( dest.nodeType !== 1 ) {\n-\t\treturn;\n-\t}\n-\n-\t\/\/ 1. Copy private data: events, handlers, etc.\n-\tif ( dataPriv.hasData( src ) ) {\n-\t\tpdataOld = dataPriv.get( src );\n-\t\tevents = pdataOld.events;\n-\n-\t\tif ( events ) {\n-\t\t\tdataPriv.remove( dest, \"handle events\" );\n-\n-\t\t\tfor ( type in events ) {\n-\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n-\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t\/\/ 2. Copy user data\n-\tif ( dataUser.hasData( src ) ) {\n-\t\tudataOld = dataUser.access( src );\n-\t\tudataCur = jQuery.extend( {}, udataOld );\n-\n-\t\tdataUser.set( dest, udataCur );\n-\t}\n-}\n-\n-\/\/ Fix IE bugs, see support tests\n-function fixInput( src, dest ) {\n-\tvar nodeName = dest.nodeName.toLowerCase();\n-\n-\t\/\/ Fails to persist the checked state of a cloned checkbox or radio button.\n-\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n-\t\tdest.checked = src.checked;\n-\n-\t\/\/ Fails to return the selected option to the default selected state when cloning options\n-\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n-\t\tdest.defaultValue = src.defaultValue;\n-\t}\n-}\n-\n-function domManip( collection, args, callback, ignored ) {\n-\n-\t\/\/ Flatten any nested arrays\n-\targs = flat( args );\n-\n-\tvar fragment, first, scripts, hasScripts, node, doc,\n-\t\ti = 0,\n-\t\tl = collection.length,\n-\t\tiNoClone = l - 1,\n-\t\tvalue = args[ 0 ],\n-\t\tvalueIsFunction = isFunction( value );\n-\n-\t\/\/ We can't cloneNode fragments that contain checked, in WebKit\n-\tif ( valueIsFunction ||\n-\t\t\t( l > 1 && typeof value === \"string\" &&\n-\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n-\t\treturn collection.each( function( index ) {\n-\t\t\tvar self = collection.eq( index );\n-\t\t\tif ( valueIsFunction ) {\n-\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n-\t\t\t}\n-\t\t\tdomManip( self, args, callback, ignored );\n-\t\t} );\n-\t}\n-\n-\tif ( l ) {\n-\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n-\t\tfirst = fragment.firstChild;\n-\n-\t\tif ( fragment.childNodes.length === 1 ) {\n-\t\t\tfragment = first;\n-\t\t}\n-\n-\t\t\/\/ Require either new content or an interest in ignored elements to invoke the callback\n-\t\tif ( first || ignored ) {\n-\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n-\t\t\thasScripts = scripts.length;\n-\n-\t\t\t\/\/ Use the original fragment for the last item\n-\t\t\t\/\/ instead of the first because it can end up\n-\t\t\t\/\/ being emptied incorrectly in certain situations (trac-8070).\n-\t\t\tfor ( ; i < l; i++ ) {\n-\t\t\t\tnode = fragment;\n-\n-\t\t\t\tif ( i !== iNoClone ) {\n-\t\t\t\t\tnode = jQuery.clone( node, true, true );\n-\n-\t\t\t\t\t\/\/ Keep references to cloned scripts for later restoration\n-\t\t\t\t\tif ( hasScripts ) {\n-\n-\t\t\t\t\t\t\/\/ Support: Android <=4.0 only, PhantomJS 1 only\n-\t\t\t\t\t\t\/\/ push.apply(_, arraylike) throws on ancient WebKit\n-\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tcallback.call( collection[ i ], node, i );\n-\t\t\t}\n-\n-\t\t\tif ( hasScripts ) {\n-\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n-\n-\t\t\t\t\/\/ Reenable scripts\n-\t\t\t\tjQuery.map( scripts, restoreScript );\n-\n-\t\t\t\t\/\/ Evaluate executable scripts on first document insertion\n-\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n-\t\t\t\t\tnode = scripts[ i ];\n-\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n-\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n-\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n-\n-\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n-\n-\t\t\t\t\t\t\t\/\/ Optional AJAX dependency, but won't run scripts if not present\n-\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n-\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n-\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n-\t\t\t\t\t\t\t\t}, doc );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t\/\/ Unwrap a CDATA section containing script contents. This shouldn't be\n-\t\t\t\t\t\t\t\/\/ needed as in XML documents they're already not visible when\n-\t\t\t\t\t\t\t\/\/ inspecting element contents and in HTML documents they have no\n-\t\t\t\t\t\t\t\/\/ meaning but we're preserving that logic for backwards compatibility.\n-\t\t\t\t\t\t\t\/\/ This will be removed completely in 4.0. See gh-4904.\n-\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn collection;\n-}\n-\n-function remove( elem, selector, keepData ) {\n-\tvar node,\n-\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n-\t\ti = 0;\n-\n-\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n-\t\tif ( !keepData && node.nodeType === 1 ) {\n-\t\t\tjQuery.cleanData( getAll( node ) );\n-\t\t}\n-\n-\t\tif ( node.parentNode ) {\n-\t\t\tif ( keepData && isAttached( node ) ) {\n-\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n-\t\t\t}\n-\t\t\tnode.parentNode.removeChild( node );\n-\t\t}\n-\t}\n-\n-\treturn elem;\n-}\n-\n-jQuery.extend( {\n-\thtmlPrefilter: function( html ) {\n-\t\treturn html;\n-\t},\n-\n-\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n-\t\tvar i, l, srcElements, destElements,\n-\t\t\tclone = elem.cloneNode( true ),\n-\t\t\tinPage = isAttached( elem );\n-\n-\t\t\/\/ Fix IE cloning issues\n-\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n-\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n-\n-\t\t\t\/\/ We eschew Sizzle here for performance reasons: https:\/\/jsperf.com\/getall-vs-sizzle\/2\n-\t\t\tdestElements = getAll( clone );\n-\t\t\tsrcElements = getAll( elem );\n-\n-\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n-\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Copy the events from the original to the clone\n-\t\tif ( dataAndEvents ) {\n-\t\t\tif ( deepDataAndEvents ) {\n-\t\t\t\tsrcElements = srcElements || getAll( elem );\n-\t\t\t\tdestElements = destElements || getAll( clone );\n-\n-\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n-\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tcloneCopyEvent( elem, clone );\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Preserve script evaluation history\n-\t\tdestElements = getAll( clone, \"script\" );\n-\t\tif ( destElements.length > 0 ) {\n-\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n-\t\t}\n-\n-\t\t\/\/ Return the cloned set\n-\t\treturn clone;\n-\t},\n-\n-\tcleanData: function( elems ) {\n-\t\tvar data, elem, type,\n-\t\t\tspecial = jQuery.event.special,\n-\t\t\ti = 0;\n-\n-\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n-\t\t\tif ( acceptData( elem ) ) {\n-\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n-\t\t\t\t\tif ( data.events ) {\n-\t\t\t\t\t\tfor ( type in data.events ) {\n-\t\t\t\t\t\t\tif ( special[ type ] ) {\n-\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n-\n-\t\t\t\t\t\t\t\/\/ This is a shortcut to avoid jQuery.event.remove's overhead\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t\/\/ Support: Chrome <=35 - 45+\n-\t\t\t\t\t\/\/ Assign undefined instead of using delete, see Data#remove\n-\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n-\t\t\t\t}\n-\t\t\t\tif ( elem[ dataUser.expando ] ) {\n-\n-\t\t\t\t\t\/\/ Support: Chrome <=35 - 45+\n-\t\t\t\t\t\/\/ Assign undefined instead of using delete, see Data#remove\n-\t\t\t\t\telem[ dataUser.expando ] = undefined;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-} );\n-\n-jQuery.fn.extend( {\n-\tdetach: function( selector ) {\n-\t\treturn remove( this, selector, true );\n-\t},\n-\n-\tremove: function( selector ) {\n-\t\treturn remove( this, selector );\n-\t},\n-\n-\ttext: function( value ) {\n-\t\treturn access( this, function( value ) {\n-\t\t\treturn value === undefined ?\n-\t\t\t\tjQuery.text( this ) :\n-\t\t\t\tthis.empty().each( function() {\n-\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n-\t\t\t\t\t\tthis.textContent = value;\n-\t\t\t\t\t}\n-\t\t\t\t} );\n-\t\t}, null, value, arguments.length );\n-\t},\n-\n-\tappend: function() {\n-\t\treturn domManip( this, arguments, function( elem ) {\n-\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n-\t\t\t\tvar target = manipulationTarget( this, elem );\n-\t\t\t\ttarget.appendChild( elem );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tprepend: function() {\n-\t\treturn domManip( this, arguments, function( elem ) {\n-\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n-\t\t\t\tvar target = manipulationTarget( this, elem );\n-\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tbefore: function() {\n-\t\treturn domManip( this, arguments, function( elem ) {\n-\t\t\tif ( this.parentNode ) {\n-\t\t\t\tthis.parentNode.insertBefore( elem, this );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tafter: function() {\n-\t\treturn domManip( this, arguments, function( elem ) {\n-\t\t\tif ( this.parentNode ) {\n-\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tempty: function() {\n-\t\tvar elem,\n-\t\t\ti = 0;\n-\n-\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n-\t\t\tif ( elem.nodeType === 1 ) {\n-\n-\t\t\t\t\/\/ Prevent memory leaks\n-\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n-\n-\t\t\t\t\/\/ Remove any remaining nodes\n-\t\t\t\telem.textContent = \"\";\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn this;\n-\t},\n-\n-\tclone: function( dataAndEvents, deepDataAndEvents ) {\n-\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n-\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n-\n-\t\treturn this.map( function() {\n-\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n-\t\t} );\n-\t},\n-\n-\thtml: function( value ) {\n-\t\treturn access( this, function( value ) {\n-\t\t\tvar elem = this[ 0 ] || {},\n-\t\t\t\ti = 0,\n-\t\t\t\tl = this.length;\n-\n-\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n-\t\t\t\treturn elem.innerHTML;\n-\t\t\t}\n-\n-\t\t\t\/\/ See if we can take a shortcut and just use innerHTML\n-\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n-\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n-\n-\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n-\n-\t\t\t\ttry {\n-\t\t\t\t\tfor ( ; i < l; i++ ) {\n-\t\t\t\t\t\telem = this[ i ] || {};\n-\n-\t\t\t\t\t\t\/\/ Remove element nodes and prevent memory leaks\n-\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n-\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n-\t\t\t\t\t\t\telem.innerHTML = value;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\telem = 0;\n-\n-\t\t\t\t\/\/ If using innerHTML throws an exception, use the fallback method\n-\t\t\t\t} catch ( e ) {}\n-\t\t\t}\n-\n-\t\t\tif ( elem ) {\n-\t\t\t\tthis.empty().append( value );\n-\t\t\t}\n-\t\t}, null, value, arguments.length );\n-\t},\n-\n-\treplaceWith: function() {\n-\t\tvar ignored = [];\n-\n-\t\t\/\/ Make the changes, replacing each non-ignored context element with the new content\n-\t\treturn domManip( this, arguments, function( elem ) {\n-\t\t\tvar parent = this.parentNode;\n-\n-\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n-\t\t\t\tjQuery.cleanData( getAll( this ) );\n-\t\t\t\tif ( parent ) {\n-\t\t\t\t\tparent.replaceChild( elem, this );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\/\/ Force callback invocation\n-\t\t}, ignored );\n-\t}\n-} );\n-\n-jQuery.each( {\n-\tappendTo: \"append\",\n-\tprependTo: \"prepend\",\n-\tinsertBefore: \"before\",\n-\tinsertAfter: \"after\",\n-\treplaceAll: \"replaceWith\"\n-}, function( name, original ) {\n-\tjQuery.fn[ name ] = function( selector ) {\n-\t\tvar elems,\n-\t\t\tret = [],\n-\t\t\tinsert = jQuery( selector ),\n-\t\t\tlast = insert.length - 1,\n-\t\t\ti = 0;\n-\n-\t\tfor ( ; i <= last; i++ ) {\n-\t\t\telems = i === last ? this : this.clone( true );\n-\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n-\n-\t\t\t\/\/ Support: Android <=4.0 only, PhantomJS 1 only\n-\t\t\t\/\/ .get() because push.apply(_, arraylike) throws on ancient WebKit\n-\t\t\tpush.apply( ret, elems.get() );\n-\t\t}\n-\n-\t\treturn this.pushStack( ret );\n-\t};\n-} );\n-var rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n-\n-var rcustomProp = \/^--\/;\n-\n-\n-var getStyles = function( elem ) {\n-\n-\t\t\/\/ Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)\n-\t\t\/\/ IE throws on elements created in popups\n-\t\t\/\/ FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n-\t\tvar view = elem.ownerDocument.defaultView;\n-\n-\t\tif ( !view || !view.opener ) {\n-\t\t\tview = window;\n-\t\t}\n-\n-\t\treturn view.getComputedStyle( elem );\n-\t};\n-\n-var swap = function( elem, options, callback ) {\n-\tvar ret, name,\n-\t\told = {};\n-\n-\t\/\/ Remember the old values, and insert the new ones\n-\tfor ( name in options ) {\n-\t\told[ name ] = elem.style[ name ];\n-\t\telem.style[ name ] = options[ name ];\n-\t}\n-\n-\tret = callback.call( elem );\n-\n-\t\/\/ Revert the old values\n-\tfor ( name in options ) {\n-\t\telem.style[ name ] = old[ name ];\n-\t}\n-\n-\treturn ret;\n-};\n-\n-\n-var rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n-\n-var whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\n-\n-\n-var rtrimCSS = new RegExp(\n-\t\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\",\n-\t\"g\"\n-);\n-\n-\n-\n-\n-( function() {\n-\n-\t\/\/ Executing both pixelPosition & boxSizingReliable tests require only one layout\n-\t\/\/ so they're executed at the same time to save the second computation.\n-\tfunction computeStyleTests() {\n-\n-\t\t\/\/ This is a singleton, we need to execute it only once\n-\t\tif ( !div ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n-\t\t\t\"margin-top:1px;padding:0;border:0\";\n-\t\tdiv.style.cssText =\n-\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n-\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n-\t\t\t\"width:60%;top:1%\";\n-\t\tdocumentElement.appendChild( container ).appendChild( div );\n-\n-\t\tvar divStyle = window.getComputedStyle( div );\n-\t\tpixelPositionVal = divStyle.top !== \"1%\";\n-\n-\t\t\/\/ Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n-\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n-\n-\t\t\/\/ Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n-\t\t\/\/ Some styles come back with percentage values, even though they shouldn't\n-\t\tdiv.style.right = \"60%\";\n-\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n-\n-\t\t\/\/ Support: IE 9 - 11 only\n-\t\t\/\/ Detect misreporting of content dimensions for box-sizing:border-box elements\n-\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n-\n-\t\t\/\/ Support: IE 9 only\n-\t\t\/\/ Detect overflow:scroll screwiness (gh-3699)\n-\t\t\/\/ Support: Chrome <=64\n-\t\t\/\/ Don't get tricked when zoom affects offsetWidth (gh-4029)\n-\t\tdiv.style.position = \"absolute\";\n-\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth \/ 3 ) === 12;\n-\n-\t\tdocumentElement.removeChild( container );\n-\n-\t\t\/\/ Nullify the div so it wouldn't be stored in the memory and\n-\t\t\/\/ it will also be a sign that checks already performed\n-\t\tdiv = null;\n-\t}\n-\n-\tfunction roundPixelMeasures( measure ) {\n-\t\treturn Math.round( parseFloat( measure ) );\n-\t}\n-\n-\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n-\t\treliableTrDimensionsVal, reliableMarginLeftVal,\n-\t\tcontainer = document.createElement( \"div\" ),\n-\t\tdiv = document.createElement( \"div\" );\n-\n-\t\/\/ Finish early in limited (non-browser) environments\n-\tif ( !div.style ) {\n-\t\treturn;\n-\t}\n-\n-\t\/\/ Support: IE <=9 - 11 only\n-\t\/\/ Style of cloned element affects source element cloned (trac-8908)\n-\tdiv.style.backgroundClip = \"content-box\";\n-\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n-\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n-\n-\tjQuery.extend( support, {\n-\t\tboxSizingReliable: function() {\n-\t\t\tcomputeStyleTests();\n-\t\t\treturn boxSizingReliableVal;\n-\t\t},\n-\t\tpixelBoxStyles: function() {\n-\t\t\tcomputeStyleTests();\n-\t\t\treturn pixelBoxStylesVal;\n-\t\t},\n-\t\tpixelPosition: function() {\n-\t\t\tcomputeStyleTests();\n-\t\t\treturn pixelPositionVal;\n-\t\t},\n-\t\treliableMarginLeft: function() {\n-\t\t\tcomputeStyleTests();\n-\t\t\treturn reliableMarginLeftVal;\n-\t\t},\n-\t\tscrollboxSize: function() {\n-\t\t\tcomputeStyleTests();\n-\t\t\treturn scrollboxSizeVal;\n-\t\t},\n-\n-\t\t\/\/ Support: IE 9 - 11+, Edge 15 - 18+\n-\t\t\/\/ IE\/Edge misreport `getComputedStyle` of table rows with width\/height\n-\t\t\/\/ set in CSS while `offset*` properties report correct values.\n-\t\t\/\/ Behavior in IE 9 is more subtle than in newer versions & it passes\n-\t\t\/\/ some versions of this test; make sure not to make it pass there!\n-\t\t\/\/\n-\t\t\/\/ Support: Firefox 70+\n-\t\t\/\/ Only Firefox includes border widths\n-\t\t\/\/ in computed dimensions. (gh-4529)\n-\t\treliableTrDimensions: function() {\n-\t\t\tvar table, tr, trChild, trStyle;\n-\t\t\tif ( reliableTrDimensionsVal == null ) {\n-\t\t\t\ttable = document.createElement( \"table\" );\n-\t\t\t\ttr = document.createElement( \"tr\" );\n-\t\t\t\ttrChild = document.createElement( \"div\" );\n-\n-\t\t\t\ttable.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n-\t\t\t\ttr.style.cssText = \"border:1px solid\";\n-\n-\t\t\t\t\/\/ Support: Chrome 86+\n-\t\t\t\t\/\/ Height set through cssText does not get applied.\n-\t\t\t\t\/\/ Computed height then comes back as 0.\n-\t\t\t\ttr.style.height = \"1px\";\n-\t\t\t\ttrChild.style.height = \"9px\";\n-\n-\t\t\t\t\/\/ Support: Android 8 Chrome 86+\n-\t\t\t\t\/\/ In our bodyBackground.html iframe,\n-\t\t\t\t\/\/ display for all div elements is set to \"inline\",\n-\t\t\t\t\/\/ which causes a problem only in Android 8 Chrome 86.\n-\t\t\t\t\/\/ Ensuring the div is display: block\n-\t\t\t\t\/\/ gets around this issue.\n-\t\t\t\ttrChild.style.display = \"block\";\n-\n-\t\t\t\tdocumentElement\n-\t\t\t\t\t.appendChild( table )\n-\t\t\t\t\t.appendChild( tr )\n-\t\t\t\t\t.appendChild( trChild );\n-\n-\t\t\t\ttrStyle = window.getComputedStyle( tr );\n-\t\t\t\treliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +\n-\t\t\t\t\tparseInt( trStyle.borderTopWidth, 10 ) +\n-\t\t\t\t\tparseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;\n-\n-\t\t\t\tdocumentElement.removeChild( table );\n-\t\t\t}\n-\t\t\treturn reliableTrDimensionsVal;\n-\t\t}\n-\t} );\n-} )();\n-\n-\n-function curCSS( elem, name, computed ) {\n-\tvar width, minWidth, maxWidth, ret,\n-\t\tisCustomProp = rcustomProp.test( name ),\n-\n-\t\t\/\/ Support: Firefox 51+\n-\t\t\/\/ Retrieving style before computed somehow\n-\t\t\/\/ fixes an issue with getting wrong values\n-\t\t\/\/ on detached elements\n-\t\tstyle = elem.style;\n-\n-\tcomputed = computed || getStyles( elem );\n-\n-\t\/\/ getPropertyValue is needed for:\n-\t\/\/   .css('filter') (IE 9 only, trac-12537)\n-\t\/\/   .css('--customProperty) (gh-3144)\n-\tif ( computed ) {\n-\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n-\n-\t\t\/\/ trim whitespace for custom property (issue gh-4926)\n-\t\tif ( isCustomProp ) {\n-\n-\t\t\t\/\/ rtrim treats U+000D CARRIAGE RETURN and U+000C FORM FEED\n-\t\t\t\/\/ as whitespace while CSS does not, but this is not a problem\n-\t\t\t\/\/ because CSS preprocessing replaces them with U+000A LINE FEED\n-\t\t\t\/\/ (which *is* CSS whitespace)\n-\t\t\t\/\/ https:\/\/www.w3.org\/TR\/css-syntax-3\/#input-preprocessing\n-\t\t\tret = ret.replace( rtrimCSS, \"$1\" );\n-\t\t}\n-\n-\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n-\t\t\tret = jQuery.style( elem, name );\n-\t\t}\n-\n-\t\t\/\/ A tribute to the \"awesome hack by Dean Edwards\"\n-\t\t\/\/ Android Browser returns percentage for some values,\n-\t\t\/\/ but width seems to be reliably pixels.\n-\t\t\/\/ This is against the CSSOM draft spec:\n-\t\t\/\/ https:\/\/drafts.csswg.org\/cssom\/#resolved-values\n-\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n-\n-\t\t\t\/\/ Remember the original values\n-\t\t\twidth = style.width;\n-\t\t\tminWidth = style.minWidth;\n-\t\t\tmaxWidth = style.maxWidth;\n-\n-\t\t\t\/\/ Put in the new values to get a computed value out\n-\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n-\t\t\tret = computed.width;\n-\n-\t\t\t\/\/ Revert the changed values\n-\t\t\tstyle.width = width;\n-\t\t\tstyle.minWidth = minWidth;\n-\t\t\tstyle.maxWidth = maxWidth;\n-\t\t}\n-\t}\n-\n-\treturn ret !== undefined ?\n-\n-\t\t\/\/ Support: IE <=9 - 11 only\n-\t\t\/\/ IE returns zIndex value as an integer.\n-\t\tret + \"\" :\n-\t\tret;\n-}\n-\n-\n-function addGetHookIf( conditionFn, hookFn ) {\n-\n-\t\/\/ Define the hook, we'll check on the first run if it's really needed.\n-\treturn {\n-\t\tget: function() {\n-\t\t\tif ( conditionFn() ) {\n-\n-\t\t\t\t\/\/ Hook not needed (or it's not possible to use it due\n-\t\t\t\t\/\/ to missing dependency), remove it.\n-\t\t\t\tdelete this.get;\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t\/\/ Hook needed; redefine it so that the support test is not executed again.\n-\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n-\t\t}\n-\t};\n-}\n-\n-\n-var cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n-\temptyStyle = document.createElement( \"div\" ).style,\n-\tvendorProps = {};\n-\n-\/\/ Return a vendor-prefixed property or undefined\n-function vendorPropName( name ) {\n-\n-\t\/\/ Check for vendor prefixed names\n-\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n-\t\ti = cssPrefixes.length;\n-\n-\twhile ( i-- ) {\n-\t\tname = cssPrefixes[ i ] + capName;\n-\t\tif ( name in emptyStyle ) {\n-\t\t\treturn name;\n-\t\t}\n-\t}\n-}\n-\n-\/\/ Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n-function finalPropName( name ) {\n-\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n-\n-\tif ( final ) {\n-\t\treturn final;\n-\t}\n-\tif ( name in emptyStyle ) {\n-\t\treturn name;\n-\t}\n-\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n-}\n-\n-\n-var\n-\n-\t\/\/ Swappable if display is none or starts with table\n-\t\/\/ except \"table\", \"table-cell\", or \"table-caption\"\n-\t\/\/ See here for display values: https:\/\/developer.mozilla.org\/en-US\/docs\/CSS\/display\n-\trdisplayswap = \/^(none|table(?!-c[ea]).+)\/,\n-\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n-\tcssNormalTransform = {\n-\t\tletterSpacing: \"0\",\n-\t\tfontWeight: \"400\"\n-\t};\n-\n-function setPositiveNumber( _elem, value, subtract ) {\n-\n-\t\/\/ Any relative (+\/-) values have already been\n-\t\/\/ normalized at this point\n-\tvar matches = rcssNum.exec( value );\n-\treturn matches ?\n-\n-\t\t\/\/ Guard against undefined \"subtract\", e.g., when used as in cssHooks\n-\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n-\t\tvalue;\n-}\n-\n-function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n-\tvar i = dimension === \"width\" ? 1 : 0,\n-\t\textra = 0,\n-\t\tdelta = 0;\n-\n-\t\/\/ Adjustment may not be necessary\n-\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n-\t\treturn 0;\n-\t}\n-\n-\tfor ( ; i < 4; i += 2 ) {\n-\n-\t\t\/\/ Both box models exclude margin\n-\t\tif ( box === \"margin\" ) {\n-\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n-\t\t}\n-\n-\t\t\/\/ If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n-\t\tif ( !isBorderBox ) {\n-\n-\t\t\t\/\/ Add padding\n-\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n-\n-\t\t\t\/\/ For \"border\" or \"margin\", add border\n-\t\t\tif ( box !== \"padding\" ) {\n-\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n-\n-\t\t\t\/\/ But still keep track of it otherwise\n-\t\t\t} else {\n-\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n-\t\t\t}\n-\n-\t\t\/\/ If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n-\t\t\/\/ \"padding\" or \"margin\"\n-\t\t} else {\n-\n-\t\t\t\/\/ For \"content\", subtract padding\n-\t\t\tif ( box === \"content\" ) {\n-\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n-\t\t\t}\n-\n-\t\t\t\/\/ For \"content\" or \"padding\", subtract border\n-\t\t\tif ( box !== \"margin\" ) {\n-\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t\/\/ Account for positive content-box scroll gutter when requested by providing computedVal\n-\tif ( !isBorderBox && computedVal >= 0 ) {\n-\n-\t\t\/\/ offsetWidth\/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n-\t\t\/\/ Assuming integer scroll gutter, subtract the rest and round down\n-\t\tdelta += Math.max( 0, Math.ceil(\n-\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n-\t\t\tcomputedVal -\n-\t\t\tdelta -\n-\t\t\textra -\n-\t\t\t0.5\n-\n-\t\t\/\/ If offsetWidth\/offsetHeight is unknown, then we can't determine content-box scroll gutter\n-\t\t\/\/ Use an explicit zero to avoid NaN (gh-3964)\n-\t\t) ) || 0;\n-\t}\n-\n-\treturn delta;\n-}\n-\n-function getWidthOrHeight( elem, dimension, extra ) {\n-\n-\t\/\/ Start with computed style\n-\tvar styles = getStyles( elem ),\n-\n-\t\t\/\/ To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n-\t\t\/\/ Fake content-box until we know it's needed to know the true value.\n-\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n-\t\tisBorderBox = boxSizingNeeded &&\n-\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n-\t\tvalueIsBorderBox = isBorderBox,\n-\n-\t\tval = curCSS( elem, dimension, styles ),\n-\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n-\n-\t\/\/ Support: Firefox <=54\n-\t\/\/ Return a confounding non-pixel value or feign ignorance, as appropriate.\n-\tif ( rnumnonpx.test( val ) ) {\n-\t\tif ( !extra ) {\n-\t\t\treturn val;\n-\t\t}\n-\t\tval = \"auto\";\n-\t}\n-\n-\n-\t\/\/ Support: IE 9 - 11 only\n-\t\/\/ Use offsetWidth\/offsetHeight for when box sizing is unreliable.\n-\t\/\/ In those cases, the computed value can be trusted to be border-box.\n-\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n-\n-\t\t\/\/ Support: IE 10 - 11+, Edge 15 - 18+\n-\t\t\/\/ IE\/Edge misreport `getComputedStyle` of table rows with width\/height\n-\t\t\/\/ set in CSS while `offset*` properties report correct values.\n-\t\t\/\/ Interestingly, in some cases IE 9 doesn't suffer from this issue.\n-\t\t!support.reliableTrDimensions() && nodeName( elem, \"tr\" ) ||\n-\n-\t\t\/\/ Fall back to offsetWidth\/offsetHeight when value is \"auto\"\n-\t\t\/\/ This happens for inline elements with no explicit setting (gh-3571)\n-\t\tval === \"auto\" ||\n-\n-\t\t\/\/ Support: Android <=4.1 - 4.3 only\n-\t\t\/\/ Also use offsetWidth\/offsetHeight for misreported inline dimensions (gh-3602)\n-\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n-\n-\t\t\/\/ Make sure the element is visible & connected\n-\t\telem.getClientRects().length ) {\n-\n-\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n-\n-\t\t\/\/ Where available, offsetWidth\/offsetHeight approximate border box dimensions.\n-\t\t\/\/ Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n-\t\t\/\/ retrieved value as a content box dimension.\n-\t\tvalueIsBorderBox = offsetProp in elem;\n-\t\tif ( valueIsBorderBox ) {\n-\t\t\tval = elem[ offsetProp ];\n-\t\t}\n-\t}\n-\n-\t\/\/ Normalize \"\" and auto\n-\tval = parseFloat( val ) || 0;\n-\n-\t\/\/ Adjust for the element's box model\n-\treturn ( val +\n-\t\tboxModelAdjustment(\n-\t\t\telem,\n-\t\t\tdimension,\n-\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n-\t\t\tvalueIsBorderBox,\n-\t\t\tstyles,\n-\n-\t\t\t\/\/ Provide the current computed size to request scroll gutter calculation (gh-3589)\n-\t\t\tval\n-\t\t)\n-\t) + \"px\";\n-}\n-\n-jQuery.extend( {\n-\n-\t\/\/ Add in style property hooks for overriding the default\n-\t\/\/ behavior of getting and setting a style property\n-\tcssHooks: {\n-\t\topacity: {\n-\t\t\tget: function( elem, computed ) {\n-\t\t\t\tif ( computed ) {\n-\n-\t\t\t\t\t\/\/ We should always get a number back from opacity\n-\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n-\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t},\n-\n-\t\/\/ Don't automatically add \"px\" to these possibly-unitless properties\n-\tcssNumber: {\n-\t\t\"animationIterationCount\": true,\n-\t\t\"columnCount\": true,\n-\t\t\"fillOpacity\": true,\n-\t\t\"flexGrow\": true,\n-\t\t\"flexShrink\": true,\n-\t\t\"fontWeight\": true,\n-\t\t\"gridArea\": true,\n-\t\t\"gridColumn\": true,\n-\t\t\"gridColumnEnd\": true,\n-\t\t\"gridColumnStart\": true,\n-\t\t\"gridRow\": true,\n-\t\t\"gridRowEnd\": true,\n-\t\t\"gridRowStart\": true,\n-\t\t\"lineHeight\": true,\n-\t\t\"opacity\": true,\n-\t\t\"order\": true,\n-\t\t\"orphans\": true,\n-\t\t\"widows\": true,\n-\t\t\"zIndex\": true,\n-\t\t\"zoom\": true\n-\t},\n-\n-\t\/\/ Add in properties whose names you wish to fix before\n-\t\/\/ setting or getting the value\n-\tcssProps: {},\n-\n-\t\/\/ Get and set the style property on a DOM Node\n-\tstyle: function( elem, name, value, extra ) {\n-\n-\t\t\/\/ Don't set styles on text and comment nodes\n-\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t\/\/ Make sure that we're working with the right name\n-\t\tvar ret, type, hooks,\n-\t\t\torigName = camelCase( name ),\n-\t\t\tisCustomProp = rcustomProp.test( name ),\n-\t\t\tstyle = elem.style;\n-\n-\t\t\/\/ Make sure that we're working with the right name. We don't\n-\t\t\/\/ want to query the value if it is a CSS custom property\n-\t\t\/\/ since they are user-defined.\n-\t\tif ( !isCustomProp ) {\n-\t\t\tname = finalPropName( origName );\n-\t\t}\n-\n-\t\t\/\/ Gets hook for the prefixed version, then unprefixed version\n-\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n-\n-\t\t\/\/ Check if we're setting a value\n-\t\tif ( value !== undefined ) {\n-\t\t\ttype = typeof value;\n-\n-\t\t\t\/\/ Convert \"+=\" or \"-=\" to relative numbers (trac-7345)\n-\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n-\t\t\t\tvalue = adjustCSS( elem, name, ret );\n-\n-\t\t\t\t\/\/ Fixes bug trac-9237\n-\t\t\t\ttype = \"number\";\n-\t\t\t}\n-\n-\t\t\t\/\/ Make sure that null and NaN values aren't set (trac-7116)\n-\t\t\tif ( value == null || value !== value ) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t\/\/ If a number was passed in, add the unit (except for certain CSS properties)\n-\t\t\t\/\/ The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n-\t\t\t\/\/ \"px\" to a few hardcoded values.\n-\t\t\tif ( type === \"number\" && !isCustomProp ) {\n-\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n-\t\t\t}\n-\n-\t\t\t\/\/ background-* props affect original clone's values\n-\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n-\t\t\t\tstyle[ name ] = \"inherit\";\n-\t\t\t}\n-\n-\t\t\t\/\/ If a hook was provided, use that value, otherwise just set the specified value\n-\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n-\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n-\n-\t\t\t\tif ( isCustomProp ) {\n-\t\t\t\t\tstyle.setProperty( name, value );\n-\t\t\t\t} else {\n-\t\t\t\t\tstyle[ name ] = value;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t} else {\n-\n-\t\t\t\/\/ If a hook was provided get the non-computed value from there\n-\t\t\tif ( hooks && \"get\" in hooks &&\n-\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n-\n-\t\t\t\treturn ret;\n-\t\t\t}\n-\n-\t\t\t\/\/ Otherwise just get the value from the style object\n-\t\t\treturn style[ name ];\n-\t\t}\n-\t},\n-\n-\tcss: function( elem, name, extra, styles ) {\n-\t\tvar val, num, hooks,\n-\t\t\torigName = camelCase( name ),\n-\t\t\tisCustomProp = rcustomProp.test( name );\n-\n-\t\t\/\/ Make sure that we're working with the right name. We don't\n-\t\t\/\/ want to modify the value if it is a CSS custom property\n-\t\t\/\/ since they are user-defined.\n-\t\tif ( !isCustomProp ) {\n-\t\t\tname = finalPropName( origName );\n-\t\t}\n-\n-\t\t\/\/ Try prefixed name followed by the unprefixed name\n-\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n-\n-\t\t\/\/ If a hook was provided get the computed value from there\n-\t\tif ( hooks && \"get\" in hooks ) {\n-\t\t\tval = hooks.get( elem, true, extra );\n-\t\t}\n-\n-\t\t\/\/ Otherwise, if a way to get the computed value exists, use that\n-\t\tif ( val === undefined ) {\n-\t\t\tval = curCSS( elem, name, styles );\n-\t\t}\n-\n-\t\t\/\/ Convert \"normal\" to computed value\n-\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n-\t\t\tval = cssNormalTransform[ name ];\n-\t\t}\n-\n-\t\t\/\/ Make numeric if forced or a qualifier was provided and val looks numeric\n-\t\tif ( extra === \"\" || extra ) {\n-\t\t\tnum = parseFloat( val );\n-\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n-\t\t}\n-\n-\t\treturn val;\n-\t}\n-} );\n-\n-jQuery.each( [ \"height\", \"width\" ], function( _i, dimension ) {\n-\tjQuery.cssHooks[ dimension ] = {\n-\t\tget: function( elem, computed, extra ) {\n-\t\t\tif ( computed ) {\n-\n-\t\t\t\t\/\/ Certain elements can have dimension info if we invisibly show them\n-\t\t\t\t\/\/ but it must have a current display style that would benefit\n-\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n-\n-\t\t\t\t\t\/\/ Support: Safari 8+\n-\t\t\t\t\t\/\/ Table columns in Safari have non-zero offsetWidth & zero\n-\t\t\t\t\t\/\/ getBoundingClientRect().width unless display is changed.\n-\t\t\t\t\t\/\/ Support: IE <=11 only\n-\t\t\t\t\t\/\/ Running getBoundingClientRect on a disconnected node\n-\t\t\t\t\t\/\/ in IE throws an error.\n-\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n-\t\t\t\t\tswap( elem, cssShow, function() {\n-\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n-\t\t\t\t\t} ) :\n-\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n-\t\t\t}\n-\t\t},\n-\n-\t\tset: function( elem, value, extra ) {\n-\t\t\tvar matches,\n-\t\t\t\tstyles = getStyles( elem ),\n-\n-\t\t\t\t\/\/ Only read styles.position if the test has a chance to fail\n-\t\t\t\t\/\/ to avoid forcing a reflow.\n-\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n-\t\t\t\t\tstyles.position === \"absolute\",\n-\n-\t\t\t\t\/\/ To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n-\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n-\t\t\t\tisBorderBox = boxSizingNeeded &&\n-\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n-\t\t\t\tsubtract = extra ?\n-\t\t\t\t\tboxModelAdjustment(\n-\t\t\t\t\t\telem,\n-\t\t\t\t\t\tdimension,\n-\t\t\t\t\t\textra,\n-\t\t\t\t\t\tisBorderBox,\n-\t\t\t\t\t\tstyles\n-\t\t\t\t\t) :\n-\t\t\t\t\t0;\n-\n-\t\t\t\/\/ Account for unreliable border-box dimensions by comparing offset* to computed and\n-\t\t\t\/\/ faking a content-box to get border and padding (gh-3699)\n-\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n-\t\t\t\tsubtract -= Math.ceil(\n-\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n-\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n-\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n-\t\t\t\t\t0.5\n-\t\t\t\t);\n-\t\t\t}\n-\n-\t\t\t\/\/ Convert to pixels if value adjustment is needed\n-\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n-\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n-\n-\t\t\t\telem.style[ dimension ] = value;\n-\t\t\t\tvalue = jQuery.css( elem, dimension );\n-\t\t\t}\n-\n-\t\t\treturn setPositiveNumber( elem, value, subtract );\n-\t\t}\n-\t};\n-} );\n-\n-jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n-\tfunction( elem, computed ) {\n-\t\tif ( computed ) {\n-\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n-\t\t\t\telem.getBoundingClientRect().left -\n-\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n-\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n-\t\t\t\t\t} )\n-\t\t\t) + \"px\";\n-\t\t}\n-\t}\n-);\n-\n-\/\/ These hooks are used by animate to expand properties\n-jQuery.each( {\n-\tmargin: \"\",\n-\tpadding: \"\",\n-\tborder: \"Width\"\n-}, function( prefix, suffix ) {\n-\tjQuery.cssHooks[ prefix + suffix ] = {\n-\t\texpand: function( value ) {\n-\t\t\tvar i = 0,\n-\t\t\t\texpanded = {},\n-\n-\t\t\t\t\/\/ Assumes a single number if not a string\n-\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n-\n-\t\t\tfor ( ; i < 4; i++ ) {\n-\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n-\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n-\t\t\t}\n-\n-\t\t\treturn expanded;\n-\t\t}\n-\t};\n-\n-\tif ( prefix !== \"margin\" ) {\n-\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n-\t}\n-} );\n-\n-jQuery.fn.extend( {\n-\tcss: function( name, value ) {\n-\t\treturn access( this, function( elem, name, value ) {\n-\t\t\tvar styles, len,\n-\t\t\t\tmap = {},\n-\t\t\t\ti = 0;\n-\n-\t\t\tif ( Array.isArray( name ) ) {\n-\t\t\t\tstyles = getStyles( elem );\n-\t\t\t\tlen = name.length;\n-\n-\t\t\t\tfor ( ; i < len; i++ ) {\n-\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n-\t\t\t\t}\n-\n-\t\t\t\treturn map;\n-\t\t\t}\n-\n-\t\t\treturn value !== undefined ?\n-\t\t\t\tjQuery.style( elem, name, value ) :\n-\t\t\t\tjQuery.css( elem, name );\n-\t\t}, name, value, arguments.length > 1 );\n-\t}\n-} );\n-\n-\n-function Tween( elem, options, prop, end, easing ) {\n-\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n-}\n-jQuery.Tween = Tween;\n-\n-Tween.prototype = {\n-\tconstructor: Tween,\n-\tinit: function( elem, options, prop, end, easing, unit ) {\n-\t\tthis.elem = elem;\n-\t\tthis.prop = prop;\n-\t\tthis.easing = easing || jQuery.easing._default;\n-\t\tthis.options = options;\n-\t\tthis.start = this.now = this.cur();\n-\t\tthis.end = end;\n-\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n-\t},\n-\tcur: function() {\n-\t\tvar hooks = Tween.propHooks[ this.prop ];\n-\n-\t\treturn hooks && hooks.get ?\n-\t\t\thooks.get( this ) :\n-\t\t\tTween.propHooks._default.get( this );\n-\t},\n-\trun: function( percent ) {\n-\t\tvar eased,\n-\t\t\thooks = Tween.propHooks[ this.prop ];\n-\n-\t\tif ( this.options.duration ) {\n-\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n-\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n-\t\t\t);\n-\t\t} else {\n-\t\t\tthis.pos = eased = percent;\n-\t\t}\n-\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n-\n-\t\tif ( this.options.step ) {\n-\t\t\tthis.options.step.call( this.elem, this.now, this );\n-\t\t}\n-\n-\t\tif ( hooks && hooks.set ) {\n-\t\t\thooks.set( this );\n-\t\t} else {\n-\t\t\tTween.propHooks._default.set( this );\n-\t\t}\n-\t\treturn this;\n-\t}\n-};\n-\n-Tween.prototype.init.prototype = Tween.prototype;\n-\n-Tween.propHooks = {\n-\t_default: {\n-\t\tget: function( tween ) {\n-\t\t\tvar result;\n-\n-\t\t\t\/\/ Use a property on the element directly when it is not a DOM element,\n-\t\t\t\/\/ or when there is no matching style property that exists.\n-\t\t\tif ( tween.elem.nodeType !== 1 ||\n-\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n-\t\t\t\treturn tween.elem[ tween.prop ];\n-\t\t\t}\n-\n-\t\t\t\/\/ Passing an empty string as a 3rd parameter to .css will automatically\n-\t\t\t\/\/ attempt a parseFloat and fallback to a string if the parse fails.\n-\t\t\t\/\/ Simple values such as \"10px\" are parsed to Float;\n-\t\t\t\/\/ complex values such as \"rotate(1rad)\" are returned as-is.\n-\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n-\n-\t\t\t\/\/ Empty strings, null, undefined and \"auto\" are converted to 0.\n-\t\t\treturn !result || result === \"auto\" ? 0 : result;\n-\t\t},\n-\t\tset: function( tween ) {\n-\n-\t\t\t\/\/ Use step hook for back compat.\n-\t\t\t\/\/ Use cssHook if its there.\n-\t\t\t\/\/ Use .style if available and use plain properties where available.\n-\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n-\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n-\t\t\t} else if ( tween.elem.nodeType === 1 && (\n-\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n-\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n-\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n-\t\t\t} else {\n-\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n-\t\t\t}\n-\t\t}\n-\t}\n-};\n-\n-\/\/ Support: IE <=9 only\n-\/\/ Panic based approach to setting things on disconnected nodes\n-Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n-\tset: function( tween ) {\n-\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n-\t\t\ttween.elem[ tween.prop ] = tween.now;\n-\t\t}\n-\t}\n-};\n-\n-jQuery.easing = {\n-\tlinear: function( p ) {\n-\t\treturn p;\n-\t},\n-\tswing: function( p ) {\n-\t\treturn 0.5 - Math.cos( p * Math.PI ) \/ 2;\n-\t},\n-\t_default: \"swing\"\n-};\n-\n-jQuery.fx = Tween.prototype.init;\n-\n-\/\/ Back compat <1.8 extension point\n-jQuery.fx.step = {};\n-\n-\n-\n-\n-var\n-\tfxNow, inProgress,\n-\trfxtypes = \/^(?:toggle|show|hide)$\/,\n-\trrun = \/queueHooks$\/;\n-\n-function schedule() {\n-\tif ( inProgress ) {\n-\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n-\t\t\twindow.requestAnimationFrame( schedule );\n-\t\t} else {\n-\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n-\t\t}\n-\n-\t\tjQuery.fx.tick();\n-\t}\n-}\n-\n-\/\/ Animations created synchronously will run synchronously\n-function createFxNow() {\n-\twindow.setTimeout( function() {\n-\t\tfxNow = undefined;\n-\t} );\n-\treturn ( fxNow = Date.now() );\n-}\n-\n-\/\/ Generate parameters to create a standard animation\n-function genFx( type, includeWidth ) {\n-\tvar which,\n-\t\ti = 0,\n-\t\tattrs = { height: type };\n-\n-\t\/\/ If we include width, step value is 1 to do all cssExpand values,\n-\t\/\/ otherwise step value is 2 to skip over Left and Right\n-\tincludeWidth = includeWidth ? 1 : 0;\n-\tfor ( ; i < 4; i += 2 - includeWidth ) {\n-\t\twhich = cssExpand[ i ];\n-\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n-\t}\n-\n-\tif ( includeWidth ) {\n-\t\tattrs.opacity = attrs.width = type;\n-\t}\n-\n-\treturn attrs;\n-}\n-\n-function createTween( value, prop, animation ) {\n-\tvar tween,\n-\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n-\t\tindex = 0,\n-\t\tlength = collection.length;\n-\tfor ( ; index < length; index++ ) {\n-\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n-\n-\t\t\t\/\/ We're done with this property\n-\t\t\treturn tween;\n-\t\t}\n-\t}\n-}\n-\n-function defaultPrefilter( elem, props, opts ) {\n-\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n-\t\tisBox = \"width\" in props || \"height\" in props,\n-\t\tanim = this,\n-\t\torig = {},\n-\t\tstyle = elem.style,\n-\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n-\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n-\n-\t\/\/ Queue-skipping animations hijack the fx hooks\n-\tif ( !opts.queue ) {\n-\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n-\t\tif ( hooks.unqueued == null ) {\n-\t\t\thooks.unqueued = 0;\n-\t\t\toldfire = hooks.empty.fire;\n-\t\t\thooks.empty.fire = function() {\n-\t\t\t\tif ( !hooks.unqueued ) {\n-\t\t\t\t\toldfire();\n-\t\t\t\t}\n-\t\t\t};\n-\t\t}\n-\t\thooks.unqueued++;\n-\n-\t\tanim.always( function() {\n-\n-\t\t\t\/\/ Ensure the complete handler is called before this completes\n-\t\t\tanim.always( function() {\n-\t\t\t\thooks.unqueued--;\n-\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n-\t\t\t\t\thooks.empty.fire();\n-\t\t\t\t}\n-\t\t\t} );\n-\t\t} );\n-\t}\n-\n-\t\/\/ Detect show\/hide animations\n-\tfor ( prop in props ) {\n-\t\tvalue = props[ prop ];\n-\t\tif ( rfxtypes.test( value ) ) {\n-\t\t\tdelete props[ prop ];\n-\t\t\ttoggle = toggle || value === \"toggle\";\n-\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n-\n-\t\t\t\t\/\/ Pretend to be hidden if this is a \"show\" and\n-\t\t\t\t\/\/ there is still data from a stopped show\/hide\n-\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n-\t\t\t\t\thidden = true;\n-\n-\t\t\t\t\/\/ Ignore all other no-op show\/hide data\n-\t\t\t\t} else {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n-\t\t}\n-\t}\n-\n-\t\/\/ Bail out if this is a no-op like .hide().hide()\n-\tpropTween = !jQuery.isEmptyObject( props );\n-\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n-\t\treturn;\n-\t}\n-\n-\t\/\/ Restrict \"overflow\" and \"display\" styles during box animations\n-\tif ( isBox && elem.nodeType === 1 ) {\n-\n-\t\t\/\/ Support: IE <=9 - 11, Edge 12 - 15\n-\t\t\/\/ Record all 3 overflow attributes because IE does not infer the shorthand\n-\t\t\/\/ from identically-valued overflowX and overflowY and Edge just mirrors\n-\t\t\/\/ the overflowX value there.\n-\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n-\n-\t\t\/\/ Identify a display type, preferring old show\/hide data over the CSS cascade\n-\t\trestoreDisplay = dataShow && dataShow.display;\n-\t\tif ( restoreDisplay == null ) {\n-\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n-\t\t}\n-\t\tdisplay = jQuery.css( elem, \"display\" );\n-\t\tif ( display === \"none\" ) {\n-\t\t\tif ( restoreDisplay ) {\n-\t\t\t\tdisplay = restoreDisplay;\n-\t\t\t} else {\n-\n-\t\t\t\t\/\/ Get nonempty value(s) by temporarily forcing visibility\n-\t\t\t\tshowHide( [ elem ], true );\n-\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n-\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n-\t\t\t\tshowHide( [ elem ] );\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Animate inline elements as inline-block\n-\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n-\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n-\n-\t\t\t\t\/\/ Restore the original display value at the end of pure show\/hide animations\n-\t\t\t\tif ( !propTween ) {\n-\t\t\t\t\tanim.done( function() {\n-\t\t\t\t\t\tstyle.display = restoreDisplay;\n-\t\t\t\t\t} );\n-\t\t\t\t\tif ( restoreDisplay == null ) {\n-\t\t\t\t\t\tdisplay = style.display;\n-\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tstyle.display = \"inline-block\";\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif ( opts.overflow ) {\n-\t\tstyle.overflow = \"hidden\";\n-\t\tanim.always( function() {\n-\t\t\tstyle.overflow = opts.overflow[ 0 ];\n-\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n-\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n-\t\t} );\n-\t}\n-\n-\t\/\/ Implement show\/hide animations\n-\tpropTween = false;\n-\tfor ( prop in orig ) {\n-\n-\t\t\/\/ General show\/hide setup for this element animation\n-\t\tif ( !propTween ) {\n-\t\t\tif ( dataShow ) {\n-\t\t\t\tif ( \"hidden\" in dataShow ) {\n-\t\t\t\t\thidden = dataShow.hidden;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n-\t\t\t}\n-\n-\t\t\t\/\/ Store hidden\/visible for toggle so `.stop().toggle()` \"reverses\"\n-\t\t\tif ( toggle ) {\n-\t\t\t\tdataShow.hidden = !hidden;\n-\t\t\t}\n-\n-\t\t\t\/\/ Show elements before animating them\n-\t\t\tif ( hidden ) {\n-\t\t\t\tshowHide( [ elem ], true );\n-\t\t\t}\n-\n-\t\t\t\/* eslint-disable no-loop-func *\/\n-\n-\t\t\tanim.done( function() {\n-\n-\t\t\t\t\/* eslint-enable no-loop-func *\/\n-\n-\t\t\t\t\/\/ The final step of a \"hide\" animation is actually hiding the element\n-\t\t\t\tif ( !hidden ) {\n-\t\t\t\t\tshowHide( [ elem ] );\n-\t\t\t\t}\n-\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n-\t\t\t\tfor ( prop in orig ) {\n-\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n-\t\t\t\t}\n-\t\t\t} );\n-\t\t}\n-\n-\t\t\/\/ Per-property setup\n-\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n-\t\tif ( !( prop in dataShow ) ) {\n-\t\t\tdataShow[ prop ] = propTween.start;\n-\t\t\tif ( hidden ) {\n-\t\t\t\tpropTween.end = propTween.start;\n-\t\t\t\tpropTween.start = 0;\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-function propFilter( props, specialEasing ) {\n-\tvar index, name, easing, value, hooks;\n-\n-\t\/\/ camelCase, specialEasing and expand cssHook pass\n-\tfor ( index in props ) {\n-\t\tname = camelCase( index );\n-\t\teasing = specialEasing[ name ];\n-\t\tvalue = props[ index ];\n-\t\tif ( Array.isArray( value ) ) {\n-\t\t\teasing = value[ 1 ];\n-\t\t\tvalue = props[ index ] = value[ 0 ];\n-\t\t}\n-\n-\t\tif ( index !== name ) {\n-\t\t\tprops[ name ] = value;\n-\t\t\tdelete props[ index ];\n-\t\t}\n-\n-\t\thooks = jQuery.cssHooks[ name ];\n-\t\tif ( hooks && \"expand\" in hooks ) {\n-\t\t\tvalue = hooks.expand( value );\n-\t\t\tdelete props[ name ];\n-\n-\t\t\t\/\/ Not quite $.extend, this won't overwrite existing keys.\n-\t\t\t\/\/ Reusing 'index' because we have the correct \"name\"\n-\t\t\tfor ( index in value ) {\n-\t\t\t\tif ( !( index in props ) ) {\n-\t\t\t\t\tprops[ index ] = value[ index ];\n-\t\t\t\t\tspecialEasing[ index ] = easing;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tspecialEasing[ name ] = easing;\n-\t\t}\n-\t}\n-}\n-\n-function Animation( elem, properties, options ) {\n-\tvar result,\n-\t\tstopped,\n-\t\tindex = 0,\n-\t\tlength = Animation.prefilters.length,\n-\t\tdeferred = jQuery.Deferred().always( function() {\n-\n-\t\t\t\/\/ Don't match elem in the :animated selector\n-\t\t\tdelete tick.elem;\n-\t\t} ),\n-\t\ttick = function() {\n-\t\t\tif ( stopped ) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvar currentTime = fxNow || createFxNow(),\n-\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n-\n-\t\t\t\t\/\/ Support: Android 2.3 only\n-\t\t\t\t\/\/ Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)\n-\t\t\t\ttemp = remaining \/ animation.duration || 0,\n-\t\t\t\tpercent = 1 - temp,\n-\t\t\t\tindex = 0,\n-\t\t\t\tlength = animation.tweens.length;\n-\n-\t\t\tfor ( ; index < length; index++ ) {\n-\t\t\t\tanimation.tweens[ index ].run( percent );\n-\t\t\t}\n-\n-\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n-\n-\t\t\t\/\/ If there's more to do, yield\n-\t\t\tif ( percent < 1 && length ) {\n-\t\t\t\treturn remaining;\n-\t\t\t}\n-\n-\t\t\t\/\/ If this was an empty animation, synthesize a final progress notification\n-\t\t\tif ( !length ) {\n-\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n-\t\t\t}\n-\n-\t\t\t\/\/ Resolve the animation and report its conclusion\n-\t\t\tdeferred.resolveWith( elem, [ animation ] );\n-\t\t\treturn false;\n-\t\t},\n-\t\tanimation = deferred.promise( {\n-\t\t\telem: elem,\n-\t\t\tprops: jQuery.extend( {}, properties ),\n-\t\t\topts: jQuery.extend( true, {\n-\t\t\t\tspecialEasing: {},\n-\t\t\t\teasing: jQuery.easing._default\n-\t\t\t}, options ),\n-\t\t\toriginalProperties: properties,\n-\t\t\toriginalOptions: options,\n-\t\t\tstartTime: fxNow || createFxNow(),\n-\t\t\tduration: options.duration,\n-\t\t\ttweens: [],\n-\t\t\tcreateTween: function( prop, end ) {\n-\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n-\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n-\t\t\t\tanimation.tweens.push( tween );\n-\t\t\t\treturn tween;\n-\t\t\t},\n-\t\t\tstop: function( gotoEnd ) {\n-\t\t\t\tvar index = 0,\n-\n-\t\t\t\t\t\/\/ If we are going to the end, we want to run all the tweens\n-\t\t\t\t\t\/\/ otherwise we skip this part\n-\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n-\t\t\t\tif ( stopped ) {\n-\t\t\t\t\treturn this;\n-\t\t\t\t}\n-\t\t\t\tstopped = true;\n-\t\t\t\tfor ( ; index < length; index++ ) {\n-\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Resolve when we played the last frame; otherwise, reject\n-\t\t\t\tif ( gotoEnd ) {\n-\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n-\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n-\t\t\t\t} else {\n-\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n-\t\t\t\t}\n-\t\t\t\treturn this;\n-\t\t\t}\n-\t\t} ),\n-\t\tprops = animation.props;\n-\n-\tpropFilter( props, animation.opts.specialEasing );\n-\n-\tfor ( ; index < length; index++ ) {\n-\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n-\t\tif ( result ) {\n-\t\t\tif ( isFunction( result.stop ) ) {\n-\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n-\t\t\t\t\tresult.stop.bind( result );\n-\t\t\t}\n-\t\t\treturn result;\n-\t\t}\n-\t}\n-\n-\tjQuery.map( props, createTween, animation );\n-\n-\tif ( isFunction( animation.opts.start ) ) {\n-\t\tanimation.opts.start.call( elem, animation );\n-\t}\n-\n-\t\/\/ Attach callbacks from options\n-\tanimation\n-\t\t.progress( animation.opts.progress )\n-\t\t.done( animation.opts.done, animation.opts.complete )\n-\t\t.fail( animation.opts.fail )\n-\t\t.always( animation.opts.always );\n-\n-\tjQuery.fx.timer(\n-\t\tjQuery.extend( tick, {\n-\t\t\telem: elem,\n-\t\t\tanim: animation,\n-\t\t\tqueue: animation.opts.queue\n-\t\t} )\n-\t);\n-\n-\treturn animation;\n-}\n-\n-jQuery.Animation = jQuery.extend( Animation, {\n-\n-\ttweeners: {\n-\t\t\"*\": [ function( prop, value ) {\n-\t\t\tvar tween = this.createTween( prop, value );\n-\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n-\t\t\treturn tween;\n-\t\t} ]\n-\t},\n-\n-\ttweener: function( props, callback ) {\n-\t\tif ( isFunction( props ) ) {\n-\t\t\tcallback = props;\n-\t\t\tprops = [ \"*\" ];\n-\t\t} else {\n-\t\t\tprops = props.match( rnothtmlwhite );\n-\t\t}\n-\n-\t\tvar prop,\n-\t\t\tindex = 0,\n-\t\t\tlength = props.length;\n-\n-\t\tfor ( ; index < length; index++ ) {\n-\t\t\tprop = props[ index ];\n-\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n-\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n-\t\t}\n-\t},\n-\n-\tprefilters: [ defaultPrefilter ],\n-\n-\tprefilter: function( callback, prepend ) {\n-\t\tif ( prepend ) {\n-\t\t\tAnimation.prefilters.unshift( callback );\n-\t\t} else {\n-\t\t\tAnimation.prefilters.push( callback );\n-\t\t}\n-\t}\n-} );\n-\n-jQuery.speed = function( speed, easing, fn ) {\n-\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n-\t\tcomplete: fn || !fn && easing ||\n-\t\t\tisFunction( speed ) && speed,\n-\t\tduration: speed,\n-\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n-\t};\n-\n-\t\/\/ Go to the end state if fx are off\n-\tif ( jQuery.fx.off ) {\n-\t\topt.duration = 0;\n-\n-\t} else {\n-\t\tif ( typeof opt.duration !== \"number\" ) {\n-\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n-\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n-\n-\t\t\t} else {\n-\t\t\t\topt.duration = jQuery.fx.speeds._default;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t\/\/ Normalize opt.queue - true\/undefined\/null -> \"fx\"\n-\tif ( opt.queue == null || opt.queue === true ) {\n-\t\topt.queue = \"fx\";\n-\t}\n-\n-\t\/\/ Queueing\n-\topt.old = opt.complete;\n-\n-\topt.complete = function() {\n-\t\tif ( isFunction( opt.old ) ) {\n-\t\t\topt.old.call( this );\n-\t\t}\n-\n-\t\tif ( opt.queue ) {\n-\t\t\tjQuery.dequeue( this, opt.queue );\n-\t\t}\n-\t};\n-\n-\treturn opt;\n-};\n-\n-jQuery.fn.extend( {\n-\tfadeTo: function( speed, to, easing, callback ) {\n-\n-\t\t\/\/ Show any hidden elements after setting opacity to 0\n-\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n-\n-\t\t\t\/\/ Animate to the value specified\n-\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n-\t},\n-\tanimate: function( prop, speed, easing, callback ) {\n-\t\tvar empty = jQuery.isEmptyObject( prop ),\n-\t\t\toptall = jQuery.speed( speed, easing, callback ),\n-\t\t\tdoAnimation = function() {\n-\n-\t\t\t\t\/\/ Operate on a copy of prop so per-property easing won't be lost\n-\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n-\n-\t\t\t\t\/\/ Empty animations, or finishing resolves immediately\n-\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n-\t\t\t\t\tanim.stop( true );\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\tdoAnimation.finish = doAnimation;\n-\n-\t\treturn empty || optall.queue === false ?\n-\t\t\tthis.each( doAnimation ) :\n-\t\t\tthis.queue( optall.queue, doAnimation );\n-\t},\n-\tstop: function( type, clearQueue, gotoEnd ) {\n-\t\tvar stopQueue = function( hooks ) {\n-\t\t\tvar stop = hooks.stop;\n-\t\t\tdelete hooks.stop;\n-\t\t\tstop( gotoEnd );\n-\t\t};\n-\n-\t\tif ( typeof type !== \"string\" ) {\n-\t\t\tgotoEnd = clearQueue;\n-\t\t\tclearQueue = type;\n-\t\t\ttype = undefined;\n-\t\t}\n-\t\tif ( clearQueue ) {\n-\t\t\tthis.queue( type || \"fx\", [] );\n-\t\t}\n-\n-\t\treturn this.each( function() {\n-\t\t\tvar dequeue = true,\n-\t\t\t\tindex = type != null && type + \"queueHooks\",\n-\t\t\t\ttimers = jQuery.timers,\n-\t\t\t\tdata = dataPriv.get( this );\n-\n-\t\t\tif ( index ) {\n-\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n-\t\t\t\t\tstopQueue( data[ index ] );\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tfor ( index in data ) {\n-\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n-\t\t\t\t\t\tstopQueue( data[ index ] );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tfor ( index = timers.length; index--; ) {\n-\t\t\t\tif ( timers[ index ].elem === this &&\n-\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n-\n-\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n-\t\t\t\t\tdequeue = false;\n-\t\t\t\t\ttimers.splice( index, 1 );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t\/\/ Start the next in the queue if the last step wasn't forced.\n-\t\t\t\/\/ Timers currently will call their complete callbacks, which\n-\t\t\t\/\/ will dequeue but only if they were gotoEnd.\n-\t\t\tif ( dequeue || !gotoEnd ) {\n-\t\t\t\tjQuery.dequeue( this, type );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\tfinish: function( type ) {\n-\t\tif ( type !== false ) {\n-\t\t\ttype = type || \"fx\";\n-\t\t}\n-\t\treturn this.each( function() {\n-\t\t\tvar index,\n-\t\t\t\tdata = dataPriv.get( this ),\n-\t\t\t\tqueue = data[ type + \"queue\" ],\n-\t\t\t\thooks = data[ type + \"queueHooks\" ],\n-\t\t\t\ttimers = jQuery.timers,\n-\t\t\t\tlength = queue ? queue.length : 0;\n-\n-\t\t\t\/\/ Enable finishing flag on private data\n-\t\t\tdata.finish = true;\n-\n-\t\t\t\/\/ Empty the queue first\n-\t\t\tjQuery.queue( this, type, [] );\n-\n-\t\t\tif ( hooks && hooks.stop ) {\n-\t\t\t\thooks.stop.call( this, true );\n-\t\t\t}\n-\n-\t\t\t\/\/ Look for any active animations, and finish them\n-\t\t\tfor ( index = timers.length; index--; ) {\n-\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n-\t\t\t\t\ttimers[ index ].anim.stop( true );\n-\t\t\t\t\ttimers.splice( index, 1 );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t\/\/ Look for any animations in the old queue and finish them\n-\t\t\tfor ( index = 0; index < length; index++ ) {\n-\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n-\t\t\t\t\tqueue[ index ].finish.call( this );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t\/\/ Turn off finishing flag\n-\t\t\tdelete data.finish;\n-\t\t} );\n-\t}\n-} );\n-\n-jQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( _i, name ) {\n-\tvar cssFn = jQuery.fn[ name ];\n-\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n-\t\treturn speed == null || typeof speed === \"boolean\" ?\n-\t\t\tcssFn.apply( this, arguments ) :\n-\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n-\t};\n-} );\n-\n-\/\/ Generate shortcuts for custom animations\n-jQuery.each( {\n-\tslideDown: genFx( \"show\" ),\n-\tslideUp: genFx( \"hide\" ),\n-\tslideToggle: genFx( \"toggle\" ),\n-\tfadeIn: { opacity: \"show\" },\n-\tfadeOut: { opacity: \"hide\" },\n-\tfadeToggle: { opacity: \"toggle\" }\n-}, function( name, props ) {\n-\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n-\t\treturn this.animate( props, speed, easing, callback );\n-\t};\n-} );\n-\n-jQuery.timers = [];\n-jQuery.fx.tick = function() {\n-\tvar timer,\n-\t\ti = 0,\n-\t\ttimers = jQuery.timers;\n-\n-\tfxNow = Date.now();\n-\n-\tfor ( ; i < timers.length; i++ ) {\n-\t\ttimer = timers[ i ];\n-\n-\t\t\/\/ Run the timer and safely remove it when done (allowing for external removal)\n-\t\tif ( !timer() && timers[ i ] === timer ) {\n-\t\t\ttimers.splice( i--, 1 );\n-\t\t}\n-\t}\n-\n-\tif ( !timers.length ) {\n-\t\tjQuery.fx.stop();\n-\t}\n-\tfxNow = undefined;\n-};\n-\n-jQuery.fx.timer = function( timer ) {\n-\tjQuery.timers.push( timer );\n-\tjQuery.fx.start();\n-};\n-\n-jQuery.fx.interval = 13;\n-jQuery.fx.start = function() {\n-\tif ( inProgress ) {\n-\t\treturn;\n-\t}\n-\n-\tinProgress = true;\n-\tschedule();\n-};\n-\n-jQuery.fx.stop = function() {\n-\tinProgress = null;\n-};\n-\n-jQuery.fx.speeds = {\n-\tslow: 600,\n-\tfast: 200,\n-\n-\t\/\/ Default speed\n-\t_default: 400\n-};\n-\n-\n-\/\/ Based off of the plugin by Clint Helfers, with permission.\n-jQuery.fn.delay = function( time, type ) {\n-\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n-\ttype = type || \"fx\";\n-\n-\treturn this.queue( type, function( next, hooks ) {\n-\t\tvar timeout = window.setTimeout( next, time );\n-\t\thooks.stop = function() {\n-\t\t\twindow.clearTimeout( timeout );\n-\t\t};\n-\t} );\n-};\n-\n-\n-( function() {\n-\tvar input = document.createElement( \"input\" ),\n-\t\tselect = document.createElement( \"select\" ),\n-\t\topt = select.appendChild( document.createElement( \"option\" ) );\n-\n-\tinput.type = \"checkbox\";\n-\n-\t\/\/ Support: Android <=4.3 only\n-\t\/\/ Default value for a checkbox should be \"on\"\n-\tsupport.checkOn = input.value !== \"\";\n-\n-\t\/\/ Support: IE <=11 only\n-\t\/\/ Must access selectedIndex to make default options select\n-\tsupport.optSelected = opt.selected;\n-\n-\t\/\/ Support: IE <=11 only\n-\t\/\/ An input loses its value after becoming a radio\n-\tinput = document.createElement( \"input\" );\n-\tinput.value = \"t\";\n-\tinput.type = \"radio\";\n-\tsupport.radioValue = input.value === \"t\";\n-} )();\n-\n-\n-var boolHook,\n-\tattrHandle = jQuery.expr.attrHandle;\n-\n-jQuery.fn.extend( {\n-\tattr: function( name, value ) {\n-\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n-\t},\n-\n-\tremoveAttr: function( name ) {\n-\t\treturn this.each( function() {\n-\t\t\tjQuery.removeAttr( this, name );\n-\t\t} );\n-\t}\n-} );\n-\n-jQuery.extend( {\n-\tattr: function( elem, name, value ) {\n-\t\tvar ret, hooks,\n-\t\t\tnType = elem.nodeType;\n-\n-\t\t\/\/ Don't get\/set attributes on text, comment and attribute nodes\n-\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t\/\/ Fallback to prop when attributes are not supported\n-\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n-\t\t\treturn jQuery.prop( elem, name, value );\n-\t\t}\n-\n-\t\t\/\/ Attribute hooks are determined by the lowercase version\n-\t\t\/\/ Grab necessary hook if one is defined\n-\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n-\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n-\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n-\t\t}\n-\n-\t\tif ( value !== undefined ) {\n-\t\t\tif ( value === null ) {\n-\t\t\t\tjQuery.removeAttr( elem, name );\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tif ( hooks && \"set\" in hooks &&\n-\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n-\t\t\t\treturn ret;\n-\t\t\t}\n-\n-\t\t\telem.setAttribute( name, value + \"\" );\n-\t\t\treturn value;\n-\t\t}\n-\n-\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n-\t\t\treturn ret;\n-\t\t}\n-\n-\t\tret = jQuery.find.attr( elem, name );\n-\n-\t\t\/\/ Non-existent attributes return null, we normalize to undefined\n-\t\treturn ret == null ? undefined : ret;\n-\t},\n-\n-\tattrHooks: {\n-\t\ttype: {\n-\t\t\tset: function( elem, value ) {\n-\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n-\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n-\t\t\t\t\tvar val = elem.value;\n-\t\t\t\t\telem.setAttribute( \"type\", value );\n-\t\t\t\t\tif ( val ) {\n-\t\t\t\t\t\telem.value = val;\n-\t\t\t\t\t}\n-\t\t\t\t\treturn value;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t},\n-\n-\tremoveAttr: function( elem, value ) {\n-\t\tvar name,\n-\t\t\ti = 0,\n-\n-\t\t\t\/\/ Attribute names can contain non-HTML whitespace characters\n-\t\t\t\/\/ https:\/\/html.spec.whatwg.org\/multipage\/syntax.html#attributes-2\n-\t\t\tattrNames = value && value.match( rnothtmlwhite );\n-\n-\t\tif ( attrNames && elem.nodeType === 1 ) {\n-\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n-\t\t\t\telem.removeAttribute( name );\n-\t\t\t}\n-\t\t}\n-\t}\n-} );\n-\n-\/\/ Hooks for boolean attributes\n-boolHook = {\n-\tset: function( elem, value, name ) {\n-\t\tif ( value === false ) {\n-\n-\t\t\t\/\/ Remove boolean attributes when set to false\n-\t\t\tjQuery.removeAttr( elem, name );\n-\t\t} else {\n-\t\t\telem.setAttribute( name, name );\n-\t\t}\n-\t\treturn name;\n-\t}\n-};\n-\n-jQuery.each( jQuery.expr.match.bool.source.match( \/\\w+\/g ), function( _i, name ) {\n-\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n-\n-\tattrHandle[ name ] = function( elem, name, isXML ) {\n-\t\tvar ret, handle,\n-\t\t\tlowercaseName = name.toLowerCase();\n-\n-\t\tif ( !isXML ) {\n-\n-\t\t\t\/\/ Avoid an infinite loop by temporarily removing this function from the getter\n-\t\t\thandle = attrHandle[ lowercaseName ];\n-\t\t\tattrHandle[ lowercaseName ] = ret;\n-\t\t\tret = getter( elem, name, isXML ) != null ?\n-\t\t\t\tlowercaseName :\n-\t\t\t\tnull;\n-\t\t\tattrHandle[ lowercaseName ] = handle;\n-\t\t}\n-\t\treturn ret;\n-\t};\n-} );\n-\n-\n-\n-\n-var rfocusable = \/^(?:input|select|textarea|button)$\/i,\n-\trclickable = \/^(?:a|area)$\/i;\n-\n-jQuery.fn.extend( {\n-\tprop: function( name, value ) {\n-\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n-\t},\n-\n-\tremoveProp: function( name ) {\n-\t\treturn this.each( function() {\n-\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n-\t\t} );\n-\t}\n-} );\n-\n-jQuery.extend( {\n-\tprop: function( elem, name, value ) {\n-\t\tvar ret, hooks,\n-\t\t\tnType = elem.nodeType;\n-\n-\t\t\/\/ Don't get\/set properties on text, comment and attribute nodes\n-\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n-\n-\t\t\t\/\/ Fix name and attach hooks\n-\t\t\tname = jQuery.propFix[ name ] || name;\n-\t\t\thooks = jQuery.propHooks[ name ];\n-\t\t}\n-\n-\t\tif ( value !== undefined ) {\n-\t\t\tif ( hooks && \"set\" in hooks &&\n-\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n-\t\t\t\treturn ret;\n-\t\t\t}\n-\n-\t\t\treturn ( elem[ name ] = value );\n-\t\t}\n-\n-\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n-\t\t\treturn ret;\n-\t\t}\n-\n-\t\treturn elem[ name ];\n-\t},\n-\n-\tpropHooks: {\n-\t\ttabIndex: {\n-\t\t\tget: function( elem ) {\n-\n-\t\t\t\t\/\/ Support: IE <=9 - 11 only\n-\t\t\t\t\/\/ elem.tabIndex doesn't always return the\n-\t\t\t\t\/\/ correct value when it hasn't been explicitly set\n-\t\t\t\t\/\/ Use proper attribute retrieval (trac-12072)\n-\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n-\n-\t\t\t\tif ( tabindex ) {\n-\t\t\t\t\treturn parseInt( tabindex, 10 );\n-\t\t\t\t}\n-\n-\t\t\t\tif (\n-\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n-\t\t\t\t\trclickable.test( elem.nodeName ) &&\n-\t\t\t\t\telem.href\n-\t\t\t\t) {\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\t\t}\n-\t},\n-\n-\tpropFix: {\n-\t\t\"for\": \"htmlFor\",\n-\t\t\"class\": \"className\"\n-\t}\n-} );\n-\n-\/\/ Support: IE <=11 only\n-\/\/ Accessing the selectedIndex property\n-\/\/ forces the browser to respect setting selected\n-\/\/ on the option\n-\/\/ The getter ensures a default option is selected\n-\/\/ when in an optgroup\n-\/\/ eslint rule \"no-unused-expressions\" is disabled for this code\n-\/\/ since it considers such accessions noop\n-if ( !support.optSelected ) {\n-\tjQuery.propHooks.selected = {\n-\t\tget: function( elem ) {\n-\n-\t\t\t\/* eslint no-unused-expressions: \"off\" *\/\n-\n-\t\t\tvar parent = elem.parentNode;\n-\t\t\tif ( parent && parent.parentNode ) {\n-\t\t\t\tparent.parentNode.selectedIndex;\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t},\n-\t\tset: function( elem ) {\n-\n-\t\t\t\/* eslint no-unused-expressions: \"off\" *\/\n-\n-\t\t\tvar parent = elem.parentNode;\n-\t\t\tif ( parent ) {\n-\t\t\t\tparent.selectedIndex;\n-\n-\t\t\t\tif ( parent.parentNode ) {\n-\t\t\t\t\tparent.parentNode.selectedIndex;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-}\n-\n-jQuery.each( [\n-\t\"tabIndex\",\n-\t\"readOnly\",\n-\t\"maxLength\",\n-\t\"cellSpacing\",\n-\t\"cellPadding\",\n-\t\"rowSpan\",\n-\t\"colSpan\",\n-\t\"useMap\",\n-\t\"frameBorder\",\n-\t\"contentEditable\"\n-], function() {\n-\tjQuery.propFix[ this.toLowerCase() ] = this;\n-} );\n-\n-\n-\n-\n-\t\/\/ Strip and collapse whitespace according to HTML spec\n-\t\/\/ https:\/\/infra.spec.whatwg.org\/#strip-and-collapse-ascii-whitespace\n-\tfunction stripAndCollapse( value ) {\n-\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n-\t\treturn tokens.join( \" \" );\n-\t}\n-\n-\n-function getClass( elem ) {\n-\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n-}\n-\n-function classesToArray( value ) {\n-\tif ( Array.isArray( value ) ) {\n-\t\treturn value;\n-\t}\n-\tif ( typeof value === \"string\" ) {\n-\t\treturn value.match( rnothtmlwhite ) || [];\n-\t}\n-\treturn [];\n-}\n-\n-jQuery.fn.extend( {\n-\taddClass: function( value ) {\n-\t\tvar classNames, cur, curValue, className, i, finalValue;\n-\n-\t\tif ( isFunction( value ) ) {\n-\t\t\treturn this.each( function( j ) {\n-\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n-\t\t\t} );\n-\t\t}\n-\n-\t\tclassNames = classesToArray( value );\n-\n-\t\tif ( classNames.length ) {\n-\t\t\treturn this.each( function() {\n-\t\t\t\tcurValue = getClass( this );\n-\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n-\n-\t\t\t\tif ( cur ) {\n-\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n-\t\t\t\t\t\tclassName = classNames[ i ];\n-\t\t\t\t\t\tif ( cur.indexOf( \" \" + className + \" \" ) < 0 ) {\n-\t\t\t\t\t\t\tcur += className + \" \";\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t\/\/ Only assign if different to avoid unneeded rendering.\n-\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n-\t\t\t\t\tif ( curValue !== finalValue ) {\n-\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} );\n-\t\t}\n-\n-\t\treturn this;\n-\t},\n-\n-\tremoveClass: function( value ) {\n-\t\tvar classNames, cur, curValue, className, i, finalValue;\n-\n-\t\tif ( isFunction( value ) ) {\n-\t\t\treturn this.each( function( j ) {\n-\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n-\t\t\t} );\n-\t\t}\n-\n-\t\tif ( !arguments.length ) {\n-\t\t\treturn this.attr( \"class\", \"\" );\n-\t\t}\n-\n-\t\tclassNames = classesToArray( value );\n-\n-\t\tif ( classNames.length ) {\n-\t\t\treturn this.each( function() {\n-\t\t\t\tcurValue = getClass( this );\n-\n-\t\t\t\t\/\/ This expression is here for better compressibility (see addClass)\n-\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n-\n-\t\t\t\tif ( cur ) {\n-\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n-\t\t\t\t\t\tclassName = classNames[ i ];\n-\n-\t\t\t\t\t\t\/\/ Remove *all* instances\n-\t\t\t\t\t\twhile ( cur.indexOf( \" \" + className + \" \" ) > -1 ) {\n-\t\t\t\t\t\t\tcur = cur.replace( \" \" + className + \" \", \" \" );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t\/\/ Only assign if different to avoid unneeded rendering.\n-\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n-\t\t\t\t\tif ( curValue !== finalValue ) {\n-\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} );\n-\t\t}\n-\n-\t\treturn this;\n-\t},\n-\n-\ttoggleClass: function( value, stateVal ) {\n-\t\tvar classNames, className, i, self,\n-\t\t\ttype = typeof value,\n-\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n-\n-\t\tif ( isFunction( value ) ) {\n-\t\t\treturn this.each( function( i ) {\n-\t\t\t\tjQuery( this ).toggleClass(\n-\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n-\t\t\t\t\tstateVal\n-\t\t\t\t);\n-\t\t\t} );\n-\t\t}\n-\n-\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n-\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n-\t\t}\n-\n-\t\tclassNames = classesToArray( value );\n-\n-\t\treturn this.each( function() {\n-\t\t\tif ( isValidValue ) {\n-\n-\t\t\t\t\/\/ Toggle individual class names\n-\t\t\t\tself = jQuery( this );\n-\n-\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n-\t\t\t\t\tclassName = classNames[ i ];\n-\n-\t\t\t\t\t\/\/ Check each className given, space separated list\n-\t\t\t\t\tif ( self.hasClass( className ) ) {\n-\t\t\t\t\t\tself.removeClass( className );\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tself.addClass( className );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\/\/ Toggle whole class name\n-\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n-\t\t\t\tclassName = getClass( this );\n-\t\t\t\tif ( className ) {\n-\n-\t\t\t\t\t\/\/ Store className if set\n-\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ If the element has a class name or if we're passed `false`,\n-\t\t\t\t\/\/ then remove the whole classname (if there was one, the above saved it).\n-\t\t\t\t\/\/ Otherwise bring back whatever was previously saved (if anything),\n-\t\t\t\t\/\/ falling back to the empty string if nothing was stored.\n-\t\t\t\tif ( this.setAttribute ) {\n-\t\t\t\t\tthis.setAttribute( \"class\",\n-\t\t\t\t\t\tclassName || value === false ?\n-\t\t\t\t\t\t\t\"\" :\n-\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\thasClass: function( selector ) {\n-\t\tvar className, elem,\n-\t\t\ti = 0;\n-\n-\t\tclassName = \" \" + selector + \" \";\n-\t\twhile ( ( elem = this[ i++ ] ) ) {\n-\t\t\tif ( elem.nodeType === 1 &&\n-\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-} );\n-\n-\n-\n-\n-var rreturn = \/\\r\/g;\n-\n-jQuery.fn.extend( {\n-\tval: function( value ) {\n-\t\tvar hooks, ret, valueIsFunction,\n-\t\t\telem = this[ 0 ];\n-\n-\t\tif ( !arguments.length ) {\n-\t\t\tif ( elem ) {\n-\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n-\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n-\n-\t\t\t\tif ( hooks &&\n-\t\t\t\t\t\"get\" in hooks &&\n-\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n-\t\t\t\t) {\n-\t\t\t\t\treturn ret;\n-\t\t\t\t}\n-\n-\t\t\t\tret = elem.value;\n-\n-\t\t\t\t\/\/ Handle most common string cases\n-\t\t\t\tif ( typeof ret === \"string\" ) {\n-\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Handle cases where value is null\/undef or number\n-\t\t\t\treturn ret == null ? \"\" : ret;\n-\t\t\t}\n-\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tvalueIsFunction = isFunction( value );\n-\n-\t\treturn this.each( function( i ) {\n-\t\t\tvar val;\n-\n-\t\t\tif ( this.nodeType !== 1 ) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tif ( valueIsFunction ) {\n-\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n-\t\t\t} else {\n-\t\t\t\tval = value;\n-\t\t\t}\n-\n-\t\t\t\/\/ Treat null\/undefined as \"\"; convert numbers to string\n-\t\t\tif ( val == null ) {\n-\t\t\t\tval = \"\";\n-\n-\t\t\t} else if ( typeof val === \"number\" ) {\n-\t\t\t\tval += \"\";\n-\n-\t\t\t} else if ( Array.isArray( val ) ) {\n-\t\t\t\tval = jQuery.map( val, function( value ) {\n-\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n-\t\t\t\t} );\n-\t\t\t}\n-\n-\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n-\n-\t\t\t\/\/ If set returns undefined, fall back to normal setting\n-\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n-\t\t\t\tthis.value = val;\n-\t\t\t}\n-\t\t} );\n-\t}\n-} );\n-\n-jQuery.extend( {\n-\tvalHooks: {\n-\t\toption: {\n-\t\t\tget: function( elem ) {\n-\n-\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n-\t\t\t\treturn val != null ?\n-\t\t\t\t\tval :\n-\n-\t\t\t\t\t\/\/ Support: IE <=10 - 11 only\n-\t\t\t\t\t\/\/ option.text throws exceptions (trac-14686, trac-14858)\n-\t\t\t\t\t\/\/ Strip and collapse whitespace\n-\t\t\t\t\t\/\/ https:\/\/html.spec.whatwg.org\/#strip-and-collapse-whitespace\n-\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n-\t\t\t}\n-\t\t},\n-\t\tselect: {\n-\t\t\tget: function( elem ) {\n-\t\t\t\tvar value, option, i,\n-\t\t\t\t\toptions = elem.options,\n-\t\t\t\t\tindex = elem.selectedIndex,\n-\t\t\t\t\tone = elem.type === \"select-one\",\n-\t\t\t\t\tvalues = one ? null : [],\n-\t\t\t\t\tmax = one ? index + 1 : options.length;\n-\n-\t\t\t\tif ( index < 0 ) {\n-\t\t\t\t\ti = max;\n-\n-\t\t\t\t} else {\n-\t\t\t\t\ti = one ? index : 0;\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Loop through all the selected options\n-\t\t\t\tfor ( ; i < max; i++ ) {\n-\t\t\t\t\toption = options[ i ];\n-\n-\t\t\t\t\t\/\/ Support: IE <=9 only\n-\t\t\t\t\t\/\/ IE8-9 doesn't update selected after form reset (trac-2551)\n-\t\t\t\t\tif ( ( option.selected || i === index ) &&\n-\n-\t\t\t\t\t\t\t\/\/ Don't return options that are disabled or in a disabled optgroup\n-\t\t\t\t\t\t\t!option.disabled &&\n-\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n-\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n-\n-\t\t\t\t\t\t\/\/ Get the specific value for the option\n-\t\t\t\t\t\tvalue = jQuery( option ).val();\n-\n-\t\t\t\t\t\t\/\/ We don't need an array for one selects\n-\t\t\t\t\t\tif ( one ) {\n-\t\t\t\t\t\t\treturn value;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\/\/ Multi-Selects return an array\n-\t\t\t\t\t\tvalues.push( value );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\treturn values;\n-\t\t\t},\n-\n-\t\t\tset: function( elem, value ) {\n-\t\t\t\tvar optionSet, option,\n-\t\t\t\t\toptions = elem.options,\n-\t\t\t\t\tvalues = jQuery.makeArray( value ),\n-\t\t\t\t\ti = options.length;\n-\n-\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\toption = options[ i ];\n-\n-\t\t\t\t\t\/* eslint-disable no-cond-assign *\/\n-\n-\t\t\t\t\tif ( option.selected =\n-\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n-\t\t\t\t\t) {\n-\t\t\t\t\t\toptionSet = true;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t\/* eslint-enable no-cond-assign *\/\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Force browsers to behave consistently when non-matching value is set\n-\t\t\t\tif ( !optionSet ) {\n-\t\t\t\t\telem.selectedIndex = -1;\n-\t\t\t\t}\n-\t\t\t\treturn values;\n-\t\t\t}\n-\t\t}\n-\t}\n-} );\n-\n-\/\/ Radios and checkboxes getter\/setter\n-jQuery.each( [ \"radio\", \"checkbox\" ], function() {\n-\tjQuery.valHooks[ this ] = {\n-\t\tset: function( elem, value ) {\n-\t\t\tif ( Array.isArray( value ) ) {\n-\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n-\t\t\t}\n-\t\t}\n-\t};\n-\tif ( !support.checkOn ) {\n-\t\tjQuery.valHooks[ this ].get = function( elem ) {\n-\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n-\t\t};\n-\t}\n-} );\n-\n-\n-\n-\n-\/\/ Return jQuery for attributes-only inclusion\n-\n-\n-support.focusin = \"onfocusin\" in window;\n-\n-\n-var rfocusMorph = \/^(?:focusinfocus|focusoutblur)$\/,\n-\tstopPropagationCallback = function( e ) {\n-\t\te.stopPropagation();\n-\t};\n-\n-jQuery.extend( jQuery.event, {\n-\n-\ttrigger: function( event, data, elem, onlyHandlers ) {\n-\n-\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n-\t\t\teventPath = [ elem || document ],\n-\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n-\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n-\n-\t\tcur = lastElement = tmp = elem = elem || document;\n-\n-\t\t\/\/ Don't do events on text and comment nodes\n-\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t\/\/ focus\/blur morphs to focusin\/out; ensure we're not firing them right now\n-\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif ( type.indexOf( \".\" ) > -1 ) {\n-\n-\t\t\t\/\/ Namespaced trigger; create a regexp to match event type in handle()\n-\t\t\tnamespaces = type.split( \".\" );\n-\t\t\ttype = namespaces.shift();\n-\t\t\tnamespaces.sort();\n-\t\t}\n-\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n-\n-\t\t\/\/ Caller can pass in a jQuery.Event object, Object, or just an event type string\n-\t\tevent = event[ jQuery.expando ] ?\n-\t\t\tevent :\n-\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n-\n-\t\t\/\/ Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n-\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n-\t\tevent.namespace = namespaces.join( \".\" );\n-\t\tevent.rnamespace = event.namespace ?\n-\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n-\t\t\tnull;\n-\n-\t\t\/\/ Clean up the event in case it is being reused\n-\t\tevent.result = undefined;\n-\t\tif ( !event.target ) {\n-\t\t\tevent.target = elem;\n-\t\t}\n-\n-\t\t\/\/ Clone any incoming data and prepend the event, creating the handler arg list\n-\t\tdata = data == null ?\n-\t\t\t[ event ] :\n-\t\t\tjQuery.makeArray( data, [ event ] );\n-\n-\t\t\/\/ Allow special events to draw outside the lines\n-\t\tspecial = jQuery.event.special[ type ] || {};\n-\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t\/\/ Determine event propagation path in advance, per W3C events spec (trac-9951)\n-\t\t\/\/ Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)\n-\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n-\n-\t\t\tbubbleType = special.delegateType || type;\n-\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n-\t\t\t\tcur = cur.parentNode;\n-\t\t\t}\n-\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n-\t\t\t\teventPath.push( cur );\n-\t\t\t\ttmp = cur;\n-\t\t\t}\n-\n-\t\t\t\/\/ Only add window if we got to document (e.g., not plain obj or detached DOM)\n-\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n-\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Fire handlers on the event path\n-\t\ti = 0;\n-\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n-\t\t\tlastElement = cur;\n-\t\t\tevent.type = i > 1 ?\n-\t\t\t\tbubbleType :\n-\t\t\t\tspecial.bindType || type;\n-\n-\t\t\t\/\/ jQuery handler\n-\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || Object.create( null ) )[ event.type ] &&\n-\t\t\t\tdataPriv.get( cur, \"handle\" );\n-\t\t\tif ( handle ) {\n-\t\t\t\thandle.apply( cur, data );\n-\t\t\t}\n-\n-\t\t\t\/\/ Native handler\n-\t\t\thandle = ontype && cur[ ontype ];\n-\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n-\t\t\t\tevent.result = handle.apply( cur, data );\n-\t\t\t\tif ( event.result === false ) {\n-\t\t\t\t\tevent.preventDefault();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tevent.type = type;\n-\n-\t\t\/\/ If nobody prevented the default action, do it now\n-\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n-\n-\t\t\tif ( ( !special._default ||\n-\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n-\t\t\t\tacceptData( elem ) ) {\n-\n-\t\t\t\t\/\/ Call a native DOM method on the target with the same name as the event.\n-\t\t\t\t\/\/ Don't do default actions on window, that's where global variables be (trac-6170)\n-\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n-\n-\t\t\t\t\t\/\/ Don't re-trigger an onFOO event when we call its FOO() method\n-\t\t\t\t\ttmp = elem[ ontype ];\n-\n-\t\t\t\t\tif ( tmp ) {\n-\t\t\t\t\t\telem[ ontype ] = null;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t\/\/ Prevent re-triggering of the same event, since we already bubbled it above\n-\t\t\t\t\tjQuery.event.triggered = type;\n-\n-\t\t\t\t\tif ( event.isPropagationStopped() ) {\n-\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n-\t\t\t\t\t}\n-\n-\t\t\t\t\telem[ type ]();\n-\n-\t\t\t\t\tif ( event.isPropagationStopped() ) {\n-\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tjQuery.event.triggered = undefined;\n-\n-\t\t\t\t\tif ( tmp ) {\n-\t\t\t\t\t\telem[ ontype ] = tmp;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn event.result;\n-\t},\n-\n-\t\/\/ Piggyback on a donor event to simulate a different one\n-\t\/\/ Used only for `focus(in | out)` events\n-\tsimulate: function( type, elem, event ) {\n-\t\tvar e = jQuery.extend(\n-\t\t\tnew jQuery.Event(),\n-\t\t\tevent,\n-\t\t\t{\n-\t\t\t\ttype: type,\n-\t\t\t\tisSimulated: true\n-\t\t\t}\n-\t\t);\n-\n-\t\tjQuery.event.trigger( e, null, elem );\n-\t}\n-\n-} );\n-\n-jQuery.fn.extend( {\n-\n-\ttrigger: function( type, data ) {\n-\t\treturn this.each( function() {\n-\t\t\tjQuery.event.trigger( type, data, this );\n-\t\t} );\n-\t},\n-\ttriggerHandler: function( type, data ) {\n-\t\tvar elem = this[ 0 ];\n-\t\tif ( elem ) {\n-\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n-\t\t}\n-\t}\n-} );\n-\n-\n-\/\/ Support: Firefox <=44\n-\/\/ Firefox doesn't have focus(in | out) events\n-\/\/ Related ticket - https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=687787\n-\/\/\n-\/\/ Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n-\/\/ focus(in | out) events fire after focus & blur events,\n-\/\/ which is spec violation - http:\/\/www.w3.org\/TR\/DOM-Level-3-Events\/#events-focusevent-event-order\n-\/\/ Related ticket - https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=449857\n-if ( !support.focusin ) {\n-\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n-\n-\t\t\/\/ Attach a single capturing handler on the document while someone wants focusin\/focusout\n-\t\tvar handler = function( event ) {\n-\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n-\t\t};\n-\n-\t\tjQuery.event.special[ fix ] = {\n-\t\t\tsetup: function() {\n-\n-\t\t\t\t\/\/ Handle: regular nodes (via `this.ownerDocument`), window\n-\t\t\t\t\/\/ (via `this.document`) & document (via `this`).\n-\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n-\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n-\n-\t\t\t\tif ( !attaches ) {\n-\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n-\t\t\t\t}\n-\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n-\t\t\t},\n-\t\t\tteardown: function() {\n-\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n-\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n-\n-\t\t\t\tif ( !attaches ) {\n-\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n-\t\t\t\t\tdataPriv.remove( doc, fix );\n-\n-\t\t\t\t} else {\n-\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t} );\n-}\n-var location = window.location;\n-\n-var nonce = { guid: Date.now() };\n-\n-var rquery = ( \/\\?\/ );\n-\n-\n-\n-\/\/ Cross-browser xml parsing\n-jQuery.parseXML = function( data ) {\n-\tvar xml, parserErrorElem;\n-\tif ( !data || typeof data !== \"string\" ) {\n-\t\treturn null;\n-\t}\n-\n-\t\/\/ Support: IE 9 - 11 only\n-\t\/\/ IE throws on parseFromString with invalid input.\n-\ttry {\n-\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text\/xml\" );\n-\t} catch ( e ) {}\n-\n-\tparserErrorElem = xml && xml.getElementsByTagName( \"parsererror\" )[ 0 ];\n-\tif ( !xml || parserErrorElem ) {\n-\t\tjQuery.error( \"Invalid XML: \" + (\n-\t\t\tparserErrorElem ?\n-\t\t\t\tjQuery.map( parserErrorElem.childNodes, function( el ) {\n-\t\t\t\t\treturn el.textContent;\n-\t\t\t\t} ).join( \"\\n\" ) :\n-\t\t\t\tdata\n-\t\t) );\n-\t}\n-\treturn xml;\n-};\n-\n-\n-var\n-\trbracket = \/\\[\\]$\/,\n-\trCRLF = \/\\r?\\n\/g,\n-\trsubmitterTypes = \/^(?:submit|button|image|reset|file)$\/i,\n-\trsubmittable = \/^(?:input|select|textarea|keygen)\/i;\n-\n-function buildParams( prefix, obj, traditional, add ) {\n-\tvar name;\n-\n-\tif ( Array.isArray( obj ) ) {\n-\n-\t\t\/\/ Serialize array item.\n-\t\tjQuery.each( obj, function( i, v ) {\n-\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n-\n-\t\t\t\t\/\/ Treat each array item as a scalar.\n-\t\t\t\tadd( prefix, v );\n-\n-\t\t\t} else {\n-\n-\t\t\t\t\/\/ Item is non-scalar (array or object), encode its numeric index.\n-\t\t\t\tbuildParams(\n-\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n-\t\t\t\t\tv,\n-\t\t\t\t\ttraditional,\n-\t\t\t\t\tadd\n-\t\t\t\t);\n-\t\t\t}\n-\t\t} );\n-\n-\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n-\n-\t\t\/\/ Serialize object item.\n-\t\tfor ( name in obj ) {\n-\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n-\t\t}\n-\n-\t} else {\n-\n-\t\t\/\/ Serialize scalar item.\n-\t\tadd( prefix, obj );\n-\t}\n-}\n-\n-\/\/ Serialize an array of form elements or a set of\n-\/\/ key\/values into a query string\n-jQuery.param = function( a, traditional ) {\n-\tvar prefix,\n-\t\ts = [],\n-\t\tadd = function( key, valueOrFunction ) {\n-\n-\t\t\t\/\/ If value is a function, invoke it and use its return value\n-\t\t\tvar value = isFunction( valueOrFunction ) ?\n-\t\t\t\tvalueOrFunction() :\n-\t\t\t\tvalueOrFunction;\n-\n-\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n-\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n-\t\t};\n-\n-\tif ( a == null ) {\n-\t\treturn \"\";\n-\t}\n-\n-\t\/\/ If an array was passed in, assume that it is an array of form elements.\n-\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n-\n-\t\t\/\/ Serialize the form elements\n-\t\tjQuery.each( a, function() {\n-\t\t\tadd( this.name, this.value );\n-\t\t} );\n-\n-\t} else {\n-\n-\t\t\/\/ If traditional, encode the \"old\" way (the way 1.3.2 or older\n-\t\t\/\/ did it), otherwise encode params recursively.\n-\t\tfor ( prefix in a ) {\n-\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n-\t\t}\n-\t}\n-\n-\t\/\/ Return the resulting serialization\n-\treturn s.join( \"&\" );\n-};\n-\n-jQuery.fn.extend( {\n-\tserialize: function() {\n-\t\treturn jQuery.param( this.serializeArray() );\n-\t},\n-\tserializeArray: function() {\n-\t\treturn this.map( function() {\n-\n-\t\t\t\/\/ Can add propHook for \"elements\" to filter or add form elements\n-\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n-\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n-\t\t} ).filter( function() {\n-\t\t\tvar type = this.type;\n-\n-\t\t\t\/\/ Use .is( \":disabled\" ) so that fieldset[disabled] works\n-\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n-\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n-\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n-\t\t} ).map( function( _i, elem ) {\n-\t\t\tvar val = jQuery( this ).val();\n-\n-\t\t\tif ( val == null ) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\tif ( Array.isArray( val ) ) {\n-\t\t\t\treturn jQuery.map( val, function( val ) {\n-\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n-\t\t\t\t} );\n-\t\t\t}\n-\n-\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n-\t\t} ).get();\n-\t}\n-} );\n-\n-\n-var\n-\tr20 = \/%20\/g,\n-\trhash = \/#.*$\/,\n-\trantiCache = \/([?&])_=[^&]*\/,\n-\trheaders = \/^(.*?):[ \\t]*([^\\r\\n]*)$\/mg,\n-\n-\t\/\/ trac-7653, trac-8125, trac-8152: local protocol detection\n-\trlocalProtocol = \/^(?:about|app|app-storage|.+-extension|file|res|widget):$\/,\n-\trnoContent = \/^(?:GET|HEAD)$\/,\n-\trprotocol = \/^\\\/\\\/\/,\n-\n-\t\/* Prefilters\n-\t * 1) They are useful to introduce custom dataTypes (see ajax\/jsonp.js for an example)\n-\t * 2) These are called:\n-\t *    - BEFORE asking for a transport\n-\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n-\t * 3) key is the dataType\n-\t * 4) the catchall symbol \"*\" can be used\n-\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n-\t *\/\n-\tprefilters = {},\n-\n-\t\/* Transports bindings\n-\t * 1) key is the dataType\n-\t * 2) the catchall symbol \"*\" can be used\n-\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n-\t *\/\n-\ttransports = {},\n-\n-\t\/\/ Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression\n-\tallTypes = \"*\/\".concat( \"*\" ),\n-\n-\t\/\/ Anchor tag for parsing the document origin\n-\toriginAnchor = document.createElement( \"a\" );\n-\n-originAnchor.href = location.href;\n-\n-\/\/ Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n-function addToPrefiltersOrTransports( structure ) {\n-\n-\t\/\/ dataTypeExpression is optional and defaults to \"*\"\n-\treturn function( dataTypeExpression, func ) {\n-\n-\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n-\t\t\tfunc = dataTypeExpression;\n-\t\t\tdataTypeExpression = \"*\";\n-\t\t}\n-\n-\t\tvar dataType,\n-\t\t\ti = 0,\n-\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n-\n-\t\tif ( isFunction( func ) ) {\n-\n-\t\t\t\/\/ For each dataType in the dataTypeExpression\n-\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n-\n-\t\t\t\t\/\/ Prepend if requested\n-\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n-\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n-\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n-\n-\t\t\t\t\/\/ Otherwise append\n-\t\t\t\t} else {\n-\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-}\n-\n-\/\/ Base inspection function for prefilters and transports\n-function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n-\n-\tvar inspected = {},\n-\t\tseekingTransport = ( structure === transports );\n-\n-\tfunction inspect( dataType ) {\n-\t\tvar selected;\n-\t\tinspected[ dataType ] = true;\n-\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n-\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n-\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n-\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n-\n-\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n-\t\t\t\tinspect( dataTypeOrTransport );\n-\t\t\t\treturn false;\n-\t\t\t} else if ( seekingTransport ) {\n-\t\t\t\treturn !( selected = dataTypeOrTransport );\n-\t\t\t}\n-\t\t} );\n-\t\treturn selected;\n-\t}\n-\n-\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n-}\n-\n-\/\/ A special extend for ajax options\n-\/\/ that takes \"flat\" options (not to be deep extended)\n-\/\/ Fixes trac-9887\n-function ajaxExtend( target, src ) {\n-\tvar key, deep,\n-\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n-\n-\tfor ( key in src ) {\n-\t\tif ( src[ key ] !== undefined ) {\n-\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n-\t\t}\n-\t}\n-\tif ( deep ) {\n-\t\tjQuery.extend( true, target, deep );\n-\t}\n-\n-\treturn target;\n-}\n-\n-\/* Handles responses to an ajax request:\n- * - finds the right dataType (mediates between content-type and expected dataType)\n- * - returns the corresponding response\n- *\/\n-function ajaxHandleResponses( s, jqXHR, responses ) {\n-\n-\tvar ct, type, finalDataType, firstDataType,\n-\t\tcontents = s.contents,\n-\t\tdataTypes = s.dataTypes;\n-\n-\t\/\/ Remove auto dataType and get content-type in the process\n-\twhile ( dataTypes[ 0 ] === \"*\" ) {\n-\t\tdataTypes.shift();\n-\t\tif ( ct === undefined ) {\n-\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n-\t\t}\n-\t}\n-\n-\t\/\/ Check if we're dealing with a known content-type\n-\tif ( ct ) {\n-\t\tfor ( type in contents ) {\n-\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n-\t\t\t\tdataTypes.unshift( type );\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t\/\/ Check to see if we have a response for the expected dataType\n-\tif ( dataTypes[ 0 ] in responses ) {\n-\t\tfinalDataType = dataTypes[ 0 ];\n-\t} else {\n-\n-\t\t\/\/ Try convertible dataTypes\n-\t\tfor ( type in responses ) {\n-\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n-\t\t\t\tfinalDataType = type;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif ( !firstDataType ) {\n-\t\t\t\tfirstDataType = type;\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Or just use first one\n-\t\tfinalDataType = finalDataType || firstDataType;\n-\t}\n-\n-\t\/\/ If we found a dataType\n-\t\/\/ We add the dataType to the list if needed\n-\t\/\/ and return the corresponding response\n-\tif ( finalDataType ) {\n-\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n-\t\t\tdataTypes.unshift( finalDataType );\n-\t\t}\n-\t\treturn responses[ finalDataType ];\n-\t}\n-}\n-\n-\/* Chain conversions given the request and the original response\n- * Also sets the responseXXX fields on the jqXHR instance\n- *\/\n-function ajaxConvert( s, response, jqXHR, isSuccess ) {\n-\tvar conv2, current, conv, tmp, prev,\n-\t\tconverters = {},\n-\n-\t\t\/\/ Work with a copy of dataTypes in case we need to modify it for conversion\n-\t\tdataTypes = s.dataTypes.slice();\n-\n-\t\/\/ Create converters map with lowercased keys\n-\tif ( dataTypes[ 1 ] ) {\n-\t\tfor ( conv in s.converters ) {\n-\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n-\t\t}\n-\t}\n-\n-\tcurrent = dataTypes.shift();\n-\n-\t\/\/ Convert to each sequential dataType\n-\twhile ( current ) {\n-\n-\t\tif ( s.responseFields[ current ] ) {\n-\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n-\t\t}\n-\n-\t\t\/\/ Apply the dataFilter if provided\n-\t\tif ( !prev && isSuccess && s.dataFilter ) {\n-\t\t\tresponse = s.dataFilter( response, s.dataType );\n-\t\t}\n-\n-\t\tprev = current;\n-\t\tcurrent = dataTypes.shift();\n-\n-\t\tif ( current ) {\n-\n-\t\t\t\/\/ There's only work to do if current dataType is non-auto\n-\t\t\tif ( current === \"*\" ) {\n-\n-\t\t\t\tcurrent = prev;\n-\n-\t\t\t\/\/ Convert response if prev dataType is non-auto and differs from current\n-\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n-\n-\t\t\t\t\/\/ Seek a direct converter\n-\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n-\n-\t\t\t\t\/\/ If none found, seek a pair\n-\t\t\t\tif ( !conv ) {\n-\t\t\t\t\tfor ( conv2 in converters ) {\n-\n-\t\t\t\t\t\t\/\/ If conv2 outputs current\n-\t\t\t\t\t\ttmp = conv2.split( \" \" );\n-\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n-\n-\t\t\t\t\t\t\t\/\/ If prev can be converted to accepted input\n-\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n-\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n-\t\t\t\t\t\t\tif ( conv ) {\n-\n-\t\t\t\t\t\t\t\t\/\/ Condense equivalence converters\n-\t\t\t\t\t\t\t\tif ( conv === true ) {\n-\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n-\n-\t\t\t\t\t\t\t\t\/\/ Otherwise, insert the intermediate dataType\n-\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n-\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n-\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Apply converter (if not an equivalence)\n-\t\t\t\tif ( conv !== true ) {\n-\n-\t\t\t\t\t\/\/ Unless errors are allowed to bubble, catch and return them\n-\t\t\t\t\tif ( conv && s.throws ) {\n-\t\t\t\t\t\tresponse = conv( response );\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tresponse = conv( response );\n-\t\t\t\t\t\t} catch ( e ) {\n-\t\t\t\t\t\t\treturn {\n-\t\t\t\t\t\t\t\tstate: \"parsererror\",\n-\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n-\t\t\t\t\t\t\t};\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn { state: \"success\", data: response };\n-}\n-\n-jQuery.extend( {\n-\n-\t\/\/ Counter for holding the number of active queries\n-\tactive: 0,\n-\n-\t\/\/ Last-Modified header cache for next request\n-\tlastModified: {},\n-\tetag: {},\n-\n-\tajaxSettings: {\n-\t\turl: location.href,\n-\t\ttype: \"GET\",\n-\t\tisLocal: rlocalProtocol.test( location.protocol ),\n-\t\tglobal: true,\n-\t\tprocessData: true,\n-\t\tasync: true,\n-\t\tcontentType: \"application\/x-www-form-urlencoded; charset=UTF-8\",\n-\n-\t\t\/*\n-\t\ttimeout: 0,\n-\t\tdata: null,\n-\t\tdataType: null,\n-\t\tusername: null,\n-\t\tpassword: null,\n-\t\tcache: null,\n-\t\tthrows: false,\n-\t\ttraditional: false,\n-\t\theaders: {},\n-\t\t*\/\n-\n-\t\taccepts: {\n-\t\t\t\"*\": allTypes,\n-\t\t\ttext: \"text\/plain\",\n-\t\t\thtml: \"text\/html\",\n-\t\t\txml: \"application\/xml, text\/xml\",\n-\t\t\tjson: \"application\/json, text\/javascript\"\n-\t\t},\n-\n-\t\tcontents: {\n-\t\t\txml: \/\\bxml\\b\/,\n-\t\t\thtml: \/\\bhtml\/,\n-\t\t\tjson: \/\\bjson\\b\/\n-\t\t},\n-\n-\t\tresponseFields: {\n-\t\t\txml: \"responseXML\",\n-\t\t\ttext: \"responseText\",\n-\t\t\tjson: \"responseJSON\"\n-\t\t},\n-\n-\t\t\/\/ Data converters\n-\t\t\/\/ Keys separate source (or catchall \"*\") and destination types with a single space\n-\t\tconverters: {\n-\n-\t\t\t\/\/ Convert anything to text\n-\t\t\t\"* text\": String,\n-\n-\t\t\t\/\/ Text to html (true = no transformation)\n-\t\t\t\"text html\": true,\n-\n-\t\t\t\/\/ Evaluate text as a json expression\n-\t\t\t\"text json\": JSON.parse,\n-\n-\t\t\t\/\/ Parse text as xml\n-\t\t\t\"text xml\": jQuery.parseXML\n-\t\t},\n-\n-\t\t\/\/ For options that shouldn't be deep extended:\n-\t\t\/\/ you can add your own custom options here if\n-\t\t\/\/ and when you create one that shouldn't be\n-\t\t\/\/ deep extended (see ajaxExtend)\n-\t\tflatOptions: {\n-\t\t\turl: true,\n-\t\t\tcontext: true\n-\t\t}\n-\t},\n-\n-\t\/\/ Creates a full fledged settings object into target\n-\t\/\/ with both ajaxSettings and settings fields.\n-\t\/\/ If target is omitted, writes into ajaxSettings.\n-\tajaxSetup: function( target, settings ) {\n-\t\treturn settings ?\n-\n-\t\t\t\/\/ Building a settings object\n-\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n-\n-\t\t\t\/\/ Extending ajaxSettings\n-\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n-\t},\n-\n-\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n-\tajaxTransport: addToPrefiltersOrTransports( transports ),\n-\n-\t\/\/ Main method\n-\tajax: function( url, options ) {\n-\n-\t\t\/\/ If url is an object, simulate pre-1.5 signature\n-\t\tif ( typeof url === \"object\" ) {\n-\t\t\toptions = url;\n-\t\t\turl = undefined;\n-\t\t}\n-\n-\t\t\/\/ Force options to be an object\n-\t\toptions = options || {};\n-\n-\t\tvar transport,\n-\n-\t\t\t\/\/ URL without anti-cache param\n-\t\t\tcacheURL,\n-\n-\t\t\t\/\/ Response headers\n-\t\t\tresponseHeadersString,\n-\t\t\tresponseHeaders,\n-\n-\t\t\t\/\/ timeout handle\n-\t\t\ttimeoutTimer,\n-\n-\t\t\t\/\/ Url cleanup var\n-\t\t\turlAnchor,\n-\n-\t\t\t\/\/ Request state (becomes false upon send and true upon completion)\n-\t\t\tcompleted,\n-\n-\t\t\t\/\/ To know if global events are to be dispatched\n-\t\t\tfireGlobals,\n-\n-\t\t\t\/\/ Loop variable\n-\t\t\ti,\n-\n-\t\t\t\/\/ uncached part of the url\n-\t\t\tuncached,\n-\n-\t\t\t\/\/ Create the final options object\n-\t\t\ts = jQuery.ajaxSetup( {}, options ),\n-\n-\t\t\t\/\/ Callbacks context\n-\t\t\tcallbackContext = s.context || s,\n-\n-\t\t\t\/\/ Context for global events is callbackContext if it is a DOM node or jQuery collection\n-\t\t\tglobalEventContext = s.context &&\n-\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n-\t\t\t\tjQuery( callbackContext ) :\n-\t\t\t\tjQuery.event,\n-\n-\t\t\t\/\/ Deferreds\n-\t\t\tdeferred = jQuery.Deferred(),\n-\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n-\n-\t\t\t\/\/ Status-dependent callbacks\n-\t\t\tstatusCode = s.statusCode || {},\n-\n-\t\t\t\/\/ Headers (they are sent all at once)\n-\t\t\trequestHeaders = {},\n-\t\t\trequestHeadersNames = {},\n-\n-\t\t\t\/\/ Default abort message\n-\t\t\tstrAbort = \"canceled\",\n-\n-\t\t\t\/\/ Fake xhr\n-\t\t\tjqXHR = {\n-\t\t\t\treadyState: 0,\n-\n-\t\t\t\t\/\/ Builds headers hashtable if needed\n-\t\t\t\tgetResponseHeader: function( key ) {\n-\t\t\t\t\tvar match;\n-\t\t\t\t\tif ( completed ) {\n-\t\t\t\t\t\tif ( !responseHeaders ) {\n-\t\t\t\t\t\t\tresponseHeaders = {};\n-\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n-\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n-\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n-\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n-\t\t\t\t\t}\n-\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n-\t\t\t\t},\n-\n-\t\t\t\t\/\/ Raw string\n-\t\t\t\tgetAllResponseHeaders: function() {\n-\t\t\t\t\treturn completed ? responseHeadersString : null;\n-\t\t\t\t},\n-\n-\t\t\t\t\/\/ Caches the header\n-\t\t\t\tsetRequestHeader: function( name, value ) {\n-\t\t\t\t\tif ( completed == null ) {\n-\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n-\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n-\t\t\t\t\t\trequestHeaders[ name ] = value;\n-\t\t\t\t\t}\n-\t\t\t\t\treturn this;\n-\t\t\t\t},\n-\n-\t\t\t\t\/\/ Overrides response content-type header\n-\t\t\t\toverrideMimeType: function( type ) {\n-\t\t\t\t\tif ( completed == null ) {\n-\t\t\t\t\t\ts.mimeType = type;\n-\t\t\t\t\t}\n-\t\t\t\t\treturn this;\n-\t\t\t\t},\n-\n-\t\t\t\t\/\/ Status-dependent callbacks\n-\t\t\t\tstatusCode: function( map ) {\n-\t\t\t\t\tvar code;\n-\t\t\t\t\tif ( map ) {\n-\t\t\t\t\t\tif ( completed ) {\n-\n-\t\t\t\t\t\t\t\/\/ Execute the appropriate callbacks\n-\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n-\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t\/\/ Lazy-add the new callbacks in a way that preserves old ones\n-\t\t\t\t\t\t\tfor ( code in map ) {\n-\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\treturn this;\n-\t\t\t\t},\n-\n-\t\t\t\t\/\/ Cancel the request\n-\t\t\t\tabort: function( statusText ) {\n-\t\t\t\t\tvar finalText = statusText || strAbort;\n-\t\t\t\t\tif ( transport ) {\n-\t\t\t\t\t\ttransport.abort( finalText );\n-\t\t\t\t\t}\n-\t\t\t\t\tdone( 0, finalText );\n-\t\t\t\t\treturn this;\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\t\/\/ Attach deferreds\n-\t\tdeferred.promise( jqXHR );\n-\n-\t\t\/\/ Add protocol if not provided (prefilters might expect it)\n-\t\t\/\/ Handle falsy url in the settings object (trac-10093: consistency with old signature)\n-\t\t\/\/ We also use the url parameter if available\n-\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n-\t\t\t.replace( rprotocol, location.protocol + \"\/\/\" );\n-\n-\t\t\/\/ Alias method option to type as per ticket trac-12004\n-\t\ts.type = options.method || options.type || s.method || s.type;\n-\n-\t\t\/\/ Extract dataTypes list\n-\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n-\n-\t\t\/\/ A cross-domain request is in order when the origin doesn't match the current origin.\n-\t\tif ( s.crossDomain == null ) {\n-\t\t\turlAnchor = document.createElement( \"a\" );\n-\n-\t\t\t\/\/ Support: IE <=8 - 11, Edge 12 - 15\n-\t\t\t\/\/ IE throws exception on accessing the href property if url is malformed,\n-\t\t\t\/\/ e.g. http:\/\/example.com:80x\/\n-\t\t\ttry {\n-\t\t\t\turlAnchor.href = s.url;\n-\n-\t\t\t\t\/\/ Support: IE <=8 - 11 only\n-\t\t\t\t\/\/ Anchor's host property isn't correctly set when s.url is relative\n-\t\t\t\turlAnchor.href = urlAnchor.href;\n-\t\t\t\ts.crossDomain = originAnchor.protocol + \"\/\/\" + originAnchor.host !==\n-\t\t\t\t\turlAnchor.protocol + \"\/\/\" + urlAnchor.host;\n-\t\t\t} catch ( e ) {\n-\n-\t\t\t\t\/\/ If there is an error parsing the URL, assume it is crossDomain,\n-\t\t\t\t\/\/ it can be rejected by the transport if it is invalid\n-\t\t\t\ts.crossDomain = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Convert data if not already a string\n-\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n-\t\t\ts.data = jQuery.param( s.data, s.traditional );\n-\t\t}\n-\n-\t\t\/\/ Apply prefilters\n-\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n-\n-\t\t\/\/ If request was aborted inside a prefilter, stop there\n-\t\tif ( completed ) {\n-\t\t\treturn jqXHR;\n-\t\t}\n-\n-\t\t\/\/ We can fire global events as of now if asked to\n-\t\t\/\/ Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)\n-\t\tfireGlobals = jQuery.event && s.global;\n-\n-\t\t\/\/ Watch for a new set of requests\n-\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n-\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n-\t\t}\n-\n-\t\t\/\/ Uppercase the type\n-\t\ts.type = s.type.toUpperCase();\n-\n-\t\t\/\/ Determine if request has content\n-\t\ts.hasContent = !rnoContent.test( s.type );\n-\n-\t\t\/\/ Save the URL in case we're toying with the If-Modified-Since\n-\t\t\/\/ and\/or If-None-Match header later on\n-\t\t\/\/ Remove hash to simplify url manipulation\n-\t\tcacheURL = s.url.replace( rhash, \"\" );\n-\n-\t\t\/\/ More options handling for requests with no content\n-\t\tif ( !s.hasContent ) {\n-\n-\t\t\t\/\/ Remember the hash so we can put it back\n-\t\t\tuncached = s.url.slice( cacheURL.length );\n-\n-\t\t\t\/\/ If data is available and should be processed, append data to url\n-\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n-\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n-\n-\t\t\t\t\/\/ trac-9682: remove data so that it's not used in an eventual retry\n-\t\t\t\tdelete s.data;\n-\t\t\t}\n-\n-\t\t\t\/\/ Add or update anti-cache param if needed\n-\t\t\tif ( s.cache === false ) {\n-\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n-\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce.guid++ ) +\n-\t\t\t\t\tuncached;\n-\t\t\t}\n-\n-\t\t\t\/\/ Put hash and anti-cache on the URL that will be requested (gh-1732)\n-\t\t\ts.url = cacheURL + uncached;\n-\n-\t\t\/\/ Change '%20' to '+' if this is encoded form body content (gh-2658)\n-\t\t} else if ( s.data && s.processData &&\n-\t\t\t( s.contentType || \"\" ).indexOf( \"application\/x-www-form-urlencoded\" ) === 0 ) {\n-\t\t\ts.data = s.data.replace( r20, \"+\" );\n-\t\t}\n-\n-\t\t\/\/ Set the If-Modified-Since and\/or If-None-Match header, if in ifModified mode.\n-\t\tif ( s.ifModified ) {\n-\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n-\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n-\t\t\t}\n-\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n-\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Set the correct header, if data is being sent\n-\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n-\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n-\t\t}\n-\n-\t\t\/\/ Set the Accepts header for the server, depending on the dataType\n-\t\tjqXHR.setRequestHeader(\n-\t\t\t\"Accept\",\n-\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n-\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n-\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n-\t\t\t\ts.accepts[ \"*\" ]\n-\t\t);\n-\n-\t\t\/\/ Check for headers option\n-\t\tfor ( i in s.headers ) {\n-\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n-\t\t}\n-\n-\t\t\/\/ Allow custom headers\/mimetypes and early abort\n-\t\tif ( s.beforeSend &&\n-\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n-\n-\t\t\t\/\/ Abort if not done already and return\n-\t\t\treturn jqXHR.abort();\n-\t\t}\n-\n-\t\t\/\/ Aborting is no longer a cancellation\n-\t\tstrAbort = \"abort\";\n-\n-\t\t\/\/ Install callbacks on deferreds\n-\t\tcompleteDeferred.add( s.complete );\n-\t\tjqXHR.done( s.success );\n-\t\tjqXHR.fail( s.error );\n-\n-\t\t\/\/ Get transport\n-\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n-\n-\t\t\/\/ If no transport, we auto-abort\n-\t\tif ( !transport ) {\n-\t\t\tdone( -1, \"No Transport\" );\n-\t\t} else {\n-\t\t\tjqXHR.readyState = 1;\n-\n-\t\t\t\/\/ Send global event\n-\t\t\tif ( fireGlobals ) {\n-\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n-\t\t\t}\n-\n-\t\t\t\/\/ If request was aborted inside ajaxSend, stop there\n-\t\t\tif ( completed ) {\n-\t\t\t\treturn jqXHR;\n-\t\t\t}\n-\n-\t\t\t\/\/ Timeout\n-\t\t\tif ( s.async && s.timeout > 0 ) {\n-\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n-\t\t\t\t\tjqXHR.abort( \"timeout\" );\n-\t\t\t\t}, s.timeout );\n-\t\t\t}\n-\n-\t\t\ttry {\n-\t\t\t\tcompleted = false;\n-\t\t\t\ttransport.send( requestHeaders, done );\n-\t\t\t} catch ( e ) {\n-\n-\t\t\t\t\/\/ Rethrow post-completion exceptions\n-\t\t\t\tif ( completed ) {\n-\t\t\t\t\tthrow e;\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Propagate others as results\n-\t\t\t\tdone( -1, e );\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Callback for when everything is done\n-\t\tfunction done( status, nativeStatusText, responses, headers ) {\n-\t\t\tvar isSuccess, success, error, response, modified,\n-\t\t\t\tstatusText = nativeStatusText;\n-\n-\t\t\t\/\/ Ignore repeat invocations\n-\t\t\tif ( completed ) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tcompleted = true;\n-\n-\t\t\t\/\/ Clear timeout if it exists\n-\t\t\tif ( timeoutTimer ) {\n-\t\t\t\twindow.clearTimeout( timeoutTimer );\n-\t\t\t}\n-\n-\t\t\t\/\/ Dereference transport for early garbage collection\n-\t\t\t\/\/ (no matter how long the jqXHR object will be used)\n-\t\t\ttransport = undefined;\n-\n-\t\t\t\/\/ Cache response headers\n-\t\t\tresponseHeadersString = headers || \"\";\n-\n-\t\t\t\/\/ Set readyState\n-\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n-\n-\t\t\t\/\/ Determine if successful\n-\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n-\n-\t\t\t\/\/ Get response data\n-\t\t\tif ( responses ) {\n-\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n-\t\t\t}\n-\n-\t\t\t\/\/ Use a noop converter for missing script but not if jsonp\n-\t\t\tif ( !isSuccess &&\n-\t\t\t\tjQuery.inArray( \"script\", s.dataTypes ) > -1 &&\n-\t\t\t\tjQuery.inArray( \"json\", s.dataTypes ) < 0 ) {\n-\t\t\t\ts.converters[ \"text script\" ] = function() {};\n-\t\t\t}\n-\n-\t\t\t\/\/ Convert no matter what (that way responseXXX fields are always set)\n-\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n-\n-\t\t\t\/\/ If successful, handle type chaining\n-\t\t\tif ( isSuccess ) {\n-\n-\t\t\t\t\/\/ Set the If-Modified-Since and\/or If-None-Match header, if in ifModified mode.\n-\t\t\t\tif ( s.ifModified ) {\n-\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n-\t\t\t\t\tif ( modified ) {\n-\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n-\t\t\t\t\t}\n-\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n-\t\t\t\t\tif ( modified ) {\n-\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ if no content\n-\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n-\t\t\t\t\tstatusText = \"nocontent\";\n-\n-\t\t\t\t\/\/ if not modified\n-\t\t\t\t} else if ( status === 304 ) {\n-\t\t\t\t\tstatusText = \"notmodified\";\n-\n-\t\t\t\t\/\/ If we have data, let's convert it\n-\t\t\t\t} else {\n-\t\t\t\t\tstatusText = response.state;\n-\t\t\t\t\tsuccess = response.data;\n-\t\t\t\t\terror = response.error;\n-\t\t\t\t\tisSuccess = !error;\n-\t\t\t\t}\n-\t\t\t} else {\n-\n-\t\t\t\t\/\/ Extract error from statusText and normalize for non-aborts\n-\t\t\t\terror = statusText;\n-\t\t\t\tif ( status || !statusText ) {\n-\t\t\t\t\tstatusText = \"error\";\n-\t\t\t\t\tif ( status < 0 ) {\n-\t\t\t\t\t\tstatus = 0;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t\/\/ Set data for the fake xhr object\n-\t\t\tjqXHR.status = status;\n-\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n-\n-\t\t\t\/\/ Success\/Error\n-\t\t\tif ( isSuccess ) {\n-\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n-\t\t\t} else {\n-\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n-\t\t\t}\n-\n-\t\t\t\/\/ Status-dependent callbacks\n-\t\t\tjqXHR.statusCode( statusCode );\n-\t\t\tstatusCode = undefined;\n-\n-\t\t\tif ( fireGlobals ) {\n-\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n-\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n-\t\t\t}\n-\n-\t\t\t\/\/ Complete\n-\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n-\n-\t\t\tif ( fireGlobals ) {\n-\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n-\n-\t\t\t\t\/\/ Handle the global AJAX counter\n-\t\t\t\tif ( !( --jQuery.active ) ) {\n-\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn jqXHR;\n-\t},\n-\n-\tgetJSON: function( url, data, callback ) {\n-\t\treturn jQuery.get( url, data, callback, \"json\" );\n-\t},\n-\n-\tgetScript: function( url, callback ) {\n-\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n-\t}\n-} );\n-\n-jQuery.each( [ \"get\", \"post\" ], function( _i, method ) {\n-\tjQuery[ method ] = function( url, data, callback, type ) {\n-\n-\t\t\/\/ Shift arguments if data argument was omitted\n-\t\tif ( isFunction( data ) ) {\n-\t\t\ttype = type || callback;\n-\t\t\tcallback = data;\n-\t\t\tdata = undefined;\n-\t\t}\n-\n-\t\t\/\/ The url can be an options object (which then must have .url)\n-\t\treturn jQuery.ajax( jQuery.extend( {\n-\t\t\turl: url,\n-\t\t\ttype: method,\n-\t\t\tdataType: type,\n-\t\t\tdata: data,\n-\t\t\tsuccess: callback\n-\t\t}, jQuery.isPlainObject( url ) && url ) );\n-\t};\n-} );\n-\n-jQuery.ajaxPrefilter( function( s ) {\n-\tvar i;\n-\tfor ( i in s.headers ) {\n-\t\tif ( i.toLowerCase() === \"content-type\" ) {\n-\t\t\ts.contentType = s.headers[ i ] || \"\";\n-\t\t}\n-\t}\n-} );\n-\n-\n-jQuery._evalUrl = function( url, options, doc ) {\n-\treturn jQuery.ajax( {\n-\t\turl: url,\n-\n-\t\t\/\/ Make this explicit, since user can override this through ajaxSetup (trac-11264)\n-\t\ttype: \"GET\",\n-\t\tdataType: \"script\",\n-\t\tcache: true,\n-\t\tasync: false,\n-\t\tglobal: false,\n-\n-\t\t\/\/ Only evaluate the response if it is successful (gh-4126)\n-\t\t\/\/ dataFilter is not invoked for failure responses, so using it instead\n-\t\t\/\/ of the default converter is kludgy but it works.\n-\t\tconverters: {\n-\t\t\t\"text script\": function() {}\n-\t\t},\n-\t\tdataFilter: function( response ) {\n-\t\t\tjQuery.globalEval( response, options, doc );\n-\t\t}\n-\t} );\n-};\n-\n-\n-jQuery.fn.extend( {\n-\twrapAll: function( html ) {\n-\t\tvar wrap;\n-\n-\t\tif ( this[ 0 ] ) {\n-\t\t\tif ( isFunction( html ) ) {\n-\t\t\t\thtml = html.call( this[ 0 ] );\n-\t\t\t}\n-\n-\t\t\t\/\/ The elements to wrap the target around\n-\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n-\n-\t\t\tif ( this[ 0 ].parentNode ) {\n-\t\t\t\twrap.insertBefore( this[ 0 ] );\n-\t\t\t}\n-\n-\t\t\twrap.map( function() {\n-\t\t\t\tvar elem = this;\n-\n-\t\t\t\twhile ( elem.firstElementChild ) {\n-\t\t\t\t\telem = elem.firstElementChild;\n-\t\t\t\t}\n-\n-\t\t\t\treturn elem;\n-\t\t\t} ).append( this );\n-\t\t}\n-\n-\t\treturn this;\n-\t},\n-\n-\twrapInner: function( html ) {\n-\t\tif ( isFunction( html ) ) {\n-\t\t\treturn this.each( function( i ) {\n-\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n-\t\t\t} );\n-\t\t}\n-\n-\t\treturn this.each( function() {\n-\t\t\tvar self = jQuery( this ),\n-\t\t\t\tcontents = self.contents();\n-\n-\t\t\tif ( contents.length ) {\n-\t\t\t\tcontents.wrapAll( html );\n-\n-\t\t\t} else {\n-\t\t\t\tself.append( html );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\twrap: function( html ) {\n-\t\tvar htmlIsFunction = isFunction( html );\n-\n-\t\treturn this.each( function( i ) {\n-\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n-\t\t} );\n-\t},\n-\n-\tunwrap: function( selector ) {\n-\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n-\t\t\tjQuery( this ).replaceWith( this.childNodes );\n-\t\t} );\n-\t\treturn this;\n-\t}\n-} );\n-\n-\n-jQuery.expr.pseudos.hidden = function( elem ) {\n-\treturn !jQuery.expr.pseudos.visible( elem );\n-};\n-jQuery.expr.pseudos.visible = function( elem ) {\n-\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n-};\n-\n-\n-\n-\n-jQuery.ajaxSettings.xhr = function() {\n-\ttry {\n-\t\treturn new window.XMLHttpRequest();\n-\t} catch ( e ) {}\n-};\n-\n-var xhrSuccessStatus = {\n-\n-\t\t\/\/ File protocol always yields status code 0, assume 200\n-\t\t0: 200,\n-\n-\t\t\/\/ Support: IE <=9 only\n-\t\t\/\/ trac-1450: sometimes IE returns 1223 when it should be 204\n-\t\t1223: 204\n-\t},\n-\txhrSupported = jQuery.ajaxSettings.xhr();\n-\n-support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n-support.ajax = xhrSupported = !!xhrSupported;\n-\n-jQuery.ajaxTransport( function( options ) {\n-\tvar callback, errorCallback;\n-\n-\t\/\/ Cross domain only allowed if supported through XMLHttpRequest\n-\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n-\t\treturn {\n-\t\t\tsend: function( headers, complete ) {\n-\t\t\t\tvar i,\n-\t\t\t\t\txhr = options.xhr();\n-\n-\t\t\t\txhr.open(\n-\t\t\t\t\toptions.type,\n-\t\t\t\t\toptions.url,\n-\t\t\t\t\toptions.async,\n-\t\t\t\t\toptions.username,\n-\t\t\t\t\toptions.password\n-\t\t\t\t);\n-\n-\t\t\t\t\/\/ Apply custom fields if provided\n-\t\t\t\tif ( options.xhrFields ) {\n-\t\t\t\t\tfor ( i in options.xhrFields ) {\n-\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Override mime type if needed\n-\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n-\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ X-Requested-With header\n-\t\t\t\t\/\/ For cross-domain requests, seeing as conditions for a preflight are\n-\t\t\t\t\/\/ akin to a jigsaw puzzle, we simply never set it to be sure.\n-\t\t\t\t\/\/ (it can always be set on a per-request basis or even using ajaxSetup)\n-\t\t\t\t\/\/ For same-domain requests, won't change header if already provided.\n-\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n-\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Set headers\n-\t\t\t\tfor ( i in headers ) {\n-\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Callback\n-\t\t\t\tcallback = function( type ) {\n-\t\t\t\t\treturn function() {\n-\t\t\t\t\t\tif ( callback ) {\n-\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n-\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n-\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n-\n-\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n-\t\t\t\t\t\t\t\txhr.abort();\n-\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n-\n-\t\t\t\t\t\t\t\t\/\/ Support: IE <=9 only\n-\t\t\t\t\t\t\t\t\/\/ On a manual native abort, IE9 throws\n-\t\t\t\t\t\t\t\t\/\/ errors on any property access that is not readyState\n-\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n-\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tcomplete(\n-\n-\t\t\t\t\t\t\t\t\t\t\/\/ File: protocol always yields status 0; see trac-8605, trac-14207\n-\t\t\t\t\t\t\t\t\t\txhr.status,\n-\t\t\t\t\t\t\t\t\t\txhr.statusText\n-\t\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tcomplete(\n-\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n-\t\t\t\t\t\t\t\t\txhr.statusText,\n-\n-\t\t\t\t\t\t\t\t\t\/\/ Support: IE <=9 only\n-\t\t\t\t\t\t\t\t\t\/\/ IE9 has no XHR2 but throws on binary (trac-11426)\n-\t\t\t\t\t\t\t\t\t\/\/ For XHR2 non-text, let the caller handle it (gh-2498)\n-\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n-\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n-\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n-\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n-\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n-\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t};\n-\t\t\t\t};\n-\n-\t\t\t\t\/\/ Listen to events\n-\t\t\t\txhr.onload = callback();\n-\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n-\n-\t\t\t\t\/\/ Support: IE 9 only\n-\t\t\t\t\/\/ Use onreadystatechange to replace onabort\n-\t\t\t\t\/\/ to handle uncaught aborts\n-\t\t\t\tif ( xhr.onabort !== undefined ) {\n-\t\t\t\t\txhr.onabort = errorCallback;\n-\t\t\t\t} else {\n-\t\t\t\t\txhr.onreadystatechange = function() {\n-\n-\t\t\t\t\t\t\/\/ Check readyState before timeout as it changes\n-\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n-\n-\t\t\t\t\t\t\t\/\/ Allow onerror to be called first,\n-\t\t\t\t\t\t\t\/\/ but that will not handle a native abort\n-\t\t\t\t\t\t\t\/\/ Also, save errorCallback to a variable\n-\t\t\t\t\t\t\t\/\/ as xhr.onerror cannot be accessed\n-\t\t\t\t\t\t\twindow.setTimeout( function() {\n-\t\t\t\t\t\t\t\tif ( callback ) {\n-\t\t\t\t\t\t\t\t\terrorCallback();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t};\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Create the abort callback\n-\t\t\t\tcallback = callback( \"abort\" );\n-\n-\t\t\t\ttry {\n-\n-\t\t\t\t\t\/\/ Do send the request (this may raise an exception)\n-\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n-\t\t\t\t} catch ( e ) {\n-\n-\t\t\t\t\t\/\/ trac-14683: Only rethrow if this hasn't been notified as an error yet\n-\t\t\t\t\tif ( callback ) {\n-\t\t\t\t\t\tthrow e;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t},\n-\n-\t\t\tabort: function() {\n-\t\t\t\tif ( callback ) {\n-\t\t\t\t\tcallback();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t}\n-} );\n-\n-\n-\n-\n-\/\/ Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n-jQuery.ajaxPrefilter( function( s ) {\n-\tif ( s.crossDomain ) {\n-\t\ts.contents.script = false;\n-\t}\n-} );\n-\n-\/\/ Install script dataType\n-jQuery.ajaxSetup( {\n-\taccepts: {\n-\t\tscript: \"text\/javascript, application\/javascript, \" +\n-\t\t\t\"application\/ecmascript, application\/x-ecmascript\"\n-\t},\n-\tcontents: {\n-\t\tscript: \/\\b(?:java|ecma)script\\b\/\n-\t},\n-\tconverters: {\n-\t\t\"text script\": function( text ) {\n-\t\t\tjQuery.globalEval( text );\n-\t\t\treturn text;\n-\t\t}\n-\t}\n-} );\n-\n-\/\/ Handle cache's special case and crossDomain\n-jQuery.ajaxPrefilter( \"script\", function( s ) {\n-\tif ( s.cache === undefined ) {\n-\t\ts.cache = false;\n-\t}\n-\tif ( s.crossDomain ) {\n-\t\ts.type = \"GET\";\n-\t}\n-} );\n-\n-\/\/ Bind script tag hack transport\n-jQuery.ajaxTransport( \"script\", function( s ) {\n-\n-\t\/\/ This transport only deals with cross domain or forced-by-attrs requests\n-\tif ( s.crossDomain || s.scriptAttrs ) {\n-\t\tvar script, callback;\n-\t\treturn {\n-\t\t\tsend: function( _, complete ) {\n-\t\t\t\tscript = jQuery( \"<script>\" )\n-\t\t\t\t\t.attr( s.scriptAttrs || {} )\n-\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n-\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n-\t\t\t\t\t\tscript.remove();\n-\t\t\t\t\t\tcallback = null;\n-\t\t\t\t\t\tif ( evt ) {\n-\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} );\n-\n-\t\t\t\t\/\/ Use native DOM manipulation to avoid our domManip AJAX trickery\n-\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n-\t\t\t},\n-\t\t\tabort: function() {\n-\t\t\t\tif ( callback ) {\n-\t\t\t\t\tcallback();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t}\n-} );\n-\n-\n-\n-\n-var oldCallbacks = [],\n-\trjsonp = \/(=)\\?(?=&|$)|\\?\\?\/;\n-\n-\/\/ Default jsonp settings\n-jQuery.ajaxSetup( {\n-\tjsonp: \"callback\",\n-\tjsonpCallback: function() {\n-\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce.guid++ ) );\n-\t\tthis[ callback ] = true;\n-\t\treturn callback;\n-\t}\n-} );\n-\n-\/\/ Detect, normalize options and install callbacks for jsonp requests\n-jQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n-\n-\tvar callbackName, overwritten, responseContainer,\n-\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n-\t\t\t\"url\" :\n-\t\t\ttypeof s.data === \"string\" &&\n-\t\t\t\t( s.contentType || \"\" )\n-\t\t\t\t\t.indexOf( \"application\/x-www-form-urlencoded\" ) === 0 &&\n-\t\t\t\trjsonp.test( s.data ) && \"data\"\n-\t\t);\n-\n-\t\/\/ Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n-\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n-\n-\t\t\/\/ Get callback name, remembering preexisting value associated with it\n-\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n-\t\t\ts.jsonpCallback() :\n-\t\t\ts.jsonpCallback;\n-\n-\t\t\/\/ Insert callback into url or form data\n-\t\tif ( jsonProp ) {\n-\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n-\t\t} else if ( s.jsonp !== false ) {\n-\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n-\t\t}\n-\n-\t\t\/\/ Use data converter to retrieve json after script execution\n-\t\ts.converters[ \"script json\" ] = function() {\n-\t\t\tif ( !responseContainer ) {\n-\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n-\t\t\t}\n-\t\t\treturn responseContainer[ 0 ];\n-\t\t};\n-\n-\t\t\/\/ Force json dataType\n-\t\ts.dataTypes[ 0 ] = \"json\";\n-\n-\t\t\/\/ Install callback\n-\t\toverwritten = window[ callbackName ];\n-\t\twindow[ callbackName ] = function() {\n-\t\t\tresponseContainer = arguments;\n-\t\t};\n-\n-\t\t\/\/ Clean-up function (fires after converters)\n-\t\tjqXHR.always( function() {\n-\n-\t\t\t\/\/ If previous value didn't exist - remove it\n-\t\t\tif ( overwritten === undefined ) {\n-\t\t\t\tjQuery( window ).removeProp( callbackName );\n-\n-\t\t\t\/\/ Otherwise restore preexisting value\n-\t\t\t} else {\n-\t\t\t\twindow[ callbackName ] = overwritten;\n-\t\t\t}\n-\n-\t\t\t\/\/ Save back as free\n-\t\t\tif ( s[ callbackName ] ) {\n-\n-\t\t\t\t\/\/ Make sure that re-using the options doesn't screw things around\n-\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n-\n-\t\t\t\t\/\/ Save the callback name for future use\n-\t\t\t\toldCallbacks.push( callbackName );\n-\t\t\t}\n-\n-\t\t\t\/\/ Call if it was a function and we have a response\n-\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n-\t\t\t\toverwritten( responseContainer[ 0 ] );\n-\t\t\t}\n-\n-\t\t\tresponseContainer = overwritten = undefined;\n-\t\t} );\n-\n-\t\t\/\/ Delegate to script\n-\t\treturn \"script\";\n-\t}\n-} );\n-\n-\n-\n-\n-\/\/ Support: Safari 8 only\n-\/\/ In Safari 8 documents created via document.implementation.createHTMLDocument\n-\/\/ collapse sibling forms: the second one becomes a child of the first one.\n-\/\/ Because of that, this security measure has to be disabled in Safari 8.\n-\/\/ https:\/\/bugs.webkit.org\/show_bug.cgi?id=137337\n-support.createHTMLDocument = ( function() {\n-\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n-\tbody.innerHTML = \"<form><\/form><form><\/form>\";\n-\treturn body.childNodes.length === 2;\n-} )();\n-\n-\n-\/\/ Argument \"data\" should be string of html\n-\/\/ context (optional): If specified, the fragment will be created in this context,\n-\/\/ defaults to document\n-\/\/ keepScripts (optional): If true, will include scripts passed in the html string\n-jQuery.parseHTML = function( data, context, keepScripts ) {\n-\tif ( typeof data !== \"string\" ) {\n-\t\treturn [];\n-\t}\n-\tif ( typeof context === \"boolean\" ) {\n-\t\tkeepScripts = context;\n-\t\tcontext = false;\n-\t}\n-\n-\tvar base, parsed, scripts;\n-\n-\tif ( !context ) {\n-\n-\t\t\/\/ Stop scripts or inline event handlers from being executed immediately\n-\t\t\/\/ by using document.implementation\n-\t\tif ( support.createHTMLDocument ) {\n-\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n-\n-\t\t\t\/\/ Set the base href for the created document\n-\t\t\t\/\/ so any parsed elements with URLs\n-\t\t\t\/\/ are based on the document's URL (gh-2965)\n-\t\t\tbase = context.createElement( \"base\" );\n-\t\t\tbase.href = document.location.href;\n-\t\t\tcontext.head.appendChild( base );\n-\t\t} else {\n-\t\t\tcontext = document;\n-\t\t}\n-\t}\n-\n-\tparsed = rsingleTag.exec( data );\n-\tscripts = !keepScripts && [];\n-\n-\t\/\/ Single tag\n-\tif ( parsed ) {\n-\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n-\t}\n-\n-\tparsed = buildFragment( [ data ], context, scripts );\n-\n-\tif ( scripts && scripts.length ) {\n-\t\tjQuery( scripts ).remove();\n-\t}\n-\n-\treturn jQuery.merge( [], parsed.childNodes );\n-};\n-\n-\n-\/**\n- * Load a url into a page\n- *\/\n-jQuery.fn.load = function( url, params, callback ) {\n-\tvar selector, type, response,\n-\t\tself = this,\n-\t\toff = url.indexOf( \" \" );\n-\n-\tif ( off > -1 ) {\n-\t\tselector = stripAndCollapse( url.slice( off ) );\n-\t\turl = url.slice( 0, off );\n-\t}\n-\n-\t\/\/ If it's a function\n-\tif ( isFunction( params ) ) {\n-\n-\t\t\/\/ We assume that it's the callback\n-\t\tcallback = params;\n-\t\tparams = undefined;\n-\n-\t\/\/ Otherwise, build a param string\n-\t} else if ( params && typeof params === \"object\" ) {\n-\t\ttype = \"POST\";\n-\t}\n-\n-\t\/\/ If we have elements to modify, make the request\n-\tif ( self.length > 0 ) {\n-\t\tjQuery.ajax( {\n-\t\t\turl: url,\n-\n-\t\t\t\/\/ If \"type\" variable is undefined, then \"GET\" method will be used.\n-\t\t\t\/\/ Make value of this field explicit since\n-\t\t\t\/\/ user can override it through ajaxSetup method\n-\t\t\ttype: type || \"GET\",\n-\t\t\tdataType: \"html\",\n-\t\t\tdata: params\n-\t\t} ).done( function( responseText ) {\n-\n-\t\t\t\/\/ Save response for use in complete callback\n-\t\t\tresponse = arguments;\n-\n-\t\t\tself.html( selector ?\n-\n-\t\t\t\t\/\/ If a selector was specified, locate the right elements in a dummy div\n-\t\t\t\t\/\/ Exclude scripts to avoid IE 'Permission Denied' errors\n-\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n-\n-\t\t\t\t\/\/ Otherwise use the full result\n-\t\t\t\tresponseText );\n-\n-\t\t\/\/ If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n-\t\t\/\/ but they are ignored because response was set above.\n-\t\t\/\/ If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n-\t\t} ).always( callback && function( jqXHR, status ) {\n-\t\t\tself.each( function() {\n-\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n-\t\t\t} );\n-\t\t} );\n-\t}\n-\n-\treturn this;\n-};\n-\n-\n-\n-\n-jQuery.expr.pseudos.animated = function( elem ) {\n-\treturn jQuery.grep( jQuery.timers, function( fn ) {\n-\t\treturn elem === fn.elem;\n-\t} ).length;\n-};\n-\n-\n-\n-\n-jQuery.offset = {\n-\tsetOffset: function( elem, options, i ) {\n-\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n-\t\t\tposition = jQuery.css( elem, \"position\" ),\n-\t\t\tcurElem = jQuery( elem ),\n-\t\t\tprops = {};\n-\n-\t\t\/\/ Set position first, in-case top\/left are set even on static elem\n-\t\tif ( position === \"static\" ) {\n-\t\t\telem.style.position = \"relative\";\n-\t\t}\n-\n-\t\tcurOffset = curElem.offset();\n-\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n-\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n-\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n-\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n-\n-\t\t\/\/ Need to be able to calculate position if either\n-\t\t\/\/ top or left is auto and position is either absolute or fixed\n-\t\tif ( calculatePosition ) {\n-\t\t\tcurPosition = curElem.position();\n-\t\t\tcurTop = curPosition.top;\n-\t\t\tcurLeft = curPosition.left;\n-\n-\t\t} else {\n-\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n-\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n-\t\t}\n-\n-\t\tif ( isFunction( options ) ) {\n-\n-\t\t\t\/\/ Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n-\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n-\t\t}\n-\n-\t\tif ( options.top != null ) {\n-\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n-\t\t}\n-\t\tif ( options.left != null ) {\n-\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n-\t\t}\n-\n-\t\tif ( \"using\" in options ) {\n-\t\t\toptions.using.call( elem, props );\n-\n-\t\t} else {\n-\t\t\tcurElem.css( props );\n-\t\t}\n-\t}\n-};\n-\n-jQuery.fn.extend( {\n-\n-\t\/\/ offset() relates an element's border box to the document origin\n-\toffset: function( options ) {\n-\n-\t\t\/\/ Preserve chaining for setter\n-\t\tif ( arguments.length ) {\n-\t\t\treturn options === undefined ?\n-\t\t\t\tthis :\n-\t\t\t\tthis.each( function( i ) {\n-\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n-\t\t\t\t} );\n-\t\t}\n-\n-\t\tvar rect, win,\n-\t\t\telem = this[ 0 ];\n-\n-\t\tif ( !elem ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t\/\/ Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n-\t\t\/\/ Support: IE <=11 only\n-\t\t\/\/ Running getBoundingClientRect on a\n-\t\t\/\/ disconnected node in IE throws an error\n-\t\tif ( !elem.getClientRects().length ) {\n-\t\t\treturn { top: 0, left: 0 };\n-\t\t}\n-\n-\t\t\/\/ Get document-relative position by adding viewport scroll to viewport-relative gBCR\n-\t\trect = elem.getBoundingClientRect();\n-\t\twin = elem.ownerDocument.defaultView;\n-\t\treturn {\n-\t\t\ttop: rect.top + win.pageYOffset,\n-\t\t\tleft: rect.left + win.pageXOffset\n-\t\t};\n-\t},\n-\n-\t\/\/ position() relates an element's margin box to its offset parent's padding box\n-\t\/\/ This corresponds to the behavior of CSS absolute positioning\n-\tposition: function() {\n-\t\tif ( !this[ 0 ] ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tvar offsetParent, offset, doc,\n-\t\t\telem = this[ 0 ],\n-\t\t\tparentOffset = { top: 0, left: 0 };\n-\n-\t\t\/\/ position:fixed elements are offset from the viewport, which itself always has zero offset\n-\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n-\n-\t\t\t\/\/ Assume position:fixed implies availability of getBoundingClientRect\n-\t\t\toffset = elem.getBoundingClientRect();\n-\n-\t\t} else {\n-\t\t\toffset = this.offset();\n-\n-\t\t\t\/\/ Account for the *real* offset parent, which can be the document or its root element\n-\t\t\t\/\/ when a statically positioned element is identified\n-\t\t\tdoc = elem.ownerDocument;\n-\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n-\t\t\twhile ( offsetParent &&\n-\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n-\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n-\n-\t\t\t\toffsetParent = offsetParent.parentNode;\n-\t\t\t}\n-\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n-\n-\t\t\t\t\/\/ Incorporate borders into its offset, since they are outside its content origin\n-\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n-\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n-\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n-\t\t\t}\n-\t\t}\n-\n-\t\t\/\/ Subtract parent offsets and element margins\n-\t\treturn {\n-\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n-\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n-\t\t};\n-\t},\n-\n-\t\/\/ This method will return documentElement in the following cases:\n-\t\/\/ 1) For the element inside the iframe without offsetParent, this method will return\n-\t\/\/    documentElement of the parent window\n-\t\/\/ 2) For the hidden or detached element\n-\t\/\/ 3) For body or html element, i.e. in case of the html node - it will return itself\n-\t\/\/\n-\t\/\/ but those exceptions were never presented as a real life use-cases\n-\t\/\/ and might be considered as more preferable results.\n-\t\/\/\n-\t\/\/ This logic, however, is not guaranteed and can change at any point in the future\n-\toffsetParent: function() {\n-\t\treturn this.map( function() {\n-\t\t\tvar offsetParent = this.offsetParent;\n-\n-\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n-\t\t\t\toffsetParent = offsetParent.offsetParent;\n-\t\t\t}\n-\n-\t\t\treturn offsetParent || documentElement;\n-\t\t} );\n-\t}\n-} );\n-\n-\/\/ Create scrollLeft and scrollTop methods\n-jQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n-\tvar top = \"pageYOffset\" === prop;\n-\n-\tjQuery.fn[ method ] = function( val ) {\n-\t\treturn access( this, function( elem, method, val ) {\n-\n-\t\t\t\/\/ Coalesce documents and windows\n-\t\t\tvar win;\n-\t\t\tif ( isWindow( elem ) ) {\n-\t\t\t\twin = elem;\n-\t\t\t} else if ( elem.nodeType === 9 ) {\n-\t\t\t\twin = elem.defaultView;\n-\t\t\t}\n-\n-\t\t\tif ( val === undefined ) {\n-\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n-\t\t\t}\n-\n-\t\t\tif ( win ) {\n-\t\t\t\twin.scrollTo(\n-\t\t\t\t\t!top ? val : win.pageXOffset,\n-\t\t\t\t\ttop ? val : win.pageYOffset\n-\t\t\t\t);\n-\n-\t\t\t} else {\n-\t\t\t\telem[ method ] = val;\n-\t\t\t}\n-\t\t}, method, val, arguments.length );\n-\t};\n-} );\n-\n-\/\/ Support: Safari <=7 - 9.1, Chrome <=37 - 49\n-\/\/ Add the top\/left cssHooks using jQuery.fn.position\n-\/\/ Webkit bug: https:\/\/bugs.webkit.org\/show_bug.cgi?id=29084\n-\/\/ Blink bug: https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=589347\n-\/\/ getComputedStyle returns percent when specified for top\/left\/bottom\/right;\n-\/\/ rather than make the css module depend on the offset module, just check for it here\n-jQuery.each( [ \"top\", \"left\" ], function( _i, prop ) {\n-\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n-\t\tfunction( elem, computed ) {\n-\t\t\tif ( computed ) {\n-\t\t\t\tcomputed = curCSS( elem, prop );\n-\n-\t\t\t\t\/\/ If curCSS returns percentage, fallback to offset\n-\t\t\t\treturn rnumnonpx.test( computed ) ?\n-\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n-\t\t\t\t\tcomputed;\n-\t\t\t}\n-\t\t}\n-\t);\n-} );\n-\n-\n-\/\/ Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n-jQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n-\tjQuery.each( {\n-\t\tpadding: \"inner\" + name,\n-\t\tcontent: type,\n-\t\t\"\": \"outer\" + name\n-\t}, function( defaultExtra, funcName ) {\n-\n-\t\t\/\/ Margin is only for outerHeight, outerWidth\n-\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n-\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n-\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n-\n-\t\t\treturn access( this, function( elem, type, value ) {\n-\t\t\t\tvar doc;\n-\n-\t\t\t\tif ( isWindow( elem ) ) {\n-\n-\t\t\t\t\t\/\/ $( window ).outerWidth\/Height return w\/h including scrollbars (gh-1729)\n-\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n-\t\t\t\t\t\telem[ \"inner\" + name ] :\n-\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n-\t\t\t\t}\n-\n-\t\t\t\t\/\/ Get document width or height\n-\t\t\t\tif ( elem.nodeType === 9 ) {\n-\t\t\t\t\tdoc = elem.documentElement;\n-\n-\t\t\t\t\t\/\/ Either scroll[Width\/Height] or offset[Width\/Height] or client[Width\/Height],\n-\t\t\t\t\t\/\/ whichever is greatest\n-\t\t\t\t\treturn Math.max(\n-\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n-\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n-\t\t\t\t\t\tdoc[ \"client\" + name ]\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\n-\t\t\t\treturn value === undefined ?\n-\n-\t\t\t\t\t\/\/ Get width or height on the element, requesting but not forcing parseFloat\n-\t\t\t\t\tjQuery.css( elem, type, extra ) :\n-\n-\t\t\t\t\t\/\/ Set width or height on the element\n-\t\t\t\t\tjQuery.style( elem, type, value, extra );\n-\t\t\t}, type, chainable ? margin : undefined, chainable );\n-\t\t};\n-\t} );\n-} );\n-\n-\n-jQuery.each( [\n-\t\"ajaxStart\",\n-\t\"ajaxStop\",\n-\t\"ajaxComplete\",\n-\t\"ajaxError\",\n-\t\"ajaxSuccess\",\n-\t\"ajaxSend\"\n-], function( _i, type ) {\n-\tjQuery.fn[ type ] = function( fn ) {\n-\t\treturn this.on( type, fn );\n-\t};\n-} );\n-\n-\n-\n-\n-jQuery.fn.extend( {\n-\n-\tbind: function( types, data, fn ) {\n-\t\treturn this.on( types, null, data, fn );\n-\t},\n-\tunbind: function( types, fn ) {\n-\t\treturn this.off( types, null, fn );\n-\t},\n-\n-\tdelegate: function( selector, types, data, fn ) {\n-\t\treturn this.on( types, selector, data, fn );\n-\t},\n-\tundelegate: function( selector, types, fn ) {\n-\n-\t\t\/\/ ( namespace ) or ( selector, types [, fn] )\n-\t\treturn arguments.length === 1 ?\n-\t\t\tthis.off( selector, \"**\" ) :\n-\t\t\tthis.off( types, selector || \"**\", fn );\n-\t},\n-\n-\thover: function( fnOver, fnOut ) {\n-\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n-\t}\n-} );\n-\n-jQuery.each(\n-\t( \"blur focus focusin focusout resize scroll click dblclick \" +\n-\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n-\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n-\tfunction( _i, name ) {\n-\n-\t\t\/\/ Handle event binding\n-\t\tjQuery.fn[ name ] = function( data, fn ) {\n-\t\t\treturn arguments.length > 0 ?\n-\t\t\t\tthis.on( name, null, data, fn ) :\n-\t\t\t\tthis.trigger( name );\n-\t\t};\n-\t}\n-);\n-\n-\n-\n-\n-\/\/ Support: Android <=4.0 only\n-\/\/ Make sure we trim BOM and NBSP\n-\/\/ Require that the \"whitespace run\" starts from a non-whitespace\n-\/\/ to avoid O(N^2) behavior when the engine would try matching \"\\s+$\" at each space position.\n-var rtrim = \/^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$\/g;\n-\n-\/\/ Bind a function to a context, optionally partially applying any\n-\/\/ arguments.\n-\/\/ jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n-\/\/ However, it is not slated for removal any time soon\n-jQuery.proxy = function( fn, context ) {\n-\tvar tmp, args, proxy;\n-\n-\tif ( typeof context === \"string\" ) {\n-\t\ttmp = fn[ context ];\n-\t\tcontext = fn;\n-\t\tfn = tmp;\n-\t}\n-\n-\t\/\/ Quick check to determine if target is callable, in the spec\n-\t\/\/ this throws a TypeError, but we will just return undefined.\n-\tif ( !isFunction( fn ) ) {\n-\t\treturn undefined;\n-\t}\n-\n-\t\/\/ Simulated bind\n-\targs = slice.call( arguments, 2 );\n-\tproxy = function() {\n-\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n-\t};\n-\n-\t\/\/ Set the guid of unique handler to the same of original handler, so it can be removed\n-\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n-\n-\treturn proxy;\n-};\n-\n-jQuery.holdReady = function( hold ) {\n-\tif ( hold ) {\n-\t\tjQuery.readyWait++;\n-\t} else {\n-\t\tjQuery.ready( true );\n-\t}\n-};\n-jQuery.isArray = Array.isArray;\n-jQuery.parseJSON = JSON.parse;\n-jQuery.nodeName = nodeName;\n-jQuery.isFunction = isFunction;\n-jQuery.isWindow = isWindow;\n-jQuery.camelCase = camelCase;\n-jQuery.type = toType;\n-\n-jQuery.now = Date.now;\n-\n-jQuery.isNumeric = function( obj ) {\n-\n-\t\/\/ As of jQuery 3.0, isNumeric is limited to\n-\t\/\/ strings and numbers (primitives or objects)\n-\t\/\/ that can be coerced to finite numbers (gh-2662)\n-\tvar type = jQuery.type( obj );\n-\treturn ( type === \"number\" || type === \"string\" ) &&\n-\n-\t\t\/\/ parseFloat NaNs numeric-cast false positives (\"\")\n-\t\t\/\/ ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n-\t\t\/\/ subtraction forces infinities to NaN\n-\t\t!isNaN( obj - parseFloat( obj ) );\n-};\n-\n-jQuery.trim = function( text ) {\n-\treturn text == null ?\n-\t\t\"\" :\n-\t\t( text + \"\" ).replace( rtrim, \"$1\" );\n-};\n-\n-\n-\n-\/\/ Register as a named AMD module, since jQuery can be concatenated with other\n-\/\/ files that may use define, but not via a proper concatenation script that\n-\/\/ understands anonymous AMD modules. A named AMD is safest and most robust\n-\/\/ way to register. Lowercase jquery is used because AMD module names are\n-\/\/ derived from file names, and jQuery is normally delivered in a lowercase\n-\/\/ file name. Do this after creating the global so that if an AMD module wants\n-\/\/ to call noConflict to hide this version of jQuery, it will work.\n-\n-\/\/ Note that for maximum portability, libraries that are not jQuery should\n-\/\/ declare themselves as anonymous modules, and avoid setting a global if an\n-\/\/ AMD loader is present. jQuery is a special case. For more information, see\n-\/\/ https:\/\/github.com\/jrburke\/requirejs\/wiki\/Updating-existing-libraries#wiki-anon\n-\n-if ( typeof define === \"function\" && define.amd ) {\n-\tdefine( \"jquery\", [], function() {\n-\t\treturn jQuery;\n-\t} );\n-}\n-\n-\n-\n-\n-var\n-\n-\t\/\/ Map over jQuery in case of overwrite\n-\t_jQuery = window.jQuery,\n-\n-\t\/\/ Map over the $ in case of overwrite\n-\t_$ = window.$;\n-\n-jQuery.noConflict = function( deep ) {\n-\tif ( window.$ === jQuery ) {\n-\t\twindow.$ = _$;\n-\t}\n-\n-\tif ( deep && window.jQuery === jQuery ) {\n-\t\twindow.jQuery = _jQuery;\n-\t}\n-\n-\treturn jQuery;\n-};\n-\n-\/\/ Expose jQuery and $ identifiers, even in AMD\n-\/\/ (trac-7102#comment:10, https:\/\/github.com\/jquery\/jquery\/pull\/557)\n-\/\/ and CommonJS for browser emulators (trac-13566)\n-if ( typeof noGlobal === \"undefined\" ) {\n-\twindow.jQuery = window.$ = jQuery;\n-}\n-\n-\n-\n-\n-return jQuery;\n-} );\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery\/jquery-3.6.1.js","additions":0,"deletions":10909,"binary":false,"changes":10909,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-\/*! jQuery v3.6.1 | (c) OpenJS Foundation and other contributors | jquery.org\/license *\/\n-!function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,y=n.hasOwnProperty,a=y.toString,l=a.call(Object),v={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.1\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for(\"boolean\"==typeof a&&(l=a,a=arguments[s]||{},s++),\"object\"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],\"__proto__\"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:\"jQuery\"+(f+Math.random()).replace(\/\\D\/g,\"\"),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||\"[object Object]\"!==o.call(e))&&(!(t=r(e))||\"function\"==typeof(n=y.call(t,\"constructor\")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,\"string\"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:v}),\"function\"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(e,t){n[\"[object \"+t+\"]\"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,y,s,c,v,S=\"sizzle\"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),j=function(e,t){return e===t&&(l=!0),0},D={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",M=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",I=\"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",W=\"\\\\[\"+M+\"*(\"+I+\")(?:\"+M+\"*([*^$|!~]?=)\"+M+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+I+\"))|)\"+M+\"*\\\\]\",F=\":(\"+I+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+W+\")*)|.*)\\\\)|)\",$=new RegExp(M+\"+\",\"g\"),B=new RegExp(\"^\"+M+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+M+\"+$\",\"g\"),_=new RegExp(\"^\"+M+\"*,\"+M+\"*\"),z=new RegExp(\"^\"+M+\"*([>+~]|\"+M+\")\"+M+\"*\"),U=new RegExp(M+\"|>\"),X=new RegExp(F),V=new RegExp(\"^\"+I+\"$\"),G={ID:new RegExp(\"^#(\"+I+\")\"),CLASS:new RegExp(\"^\\\\.(\"+I+\")\"),TAG:new RegExp(\"^(\"+I+\"|[*])\"),ATTR:new RegExp(\"^\"+W),PSEUDO:new RegExp(\"^\"+F),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+M+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+M+\"*(?:([+-]|)\"+M+\"*(\\\\d+)|))\"+M+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+R+\")$\",\"i\"),needsContext:new RegExp(\"^\"+M+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+M+\"*((?:-\\\\d)?\\\\d*)\"+M+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=\/HTML$\/i,Q=\/^(?:input|select|textarea|button)$\/i,J=\/^h\\d$\/i,K=\/^[^{]+\\{\\s*\\[native \\w\/,Z=\/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$\/,ee=\/[+~]\/,te=new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\",\"g\"),ne=function(e,t){var n=\"0x\"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=\/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]\/g,ie=function(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&\"fieldset\"===e.nodeName.toLowerCase()},{dir:\"parentNode\",next:\"legend\"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],\"string\"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&v(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+\" \"]&&(!y||!y.test(t))&&(1!==p||\"object\"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ve(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute(\"id\"))?s=s.replace(re,ie):e.setAttribute(\"id\",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?\"#\"+s:\":scope\")+\" \"+xe(l[o]);c=l.join(\",\")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute(\"id\")}}}return g(t.replace(B,\"$1\"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+\" \")>b.cacheLength&&delete e[r.shift()],e[t+\" \"]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split(\"|\"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return\"input\"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return(\"input\"===t||\"button\"===t)&&e.type===n}}function ge(t){return function(e){return\"form\"in e?e.parentNode&&!1===e.disabled?\"label\"in e?\"label\"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:\"label\"in e&&e.disabled===t}}function ye(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ve(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||\"HTML\")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener(\"unload\",oe,!1):n.attachEvent&&n.attachEvent(\"onunload\",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement(\"div\")),\"undefined\"!=typeof e.querySelectorAll&&!e.querySelectorAll(\":scope fieldset div\").length}),d.attributes=ce(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute(\"id\")===t}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return t&&t.value===n}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],y=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML=\"<a id='\"+S+\"'><\/a><select id='\"+S+\"-\\r\\\\' msallowcapture=''><option selected=''><\/option><\/select>\",e.querySelectorAll(\"[msallowcapture^='']\").length&&y.push(\"[*^$]=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\"[selected]\").length||y.push(\"\\\\[\"+M+\"*(?:value|\"+R+\")\"),e.querySelectorAll(\"[id~=\"+S+\"-]\").length||y.push(\"~=\"),(t=C.createElement(\"input\")).setAttribute(\"name\",\"\"),e.appendChild(t),e.querySelectorAll(\"[name='']\").length||y.push(\"\\\\[\"+M+\"*name\"+M+\"*=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\":checked\").length||y.push(\":checked\"),e.querySelectorAll(\"a#\"+S+\"+*\").length||y.push(\".#.+[+~]\"),e.querySelectorAll(\"\\\\\\f\"),y.push(\"[\\\\r\\\\n\\\\f]\")}),ce(function(e){e.innerHTML=\"<a href='' disabled='disabled'><\/a><select disabled='disabled'><option\/><\/select>\";var t=C.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),e.querySelectorAll(\"[name=d]\").length&&y.push(\"name\"+M+\"*[*^$|!~]?=\"),2!==e.querySelectorAll(\":enabled\").length&&y.push(\":enabled\",\":disabled\"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&y.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),y.push(\",.*:\")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,\"*\"),c.call(e,\"[s!='']:x\"),s.push(\"!=\",F)}),y=y.length&&new RegExp(y.join(\"|\")),s=s.length&&new RegExp(s.join(\"|\")),t=K.test(a.compareDocumentPosition),v=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},j=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&v(p,e)?-1:t==C||t.ownerDocument==p&&v(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+\" \"]&&(!s||!s.test(t))&&(!y||!y.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),v(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&D.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+\"\").replace(re,ie)},se.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(j),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n=\"\",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||\"\").replace(te,ne),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+\" \"];return t||(t=new RegExp(\"(^|\"+M+\")\"+e+\"(\"+M+\"|$)\"))&&m(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?\"!=\"===r:!r||(t+=\"\",\"=\"===r?t===i:\"!=\"===r?t!==i:\"^=\"===r?i&&0===t.indexOf(i):\"*=\"===r?i&&-1<t.indexOf(i):\"$=\"===r?i&&t.slice(-i.length)===i:\"~=\"===r?-1<(\" \"+t.replace($,\" \")+\" \").indexOf(i):\"|=\"===r&&(t===i||t.slice(0,i.length+1)===i+\"-\"))}},CHILD:function(h,e,t,g,y){var v=\"nth\"!==h.slice(0,3),m=\"last\"!==h.slice(-4),x=\"of-type\"===e;return 1===g&&0===y?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=v!==m?\"nextSibling\":\"previousSibling\",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(v){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l=\"only\"===h&&!u&&\"nextSibling\"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=y)===g||d%g==0&&0<=d\/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error(\"unsupported pseudo: \"+e);return a[S]?a(o):1<a.length?(t=[e,e,\"\",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,\"$1\"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||\"\")||se.error(\"unsupported lang: \"+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute(\"xml:lang\")||e.getAttribute(\"lang\"))return(t=t.toLowerCase())===n||0===t.indexOf(n+\"-\")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&\"button\"===e.type||\"button\"===t},text:function(e){var t;return\"input\"===e.nodeName.toLowerCase()&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||\"text\"===t.toLowerCase())},first:ye(function(){return[0]}),last:ye(function(e,t){return[t-1]}),eq:ye(function(e,t,n){return[n<0?n+t:n]}),even:ye(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ye(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ye(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ye(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r=\"\";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&\"parentNode\"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,y,v,e){return y&&!y[S]&&(y=Ce(y)),v&&!v[S]&&(v=Ce(v,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||\"*\",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?v||(e?d:l||y)?[]:t:f;if(g&&g(f,p,n,r),y){i=Te(p,u),y(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(v||d){if(v){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);v(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=v?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),v?v(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[\" \"],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:\" \"===e[s-2].type?\"*\":\"\"})).replace(B,\"$1\"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+\" \"];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B,\" \")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,y,v,m,x,r,i=[],o=[],a=A[e+\" \"];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(y=o,m=0<(v=i).length,x=0<y.length,r=function(e,t,n,r,i){var o,a,s,u=0,l=\"0\",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG(\"*\",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=y[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=v[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+v.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l=\"function\"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&\"ID\"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ve(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ve(t.parentNode)||t),n},d.sortStable=S.split(\"\").sort(j).join(\"\")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement(\"fieldset\"))}),ce(function(e){return e.innerHTML=\"<a href='#'><\/a>\",\"#\"===e.firstChild.getAttribute(\"href\")})||fe(\"type|href|height|width\",function(e,t,n){if(!n)return e.getAttribute(t,\"type\"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML=\"<input\/>\",e.firstChild.setAttribute(\"value\",\"\"),\"\"===e.firstChild.getAttribute(\"value\")})||fe(\"value\",function(e,t,n){if(!n&&\"input\"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute(\"disabled\")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[\":\"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=\/^<([a-z][^\\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\\/?>(?:<\\\/\\1>|)$\/i;function j(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):\"string\"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if(\"string\"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,\"string\"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var D,q=\/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$\/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||D,\"string\"==typeof e){if(!(r=\"<\"===e[0]&&\">\"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,D=S(E);var L=\/^(?:parents|prev(?:Until|All))\/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a=\"string\"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?\"string\"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,\"parentNode\")},parentsUntil:function(e,t,n){return h(e,\"parentNode\",n)},next:function(e){return O(e,\"nextSibling\")},prev:function(e){return O(e,\"previousSibling\")},nextAll:function(e){return h(e,\"nextSibling\")},prevAll:function(e){return h(e,\"previousSibling\")},nextUntil:function(e,t,n){return h(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return h(e,\"previousSibling\",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,\"template\")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return\"Until\"!==r.slice(-5)&&(t=e),t&&\"string\"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=\/[^\\x20\\t\\r\\n\\f]+\/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r=\"string\"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:\"\")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&\"string\"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t=\"\",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=\"\"),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[[\"notify\",\"progress\",S.Callbacks(\"memory\"),S.Callbacks(\"memory\"),2],[\"resolve\",\"done\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),1,\"rejected\"]],i=\"pending\",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},\"catch\":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+\"With\"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError(\"Thenable self-resolution\");t=e&&(\"object\"==typeof e||\"function\"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+\"With\"](this===s?void 0:this,arguments),this},s[t[0]+\"With\"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),\"pending\"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=\/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$\/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn(\"jQuery.Deferred exception: \"+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function $(){E.removeEventListener(\"DOMContentLoaded\",$),C.removeEventListener(\"load\",$),S.ready()}S.fn.ready=function(e){return F.then(e)[\"catch\"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,\"complete\"===E.readyState||\"loading\"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener(\"DOMContentLoaded\",$),C.addEventListener(\"load\",$));var B=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if(\"object\"===w(n))for(s in i=!0,n)B(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=\/^-ms-\/,z=\/-([a-z])\/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,\"ms-\").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if(\"string\"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&\"string\"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=\/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$\/,K=\/[A-Z]\/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r=\"data-\"+t.replace(K,\"-$&\").toLowerCase(),\"string\"==typeof(n=e.getAttribute(r))){try{n=\"true\"===(i=n)||\"false\"!==i&&(\"null\"===i?null:i===+i+\"\"?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,\"hasDataAttrs\"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf(\"data-\")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,\"hasDataAttrs\",!0)}return i}return\"object\"==typeof n?this.each(function(){Q.set(this,n)}):B(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||\"fx\")+\"queue\",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||\"fx\";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks(\"once memory\").add(function(){Y.remove(e,[t+\"queue\",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return\"string\"!=typeof t&&(n=t,t=\"fx\",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),\"fx\"===t&&\"inprogress\"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};\"string\"!=typeof e&&(t=e,e=void 0),e=e||\"fx\";while(a--)(n=Y.get(o[a],e+\"queueHooks\"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=\/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)\/.source,te=new RegExp(\"^(?:([+-])=|)(\"+ee+\")([a-z%]*)$\",\"i\"),ne=[\"Top\",\"Right\",\"Bottom\",\"Left\"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return\"none\"===(e=t||e).style.display||\"\"===e.style.display&&ie(e)&&\"none\"===S.css(e,\"display\")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,\"\")},u=s(),l=n&&n[3]||(S.cssNumber[t]?\"\":\"px\"),c=e.nodeType&&(S.cssNumber[t]||\"px\"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u\/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()\/u||.5))<=0&&(a=0),c\/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?(\"none\"===n&&(l[c]=Y.get(r,\"display\")||null,l[c]||(r.style.display=\"\")),\"\"===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,\"display\"),o.parentNode.removeChild(o),\"none\"===u&&(u=\"block\"),ue[s]=u)))):\"none\"!==n&&(l[c]=\"none\",Y.set(r,\"display\",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=\/^(?:checkbox|radio)$\/i,de=\/<([a-z][^\\\/\\0>\\x20\\t\\r\\n\\f]*)\/i,he=\/^$|^module$|\\\/(?:java|ecma)script\/i;ce=E.createDocumentFragment().appendChild(E.createElement(\"div\")),(fe=E.createElement(\"input\")).setAttribute(\"type\",\"radio\"),fe.setAttribute(\"checked\",\"checked\"),fe.setAttribute(\"name\",\"t\"),ce.appendChild(fe),v.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML=\"<textarea>x<\/textarea>\",v.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML=\"<option><\/option>\",v.option=!!ce.lastChild;var ge={thead:[1,\"<table>\",\"<\/table>\"],col:[2,\"<table><colgroup>\",\"<\/colgroup><\/table>\"],tr:[2,\"<table><tbody>\",\"<\/tbody><\/table>\"],td:[3,\"<table><tbody><tr>\",\"<\/tr><\/tbody><\/table>\"],_default:[0,\"\",\"\"]};function ye(e,t){var n;return n=\"undefined\"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||\"*\"):\"undefined\"!=typeof e.querySelectorAll?e.querySelectorAll(t||\"*\"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ve(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],\"globalEval\",!t||Y.get(t[n],\"globalEval\"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,v.option||(ge.optgroup=ge.option=[1,\"<select multiple='multiple'>\",\"<\/select>\"]);var me=\/<|&#?\\w+;\/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if(\"object\"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement(\"div\")),s=(de.exec(o)||[\"\",\"\"])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=\"\"}else p.push(t.createTextNode(o));f.textContent=\"\",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ye(f.appendChild(o),\"script\"),l&&ve(a),n){c=0;while(o=a[c++])he.test(o.type||\"\")&&n.push(o)}return f}var be=\/^([^.]*)(?:\\.(.+)|)\/;function we(){return!0}function Te(){return!1}function Ce(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==(\"focus\"===t)}function Ee(e,t,n,r,i,o){var a,s;if(\"object\"==typeof t){for(s in\"string\"!=typeof n&&(r=r||n,n=void 0),t)Ee(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&(\"string\"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Te;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Se(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n&&n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,we)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=y.events)||(u=y.events=Object.create(null)),(a=y.handle)||(a=y.handle=function(e){return\"undefined\"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||\"\").match(P)||[\"\"]).length;while(l--)d=g=(s=be.exec(e[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(\".\")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=Y.hasData(e)&&Y.get(e);if(y&&(u=y.events)){l=(t=(t||\"\").match(P)||[\"\"]).length;while(l--)if(d=g=(s=be.exec(t[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&(\"**\"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,y.handle)||S.removeEvent(e,d,y.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,\"handle events\")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,\"events\")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!(\"click\"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&(\"click\"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+\" \"]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Se(t,\"click\",we),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Se(t,\"click\"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Y.get(t,\"click\")||A(t,\"a\")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?we:Te,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Te,isPropagationStopped:Te,isImmediatePropagationStopped:Te,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=we,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=we,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=we,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\"char\":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},S.event.addProp),S.each({focus:\"focusin\",blur:\"focusout\"},function(t,e){S.event.special[t]={setup:function(){return Se(this,t,Ce),!1},trigger:function(){return Se(this,t),!0},_default:function(e){return Y.get(e.target,t)},delegateType:e}}),S.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return Ee(this,e,t,n,r)},one:function(e,t,n,r){return Ee(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+\".\"+r.namespace:r.origType,r.selector,r.handler),this;if(\"object\"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&\"function\"!=typeof t||(n=t,t=void 0),!1===n&&(n=Te),this.each(function(){S.event.remove(this,e,n,t)})}});var ke=\/<script|<style|<link\/i,Ae=\/checked\\s*(?:[^=]|=\\s*.checked.)\/i,Ne=\/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$\/g;function je(e,t){return A(e,\"table\")&&A(11!==t.nodeType?t:t.firstChild,\"tr\")&&S(e).children(\"tbody\")[0]||e}function De(e){return e.type=(null!==e.getAttribute(\"type\"))+\"\/\"+e.type,e}function qe(e){return\"true\/\"===(e.type||\"\").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute(\"type\"),e}function Le(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,\"handle events\"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function He(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&\"string\"==typeof d&&!v.checkClone&&Ae.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),He(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ye(e,\"script\"),De)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ye(u,\"script\"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,qe),c=0;c<s;c++)u=a[c],he.test(u.type||\"\")&&!Y.access(u,\"globalEval\")&&S.contains(l,u)&&(u.src&&\"module\"!==(u.type||\"\").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute(\"nonce\")},l):b(u.textContent.replace(Ne,\"\"),u,l))}return n}function Oe(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ye(r)),r.parentNode&&(n&&ie(r)&&ve(ye(r,\"script\")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(v.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ye(c),r=0,i=(o=ye(e)).length;r<i;r++)s=o[r],u=a[r],void 0,\"input\"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:\"input\"!==l&&\"textarea\"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ye(e),a=a||ye(c),r=0,i=o.length;r<i;r++)Le(o[r],a[r]);else Le(e,c);return 0<(a=ye(c,\"script\")).length&&ve(a,!f&&ye(e,\"script\")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Oe(this,e,!0)},remove:function(e){return Oe(this,e)},text:function(e){return B(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return He(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||je(this,e).appendChild(e)})},prepend:function(){return He(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=je(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ye(e,!1)),e.textContent=\"\");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return B(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if(\"string\"==typeof e&&!ke.test(e)&&!ge[(de.exec(e)||[\"\",\"\"])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ye(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return He(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ye(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Pe=new RegExp(\"^(\"+ee+\")(?!px)[a-z%]+$\",\"i\"),Re=\/^--\/,Me=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Ie=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},We=new RegExp(ne.join(\"|\"),\"i\"),Fe=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",$e=new RegExp(\"^\"+Fe+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+Fe+\"+$\",\"g\");function Be(e,t,n){var r,i,o,a,s=Re.test(t),u=e.style;return(n=n||Me(e))&&(a=n.getPropertyValue(t)||n[t],s&&(a=a.replace($e,\"$1\")),\"\"!==a||ie(e)||(a=S.style(e,t)),!v.pixelBoxStyles()&&Pe.test(a)&&We.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=n.width,u.width=r,u.minWidth=i,u.maxWidth=o)),void 0!==a?a+\"\":a}function _e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText=\"position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0\",l.style.cssText=\"position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%\",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n=\"1%\"!==e.top,s=12===t(e.marginLeft),l.style.right=\"60%\",o=36===t(e.right),r=36===t(e.width),l.style.position=\"absolute\",i=12===t(l.offsetWidth\/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement(\"div\"),l=E.createElement(\"div\");l.style&&(l.style.backgroundClip=\"content-box\",l.cloneNode(!0).style.backgroundClip=\"\",v.clearCloneStyle=\"content-box\"===l.style.backgroundClip,S.extend(v,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement(\"table\"),t=E.createElement(\"tr\"),n=E.createElement(\"div\"),e.style.cssText=\"position:absolute;left:-11111px;border-collapse:separate\",t.style.cssText=\"border:1px solid\",t.style.height=\"1px\",n.style.height=\"9px\",n.style.display=\"block\",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,re.removeChild(e)),a}}))}();var ze=[\"Webkit\",\"Moz\",\"ms\"],Ue=E.createElement(\"div\").style,Xe={};function Ve(e){var t=S.cssProps[e]||Xe[e];return t||(e in Ue?e:Xe[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=ze.length;while(n--)if((e=ze[n]+t)in Ue)return e}(e)||e)}var Ge=\/^(none|table(?!-c[ea]).+)\/,Ye={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Qe={letterSpacing:\"0\",fontWeight:\"400\"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||\"px\"):t}function Ke(e,t,n,r,i,o){var a=\"width\"===t?1:0,s=0,u=0;if(n===(r?\"border\":\"content\"))return 0;for(;a<4;a+=2)\"margin\"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?(\"content\"===n&&(u-=S.css(e,\"padding\"+ne[a],!0,i)),\"margin\"!==n&&(u-=S.css(e,\"border\"+ne[a]+\"Width\",!0,i))):(u+=S.css(e,\"padding\"+ne[a],!0,i),\"padding\"!==n?u+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i):s+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e[\"offset\"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Me(e),i=(!v.boxSizingReliable()||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,r),o=i,a=Be(e,t,r),s=\"offset\"+t[0].toUpperCase()+t.slice(1);if(Pe.test(a)){if(!n)return a;a=\"auto\"}return(!v.boxSizingReliable()&&i||!v.reliableTrDimensions()&&A(e,\"tr\")||\"auto\"===a||!parseFloat(a)&&\"inline\"===S.css(e,\"display\",!1,r))&&e.getClientRects().length&&(i=\"border-box\"===S.css(e,\"boxSizing\",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?\"border\":\"content\"),o,r,a)+\"px\"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Re.test(t),l=e.style;if(u||(t=Ve(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&\"get\"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];\"string\"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o=\"number\"),null!=n&&n==n&&(\"number\"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?\"\":\"px\")),v.clearCloneStyle||\"\"!==n||0!==t.indexOf(\"background\")||(l[t]=\"inherit\"),a&&\"set\"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Re.test(t)||(t=Ve(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&\"get\"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),\"normal\"===i&&t in Qe&&(i=Qe[t]),\"\"===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each([\"height\",\"width\"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ge.test(S.css(e,\"display\"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):Ie(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Me(e),o=!v.scrollboxSize()&&\"absolute\"===i.position,a=(o||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e[\"offset\"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,\"border\",!1,i)-.5)),s&&(r=te.exec(t))&&\"px\"!==(r[3]||\"px\")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=_e(v.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,\"marginLeft\"))||e.getBoundingClientRect().left-Ie(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+\"px\"}),S.each({margin:\"\",padding:\"\",border:\"Width\"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r=\"string\"==typeof e?e.split(\" \"):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},\"margin\"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return B(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Me(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?\"\":\"px\")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,\"\"))&&\"auto\"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Ve(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)\/2},_default:\"swing\"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=\/^(?:toggle|show|hide)$\/,at=\/queueHooks$\/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i[\"margin\"+(n=ne[r])]=i[\"padding\"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners[\"*\"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t\/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&\"expand\"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{\"*\":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=[\"*\"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f=\"width\"in t||\"height\"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),y=Y.get(e,\"fxshow\");for(r in n.queue||(null==(a=S._queueHooks(e,\"fx\")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,\"fx\").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||\"toggle\"===i,i===(g?\"hide\":\"show\")){if(\"show\"!==i||!y||void 0===y[r])continue;g=!0}d[r]=y&&y[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=y&&y.display)&&(l=Y.get(e,\"display\")),\"none\"===(c=S.css(e,\"display\"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,\"display\"),le([e]))),(\"inline\"===c||\"inline-block\"===c&&null!=l)&&\"none\"===S.css(e,\"float\")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l=\"none\"===c?\"\":c)),h.display=\"inline-block\")),n.overflow&&(h.overflow=\"hidden\",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(y?\"hidden\"in y&&(g=y.hidden):y=Y.access(e,\"fxshow\",{display:l}),o&&(y.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,\"fxshow\"),d)S.style(e,r,d[r])})),u=ct(g?y[r]:0,r,p),r in y||(y[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&\"object\"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:\"number\"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,\"finish\"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return\"string\"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||\"fx\",[]),this.each(function(){var e=!0,t=null!=i&&i+\"queueHooks\",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||\"fx\"),this.each(function(){var e,t=Y.get(this),n=t[a+\"queue\"],r=t[a+\"queueHooks\"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each([\"toggle\",\"show\",\"hide\"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||\"boolean\"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt(\"show\"),slideUp:lt(\"hide\"),slideToggle:lt(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||\"fx\",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement(\"input\"),it=E.createElement(\"select\").appendChild(E.createElement(\"option\")),rt.type=\"checkbox\",v.checkOn=\"\"!==rt.value,v.optSelected=it.selected,(rt=E.createElement(\"input\")).value=\"t\",rt.type=\"radio\",v.radioValue=\"t\"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return B(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return\"undefined\"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+\"\"),n):i&&\"get\"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!v.radioValue&&\"radio\"===t&&A(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(\/\\w+\/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=\/^(?:input|select|textarea|button)$\/i,gt=\/^(?:a|area)$\/i;function yt(e){return(e.match(P)||[]).join(\" \")}function vt(e){return e.getAttribute&&e.getAttribute(\"class\")||\"\"}function mt(e){return Array.isArray(e)?e:\"string\"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return B(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&\"get\"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,\"tabindex\");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"}}),v.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a;return m(t)?this.each(function(e){S(this).addClass(t.call(this,e,vt(this)))}):(e=mt(t)).length?this.each(function(){if(r=vt(this),n=1===this.nodeType&&\" \"+yt(r)+\" \"){for(o=0;o<e.length;o++)i=e[o],n.indexOf(\" \"+i+\" \")<0&&(n+=i+\" \");a=yt(n),r!==a&&this.setAttribute(\"class\",a)}}):this},removeClass:function(t){var e,n,r,i,o,a;return m(t)?this.each(function(e){S(this).removeClass(t.call(this,e,vt(this)))}):arguments.length?(e=mt(t)).length?this.each(function(){if(r=vt(this),n=1===this.nodeType&&\" \"+yt(r)+\" \"){for(o=0;o<e.length;o++){i=e[o];while(-1<n.indexOf(\" \"+i+\" \"))n=n.replace(\" \"+i+\" \",\" \")}a=yt(n),r!==a&&this.setAttribute(\"class\",a)}}):this:this.attr(\"class\",\"\")},toggleClass:function(t,n){var e,r,i,o,a=typeof t,s=\"string\"===a||Array.isArray(t);return m(t)?this.each(function(e){S(this).toggleClass(t.call(this,e,vt(this),n),n)}):\"boolean\"==typeof n&&s?n?this.addClass(t):this.removeClass(t):(e=mt(t),this.each(function(){if(s)for(o=S(this),i=0;i<e.length;i++)r=e[i],o.hasClass(r)?o.removeClass(r):o.addClass(r);else void 0!==t&&\"boolean\"!==a||((r=vt(this))&&Y.set(this,\"__className__\",r),this.setAttribute&&this.setAttribute(\"class\",r||!1===t?\"\":Y.get(this,\"__className__\")||\"\"))}))},hasClass:function(e){var t,n,r=0;t=\" \"+e+\" \";while(n=this[r++])if(1===n.nodeType&&-1<(\" \"+yt(vt(n))+\" \").indexOf(t))return!0;return!1}});var xt=\/\\r\/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t=\"\":\"number\"==typeof t?t+=\"\":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?\"\":e+\"\"})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&\"set\"in r&&void 0!==r.set(this,t,\"value\")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&\"get\"in r&&void 0!==(e=r.get(t,\"value\"))?e:\"string\"==typeof(e=t.value)?e.replace(xt,\"\"):null==e?\"\":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,\"value\");return null!=t?t:yt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a=\"select-one\"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,\"optgroup\"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each([\"radio\",\"checkbox\"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},v.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})}),v.focusin=\"onfocusin\"in C;var bt=\/^(?:focusinfocus|focusoutblur)$\/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=y.call(e,\"type\")?e.type:e,h=y.call(e,\"namespace\")?e.namespace.split(\".\"):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(\".\")&&(d=(h=d.split(\".\")).shift(),h.sort()),u=d.indexOf(\":\")<0&&\"on\"+d,(e=e[S.expando]?e:new S.Event(d,\"object\"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join(\".\"),e.rnamespace=e.namespace?new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,\"events\")||Object.create(null))[e.type]&&Y.get(o,\"handle\"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),v.focusin||S.each({focus:\"focusin\",blur:\"focusout\"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=\/\\?\/;S.parseXML=function(e){var t,n;if(!e||\"string\"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,\"text\/xml\")}catch(e){}return n=t&&t.getElementsByTagName(\"parsererror\")[0],t&&!n||S.error(\"Invalid XML: \"+(n?S.map(n.childNodes,function(e){return e.textContent}).join(\"\\n\"):e)),t};var St=\/\\[\\]$\/,kt=\/\\r?\\n\/g,At=\/^(?:submit|button|image|reset|file)$\/i,Nt=\/^(?:input|select|textarea|keygen)\/i;function jt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):jt(n+\"[\"+(\"object\"==typeof t&&null!=t?e:\"\")+\"]\",t,r,i)});else if(r||\"object\"!==w(e))i(n,e);else for(t in e)jt(n+\"[\"+t+\"]\",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(null==n?\"\":n)};if(null==e)return\"\";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)jt(n,e[n],t,i);return r.join(\"&\")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,\"elements\");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(\":disabled\")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,\"\\r\\n\")}}):{name:t.name,value:n.replace(kt,\"\\r\\n\")}}).get()}});var Dt=\/%20\/g,qt=\/#.*$\/,Lt=\/([?&])_=[^&]*\/,Ht=\/^(.*?):[ \\t]*([^\\r\\n]*)$\/gm,Ot=\/^(?:GET|HEAD)$\/,Pt=\/^\\\/\\\/\/,Rt={},Mt={},It=\"*\/\".concat(\"*\"),Wt=E.createElement(\"a\");function Ft(o){return function(e,t){\"string\"!=typeof e&&(t=e,e=\"*\");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])\"+\"===n[0]?(n=n.slice(1)||\"*\",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function $t(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return\"string\"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s[\"*\"]&&l(\"*\")}function Bt(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:\"GET\",isLocal:\/^(?:about|app|app-storage|.+-extension|file|res|widget):$\/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:\"application\/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":It,text:\"text\/plain\",html:\"text\/html\",xml:\"application\/xml, text\/xml\",json:\"application\/json, text\/javascript\"},contents:{xml:\/\\bxml\\b\/,html:\/\\bhtml\/,json:\/\\bjson\\b\/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":JSON.parse,\"text xml\":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Bt(Bt(e,S.ajaxSettings),t):Bt(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){\"object\"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,y=S.ajaxSetup({},t),v=y.context||y,m=y.context&&(v.nodeType||v.jquery)?S(v):S.event,x=S.Deferred(),b=S.Callbacks(\"once memory\"),w=y.statusCode||{},a={},s={},u=\"canceled\",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+\" \"]=(n[t[1].toLowerCase()+\" \"]||[]).concat(t[2])}t=n[e.toLowerCase()+\" \"]}return null==t?null:t.join(\", \")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(y.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),y.url=((e||y.url||Tt.href)+\"\").replace(Pt,Tt.protocol+\"\/\/\"),y.type=t.method||t.type||y.method||y.type,y.dataTypes=(y.dataType||\"*\").toLowerCase().match(P)||[\"\"],null==y.crossDomain){r=E.createElement(\"a\");try{r.href=y.url,r.href=r.href,y.crossDomain=Wt.protocol+\"\/\/\"+Wt.host!=r.protocol+\"\/\/\"+r.host}catch(e){y.crossDomain=!0}}if(y.data&&y.processData&&\"string\"!=typeof y.data&&(y.data=S.param(y.data,y.traditional)),$t(Rt,y,t,T),h)return T;for(i in(g=S.event&&y.global)&&0==S.active++&&S.event.trigger(\"ajaxStart\"),y.type=y.type.toUpperCase(),y.hasContent=!Ot.test(y.type),f=y.url.replace(qt,\"\"),y.hasContent?y.data&&y.processData&&0===(y.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&(y.data=y.data.replace(Dt,\"+\")):(o=y.url.slice(f.length),y.data&&(y.processData||\"string\"==typeof y.data)&&(f+=(Et.test(f)?\"&\":\"?\")+y.data,delete y.data),!1===y.cache&&(f=f.replace(Lt,\"$1\"),o=(Et.test(f)?\"&\":\"?\")+\"_=\"+Ct.guid+++o),y.url=f+o),y.ifModified&&(S.lastModified[f]&&T.setRequestHeader(\"If-Modified-Since\",S.lastModified[f]),S.etag[f]&&T.setRequestHeader(\"If-None-Match\",S.etag[f])),(y.data&&y.hasContent&&!1!==y.contentType||t.contentType)&&T.setRequestHeader(\"Content-Type\",y.contentType),T.setRequestHeader(\"Accept\",y.dataTypes[0]&&y.accepts[y.dataTypes[0]]?y.accepts[y.dataTypes[0]]+(\"*\"!==y.dataTypes[0]?\", \"+It+\"; q=0.01\":\"\"):y.accepts[\"*\"]),y.headers)T.setRequestHeader(i,y.headers[i]);if(y.beforeSend&&(!1===y.beforeSend.call(v,T,y)||h))return T.abort();if(u=\"abort\",b.add(y.complete),T.done(y.success),T.fail(y.error),c=$t(Mt,y,t,T)){if(T.readyState=1,g&&m.trigger(\"ajaxSend\",[T,y]),h)return T;y.async&&0<y.timeout&&(d=C.setTimeout(function(){T.abort(\"timeout\")},y.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,\"No Transport\");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||\"\",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader(\"Content-Type\"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+\" \"+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(y,T,n)),!i&&-1<S.inArray(\"script\",y.dataTypes)&&S.inArray(\"json\",y.dataTypes)<0&&(y.converters[\"text script\"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if(\"*\"===o)o=u;else if(\"*\"!==u&&u!==o){if(!(a=l[u+\" \"+o]||l[\"* \"+o]))for(i in l)if((s=i.split(\" \"))[1]===o&&(a=l[u+\" \"+s[0]]||l[\"* \"+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(e){return{state:\"parsererror\",error:a?e:\"No conversion from \"+u+\" to \"+o}}}return{state:\"success\",data:t}}(y,s,T,i),i?(y.ifModified&&((u=T.getResponseHeader(\"Last-Modified\"))&&(S.lastModified[f]=u),(u=T.getResponseHeader(\"etag\"))&&(S.etag[f]=u)),204===e||\"HEAD\"===y.type?l=\"nocontent\":304===e?l=\"notmodified\":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l=\"error\",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+\"\",i?x.resolveWith(v,[o,l,T]):x.rejectWith(v,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?\"ajaxSuccess\":\"ajaxError\",[T,y,i?o:a]),b.fireWith(v,[T,l]),g&&(m.trigger(\"ajaxComplete\",[T,y]),--S.active||S.event.trigger(\"ajaxStop\")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,\"json\")},getScript:function(e,t){return S.get(e,void 0,t,\"script\")}}),S.each([\"get\",\"post\"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)\"content-type\"===t.toLowerCase()&&(e.contentType=e.headers[t]||\"\")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:\"GET\",dataType:\"script\",cache:!0,async:!1,global:!1,converters:{\"text script\":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not(\"body\").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();v.cors=!!zt&&\"withCredentials\"in zt,v.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(v.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e[\"X-Requested-With\"]||(e[\"X-Requested-With\"]=\"XMLHttpRequest\"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,\"abort\"===e?r.abort():\"error\"===e?\"number\"!=typeof r.status?t(0,\"error\"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,\"text\"!==(r.responseType||\"text\")||\"string\"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o(\"error\"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o(\"abort\");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:\"text\/javascript, application\/javascript, application\/ecmascript, application\/x-ecmascript\"},contents:{script:\/\\b(?:java|ecma)script\\b\/},converters:{\"text script\":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter(\"script\",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\")}),S.ajaxTransport(\"script\",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S(\"<script>\").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on(\"load error\",i=function(e){r.remove(),i=null,e&&t(\"error\"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=\/(=)\\?(?=&|$)|\\?\\?\/;S.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=Xt.pop()||S.expando+\"_\"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter(\"json jsonp\",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?\"url\":\"string\"==typeof e.data&&0===(e.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&Vt.test(e.data)&&\"data\");if(a||\"jsonp\"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,\"$1\"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?\"&\":\"?\")+e.jsonp+\"=\"+r),e.converters[\"script json\"]=function(){return o||S.error(r+\" was not called\"),o[0]},e.dataTypes[0]=\"json\",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),\"script\"}),v.createHTMLDocument=((Ut=E.implementation.createHTMLDocument(\"\").body).innerHTML=\"<form><\/form><form><\/form>\",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return\"string\"!=typeof e?[]:(\"boolean\"==typeof t&&(n=t,t=!1),t||(v.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument(\"\")).createElement(\"base\")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(\" \");return-1<s&&(r=yt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&\"object\"==typeof t&&(i=\"POST\"),0<a.length&&S.ajax({url:e,type:i||\"GET\",dataType:\"html\",data:t}).done(function(e){o=arguments,a.html(r?S(\"<div>\").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,\"position\"),c=S(e),f={};\"static\"===l&&(e.style.position=\"relative\"),s=c.offset(),o=S.css(e,\"top\"),u=S.css(e,\"left\"),(\"absolute\"===l||\"fixed\"===l)&&-1<(o+u).indexOf(\"auto\")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),\"using\"in t?t.using.call(e,f):c.css(f)}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if(\"fixed\"===S.css(r,\"position\"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&\"static\"===S.css(e,\"position\"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,\"borderTopWidth\",!0),i.left+=S.css(e,\"borderLeftWidth\",!0))}return{top:t.top-i.top-S.css(r,\"marginTop\",!0),left:t.left-i.left-S.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&\"static\"===S.css(e,\"position\"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(t,i){var o=\"pageYOffset\"===i;S.fn[t]=function(e){return B(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each([\"top\",\"left\"],function(e,n){S.cssHooks[n]=_e(v.pixelPosition,function(e,t){if(t)return t=Be(e,n),Pe.test(t)?S(e).position()[n]+\"px\":t})}),S.each({Height:\"height\",Width:\"width\"},function(a,s){S.each({padding:\"inner\"+a,content:s,\"\":\"outer\"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||\"boolean\"!=typeof e),i=r||(!0===e||!0===t?\"margin\":\"border\");return B(this,function(e,t,n){var r;return x(e)?0===o.indexOf(\"outer\")?e[\"inner\"+a]:e.document.documentElement[\"client\"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body[\"scroll\"+a],r[\"scroll\"+a],e.body[\"offset\"+a],r[\"offset\"+a],r[\"client\"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=\/^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$\/g;S.proxy=function(e,t){var n,r,i;if(\"string\"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return(\"number\"===t||\"string\"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?\"\":(e+\"\").replace(Gt,\"$1\")},\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},\"undefined\"==typeof e&&(C.jQuery=C.$=S),S});\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery\/jquery-3.6.1.min.js","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -0,0 +1,10716 @@\n+\/*!\n+ * jQuery JavaScript Library v3.7.1\n+ * https:\/\/jquery.com\/\n+ *\n+ * Copyright OpenJS Foundation and other contributors\n+ * Released under the MIT license\n+ * https:\/\/jquery.org\/license\n+ *\n+ * Date: 2023-08-28T13:37Z\n+ *\/\n+( function( global, factory ) {\n+\n+\t\"use strict\";\n+\n+\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n+\n+\t\t\/\/ For CommonJS and CommonJS-like environments where a proper `window`\n+\t\t\/\/ is present, execute the factory and get jQuery.\n+\t\t\/\/ For environments that do not have a `window` with a `document`\n+\t\t\/\/ (such as Node.js), expose a factory as module.exports.\n+\t\t\/\/ This accentuates the need for the creation of a real `window`.\n+\t\t\/\/ e.g. var jQuery = require(\"jquery\")(window);\n+\t\t\/\/ See ticket trac-14549 for more info.\n+\t\tmodule.exports = global.document ?\n+\t\t\tfactory( global, true ) :\n+\t\t\tfunction( w ) {\n+\t\t\t\tif ( !w.document ) {\n+\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n+\t\t\t\t}\n+\t\t\t\treturn factory( w );\n+\t\t\t};\n+\t} else {\n+\t\tfactory( global );\n+\t}\n+\n+\/\/ Pass this if window is not defined yet\n+} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n+\n+\/\/ Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n+\/\/ throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n+\/\/ arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n+\/\/ enough that all such attempts are guarded in a try block.\n+\"use strict\";\n+\n+var arr = [];\n+\n+var getProto = Object.getPrototypeOf;\n+\n+var slice = arr.slice;\n+\n+var flat = arr.flat ? function( array ) {\n+\treturn arr.flat.call( array );\n+} : function( array ) {\n+\treturn arr.concat.apply( [], array );\n+};\n+\n+\n+var push = arr.push;\n+\n+var indexOf = arr.indexOf;\n+\n+var class2type = {};\n+\n+var toString = class2type.toString;\n+\n+var hasOwn = class2type.hasOwnProperty;\n+\n+var fnToString = hasOwn.toString;\n+\n+var ObjectFunctionString = fnToString.call( Object );\n+\n+var support = {};\n+\n+var isFunction = function isFunction( obj ) {\n+\n+\t\t\/\/ Support: Chrome <=57, Firefox <=52\n+\t\t\/\/ In some browsers, typeof returns \"function\" for HTML <object> elements\n+\t\t\/\/ (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n+\t\t\/\/ We don't want to classify *any* DOM node as a function.\n+\t\t\/\/ Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n+\t\t\/\/ Plus for old WebKit, typeof returns \"function\" for HTML collections\n+\t\t\/\/ (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n+\t\treturn typeof obj === \"function\" && typeof obj.nodeType !== \"number\" &&\n+\t\t\ttypeof obj.item !== \"function\";\n+\t};\n+\n+\n+var isWindow = function isWindow( obj ) {\n+\t\treturn obj != null && obj === obj.window;\n+\t};\n+\n+\n+var document = window.document;\n+\n+\n+\n+\tvar preservedScriptAttributes = {\n+\t\ttype: true,\n+\t\tsrc: true,\n+\t\tnonce: true,\n+\t\tnoModule: true\n+\t};\n+\n+\tfunction DOMEval( code, node, doc ) {\n+\t\tdoc = doc || document;\n+\n+\t\tvar i, val,\n+\t\t\tscript = doc.createElement( \"script\" );\n+\n+\t\tscript.text = code;\n+\t\tif ( node ) {\n+\t\t\tfor ( i in preservedScriptAttributes ) {\n+\n+\t\t\t\t\/\/ Support: Firefox 64+, Edge 18+\n+\t\t\t\t\/\/ Some browsers don't support the \"nonce\" property on scripts.\n+\t\t\t\t\/\/ On the other hand, just using `getAttribute` is not enough as\n+\t\t\t\t\/\/ the `nonce` attribute is reset to an empty string whenever it\n+\t\t\t\t\/\/ becomes browsing-context connected.\n+\t\t\t\t\/\/ See https:\/\/github.com\/whatwg\/html\/issues\/2369\n+\t\t\t\t\/\/ See https:\/\/html.spec.whatwg.org\/#nonce-attributes\n+\t\t\t\t\/\/ The `node.getAttribute` check was added for the sake of\n+\t\t\t\t\/\/ `jQuery.globalEval` so that it can fake a nonce-containing node\n+\t\t\t\t\/\/ via an object.\n+\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n+\t\t\t\tif ( val ) {\n+\t\t\t\t\tscript.setAttribute( i, val );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n+\t}\n+\n+\n+function toType( obj ) {\n+\tif ( obj == null ) {\n+\t\treturn obj + \"\";\n+\t}\n+\n+\t\/\/ Support: Android <=2.3 only (functionish RegExp)\n+\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n+\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n+\t\ttypeof obj;\n+}\n+\/* global Symbol *\/\n+\/\/ Defining this global in .eslintrc.json would create a danger of using the global\n+\/\/ unguarded in another place, it seems safer to define global only for this module\n+\n+\n+\n+var version = \"3.7.1\",\n+\n+\trhtmlSuffix = \/HTML$\/i,\n+\n+\t\/\/ Define a local copy of jQuery\n+\tjQuery = function( selector, context ) {\n+\n+\t\t\/\/ The jQuery object is actually just the init constructor 'enhanced'\n+\t\t\/\/ Need init if jQuery is called (just allow error to be thrown if not included)\n+\t\treturn new jQuery.fn.init( selector, context );\n+\t};\n+\n+jQuery.fn = jQuery.prototype = {\n+\n+\t\/\/ The current version of jQuery being used\n+\tjquery: version,\n+\n+\tconstructor: jQuery,\n+\n+\t\/\/ The default length of a jQuery object is 0\n+\tlength: 0,\n+\n+\ttoArray: function() {\n+\t\treturn slice.call( this );\n+\t},\n+\n+\t\/\/ Get the Nth element in the matched element set OR\n+\t\/\/ Get the whole matched element set as a clean array\n+\tget: function( num ) {\n+\n+\t\t\/\/ Return all the elements in a clean array\n+\t\tif ( num == null ) {\n+\t\t\treturn slice.call( this );\n+\t\t}\n+\n+\t\t\/\/ Return just the one element from the set\n+\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n+\t},\n+\n+\t\/\/ Take an array of elements and push it onto the stack\n+\t\/\/ (returning the new matched element set)\n+\tpushStack: function( elems ) {\n+\n+\t\t\/\/ Build a new jQuery matched element set\n+\t\tvar ret = jQuery.merge( this.constructor(), elems );\n+\n+\t\t\/\/ Add the old object onto the stack (as a reference)\n+\t\tret.prevObject = this;\n+\n+\t\t\/\/ Return the newly-formed element set\n+\t\treturn ret;\n+\t},\n+\n+\t\/\/ Execute a callback for every element in the matched set.\n+\teach: function( callback ) {\n+\t\treturn jQuery.each( this, callback );\n+\t},\n+\n+\tmap: function( callback ) {\n+\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n+\t\t\treturn callback.call( elem, i, elem );\n+\t\t} ) );\n+\t},\n+\n+\tslice: function() {\n+\t\treturn this.pushStack( slice.apply( this, arguments ) );\n+\t},\n+\n+\tfirst: function() {\n+\t\treturn this.eq( 0 );\n+\t},\n+\n+\tlast: function() {\n+\t\treturn this.eq( -1 );\n+\t},\n+\n+\teven: function() {\n+\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n+\t\t\treturn ( i + 1 ) % 2;\n+\t\t} ) );\n+\t},\n+\n+\todd: function() {\n+\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n+\t\t\treturn i % 2;\n+\t\t} ) );\n+\t},\n+\n+\teq: function( i ) {\n+\t\tvar len = this.length,\n+\t\t\tj = +i + ( i < 0 ? len : 0 );\n+\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n+\t},\n+\n+\tend: function() {\n+\t\treturn this.prevObject || this.constructor();\n+\t},\n+\n+\t\/\/ For internal use only.\n+\t\/\/ Behaves like an Array's method, not like a jQuery method.\n+\tpush: push,\n+\tsort: arr.sort,\n+\tsplice: arr.splice\n+};\n+\n+jQuery.extend = jQuery.fn.extend = function() {\n+\tvar options, name, src, copy, copyIsArray, clone,\n+\t\ttarget = arguments[ 0 ] || {},\n+\t\ti = 1,\n+\t\tlength = arguments.length,\n+\t\tdeep = false;\n+\n+\t\/\/ Handle a deep copy situation\n+\tif ( typeof target === \"boolean\" ) {\n+\t\tdeep = target;\n+\n+\t\t\/\/ Skip the boolean and the target\n+\t\ttarget = arguments[ i ] || {};\n+\t\ti++;\n+\t}\n+\n+\t\/\/ Handle case when target is a string or something (possible in deep copy)\n+\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n+\t\ttarget = {};\n+\t}\n+\n+\t\/\/ Extend jQuery itself if only one argument is passed\n+\tif ( i === length ) {\n+\t\ttarget = this;\n+\t\ti--;\n+\t}\n+\n+\tfor ( ; i < length; i++ ) {\n+\n+\t\t\/\/ Only deal with non-null\/undefined values\n+\t\tif ( ( options = arguments[ i ] ) != null ) {\n+\n+\t\t\t\/\/ Extend the base object\n+\t\t\tfor ( name in options ) {\n+\t\t\t\tcopy = options[ name ];\n+\n+\t\t\t\t\/\/ Prevent Object.prototype pollution\n+\t\t\t\t\/\/ Prevent never-ending loop\n+\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Recurse if we're merging plain objects or arrays\n+\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n+\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n+\t\t\t\t\tsrc = target[ name ];\n+\n+\t\t\t\t\t\/\/ Ensure proper type for the source value\n+\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n+\t\t\t\t\t\tclone = [];\n+\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n+\t\t\t\t\t\tclone = {};\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tclone = src;\n+\t\t\t\t\t}\n+\t\t\t\t\tcopyIsArray = false;\n+\n+\t\t\t\t\t\/\/ Never move original objects, clone them\n+\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n+\n+\t\t\t\t\/\/ Don't bring in undefined values\n+\t\t\t\t} else if ( copy !== undefined ) {\n+\t\t\t\t\ttarget[ name ] = copy;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t\/\/ Return the modified object\n+\treturn target;\n+};\n+\n+jQuery.extend( {\n+\n+\t\/\/ Unique for each copy of jQuery on the page\n+\texpando: \"jQuery\" + ( version + Math.random() ).replace( \/\\D\/g, \"\" ),\n+\n+\t\/\/ Assume jQuery is ready without the ready module\n+\tisReady: true,\n+\n+\terror: function( msg ) {\n+\t\tthrow new Error( msg );\n+\t},\n+\n+\tnoop: function() {},\n+\n+\tisPlainObject: function( obj ) {\n+\t\tvar proto, Ctor;\n+\n+\t\t\/\/ Detect obvious negatives\n+\t\t\/\/ Use toString instead of jQuery.type to catch host objects\n+\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tproto = getProto( obj );\n+\n+\t\t\/\/ Objects with no prototype (e.g., `Object.create( null )`) are plain\n+\t\tif ( !proto ) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t\/\/ Objects with prototype are plain iff they were constructed by a global Object function\n+\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n+\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n+\t},\n+\n+\tisEmptyObject: function( obj ) {\n+\t\tvar name;\n+\n+\t\tfor ( name in obj ) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t},\n+\n+\t\/\/ Evaluates a script in a provided context; falls back to the global one\n+\t\/\/ if not specified.\n+\tglobalEval: function( code, options, doc ) {\n+\t\tDOMEval( code, { nonce: options && options.nonce }, doc );\n+\t},\n+\n+\teach: function( obj, callback ) {\n+\t\tvar length, i = 0;\n+\n+\t\tif ( isArrayLike( obj ) ) {\n+\t\t\tlength = obj.length;\n+\t\t\tfor ( ; i < length; i++ ) {\n+\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor ( i in obj ) {\n+\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn obj;\n+\t},\n+\n+\n+\t\/\/ Retrieve the text value of an array of DOM nodes\n+\ttext: function( elem ) {\n+\t\tvar node,\n+\t\t\tret = \"\",\n+\t\t\ti = 0,\n+\t\t\tnodeType = elem.nodeType;\n+\n+\t\tif ( !nodeType ) {\n+\n+\t\t\t\/\/ If no nodeType, this is expected to be an array\n+\t\t\twhile ( ( node = elem[ i++ ] ) ) {\n+\n+\t\t\t\t\/\/ Do not traverse comment nodes\n+\t\t\t\tret += jQuery.text( node );\n+\t\t\t}\n+\t\t}\n+\t\tif ( nodeType === 1 || nodeType === 11 ) {\n+\t\t\treturn elem.textContent;\n+\t\t}\n+\t\tif ( nodeType === 9 ) {\n+\t\t\treturn elem.documentElement.textContent;\n+\t\t}\n+\t\tif ( nodeType === 3 || nodeType === 4 ) {\n+\t\t\treturn elem.nodeValue;\n+\t\t}\n+\n+\t\t\/\/ Do not include comment or processing instruction nodes\n+\n+\t\treturn ret;\n+\t},\n+\n+\t\/\/ results is for internal usage only\n+\tmakeArray: function( arr, results ) {\n+\t\tvar ret = results || [];\n+\n+\t\tif ( arr != null ) {\n+\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n+\t\t\t\tjQuery.merge( ret,\n+\t\t\t\t\ttypeof arr === \"string\" ?\n+\t\t\t\t\t\t[ arr ] : arr\n+\t\t\t\t);\n+\t\t\t} else {\n+\t\t\t\tpush.call( ret, arr );\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn ret;\n+\t},\n+\n+\tinArray: function( elem, arr, i ) {\n+\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n+\t},\n+\n+\tisXMLDoc: function( elem ) {\n+\t\tvar namespace = elem && elem.namespaceURI,\n+\t\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n+\n+\t\t\/\/ Assume HTML when documentElement doesn't yet exist, such as inside\n+\t\t\/\/ document fragments.\n+\t\treturn !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n+\t},\n+\n+\t\/\/ Support: Android <=4.0 only, PhantomJS 1 only\n+\t\/\/ push.apply(_, arraylike) throws on ancient WebKit\n+\tmerge: function( first, second ) {\n+\t\tvar len = +second.length,\n+\t\t\tj = 0,\n+\t\t\ti = first.length;\n+\n+\t\tfor ( ; j < len; j++ ) {\n+\t\t\tfirst[ i++ ] = second[ j ];\n+\t\t}\n+\n+\t\tfirst.length = i;\n+\n+\t\treturn first;\n+\t},\n+\n+\tgrep: function( elems, callback, invert ) {\n+\t\tvar callbackInverse,\n+\t\t\tmatches = [],\n+\t\t\ti = 0,\n+\t\t\tlength = elems.length,\n+\t\t\tcallbackExpect = !invert;\n+\n+\t\t\/\/ Go through the array, only saving the items\n+\t\t\/\/ that pass the validator function\n+\t\tfor ( ; i < length; i++ ) {\n+\t\t\tcallbackInverse = !callback( elems[ i ], i );\n+\t\t\tif ( callbackInverse !== callbackExpect ) {\n+\t\t\t\tmatches.push( elems[ i ] );\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn matches;\n+\t},\n+\n+\t\/\/ arg is for internal usage only\n+\tmap: function( elems, callback, arg ) {\n+\t\tvar length, value,\n+\t\t\ti = 0,\n+\t\t\tret = [];\n+\n+\t\t\/\/ Go through the array, translating each of the items to their new values\n+\t\tif ( isArrayLike( elems ) ) {\n+\t\t\tlength = elems.length;\n+\t\t\tfor ( ; i < length; i++ ) {\n+\t\t\t\tvalue = callback( elems[ i ], i, arg );\n+\n+\t\t\t\tif ( value != null ) {\n+\t\t\t\t\tret.push( value );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\/\/ Go through every key on the object,\n+\t\t} else {\n+\t\t\tfor ( i in elems ) {\n+\t\t\t\tvalue = callback( elems[ i ], i, arg );\n+\n+\t\t\t\tif ( value != null ) {\n+\t\t\t\t\tret.push( value );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Flatten any nested arrays\n+\t\treturn flat( ret );\n+\t},\n+\n+\t\/\/ A global GUID counter for objects\n+\tguid: 1,\n+\n+\t\/\/ jQuery.support is not used in Core but other projects attach their\n+\t\/\/ properties to it so it needs to exist.\n+\tsupport: support\n+} );\n+\n+if ( typeof Symbol === \"function\" ) {\n+\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n+}\n+\n+\/\/ Populate the class2type map\n+jQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n+\tfunction( _i, name ) {\n+\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n+\t} );\n+\n+function isArrayLike( obj ) {\n+\n+\t\/\/ Support: real iOS 8.2 only (not reproducible in simulator)\n+\t\/\/ `in` check used to prevent JIT error (gh-2145)\n+\t\/\/ hasOwn isn't used here due to false negatives\n+\t\/\/ regarding Nodelist length in IE\n+\tvar length = !!obj && \"length\" in obj && obj.length,\n+\t\ttype = toType( obj );\n+\n+\tif ( isFunction( obj ) || isWindow( obj ) ) {\n+\t\treturn false;\n+\t}\n+\n+\treturn type === \"array\" || length === 0 ||\n+\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n+}\n+\n+\n+function nodeName( elem, name ) {\n+\n+\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n+\n+}\n+var pop = arr.pop;\n+\n+\n+var sort = arr.sort;\n+\n+\n+var splice = arr.splice;\n+\n+\n+var whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\n+\n+\n+var rtrimCSS = new RegExp(\n+\t\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\",\n+\t\"g\"\n+);\n+\n+\n+\n+\n+\/\/ Note: an element does not contain itself\n+jQuery.contains = function( a, b ) {\n+\tvar bup = b && b.parentNode;\n+\n+\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n+\n+\t\t\/\/ Support: IE 9 - 11+\n+\t\t\/\/ IE doesn't have `contains` on SVG.\n+\t\ta.contains ?\n+\t\t\ta.contains( bup ) :\n+\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n+\t) );\n+};\n+\n+\n+\n+\n+\/\/ CSS string\/identifier serialization\n+\/\/ https:\/\/drafts.csswg.org\/cssom\/#common-serializing-idioms\n+var rcssescape = \/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]\/g;\n+\n+function fcssescape( ch, asCodePoint ) {\n+\tif ( asCodePoint ) {\n+\n+\t\t\/\/ U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n+\t\tif ( ch === \"\\0\" ) {\n+\t\t\treturn \"\\uFFFD\";\n+\t\t}\n+\n+\t\t\/\/ Control characters and (dependent upon position) numbers get escaped as code points\n+\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n+\t}\n+\n+\t\/\/ Other potentially-special ASCII characters get backslash-escaped\n+\treturn \"\\\\\" + ch;\n+}\n+\n+jQuery.escapeSelector = function( sel ) {\n+\treturn ( sel + \"\" ).replace( rcssescape, fcssescape );\n+};\n+\n+\n+\n+\n+var preferredDoc = document,\n+\tpushNative = push;\n+\n+( function() {\n+\n+var i,\n+\tExpr,\n+\toutermostContext,\n+\tsortInput,\n+\thasDuplicate,\n+\tpush = pushNative,\n+\n+\t\/\/ Local document vars\n+\tdocument,\n+\tdocumentElement,\n+\tdocumentIsHTML,\n+\trbuggyQSA,\n+\tmatches,\n+\n+\t\/\/ Instance-specific data\n+\texpando = jQuery.expando,\n+\tdirruns = 0,\n+\tdone = 0,\n+\tclassCache = createCache(),\n+\ttokenCache = createCache(),\n+\tcompilerCache = createCache(),\n+\tnonnativeSelectorCache = createCache(),\n+\tsortOrder = function( a, b ) {\n+\t\tif ( a === b ) {\n+\t\t\thasDuplicate = true;\n+\t\t}\n+\t\treturn 0;\n+\t},\n+\n+\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|\" +\n+\t\t\"loop|multiple|open|readonly|required|scoped\",\n+\n+\t\/\/ Regular expressions\n+\n+\t\/\/ https:\/\/www.w3.org\/TR\/css-syntax-3\/#ident-token-diagram\n+\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n+\t\t\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n+\n+\t\/\/ Attribute selectors: https:\/\/www.w3.org\/TR\/selectors\/#attribute-selectors\n+\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n+\n+\t\t\/\/ Operator (capture 2)\n+\t\t\"*([*^$|!~]?=)\" + whitespace +\n+\n+\t\t\/\/ \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n+\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" +\n+\t\twhitespace + \"*\\\\]\",\n+\n+\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n+\n+\t\t\/\/ To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n+\t\t\/\/ 1. quoted (capture 3; capture 4 or capture 5)\n+\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n+\n+\t\t\/\/ 2. simple (capture 6)\n+\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n+\n+\t\t\/\/ 3. anything else (capture 2)\n+\t\t\".*\" +\n+\t\t\")\\\\)|)\",\n+\n+\t\/\/ Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n+\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n+\n+\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n+\trleadingCombinator = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" +\n+\t\twhitespace + \"*\" ),\n+\trdescend = new RegExp( whitespace + \"|>\" ),\n+\n+\trpseudo = new RegExp( pseudos ),\n+\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n+\n+\tmatchExpr = {\n+\t\tID: new RegExp( \"^#(\" + identifier + \")\" ),\n+\t\tCLASS: new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n+\t\tTAG: new RegExp( \"^(\" + identifier + \"|[*])\" ),\n+\t\tATTR: new RegExp( \"^\" + attributes ),\n+\t\tPSEUDO: new RegExp( \"^\" + pseudos ),\n+\t\tCHILD: new RegExp(\n+\t\t\t\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n+\t\t\t\twhitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" +\n+\t\t\t\twhitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n+\t\tbool: new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n+\n+\t\t\/\/ For use in libraries implementing .is()\n+\t\t\/\/ We use this for POS matching in `select`\n+\t\tneedsContext: new RegExp( \"^\" + whitespace +\n+\t\t\t\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace +\n+\t\t\t\"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n+\t},\n+\n+\trinputs = \/^(?:input|select|textarea|button)$\/i,\n+\trheader = \/^h\\d$\/i,\n+\n+\t\/\/ Easily-parseable\/retrievable ID or TAG or CLASS selectors\n+\trquickExpr = \/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$\/,\n+\n+\trsibling = \/[+~]\/,\n+\n+\t\/\/ CSS escapes\n+\t\/\/ https:\/\/www.w3.org\/TR\/CSS21\/syndata.html#escaped-characters\n+\trunescape = new RegExp( \"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n+\t\t\"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\" ),\n+\tfunescape = function( escape, nonHex ) {\n+\t\tvar high = \"0x\" + escape.slice( 1 ) - 0x10000;\n+\n+\t\tif ( nonHex ) {\n+\n+\t\t\t\/\/ Strip the backslash prefix from a non-hex escape sequence\n+\t\t\treturn nonHex;\n+\t\t}\n+\n+\t\t\/\/ Replace a hexadecimal escape sequence with the encoded Unicode code point\n+\t\t\/\/ Support: IE <=11+\n+\t\t\/\/ For values outside the Basic Multilingual Plane (BMP), manually construct a\n+\t\t\/\/ surrogate pair\n+\t\treturn high < 0 ?\n+\t\t\tString.fromCharCode( high + 0x10000 ) :\n+\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n+\t},\n+\n+\t\/\/ Used for iframes; see `setDocument`.\n+\t\/\/ Support: IE 9 - 11+, Edge 12 - 18+\n+\t\/\/ Removing the function wrapper causes a \"Permission Denied\"\n+\t\/\/ error in IE\/Edge.\n+\tunloadHandler = function() {\n+\t\tsetDocument();\n+\t},\n+\n+\tinDisabledFieldset = addCombinator(\n+\t\tfunction( elem ) {\n+\t\t\treturn elem.disabled === true && nodeName( elem, \"fieldset\" );\n+\t\t},\n+\t\t{ dir: \"parentNode\", next: \"legend\" }\n+\t);\n+\n+\/\/ Support: IE <=9 only\n+\/\/ Accessing document.activeElement can throw unexpectedly\n+\/\/ https:\/\/bugs.jquery.com\/ticket\/13393\n+function safeActiveElement() {\n+\ttry {\n+\t\treturn document.activeElement;\n+\t} catch ( err ) { }\n+}\n+\n+\/\/ Optimize for push.apply( _, NodeList )\n+try {\n+\tpush.apply(\n+\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n+\t\tpreferredDoc.childNodes\n+\t);\n+\n+\t\/\/ Support: Android <=4.0\n+\t\/\/ Detect silently failing push.apply\n+\t\/\/ eslint-disable-next-line no-unused-expressions\n+\tarr[ preferredDoc.childNodes.length ].nodeType;\n+} catch ( e ) {\n+\tpush = {\n+\t\tapply: function( target, els ) {\n+\t\t\tpushNative.apply( target, slice.call( els ) );\n+\t\t},\n+\t\tcall: function( target ) {\n+\t\t\tpushNative.apply( target, slice.call( arguments, 1 ) );\n+\t\t}\n+\t};\n+}\n+\n+function find( selector, context, results, seed ) {\n+\tvar m, i, elem, nid, match, groups, newSelector,\n+\t\tnewContext = context && context.ownerDocument,\n+\n+\t\t\/\/ nodeType defaults to 9, since context defaults to document\n+\t\tnodeType = context ? context.nodeType : 9;\n+\n+\tresults = results || [];\n+\n+\t\/\/ Return early from calls with invalid selector or context\n+\tif ( typeof selector !== \"string\" || !selector ||\n+\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n+\n+\t\treturn results;\n+\t}\n+\n+\t\/\/ Try to shortcut find operations (as opposed to filters) in HTML documents\n+\tif ( !seed ) {\n+\t\tsetDocument( context );\n+\t\tcontext = context || document;\n+\n+\t\tif ( documentIsHTML ) {\n+\n+\t\t\t\/\/ If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n+\t\t\t\/\/ (excepting DocumentFragment context, where the methods don't exist)\n+\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n+\n+\t\t\t\t\/\/ ID selector\n+\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n+\n+\t\t\t\t\t\/\/ Document context\n+\t\t\t\t\tif ( nodeType === 9 ) {\n+\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n+\n+\t\t\t\t\t\t\t\/\/ Support: IE 9 only\n+\t\t\t\t\t\t\t\/\/ getElementById can match elements by name instead of ID\n+\t\t\t\t\t\t\tif ( elem.id === m ) {\n+\t\t\t\t\t\t\t\tpush.call( results, elem );\n+\t\t\t\t\t\t\t\treturn results;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\treturn results;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\/\/ Element context\n+\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\/\/ Support: IE 9 only\n+\t\t\t\t\t\t\/\/ getElementById can match elements by name instead of ID\n+\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n+\t\t\t\t\t\t\tfind.contains( context, elem ) &&\n+\t\t\t\t\t\t\telem.id === m ) {\n+\n+\t\t\t\t\t\t\tpush.call( results, elem );\n+\t\t\t\t\t\t\treturn results;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\/\/ Type selector\n+\t\t\t\t} else if ( match[ 2 ] ) {\n+\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n+\t\t\t\t\treturn results;\n+\n+\t\t\t\t\/\/ Class selector\n+\t\t\t\t} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {\n+\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n+\t\t\t\t\treturn results;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t\/\/ Take advantage of querySelectorAll\n+\t\t\tif ( !nonnativeSelectorCache[ selector + \" \" ] &&\n+\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {\n+\n+\t\t\t\tnewSelector = selector;\n+\t\t\t\tnewContext = context;\n+\n+\t\t\t\t\/\/ qSA considers elements outside a scoping root when evaluating child or\n+\t\t\t\t\/\/ descendant combinators, which is not what we want.\n+\t\t\t\t\/\/ In such cases, we work around the behavior by prefixing every selector in the\n+\t\t\t\t\/\/ list with an ID selector referencing the scope context.\n+\t\t\t\t\/\/ The technique has to be used as well when a leading combinator is used\n+\t\t\t\t\/\/ as such selectors are not recognized by querySelectorAll.\n+\t\t\t\t\/\/ Thanks to Andrew Dupont for this technique.\n+\t\t\t\tif ( nodeType === 1 &&\n+\t\t\t\t\t( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {\n+\n+\t\t\t\t\t\/\/ Expand context for sibling selectors\n+\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n+\t\t\t\t\t\tcontext;\n+\n+\t\t\t\t\t\/\/ We can use :scope instead of the ID hack if the browser\n+\t\t\t\t\t\/\/ supports it & if we're not changing the context.\n+\t\t\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\t\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when\n+\t\t\t\t\t\/\/ strict-comparing two documents; shallow comparisons work.\n+\t\t\t\t\t\/\/ eslint-disable-next-line eqeqeq\n+\t\t\t\t\tif ( newContext != context || !support.scope ) {\n+\n+\t\t\t\t\t\t\/\/ Capture the context ID, setting it first if necessary\n+\t\t\t\t\t\tif ( ( nid = context.getAttribute( \"id\" ) ) ) {\n+\t\t\t\t\t\t\tnid = jQuery.escapeSelector( nid );\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcontext.setAttribute( \"id\", ( nid = expando ) );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t\/\/ Prefix every selector in the list\n+\t\t\t\t\tgroups = tokenize( selector );\n+\t\t\t\t\ti = groups.length;\n+\t\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\t\tgroups[ i ] = ( nid ? \"#\" + nid : \":scope\" ) + \" \" +\n+\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n+\t\t\t\t\t}\n+\t\t\t\t\tnewSelector = groups.join( \",\" );\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tpush.apply( results,\n+\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n+\t\t\t\t\t);\n+\t\t\t\t\treturn results;\n+\t\t\t\t} catch ( qsaError ) {\n+\t\t\t\t\tnonnativeSelectorCache( selector, true );\n+\t\t\t\t} finally {\n+\t\t\t\t\tif ( nid === expando ) {\n+\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t\/\/ All others\n+\treturn select( selector.replace( rtrimCSS, \"$1\" ), context, results, seed );\n+}\n+\n+\/**\n+ * Create key-value caches of limited size\n+ * @returns {function(string, object)} Returns the Object data after storing it on itself with\n+ *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n+ *\tdeleting the oldest entry\n+ *\/\n+function createCache() {\n+\tvar keys = [];\n+\n+\tfunction cache( key, value ) {\n+\n+\t\t\/\/ Use (key + \" \") to avoid collision with native prototype properties\n+\t\t\/\/ (see https:\/\/github.com\/jquery\/sizzle\/issues\/157)\n+\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n+\n+\t\t\t\/\/ Only keep the most recent entries\n+\t\t\tdelete cache[ keys.shift() ];\n+\t\t}\n+\t\treturn ( cache[ key + \" \" ] = value );\n+\t}\n+\treturn cache;\n+}\n+\n+\/**\n+ * Mark a function for special use by jQuery selector module\n+ * @param {Function} fn The function to mark\n+ *\/\n+function markFunction( fn ) {\n+\tfn[ expando ] = true;\n+\treturn fn;\n+}\n+\n+\/**\n+ * Support testing using an element\n+ * @param {Function} fn Passed the created element and returns a boolean result\n+ *\/\n+function assert( fn ) {\n+\tvar el = document.createElement( \"fieldset\" );\n+\n+\ttry {\n+\t\treturn !!fn( el );\n+\t} catch ( e ) {\n+\t\treturn false;\n+\t} finally {\n+\n+\t\t\/\/ Remove from its parent by default\n+\t\tif ( el.parentNode ) {\n+\t\t\tel.parentNode.removeChild( el );\n+\t\t}\n+\n+\t\t\/\/ release memory in IE\n+\t\tel = null;\n+\t}\n+}\n+\n+\/**\n+ * Returns a function to use in pseudos for input types\n+ * @param {String} type\n+ *\/\n+function createInputPseudo( type ) {\n+\treturn function( elem ) {\n+\t\treturn nodeName( elem, \"input\" ) && elem.type === type;\n+\t};\n+}\n+\n+\/**\n+ * Returns a function to use in pseudos for buttons\n+ * @param {String} type\n+ *\/\n+function createButtonPseudo( type ) {\n+\treturn function( elem ) {\n+\t\treturn ( nodeName( elem, \"input\" ) || nodeName( elem, \"button\" ) ) &&\n+\t\t\telem.type === type;\n+\t};\n+}\n+\n+\/**\n+ * Returns a function to use in pseudos for :enabled\/:disabled\n+ * @param {Boolean} disabled true for :disabled; false for :enabled\n+ *\/\n+function createDisabledPseudo( disabled ) {\n+\n+\t\/\/ Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n+\treturn function( elem ) {\n+\n+\t\t\/\/ Only certain elements can match :enabled or :disabled\n+\t\t\/\/ https:\/\/html.spec.whatwg.org\/multipage\/scripting.html#selector-enabled\n+\t\t\/\/ https:\/\/html.spec.whatwg.org\/multipage\/scripting.html#selector-disabled\n+\t\tif ( \"form\" in elem ) {\n+\n+\t\t\t\/\/ Check for inherited disabledness on relevant non-disabled elements:\n+\t\t\t\/\/ * listed form-associated elements in a disabled fieldset\n+\t\t\t\/\/   https:\/\/html.spec.whatwg.org\/multipage\/forms.html#category-listed\n+\t\t\t\/\/   https:\/\/html.spec.whatwg.org\/multipage\/forms.html#concept-fe-disabled\n+\t\t\t\/\/ * option elements in a disabled optgroup\n+\t\t\t\/\/   https:\/\/html.spec.whatwg.org\/multipage\/forms.html#concept-option-disabled\n+\t\t\t\/\/ All such elements have a \"form\" property.\n+\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n+\n+\t\t\t\t\/\/ Option elements defer to a parent optgroup if present\n+\t\t\t\tif ( \"label\" in elem ) {\n+\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n+\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn elem.disabled === disabled;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Support: IE 6 - 11+\n+\t\t\t\t\/\/ Use the isDisabled shortcut property to check for disabled fieldset ancestors\n+\t\t\t\treturn elem.isDisabled === disabled ||\n+\n+\t\t\t\t\t\/\/ Where there is no isDisabled, check manually\n+\t\t\t\t\telem.isDisabled !== !disabled &&\n+\t\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n+\t\t\t}\n+\n+\t\t\treturn elem.disabled === disabled;\n+\n+\t\t\/\/ Try to winnow out elements that can't be disabled before trusting the disabled property.\n+\t\t\/\/ Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n+\t\t\/\/ even exist on them, let alone have a boolean value.\n+\t\t} else if ( \"label\" in elem ) {\n+\t\t\treturn elem.disabled === disabled;\n+\t\t}\n+\n+\t\t\/\/ Remaining elements are neither :enabled nor :disabled\n+\t\treturn false;\n+\t};\n+}\n+\n+\/**\n+ * Returns a function to use in pseudos for positionals\n+ * @param {Function} fn\n+ *\/\n+function createPositionalPseudo( fn ) {\n+\treturn markFunction( function( argument ) {\n+\t\targument = +argument;\n+\t\treturn markFunction( function( seed, matches ) {\n+\t\t\tvar j,\n+\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n+\t\t\t\ti = matchIndexes.length;\n+\n+\t\t\t\/\/ Match elements found at the specified indexes\n+\t\t\twhile ( i-- ) {\n+\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n+\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} );\n+\t} );\n+}\n+\n+\/**\n+ * Checks a node for validity as a jQuery selector context\n+ * @param {Element|Object=} context\n+ * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n+ *\/\n+function testContext( context ) {\n+\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n+}\n+\n+\/**\n+ * Sets document-related variables once based on the current document\n+ * @param {Element|Object} [node] An element or document object to use to set the document\n+ * @returns {Object} Returns the current document\n+ *\/\n+function setDocument( node ) {\n+\tvar subWindow,\n+\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n+\n+\t\/\/ Return early if doc is invalid or already selected\n+\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\/\/ two documents; shallow comparisons work.\n+\t\/\/ eslint-disable-next-line eqeqeq\n+\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n+\t\treturn document;\n+\t}\n+\n+\t\/\/ Update global variables\n+\tdocument = doc;\n+\tdocumentElement = document.documentElement;\n+\tdocumentIsHTML = !jQuery.isXMLDoc( document );\n+\n+\t\/\/ Support: iOS 7 only, IE 9 - 11+\n+\t\/\/ Older browsers didn't support unprefixed `matches`.\n+\tmatches = documentElement.matches ||\n+\t\tdocumentElement.webkitMatchesSelector ||\n+\t\tdocumentElement.msMatchesSelector;\n+\n+\t\/\/ Support: IE 9 - 11+, Edge 12 - 18+\n+\t\/\/ Accessing iframe documents after unload throws \"permission denied\" errors\n+\t\/\/ (see trac-13936).\n+\t\/\/ Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,\n+\t\/\/ all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.\n+\tif ( documentElement.msMatchesSelector &&\n+\n+\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\/\/ two documents; shallow comparisons work.\n+\t\t\/\/ eslint-disable-next-line eqeqeq\n+\t\tpreferredDoc != document &&\n+\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n+\n+\t\t\/\/ Support: IE 9 - 11+, Edge 12 - 18+\n+\t\tsubWindow.addEventListener( \"unload\", unloadHandler );\n+\t}\n+\n+\t\/\/ Support: IE <10\n+\t\/\/ Check if getElementById returns elements by name\n+\t\/\/ The broken getElementById methods don't pick up programmatically-set names,\n+\t\/\/ so use a roundabout getElementsByName test\n+\tsupport.getById = assert( function( el ) {\n+\t\tdocumentElement.appendChild( el ).id = jQuery.expando;\n+\t\treturn !document.getElementsByName ||\n+\t\t\t!document.getElementsByName( jQuery.expando ).length;\n+\t} );\n+\n+\t\/\/ Support: IE 9 only\n+\t\/\/ Check to see if it's possible to do matchesSelector\n+\t\/\/ on a disconnected node.\n+\tsupport.disconnectedMatch = assert( function( el ) {\n+\t\treturn matches.call( el, \"*\" );\n+\t} );\n+\n+\t\/\/ Support: IE 9 - 11+, Edge 12 - 18+\n+\t\/\/ IE\/Edge don't support the :scope pseudo-class.\n+\tsupport.scope = assert( function() {\n+\t\treturn document.querySelectorAll( \":scope\" );\n+\t} );\n+\n+\t\/\/ Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only\n+\t\/\/ Make sure the `:has()` argument is parsed unforgivingly.\n+\t\/\/ We include `*` in the test to detect buggy implementations that are\n+\t\/\/ _selectively_ forgiving (specifically when the list includes at least\n+\t\/\/ one valid selector).\n+\t\/\/ Note that we treat complete lack of support for `:has()` as if it were\n+\t\/\/ spec-compliant support, which is fine because use of `:has()` in such\n+\t\/\/ environments will fail in the qSA path and fall back to jQuery traversal\n+\t\/\/ anyway.\n+\tsupport.cssHas = assert( function() {\n+\t\ttry {\n+\t\t\tdocument.querySelector( \":has(*,:jqfake)\" );\n+\t\t\treturn false;\n+\t\t} catch ( e ) {\n+\t\t\treturn true;\n+\t\t}\n+\t} );\n+\n+\t\/\/ ID filter and find\n+\tif ( support.getById ) {\n+\t\tExpr.filter.ID = function( id ) {\n+\t\t\tvar attrId = id.replace( runescape, funescape );\n+\t\t\treturn function( elem ) {\n+\t\t\t\treturn elem.getAttribute( \"id\" ) === attrId;\n+\t\t\t};\n+\t\t};\n+\t\tExpr.find.ID = function( id, context ) {\n+\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n+\t\t\t\tvar elem = context.getElementById( id );\n+\t\t\t\treturn elem ? [ elem ] : [];\n+\t\t\t}\n+\t\t};\n+\t} else {\n+\t\tExpr.filter.ID =  function( id ) {\n+\t\t\tvar attrId = id.replace( runescape, funescape );\n+\t\t\treturn function( elem ) {\n+\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n+\t\t\t\t\telem.getAttributeNode( \"id\" );\n+\t\t\t\treturn node && node.value === attrId;\n+\t\t\t};\n+\t\t};\n+\n+\t\t\/\/ Support: IE 6 - 7 only\n+\t\t\/\/ getElementById is not reliable as a find shortcut\n+\t\tExpr.find.ID = function( id, context ) {\n+\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n+\t\t\t\tvar node, i, elems,\n+\t\t\t\t\telem = context.getElementById( id );\n+\n+\t\t\t\tif ( elem ) {\n+\n+\t\t\t\t\t\/\/ Verify the id attribute\n+\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n+\t\t\t\t\tif ( node && node.value === id ) {\n+\t\t\t\t\t\treturn [ elem ];\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t\/\/ Fall back on getElementsByName\n+\t\t\t\t\telems = context.getElementsByName( id );\n+\t\t\t\t\ti = 0;\n+\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n+\t\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n+\t\t\t\t\t\tif ( node && node.value === id ) {\n+\t\t\t\t\t\t\treturn [ elem ];\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn [];\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t\/\/ Tag\n+\tExpr.find.TAG = function( tag, context ) {\n+\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n+\t\t\treturn context.getElementsByTagName( tag );\n+\n+\t\t\/\/ DocumentFragment nodes don't have gEBTN\n+\t\t} else {\n+\t\t\treturn context.querySelectorAll( tag );\n+\t\t}\n+\t};\n+\n+\t\/\/ Class\n+\tExpr.find.CLASS = function( className, context ) {\n+\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n+\t\t\treturn context.getElementsByClassName( className );\n+\t\t}\n+\t};\n+\n+\t\/* QSA\/matchesSelector\n+\t---------------------------------------------------------------------- *\/\n+\n+\t\/\/ QSA and matchesSelector support\n+\n+\trbuggyQSA = [];\n+\n+\t\/\/ Build QSA regex\n+\t\/\/ Regex strategy adopted from Diego Perini\n+\tassert( function( el ) {\n+\n+\t\tvar input;\n+\n+\t\tdocumentElement.appendChild( el ).innerHTML =\n+\t\t\t\"<a id='\" + expando + \"' href='' disabled='disabled'><\/a>\" +\n+\t\t\t\"<select id='\" + expando + \"-\\r\\\\' disabled='disabled'>\" +\n+\t\t\t\"<option selected=''><\/option><\/select>\";\n+\n+\t\t\/\/ Support: iOS <=7 - 8 only\n+\t\t\/\/ Boolean attributes and \"value\" are not treated correctly in some XML documents\n+\t\tif ( !el.querySelectorAll( \"[selected]\" ).length ) {\n+\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n+\t\t}\n+\n+\t\t\/\/ Support: iOS <=7 - 8 only\n+\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n+\t\t\trbuggyQSA.push( \"~=\" );\n+\t\t}\n+\n+\t\t\/\/ Support: iOS 8 only\n+\t\t\/\/ https:\/\/bugs.webkit.org\/show_bug.cgi?id=136851\n+\t\t\/\/ In-page `selector#id sibling-combinator selector` fails\n+\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n+\t\t\trbuggyQSA.push( \".#.+[+~]\" );\n+\t\t}\n+\n+\t\t\/\/ Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+\n+\t\t\/\/ In some of the document kinds, these selectors wouldn't work natively.\n+\t\t\/\/ This is probably OK but for backwards compatibility we want to maintain\n+\t\t\/\/ handling them through jQuery traversal in jQuery 3.x.\n+\t\tif ( !el.querySelectorAll( \":checked\" ).length ) {\n+\t\t\trbuggyQSA.push( \":checked\" );\n+\t\t}\n+\n+\t\t\/\/ Support: Windows 8 Native Apps\n+\t\t\/\/ The type and name attributes are restricted during .innerHTML assignment\n+\t\tinput = document.createElement( \"input\" );\n+\t\tinput.setAttribute( \"type\", \"hidden\" );\n+\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n+\n+\t\t\/\/ Support: IE 9 - 11+\n+\t\t\/\/ IE's :disabled selector does not pick up the children of disabled fieldsets\n+\t\t\/\/ Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+\n+\t\t\/\/ In some of the document kinds, these selectors wouldn't work natively.\n+\t\t\/\/ This is probably OK but for backwards compatibility we want to maintain\n+\t\t\/\/ handling them through jQuery traversal in jQuery 3.x.\n+\t\tdocumentElement.appendChild( el ).disabled = true;\n+\t\tif ( el.querySelectorAll( \":disabled\" ).length !== 2 ) {\n+\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n+\t\t}\n+\n+\t\t\/\/ Support: IE 11+, Edge 15 - 18+\n+\t\t\/\/ IE 11\/Edge don't find elements on a `[name='']` query in some cases.\n+\t\t\/\/ Adding a temporary attribute to the document before the selection works\n+\t\t\/\/ around the issue.\n+\t\t\/\/ Interestingly, IE 10 & older don't seem to have the issue.\n+\t\tinput = document.createElement( \"input\" );\n+\t\tinput.setAttribute( \"name\", \"\" );\n+\t\tel.appendChild( input );\n+\t\tif ( !el.querySelectorAll( \"[name='']\" ).length ) {\n+\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" +\n+\t\t\t\twhitespace + \"*(?:''|\\\"\\\")\" );\n+\t\t}\n+\t} );\n+\n+\tif ( !support.cssHas ) {\n+\n+\t\t\/\/ Support: Chrome 105 - 110+, Safari 15.4 - 16.3+\n+\t\t\/\/ Our regular `try-catch` mechanism fails to detect natively-unsupported\n+\t\t\/\/ pseudo-classes inside `:has()` (such as `:has(:contains(\"Foo\"))`)\n+\t\t\/\/ in browsers that parse the `:has()` argument as a forgiving selector list.\n+\t\t\/\/ https:\/\/drafts.csswg.org\/selectors\/#relational now requires the argument\n+\t\t\/\/ to be parsed unforgivingly, but browsers have not yet fully adjusted.\n+\t\trbuggyQSA.push( \":has\" );\n+\t}\n+\n+\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \"|\" ) );\n+\n+\t\/* Sorting\n+\t---------------------------------------------------------------------- *\/\n+\n+\t\/\/ Document order sorting\n+\tsortOrder = function( a, b ) {\n+\n+\t\t\/\/ Flag for duplicate removal\n+\t\tif ( a === b ) {\n+\t\t\thasDuplicate = true;\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\t\/\/ Sort on method existence if only one input has compareDocumentPosition\n+\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n+\t\tif ( compare ) {\n+\t\t\treturn compare;\n+\t\t}\n+\n+\t\t\/\/ Calculate position if both inputs belong to the same document\n+\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\/\/ two documents; shallow comparisons work.\n+\t\t\/\/ eslint-disable-next-line eqeqeq\n+\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n+\t\t\ta.compareDocumentPosition( b ) :\n+\n+\t\t\t\/\/ Otherwise we know they are disconnected\n+\t\t\t1;\n+\n+\t\t\/\/ Disconnected nodes\n+\t\tif ( compare & 1 ||\n+\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n+\n+\t\t\t\/\/ Choose the first element that is related to our preferred document\n+\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t\/\/ two documents; shallow comparisons work.\n+\t\t\t\/\/ eslint-disable-next-line eqeqeq\n+\t\t\tif ( a === document || a.ownerDocument == preferredDoc &&\n+\t\t\t\tfind.contains( preferredDoc, a ) ) {\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\n+\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t\/\/ two documents; shallow comparisons work.\n+\t\t\t\/\/ eslint-disable-next-line eqeqeq\n+\t\t\tif ( b === document || b.ownerDocument == preferredDoc &&\n+\t\t\t\tfind.contains( preferredDoc, b ) ) {\n+\t\t\t\treturn 1;\n+\t\t\t}\n+\n+\t\t\t\/\/ Maintain original order\n+\t\t\treturn sortInput ?\n+\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n+\t\t\t\t0;\n+\t\t}\n+\n+\t\treturn compare & 4 ? -1 : 1;\n+\t};\n+\n+\treturn document;\n+}\n+\n+find.matches = function( expr, elements ) {\n+\treturn find( expr, null, null, elements );\n+};\n+\n+find.matchesSelector = function( elem, expr ) {\n+\tsetDocument( elem );\n+\n+\tif ( documentIsHTML &&\n+\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n+\t\t( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {\n+\n+\t\ttry {\n+\t\t\tvar ret = matches.call( elem, expr );\n+\n+\t\t\t\/\/ IE 9's matchesSelector returns false on disconnected nodes\n+\t\t\tif ( ret || support.disconnectedMatch ||\n+\n+\t\t\t\t\t\/\/ As well, disconnected nodes are said to be in a document\n+\t\t\t\t\t\/\/ fragment in IE 9\n+\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\t\t} catch ( e ) {\n+\t\t\tnonnativeSelectorCache( expr, true );\n+\t\t}\n+\t}\n+\n+\treturn find( expr, document, null, [ elem ] ).length > 0;\n+};\n+\n+find.contains = function( context, elem ) {\n+\n+\t\/\/ Set document vars if needed\n+\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\/\/ two documents; shallow comparisons work.\n+\t\/\/ eslint-disable-next-line eqeqeq\n+\tif ( ( context.ownerDocument || context ) != document ) {\n+\t\tsetDocument( context );\n+\t}\n+\treturn jQuery.contains( context, elem );\n+};\n+\n+\n+find.attr = function( elem, name ) {\n+\n+\t\/\/ Set document vars if needed\n+\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\/\/ two documents; shallow comparisons work.\n+\t\/\/ eslint-disable-next-line eqeqeq\n+\tif ( ( elem.ownerDocument || elem ) != document ) {\n+\t\tsetDocument( elem );\n+\t}\n+\n+\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n+\n+\t\t\/\/ Don't get fooled by Object.prototype properties (see trac-13807)\n+\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n+\t\t\tfn( elem, name, !documentIsHTML ) :\n+\t\t\tundefined;\n+\n+\tif ( val !== undefined ) {\n+\t\treturn val;\n+\t}\n+\n+\treturn elem.getAttribute( name );\n+};\n+\n+find.error = function( msg ) {\n+\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n+};\n+\n+\/**\n+ * Document sorting and removing duplicates\n+ * @param {ArrayLike} results\n+ *\/\n+jQuery.uniqueSort = function( results ) {\n+\tvar elem,\n+\t\tduplicates = [],\n+\t\tj = 0,\n+\t\ti = 0;\n+\n+\t\/\/ Unless we *know* we can detect duplicates, assume their presence\n+\t\/\/\n+\t\/\/ Support: Android <=4.0+\n+\t\/\/ Testing for detecting duplicates is unpredictable so instead assume we can't\n+\t\/\/ depend on duplicate detection in all browsers without a stable sort.\n+\thasDuplicate = !support.sortStable;\n+\tsortInput = !support.sortStable && slice.call( results, 0 );\n+\tsort.call( results, sortOrder );\n+\n+\tif ( hasDuplicate ) {\n+\t\twhile ( ( elem = results[ i++ ] ) ) {\n+\t\t\tif ( elem === results[ i ] ) {\n+\t\t\t\tj = duplicates.push( i );\n+\t\t\t}\n+\t\t}\n+\t\twhile ( j-- ) {\n+\t\t\tsplice.call( results, duplicates[ j ], 1 );\n+\t\t}\n+\t}\n+\n+\t\/\/ Clear input after sorting to release objects\n+\t\/\/ See https:\/\/github.com\/jquery\/sizzle\/pull\/225\n+\tsortInput = null;\n+\n+\treturn results;\n+};\n+\n+jQuery.fn.uniqueSort = function() {\n+\treturn this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );\n+};\n+\n+Expr = jQuery.expr = {\n+\n+\t\/\/ Can be adjusted by the user\n+\tcacheLength: 50,\n+\n+\tcreatePseudo: markFunction,\n+\n+\tmatch: matchExpr,\n+\n+\tattrHandle: {},\n+\n+\tfind: {},\n+\n+\trelative: {\n+\t\t\">\": { dir: \"parentNode\", first: true },\n+\t\t\" \": { dir: \"parentNode\" },\n+\t\t\"+\": { dir: \"previousSibling\", first: true },\n+\t\t\"~\": { dir: \"previousSibling\" }\n+\t},\n+\n+\tpreFilter: {\n+\t\tATTR: function( match ) {\n+\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n+\n+\t\t\t\/\/ Move the given value to match[3] whether quoted or unquoted\n+\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || \"\" )\n+\t\t\t\t.replace( runescape, funescape );\n+\n+\t\t\tif ( match[ 2 ] === \"~=\" ) {\n+\t\t\t\tmatch[ 3 ] = \" \" + match[ 3 ] + \" \";\n+\t\t\t}\n+\n+\t\t\treturn match.slice( 0, 4 );\n+\t\t},\n+\n+\t\tCHILD: function( match ) {\n+\n+\t\t\t\/* matches from matchExpr[\"CHILD\"]\n+\t\t\t\t1 type (only|nth|...)\n+\t\t\t\t2 what (child|of-type)\n+\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n+\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n+\t\t\t\t5 sign of xn-component\n+\t\t\t\t6 x of xn-component\n+\t\t\t\t7 sign of y-component\n+\t\t\t\t8 y of y-component\n+\t\t\t*\/\n+\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n+\n+\t\t\tif ( match[ 1 ].slice( 0, 3 ) === \"nth\" ) {\n+\n+\t\t\t\t\/\/ nth-* requires argument\n+\t\t\t\tif ( !match[ 3 ] ) {\n+\t\t\t\t\tfind.error( match[ 0 ] );\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ numeric x and y parameters for Expr.filter.CHILD\n+\t\t\t\t\/\/ remember that false\/true cast respectively to 0\/1\n+\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n+\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n+\t\t\t\t\t2 * ( match[ 3 ] === \"even\" || match[ 3 ] === \"odd\" )\n+\t\t\t\t);\n+\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \"odd\" );\n+\n+\t\t\t\/\/ other types prohibit arguments\n+\t\t\t} else if ( match[ 3 ] ) {\n+\t\t\t\tfind.error( match[ 0 ] );\n+\t\t\t}\n+\n+\t\t\treturn match;\n+\t\t},\n+\n+\t\tPSEUDO: function( match ) {\n+\t\t\tvar excess,\n+\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n+\n+\t\t\tif ( matchExpr.CHILD.test( match[ 0 ] ) ) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\t\/\/ Accept quoted arguments as-is\n+\t\t\tif ( match[ 3 ] ) {\n+\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \"\";\n+\n+\t\t\t\/\/ Strip excess characters from unquoted arguments\n+\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n+\n+\t\t\t\t\/\/ Get excess from tokenize (recursively)\n+\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n+\n+\t\t\t\t\/\/ advance to the next closing parenthesis\n+\t\t\t\t( excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length ) ) {\n+\n+\t\t\t\t\/\/ excess is a negative index\n+\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n+\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n+\t\t\t}\n+\n+\t\t\t\/\/ Return only captures needed by the pseudo filter method (type and argument)\n+\t\t\treturn match.slice( 0, 3 );\n+\t\t}\n+\t},\n+\n+\tfilter: {\n+\n+\t\tTAG: function( nodeNameSelector ) {\n+\t\t\tvar expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n+\t\t\treturn nodeNameSelector === \"*\" ?\n+\t\t\t\tfunction() {\n+\t\t\t\t\treturn true;\n+\t\t\t\t} :\n+\t\t\t\tfunction( elem ) {\n+\t\t\t\t\treturn nodeName( elem, expectedNodeName );\n+\t\t\t\t};\n+\t\t},\n+\n+\t\tCLASS: function( className ) {\n+\t\t\tvar pattern = classCache[ className + \" \" ];\n+\n+\t\t\treturn pattern ||\n+\t\t\t\t( pattern = new RegExp( \"(^|\" + whitespace + \")\" + className +\n+\t\t\t\t\t\"(\" + whitespace + \"|$)\" ) ) &&\n+\t\t\t\tclassCache( className, function( elem ) {\n+\t\t\t\t\treturn pattern.test(\n+\t\t\t\t\t\ttypeof elem.className === \"string\" && elem.className ||\n+\t\t\t\t\t\t\ttypeof elem.getAttribute !== \"undefined\" &&\n+\t\t\t\t\t\t\t\telem.getAttribute( \"class\" ) ||\n+\t\t\t\t\t\t\t\"\"\n+\t\t\t\t\t);\n+\t\t\t\t} );\n+\t\t},\n+\n+\t\tATTR: function( name, operator, check ) {\n+\t\t\treturn function( elem ) {\n+\t\t\t\tvar result = find.attr( elem, name );\n+\n+\t\t\t\tif ( result == null ) {\n+\t\t\t\t\treturn operator === \"!=\";\n+\t\t\t\t}\n+\t\t\t\tif ( !operator ) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\n+\t\t\t\tresult += \"\";\n+\n+\t\t\t\tif ( operator === \"=\" ) {\n+\t\t\t\t\treturn result === check;\n+\t\t\t\t}\n+\t\t\t\tif ( operator === \"!=\" ) {\n+\t\t\t\t\treturn result !== check;\n+\t\t\t\t}\n+\t\t\t\tif ( operator === \"^=\" ) {\n+\t\t\t\t\treturn check && result.indexOf( check ) === 0;\n+\t\t\t\t}\n+\t\t\t\tif ( operator === \"*=\" ) {\n+\t\t\t\t\treturn check && result.indexOf( check ) > -1;\n+\t\t\t\t}\n+\t\t\t\tif ( operator === \"$=\" ) {\n+\t\t\t\t\treturn check && result.slice( -check.length ) === check;\n+\t\t\t\t}\n+\t\t\t\tif ( operator === \"~=\" ) {\n+\t\t\t\t\treturn ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" )\n+\t\t\t\t\t\t.indexOf( check ) > -1;\n+\t\t\t\t}\n+\t\t\t\tif ( operator === \"|=\" ) {\n+\t\t\t\t\treturn result === check || result.slice( 0, check.length + 1 ) === check + \"-\";\n+\t\t\t\t}\n+\n+\t\t\t\treturn false;\n+\t\t\t};\n+\t\t},\n+\n+\t\tCHILD: function( type, what, _argument, first, last ) {\n+\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n+\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n+\t\t\t\tofType = what === \"of-type\";\n+\n+\t\t\treturn first === 1 && last === 0 ?\n+\n+\t\t\t\t\/\/ Shortcut for :nth-*(n)\n+\t\t\t\tfunction( elem ) {\n+\t\t\t\t\treturn !!elem.parentNode;\n+\t\t\t\t} :\n+\n+\t\t\t\tfunction( elem, _context, xml ) {\n+\t\t\t\t\tvar cache, outerCache, node, nodeIndex, start,\n+\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n+\t\t\t\t\t\tparent = elem.parentNode,\n+\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n+\t\t\t\t\t\tuseCache = !xml && !ofType,\n+\t\t\t\t\t\tdiff = false;\n+\n+\t\t\t\t\tif ( parent ) {\n+\n+\t\t\t\t\t\t\/\/ :(first|last|only)-(child|of-type)\n+\t\t\t\t\t\tif ( simple ) {\n+\t\t\t\t\t\t\twhile ( dir ) {\n+\t\t\t\t\t\t\t\tnode = elem;\n+\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n+\t\t\t\t\t\t\t\t\tif ( ofType ?\n+\t\t\t\t\t\t\t\t\t\tnodeName( node, name ) :\n+\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n+\n+\t\t\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\/\/ Reverse direction for :only-* (if we haven't yet done so)\n+\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n+\n+\t\t\t\t\t\t\/\/ non-xml :nth-child(...) stores cache data on `parent`\n+\t\t\t\t\t\tif ( forward && useCache ) {\n+\n+\t\t\t\t\t\t\t\/\/ Seek `elem` from a previously-cached index\n+\t\t\t\t\t\t\touterCache = parent[ expando ] || ( parent[ expando ] = {} );\n+\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n+\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n+\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n+\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n+\n+\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n+\n+\t\t\t\t\t\t\t\t\/\/ Fallback to seeking `elem` from the start\n+\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n+\n+\t\t\t\t\t\t\t\t\/\/ When found, cache indexes on `parent` and break\n+\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n+\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t\/\/ Use previously-cached element index if available\n+\t\t\t\t\t\t\tif ( useCache ) {\n+\t\t\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n+\t\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n+\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n+\t\t\t\t\t\t\t\tdiff = nodeIndex;\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\/\/ xml :nth-child(...)\n+\t\t\t\t\t\t\t\/\/ or :nth-last-child(...) or :nth(-last)?-of-type(...)\n+\t\t\t\t\t\t\tif ( diff === false ) {\n+\n+\t\t\t\t\t\t\t\t\/\/ Use the same loop as above to seek `elem` from the start\n+\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n+\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n+\n+\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n+\t\t\t\t\t\t\t\t\t\tnodeName( node, name ) :\n+\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n+\t\t\t\t\t\t\t\t\t\t++diff ) {\n+\n+\t\t\t\t\t\t\t\t\t\t\/\/ Cache the index of each encountered element\n+\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n+\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n+\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n+\t\t\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, diff ];\n+\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n+\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\/\/ Incorporate the offset, then check against cycle size\n+\t\t\t\t\t\tdiff -= last;\n+\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff \/ first >= 0 );\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\t\t},\n+\n+\t\tPSEUDO: function( pseudo, argument ) {\n+\n+\t\t\t\/\/ pseudo-class names are case-insensitive\n+\t\t\t\/\/ https:\/\/www.w3.org\/TR\/selectors\/#pseudo-classes\n+\t\t\t\/\/ Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n+\t\t\t\/\/ Remember that setFilters inherits from pseudos\n+\t\t\tvar args,\n+\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n+\t\t\t\t\tfind.error( \"unsupported pseudo: \" + pseudo );\n+\n+\t\t\t\/\/ The user may use createPseudo to indicate that\n+\t\t\t\/\/ arguments are needed to create the filter function\n+\t\t\t\/\/ just as jQuery does\n+\t\t\tif ( fn[ expando ] ) {\n+\t\t\t\treturn fn( argument );\n+\t\t\t}\n+\n+\t\t\t\/\/ But maintain support for old signatures\n+\t\t\tif ( fn.length > 1 ) {\n+\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n+\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n+\t\t\t\t\tmarkFunction( function( seed, matches ) {\n+\t\t\t\t\t\tvar idx,\n+\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n+\t\t\t\t\t\t\ti = matched.length;\n+\t\t\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[ i ] );\n+\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} ) :\n+\t\t\t\t\tfunction( elem ) {\n+\t\t\t\t\t\treturn fn( elem, 0, args );\n+\t\t\t\t\t};\n+\t\t\t}\n+\n+\t\t\treturn fn;\n+\t\t}\n+\t},\n+\n+\tpseudos: {\n+\n+\t\t\/\/ Potentially complex pseudos\n+\t\tnot: markFunction( function( selector ) {\n+\n+\t\t\t\/\/ Trim the selector passed to compile\n+\t\t\t\/\/ to avoid treating leading and trailing\n+\t\t\t\/\/ spaces as combinators\n+\t\t\tvar input = [],\n+\t\t\t\tresults = [],\n+\t\t\t\tmatcher = compile( selector.replace( rtrimCSS, \"$1\" ) );\n+\n+\t\t\treturn matcher[ expando ] ?\n+\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n+\t\t\t\t\tvar elem,\n+\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n+\t\t\t\t\t\ti = seed.length;\n+\n+\t\t\t\t\t\/\/ Match elements unmatched by `matcher`\n+\t\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n+\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} ) :\n+\t\t\t\tfunction( elem, _context, xml ) {\n+\t\t\t\t\tinput[ 0 ] = elem;\n+\t\t\t\t\tmatcher( input, null, xml, results );\n+\n+\t\t\t\t\t\/\/ Don't keep the element\n+\t\t\t\t\t\/\/ (see https:\/\/github.com\/jquery\/sizzle\/issues\/299)\n+\t\t\t\t\tinput[ 0 ] = null;\n+\t\t\t\t\treturn !results.pop();\n+\t\t\t\t};\n+\t\t} ),\n+\n+\t\thas: markFunction( function( selector ) {\n+\t\t\treturn function( elem ) {\n+\t\t\t\treturn find( selector, elem ).length > 0;\n+\t\t\t};\n+\t\t} ),\n+\n+\t\tcontains: markFunction( function( text ) {\n+\t\t\ttext = text.replace( runescape, funescape );\n+\t\t\treturn function( elem ) {\n+\t\t\t\treturn ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;\n+\t\t\t};\n+\t\t} ),\n+\n+\t\t\/\/ \"Whether an element is represented by a :lang() selector\n+\t\t\/\/ is based solely on the element's language value\n+\t\t\/\/ being equal to the identifier C,\n+\t\t\/\/ or beginning with the identifier C immediately followed by \"-\".\n+\t\t\/\/ The matching of C against the element's language value is performed case-insensitively.\n+\t\t\/\/ The identifier C does not have to be a valid language name.\"\n+\t\t\/\/ https:\/\/www.w3.org\/TR\/selectors\/#lang-pseudo\n+\t\tlang: markFunction( function( lang ) {\n+\n+\t\t\t\/\/ lang value must be a valid identifier\n+\t\t\tif ( !ridentifier.test( lang || \"\" ) ) {\n+\t\t\t\tfind.error( \"unsupported lang: \" + lang );\n+\t\t\t}\n+\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n+\t\t\treturn function( elem ) {\n+\t\t\t\tvar elemLang;\n+\t\t\t\tdo {\n+\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n+\t\t\t\t\t\telem.lang :\n+\t\t\t\t\t\telem.getAttribute( \"xml:lang\" ) || elem.getAttribute( \"lang\" ) ) ) {\n+\n+\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n+\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n+\t\t\t\t\t}\n+\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n+\t\t\t\treturn false;\n+\t\t\t};\n+\t\t} ),\n+\n+\t\t\/\/ Miscellaneous\n+\t\ttarget: function( elem ) {\n+\t\t\tvar hash = window.location && window.location.hash;\n+\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n+\t\t},\n+\n+\t\troot: function( elem ) {\n+\t\t\treturn elem === documentElement;\n+\t\t},\n+\n+\t\tfocus: function( elem ) {\n+\t\t\treturn elem === safeActiveElement() &&\n+\t\t\t\tdocument.hasFocus() &&\n+\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n+\t\t},\n+\n+\t\t\/\/ Boolean properties\n+\t\tenabled: createDisabledPseudo( false ),\n+\t\tdisabled: createDisabledPseudo( true ),\n+\n+\t\tchecked: function( elem ) {\n+\n+\t\t\t\/\/ In CSS3, :checked should return both checked and selected elements\n+\t\t\t\/\/ https:\/\/www.w3.org\/TR\/2011\/REC-css3-selectors-20110929\/#checked\n+\t\t\treturn ( nodeName( elem, \"input\" ) && !!elem.checked ) ||\n+\t\t\t\t( nodeName( elem, \"option\" ) && !!elem.selected );\n+\t\t},\n+\n+\t\tselected: function( elem ) {\n+\n+\t\t\t\/\/ Support: IE <=11+\n+\t\t\t\/\/ Accessing the selectedIndex property\n+\t\t\t\/\/ forces the browser to treat the default option as\n+\t\t\t\/\/ selected when in an optgroup.\n+\t\t\tif ( elem.parentNode ) {\n+\t\t\t\t\/\/ eslint-disable-next-line no-unused-expressions\n+\t\t\t\telem.parentNode.selectedIndex;\n+\t\t\t}\n+\n+\t\t\treturn elem.selected === true;\n+\t\t},\n+\n+\t\t\/\/ Contents\n+\t\tempty: function( elem ) {\n+\n+\t\t\t\/\/ https:\/\/www.w3.org\/TR\/selectors\/#empty-pseudo\n+\t\t\t\/\/ :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n+\t\t\t\/\/   but not by others (comment: 8; processing instruction: 7; etc.)\n+\t\t\t\/\/ nodeType < 6 works because attributes (2) do not appear as children\n+\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n+\t\t\t\tif ( elem.nodeType < 6 ) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t},\n+\n+\t\tparent: function( elem ) {\n+\t\t\treturn !Expr.pseudos.empty( elem );\n+\t\t},\n+\n+\t\t\/\/ Element\/input types\n+\t\theader: function( elem ) {\n+\t\t\treturn rheader.test( elem.nodeName );\n+\t\t},\n+\n+\t\tinput: function( elem ) {\n+\t\t\treturn rinputs.test( elem.nodeName );\n+\t\t},\n+\n+\t\tbutton: function( elem ) {\n+\t\t\treturn nodeName( elem, \"input\" ) && elem.type === \"button\" ||\n+\t\t\t\tnodeName( elem, \"button\" );\n+\t\t},\n+\n+\t\ttext: function( elem ) {\n+\t\t\tvar attr;\n+\t\t\treturn nodeName( elem, \"input\" ) && elem.type === \"text\" &&\n+\n+\t\t\t\t\/\/ Support: IE <10 only\n+\t\t\t\t\/\/ New HTML5 attribute values (e.g., \"search\") appear\n+\t\t\t\t\/\/ with elem.type === \"text\"\n+\t\t\t\t( ( attr = elem.getAttribute( \"type\" ) ) == null ||\n+\t\t\t\t\tattr.toLowerCase() === \"text\" );\n+\t\t},\n+\n+\t\t\/\/ Position-in-collection\n+\t\tfirst: createPositionalPseudo( function() {\n+\t\t\treturn [ 0 ];\n+\t\t} ),\n+\n+\t\tlast: createPositionalPseudo( function( _matchIndexes, length ) {\n+\t\t\treturn [ length - 1 ];\n+\t\t} ),\n+\n+\t\teq: createPositionalPseudo( function( _matchIndexes, length, argument ) {\n+\t\t\treturn [ argument < 0 ? argument + length : argument ];\n+\t\t} ),\n+\n+\t\teven: createPositionalPseudo( function( matchIndexes, length ) {\n+\t\t\tvar i = 0;\n+\t\t\tfor ( ; i < length; i += 2 ) {\n+\t\t\t\tmatchIndexes.push( i );\n+\t\t\t}\n+\t\t\treturn matchIndexes;\n+\t\t} ),\n+\n+\t\todd: createPositionalPseudo( function( matchIndexes, length ) {\n+\t\t\tvar i = 1;\n+\t\t\tfor ( ; i < length; i += 2 ) {\n+\t\t\t\tmatchIndexes.push( i );\n+\t\t\t}\n+\t\t\treturn matchIndexes;\n+\t\t} ),\n+\n+\t\tlt: createPositionalPseudo( function( matchIndexes, length, argument ) {\n+\t\t\tvar i;\n+\n+\t\t\tif ( argument < 0 ) {\n+\t\t\t\ti = argument + length;\n+\t\t\t} else if ( argument > length ) {\n+\t\t\t\ti = length;\n+\t\t\t} else {\n+\t\t\t\ti = argument;\n+\t\t\t}\n+\n+\t\t\tfor ( ; --i >= 0; ) {\n+\t\t\t\tmatchIndexes.push( i );\n+\t\t\t}\n+\t\t\treturn matchIndexes;\n+\t\t} ),\n+\n+\t\tgt: createPositionalPseudo( function( matchIndexes, length, argument ) {\n+\t\t\tvar i = argument < 0 ? argument + length : argument;\n+\t\t\tfor ( ; ++i < length; ) {\n+\t\t\t\tmatchIndexes.push( i );\n+\t\t\t}\n+\t\t\treturn matchIndexes;\n+\t\t} )\n+\t}\n+};\n+\n+Expr.pseudos.nth = Expr.pseudos.eq;\n+\n+\/\/ Add button\/input type pseudos\n+for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n+\tExpr.pseudos[ i ] = createInputPseudo( i );\n+}\n+for ( i in { submit: true, reset: true } ) {\n+\tExpr.pseudos[ i ] = createButtonPseudo( i );\n+}\n+\n+\/\/ Easy API for creating new setFilters\n+function setFilters() {}\n+setFilters.prototype = Expr.filters = Expr.pseudos;\n+Expr.setFilters = new setFilters();\n+\n+function tokenize( selector, parseOnly ) {\n+\tvar matched, match, tokens, type,\n+\t\tsoFar, groups, preFilters,\n+\t\tcached = tokenCache[ selector + \" \" ];\n+\n+\tif ( cached ) {\n+\t\treturn parseOnly ? 0 : cached.slice( 0 );\n+\t}\n+\n+\tsoFar = selector;\n+\tgroups = [];\n+\tpreFilters = Expr.preFilter;\n+\n+\twhile ( soFar ) {\n+\n+\t\t\/\/ Comma and first run\n+\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n+\t\t\tif ( match ) {\n+\n+\t\t\t\t\/\/ Don't consume trailing commas as valid\n+\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n+\t\t\t}\n+\t\t\tgroups.push( ( tokens = [] ) );\n+\t\t}\n+\n+\t\tmatched = false;\n+\n+\t\t\/\/ Combinators\n+\t\tif ( ( match = rleadingCombinator.exec( soFar ) ) ) {\n+\t\t\tmatched = match.shift();\n+\t\t\ttokens.push( {\n+\t\t\t\tvalue: matched,\n+\n+\t\t\t\t\/\/ Cast descendant combinators to space\n+\t\t\t\ttype: match[ 0 ].replace( rtrimCSS, \" \" )\n+\t\t\t} );\n+\t\t\tsoFar = soFar.slice( matched.length );\n+\t\t}\n+\n+\t\t\/\/ Filters\n+\t\tfor ( type in Expr.filter ) {\n+\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n+\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n+\t\t\t\tmatched = match.shift();\n+\t\t\t\ttokens.push( {\n+\t\t\t\t\tvalue: matched,\n+\t\t\t\t\ttype: type,\n+\t\t\t\t\tmatches: match\n+\t\t\t\t} );\n+\t\t\t\tsoFar = soFar.slice( matched.length );\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ( !matched ) {\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\t\/\/ Return the length of the invalid excess\n+\t\/\/ if we're just parsing\n+\t\/\/ Otherwise, throw an error or return tokens\n+\tif ( parseOnly ) {\n+\t\treturn soFar.length;\n+\t}\n+\n+\treturn soFar ?\n+\t\tfind.error( selector ) :\n+\n+\t\t\/\/ Cache the tokens\n+\t\ttokenCache( selector, groups ).slice( 0 );\n+}\n+\n+function toSelector( tokens ) {\n+\tvar i = 0,\n+\t\tlen = tokens.length,\n+\t\tselector = \"\";\n+\tfor ( ; i < len; i++ ) {\n+\t\tselector += tokens[ i ].value;\n+\t}\n+\treturn selector;\n+}\n+\n+function addCombinator( matcher, combinator, base ) {\n+\tvar dir = combinator.dir,\n+\t\tskip = combinator.next,\n+\t\tkey = skip || dir,\n+\t\tcheckNonElements = base && key === \"parentNode\",\n+\t\tdoneName = done++;\n+\n+\treturn combinator.first ?\n+\n+\t\t\/\/ Check against closest ancestor\/preceding element\n+\t\tfunction( elem, context, xml ) {\n+\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n+\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n+\t\t\t\t\treturn matcher( elem, context, xml );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t} :\n+\n+\t\t\/\/ Check against all ancestor\/preceding elements\n+\t\tfunction( elem, context, xml ) {\n+\t\t\tvar oldCache, outerCache,\n+\t\t\t\tnewCache = [ dirruns, doneName ];\n+\n+\t\t\t\/\/ We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n+\t\t\tif ( xml ) {\n+\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n+\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n+\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n+\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n+\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n+\n+\t\t\t\t\t\tif ( skip && nodeName( elem, skip ) ) {\n+\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n+\t\t\t\t\t\t} else if ( ( oldCache = outerCache[ key ] ) &&\n+\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n+\n+\t\t\t\t\t\t\t\/\/ Assign to newCache so results back-propagate to previous elements\n+\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n+\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t\/\/ Reuse newcache so results back-propagate to previous elements\n+\t\t\t\t\t\t\touterCache[ key ] = newCache;\n+\n+\t\t\t\t\t\t\t\/\/ A match means we're done; a fail means we have to keep checking\n+\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n+\t\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t};\n+}\n+\n+function elementMatcher( matchers ) {\n+\treturn matchers.length > 1 ?\n+\t\tfunction( elem, context, xml ) {\n+\t\t\tvar i = matchers.length;\n+\t\t\twhile ( i-- ) {\n+\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t} :\n+\t\tmatchers[ 0 ];\n+}\n+\n+function multipleContexts( selector, contexts, results ) {\n+\tvar i = 0,\n+\t\tlen = contexts.length;\n+\tfor ( ; i < len; i++ ) {\n+\t\tfind( selector, contexts[ i ], results );\n+\t}\n+\treturn results;\n+}\n+\n+function condense( unmatched, map, filter, context, xml ) {\n+\tvar elem,\n+\t\tnewUnmatched = [],\n+\t\ti = 0,\n+\t\tlen = unmatched.length,\n+\t\tmapped = map != null;\n+\n+\tfor ( ; i < len; i++ ) {\n+\t\tif ( ( elem = unmatched[ i ] ) ) {\n+\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n+\t\t\t\tnewUnmatched.push( elem );\n+\t\t\t\tif ( mapped ) {\n+\t\t\t\t\tmap.push( i );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newUnmatched;\n+}\n+\n+function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n+\tif ( postFilter && !postFilter[ expando ] ) {\n+\t\tpostFilter = setMatcher( postFilter );\n+\t}\n+\tif ( postFinder && !postFinder[ expando ] ) {\n+\t\tpostFinder = setMatcher( postFinder, postSelector );\n+\t}\n+\treturn markFunction( function( seed, results, context, xml ) {\n+\t\tvar temp, i, elem, matcherOut,\n+\t\t\tpreMap = [],\n+\t\t\tpostMap = [],\n+\t\t\tpreexisting = results.length,\n+\n+\t\t\t\/\/ Get initial elements from seed or context\n+\t\t\telems = seed ||\n+\t\t\t\tmultipleContexts( selector || \"*\",\n+\t\t\t\t\tcontext.nodeType ? [ context ] : context, [] ),\n+\n+\t\t\t\/\/ Prefilter to get matcher input, preserving a map for seed-results synchronization\n+\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n+\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n+\t\t\t\telems;\n+\n+\t\tif ( matcher ) {\n+\n+\t\t\t\/\/ If we have a postFinder, or filtered seed, or non-seed postFilter\n+\t\t\t\/\/ or preexisting results,\n+\t\t\tmatcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n+\n+\t\t\t\t\/\/ ...intermediate processing is necessary\n+\t\t\t\t[] :\n+\n+\t\t\t\t\/\/ ...otherwise use results directly\n+\t\t\t\tresults;\n+\n+\t\t\t\/\/ Find primary matches\n+\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n+\t\t} else {\n+\t\t\tmatcherOut = matcherIn;\n+\t\t}\n+\n+\t\t\/\/ Apply postFilter\n+\t\tif ( postFilter ) {\n+\t\t\ttemp = condense( matcherOut, postMap );\n+\t\t\tpostFilter( temp, [], context, xml );\n+\n+\t\t\t\/\/ Un-match failing elements by moving them back to matcherIn\n+\t\t\ti = temp.length;\n+\t\t\twhile ( i-- ) {\n+\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n+\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ( seed ) {\n+\t\t\tif ( postFinder || preFilter ) {\n+\t\t\t\tif ( postFinder ) {\n+\n+\t\t\t\t\t\/\/ Get the final matcherOut by condensing this intermediate into postFinder contexts\n+\t\t\t\t\ttemp = [];\n+\t\t\t\t\ti = matcherOut.length;\n+\t\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n+\n+\t\t\t\t\t\t\t\/\/ Restore matcherIn since elem is not yet a final match\n+\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Move matched elements from seed to results to keep them synchronized\n+\t\t\t\ti = matcherOut.length;\n+\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n+\t\t\t\t\t\t( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {\n+\n+\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\/\/ Add elements to results, through postFinder if defined\n+\t\t} else {\n+\t\t\tmatcherOut = condense(\n+\t\t\t\tmatcherOut === results ?\n+\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n+\t\t\t\t\tmatcherOut\n+\t\t\t);\n+\t\t\tif ( postFinder ) {\n+\t\t\t\tpostFinder( null, results, matcherOut, xml );\n+\t\t\t} else {\n+\t\t\t\tpush.apply( results, matcherOut );\n+\t\t\t}\n+\t\t}\n+\t} );\n+}\n+\n+function matcherFromTokens( tokens ) {\n+\tvar checkContext, matcher, j,\n+\t\tlen = tokens.length,\n+\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n+\t\timplicitRelative = leadingRelative || Expr.relative[ \" \" ],\n+\t\ti = leadingRelative ? 1 : 0,\n+\n+\t\t\/\/ The foundational matcher ensures that elements are reachable from top-level context(s)\n+\t\tmatchContext = addCombinator( function( elem ) {\n+\t\t\treturn elem === checkContext;\n+\t\t}, implicitRelative, true ),\n+\t\tmatchAnyContext = addCombinator( function( elem ) {\n+\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n+\t\t}, implicitRelative, true ),\n+\t\tmatchers = [ function( elem, context, xml ) {\n+\n+\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t\/\/ two documents; shallow comparisons work.\n+\t\t\t\/\/ eslint-disable-next-line eqeqeq\n+\t\t\tvar ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (\n+\t\t\t\t( checkContext = context ).nodeType ?\n+\t\t\t\t\tmatchContext( elem, context, xml ) :\n+\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n+\n+\t\t\t\/\/ Avoid hanging onto element\n+\t\t\t\/\/ (see https:\/\/github.com\/jquery\/sizzle\/issues\/299)\n+\t\t\tcheckContext = null;\n+\t\t\treturn ret;\n+\t\t} ];\n+\n+\tfor ( ; i < len; i++ ) {\n+\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n+\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n+\t\t} else {\n+\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n+\n+\t\t\t\/\/ Return special upon seeing a positional matcher\n+\t\t\tif ( matcher[ expando ] ) {\n+\n+\t\t\t\t\/\/ Find the next relative operator (if any) for proper handling\n+\t\t\t\tj = ++i;\n+\t\t\t\tfor ( ; j < len; j++ ) {\n+\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn setMatcher(\n+\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n+\t\t\t\t\ti > 1 && toSelector(\n+\n+\t\t\t\t\t\t\/\/ If the preceding token was a descendant combinator, insert an implicit any-element `*`\n+\t\t\t\t\t\ttokens.slice( 0, i - 1 )\n+\t\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" } )\n+\t\t\t\t\t).replace( rtrimCSS, \"$1\" ),\n+\t\t\t\t\tmatcher,\n+\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n+\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n+\t\t\t\t\tj < len && toSelector( tokens )\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\tmatchers.push( matcher );\n+\t\t}\n+\t}\n+\n+\treturn elementMatcher( matchers );\n+}\n+\n+function matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n+\tvar bySet = setMatchers.length > 0,\n+\t\tbyElement = elementMatchers.length > 0,\n+\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n+\t\t\tvar elem, j, matcher,\n+\t\t\t\tmatchedCount = 0,\n+\t\t\t\ti = \"0\",\n+\t\t\t\tunmatched = seed && [],\n+\t\t\t\tsetMatched = [],\n+\t\t\t\tcontextBackup = outermostContext,\n+\n+\t\t\t\t\/\/ We must always have either seed elements or outermost context\n+\t\t\t\telems = seed || byElement && Expr.find.TAG( \"*\", outermost ),\n+\n+\t\t\t\t\/\/ Use integer dirruns iff this is the outermost matcher\n+\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n+\t\t\t\tlen = elems.length;\n+\n+\t\t\tif ( outermost ) {\n+\n+\t\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t\t\/\/ two documents; shallow comparisons work.\n+\t\t\t\t\/\/ eslint-disable-next-line eqeqeq\n+\t\t\t\toutermostContext = context == document || context || outermost;\n+\t\t\t}\n+\n+\t\t\t\/\/ Add elements passing elementMatchers directly to results\n+\t\t\t\/\/ Support: iOS <=7 - 9 only\n+\t\t\t\/\/ Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching\n+\t\t\t\/\/ elements by id. (see trac-14142)\n+\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n+\t\t\t\tif ( byElement && elem ) {\n+\t\t\t\t\tj = 0;\n+\n+\t\t\t\t\t\/\/ Support: IE 11+, Edge 17 - 18+\n+\t\t\t\t\t\/\/ IE\/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t\t\t\/\/ two documents; shallow comparisons work.\n+\t\t\t\t\t\/\/ eslint-disable-next-line eqeqeq\n+\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n+\t\t\t\t\t\tsetDocument( elem );\n+\t\t\t\t\t\txml = !documentIsHTML;\n+\t\t\t\t\t}\n+\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n+\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n+\t\t\t\t\t\t\tpush.call( results, elem );\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif ( outermost ) {\n+\t\t\t\t\t\tdirruns = dirrunsUnique;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Track unmatched elements for set filters\n+\t\t\t\tif ( bySet ) {\n+\n+\t\t\t\t\t\/\/ They will have gone through all possible matchers\n+\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n+\t\t\t\t\t\tmatchedCount--;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t\/\/ Lengthen the array for every element, matched or not\n+\t\t\t\t\tif ( seed ) {\n+\t\t\t\t\t\tunmatched.push( elem );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t\/\/ `i` is now the count of elements visited above, and adding it to `matchedCount`\n+\t\t\t\/\/ makes the latter nonnegative.\n+\t\t\tmatchedCount += i;\n+\n+\t\t\t\/\/ Apply set filters to unmatched elements\n+\t\t\t\/\/ NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n+\t\t\t\/\/ equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n+\t\t\t\/\/ no element matchers and no seed.\n+\t\t\t\/\/ Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n+\t\t\t\/\/ case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n+\t\t\t\/\/ numerically zero.\n+\t\t\tif ( bySet && i !== matchedCount ) {\n+\t\t\t\tj = 0;\n+\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n+\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n+\t\t\t\t}\n+\n+\t\t\t\tif ( seed ) {\n+\n+\t\t\t\t\t\/\/ Reintegrate element matches to eliminate the need for sorting\n+\t\t\t\t\tif ( matchedCount > 0 ) {\n+\t\t\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n+\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t\/\/ Discard index placeholder values to get only actual matches\n+\t\t\t\t\tsetMatched = condense( setMatched );\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Add matches to results\n+\t\t\t\tpush.apply( results, setMatched );\n+\n+\t\t\t\t\/\/ Seedless set matches succeeding multiple successful matchers stipulate sorting\n+\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n+\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n+\n+\t\t\t\t\tjQuery.uniqueSort( results );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t\/\/ Override manipulation of globals by nested matchers\n+\t\t\tif ( outermost ) {\n+\t\t\t\tdirruns = dirrunsUnique;\n+\t\t\t\toutermostContext = contextBackup;\n+\t\t\t}\n+\n+\t\t\treturn unmatched;\n+\t\t};\n+\n+\treturn bySet ?\n+\t\tmarkFunction( superMatcher ) :\n+\t\tsuperMatcher;\n+}\n+\n+function compile( selector, match \/* Internal Use Only *\/ ) {\n+\tvar i,\n+\t\tsetMatchers = [],\n+\t\telementMatchers = [],\n+\t\tcached = compilerCache[ selector + \" \" ];\n+\n+\tif ( !cached ) {\n+\n+\t\t\/\/ Generate a function of recursive functions that can be used to check each element\n+\t\tif ( !match ) {\n+\t\t\tmatch = tokenize( selector );\n+\t\t}\n+\t\ti = match.length;\n+\t\twhile ( i-- ) {\n+\t\t\tcached = matcherFromTokens( match[ i ] );\n+\t\t\tif ( cached[ expando ] ) {\n+\t\t\t\tsetMatchers.push( cached );\n+\t\t\t} else {\n+\t\t\t\telementMatchers.push( cached );\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Cache the compiled function\n+\t\tcached = compilerCache( selector,\n+\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers ) );\n+\n+\t\t\/\/ Save selector and tokenization\n+\t\tcached.selector = selector;\n+\t}\n+\treturn cached;\n+}\n+\n+\/**\n+ * A low-level selection function that works with jQuery's compiled\n+ *  selector functions\n+ * @param {String|Function} selector A selector or a pre-compiled\n+ *  selector function built with jQuery selector compile\n+ * @param {Element} context\n+ * @param {Array} [results]\n+ * @param {Array} [seed] A set of elements to match against\n+ *\/\n+function select( selector, context, results, seed ) {\n+\tvar i, tokens, token, type, find,\n+\t\tcompiled = typeof selector === \"function\" && selector,\n+\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n+\n+\tresults = results || [];\n+\n+\t\/\/ Try to minimize operations if there is only one selector in the list and no seed\n+\t\/\/ (the latter of which guarantees us context)\n+\tif ( match.length === 1 ) {\n+\n+\t\t\/\/ Reduce context if the leading compound selector is an ID\n+\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n+\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n+\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n+\n+\t\t\tcontext = ( Expr.find.ID(\n+\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n+\t\t\t\tcontext\n+\t\t\t) || [] )[ 0 ];\n+\t\t\tif ( !context ) {\n+\t\t\t\treturn results;\n+\n+\t\t\t\/\/ Precompiled matchers will still verify ancestry, so step up a level\n+\t\t\t} else if ( compiled ) {\n+\t\t\t\tcontext = context.parentNode;\n+\t\t\t}\n+\n+\t\t\tselector = selector.slice( tokens.shift().value.length );\n+\t\t}\n+\n+\t\t\/\/ Fetch a seed set for right-to-left matching\n+\t\ti = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;\n+\t\twhile ( i-- ) {\n+\t\t\ttoken = tokens[ i ];\n+\n+\t\t\t\/\/ Abort if we hit a combinator\n+\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n+\n+\t\t\t\t\/\/ Search, expanding context for leading sibling combinators\n+\t\t\t\tif ( ( seed = find(\n+\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n+\t\t\t\t\trsibling.test( tokens[ 0 ].type ) &&\n+\t\t\t\t\t\ttestContext( context.parentNode ) || context\n+\t\t\t\t) ) ) {\n+\n+\t\t\t\t\t\/\/ If seed is empty or no tokens remain, we can return early\n+\t\t\t\t\ttokens.splice( i, 1 );\n+\t\t\t\t\tselector = seed.length && toSelector( tokens );\n+\t\t\t\t\tif ( !selector ) {\n+\t\t\t\t\t\tpush.apply( results, seed );\n+\t\t\t\t\t\treturn results;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t\/\/ Compile and execute a filtering function if one is not provided\n+\t\/\/ Provide `match` to avoid retokenization if we modified the selector above\n+\t( compiled || compile( selector, match ) )(\n+\t\tseed,\n+\t\tcontext,\n+\t\t!documentIsHTML,\n+\t\tresults,\n+\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n+\t);\n+\treturn results;\n+}\n+\n+\/\/ One-time assignments\n+\n+\/\/ Support: Android <=4.0 - 4.1+\n+\/\/ Sort stability\n+support.sortStable = expando.split( \"\" ).sort( sortOrder ).join( \"\" ) === expando;\n+\n+\/\/ Initialize against the default document\n+setDocument();\n+\n+\/\/ Support: Android <=4.0 - 4.1+\n+\/\/ Detached nodes confoundingly follow *each other*\n+support.sortDetached = assert( function( el ) {\n+\n+\t\/\/ Should return 1, but returns 4 (following)\n+\treturn el.compareDocumentPosition( document.createElement( \"fieldset\" ) ) & 1;\n+} );\n+\n+jQuery.find = find;\n+\n+\/\/ Deprecated\n+jQuery.expr[ \":\" ] = jQuery.expr.pseudos;\n+jQuery.unique = jQuery.uniqueSort;\n+\n+\/\/ These have always been private, but they used to be documented as part of\n+\/\/ Sizzle so let's maintain them for now for backwards compatibility purposes.\n+find.compile = compile;\n+find.select = select;\n+find.setDocument = setDocument;\n+find.tokenize = tokenize;\n+\n+find.escape = jQuery.escapeSelector;\n+find.getText = jQuery.text;\n+find.isXML = jQuery.isXMLDoc;\n+find.selectors = jQuery.expr;\n+find.support = jQuery.support;\n+find.uniqueSort = jQuery.uniqueSort;\n+\n+\t\/* eslint-enable *\/\n+\n+} )();\n+\n+\n+var dir = function( elem, dir, until ) {\n+\tvar matched = [],\n+\t\ttruncate = until !== undefined;\n+\n+\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n+\t\tif ( elem.nodeType === 1 ) {\n+\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tmatched.push( elem );\n+\t\t}\n+\t}\n+\treturn matched;\n+};\n+\n+\n+var siblings = function( n, elem ) {\n+\tvar matched = [];\n+\n+\tfor ( ; n; n = n.nextSibling ) {\n+\t\tif ( n.nodeType === 1 && n !== elem ) {\n+\t\t\tmatched.push( n );\n+\t\t}\n+\t}\n+\n+\treturn matched;\n+};\n+\n+\n+var rneedsContext = jQuery.expr.match.needsContext;\n+\n+var rsingleTag = ( \/^<([a-z][^\\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\\/?>(?:<\\\/\\1>|)$\/i );\n+\n+\n+\n+\/\/ Implement the identical functionality for filter and not\n+function winnow( elements, qualifier, not ) {\n+\tif ( isFunction( qualifier ) ) {\n+\t\treturn jQuery.grep( elements, function( elem, i ) {\n+\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n+\t\t} );\n+\t}\n+\n+\t\/\/ Single element\n+\tif ( qualifier.nodeType ) {\n+\t\treturn jQuery.grep( elements, function( elem ) {\n+\t\t\treturn ( elem === qualifier ) !== not;\n+\t\t} );\n+\t}\n+\n+\t\/\/ Arraylike of elements (jQuery, arguments, Array)\n+\tif ( typeof qualifier !== \"string\" ) {\n+\t\treturn jQuery.grep( elements, function( elem ) {\n+\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n+\t\t} );\n+\t}\n+\n+\t\/\/ Filtered directly for both simple and complex selectors\n+\treturn jQuery.filter( qualifier, elements, not );\n+}\n+\n+jQuery.filter = function( expr, elems, not ) {\n+\tvar elem = elems[ 0 ];\n+\n+\tif ( not ) {\n+\t\texpr = \":not(\" + expr + \")\";\n+\t}\n+\n+\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n+\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n+\t}\n+\n+\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n+\t\treturn elem.nodeType === 1;\n+\t} ) );\n+};\n+\n+jQuery.fn.extend( {\n+\tfind: function( selector ) {\n+\t\tvar i, ret,\n+\t\t\tlen = this.length,\n+\t\t\tself = this;\n+\n+\t\tif ( typeof selector !== \"string\" ) {\n+\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n+\t\t\t\tfor ( i = 0; i < len; i++ ) {\n+\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} ) );\n+\t\t}\n+\n+\t\tret = this.pushStack( [] );\n+\n+\t\tfor ( i = 0; i < len; i++ ) {\n+\t\t\tjQuery.find( selector, self[ i ], ret );\n+\t\t}\n+\n+\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n+\t},\n+\tfilter: function( selector ) {\n+\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n+\t},\n+\tnot: function( selector ) {\n+\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n+\t},\n+\tis: function( selector ) {\n+\t\treturn !!winnow(\n+\t\t\tthis,\n+\n+\t\t\t\/\/ If this is a positional\/relative selector, check membership in the returned set\n+\t\t\t\/\/ so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n+\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n+\t\t\t\tjQuery( selector ) :\n+\t\t\t\tselector || [],\n+\t\t\tfalse\n+\t\t).length;\n+\t}\n+} );\n+\n+\n+\/\/ Initialize a jQuery object\n+\n+\n+\/\/ A central reference to the root jQuery(document)\n+var rootjQuery,\n+\n+\t\/\/ A simple way to check for HTML strings\n+\t\/\/ Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n+\t\/\/ Strict HTML recognition (trac-11290: must start with <)\n+\t\/\/ Shortcut simple #id case for speed\n+\trquickExpr = \/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$\/,\n+\n+\tinit = jQuery.fn.init = function( selector, context, root ) {\n+\t\tvar match, elem;\n+\n+\t\t\/\/ HANDLE: $(\"\"), $(null), $(undefined), $(false)\n+\t\tif ( !selector ) {\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\t\/\/ Method init() accepts an alternate rootjQuery\n+\t\t\/\/ so migrate can support jQuery.sub (gh-2101)\n+\t\troot = root || rootjQuery;\n+\n+\t\t\/\/ Handle HTML strings\n+\t\tif ( typeof selector === \"string\" ) {\n+\t\t\tif ( selector[ 0 ] === \"<\" &&\n+\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n+\t\t\t\tselector.length >= 3 ) {\n+\n+\t\t\t\t\/\/ Assume that strings that start and end with <> are HTML and skip the regex check\n+\t\t\t\tmatch = [ null, selector, null ];\n+\n+\t\t\t} else {\n+\t\t\t\tmatch = rquickExpr.exec( selector );\n+\t\t\t}\n+\n+\t\t\t\/\/ Match html or make sure no context is specified for #id\n+\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n+\n+\t\t\t\t\/\/ HANDLE: $(html) -> $(array)\n+\t\t\t\tif ( match[ 1 ] ) {\n+\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n+\n+\t\t\t\t\t\/\/ Option to run scripts is true for back-compat\n+\t\t\t\t\t\/\/ Intentionally let the error be thrown if parseHTML is not present\n+\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n+\t\t\t\t\t\tmatch[ 1 ],\n+\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n+\t\t\t\t\t\ttrue\n+\t\t\t\t\t) );\n+\n+\t\t\t\t\t\/\/ HANDLE: $(html, props)\n+\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n+\t\t\t\t\t\tfor ( match in context ) {\n+\n+\t\t\t\t\t\t\t\/\/ Properties of context are called as methods if possible\n+\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n+\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n+\n+\t\t\t\t\t\t\t\/\/ ...and otherwise set as attributes\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn this;\n+\n+\t\t\t\t\/\/ HANDLE: $(#id)\n+\t\t\t\t} else {\n+\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n+\n+\t\t\t\t\tif ( elem ) {\n+\n+\t\t\t\t\t\t\/\/ Inject the element directly into the jQuery object\n+\t\t\t\t\t\tthis[ 0 ] = elem;\n+\t\t\t\t\t\tthis.length = 1;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn this;\n+\t\t\t\t}\n+\n+\t\t\t\/\/ HANDLE: $(expr, $(...))\n+\t\t\t} else if ( !context || context.jquery ) {\n+\t\t\t\treturn ( context || root ).find( selector );\n+\n+\t\t\t\/\/ HANDLE: $(expr, context)\n+\t\t\t\/\/ (which is just equivalent to: $(context).find(expr)\n+\t\t\t} else {\n+\t\t\t\treturn this.constructor( context ).find( selector );\n+\t\t\t}\n+\n+\t\t\/\/ HANDLE: $(DOMElement)\n+\t\t} else if ( selector.nodeType ) {\n+\t\t\tthis[ 0 ] = selector;\n+\t\t\tthis.length = 1;\n+\t\t\treturn this;\n+\n+\t\t\/\/ HANDLE: $(function)\n+\t\t\/\/ Shortcut for document ready\n+\t\t} else if ( isFunction( selector ) ) {\n+\t\t\treturn root.ready !== undefined ?\n+\t\t\t\troot.ready( selector ) :\n+\n+\t\t\t\t\/\/ Execute immediately if ready is not present\n+\t\t\t\tselector( jQuery );\n+\t\t}\n+\n+\t\treturn jQuery.makeArray( selector, this );\n+\t};\n+\n+\/\/ Give the init function the jQuery prototype for later instantiation\n+init.prototype = jQuery.fn;\n+\n+\/\/ Initialize central reference\n+rootjQuery = jQuery( document );\n+\n+\n+var rparentsprev = \/^(?:parents|prev(?:Until|All))\/,\n+\n+\t\/\/ Methods guaranteed to produce a unique set when starting from a unique set\n+\tguaranteedUnique = {\n+\t\tchildren: true,\n+\t\tcontents: true,\n+\t\tnext: true,\n+\t\tprev: true\n+\t};\n+\n+jQuery.fn.extend( {\n+\thas: function( target ) {\n+\t\tvar targets = jQuery( target, this ),\n+\t\t\tl = targets.length;\n+\n+\t\treturn this.filter( function() {\n+\t\t\tvar i = 0;\n+\t\t\tfor ( ; i < l; i++ ) {\n+\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tclosest: function( selectors, context ) {\n+\t\tvar cur,\n+\t\t\ti = 0,\n+\t\t\tl = this.length,\n+\t\t\tmatched = [],\n+\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n+\n+\t\t\/\/ Positional selectors never match, since there's no _selection_ context\n+\t\tif ( !rneedsContext.test( selectors ) ) {\n+\t\t\tfor ( ; i < l; i++ ) {\n+\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n+\n+\t\t\t\t\t\/\/ Always skip document fragments\n+\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n+\t\t\t\t\t\ttargets.index( cur ) > -1 :\n+\n+\t\t\t\t\t\t\/\/ Don't pass non-elements to jQuery#find\n+\t\t\t\t\t\tcur.nodeType === 1 &&\n+\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n+\n+\t\t\t\t\t\tmatched.push( cur );\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n+\t},\n+\n+\t\/\/ Determine the position of an element within the set\n+\tindex: function( elem ) {\n+\n+\t\t\/\/ No argument, return index in parent\n+\t\tif ( !elem ) {\n+\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n+\t\t}\n+\n+\t\t\/\/ Index in selector\n+\t\tif ( typeof elem === \"string\" ) {\n+\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n+\t\t}\n+\n+\t\t\/\/ Locate the position of the desired element\n+\t\treturn indexOf.call( this,\n+\n+\t\t\t\/\/ If it receives a jQuery object, the first element is used\n+\t\t\telem.jquery ? elem[ 0 ] : elem\n+\t\t);\n+\t},\n+\n+\tadd: function( selector, context ) {\n+\t\treturn this.pushStack(\n+\t\t\tjQuery.uniqueSort(\n+\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n+\t\t\t)\n+\t\t);\n+\t},\n+\n+\taddBack: function( selector ) {\n+\t\treturn this.add( selector == null ?\n+\t\t\tthis.prevObject : this.prevObject.filter( selector )\n+\t\t);\n+\t}\n+} );\n+\n+function sibling( cur, dir ) {\n+\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n+\treturn cur;\n+}\n+\n+jQuery.each( {\n+\tparent: function( elem ) {\n+\t\tvar parent = elem.parentNode;\n+\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n+\t},\n+\tparents: function( elem ) {\n+\t\treturn dir( elem, \"parentNode\" );\n+\t},\n+\tparentsUntil: function( elem, _i, until ) {\n+\t\treturn dir( elem, \"parentNode\", until );\n+\t},\n+\tnext: function( elem ) {\n+\t\treturn sibling( elem, \"nextSibling\" );\n+\t},\n+\tprev: function( elem ) {\n+\t\treturn sibling( elem, \"previousSibling\" );\n+\t},\n+\tnextAll: function( elem ) {\n+\t\treturn dir( elem, \"nextSibling\" );\n+\t},\n+\tprevAll: function( elem ) {\n+\t\treturn dir( elem, \"previousSibling\" );\n+\t},\n+\tnextUntil: function( elem, _i, until ) {\n+\t\treturn dir( elem, \"nextSibling\", until );\n+\t},\n+\tprevUntil: function( elem, _i, until ) {\n+\t\treturn dir( elem, \"previousSibling\", until );\n+\t},\n+\tsiblings: function( elem ) {\n+\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n+\t},\n+\tchildren: function( elem ) {\n+\t\treturn siblings( elem.firstChild );\n+\t},\n+\tcontents: function( elem ) {\n+\t\tif ( elem.contentDocument != null &&\n+\n+\t\t\t\/\/ Support: IE 11+\n+\t\t\t\/\/ <object> elements with no `data` attribute has an object\n+\t\t\t\/\/ `contentDocument` with a `null` prototype.\n+\t\t\tgetProto( elem.contentDocument ) ) {\n+\n+\t\t\treturn elem.contentDocument;\n+\t\t}\n+\n+\t\t\/\/ Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n+\t\t\/\/ Treat the template element as a regular one in browsers that\n+\t\t\/\/ don't support it.\n+\t\tif ( nodeName( elem, \"template\" ) ) {\n+\t\t\telem = elem.content || elem;\n+\t\t}\n+\n+\t\treturn jQuery.merge( [], elem.childNodes );\n+\t}\n+}, function( name, fn ) {\n+\tjQuery.fn[ name ] = function( until, selector ) {\n+\t\tvar matched = jQuery.map( this, fn, until );\n+\n+\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n+\t\t\tselector = until;\n+\t\t}\n+\n+\t\tif ( selector && typeof selector === \"string\" ) {\n+\t\t\tmatched = jQuery.filter( selector, matched );\n+\t\t}\n+\n+\t\tif ( this.length > 1 ) {\n+\n+\t\t\t\/\/ Remove duplicates\n+\t\t\tif ( !guaranteedUnique[ name ] ) {\n+\t\t\t\tjQuery.uniqueSort( matched );\n+\t\t\t}\n+\n+\t\t\t\/\/ Reverse order for parents* and prev-derivatives\n+\t\t\tif ( rparentsprev.test( name ) ) {\n+\t\t\t\tmatched.reverse();\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn this.pushStack( matched );\n+\t};\n+} );\n+var rnothtmlwhite = ( \/[^\\x20\\t\\r\\n\\f]+\/g );\n+\n+\n+\n+\/\/ Convert String-formatted options into Object-formatted ones\n+function createOptions( options ) {\n+\tvar object = {};\n+\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n+\t\tobject[ flag ] = true;\n+\t} );\n+\treturn object;\n+}\n+\n+\/*\n+ * Create a callback list using the following parameters:\n+ *\n+ *\toptions: an optional list of space-separated options that will change how\n+ *\t\t\tthe callback list behaves or a more traditional option object\n+ *\n+ * By default a callback list will act like an event callback list and can be\n+ * \"fired\" multiple times.\n+ *\n+ * Possible options:\n+ *\n+ *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n+ *\n+ *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n+ *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n+ *\t\t\t\t\tvalues (like a Deferred)\n+ *\n+ *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n+ *\n+ *\tstopOnFalse:\tinterrupt callings when a callback returns false\n+ *\n+ *\/\n+jQuery.Callbacks = function( options ) {\n+\n+\t\/\/ Convert options from String-formatted to Object-formatted if needed\n+\t\/\/ (we check in cache first)\n+\toptions = typeof options === \"string\" ?\n+\t\tcreateOptions( options ) :\n+\t\tjQuery.extend( {}, options );\n+\n+\tvar \/\/ Flag to know if list is currently firing\n+\t\tfiring,\n+\n+\t\t\/\/ Last fire value for non-forgettable lists\n+\t\tmemory,\n+\n+\t\t\/\/ Flag to know if list was already fired\n+\t\tfired,\n+\n+\t\t\/\/ Flag to prevent firing\n+\t\tlocked,\n+\n+\t\t\/\/ Actual callback list\n+\t\tlist = [],\n+\n+\t\t\/\/ Queue of execution data for repeatable lists\n+\t\tqueue = [],\n+\n+\t\t\/\/ Index of currently firing callback (modified by add\/remove as needed)\n+\t\tfiringIndex = -1,\n+\n+\t\t\/\/ Fire callbacks\n+\t\tfire = function() {\n+\n+\t\t\t\/\/ Enforce single-firing\n+\t\t\tlocked = locked || options.once;\n+\n+\t\t\t\/\/ Execute callbacks for all pending executions,\n+\t\t\t\/\/ respecting firingIndex overrides and runtime changes\n+\t\t\tfired = firing = true;\n+\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n+\t\t\t\tmemory = queue.shift();\n+\t\t\t\twhile ( ++firingIndex < list.length ) {\n+\n+\t\t\t\t\t\/\/ Run callback and check for early termination\n+\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n+\t\t\t\t\t\toptions.stopOnFalse ) {\n+\n+\t\t\t\t\t\t\/\/ Jump to end and forget the data so .add doesn't re-fire\n+\t\t\t\t\t\tfiringIndex = list.length;\n+\t\t\t\t\t\tmemory = false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t\/\/ Forget the data if we're done with it\n+\t\t\tif ( !options.memory ) {\n+\t\t\t\tmemory = false;\n+\t\t\t}\n+\n+\t\t\tfiring = false;\n+\n+\t\t\t\/\/ Clean up if we're done firing for good\n+\t\t\tif ( locked ) {\n+\n+\t\t\t\t\/\/ Keep an empty list if we have data for future add calls\n+\t\t\t\tif ( memory ) {\n+\t\t\t\t\tlist = [];\n+\n+\t\t\t\t\/\/ Otherwise, this object is spent\n+\t\t\t\t} else {\n+\t\t\t\t\tlist = \"\";\n+\t\t\t\t}\n+\t\t\t}\n+\t\t},\n+\n+\t\t\/\/ Actual Callbacks object\n+\t\tself = {\n+\n+\t\t\t\/\/ Add a callback or a collection of callbacks to the list\n+\t\t\tadd: function() {\n+\t\t\t\tif ( list ) {\n+\n+\t\t\t\t\t\/\/ If we have memory from a past run, we should fire after adding\n+\t\t\t\t\tif ( memory && !firing ) {\n+\t\t\t\t\t\tfiringIndex = list.length - 1;\n+\t\t\t\t\t\tqueue.push( memory );\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t( function add( args ) {\n+\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n+\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n+\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n+\t\t\t\t\t\t\t\t\tlist.push( arg );\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n+\n+\t\t\t\t\t\t\t\t\/\/ Inspect recursively\n+\t\t\t\t\t\t\t\tadd( arg );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} );\n+\t\t\t\t\t} )( arguments );\n+\n+\t\t\t\t\tif ( memory && !firing ) {\n+\t\t\t\t\t\tfire();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn this;\n+\t\t\t},\n+\n+\t\t\t\/\/ Remove a callback from the list\n+\t\t\tremove: function() {\n+\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n+\t\t\t\t\tvar index;\n+\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n+\t\t\t\t\t\tlist.splice( index, 1 );\n+\n+\t\t\t\t\t\t\/\/ Handle firing indexes\n+\t\t\t\t\t\tif ( index <= firingIndex ) {\n+\t\t\t\t\t\t\tfiringIndex--;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} );\n+\t\t\t\treturn this;\n+\t\t\t},\n+\n+\t\t\t\/\/ Check if a given callback is in the list.\n+\t\t\t\/\/ If no argument is given, return whether or not list has callbacks attached.\n+\t\t\thas: function( fn ) {\n+\t\t\t\treturn fn ?\n+\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n+\t\t\t\t\tlist.length > 0;\n+\t\t\t},\n+\n+\t\t\t\/\/ Remove all callbacks from the list\n+\t\t\tempty: function() {\n+\t\t\t\tif ( list ) {\n+\t\t\t\t\tlist = [];\n+\t\t\t\t}\n+\t\t\t\treturn this;\n+\t\t\t},\n+\n+\t\t\t\/\/ Disable .fire and .add\n+\t\t\t\/\/ Abort any current\/pending executions\n+\t\t\t\/\/ Clear all callbacks and values\n+\t\t\tdisable: function() {\n+\t\t\t\tlocked = queue = [];\n+\t\t\t\tlist = memory = \"\";\n+\t\t\t\treturn this;\n+\t\t\t},\n+\t\t\tdisabled: function() {\n+\t\t\t\treturn !list;\n+\t\t\t},\n+\n+\t\t\t\/\/ Disable .fire\n+\t\t\t\/\/ Also disable .add unless we have memory (since it would have no effect)\n+\t\t\t\/\/ Abort any pending executions\n+\t\t\tlock: function() {\n+\t\t\t\tlocked = queue = [];\n+\t\t\t\tif ( !memory && !firing ) {\n+\t\t\t\t\tlist = memory = \"\";\n+\t\t\t\t}\n+\t\t\t\treturn this;\n+\t\t\t},\n+\t\t\tlocked: function() {\n+\t\t\t\treturn !!locked;\n+\t\t\t},\n+\n+\t\t\t\/\/ Call all callbacks with the given context and arguments\n+\t\t\tfireWith: function( context, args ) {\n+\t\t\t\tif ( !locked ) {\n+\t\t\t\t\targs = args || [];\n+\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n+\t\t\t\t\tqueue.push( args );\n+\t\t\t\t\tif ( !firing ) {\n+\t\t\t\t\t\tfire();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn this;\n+\t\t\t},\n+\n+\t\t\t\/\/ Call all the callbacks with the given arguments\n+\t\t\tfire: function() {\n+\t\t\t\tself.fireWith( this, arguments );\n+\t\t\t\treturn this;\n+\t\t\t},\n+\n+\t\t\t\/\/ To know if the callbacks have already been called at least once\n+\t\t\tfired: function() {\n+\t\t\t\treturn !!fired;\n+\t\t\t}\n+\t\t};\n+\n+\treturn self;\n+};\n+\n+\n+function Identity( v ) {\n+\treturn v;\n+}\n+function Thrower( ex ) {\n+\tthrow ex;\n+}\n+\n+function adoptValue( value, resolve, reject, noValue ) {\n+\tvar method;\n+\n+\ttry {\n+\n+\t\t\/\/ Check for promise aspect first to privilege synchronous behavior\n+\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n+\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n+\n+\t\t\/\/ Other thenables\n+\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n+\t\t\tmethod.call( value, resolve, reject );\n+\n+\t\t\/\/ Other non-thenables\n+\t\t} else {\n+\n+\t\t\t\/\/ Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n+\t\t\t\/\/ * false: [ value ].slice( 0 ) => resolve( value )\n+\t\t\t\/\/ * true: [ value ].slice( 1 ) => resolve()\n+\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n+\t\t}\n+\n+\t\/\/ For Promises\/A+, convert exceptions into rejections\n+\t\/\/ Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n+\t\/\/ Deferred#then to conditionally suppress rejection.\n+\t} catch ( value ) {\n+\n+\t\t\/\/ Support: Android 4.0 only\n+\t\t\/\/ Strict mode functions invoked without .call\/.apply get global-object context\n+\t\treject.apply( undefined, [ value ] );\n+\t}\n+}\n+\n+jQuery.extend( {\n+\n+\tDeferred: function( func ) {\n+\t\tvar tuples = [\n+\n+\t\t\t\t\/\/ action, add listener, callbacks,\n+\t\t\t\t\/\/ ... .then handlers, argument index, [final state]\n+\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n+\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n+\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n+\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n+\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n+\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n+\t\t\t],\n+\t\t\tstate = \"pending\",\n+\t\t\tpromise = {\n+\t\t\t\tstate: function() {\n+\t\t\t\t\treturn state;\n+\t\t\t\t},\n+\t\t\t\talways: function() {\n+\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n+\t\t\t\t\treturn this;\n+\t\t\t\t},\n+\t\t\t\t\"catch\": function( fn ) {\n+\t\t\t\t\treturn promise.then( null, fn );\n+\t\t\t\t},\n+\n+\t\t\t\t\/\/ Keep pipe for back-compat\n+\t\t\t\tpipe: function( \/* fnDone, fnFail, fnProgress *\/ ) {\n+\t\t\t\t\tvar fns = arguments;\n+\n+\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n+\t\t\t\t\t\tjQuery.each( tuples, function( _i, tuple ) {\n+\n+\t\t\t\t\t\t\t\/\/ Map tuples (progress, done, fail) to arguments (done, fail, progress)\n+\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n+\n+\t\t\t\t\t\t\t\/\/ deferred.progress(function() { bind to newDefer or newDefer.notify })\n+\t\t\t\t\t\t\t\/\/ deferred.done(function() { bind to newDefer or newDefer.resolve })\n+\t\t\t\t\t\t\t\/\/ deferred.fail(function() { bind to newDefer or newDefer.reject })\n+\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n+\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n+\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n+\t\t\t\t\t\t\t\t\treturned.promise()\n+\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n+\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n+\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n+\t\t\t\t\t\t\t\t\t\tthis,\n+\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n+\t\t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} );\n+\t\t\t\t\t\t} );\n+\t\t\t\t\t\tfns = null;\n+\t\t\t\t\t} ).promise();\n+\t\t\t\t},\n+\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n+\t\t\t\t\tvar maxDepth = 0;\n+\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n+\t\t\t\t\t\treturn function() {\n+\t\t\t\t\t\t\tvar that = this,\n+\t\t\t\t\t\t\t\targs = arguments,\n+\t\t\t\t\t\t\t\tmightThrow = function() {\n+\t\t\t\t\t\t\t\t\tvar returned, then;\n+\n+\t\t\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ section 2.3.3.3.3\n+\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-59\n+\t\t\t\t\t\t\t\t\t\/\/ Ignore double-resolution attempts\n+\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n+\t\t\t\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n+\n+\t\t\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ section 2.3.1\n+\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-48\n+\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n+\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ sections 2.3.3.1, 3.5\n+\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-54\n+\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-75\n+\t\t\t\t\t\t\t\t\t\/\/ Retrieve `then` only once\n+\t\t\t\t\t\t\t\t\tthen = returned &&\n+\n+\t\t\t\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ section 2.3.4\n+\t\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-64\n+\t\t\t\t\t\t\t\t\t\t\/\/ Only check objects and functions for thenability\n+\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n+\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n+\t\t\t\t\t\t\t\t\t\treturned.then;\n+\n+\t\t\t\t\t\t\t\t\t\/\/ Handle a returned thenable\n+\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n+\n+\t\t\t\t\t\t\t\t\t\t\/\/ Special processors (notify) just wait for resolution\n+\t\t\t\t\t\t\t\t\t\tif ( special ) {\n+\t\t\t\t\t\t\t\t\t\t\tthen.call(\n+\t\t\t\t\t\t\t\t\t\t\t\treturned,\n+\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n+\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n+\t\t\t\t\t\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t\t\t\t\t\/\/ Normal processors (resolve) also hook into progress\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t\t\t\t\t\/\/ ...and disregard older resolution values\n+\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n+\n+\t\t\t\t\t\t\t\t\t\t\tthen.call(\n+\t\t\t\t\t\t\t\t\t\t\t\treturned,\n+\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n+\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n+\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n+\t\t\t\t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\/\/ Handle all other returned values\n+\t\t\t\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t\t\t\t\/\/ Only substitute handlers pass on context\n+\t\t\t\t\t\t\t\t\t\t\/\/ and multiple values (non-spec behavior)\n+\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n+\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n+\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n+\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\/\/ Process the value(s)\n+\t\t\t\t\t\t\t\t\t\t\/\/ Default process is resolve\n+\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t},\n+\n+\t\t\t\t\t\t\t\t\/\/ Only normal processors (resolve) catch and reject exceptions\n+\t\t\t\t\t\t\t\tprocess = special ?\n+\t\t\t\t\t\t\t\t\tmightThrow :\n+\t\t\t\t\t\t\t\t\tfunction() {\n+\t\t\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n+\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n+\n+\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n+\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.error );\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ section 2.3.3.3.4.1\n+\t\t\t\t\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-61\n+\t\t\t\t\t\t\t\t\t\t\t\/\/ Ignore post-resolution exceptions\n+\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\/\/ Only substitute handlers pass on context\n+\t\t\t\t\t\t\t\t\t\t\t\t\/\/ and multiple values (non-spec behavior)\n+\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n+\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\t\t\/\/ Support: Promises\/A+ section 2.3.3.3.1\n+\t\t\t\t\t\t\t\/\/ https:\/\/promisesaplus.com\/#point-57\n+\t\t\t\t\t\t\t\/\/ Re-resolve promises immediately to dodge false rejection from\n+\t\t\t\t\t\t\t\/\/ subsequent errors\n+\t\t\t\t\t\t\tif ( depth ) {\n+\t\t\t\t\t\t\t\tprocess();\n+\t\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t\t\/\/ Call an optional hook to record the error, in case of exception\n+\t\t\t\t\t\t\t\t\/\/ since it's otherwise lost when execution goes async\n+\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getErrorHook ) {\n+\t\t\t\t\t\t\t\t\tprocess.error = jQuery.Deferred.getErrorHook();\n+\n+\t\t\t\t\t\t\t\t\/\/ The deprecated alias of the above. While the name suggests\n+\t\t\t\t\t\t\t\t\/\/ returning the stack, not an error instance, jQuery just passes\n+\t\t\t\t\t\t\t\t\/\/ it directly to `console.warn` so both will work; an instance\n+\t\t\t\t\t\t\t\t\/\/ just better cooperates with source maps.\n+\t\t\t\t\t\t\t\t} else if ( jQuery.Deferred.getStackHook ) {\n+\t\t\t\t\t\t\t\t\tprocess.error = jQuery.Deferred.getStackHook();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\twindow.setTimeout( process );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n+\n+\t\t\t\t\t\t\/\/ progress_handlers.add( ... )\n+\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n+\t\t\t\t\t\t\tresolve(\n+\t\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\t\tnewDefer,\n+\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n+\t\t\t\t\t\t\t\t\tonProgress :\n+\t\t\t\t\t\t\t\t\tIdentity,\n+\t\t\t\t\t\t\t\tnewDefer.notifyWith\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t\/\/ fulfilled_handlers.add( ... )\n+\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n+\t\t\t\t\t\t\tresolve(\n+\t\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\t\tnewDefer,\n+\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n+\t\t\t\t\t\t\t\t\tonFulfilled :\n+\t\t\t\t\t\t\t\t\tIdentity\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t\/\/ rejected_handlers.add( ... )\n+\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n+\t\t\t\t\t\t\tresolve(\n+\t\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\t\tnewDefer,\n+\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n+\t\t\t\t\t\t\t\t\tonRejected :\n+\t\t\t\t\t\t\t\t\tThrower\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t);\n+\t\t\t\t\t} ).promise();\n+\t\t\t\t},\n+\n+\t\t\t\t\/\/ Get a promise for this deferred\n+\t\t\t\t\/\/ If obj is provided, the promise aspect is added to the object\n+\t\t\t\tpromise: function( obj ) {\n+\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tdeferred = {};\n+\n+\t\t\/\/ Add list-specific methods\n+\t\tjQuery.each( tuples, function( i, tuple ) {\n+\t\t\tvar list = tuple[ 2 ],\n+\t\t\t\tstateString = tuple[ 5 ];\n+\n+\t\t\t\/\/ promise.progress = list.add\n+\t\t\t\/\/ promise.done = list.add\n+\t\t\t\/\/ promise.fail = list.add\n+\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n+\n+\t\t\t\/\/ Handle state\n+\t\t\tif ( stateString ) {\n+\t\t\t\tlist.add(\n+\t\t\t\t\tfunction() {\n+\n+\t\t\t\t\t\t\/\/ state = \"resolved\" (i.e., fulfilled)\n+\t\t\t\t\t\t\/\/ state = \"rejected\"\n+\t\t\t\t\t\tstate = stateString;\n+\t\t\t\t\t},\n+\n+\t\t\t\t\t\/\/ rejected_callbacks.disable\n+\t\t\t\t\t\/\/ fulfilled_callbacks.disable\n+\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n+\n+\t\t\t\t\t\/\/ rejected_handlers.disable\n+\t\t\t\t\t\/\/ fulfilled_handlers.disable\n+\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n+\n+\t\t\t\t\t\/\/ progress_callbacks.lock\n+\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n+\n+\t\t\t\t\t\/\/ progress_handlers.lock\n+\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n+\t\t\t\t);\n+\t\t\t}\n+\n+\t\t\t\/\/ progress_handlers.fire\n+\t\t\t\/\/ fulfilled_handlers.fire\n+\t\t\t\/\/ rejected_handlers.fire\n+\t\t\tlist.add( tuple[ 3 ].fire );\n+\n+\t\t\t\/\/ deferred.notify = function() { deferred.notifyWith(...) }\n+\t\t\t\/\/ deferred.resolve = function() { deferred.resolveWith(...) }\n+\t\t\t\/\/ deferred.reject = function() { deferred.rejectWith(...) }\n+\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n+\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n+\t\t\t\treturn this;\n+\t\t\t};\n+\n+\t\t\t\/\/ deferred.notifyWith = list.fireWith\n+\t\t\t\/\/ deferred.resolveWith = list.fireWith\n+\t\t\t\/\/ deferred.rejectWith = list.fireWith\n+\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n+\t\t} );\n+\n+\t\t\/\/ Make the deferred a promise\n+\t\tpromise.promise( deferred );\n+\n+\t\t\/\/ Call given func if any\n+\t\tif ( func ) {\n+\t\t\tfunc.call( deferred, deferred );\n+\t\t}\n+\n+\t\t\/\/ All done!\n+\t\treturn deferred;\n+\t},\n+\n+\t\/\/ Deferred helper\n+\twhen: function( singleValue ) {\n+\t\tvar\n+\n+\t\t\t\/\/ count of uncompleted subordinates\n+\t\t\tremaining = arguments.length,\n+\n+\t\t\t\/\/ count of unprocessed arguments\n+\t\t\ti = remaining,\n+\n+\t\t\t\/\/ subordinate fulfillment data\n+\t\t\tresolveContexts = Array( i ),\n+\t\t\tresolveValues = slice.call( arguments ),\n+\n+\t\t\t\/\/ the primary Deferred\n+\t\t\tprimary = jQuery.Deferred(),\n+\n+\t\t\t\/\/ subordinate callback factory\n+\t\t\tupdateFunc = function( i ) {\n+\t\t\t\treturn function( value ) {\n+\t\t\t\t\tresolveContexts[ i ] = this;\n+\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n+\t\t\t\t\tif ( !( --remaining ) ) {\n+\t\t\t\t\t\tprimary.resolveWith( resolveContexts, resolveValues );\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\t\t\t};\n+\n+\t\t\/\/ Single- and empty arguments are adopted like Promise.resolve\n+\t\tif ( remaining <= 1 ) {\n+\t\t\tadoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,\n+\t\t\t\t!remaining );\n+\n+\t\t\t\/\/ Use .then() to unwrap secondary thenables (cf. gh-3000)\n+\t\t\tif ( primary.state() === \"pending\" ||\n+\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n+\n+\t\t\t\treturn primary.then();\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Multiple arguments are aggregated like Promise.all array elements\n+\t\twhile ( i-- ) {\n+\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );\n+\t\t}\n+\n+\t\treturn primary.promise();\n+\t}\n+} );\n+\n+\n+\/\/ These usually indicate a programmer mistake during development,\n+\/\/ warn about them ASAP rather than swallowing them by default.\n+var rerrorNames = \/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$\/;\n+\n+\/\/ If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error\n+\/\/ captured before the async barrier to get the original error cause\n+\/\/ which may otherwise be hidden.\n+jQuery.Deferred.exceptionHook = function( error, asyncError ) {\n+\n+\t\/\/ Support: IE 8 - 9 only\n+\t\/\/ Console exists when dev tools are open, which can happen at any time\n+\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n+\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message,\n+\t\t\terror.stack, asyncError );\n+\t}\n+};\n+\n+\n+\n+\n+jQuery.readyException = function( error ) {\n+\twindow.setTimeout( function() {\n+\t\tthrow error;\n+\t} );\n+};\n+\n+\n+\n+\n+\/\/ The deferred used on DOM ready\n+var readyList = jQuery.Deferred();\n+\n+jQuery.fn.ready = function( fn ) {\n+\n+\treadyList\n+\t\t.then( fn )\n+\n+\t\t\/\/ Wrap jQuery.readyException in a function so that the lookup\n+\t\t\/\/ happens at the time of error handling instead of callback\n+\t\t\/\/ registration.\n+\t\t.catch( function( error ) {\n+\t\t\tjQuery.readyException( error );\n+\t\t} );\n+\n+\treturn this;\n+};\n+\n+jQuery.extend( {\n+\n+\t\/\/ Is the DOM ready to be used? Set to true once it occurs.\n+\tisReady: false,\n+\n+\t\/\/ A counter to track how many items to wait for before\n+\t\/\/ the ready event fires. See trac-6781\n+\treadyWait: 1,\n+\n+\t\/\/ Handle when the DOM is ready\n+\tready: function( wait ) {\n+\n+\t\t\/\/ Abort if there are pending holds or we're already ready\n+\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ Remember that the DOM is ready\n+\t\tjQuery.isReady = true;\n+\n+\t\t\/\/ If a normal DOM Ready event fired, decrement, and wait if need be\n+\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ If there are functions bound, to execute\n+\t\treadyList.resolveWith( document, [ jQuery ] );\n+\t}\n+} );\n+\n+jQuery.ready.then = readyList.then;\n+\n+\/\/ The ready event handler and self cleanup method\n+function completed() {\n+\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n+\twindow.removeEventListener( \"load\", completed );\n+\tjQuery.ready();\n+}\n+\n+\/\/ Catch cases where $(document).ready() is called\n+\/\/ after the browser event has already occurred.\n+\/\/ Support: IE <=9 - 10 only\n+\/\/ Older IE sometimes signals \"interactive\" too soon\n+if ( document.readyState === \"complete\" ||\n+\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n+\n+\t\/\/ Handle it asynchronously to allow scripts the opportunity to delay ready\n+\twindow.setTimeout( jQuery.ready );\n+\n+} else {\n+\n+\t\/\/ Use the handy event callback\n+\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n+\n+\t\/\/ A fallback to window.onload, that will always work\n+\twindow.addEventListener( \"load\", completed );\n+}\n+\n+\n+\n+\n+\/\/ Multifunctional method to get and set values of a collection\n+\/\/ The value\/s can optionally be executed if it's a function\n+var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n+\tvar i = 0,\n+\t\tlen = elems.length,\n+\t\tbulk = key == null;\n+\n+\t\/\/ Sets many values\n+\tif ( toType( key ) === \"object\" ) {\n+\t\tchainable = true;\n+\t\tfor ( i in key ) {\n+\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n+\t\t}\n+\n+\t\/\/ Sets one value\n+\t} else if ( value !== undefined ) {\n+\t\tchainable = true;\n+\n+\t\tif ( !isFunction( value ) ) {\n+\t\t\traw = true;\n+\t\t}\n+\n+\t\tif ( bulk ) {\n+\n+\t\t\t\/\/ Bulk operations run against the entire set\n+\t\t\tif ( raw ) {\n+\t\t\t\tfn.call( elems, value );\n+\t\t\t\tfn = null;\n+\n+\t\t\t\/\/ ...except when executing function values\n+\t\t\t} else {\n+\t\t\t\tbulk = fn;\n+\t\t\t\tfn = function( elem, _key, value ) {\n+\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n+\t\t\t\t};\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ( fn ) {\n+\t\t\tfor ( ; i < len; i++ ) {\n+\t\t\t\tfn(\n+\t\t\t\t\telems[ i ], key, raw ?\n+\t\t\t\t\t\tvalue :\n+\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n+\t\t\t\t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif ( chainable ) {\n+\t\treturn elems;\n+\t}\n+\n+\t\/\/ Gets\n+\tif ( bulk ) {\n+\t\treturn fn.call( elems );\n+\t}\n+\n+\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n+};\n+\n+\n+\/\/ Matches dashed string for camelizing\n+var rmsPrefix = \/^-ms-\/,\n+\trdashAlpha = \/-([a-z])\/g;\n+\n+\/\/ Used by camelCase as callback to replace()\n+function fcamelCase( _all, letter ) {\n+\treturn letter.toUpperCase();\n+}\n+\n+\/\/ Convert dashed to camelCase; used by the css and data modules\n+\/\/ Support: IE <=9 - 11, Edge 12 - 15\n+\/\/ Microsoft forgot to hump their vendor prefix (trac-9572)\n+function camelCase( string ) {\n+\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n+}\n+var acceptData = function( owner ) {\n+\n+\t\/\/ Accepts only:\n+\t\/\/  - Node\n+\t\/\/    - Node.ELEMENT_NODE\n+\t\/\/    - Node.DOCUMENT_NODE\n+\t\/\/  - Object\n+\t\/\/    - Any\n+\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n+};\n+\n+\n+\n+\n+function Data() {\n+\tthis.expando = jQuery.expando + Data.uid++;\n+}\n+\n+Data.uid = 1;\n+\n+Data.prototype = {\n+\n+\tcache: function( owner ) {\n+\n+\t\t\/\/ Check if the owner object already has a cache\n+\t\tvar value = owner[ this.expando ];\n+\n+\t\t\/\/ If not, create one\n+\t\tif ( !value ) {\n+\t\t\tvalue = {};\n+\n+\t\t\t\/\/ We can accept data for non-element nodes in modern browsers,\n+\t\t\t\/\/ but we should not, see trac-8335.\n+\t\t\t\/\/ Always return an empty object.\n+\t\t\tif ( acceptData( owner ) ) {\n+\n+\t\t\t\t\/\/ If it is a node unlikely to be stringify-ed or looped over\n+\t\t\t\t\/\/ use plain assignment\n+\t\t\t\tif ( owner.nodeType ) {\n+\t\t\t\t\towner[ this.expando ] = value;\n+\n+\t\t\t\t\/\/ Otherwise secure it in a non-enumerable property\n+\t\t\t\t\/\/ configurable must be true to allow the property to be\n+\t\t\t\t\/\/ deleted when data is removed\n+\t\t\t\t} else {\n+\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n+\t\t\t\t\t\tvalue: value,\n+\t\t\t\t\t\tconfigurable: true\n+\t\t\t\t\t} );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn value;\n+\t},\n+\tset: function( owner, data, value ) {\n+\t\tvar prop,\n+\t\t\tcache = this.cache( owner );\n+\n+\t\t\/\/ Handle: [ owner, key, value ] args\n+\t\t\/\/ Always use camelCase key (gh-2257)\n+\t\tif ( typeof data === \"string\" ) {\n+\t\t\tcache[ camelCase( data ) ] = value;\n+\n+\t\t\/\/ Handle: [ owner, { properties } ] args\n+\t\t} else {\n+\n+\t\t\t\/\/ Copy the properties one-by-one to the cache object\n+\t\t\tfor ( prop in data ) {\n+\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n+\t\t\t}\n+\t\t}\n+\t\treturn cache;\n+\t},\n+\tget: function( owner, key ) {\n+\t\treturn key === undefined ?\n+\t\t\tthis.cache( owner ) :\n+\n+\t\t\t\/\/ Always use camelCase key (gh-2257)\n+\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n+\t},\n+\taccess: function( owner, key, value ) {\n+\n+\t\t\/\/ In cases where either:\n+\t\t\/\/\n+\t\t\/\/   1. No key was specified\n+\t\t\/\/   2. A string key was specified, but no value provided\n+\t\t\/\/\n+\t\t\/\/ Take the \"read\" path and allow the get method to determine\n+\t\t\/\/ which value to return, respectively either:\n+\t\t\/\/\n+\t\t\/\/   1. The entire cache object\n+\t\t\/\/   2. The data stored at the key\n+\t\t\/\/\n+\t\tif ( key === undefined ||\n+\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n+\n+\t\t\treturn this.get( owner, key );\n+\t\t}\n+\n+\t\t\/\/ When the key is not a string, or both a key and value\n+\t\t\/\/ are specified, set or extend (existing objects) with either:\n+\t\t\/\/\n+\t\t\/\/   1. An object of properties\n+\t\t\/\/   2. A key and value\n+\t\t\/\/\n+\t\tthis.set( owner, key, value );\n+\n+\t\t\/\/ Since the \"set\" path can have two possible entry points\n+\t\t\/\/ return the expected data based on which path was taken[*]\n+\t\treturn value !== undefined ? value : key;\n+\t},\n+\tremove: function( owner, key ) {\n+\t\tvar i,\n+\t\t\tcache = owner[ this.expando ];\n+\n+\t\tif ( cache === undefined ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif ( key !== undefined ) {\n+\n+\t\t\t\/\/ Support array or space separated string of keys\n+\t\t\tif ( Array.isArray( key ) ) {\n+\n+\t\t\t\t\/\/ If key is an array of keys...\n+\t\t\t\t\/\/ We always set camelCase keys, so remove that.\n+\t\t\t\tkey = key.map( camelCase );\n+\t\t\t} else {\n+\t\t\t\tkey = camelCase( key );\n+\n+\t\t\t\t\/\/ If a key with the spaces exists, use it.\n+\t\t\t\t\/\/ Otherwise, create an array by matching non-whitespace\n+\t\t\t\tkey = key in cache ?\n+\t\t\t\t\t[ key ] :\n+\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n+\t\t\t}\n+\n+\t\t\ti = key.length;\n+\n+\t\t\twhile ( i-- ) {\n+\t\t\t\tdelete cache[ key[ i ] ];\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Remove the expando if there's no more data\n+\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n+\n+\t\t\t\/\/ Support: Chrome <=35 - 45\n+\t\t\t\/\/ Webkit & Blink performance suffers when deleting properties\n+\t\t\t\/\/ from DOM nodes, so set to undefined instead\n+\t\t\t\/\/ https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=378607 (bug restricted)\n+\t\t\tif ( owner.nodeType ) {\n+\t\t\t\towner[ this.expando ] = undefined;\n+\t\t\t} else {\n+\t\t\t\tdelete owner[ this.expando ];\n+\t\t\t}\n+\t\t}\n+\t},\n+\thasData: function( owner ) {\n+\t\tvar cache = owner[ this.expando ];\n+\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n+\t}\n+};\n+var dataPriv = new Data();\n+\n+var dataUser = new Data();\n+\n+\n+\n+\/\/\tImplementation Summary\n+\/\/\n+\/\/\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n+\/\/\t2. Improve the module's maintainability by reducing the storage\n+\/\/\t\tpaths to a single mechanism.\n+\/\/\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n+\/\/\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n+\/\/\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n+\/\/\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n+\n+var rbrace = \/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$\/,\n+\trmultiDash = \/[A-Z]\/g;\n+\n+function getData( data ) {\n+\tif ( data === \"true\" ) {\n+\t\treturn true;\n+\t}\n+\n+\tif ( data === \"false\" ) {\n+\t\treturn false;\n+\t}\n+\n+\tif ( data === \"null\" ) {\n+\t\treturn null;\n+\t}\n+\n+\t\/\/ Only convert to a number if it doesn't change the string\n+\tif ( data === +data + \"\" ) {\n+\t\treturn +data;\n+\t}\n+\n+\tif ( rbrace.test( data ) ) {\n+\t\treturn JSON.parse( data );\n+\t}\n+\n+\treturn data;\n+}\n+\n+function dataAttr( elem, key, data ) {\n+\tvar name;\n+\n+\t\/\/ If nothing was found internally, try to fetch any\n+\t\/\/ data from the HTML5 data-* attribute\n+\tif ( data === undefined && elem.nodeType === 1 ) {\n+\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n+\t\tdata = elem.getAttribute( name );\n+\n+\t\tif ( typeof data === \"string\" ) {\n+\t\t\ttry {\n+\t\t\t\tdata = getData( data );\n+\t\t\t} catch ( e ) {}\n+\n+\t\t\t\/\/ Make sure we set the data so it isn't changed later\n+\t\t\tdataUser.set( elem, key, data );\n+\t\t} else {\n+\t\t\tdata = undefined;\n+\t\t}\n+\t}\n+\treturn data;\n+}\n+\n+jQuery.extend( {\n+\thasData: function( elem ) {\n+\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n+\t},\n+\n+\tdata: function( elem, name, data ) {\n+\t\treturn dataUser.access( elem, name, data );\n+\t},\n+\n+\tremoveData: function( elem, name ) {\n+\t\tdataUser.remove( elem, name );\n+\t},\n+\n+\t\/\/ TODO: Now that all calls to _data and _removeData have been replaced\n+\t\/\/ with direct calls to dataPriv methods, these can be deprecated.\n+\t_data: function( elem, name, data ) {\n+\t\treturn dataPriv.access( elem, name, data );\n+\t},\n+\n+\t_removeData: function( elem, name ) {\n+\t\tdataPriv.remove( elem, name );\n+\t}\n+} );\n+\n+jQuery.fn.extend( {\n+\tdata: function( key, value ) {\n+\t\tvar i, name, data,\n+\t\t\telem = this[ 0 ],\n+\t\t\tattrs = elem && elem.attributes;\n+\n+\t\t\/\/ Gets all values\n+\t\tif ( key === undefined ) {\n+\t\t\tif ( this.length ) {\n+\t\t\t\tdata = dataUser.get( elem );\n+\n+\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n+\t\t\t\t\ti = attrs.length;\n+\t\t\t\t\twhile ( i-- ) {\n+\n+\t\t\t\t\t\t\/\/ Support: IE 11 only\n+\t\t\t\t\t\t\/\/ The attrs elements can be null (trac-14894)\n+\t\t\t\t\t\tif ( attrs[ i ] ) {\n+\t\t\t\t\t\t\tname = attrs[ i ].name;\n+\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n+\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n+\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn data;\n+\t\t}\n+\n+\t\t\/\/ Sets multiple values\n+\t\tif ( typeof key === \"object\" ) {\n+\t\t\treturn this.each( function() {\n+\t\t\t\tdataUser.set( this, key );\n+\t\t\t} );\n+\t\t}\n+\n+\t\treturn access( this, function( value ) {\n+\t\t\tvar data;\n+\n+\t\t\t\/\/ The calling jQuery object (element matches) is not empty\n+\t\t\t\/\/ (and therefore has an element appears at this[ 0 ]) and the\n+\t\t\t\/\/ `value` parameter was not undefined. An empty jQuery object\n+\t\t\t\/\/ will result in `undefined` for elem = this[ 0 ] which will\n+\t\t\t\/\/ throw an exception if an attempt to read a data cache is made.\n+\t\t\tif ( elem && value === undefined ) {\n+\n+\t\t\t\t\/\/ Attempt to get data from the cache\n+\t\t\t\t\/\/ The key will always be camelCased in Data\n+\t\t\t\tdata = dataUser.get( elem, key );\n+\t\t\t\tif ( data !== undefined ) {\n+\t\t\t\t\treturn data;\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Attempt to \"discover\" the data in\n+\t\t\t\t\/\/ HTML5 custom data-* attrs\n+\t\t\t\tdata = dataAttr( elem, key );\n+\t\t\t\tif ( data !== undefined ) {\n+\t\t\t\t\treturn data;\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ We tried really hard, but the data doesn't exist.\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t\/\/ Set the data...\n+\t\t\tthis.each( function() {\n+\n+\t\t\t\t\/\/ We always store the camelCased key\n+\t\t\t\tdataUser.set( this, key, value );\n+\t\t\t} );\n+\t\t}, null, value, arguments.length > 1, null, true );\n+\t},\n+\n+\tremoveData: function( key ) {\n+\t\treturn this.each( function() {\n+\t\t\tdataUser.remove( this, key );\n+\t\t} );\n+\t}\n+} );\n+\n+\n+jQuery.extend( {\n+\tqueue: function( elem, type, data ) {\n+\t\tvar queue;\n+\n+\t\tif ( elem ) {\n+\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n+\t\t\tqueue = dataPriv.get( elem, type );\n+\n+\t\t\t\/\/ Speed up dequeue by getting out quickly if this is just a lookup\n+\t\t\tif ( data ) {\n+\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n+\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n+\t\t\t\t} else {\n+\t\t\t\t\tqueue.push( data );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn queue || [];\n+\t\t}\n+\t},\n+\n+\tdequeue: function( elem, type ) {\n+\t\ttype = type || \"fx\";\n+\n+\t\tvar queue = jQuery.queue( elem, type ),\n+\t\t\tstartLength = queue.length,\n+\t\t\tfn = queue.shift(),\n+\t\t\thooks = jQuery._queueHooks( elem, type ),\n+\t\t\tnext = function() {\n+\t\t\t\tjQuery.dequeue( elem, type );\n+\t\t\t};\n+\n+\t\t\/\/ If the fx queue is dequeued, always remove the progress sentinel\n+\t\tif ( fn === \"inprogress\" ) {\n+\t\t\tfn = queue.shift();\n+\t\t\tstartLength--;\n+\t\t}\n+\n+\t\tif ( fn ) {\n+\n+\t\t\t\/\/ Add a progress sentinel to prevent the fx queue from being\n+\t\t\t\/\/ automatically dequeued\n+\t\t\tif ( type === \"fx\" ) {\n+\t\t\t\tqueue.unshift( \"inprogress\" );\n+\t\t\t}\n+\n+\t\t\t\/\/ Clear up the last queue stop function\n+\t\t\tdelete hooks.stop;\n+\t\t\tfn.call( elem, next, hooks );\n+\t\t}\n+\n+\t\tif ( !startLength && hooks ) {\n+\t\t\thooks.empty.fire();\n+\t\t}\n+\t},\n+\n+\t\/\/ Not public - generate a queueHooks object, or return the current one\n+\t_queueHooks: function( elem, type ) {\n+\t\tvar key = type + \"queueHooks\";\n+\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n+\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n+\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n+\t\t\t} )\n+\t\t} );\n+\t}\n+} );\n+\n+jQuery.fn.extend( {\n+\tqueue: function( type, data ) {\n+\t\tvar setter = 2;\n+\n+\t\tif ( typeof type !== \"string\" ) {\n+\t\t\tdata = type;\n+\t\t\ttype = \"fx\";\n+\t\t\tsetter--;\n+\t\t}\n+\n+\t\tif ( arguments.length < setter ) {\n+\t\t\treturn jQuery.queue( this[ 0 ], type );\n+\t\t}\n+\n+\t\treturn data === undefined ?\n+\t\t\tthis :\n+\t\t\tthis.each( function() {\n+\t\t\t\tvar queue = jQuery.queue( this, type, data );\n+\n+\t\t\t\t\/\/ Ensure a hooks for this queue\n+\t\t\t\tjQuery._queueHooks( this, type );\n+\n+\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n+\t\t\t\t\tjQuery.dequeue( this, type );\n+\t\t\t\t}\n+\t\t\t} );\n+\t},\n+\tdequeue: function( type ) {\n+\t\treturn this.each( function() {\n+\t\t\tjQuery.dequeue( this, type );\n+\t\t} );\n+\t},\n+\tclearQueue: function( type ) {\n+\t\treturn this.queue( type || \"fx\", [] );\n+\t},\n+\n+\t\/\/ Get a promise resolved when queues of a certain type\n+\t\/\/ are emptied (fx is the type by default)\n+\tpromise: function( type, obj ) {\n+\t\tvar tmp,\n+\t\t\tcount = 1,\n+\t\t\tdefer = jQuery.Deferred(),\n+\t\t\telements = this,\n+\t\t\ti = this.length,\n+\t\t\tresolve = function() {\n+\t\t\t\tif ( !( --count ) ) {\n+\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\tif ( typeof type !== \"string\" ) {\n+\t\t\tobj = type;\n+\t\t\ttype = undefined;\n+\t\t}\n+\t\ttype = type || \"fx\";\n+\n+\t\twhile ( i-- ) {\n+\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n+\t\t\tif ( tmp && tmp.empty ) {\n+\t\t\t\tcount++;\n+\t\t\t\ttmp.empty.add( resolve );\n+\t\t\t}\n+\t\t}\n+\t\tresolve();\n+\t\treturn defer.promise( obj );\n+\t}\n+} );\n+var pnum = ( \/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)\/ ).source;\n+\n+var rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n+\n+\n+var cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n+\n+var documentElement = document.documentElement;\n+\n+\n+\n+\tvar isAttached = function( elem ) {\n+\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n+\t\t},\n+\t\tcomposed = { composed: true };\n+\n+\t\/\/ Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n+\t\/\/ Check attachment across shadow DOM boundaries when possible (gh-3504)\n+\t\/\/ Support: iOS 10.0-10.2 only\n+\t\/\/ Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n+\t\/\/ leading to errors. We need to check for `getRootNode`.\n+\tif ( documentElement.getRootNode ) {\n+\t\tisAttached = function( elem ) {\n+\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n+\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n+\t\t};\n+\t}\n+var isHiddenWithinTree = function( elem, el ) {\n+\n+\t\t\/\/ isHiddenWithinTree might be called from jQuery#filter function;\n+\t\t\/\/ in that case, element will be second argument\n+\t\telem = el || elem;\n+\n+\t\t\/\/ Inline style trumps all\n+\t\treturn elem.style.display === \"none\" ||\n+\t\t\telem.style.display === \"\" &&\n+\n+\t\t\t\/\/ Otherwise, check computed style\n+\t\t\t\/\/ Support: Firefox <=43 - 45\n+\t\t\t\/\/ Disconnected elements can have computed display: none, so first confirm that elem is\n+\t\t\t\/\/ in the document.\n+\t\t\tisAttached( elem ) &&\n+\n+\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n+\t};\n+\n+\n+\n+function adjustCSS( elem, prop, valueParts, tween ) {\n+\tvar adjusted, scale,\n+\t\tmaxIterations = 20,\n+\t\tcurrentValue = tween ?\n+\t\t\tfunction() {\n+\t\t\t\treturn tween.cur();\n+\t\t\t} :\n+\t\t\tfunction() {\n+\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n+\t\t\t},\n+\t\tinitial = currentValue(),\n+\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n+\n+\t\t\/\/ Starting value computation is required for potential unit mismatches\n+\t\tinitialInUnit = elem.nodeType &&\n+\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n+\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n+\n+\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n+\n+\t\t\/\/ Support: Firefox <=54\n+\t\t\/\/ Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n+\t\tinitial = initial \/ 2;\n+\n+\t\t\/\/ Trust units reported by jQuery.css\n+\t\tunit = unit || initialInUnit[ 3 ];\n+\n+\t\t\/\/ Iteratively approximate from a nonzero starting point\n+\t\tinitialInUnit = +initial || 1;\n+\n+\t\twhile ( maxIterations-- ) {\n+\n+\t\t\t\/\/ Evaluate and update our best guess (doubling guesses that zero out).\n+\t\t\t\/\/ Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n+\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n+\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() \/ initial || 0.5 ) ) <= 0 ) {\n+\t\t\t\tmaxIterations = 0;\n+\t\t\t}\n+\t\t\tinitialInUnit = initialInUnit \/ scale;\n+\n+\t\t}\n+\n+\t\tinitialInUnit = initialInUnit * 2;\n+\t\tjQuery.style( elem, prop, initialInUnit + unit );\n+\n+\t\t\/\/ Make sure we update the tween properties later on\n+\t\tvalueParts = valueParts || [];\n+\t}\n+\n+\tif ( valueParts ) {\n+\t\tinitialInUnit = +initialInUnit || +initial || 0;\n+\n+\t\t\/\/ Apply relative offset (+=\/-=) if specified\n+\t\tadjusted = valueParts[ 1 ] ?\n+\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n+\t\t\t+valueParts[ 2 ];\n+\t\tif ( tween ) {\n+\t\t\ttween.unit = unit;\n+\t\t\ttween.start = initialInUnit;\n+\t\t\ttween.end = adjusted;\n+\t\t}\n+\t}\n+\treturn adjusted;\n+}\n+\n+\n+var defaultDisplayMap = {};\n+\n+function getDefaultDisplay( elem ) {\n+\tvar temp,\n+\t\tdoc = elem.ownerDocument,\n+\t\tnodeName = elem.nodeName,\n+\t\tdisplay = defaultDisplayMap[ nodeName ];\n+\n+\tif ( display ) {\n+\t\treturn display;\n+\t}\n+\n+\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n+\tdisplay = jQuery.css( temp, \"display\" );\n+\n+\ttemp.parentNode.removeChild( temp );\n+\n+\tif ( display === \"none\" ) {\n+\t\tdisplay = \"block\";\n+\t}\n+\tdefaultDisplayMap[ nodeName ] = display;\n+\n+\treturn display;\n+}\n+\n+function showHide( elements, show ) {\n+\tvar display, elem,\n+\t\tvalues = [],\n+\t\tindex = 0,\n+\t\tlength = elements.length;\n+\n+\t\/\/ Determine new display value for elements that need to change\n+\tfor ( ; index < length; index++ ) {\n+\t\telem = elements[ index ];\n+\t\tif ( !elem.style ) {\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tdisplay = elem.style.display;\n+\t\tif ( show ) {\n+\n+\t\t\t\/\/ Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n+\t\t\t\/\/ check is required in this first loop unless we have a nonempty display value (either\n+\t\t\t\/\/ inline or about-to-be-restored)\n+\t\t\tif ( display === \"none\" ) {\n+\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n+\t\t\t\tif ( !values[ index ] ) {\n+\t\t\t\t\telem.style.display = \"\";\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n+\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif ( display !== \"none\" ) {\n+\t\t\t\tvalues[ index ] = \"none\";\n+\n+\t\t\t\t\/\/ Remember what we're overwriting\n+\t\t\t\tdataPriv.set( elem, \"display\", display );\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t\/\/ Set the display of the elements in a second loop to avoid constant reflow\n+\tfor ( index = 0; index < length; index++ ) {\n+\t\tif ( values[ index ] != null ) {\n+\t\t\telements[ index ].style.display = values[ index ];\n+\t\t}\n+\t}\n+\n+\treturn elements;\n+}\n+\n+jQuery.fn.extend( {\n+\tshow: function() {\n+\t\treturn showHide( this, true );\n+\t},\n+\thide: function() {\n+\t\treturn showHide( this );\n+\t},\n+\ttoggle: function( state ) {\n+\t\tif ( typeof state === \"boolean\" ) {\n+\t\t\treturn state ? this.show() : this.hide();\n+\t\t}\n+\n+\t\treturn this.each( function() {\n+\t\t\tif ( isHiddenWithinTree( this ) ) {\n+\t\t\t\tjQuery( this ).show();\n+\t\t\t} else {\n+\t\t\t\tjQuery( this ).hide();\n+\t\t\t}\n+\t\t} );\n+\t}\n+} );\n+var rcheckableType = ( \/^(?:checkbox|radio)$\/i );\n+\n+var rtagName = ( \/<([a-z][^\\\/\\0>\\x20\\t\\r\\n\\f]*)\/i );\n+\n+var rscriptType = ( \/^$|^module$|\\\/(?:java|ecma)script\/i );\n+\n+\n+\n+( function() {\n+\tvar fragment = document.createDocumentFragment(),\n+\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n+\t\tinput = document.createElement( \"input\" );\n+\n+\t\/\/ Support: Android 4.0 - 4.3 only\n+\t\/\/ Check state lost if the name is set (trac-11217)\n+\t\/\/ Support: Windows Web Apps (WWA)\n+\t\/\/ `name` and `type` must use .setAttribute for WWA (trac-14901)\n+\tinput.setAttribute( \"type\", \"radio\" );\n+\tinput.setAttribute( \"checked\", \"checked\" );\n+\tinput.setAttribute( \"name\", \"t\" );\n+\n+\tdiv.appendChild( input );\n+\n+\t\/\/ Support: Android <=4.1 only\n+\t\/\/ Older WebKit doesn't clone checked state correctly in fragments\n+\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n+\n+\t\/\/ Support: IE <=11 only\n+\t\/\/ Make sure textarea (and checkbox) defaultValue is properly cloned\n+\tdiv.innerHTML = \"<textarea>x<\/textarea>\";\n+\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n+\n+\t\/\/ Support: IE <=9 only\n+\t\/\/ IE <=9 replaces <option> tags with their contents when inserted outside of\n+\t\/\/ the select element.\n+\tdiv.innerHTML = \"<option><\/option>\";\n+\tsupport.option = !!div.lastChild;\n+} )();\n+\n+\n+\/\/ We have to close these tags to support XHTML (trac-13200)\n+var wrapMap = {\n+\n+\t\/\/ XHTML parsers do not magically insert elements in the\n+\t\/\/ same way that tag soup parsers do. So we cannot shorten\n+\t\/\/ this by omitting <tbody> or other required elements.\n+\tthead: [ 1, \"<table>\", \"<\/table>\" ],\n+\tcol: [ 2, \"<table><colgroup>\", \"<\/colgroup><\/table>\" ],\n+\ttr: [ 2, \"<table><tbody>\", \"<\/tbody><\/table>\" ],\n+\ttd: [ 3, \"<table><tbody><tr>\", \"<\/tr><\/tbody><\/table>\" ],\n+\n+\t_default: [ 0, \"\", \"\" ]\n+};\n+\n+wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n+wrapMap.th = wrapMap.td;\n+\n+\/\/ Support: IE <=9 only\n+if ( !support.option ) {\n+\twrapMap.optgroup = wrapMap.option = [ 1, \"<select multiple='multiple'>\", \"<\/select>\" ];\n+}\n+\n+\n+function getAll( context, tag ) {\n+\n+\t\/\/ Support: IE <=9 - 11 only\n+\t\/\/ Use typeof to avoid zero-argument method invocation on host objects (trac-15151)\n+\tvar ret;\n+\n+\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n+\t\tret = context.getElementsByTagName( tag || \"*\" );\n+\n+\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n+\t\tret = context.querySelectorAll( tag || \"*\" );\n+\n+\t} else {\n+\t\tret = [];\n+\t}\n+\n+\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n+\t\treturn jQuery.merge( [ context ], ret );\n+\t}\n+\n+\treturn ret;\n+}\n+\n+\n+\/\/ Mark scripts as having already been evaluated\n+function setGlobalEval( elems, refElements ) {\n+\tvar i = 0,\n+\t\tl = elems.length;\n+\n+\tfor ( ; i < l; i++ ) {\n+\t\tdataPriv.set(\n+\t\t\telems[ i ],\n+\t\t\t\"globalEval\",\n+\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n+\t\t);\n+\t}\n+}\n+\n+\n+var rhtml = \/<|&#?\\w+;\/;\n+\n+function buildFragment( elems, context, scripts, selection, ignored ) {\n+\tvar elem, tmp, tag, wrap, attached, j,\n+\t\tfragment = context.createDocumentFragment(),\n+\t\tnodes = [],\n+\t\ti = 0,\n+\t\tl = elems.length;\n+\n+\tfor ( ; i < l; i++ ) {\n+\t\telem = elems[ i ];\n+\n+\t\tif ( elem || elem === 0 ) {\n+\n+\t\t\t\/\/ Add nodes directly\n+\t\t\tif ( toType( elem ) === \"object\" ) {\n+\n+\t\t\t\t\/\/ Support: Android <=4.0 only, PhantomJS 1 only\n+\t\t\t\t\/\/ push.apply(_, arraylike) throws on ancient WebKit\n+\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n+\n+\t\t\t\/\/ Convert non-html into a text node\n+\t\t\t} else if ( !rhtml.test( elem ) ) {\n+\t\t\t\tnodes.push( context.createTextNode( elem ) );\n+\n+\t\t\t\/\/ Convert html into DOM nodes\n+\t\t\t} else {\n+\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n+\n+\t\t\t\t\/\/ Deserialize a standard representation\n+\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n+\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n+\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n+\n+\t\t\t\t\/\/ Descend through wrappers to the right content\n+\t\t\t\tj = wrap[ 0 ];\n+\t\t\t\twhile ( j-- ) {\n+\t\t\t\t\ttmp = tmp.lastChild;\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Support: Android <=4.0 only, PhantomJS 1 only\n+\t\t\t\t\/\/ push.apply(_, arraylike) throws on ancient WebKit\n+\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n+\n+\t\t\t\t\/\/ Remember the top-level container\n+\t\t\t\ttmp = fragment.firstChild;\n+\n+\t\t\t\t\/\/ Ensure the created nodes are orphaned (trac-12392)\n+\t\t\t\ttmp.textContent = \"\";\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t\/\/ Remove wrapper from fragment\n+\tfragment.textContent = \"\";\n+\n+\ti = 0;\n+\twhile ( ( elem = nodes[ i++ ] ) ) {\n+\n+\t\t\/\/ Skip elements already in the context collection (trac-4087)\n+\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n+\t\t\tif ( ignored ) {\n+\t\t\t\tignored.push( elem );\n+\t\t\t}\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tattached = isAttached( elem );\n+\n+\t\t\/\/ Append to fragment\n+\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n+\n+\t\t\/\/ Preserve script evaluation history\n+\t\tif ( attached ) {\n+\t\t\tsetGlobalEval( tmp );\n+\t\t}\n+\n+\t\t\/\/ Capture executables\n+\t\tif ( scripts ) {\n+\t\t\tj = 0;\n+\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n+\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n+\t\t\t\t\tscripts.push( elem );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn fragment;\n+}\n+\n+\n+var rtypenamespace = \/^([^.]*)(?:\\.(.+)|)\/;\n+\n+function returnTrue() {\n+\treturn true;\n+}\n+\n+function returnFalse() {\n+\treturn false;\n+}\n+\n+function on( elem, types, selector, data, fn, one ) {\n+\tvar origFn, type;\n+\n+\t\/\/ Types can be a map of types\/handlers\n+\tif ( typeof types === \"object\" ) {\n+\n+\t\t\/\/ ( types-Object, selector, data )\n+\t\tif ( typeof selector !== \"string\" ) {\n+\n+\t\t\t\/\/ ( types-Object, data )\n+\t\t\tdata = data || selector;\n+\t\t\tselector = undefined;\n+\t\t}\n+\t\tfor ( type in types ) {\n+\t\t\ton( elem, type, selector, data, types[ type ], one );\n+\t\t}\n+\t\treturn elem;\n+\t}\n+\n+\tif ( data == null && fn == null ) {\n+\n+\t\t\/\/ ( types, fn )\n+\t\tfn = selector;\n+\t\tdata = selector = undefined;\n+\t} else if ( fn == null ) {\n+\t\tif ( typeof selector === \"string\" ) {\n+\n+\t\t\t\/\/ ( types, selector, fn )\n+\t\t\tfn = data;\n+\t\t\tdata = undefined;\n+\t\t} else {\n+\n+\t\t\t\/\/ ( types, data, fn )\n+\t\t\tfn = data;\n+\t\t\tdata = selector;\n+\t\t\tselector = undefined;\n+\t\t}\n+\t}\n+\tif ( fn === false ) {\n+\t\tfn = returnFalse;\n+\t} else if ( !fn ) {\n+\t\treturn elem;\n+\t}\n+\n+\tif ( one === 1 ) {\n+\t\torigFn = fn;\n+\t\tfn = function( event ) {\n+\n+\t\t\t\/\/ Can use an empty set, since event contains the info\n+\t\t\tjQuery().off( event );\n+\t\t\treturn origFn.apply( this, arguments );\n+\t\t};\n+\n+\t\t\/\/ Use same guid so caller can remove using origFn\n+\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n+\t}\n+\treturn elem.each( function() {\n+\t\tjQuery.event.add( this, types, fn, data, selector );\n+\t} );\n+}\n+\n+\/*\n+ * Helper functions for managing events -- not part of the public interface.\n+ * Props to Dean Edwards' addEvent library for many of the ideas.\n+ *\/\n+jQuery.event = {\n+\n+\tglobal: {},\n+\n+\tadd: function( elem, types, handler, data, selector ) {\n+\n+\t\tvar handleObjIn, eventHandle, tmp,\n+\t\t\tevents, t, handleObj,\n+\t\t\tspecial, handlers, type, namespaces, origType,\n+\t\t\telemData = dataPriv.get( elem );\n+\n+\t\t\/\/ Only attach events to objects that accept data\n+\t\tif ( !acceptData( elem ) ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ Caller can pass in an object of custom data in lieu of the handler\n+\t\tif ( handler.handler ) {\n+\t\t\thandleObjIn = handler;\n+\t\t\thandler = handleObjIn.handler;\n+\t\t\tselector = handleObjIn.selector;\n+\t\t}\n+\n+\t\t\/\/ Ensure that invalid selectors throw exceptions at attach time\n+\t\t\/\/ Evaluate against documentElement in case elem is a non-element node (e.g., document)\n+\t\tif ( selector ) {\n+\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n+\t\t}\n+\n+\t\t\/\/ Make sure that the handler has a unique ID, used to find\/remove it later\n+\t\tif ( !handler.guid ) {\n+\t\t\thandler.guid = jQuery.guid++;\n+\t\t}\n+\n+\t\t\/\/ Init the element's event structure and main handler, if this is the first\n+\t\tif ( !( events = elemData.events ) ) {\n+\t\t\tevents = elemData.events = Object.create( null );\n+\t\t}\n+\t\tif ( !( eventHandle = elemData.handle ) ) {\n+\t\t\teventHandle = elemData.handle = function( e ) {\n+\n+\t\t\t\t\/\/ Discard the second event of a jQuery.event.trigger() and\n+\t\t\t\t\/\/ when an event is called after a page has unloaded\n+\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n+\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n+\t\t\t};\n+\t\t}\n+\n+\t\t\/\/ Handle multiple events separated by a space\n+\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n+\t\tt = types.length;\n+\t\twhile ( t-- ) {\n+\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n+\t\t\ttype = origType = tmp[ 1 ];\n+\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n+\n+\t\t\t\/\/ There *must* be a type, no attaching namespace-only handlers\n+\t\t\tif ( !type ) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t\/\/ If event changes its type, use the special event handlers for the changed type\n+\t\t\tspecial = jQuery.event.special[ type ] || {};\n+\n+\t\t\t\/\/ If selector defined, determine special event api type, otherwise given type\n+\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n+\n+\t\t\t\/\/ Update special based on newly reset type\n+\t\t\tspecial = jQuery.event.special[ type ] || {};\n+\n+\t\t\t\/\/ handleObj is passed to all event handlers\n+\t\t\thandleObj = jQuery.extend( {\n+\t\t\t\ttype: type,\n+\t\t\t\torigType: origType,\n+\t\t\t\tdata: data,\n+\t\t\t\thandler: handler,\n+\t\t\t\tguid: handler.guid,\n+\t\t\t\tselector: selector,\n+\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n+\t\t\t\tnamespace: namespaces.join( \".\" )\n+\t\t\t}, handleObjIn );\n+\n+\t\t\t\/\/ Init the event handler queue if we're the first\n+\t\t\tif ( !( handlers = events[ type ] ) ) {\n+\t\t\t\thandlers = events[ type ] = [];\n+\t\t\t\thandlers.delegateCount = 0;\n+\n+\t\t\t\t\/\/ Only use addEventListener if the special events handler returns false\n+\t\t\t\tif ( !special.setup ||\n+\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n+\n+\t\t\t\t\tif ( elem.addEventListener ) {\n+\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif ( special.add ) {\n+\t\t\t\tspecial.add.call( elem, handleObj );\n+\n+\t\t\t\tif ( !handleObj.handler.guid ) {\n+\t\t\t\t\thandleObj.handler.guid = handler.guid;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t\/\/ Add to the element's handler list, delegates in front\n+\t\t\tif ( selector ) {\n+\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n+\t\t\t} else {\n+\t\t\t\thandlers.push( handleObj );\n+\t\t\t}\n+\n+\t\t\t\/\/ Keep track of which events have ever been used, for event optimization\n+\t\t\tjQuery.event.global[ type ] = true;\n+\t\t}\n+\n+\t},\n+\n+\t\/\/ Detach an event or set of events from an element\n+\tremove: function( elem, types, handler, selector, mappedTypes ) {\n+\n+\t\tvar j, origCount, tmp,\n+\t\t\tevents, t, handleObj,\n+\t\t\tspecial, handlers, type, namespaces, origType,\n+\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n+\n+\t\tif ( !elemData || !( events = elemData.events ) ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ Once for each type.namespace in types; type may be omitted\n+\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n+\t\tt = types.length;\n+\t\twhile ( t-- ) {\n+\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n+\t\t\ttype = origType = tmp[ 1 ];\n+\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n+\n+\t\t\t\/\/ Unbind all events (on this namespace, if provided) for the element\n+\t\t\tif ( !type ) {\n+\t\t\t\tfor ( type in events ) {\n+\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n+\t\t\t\t}\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tspecial = jQuery.event.special[ type ] || {};\n+\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n+\t\t\thandlers = events[ type ] || [];\n+\t\t\ttmp = tmp[ 2 ] &&\n+\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n+\n+\t\t\t\/\/ Remove matching events\n+\t\t\torigCount = j = handlers.length;\n+\t\t\twhile ( j-- ) {\n+\t\t\t\thandleObj = handlers[ j ];\n+\n+\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n+\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n+\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n+\t\t\t\t\t( !selector || selector === handleObj.selector ||\n+\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n+\t\t\t\t\thandlers.splice( j, 1 );\n+\n+\t\t\t\t\tif ( handleObj.selector ) {\n+\t\t\t\t\t\thandlers.delegateCount--;\n+\t\t\t\t\t}\n+\t\t\t\t\tif ( special.remove ) {\n+\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t\/\/ Remove generic event handler if we removed something and no more handlers exist\n+\t\t\t\/\/ (avoids potential for endless recursion during removal of special event handlers)\n+\t\t\tif ( origCount && !handlers.length ) {\n+\t\t\t\tif ( !special.teardown ||\n+\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n+\n+\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n+\t\t\t\t}\n+\n+\t\t\t\tdelete events[ type ];\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Remove data and the expando if it's no longer used\n+\t\tif ( jQuery.isEmptyObject( events ) ) {\n+\t\t\tdataPriv.remove( elem, \"handle events\" );\n+\t\t}\n+\t},\n+\n+\tdispatch: function( nativeEvent ) {\n+\n+\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n+\t\t\targs = new Array( arguments.length ),\n+\n+\t\t\t\/\/ Make a writable jQuery.Event from the native event object\n+\t\t\tevent = jQuery.event.fix( nativeEvent ),\n+\n+\t\t\thandlers = (\n+\t\t\t\tdataPriv.get( this, \"events\" ) || Object.create( null )\n+\t\t\t)[ event.type ] || [],\n+\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n+\n+\t\t\/\/ Use the fix-ed jQuery.Event rather than the (read-only) native event\n+\t\targs[ 0 ] = event;\n+\n+\t\tfor ( i = 1; i < arguments.length; i++ ) {\n+\t\t\targs[ i ] = arguments[ i ];\n+\t\t}\n+\n+\t\tevent.delegateTarget = this;\n+\n+\t\t\/\/ Call the preDispatch hook for the mapped type, and let it bail if desired\n+\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ Determine handlers\n+\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n+\n+\t\t\/\/ Run delegates first; they may want to stop propagation beneath us\n+\t\ti = 0;\n+\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n+\t\t\tevent.currentTarget = matched.elem;\n+\n+\t\t\tj = 0;\n+\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n+\t\t\t\t!event.isImmediatePropagationStopped() ) {\n+\n+\t\t\t\t\/\/ If the event is namespaced, then each handler is only invoked if it is\n+\t\t\t\t\/\/ specially universal or its namespaces are a superset of the event's.\n+\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n+\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n+\n+\t\t\t\t\tevent.handleObj = handleObj;\n+\t\t\t\t\tevent.data = handleObj.data;\n+\n+\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n+\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n+\n+\t\t\t\t\tif ( ret !== undefined ) {\n+\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n+\t\t\t\t\t\t\tevent.preventDefault();\n+\t\t\t\t\t\t\tevent.stopPropagation();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Call the postDispatch hook for the mapped type\n+\t\tif ( special.postDispatch ) {\n+\t\t\tspecial.postDispatch.call( this, event );\n+\t\t}\n+\n+\t\treturn event.result;\n+\t},\n+\n+\thandlers: function( event, handlers ) {\n+\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n+\t\t\thandlerQueue = [],\n+\t\t\tdelegateCount = handlers.delegateCount,\n+\t\t\tcur = event.target;\n+\n+\t\t\/\/ Find delegate handlers\n+\t\tif ( delegateCount &&\n+\n+\t\t\t\/\/ Support: IE <=9\n+\t\t\t\/\/ Black-hole SVG <use> instance trees (trac-13180)\n+\t\t\tcur.nodeType &&\n+\n+\t\t\t\/\/ Support: Firefox <=42\n+\t\t\t\/\/ Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n+\t\t\t\/\/ https:\/\/www.w3.org\/TR\/DOM-Level-3-Events\/#event-type-click\n+\t\t\t\/\/ Support: IE 11 only\n+\t\t\t\/\/ ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n+\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n+\n+\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n+\n+\t\t\t\t\/\/ Don't check non-elements (trac-13208)\n+\t\t\t\t\/\/ Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n+\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n+\t\t\t\t\tmatchedHandlers = [];\n+\t\t\t\t\tmatchedSelectors = {};\n+\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n+\t\t\t\t\t\thandleObj = handlers[ i ];\n+\n+\t\t\t\t\t\t\/\/ Don't conflict with Object.prototype properties (trac-13203)\n+\t\t\t\t\t\tsel = handleObj.selector + \" \";\n+\n+\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n+\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n+\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n+\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n+\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif ( matchedHandlers.length ) {\n+\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Add the remaining (directly-bound) handlers\n+\t\tcur = this;\n+\t\tif ( delegateCount < handlers.length ) {\n+\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n+\t\t}\n+\n+\t\treturn handlerQueue;\n+\t},\n+\n+\taddProp: function( name, hook ) {\n+\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n+\t\t\tenumerable: true,\n+\t\t\tconfigurable: true,\n+\n+\t\t\tget: isFunction( hook ) ?\n+\t\t\t\tfunction() {\n+\t\t\t\t\tif ( this.originalEvent ) {\n+\t\t\t\t\t\treturn hook( this.originalEvent );\n+\t\t\t\t\t}\n+\t\t\t\t} :\n+\t\t\t\tfunction() {\n+\t\t\t\t\tif ( this.originalEvent ) {\n+\t\t\t\t\t\treturn this.originalEvent[ name ];\n+\t\t\t\t\t}\n+\t\t\t\t},\n+\n+\t\t\tset: function( value ) {\n+\t\t\t\tObject.defineProperty( this, name, {\n+\t\t\t\t\tenumerable: true,\n+\t\t\t\t\tconfigurable: true,\n+\t\t\t\t\twritable: true,\n+\t\t\t\t\tvalue: value\n+\t\t\t\t} );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tfix: function( originalEvent ) {\n+\t\treturn originalEvent[ jQuery.expando ] ?\n+\t\t\toriginalEvent :\n+\t\t\tnew jQuery.Event( originalEvent );\n+\t},\n+\n+\tspecial: {\n+\t\tload: {\n+\n+\t\t\t\/\/ Prevent triggered image.load events from bubbling to window.load\n+\t\t\tnoBubble: true\n+\t\t},\n+\t\tclick: {\n+\n+\t\t\t\/\/ Utilize native event to ensure correct state for checkable inputs\n+\t\t\tsetup: function( data ) {\n+\n+\t\t\t\t\/\/ For mutual compressibility with _default, replace `this` access with a local var.\n+\t\t\t\t\/\/ `|| data` is dead code meant only to preserve the variable through minification.\n+\t\t\t\tvar el = this || data;\n+\n+\t\t\t\t\/\/ Claim the first handler\n+\t\t\t\tif ( rcheckableType.test( el.type ) &&\n+\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n+\n+\t\t\t\t\t\/\/ dataPriv.set( el, \"click\", ... )\n+\t\t\t\t\tleverageNative( el, \"click\", true );\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Return false to allow normal processing in the caller\n+\t\t\t\treturn false;\n+\t\t\t},\n+\t\t\ttrigger: function( data ) {\n+\n+\t\t\t\t\/\/ For mutual compressibility with _default, replace `this` access with a local var.\n+\t\t\t\t\/\/ `|| data` is dead code meant only to preserve the variable through minification.\n+\t\t\t\tvar el = this || data;\n+\n+\t\t\t\t\/\/ Force setup before triggering a click\n+\t\t\t\tif ( rcheckableType.test( el.type ) &&\n+\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n+\n+\t\t\t\t\tleverageNative( el, \"click\" );\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Return non-false to allow normal event-path propagation\n+\t\t\t\treturn true;\n+\t\t\t},\n+\n+\t\t\t\/\/ For cross-browser consistency, suppress native .click() on links\n+\t\t\t\/\/ Also prevent it if we're currently inside a leveraged native-event stack\n+\t\t\t_default: function( event ) {\n+\t\t\t\tvar target = event.target;\n+\t\t\t\treturn rcheckableType.test( target.type ) &&\n+\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n+\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n+\t\t\t\t\tnodeName( target, \"a\" );\n+\t\t\t}\n+\t\t},\n+\n+\t\tbeforeunload: {\n+\t\t\tpostDispatch: function( event ) {\n+\n+\t\t\t\t\/\/ Support: Firefox 20+\n+\t\t\t\t\/\/ Firefox doesn't alert if the returnValue field is not set.\n+\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n+\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+};\n+\n+\/\/ Ensure the presence of an event listener that handles manually-triggered\n+\/\/ synthetic events by interrupting progress until reinvoked in response to\n+\/\/ *native* events that it fires directly, ensuring that state changes have\n+\/\/ already occurred before other listeners are invoked.\n+function leverageNative( el, type, isSetup ) {\n+\n+\t\/\/ Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add\n+\tif ( !isSetup ) {\n+\t\tif ( dataPriv.get( el, type ) === undefined ) {\n+\t\t\tjQuery.event.add( el, type, returnTrue );\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\t\/\/ Register the controller as a special universal handler for all event namespaces\n+\tdataPriv.set( el, type, false );\n+\tjQuery.event.add( el, type, {\n+\t\tnamespace: false,\n+\t\thandler: function( event ) {\n+\t\t\tvar result,\n+\t\t\t\tsaved = dataPriv.get( this, type );\n+\n+\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n+\n+\t\t\t\t\/\/ Interrupt processing of the outer synthetic .trigger()ed event\n+\t\t\t\tif ( !saved ) {\n+\n+\t\t\t\t\t\/\/ Store arguments for use when handling the inner native event\n+\t\t\t\t\t\/\/ There will always be at least one argument (an event object), so this array\n+\t\t\t\t\t\/\/ will not be confused with a leftover capture object.\n+\t\t\t\t\tsaved = slice.call( arguments );\n+\t\t\t\t\tdataPriv.set( this, type, saved );\n+\n+\t\t\t\t\t\/\/ Trigger the native event and capture its result\n+\t\t\t\t\tthis[ type ]();\n+\t\t\t\t\tresult = dataPriv.get( this, type );\n+\t\t\t\t\tdataPriv.set( this, type, false );\n+\n+\t\t\t\t\tif ( saved !== result ) {\n+\n+\t\t\t\t\t\t\/\/ Cancel the outer synthetic event\n+\t\t\t\t\t\tevent.stopImmediatePropagation();\n+\t\t\t\t\t\tevent.preventDefault();\n+\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\/\/ If this is an inner synthetic event for an event with a bubbling surrogate\n+\t\t\t\t\/\/ (focus or blur), assume that the surrogate already propagated from triggering\n+\t\t\t\t\/\/ the native event and prevent that from happening again here.\n+\t\t\t\t\/\/ This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n+\t\t\t\t\/\/ bubbling surrogate propagates *after* the non-bubbling base), but that seems\n+\t\t\t\t\/\/ less bad than duplication.\n+\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n+\t\t\t\t\tevent.stopPropagation();\n+\t\t\t\t}\n+\n+\t\t\t\/\/ If this is a native event triggered above, everything is now in order\n+\t\t\t\/\/ Fire an inner synthetic event with the original arguments\n+\t\t\t} else if ( saved ) {\n+\n+\t\t\t\t\/\/ ...and capture the result\n+\t\t\t\tdataPriv.set( this, type, jQuery.event.trigger(\n+\t\t\t\t\tsaved[ 0 ],\n+\t\t\t\t\tsaved.slice( 1 ),\n+\t\t\t\t\tthis\n+\t\t\t\t) );\n+\n+\t\t\t\t\/\/ Abort handling of the native event by all jQuery handlers while allowing\n+\t\t\t\t\/\/ native handlers on the same element to run. On target, this is achieved\n+\t\t\t\t\/\/ by stopping immediate propagation just on the jQuery event. However,\n+\t\t\t\t\/\/ the native event is re-wrapped by a jQuery one on each level of the\n+\t\t\t\t\/\/ propagation so the only way to stop it for jQuery is to stop it for\n+\t\t\t\t\/\/ everyone via native `stopPropagation()`. This is not a problem for\n+\t\t\t\t\/\/ focus\/blur which don't bubble, but it does also stop click on checkboxes\n+\t\t\t\t\/\/ and radios. We accept this limitation.\n+\t\t\t\tevent.stopPropagation();\n+\t\t\t\tevent.isImmediatePropagationStopped = returnTrue;\n+\t\t\t}\n+\t\t}\n+\t} );\n+}\n+\n+jQuery.removeEvent = function( elem, type, handle ) {\n+\n+\t\/\/ This \"if\" is needed for plain objects\n+\tif ( elem.removeEventListener ) {\n+\t\telem.removeEventListener( type, handle );\n+\t}\n+};\n+\n+jQuery.Event = function( src, props ) {\n+\n+\t\/\/ Allow instantiation without the 'new' keyword\n+\tif ( !( this instanceof jQuery.Event ) ) {\n+\t\treturn new jQuery.Event( src, props );\n+\t}\n+\n+\t\/\/ Event object\n+\tif ( src && src.type ) {\n+\t\tthis.originalEvent = src;\n+\t\tthis.type = src.type;\n+\n+\t\t\/\/ Events bubbling up the document may have been marked as prevented\n+\t\t\/\/ by a handler lower down the tree; reflect the correct value.\n+\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n+\t\t\t\tsrc.defaultPrevented === undefined &&\n+\n+\t\t\t\t\/\/ Support: Android <=2.3 only\n+\t\t\t\tsrc.returnValue === false ?\n+\t\t\treturnTrue :\n+\t\t\treturnFalse;\n+\n+\t\t\/\/ Create target properties\n+\t\t\/\/ Support: Safari <=6 - 7 only\n+\t\t\/\/ Target should not be a text node (trac-504, trac-13143)\n+\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n+\t\t\tsrc.target.parentNode :\n+\t\t\tsrc.target;\n+\n+\t\tthis.currentTarget = src.currentTarget;\n+\t\tthis.relatedTarget = src.relatedTarget;\n+\n+\t\/\/ Event type\n+\t} else {\n+\t\tthis.type = src;\n+\t}\n+\n+\t\/\/ Put explicitly provided properties onto the event object\n+\tif ( props ) {\n+\t\tjQuery.extend( this, props );\n+\t}\n+\n+\t\/\/ Create a timestamp if incoming event doesn't have one\n+\tthis.timeStamp = src && src.timeStamp || Date.now();\n+\n+\t\/\/ Mark it as fixed\n+\tthis[ jQuery.expando ] = true;\n+};\n+\n+\/\/ jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n+\/\/ https:\/\/www.w3.org\/TR\/2003\/WD-DOM-Level-3-Events-20030331\/ecma-script-binding.html\n+jQuery.Event.prototype = {\n+\tconstructor: jQuery.Event,\n+\tisDefaultPrevented: returnFalse,\n+\tisPropagationStopped: returnFalse,\n+\tisImmediatePropagationStopped: returnFalse,\n+\tisSimulated: false,\n+\n+\tpreventDefault: function() {\n+\t\tvar e = this.originalEvent;\n+\n+\t\tthis.isDefaultPrevented = returnTrue;\n+\n+\t\tif ( e && !this.isSimulated ) {\n+\t\t\te.preventDefault();\n+\t\t}\n+\t},\n+\tstopPropagation: function() {\n+\t\tvar e = this.originalEvent;\n+\n+\t\tthis.isPropagationStopped = returnTrue;\n+\n+\t\tif ( e && !this.isSimulated ) {\n+\t\t\te.stopPropagation();\n+\t\t}\n+\t},\n+\tstopImmediatePropagation: function() {\n+\t\tvar e = this.originalEvent;\n+\n+\t\tthis.isImmediatePropagationStopped = returnTrue;\n+\n+\t\tif ( e && !this.isSimulated ) {\n+\t\t\te.stopImmediatePropagation();\n+\t\t}\n+\n+\t\tthis.stopPropagation();\n+\t}\n+};\n+\n+\/\/ Includes all common event props including KeyEvent and MouseEvent specific props\n+jQuery.each( {\n+\taltKey: true,\n+\tbubbles: true,\n+\tcancelable: true,\n+\tchangedTouches: true,\n+\tctrlKey: true,\n+\tdetail: true,\n+\teventPhase: true,\n+\tmetaKey: true,\n+\tpageX: true,\n+\tpageY: true,\n+\tshiftKey: true,\n+\tview: true,\n+\t\"char\": true,\n+\tcode: true,\n+\tcharCode: true,\n+\tkey: true,\n+\tkeyCode: true,\n+\tbutton: true,\n+\tbuttons: true,\n+\tclientX: true,\n+\tclientY: true,\n+\toffsetX: true,\n+\toffsetY: true,\n+\tpointerId: true,\n+\tpointerType: true,\n+\tscreenX: true,\n+\tscreenY: true,\n+\ttargetTouches: true,\n+\ttoElement: true,\n+\ttouches: true,\n+\twhich: true\n+}, jQuery.event.addProp );\n+\n+jQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n+\n+\tfunction focusMappedHandler( nativeEvent ) {\n+\t\tif ( document.documentMode ) {\n+\n+\t\t\t\/\/ Support: IE 11+\n+\t\t\t\/\/ Attach a single focusin\/focusout handler on the document while someone wants\n+\t\t\t\/\/ focus\/blur. This is because the former are synchronous in IE while the latter\n+\t\t\t\/\/ are async. In other browsers, all those handlers are invoked synchronously.\n+\n+\t\t\t\/\/ `handle` from private data would already wrap the event, but we need\n+\t\t\t\/\/ to change the `type` here.\n+\t\t\tvar handle = dataPriv.get( this, \"handle\" ),\n+\t\t\t\tevent = jQuery.event.fix( nativeEvent );\n+\t\t\tevent.type = nativeEvent.type === \"focusin\" ? \"focus\" : \"blur\";\n+\t\t\tevent.isSimulated = true;\n+\n+\t\t\t\/\/ First, handle focusin\/focusout\n+\t\t\thandle( nativeEvent );\n+\n+\t\t\t\/\/ ...then, handle focus\/blur\n+\t\t\t\/\/\n+\t\t\t\/\/ focus\/blur don't bubble while focusin\/focusout do; simulate the former by only\n+\t\t\t\/\/ invoking the handler at the lower level.\n+\t\t\tif ( event.target === event.currentTarget ) {\n+\n+\t\t\t\t\/\/ The setup part calls `leverageNative`, which, in turn, calls\n+\t\t\t\t\/\/ `jQuery.event.add`, so event handle will already have been set\n+\t\t\t\t\/\/ by this point.\n+\t\t\t\thandle( event );\n+\t\t\t}\n+\t\t} else {\n+\n+\t\t\t\/\/ For non-IE browsers, attach a single capturing handler on the document\n+\t\t\t\/\/ while someone wants focusin\/focusout.\n+\t\t\tjQuery.event.simulate( delegateType, nativeEvent.target,\n+\t\t\t\tjQuery.event.fix( nativeEvent ) );\n+\t\t}\n+\t}\n+\n+\tjQuery.event.special[ type ] = {\n+\n+\t\t\/\/ Utilize native event if possible so blur\/focus sequence is correct\n+\t\tsetup: function() {\n+\n+\t\t\tvar attaches;\n+\n+\t\t\t\/\/ Claim the first handler\n+\t\t\t\/\/ dataPriv.set( this, \"focus\", ... )\n+\t\t\t\/\/ dataPriv.set( this, \"blur\", ... )\n+\t\t\tleverageNative( this, type, true );\n+\n+\t\t\tif ( document.documentMode ) {\n+\n+\t\t\t\t\/\/ Support: IE 9 - 11+\n+\t\t\t\t\/\/ We use the same native handler for focusin & focus (and focusout & blur)\n+\t\t\t\t\/\/ so we need to coordinate setup & teardown parts between those events.\n+\t\t\t\t\/\/ Use `delegateType` as the key as `type` is already used by `leverageNative`.\n+\t\t\t\tattaches = dataPriv.get( this, delegateType );\n+\t\t\t\tif ( !attaches ) {\n+\t\t\t\t\tthis.addEventListener( delegateType, focusMappedHandler );\n+\t\t\t\t}\n+\t\t\t\tdataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );\n+\t\t\t} else {\n+\n+\t\t\t\t\/\/ Return false to allow normal processing in the caller\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t},\n+\t\ttrigger: function() {\n+\n+\t\t\t\/\/ Force setup before trigger\n+\t\t\tleverageNative( this, type );\n+\n+\t\t\t\/\/ Return non-false to allow normal event-path propagation\n+\t\t\treturn true;\n+\t\t},\n+\n+\t\tteardown: function() {\n+\t\t\tvar attaches;\n+\n+\t\t\tif ( document.documentMode ) {\n+\t\t\t\tattaches = dataPriv.get( this, delegateType ) - 1;\n+\t\t\t\tif ( !attaches ) {\n+\t\t\t\t\tthis.removeEventListener( delegateType, focusMappedHandler );\n+\t\t\t\t\tdataPriv.remove( this, delegateType );\n+\t\t\t\t} else {\n+\t\t\t\t\tdataPriv.set( this, delegateType, attaches );\n+\t\t\t\t}\n+\t\t\t} else {\n+\n+\t\t\t\t\/\/ Return false to indicate standard teardown should be applied\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t},\n+\n+\t\t\/\/ Suppress native focus or blur if we're currently inside\n+\t\t\/\/ a leveraged native-event stack\n+\t\t_default: function( event ) {\n+\t\t\treturn dataPriv.get( event.target, type );\n+\t\t},\n+\n+\t\tdelegateType: delegateType\n+\t};\n+\n+\t\/\/ Support: Firefox <=44\n+\t\/\/ Firefox doesn't have focus(in | out) events\n+\t\/\/ Related ticket - https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=687787\n+\t\/\/\n+\t\/\/ Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n+\t\/\/ focus(in | out) events fire after focus & blur events,\n+\t\/\/ which is spec violation - http:\/\/www.w3.org\/TR\/DOM-Level-3-Events\/#events-focusevent-event-order\n+\t\/\/ Related ticket - https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=449857\n+\t\/\/\n+\t\/\/ Support: IE 9 - 11+\n+\t\/\/ To preserve relative focusin\/focus & focusout\/blur event order guaranteed on the 3.x branch,\n+\t\/\/ attach a single handler for both events in IE.\n+\tjQuery.event.special[ delegateType ] = {\n+\t\tsetup: function() {\n+\n+\t\t\t\/\/ Handle: regular nodes (via `this.ownerDocument`), window\n+\t\t\t\/\/ (via `this.document`) & document (via `this`).\n+\t\t\tvar doc = this.ownerDocument || this.document || this,\n+\t\t\t\tdataHolder = document.documentMode ? this : doc,\n+\t\t\t\tattaches = dataPriv.get( dataHolder, delegateType );\n+\n+\t\t\t\/\/ Support: IE 9 - 11+\n+\t\t\t\/\/ We use the same native handler for focusin & focus (and focusout & blur)\n+\t\t\t\/\/ so we need to coordinate setup & teardown parts between those events.\n+\t\t\t\/\/ Use `delegateType` as the key as `type` is already used by `leverageNative`.\n+\t\t\tif ( !attaches ) {\n+\t\t\t\tif ( document.documentMode ) {\n+\t\t\t\t\tthis.addEventListener( delegateType, focusMappedHandler );\n+\t\t\t\t} else {\n+\t\t\t\t\tdoc.addEventListener( type, focusMappedHandler, true );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tdataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );\n+\t\t},\n+\t\tteardown: function() {\n+\t\t\tvar doc = this.ownerDocument || this.document || this,\n+\t\t\t\tdataHolder = document.documentMode ? this : doc,\n+\t\t\t\tattaches = dataPriv.get( dataHolder, delegateType ) - 1;\n+\n+\t\t\tif ( !attaches ) {\n+\t\t\t\tif ( document.documentMode ) {\n+\t\t\t\t\tthis.removeEventListener( delegateType, focusMappedHandler );\n+\t\t\t\t} else {\n+\t\t\t\t\tdoc.removeEventListener( type, focusMappedHandler, true );\n+\t\t\t\t}\n+\t\t\t\tdataPriv.remove( dataHolder, delegateType );\n+\t\t\t} else {\n+\t\t\t\tdataPriv.set( dataHolder, delegateType, attaches );\n+\t\t\t}\n+\t\t}\n+\t};\n+} );\n+\n+\/\/ Create mouseenter\/leave events using mouseover\/out and event-time checks\n+\/\/ so that event delegation works in jQuery.\n+\/\/ Do the same for pointerenter\/pointerleave and pointerover\/pointerout\n+\/\/\n+\/\/ Support: Safari 7 only\n+\/\/ Safari sends mouseenter too often; see:\n+\/\/ https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=470258\n+\/\/ for the description of the bug (it existed in older Chrome versions as well).\n+jQuery.each( {\n+\tmouseenter: \"mouseover\",\n+\tmouseleave: \"mouseout\",\n+\tpointerenter: \"pointerover\",\n+\tpointerleave: \"pointerout\"\n+}, function( orig, fix ) {\n+\tjQuery.event.special[ orig ] = {\n+\t\tdelegateType: fix,\n+\t\tbindType: fix,\n+\n+\t\thandle: function( event ) {\n+\t\t\tvar ret,\n+\t\t\t\ttarget = this,\n+\t\t\t\trelated = event.relatedTarget,\n+\t\t\t\thandleObj = event.handleObj;\n+\n+\t\t\t\/\/ For mouseenter\/leave call the handler if related is outside the target.\n+\t\t\t\/\/ NB: No relatedTarget if the mouse left\/entered the browser window\n+\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n+\t\t\t\tevent.type = handleObj.origType;\n+\t\t\t\tret = handleObj.handler.apply( this, arguments );\n+\t\t\t\tevent.type = fix;\n+\t\t\t}\n+\t\t\treturn ret;\n+\t\t}\n+\t};\n+} );\n+\n+jQuery.fn.extend( {\n+\n+\ton: function( types, selector, data, fn ) {\n+\t\treturn on( this, types, selector, data, fn );\n+\t},\n+\tone: function( types, selector, data, fn ) {\n+\t\treturn on( this, types, selector, data, fn, 1 );\n+\t},\n+\toff: function( types, selector, fn ) {\n+\t\tvar handleObj, type;\n+\t\tif ( types && types.preventDefault && types.handleObj ) {\n+\n+\t\t\t\/\/ ( event )  dispatched jQuery.Event\n+\t\t\thandleObj = types.handleObj;\n+\t\t\tjQuery( types.delegateTarget ).off(\n+\t\t\t\thandleObj.namespace ?\n+\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n+\t\t\t\t\thandleObj.origType,\n+\t\t\t\thandleObj.selector,\n+\t\t\t\thandleObj.handler\n+\t\t\t);\n+\t\t\treturn this;\n+\t\t}\n+\t\tif ( typeof types === \"object\" ) {\n+\n+\t\t\t\/\/ ( types-object [, selector] )\n+\t\t\tfor ( type in types ) {\n+\t\t\t\tthis.off( type, selector, types[ type ] );\n+\t\t\t}\n+\t\t\treturn this;\n+\t\t}\n+\t\tif ( selector === false || typeof selector === \"function\" ) {\n+\n+\t\t\t\/\/ ( types [, fn] )\n+\t\t\tfn = selector;\n+\t\t\tselector = undefined;\n+\t\t}\n+\t\tif ( fn === false ) {\n+\t\t\tfn = returnFalse;\n+\t\t}\n+\t\treturn this.each( function() {\n+\t\t\tjQuery.event.remove( this, types, fn, selector );\n+\t\t} );\n+\t}\n+} );\n+\n+\n+var\n+\n+\t\/\/ Support: IE <=10 - 11, Edge 12 - 13 only\n+\t\/\/ In IE\/Edge using regex groups here causes severe slowdowns.\n+\t\/\/ See https:\/\/connect.microsoft.com\/IE\/feedback\/details\/1736512\/\n+\trnoInnerhtml = \/<script|<style|<link\/i,\n+\n+\t\/\/ checked=\"checked\" or checked\n+\trchecked = \/checked\\s*(?:[^=]|=\\s*.checked.)\/i,\n+\n+\trcleanScript = \/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$\/g;\n+\n+\/\/ Prefer a tbody over its parent table for containing new rows\n+function manipulationTarget( elem, content ) {\n+\tif ( nodeName( elem, \"table\" ) &&\n+\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n+\n+\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n+\t}\n+\n+\treturn elem;\n+}\n+\n+\/\/ Replace\/restore the type attribute of script elements for safe DOM manipulation\n+function disableScript( elem ) {\n+\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"\/\" + elem.type;\n+\treturn elem;\n+}\n+function restoreScript( elem ) {\n+\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true\/\" ) {\n+\t\telem.type = elem.type.slice( 5 );\n+\t} else {\n+\t\telem.removeAttribute( \"type\" );\n+\t}\n+\n+\treturn elem;\n+}\n+\n+function cloneCopyEvent( src, dest ) {\n+\tvar i, l, type, pdataOld, udataOld, udataCur, events;\n+\n+\tif ( dest.nodeType !== 1 ) {\n+\t\treturn;\n+\t}\n+\n+\t\/\/ 1. Copy private data: events, handlers, etc.\n+\tif ( dataPriv.hasData( src ) ) {\n+\t\tpdataOld = dataPriv.get( src );\n+\t\tevents = pdataOld.events;\n+\n+\t\tif ( events ) {\n+\t\t\tdataPriv.remove( dest, \"handle events\" );\n+\n+\t\t\tfor ( type in events ) {\n+\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n+\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t\/\/ 2. Copy user data\n+\tif ( dataUser.hasData( src ) ) {\n+\t\tudataOld = dataUser.access( src );\n+\t\tudataCur = jQuery.extend( {}, udataOld );\n+\n+\t\tdataUser.set( dest, udataCur );\n+\t}\n+}\n+\n+\/\/ Fix IE bugs, see support tests\n+function fixInput( src, dest ) {\n+\tvar nodeName = dest.nodeName.toLowerCase();\n+\n+\t\/\/ Fails to persist the checked state of a cloned checkbox or radio button.\n+\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n+\t\tdest.checked = src.checked;\n+\n+\t\/\/ Fails to return the selected option to the default selected state when cloning options\n+\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n+\t\tdest.defaultValue = src.defaultValue;\n+\t}\n+}\n+\n+function domManip( collection, args, callback, ignored ) {\n+\n+\t\/\/ Flatten any nested arrays\n+\targs = flat( args );\n+\n+\tvar fragment, first, scripts, hasScripts, node, doc,\n+\t\ti = 0,\n+\t\tl = collection.length,\n+\t\tiNoClone = l - 1,\n+\t\tvalue = args[ 0 ],\n+\t\tvalueIsFunction = isFunction( value );\n+\n+\t\/\/ We can't cloneNode fragments that contain checked, in WebKit\n+\tif ( valueIsFunction ||\n+\t\t\t( l > 1 && typeof value === \"string\" &&\n+\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n+\t\treturn collection.each( function( index ) {\n+\t\t\tvar self = collection.eq( index );\n+\t\t\tif ( valueIsFunction ) {\n+\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n+\t\t\t}\n+\t\t\tdomManip( self, args, callback, ignored );\n+\t\t} );\n+\t}\n+\n+\tif ( l ) {\n+\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n+\t\tfirst = fragment.firstChild;\n+\n+\t\tif ( fragment.childNodes.length === 1 ) {\n+\t\t\tfragment = first;\n+\t\t}\n+\n+\t\t\/\/ Require either new content or an interest in ignored elements to invoke the callback\n+\t\tif ( first || ignored ) {\n+\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n+\t\t\thasScripts = scripts.length;\n+\n+\t\t\t\/\/ Use the original fragment for the last item\n+\t\t\t\/\/ instead of the first because it can end up\n+\t\t\t\/\/ being emptied incorrectly in certain situations (trac-8070).\n+\t\t\tfor ( ; i < l; i++ ) {\n+\t\t\t\tnode = fragment;\n+\n+\t\t\t\tif ( i !== iNoClone ) {\n+\t\t\t\t\tnode = jQuery.clone( node, true, true );\n+\n+\t\t\t\t\t\/\/ Keep references to cloned scripts for later restoration\n+\t\t\t\t\tif ( hasScripts ) {\n+\n+\t\t\t\t\t\t\/\/ Support: Android <=4.0 only, PhantomJS 1 only\n+\t\t\t\t\t\t\/\/ push.apply(_, arraylike) throws on ancient WebKit\n+\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tcallback.call( collection[ i ], node, i );\n+\t\t\t}\n+\n+\t\t\tif ( hasScripts ) {\n+\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n+\n+\t\t\t\t\/\/ Re-enable scripts\n+\t\t\t\tjQuery.map( scripts, restoreScript );\n+\n+\t\t\t\t\/\/ Evaluate executable scripts on first document insertion\n+\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n+\t\t\t\t\tnode = scripts[ i ];\n+\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n+\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n+\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n+\n+\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n+\n+\t\t\t\t\t\t\t\/\/ Optional AJAX dependency, but won't run scripts if not present\n+\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n+\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n+\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n+\t\t\t\t\t\t\t\t}, doc );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t\/\/ Unwrap a CDATA section containing script contents. This shouldn't be\n+\t\t\t\t\t\t\t\/\/ needed as in XML documents they're already not visible when\n+\t\t\t\t\t\t\t\/\/ inspecting element contents and in HTML documents they have no\n+\t\t\t\t\t\t\t\/\/ meaning but we're preserving that logic for backwards compatibility.\n+\t\t\t\t\t\t\t\/\/ This will be removed completely in 4.0. See gh-4904.\n+\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn collection;\n+}\n+\n+function remove( elem, selector, keepData ) {\n+\tvar node,\n+\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n+\t\ti = 0;\n+\n+\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n+\t\tif ( !keepData && node.nodeType === 1 ) {\n+\t\t\tjQuery.cleanData( getAll( node ) );\n+\t\t}\n+\n+\t\tif ( node.parentNode ) {\n+\t\t\tif ( keepData && isAttached( node ) ) {\n+\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n+\t\t\t}\n+\t\t\tnode.parentNode.removeChild( node );\n+\t\t}\n+\t}\n+\n+\treturn elem;\n+}\n+\n+jQuery.extend( {\n+\thtmlPrefilter: function( html ) {\n+\t\treturn html;\n+\t},\n+\n+\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n+\t\tvar i, l, srcElements, destElements,\n+\t\t\tclone = elem.cloneNode( true ),\n+\t\t\tinPage = isAttached( elem );\n+\n+\t\t\/\/ Fix IE cloning issues\n+\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n+\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n+\n+\t\t\t\/\/ We eschew jQuery#find here for performance reasons:\n+\t\t\t\/\/ https:\/\/jsperf.com\/getall-vs-sizzle\/2\n+\t\t\tdestElements = getAll( clone );\n+\t\t\tsrcElements = getAll( elem );\n+\n+\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n+\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Copy the events from the original to the clone\n+\t\tif ( dataAndEvents ) {\n+\t\t\tif ( deepDataAndEvents ) {\n+\t\t\t\tsrcElements = srcElements || getAll( elem );\n+\t\t\t\tdestElements = destElements || getAll( clone );\n+\n+\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n+\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tcloneCopyEvent( elem, clone );\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Preserve script evaluation history\n+\t\tdestElements = getAll( clone, \"script\" );\n+\t\tif ( destElements.length > 0 ) {\n+\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n+\t\t}\n+\n+\t\t\/\/ Return the cloned set\n+\t\treturn clone;\n+\t},\n+\n+\tcleanData: function( elems ) {\n+\t\tvar data, elem, type,\n+\t\t\tspecial = jQuery.event.special,\n+\t\t\ti = 0;\n+\n+\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n+\t\t\tif ( acceptData( elem ) ) {\n+\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n+\t\t\t\t\tif ( data.events ) {\n+\t\t\t\t\t\tfor ( type in data.events ) {\n+\t\t\t\t\t\t\tif ( special[ type ] ) {\n+\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n+\n+\t\t\t\t\t\t\t\/\/ This is a shortcut to avoid jQuery.event.remove's overhead\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t\/\/ Support: Chrome <=35 - 45+\n+\t\t\t\t\t\/\/ Assign undefined instead of using delete, see Data#remove\n+\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n+\t\t\t\t}\n+\t\t\t\tif ( elem[ dataUser.expando ] ) {\n+\n+\t\t\t\t\t\/\/ Support: Chrome <=35 - 45+\n+\t\t\t\t\t\/\/ Assign undefined instead of using delete, see Data#remove\n+\t\t\t\t\telem[ dataUser.expando ] = undefined;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+} );\n+\n+jQuery.fn.extend( {\n+\tdetach: function( selector ) {\n+\t\treturn remove( this, selector, true );\n+\t},\n+\n+\tremove: function( selector ) {\n+\t\treturn remove( this, selector );\n+\t},\n+\n+\ttext: function( value ) {\n+\t\treturn access( this, function( value ) {\n+\t\t\treturn value === undefined ?\n+\t\t\t\tjQuery.text( this ) :\n+\t\t\t\tthis.empty().each( function() {\n+\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n+\t\t\t\t\t\tthis.textContent = value;\n+\t\t\t\t\t}\n+\t\t\t\t} );\n+\t\t}, null, value, arguments.length );\n+\t},\n+\n+\tappend: function() {\n+\t\treturn domManip( this, arguments, function( elem ) {\n+\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n+\t\t\t\tvar target = manipulationTarget( this, elem );\n+\t\t\t\ttarget.appendChild( elem );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tprepend: function() {\n+\t\treturn domManip( this, arguments, function( elem ) {\n+\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n+\t\t\t\tvar target = manipulationTarget( this, elem );\n+\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tbefore: function() {\n+\t\treturn domManip( this, arguments, function( elem ) {\n+\t\t\tif ( this.parentNode ) {\n+\t\t\t\tthis.parentNode.insertBefore( elem, this );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tafter: function() {\n+\t\treturn domManip( this, arguments, function( elem ) {\n+\t\t\tif ( this.parentNode ) {\n+\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tempty: function() {\n+\t\tvar elem,\n+\t\t\ti = 0;\n+\n+\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n+\t\t\tif ( elem.nodeType === 1 ) {\n+\n+\t\t\t\t\/\/ Prevent memory leaks\n+\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n+\n+\t\t\t\t\/\/ Remove any remaining nodes\n+\t\t\t\telem.textContent = \"\";\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn this;\n+\t},\n+\n+\tclone: function( dataAndEvents, deepDataAndEvents ) {\n+\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n+\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n+\n+\t\treturn this.map( function() {\n+\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n+\t\t} );\n+\t},\n+\n+\thtml: function( value ) {\n+\t\treturn access( this, function( value ) {\n+\t\t\tvar elem = this[ 0 ] || {},\n+\t\t\t\ti = 0,\n+\t\t\t\tl = this.length;\n+\n+\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n+\t\t\t\treturn elem.innerHTML;\n+\t\t\t}\n+\n+\t\t\t\/\/ See if we can take a shortcut and just use innerHTML\n+\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n+\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n+\n+\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tfor ( ; i < l; i++ ) {\n+\t\t\t\t\t\telem = this[ i ] || {};\n+\n+\t\t\t\t\t\t\/\/ Remove element nodes and prevent memory leaks\n+\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n+\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n+\t\t\t\t\t\t\telem.innerHTML = value;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\telem = 0;\n+\n+\t\t\t\t\/\/ If using innerHTML throws an exception, use the fallback method\n+\t\t\t\t} catch ( e ) {}\n+\t\t\t}\n+\n+\t\t\tif ( elem ) {\n+\t\t\t\tthis.empty().append( value );\n+\t\t\t}\n+\t\t}, null, value, arguments.length );\n+\t},\n+\n+\treplaceWith: function() {\n+\t\tvar ignored = [];\n+\n+\t\t\/\/ Make the changes, replacing each non-ignored context element with the new content\n+\t\treturn domManip( this, arguments, function( elem ) {\n+\t\t\tvar parent = this.parentNode;\n+\n+\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n+\t\t\t\tjQuery.cleanData( getAll( this ) );\n+\t\t\t\tif ( parent ) {\n+\t\t\t\t\tparent.replaceChild( elem, this );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\/\/ Force callback invocation\n+\t\t}, ignored );\n+\t}\n+} );\n+\n+jQuery.each( {\n+\tappendTo: \"append\",\n+\tprependTo: \"prepend\",\n+\tinsertBefore: \"before\",\n+\tinsertAfter: \"after\",\n+\treplaceAll: \"replaceWith\"\n+}, function( name, original ) {\n+\tjQuery.fn[ name ] = function( selector ) {\n+\t\tvar elems,\n+\t\t\tret = [],\n+\t\t\tinsert = jQuery( selector ),\n+\t\t\tlast = insert.length - 1,\n+\t\t\ti = 0;\n+\n+\t\tfor ( ; i <= last; i++ ) {\n+\t\t\telems = i === last ? this : this.clone( true );\n+\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n+\n+\t\t\t\/\/ Support: Android <=4.0 only, PhantomJS 1 only\n+\t\t\t\/\/ .get() because push.apply(_, arraylike) throws on ancient WebKit\n+\t\t\tpush.apply( ret, elems.get() );\n+\t\t}\n+\n+\t\treturn this.pushStack( ret );\n+\t};\n+} );\n+var rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n+\n+var rcustomProp = \/^--\/;\n+\n+\n+var getStyles = function( elem ) {\n+\n+\t\t\/\/ Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)\n+\t\t\/\/ IE throws on elements created in popups\n+\t\t\/\/ FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n+\t\tvar view = elem.ownerDocument.defaultView;\n+\n+\t\tif ( !view || !view.opener ) {\n+\t\t\tview = window;\n+\t\t}\n+\n+\t\treturn view.getComputedStyle( elem );\n+\t};\n+\n+var swap = function( elem, options, callback ) {\n+\tvar ret, name,\n+\t\told = {};\n+\n+\t\/\/ Remember the old values, and insert the new ones\n+\tfor ( name in options ) {\n+\t\told[ name ] = elem.style[ name ];\n+\t\telem.style[ name ] = options[ name ];\n+\t}\n+\n+\tret = callback.call( elem );\n+\n+\t\/\/ Revert the old values\n+\tfor ( name in options ) {\n+\t\telem.style[ name ] = old[ name ];\n+\t}\n+\n+\treturn ret;\n+};\n+\n+\n+var rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n+\n+\n+\n+( function() {\n+\n+\t\/\/ Executing both pixelPosition & boxSizingReliable tests require only one layout\n+\t\/\/ so they're executed at the same time to save the second computation.\n+\tfunction computeStyleTests() {\n+\n+\t\t\/\/ This is a singleton, we need to execute it only once\n+\t\tif ( !div ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n+\t\t\t\"margin-top:1px;padding:0;border:0\";\n+\t\tdiv.style.cssText =\n+\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n+\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n+\t\t\t\"width:60%;top:1%\";\n+\t\tdocumentElement.appendChild( container ).appendChild( div );\n+\n+\t\tvar divStyle = window.getComputedStyle( div );\n+\t\tpixelPositionVal = divStyle.top !== \"1%\";\n+\n+\t\t\/\/ Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n+\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n+\n+\t\t\/\/ Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n+\t\t\/\/ Some styles come back with percentage values, even though they shouldn't\n+\t\tdiv.style.right = \"60%\";\n+\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n+\n+\t\t\/\/ Support: IE 9 - 11 only\n+\t\t\/\/ Detect misreporting of content dimensions for box-sizing:border-box elements\n+\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n+\n+\t\t\/\/ Support: IE 9 only\n+\t\t\/\/ Detect overflow:scroll screwiness (gh-3699)\n+\t\t\/\/ Support: Chrome <=64\n+\t\t\/\/ Don't get tricked when zoom affects offsetWidth (gh-4029)\n+\t\tdiv.style.position = \"absolute\";\n+\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth \/ 3 ) === 12;\n+\n+\t\tdocumentElement.removeChild( container );\n+\n+\t\t\/\/ Nullify the div so it wouldn't be stored in the memory and\n+\t\t\/\/ it will also be a sign that checks already performed\n+\t\tdiv = null;\n+\t}\n+\n+\tfunction roundPixelMeasures( measure ) {\n+\t\treturn Math.round( parseFloat( measure ) );\n+\t}\n+\n+\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n+\t\treliableTrDimensionsVal, reliableMarginLeftVal,\n+\t\tcontainer = document.createElement( \"div\" ),\n+\t\tdiv = document.createElement( \"div\" );\n+\n+\t\/\/ Finish early in limited (non-browser) environments\n+\tif ( !div.style ) {\n+\t\treturn;\n+\t}\n+\n+\t\/\/ Support: IE <=9 - 11 only\n+\t\/\/ Style of cloned element affects source element cloned (trac-8908)\n+\tdiv.style.backgroundClip = \"content-box\";\n+\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n+\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n+\n+\tjQuery.extend( support, {\n+\t\tboxSizingReliable: function() {\n+\t\t\tcomputeStyleTests();\n+\t\t\treturn boxSizingReliableVal;\n+\t\t},\n+\t\tpixelBoxStyles: function() {\n+\t\t\tcomputeStyleTests();\n+\t\t\treturn pixelBoxStylesVal;\n+\t\t},\n+\t\tpixelPosition: function() {\n+\t\t\tcomputeStyleTests();\n+\t\t\treturn pixelPositionVal;\n+\t\t},\n+\t\treliableMarginLeft: function() {\n+\t\t\tcomputeStyleTests();\n+\t\t\treturn reliableMarginLeftVal;\n+\t\t},\n+\t\tscrollboxSize: function() {\n+\t\t\tcomputeStyleTests();\n+\t\t\treturn scrollboxSizeVal;\n+\t\t},\n+\n+\t\t\/\/ Support: IE 9 - 11+, Edge 15 - 18+\n+\t\t\/\/ IE\/Edge misreport `getComputedStyle` of table rows with width\/height\n+\t\t\/\/ set in CSS while `offset*` properties report correct values.\n+\t\t\/\/ Behavior in IE 9 is more subtle than in newer versions & it passes\n+\t\t\/\/ some versions of this test; make sure not to make it pass there!\n+\t\t\/\/\n+\t\t\/\/ Support: Firefox 70+\n+\t\t\/\/ Only Firefox includes border widths\n+\t\t\/\/ in computed dimensions. (gh-4529)\n+\t\treliableTrDimensions: function() {\n+\t\t\tvar table, tr, trChild, trStyle;\n+\t\t\tif ( reliableTrDimensionsVal == null ) {\n+\t\t\t\ttable = document.createElement( \"table\" );\n+\t\t\t\ttr = document.createElement( \"tr\" );\n+\t\t\t\ttrChild = document.createElement( \"div\" );\n+\n+\t\t\t\ttable.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n+\t\t\t\ttr.style.cssText = \"box-sizing:content-box;border:1px solid\";\n+\n+\t\t\t\t\/\/ Support: Chrome 86+\n+\t\t\t\t\/\/ Height set through cssText does not get applied.\n+\t\t\t\t\/\/ Computed height then comes back as 0.\n+\t\t\t\ttr.style.height = \"1px\";\n+\t\t\t\ttrChild.style.height = \"9px\";\n+\n+\t\t\t\t\/\/ Support: Android 8 Chrome 86+\n+\t\t\t\t\/\/ In our bodyBackground.html iframe,\n+\t\t\t\t\/\/ display for all div elements is set to \"inline\",\n+\t\t\t\t\/\/ which causes a problem only in Android 8 Chrome 86.\n+\t\t\t\t\/\/ Ensuring the div is `display: block`\n+\t\t\t\t\/\/ gets around this issue.\n+\t\t\t\ttrChild.style.display = \"block\";\n+\n+\t\t\t\tdocumentElement\n+\t\t\t\t\t.appendChild( table )\n+\t\t\t\t\t.appendChild( tr )\n+\t\t\t\t\t.appendChild( trChild );\n+\n+\t\t\t\ttrStyle = window.getComputedStyle( tr );\n+\t\t\t\treliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +\n+\t\t\t\t\tparseInt( trStyle.borderTopWidth, 10 ) +\n+\t\t\t\t\tparseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;\n+\n+\t\t\t\tdocumentElement.removeChild( table );\n+\t\t\t}\n+\t\t\treturn reliableTrDimensionsVal;\n+\t\t}\n+\t} );\n+} )();\n+\n+\n+function curCSS( elem, name, computed ) {\n+\tvar width, minWidth, maxWidth, ret,\n+\t\tisCustomProp = rcustomProp.test( name ),\n+\n+\t\t\/\/ Support: Firefox 51+\n+\t\t\/\/ Retrieving style before computed somehow\n+\t\t\/\/ fixes an issue with getting wrong values\n+\t\t\/\/ on detached elements\n+\t\tstyle = elem.style;\n+\n+\tcomputed = computed || getStyles( elem );\n+\n+\t\/\/ getPropertyValue is needed for:\n+\t\/\/   .css('filter') (IE 9 only, trac-12537)\n+\t\/\/   .css('--customProperty) (gh-3144)\n+\tif ( computed ) {\n+\n+\t\t\/\/ Support: IE <=9 - 11+\n+\t\t\/\/ IE only supports `\"float\"` in `getPropertyValue`; in computed styles\n+\t\t\/\/ it's only available as `\"cssFloat\"`. We no longer modify properties\n+\t\t\/\/ sent to `.css()` apart from camelCasing, so we need to check both.\n+\t\t\/\/ Normally, this would create difference in behavior: if\n+\t\t\/\/ `getPropertyValue` returns an empty string, the value returned\n+\t\t\/\/ by `.css()` would be `undefined`. This is usually the case for\n+\t\t\/\/ disconnected elements. However, in IE even disconnected elements\n+\t\t\/\/ with no styles return `\"none\"` for `getPropertyValue( \"float\" )`\n+\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n+\n+\t\tif ( isCustomProp && ret ) {\n+\n+\t\t\t\/\/ Support: Firefox 105+, Chrome <=105+\n+\t\t\t\/\/ Spec requires trimming whitespace for custom properties (gh-4926).\n+\t\t\t\/\/ Firefox only trims leading whitespace. Chrome just collapses\n+\t\t\t\/\/ both leading & trailing whitespace to a single space.\n+\t\t\t\/\/\n+\t\t\t\/\/ Fall back to `undefined` if empty string returned.\n+\t\t\t\/\/ This collapses a missing definition with property defined\n+\t\t\t\/\/ and set to an empty string but there's no standard API\n+\t\t\t\/\/ allowing us to differentiate them without a performance penalty\n+\t\t\t\/\/ and returning `undefined` aligns with older jQuery.\n+\t\t\t\/\/\n+\t\t\t\/\/ rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED\n+\t\t\t\/\/ as whitespace while CSS does not, but this is not a problem\n+\t\t\t\/\/ because CSS preprocessing replaces them with U+000A LINE FEED\n+\t\t\t\/\/ (which *is* CSS whitespace)\n+\t\t\t\/\/ https:\/\/www.w3.org\/TR\/css-syntax-3\/#input-preprocessing\n+\t\t\tret = ret.replace( rtrimCSS, \"$1\" ) || undefined;\n+\t\t}\n+\n+\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n+\t\t\tret = jQuery.style( elem, name );\n+\t\t}\n+\n+\t\t\/\/ A tribute to the \"awesome hack by Dean Edwards\"\n+\t\t\/\/ Android Browser returns percentage for some values,\n+\t\t\/\/ but width seems to be reliably pixels.\n+\t\t\/\/ This is against the CSSOM draft spec:\n+\t\t\/\/ https:\/\/drafts.csswg.org\/cssom\/#resolved-values\n+\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n+\n+\t\t\t\/\/ Remember the original values\n+\t\t\twidth = style.width;\n+\t\t\tminWidth = style.minWidth;\n+\t\t\tmaxWidth = style.maxWidth;\n+\n+\t\t\t\/\/ Put in the new values to get a computed value out\n+\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n+\t\t\tret = computed.width;\n+\n+\t\t\t\/\/ Revert the changed values\n+\t\t\tstyle.width = width;\n+\t\t\tstyle.minWidth = minWidth;\n+\t\t\tstyle.maxWidth = maxWidth;\n+\t\t}\n+\t}\n+\n+\treturn ret !== undefined ?\n+\n+\t\t\/\/ Support: IE <=9 - 11 only\n+\t\t\/\/ IE returns zIndex value as an integer.\n+\t\tret + \"\" :\n+\t\tret;\n+}\n+\n+\n+function addGetHookIf( conditionFn, hookFn ) {\n+\n+\t\/\/ Define the hook, we'll check on the first run if it's really needed.\n+\treturn {\n+\t\tget: function() {\n+\t\t\tif ( conditionFn() ) {\n+\n+\t\t\t\t\/\/ Hook not needed (or it's not possible to use it due\n+\t\t\t\t\/\/ to missing dependency), remove it.\n+\t\t\t\tdelete this.get;\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t\/\/ Hook needed; redefine it so that the support test is not executed again.\n+\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n+\t\t}\n+\t};\n+}\n+\n+\n+var cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n+\temptyStyle = document.createElement( \"div\" ).style,\n+\tvendorProps = {};\n+\n+\/\/ Return a vendor-prefixed property or undefined\n+function vendorPropName( name ) {\n+\n+\t\/\/ Check for vendor prefixed names\n+\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n+\t\ti = cssPrefixes.length;\n+\n+\twhile ( i-- ) {\n+\t\tname = cssPrefixes[ i ] + capName;\n+\t\tif ( name in emptyStyle ) {\n+\t\t\treturn name;\n+\t\t}\n+\t}\n+}\n+\n+\/\/ Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n+function finalPropName( name ) {\n+\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n+\n+\tif ( final ) {\n+\t\treturn final;\n+\t}\n+\tif ( name in emptyStyle ) {\n+\t\treturn name;\n+\t}\n+\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n+}\n+\n+\n+var\n+\n+\t\/\/ Swappable if display is none or starts with table\n+\t\/\/ except \"table\", \"table-cell\", or \"table-caption\"\n+\t\/\/ See here for display values: https:\/\/developer.mozilla.org\/en-US\/docs\/CSS\/display\n+\trdisplayswap = \/^(none|table(?!-c[ea]).+)\/,\n+\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n+\tcssNormalTransform = {\n+\t\tletterSpacing: \"0\",\n+\t\tfontWeight: \"400\"\n+\t};\n+\n+function setPositiveNumber( _elem, value, subtract ) {\n+\n+\t\/\/ Any relative (+\/-) values have already been\n+\t\/\/ normalized at this point\n+\tvar matches = rcssNum.exec( value );\n+\treturn matches ?\n+\n+\t\t\/\/ Guard against undefined \"subtract\", e.g., when used as in cssHooks\n+\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n+\t\tvalue;\n+}\n+\n+function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n+\tvar i = dimension === \"width\" ? 1 : 0,\n+\t\textra = 0,\n+\t\tdelta = 0,\n+\t\tmarginDelta = 0;\n+\n+\t\/\/ Adjustment may not be necessary\n+\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n+\t\treturn 0;\n+\t}\n+\n+\tfor ( ; i < 4; i += 2 ) {\n+\n+\t\t\/\/ Both box models exclude margin\n+\t\t\/\/ Count margin delta separately to only add it after scroll gutter adjustment.\n+\t\t\/\/ This is needed to make negative margins work with `outerHeight( true )` (gh-3982).\n+\t\tif ( box === \"margin\" ) {\n+\t\t\tmarginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n+\t\t}\n+\n+\t\t\/\/ If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n+\t\tif ( !isBorderBox ) {\n+\n+\t\t\t\/\/ Add padding\n+\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n+\n+\t\t\t\/\/ For \"border\" or \"margin\", add border\n+\t\t\tif ( box !== \"padding\" ) {\n+\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n+\n+\t\t\t\/\/ But still keep track of it otherwise\n+\t\t\t} else {\n+\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n+\t\t\t}\n+\n+\t\t\/\/ If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n+\t\t\/\/ \"padding\" or \"margin\"\n+\t\t} else {\n+\n+\t\t\t\/\/ For \"content\", subtract padding\n+\t\t\tif ( box === \"content\" ) {\n+\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n+\t\t\t}\n+\n+\t\t\t\/\/ For \"content\" or \"padding\", subtract border\n+\t\t\tif ( box !== \"margin\" ) {\n+\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t\/\/ Account for positive content-box scroll gutter when requested by providing computedVal\n+\tif ( !isBorderBox && computedVal >= 0 ) {\n+\n+\t\t\/\/ offsetWidth\/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n+\t\t\/\/ Assuming integer scroll gutter, subtract the rest and round down\n+\t\tdelta += Math.max( 0, Math.ceil(\n+\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n+\t\t\tcomputedVal -\n+\t\t\tdelta -\n+\t\t\textra -\n+\t\t\t0.5\n+\n+\t\t\/\/ If offsetWidth\/offsetHeight is unknown, then we can't determine content-box scroll gutter\n+\t\t\/\/ Use an explicit zero to avoid NaN (gh-3964)\n+\t\t) ) || 0;\n+\t}\n+\n+\treturn delta + marginDelta;\n+}\n+\n+function getWidthOrHeight( elem, dimension, extra ) {\n+\n+\t\/\/ Start with computed style\n+\tvar styles = getStyles( elem ),\n+\n+\t\t\/\/ To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n+\t\t\/\/ Fake content-box until we know it's needed to know the true value.\n+\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n+\t\tisBorderBox = boxSizingNeeded &&\n+\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n+\t\tvalueIsBorderBox = isBorderBox,\n+\n+\t\tval = curCSS( elem, dimension, styles ),\n+\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n+\n+\t\/\/ Support: Firefox <=54\n+\t\/\/ Return a confounding non-pixel value or feign ignorance, as appropriate.\n+\tif ( rnumnonpx.test( val ) ) {\n+\t\tif ( !extra ) {\n+\t\t\treturn val;\n+\t\t}\n+\t\tval = \"auto\";\n+\t}\n+\n+\n+\t\/\/ Support: IE 9 - 11 only\n+\t\/\/ Use offsetWidth\/offsetHeight for when box sizing is unreliable.\n+\t\/\/ In those cases, the computed value can be trusted to be border-box.\n+\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n+\n+\t\t\/\/ Support: IE 10 - 11+, Edge 15 - 18+\n+\t\t\/\/ IE\/Edge misreport `getComputedStyle` of table rows with width\/height\n+\t\t\/\/ set in CSS while `offset*` properties report correct values.\n+\t\t\/\/ Interestingly, in some cases IE 9 doesn't suffer from this issue.\n+\t\t!support.reliableTrDimensions() && nodeName( elem, \"tr\" ) ||\n+\n+\t\t\/\/ Fall back to offsetWidth\/offsetHeight when value is \"auto\"\n+\t\t\/\/ This happens for inline elements with no explicit setting (gh-3571)\n+\t\tval === \"auto\" ||\n+\n+\t\t\/\/ Support: Android <=4.1 - 4.3 only\n+\t\t\/\/ Also use offsetWidth\/offsetHeight for misreported inline dimensions (gh-3602)\n+\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n+\n+\t\t\/\/ Make sure the element is visible & connected\n+\t\telem.getClientRects().length ) {\n+\n+\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n+\n+\t\t\/\/ Where available, offsetWidth\/offsetHeight approximate border box dimensions.\n+\t\t\/\/ Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n+\t\t\/\/ retrieved value as a content box dimension.\n+\t\tvalueIsBorderBox = offsetProp in elem;\n+\t\tif ( valueIsBorderBox ) {\n+\t\t\tval = elem[ offsetProp ];\n+\t\t}\n+\t}\n+\n+\t\/\/ Normalize \"\" and auto\n+\tval = parseFloat( val ) || 0;\n+\n+\t\/\/ Adjust for the element's box model\n+\treturn ( val +\n+\t\tboxModelAdjustment(\n+\t\t\telem,\n+\t\t\tdimension,\n+\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n+\t\t\tvalueIsBorderBox,\n+\t\t\tstyles,\n+\n+\t\t\t\/\/ Provide the current computed size to request scroll gutter calculation (gh-3589)\n+\t\t\tval\n+\t\t)\n+\t) + \"px\";\n+}\n+\n+jQuery.extend( {\n+\n+\t\/\/ Add in style property hooks for overriding the default\n+\t\/\/ behavior of getting and setting a style property\n+\tcssHooks: {\n+\t\topacity: {\n+\t\t\tget: function( elem, computed ) {\n+\t\t\t\tif ( computed ) {\n+\n+\t\t\t\t\t\/\/ We should always get a number back from opacity\n+\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n+\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t},\n+\n+\t\/\/ Don't automatically add \"px\" to these possibly-unitless properties\n+\tcssNumber: {\n+\t\tanimationIterationCount: true,\n+\t\taspectRatio: true,\n+\t\tborderImageSlice: true,\n+\t\tcolumnCount: true,\n+\t\tflexGrow: true,\n+\t\tflexShrink: true,\n+\t\tfontWeight: true,\n+\t\tgridArea: true,\n+\t\tgridColumn: true,\n+\t\tgridColumnEnd: true,\n+\t\tgridColumnStart: true,\n+\t\tgridRow: true,\n+\t\tgridRowEnd: true,\n+\t\tgridRowStart: true,\n+\t\tlineHeight: true,\n+\t\topacity: true,\n+\t\torder: true,\n+\t\torphans: true,\n+\t\tscale: true,\n+\t\twidows: true,\n+\t\tzIndex: true,\n+\t\tzoom: true,\n+\n+\t\t\/\/ SVG-related\n+\t\tfillOpacity: true,\n+\t\tfloodOpacity: true,\n+\t\tstopOpacity: true,\n+\t\tstrokeMiterlimit: true,\n+\t\tstrokeOpacity: true\n+\t},\n+\n+\t\/\/ Add in properties whose names you wish to fix before\n+\t\/\/ setting or getting the value\n+\tcssProps: {},\n+\n+\t\/\/ Get and set the style property on a DOM Node\n+\tstyle: function( elem, name, value, extra ) {\n+\n+\t\t\/\/ Don't set styles on text and comment nodes\n+\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ Make sure that we're working with the right name\n+\t\tvar ret, type, hooks,\n+\t\t\torigName = camelCase( name ),\n+\t\t\tisCustomProp = rcustomProp.test( name ),\n+\t\t\tstyle = elem.style;\n+\n+\t\t\/\/ Make sure that we're working with the right name. We don't\n+\t\t\/\/ want to query the value if it is a CSS custom property\n+\t\t\/\/ since they are user-defined.\n+\t\tif ( !isCustomProp ) {\n+\t\t\tname = finalPropName( origName );\n+\t\t}\n+\n+\t\t\/\/ Gets hook for the prefixed version, then unprefixed version\n+\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n+\n+\t\t\/\/ Check if we're setting a value\n+\t\tif ( value !== undefined ) {\n+\t\t\ttype = typeof value;\n+\n+\t\t\t\/\/ Convert \"+=\" or \"-=\" to relative numbers (trac-7345)\n+\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n+\t\t\t\tvalue = adjustCSS( elem, name, ret );\n+\n+\t\t\t\t\/\/ Fixes bug trac-9237\n+\t\t\t\ttype = \"number\";\n+\t\t\t}\n+\n+\t\t\t\/\/ Make sure that null and NaN values aren't set (trac-7116)\n+\t\t\tif ( value == null || value !== value ) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t\/\/ If a number was passed in, add the unit (except for certain CSS properties)\n+\t\t\t\/\/ The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n+\t\t\t\/\/ \"px\" to a few hardcoded values.\n+\t\t\tif ( type === \"number\" && !isCustomProp ) {\n+\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n+\t\t\t}\n+\n+\t\t\t\/\/ background-* props affect original clone's values\n+\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n+\t\t\t\tstyle[ name ] = \"inherit\";\n+\t\t\t}\n+\n+\t\t\t\/\/ If a hook was provided, use that value, otherwise just set the specified value\n+\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n+\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n+\n+\t\t\t\tif ( isCustomProp ) {\n+\t\t\t\t\tstyle.setProperty( name, value );\n+\t\t\t\t} else {\n+\t\t\t\t\tstyle[ name ] = value;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t} else {\n+\n+\t\t\t\/\/ If a hook was provided get the non-computed value from there\n+\t\t\tif ( hooks && \"get\" in hooks &&\n+\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n+\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\n+\t\t\t\/\/ Otherwise just get the value from the style object\n+\t\t\treturn style[ name ];\n+\t\t}\n+\t},\n+\n+\tcss: function( elem, name, extra, styles ) {\n+\t\tvar val, num, hooks,\n+\t\t\torigName = camelCase( name ),\n+\t\t\tisCustomProp = rcustomProp.test( name );\n+\n+\t\t\/\/ Make sure that we're working with the right name. We don't\n+\t\t\/\/ want to modify the value if it is a CSS custom property\n+\t\t\/\/ since they are user-defined.\n+\t\tif ( !isCustomProp ) {\n+\t\t\tname = finalPropName( origName );\n+\t\t}\n+\n+\t\t\/\/ Try prefixed name followed by the unprefixed name\n+\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n+\n+\t\t\/\/ If a hook was provided get the computed value from there\n+\t\tif ( hooks && \"get\" in hooks ) {\n+\t\t\tval = hooks.get( elem, true, extra );\n+\t\t}\n+\n+\t\t\/\/ Otherwise, if a way to get the computed value exists, use that\n+\t\tif ( val === undefined ) {\n+\t\t\tval = curCSS( elem, name, styles );\n+\t\t}\n+\n+\t\t\/\/ Convert \"normal\" to computed value\n+\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n+\t\t\tval = cssNormalTransform[ name ];\n+\t\t}\n+\n+\t\t\/\/ Make numeric if forced or a qualifier was provided and val looks numeric\n+\t\tif ( extra === \"\" || extra ) {\n+\t\t\tnum = parseFloat( val );\n+\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n+\t\t}\n+\n+\t\treturn val;\n+\t}\n+} );\n+\n+jQuery.each( [ \"height\", \"width\" ], function( _i, dimension ) {\n+\tjQuery.cssHooks[ dimension ] = {\n+\t\tget: function( elem, computed, extra ) {\n+\t\t\tif ( computed ) {\n+\n+\t\t\t\t\/\/ Certain elements can have dimension info if we invisibly show them\n+\t\t\t\t\/\/ but it must have a current display style that would benefit\n+\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n+\n+\t\t\t\t\t\/\/ Support: Safari 8+\n+\t\t\t\t\t\/\/ Table columns in Safari have non-zero offsetWidth & zero\n+\t\t\t\t\t\/\/ getBoundingClientRect().width unless display is changed.\n+\t\t\t\t\t\/\/ Support: IE <=11 only\n+\t\t\t\t\t\/\/ Running getBoundingClientRect on a disconnected node\n+\t\t\t\t\t\/\/ in IE throws an error.\n+\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n+\t\t\t\t\tswap( elem, cssShow, function() {\n+\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n+\t\t\t\t\t} ) :\n+\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n+\t\t\t}\n+\t\t},\n+\n+\t\tset: function( elem, value, extra ) {\n+\t\t\tvar matches,\n+\t\t\t\tstyles = getStyles( elem ),\n+\n+\t\t\t\t\/\/ Only read styles.position if the test has a chance to fail\n+\t\t\t\t\/\/ to avoid forcing a reflow.\n+\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n+\t\t\t\t\tstyles.position === \"absolute\",\n+\n+\t\t\t\t\/\/ To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n+\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n+\t\t\t\tisBorderBox = boxSizingNeeded &&\n+\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n+\t\t\t\tsubtract = extra ?\n+\t\t\t\t\tboxModelAdjustment(\n+\t\t\t\t\t\telem,\n+\t\t\t\t\t\tdimension,\n+\t\t\t\t\t\textra,\n+\t\t\t\t\t\tisBorderBox,\n+\t\t\t\t\t\tstyles\n+\t\t\t\t\t) :\n+\t\t\t\t\t0;\n+\n+\t\t\t\/\/ Account for unreliable border-box dimensions by comparing offset* to computed and\n+\t\t\t\/\/ faking a content-box to get border and padding (gh-3699)\n+\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n+\t\t\t\tsubtract -= Math.ceil(\n+\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n+\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n+\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n+\t\t\t\t\t0.5\n+\t\t\t\t);\n+\t\t\t}\n+\n+\t\t\t\/\/ Convert to pixels if value adjustment is needed\n+\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n+\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n+\n+\t\t\t\telem.style[ dimension ] = value;\n+\t\t\t\tvalue = jQuery.css( elem, dimension );\n+\t\t\t}\n+\n+\t\t\treturn setPositiveNumber( elem, value, subtract );\n+\t\t}\n+\t};\n+} );\n+\n+jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n+\tfunction( elem, computed ) {\n+\t\tif ( computed ) {\n+\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n+\t\t\t\telem.getBoundingClientRect().left -\n+\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n+\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n+\t\t\t\t\t} )\n+\t\t\t) + \"px\";\n+\t\t}\n+\t}\n+);\n+\n+\/\/ These hooks are used by animate to expand properties\n+jQuery.each( {\n+\tmargin: \"\",\n+\tpadding: \"\",\n+\tborder: \"Width\"\n+}, function( prefix, suffix ) {\n+\tjQuery.cssHooks[ prefix + suffix ] = {\n+\t\texpand: function( value ) {\n+\t\t\tvar i = 0,\n+\t\t\t\texpanded = {},\n+\n+\t\t\t\t\/\/ Assumes a single number if not a string\n+\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n+\n+\t\t\tfor ( ; i < 4; i++ ) {\n+\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n+\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n+\t\t\t}\n+\n+\t\t\treturn expanded;\n+\t\t}\n+\t};\n+\n+\tif ( prefix !== \"margin\" ) {\n+\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n+\t}\n+} );\n+\n+jQuery.fn.extend( {\n+\tcss: function( name, value ) {\n+\t\treturn access( this, function( elem, name, value ) {\n+\t\t\tvar styles, len,\n+\t\t\t\tmap = {},\n+\t\t\t\ti = 0;\n+\n+\t\t\tif ( Array.isArray( name ) ) {\n+\t\t\t\tstyles = getStyles( elem );\n+\t\t\t\tlen = name.length;\n+\n+\t\t\t\tfor ( ; i < len; i++ ) {\n+\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n+\t\t\t\t}\n+\n+\t\t\t\treturn map;\n+\t\t\t}\n+\n+\t\t\treturn value !== undefined ?\n+\t\t\t\tjQuery.style( elem, name, value ) :\n+\t\t\t\tjQuery.css( elem, name );\n+\t\t}, name, value, arguments.length > 1 );\n+\t}\n+} );\n+\n+\n+function Tween( elem, options, prop, end, easing ) {\n+\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n+}\n+jQuery.Tween = Tween;\n+\n+Tween.prototype = {\n+\tconstructor: Tween,\n+\tinit: function( elem, options, prop, end, easing, unit ) {\n+\t\tthis.elem = elem;\n+\t\tthis.prop = prop;\n+\t\tthis.easing = easing || jQuery.easing._default;\n+\t\tthis.options = options;\n+\t\tthis.start = this.now = this.cur();\n+\t\tthis.end = end;\n+\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n+\t},\n+\tcur: function() {\n+\t\tvar hooks = Tween.propHooks[ this.prop ];\n+\n+\t\treturn hooks && hooks.get ?\n+\t\t\thooks.get( this ) :\n+\t\t\tTween.propHooks._default.get( this );\n+\t},\n+\trun: function( percent ) {\n+\t\tvar eased,\n+\t\t\thooks = Tween.propHooks[ this.prop ];\n+\n+\t\tif ( this.options.duration ) {\n+\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n+\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n+\t\t\t);\n+\t\t} else {\n+\t\t\tthis.pos = eased = percent;\n+\t\t}\n+\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n+\n+\t\tif ( this.options.step ) {\n+\t\t\tthis.options.step.call( this.elem, this.now, this );\n+\t\t}\n+\n+\t\tif ( hooks && hooks.set ) {\n+\t\t\thooks.set( this );\n+\t\t} else {\n+\t\t\tTween.propHooks._default.set( this );\n+\t\t}\n+\t\treturn this;\n+\t}\n+};\n+\n+Tween.prototype.init.prototype = Tween.prototype;\n+\n+Tween.propHooks = {\n+\t_default: {\n+\t\tget: function( tween ) {\n+\t\t\tvar result;\n+\n+\t\t\t\/\/ Use a property on the element directly when it is not a DOM element,\n+\t\t\t\/\/ or when there is no matching style property that exists.\n+\t\t\tif ( tween.elem.nodeType !== 1 ||\n+\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n+\t\t\t\treturn tween.elem[ tween.prop ];\n+\t\t\t}\n+\n+\t\t\t\/\/ Passing an empty string as a 3rd parameter to .css will automatically\n+\t\t\t\/\/ attempt a parseFloat and fallback to a string if the parse fails.\n+\t\t\t\/\/ Simple values such as \"10px\" are parsed to Float;\n+\t\t\t\/\/ complex values such as \"rotate(1rad)\" are returned as-is.\n+\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n+\n+\t\t\t\/\/ Empty strings, null, undefined and \"auto\" are converted to 0.\n+\t\t\treturn !result || result === \"auto\" ? 0 : result;\n+\t\t},\n+\t\tset: function( tween ) {\n+\n+\t\t\t\/\/ Use step hook for back compat.\n+\t\t\t\/\/ Use cssHook if its there.\n+\t\t\t\/\/ Use .style if available and use plain properties where available.\n+\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n+\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n+\t\t\t} else if ( tween.elem.nodeType === 1 && (\n+\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n+\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n+\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n+\t\t\t} else {\n+\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n+\t\t\t}\n+\t\t}\n+\t}\n+};\n+\n+\/\/ Support: IE <=9 only\n+\/\/ Panic based approach to setting things on disconnected nodes\n+Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n+\tset: function( tween ) {\n+\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n+\t\t\ttween.elem[ tween.prop ] = tween.now;\n+\t\t}\n+\t}\n+};\n+\n+jQuery.easing = {\n+\tlinear: function( p ) {\n+\t\treturn p;\n+\t},\n+\tswing: function( p ) {\n+\t\treturn 0.5 - Math.cos( p * Math.PI ) \/ 2;\n+\t},\n+\t_default: \"swing\"\n+};\n+\n+jQuery.fx = Tween.prototype.init;\n+\n+\/\/ Back compat <1.8 extension point\n+jQuery.fx.step = {};\n+\n+\n+\n+\n+var\n+\tfxNow, inProgress,\n+\trfxtypes = \/^(?:toggle|show|hide)$\/,\n+\trrun = \/queueHooks$\/;\n+\n+function schedule() {\n+\tif ( inProgress ) {\n+\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n+\t\t\twindow.requestAnimationFrame( schedule );\n+\t\t} else {\n+\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n+\t\t}\n+\n+\t\tjQuery.fx.tick();\n+\t}\n+}\n+\n+\/\/ Animations created synchronously will run synchronously\n+function createFxNow() {\n+\twindow.setTimeout( function() {\n+\t\tfxNow = undefined;\n+\t} );\n+\treturn ( fxNow = Date.now() );\n+}\n+\n+\/\/ Generate parameters to create a standard animation\n+function genFx( type, includeWidth ) {\n+\tvar which,\n+\t\ti = 0,\n+\t\tattrs = { height: type };\n+\n+\t\/\/ If we include width, step value is 1 to do all cssExpand values,\n+\t\/\/ otherwise step value is 2 to skip over Left and Right\n+\tincludeWidth = includeWidth ? 1 : 0;\n+\tfor ( ; i < 4; i += 2 - includeWidth ) {\n+\t\twhich = cssExpand[ i ];\n+\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n+\t}\n+\n+\tif ( includeWidth ) {\n+\t\tattrs.opacity = attrs.width = type;\n+\t}\n+\n+\treturn attrs;\n+}\n+\n+function createTween( value, prop, animation ) {\n+\tvar tween,\n+\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n+\t\tindex = 0,\n+\t\tlength = collection.length;\n+\tfor ( ; index < length; index++ ) {\n+\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n+\n+\t\t\t\/\/ We're done with this property\n+\t\t\treturn tween;\n+\t\t}\n+\t}\n+}\n+\n+function defaultPrefilter( elem, props, opts ) {\n+\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n+\t\tisBox = \"width\" in props || \"height\" in props,\n+\t\tanim = this,\n+\t\torig = {},\n+\t\tstyle = elem.style,\n+\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n+\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n+\n+\t\/\/ Queue-skipping animations hijack the fx hooks\n+\tif ( !opts.queue ) {\n+\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n+\t\tif ( hooks.unqueued == null ) {\n+\t\t\thooks.unqueued = 0;\n+\t\t\toldfire = hooks.empty.fire;\n+\t\t\thooks.empty.fire = function() {\n+\t\t\t\tif ( !hooks.unqueued ) {\n+\t\t\t\t\toldfire();\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t\thooks.unqueued++;\n+\n+\t\tanim.always( function() {\n+\n+\t\t\t\/\/ Ensure the complete handler is called before this completes\n+\t\t\tanim.always( function() {\n+\t\t\t\thooks.unqueued--;\n+\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n+\t\t\t\t\thooks.empty.fire();\n+\t\t\t\t}\n+\t\t\t} );\n+\t\t} );\n+\t}\n+\n+\t\/\/ Detect show\/hide animations\n+\tfor ( prop in props ) {\n+\t\tvalue = props[ prop ];\n+\t\tif ( rfxtypes.test( value ) ) {\n+\t\t\tdelete props[ prop ];\n+\t\t\ttoggle = toggle || value === \"toggle\";\n+\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n+\n+\t\t\t\t\/\/ Pretend to be hidden if this is a \"show\" and\n+\t\t\t\t\/\/ there is still data from a stopped show\/hide\n+\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n+\t\t\t\t\thidden = true;\n+\n+\t\t\t\t\/\/ Ignore all other no-op show\/hide data\n+\t\t\t\t} else {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n+\t\t}\n+\t}\n+\n+\t\/\/ Bail out if this is a no-op like .hide().hide()\n+\tpropTween = !jQuery.isEmptyObject( props );\n+\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n+\t\treturn;\n+\t}\n+\n+\t\/\/ Restrict \"overflow\" and \"display\" styles during box animations\n+\tif ( isBox && elem.nodeType === 1 ) {\n+\n+\t\t\/\/ Support: IE <=9 - 11, Edge 12 - 15\n+\t\t\/\/ Record all 3 overflow attributes because IE does not infer the shorthand\n+\t\t\/\/ from identically-valued overflowX and overflowY and Edge just mirrors\n+\t\t\/\/ the overflowX value there.\n+\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n+\n+\t\t\/\/ Identify a display type, preferring old show\/hide data over the CSS cascade\n+\t\trestoreDisplay = dataShow && dataShow.display;\n+\t\tif ( restoreDisplay == null ) {\n+\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n+\t\t}\n+\t\tdisplay = jQuery.css( elem, \"display\" );\n+\t\tif ( display === \"none\" ) {\n+\t\t\tif ( restoreDisplay ) {\n+\t\t\t\tdisplay = restoreDisplay;\n+\t\t\t} else {\n+\n+\t\t\t\t\/\/ Get nonempty value(s) by temporarily forcing visibility\n+\t\t\t\tshowHide( [ elem ], true );\n+\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n+\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n+\t\t\t\tshowHide( [ elem ] );\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Animate inline elements as inline-block\n+\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n+\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n+\n+\t\t\t\t\/\/ Restore the original display value at the end of pure show\/hide animations\n+\t\t\t\tif ( !propTween ) {\n+\t\t\t\t\tanim.done( function() {\n+\t\t\t\t\t\tstyle.display = restoreDisplay;\n+\t\t\t\t\t} );\n+\t\t\t\t\tif ( restoreDisplay == null ) {\n+\t\t\t\t\t\tdisplay = style.display;\n+\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tstyle.display = \"inline-block\";\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif ( opts.overflow ) {\n+\t\tstyle.overflow = \"hidden\";\n+\t\tanim.always( function() {\n+\t\t\tstyle.overflow = opts.overflow[ 0 ];\n+\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n+\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n+\t\t} );\n+\t}\n+\n+\t\/\/ Implement show\/hide animations\n+\tpropTween = false;\n+\tfor ( prop in orig ) {\n+\n+\t\t\/\/ General show\/hide setup for this element animation\n+\t\tif ( !propTween ) {\n+\t\t\tif ( dataShow ) {\n+\t\t\t\tif ( \"hidden\" in dataShow ) {\n+\t\t\t\t\thidden = dataShow.hidden;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n+\t\t\t}\n+\n+\t\t\t\/\/ Store hidden\/visible for toggle so `.stop().toggle()` \"reverses\"\n+\t\t\tif ( toggle ) {\n+\t\t\t\tdataShow.hidden = !hidden;\n+\t\t\t}\n+\n+\t\t\t\/\/ Show elements before animating them\n+\t\t\tif ( hidden ) {\n+\t\t\t\tshowHide( [ elem ], true );\n+\t\t\t}\n+\n+\t\t\t\/* eslint-disable no-loop-func *\/\n+\n+\t\t\tanim.done( function() {\n+\n+\t\t\t\t\/* eslint-enable no-loop-func *\/\n+\n+\t\t\t\t\/\/ The final step of a \"hide\" animation is actually hiding the element\n+\t\t\t\tif ( !hidden ) {\n+\t\t\t\t\tshowHide( [ elem ] );\n+\t\t\t\t}\n+\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n+\t\t\t\tfor ( prop in orig ) {\n+\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n+\t\t\t\t}\n+\t\t\t} );\n+\t\t}\n+\n+\t\t\/\/ Per-property setup\n+\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n+\t\tif ( !( prop in dataShow ) ) {\n+\t\t\tdataShow[ prop ] = propTween.start;\n+\t\t\tif ( hidden ) {\n+\t\t\t\tpropTween.end = propTween.start;\n+\t\t\t\tpropTween.start = 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+function propFilter( props, specialEasing ) {\n+\tvar index, name, easing, value, hooks;\n+\n+\t\/\/ camelCase, specialEasing and expand cssHook pass\n+\tfor ( index in props ) {\n+\t\tname = camelCase( index );\n+\t\teasing = specialEasing[ name ];\n+\t\tvalue = props[ index ];\n+\t\tif ( Array.isArray( value ) ) {\n+\t\t\teasing = value[ 1 ];\n+\t\t\tvalue = props[ index ] = value[ 0 ];\n+\t\t}\n+\n+\t\tif ( index !== name ) {\n+\t\t\tprops[ name ] = value;\n+\t\t\tdelete props[ index ];\n+\t\t}\n+\n+\t\thooks = jQuery.cssHooks[ name ];\n+\t\tif ( hooks && \"expand\" in hooks ) {\n+\t\t\tvalue = hooks.expand( value );\n+\t\t\tdelete props[ name ];\n+\n+\t\t\t\/\/ Not quite $.extend, this won't overwrite existing keys.\n+\t\t\t\/\/ Reusing 'index' because we have the correct \"name\"\n+\t\t\tfor ( index in value ) {\n+\t\t\t\tif ( !( index in props ) ) {\n+\t\t\t\t\tprops[ index ] = value[ index ];\n+\t\t\t\t\tspecialEasing[ index ] = easing;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tspecialEasing[ name ] = easing;\n+\t\t}\n+\t}\n+}\n+\n+function Animation( elem, properties, options ) {\n+\tvar result,\n+\t\tstopped,\n+\t\tindex = 0,\n+\t\tlength = Animation.prefilters.length,\n+\t\tdeferred = jQuery.Deferred().always( function() {\n+\n+\t\t\t\/\/ Don't match elem in the :animated selector\n+\t\t\tdelete tick.elem;\n+\t\t} ),\n+\t\ttick = function() {\n+\t\t\tif ( stopped ) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tvar currentTime = fxNow || createFxNow(),\n+\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n+\n+\t\t\t\t\/\/ Support: Android 2.3 only\n+\t\t\t\t\/\/ Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)\n+\t\t\t\ttemp = remaining \/ animation.duration || 0,\n+\t\t\t\tpercent = 1 - temp,\n+\t\t\t\tindex = 0,\n+\t\t\t\tlength = animation.tweens.length;\n+\n+\t\t\tfor ( ; index < length; index++ ) {\n+\t\t\t\tanimation.tweens[ index ].run( percent );\n+\t\t\t}\n+\n+\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n+\n+\t\t\t\/\/ If there's more to do, yield\n+\t\t\tif ( percent < 1 && length ) {\n+\t\t\t\treturn remaining;\n+\t\t\t}\n+\n+\t\t\t\/\/ If this was an empty animation, synthesize a final progress notification\n+\t\t\tif ( !length ) {\n+\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n+\t\t\t}\n+\n+\t\t\t\/\/ Resolve the animation and report its conclusion\n+\t\t\tdeferred.resolveWith( elem, [ animation ] );\n+\t\t\treturn false;\n+\t\t},\n+\t\tanimation = deferred.promise( {\n+\t\t\telem: elem,\n+\t\t\tprops: jQuery.extend( {}, properties ),\n+\t\t\topts: jQuery.extend( true, {\n+\t\t\t\tspecialEasing: {},\n+\t\t\t\teasing: jQuery.easing._default\n+\t\t\t}, options ),\n+\t\t\toriginalProperties: properties,\n+\t\t\toriginalOptions: options,\n+\t\t\tstartTime: fxNow || createFxNow(),\n+\t\t\tduration: options.duration,\n+\t\t\ttweens: [],\n+\t\t\tcreateTween: function( prop, end ) {\n+\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n+\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n+\t\t\t\tanimation.tweens.push( tween );\n+\t\t\t\treturn tween;\n+\t\t\t},\n+\t\t\tstop: function( gotoEnd ) {\n+\t\t\t\tvar index = 0,\n+\n+\t\t\t\t\t\/\/ If we are going to the end, we want to run all the tweens\n+\t\t\t\t\t\/\/ otherwise we skip this part\n+\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n+\t\t\t\tif ( stopped ) {\n+\t\t\t\t\treturn this;\n+\t\t\t\t}\n+\t\t\t\tstopped = true;\n+\t\t\t\tfor ( ; index < length; index++ ) {\n+\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Resolve when we played the last frame; otherwise, reject\n+\t\t\t\tif ( gotoEnd ) {\n+\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n+\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n+\t\t\t\t} else {\n+\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n+\t\t\t\t}\n+\t\t\t\treturn this;\n+\t\t\t}\n+\t\t} ),\n+\t\tprops = animation.props;\n+\n+\tpropFilter( props, animation.opts.specialEasing );\n+\n+\tfor ( ; index < length; index++ ) {\n+\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n+\t\tif ( result ) {\n+\t\t\tif ( isFunction( result.stop ) ) {\n+\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n+\t\t\t\t\tresult.stop.bind( result );\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\t}\n+\n+\tjQuery.map( props, createTween, animation );\n+\n+\tif ( isFunction( animation.opts.start ) ) {\n+\t\tanimation.opts.start.call( elem, animation );\n+\t}\n+\n+\t\/\/ Attach callbacks from options\n+\tanimation\n+\t\t.progress( animation.opts.progress )\n+\t\t.done( animation.opts.done, animation.opts.complete )\n+\t\t.fail( animation.opts.fail )\n+\t\t.always( animation.opts.always );\n+\n+\tjQuery.fx.timer(\n+\t\tjQuery.extend( tick, {\n+\t\t\telem: elem,\n+\t\t\tanim: animation,\n+\t\t\tqueue: animation.opts.queue\n+\t\t} )\n+\t);\n+\n+\treturn animation;\n+}\n+\n+jQuery.Animation = jQuery.extend( Animation, {\n+\n+\ttweeners: {\n+\t\t\"*\": [ function( prop, value ) {\n+\t\t\tvar tween = this.createTween( prop, value );\n+\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n+\t\t\treturn tween;\n+\t\t} ]\n+\t},\n+\n+\ttweener: function( props, callback ) {\n+\t\tif ( isFunction( props ) ) {\n+\t\t\tcallback = props;\n+\t\t\tprops = [ \"*\" ];\n+\t\t} else {\n+\t\t\tprops = props.match( rnothtmlwhite );\n+\t\t}\n+\n+\t\tvar prop,\n+\t\t\tindex = 0,\n+\t\t\tlength = props.length;\n+\n+\t\tfor ( ; index < length; index++ ) {\n+\t\t\tprop = props[ index ];\n+\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n+\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n+\t\t}\n+\t},\n+\n+\tprefilters: [ defaultPrefilter ],\n+\n+\tprefilter: function( callback, prepend ) {\n+\t\tif ( prepend ) {\n+\t\t\tAnimation.prefilters.unshift( callback );\n+\t\t} else {\n+\t\t\tAnimation.prefilters.push( callback );\n+\t\t}\n+\t}\n+} );\n+\n+jQuery.speed = function( speed, easing, fn ) {\n+\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n+\t\tcomplete: fn || !fn && easing ||\n+\t\t\tisFunction( speed ) && speed,\n+\t\tduration: speed,\n+\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n+\t};\n+\n+\t\/\/ Go to the end state if fx are off\n+\tif ( jQuery.fx.off ) {\n+\t\topt.duration = 0;\n+\n+\t} else {\n+\t\tif ( typeof opt.duration !== \"number\" ) {\n+\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n+\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n+\n+\t\t\t} else {\n+\t\t\t\topt.duration = jQuery.fx.speeds._default;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t\/\/ Normalize opt.queue - true\/undefined\/null -> \"fx\"\n+\tif ( opt.queue == null || opt.queue === true ) {\n+\t\topt.queue = \"fx\";\n+\t}\n+\n+\t\/\/ Queueing\n+\topt.old = opt.complete;\n+\n+\topt.complete = function() {\n+\t\tif ( isFunction( opt.old ) ) {\n+\t\t\topt.old.call( this );\n+\t\t}\n+\n+\t\tif ( opt.queue ) {\n+\t\t\tjQuery.dequeue( this, opt.queue );\n+\t\t}\n+\t};\n+\n+\treturn opt;\n+};\n+\n+jQuery.fn.extend( {\n+\tfadeTo: function( speed, to, easing, callback ) {\n+\n+\t\t\/\/ Show any hidden elements after setting opacity to 0\n+\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n+\n+\t\t\t\/\/ Animate to the value specified\n+\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n+\t},\n+\tanimate: function( prop, speed, easing, callback ) {\n+\t\tvar empty = jQuery.isEmptyObject( prop ),\n+\t\t\toptall = jQuery.speed( speed, easing, callback ),\n+\t\t\tdoAnimation = function() {\n+\n+\t\t\t\t\/\/ Operate on a copy of prop so per-property easing won't be lost\n+\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n+\n+\t\t\t\t\/\/ Empty animations, or finishing resolves immediately\n+\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n+\t\t\t\t\tanim.stop( true );\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\tdoAnimation.finish = doAnimation;\n+\n+\t\treturn empty || optall.queue === false ?\n+\t\t\tthis.each( doAnimation ) :\n+\t\t\tthis.queue( optall.queue, doAnimation );\n+\t},\n+\tstop: function( type, clearQueue, gotoEnd ) {\n+\t\tvar stopQueue = function( hooks ) {\n+\t\t\tvar stop = hooks.stop;\n+\t\t\tdelete hooks.stop;\n+\t\t\tstop( gotoEnd );\n+\t\t};\n+\n+\t\tif ( typeof type !== \"string\" ) {\n+\t\t\tgotoEnd = clearQueue;\n+\t\t\tclearQueue = type;\n+\t\t\ttype = undefined;\n+\t\t}\n+\t\tif ( clearQueue ) {\n+\t\t\tthis.queue( type || \"fx\", [] );\n+\t\t}\n+\n+\t\treturn this.each( function() {\n+\t\t\tvar dequeue = true,\n+\t\t\t\tindex = type != null && type + \"queueHooks\",\n+\t\t\t\ttimers = jQuery.timers,\n+\t\t\t\tdata = dataPriv.get( this );\n+\n+\t\t\tif ( index ) {\n+\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n+\t\t\t\t\tstopQueue( data[ index ] );\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor ( index in data ) {\n+\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n+\t\t\t\t\t\tstopQueue( data[ index ] );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfor ( index = timers.length; index--; ) {\n+\t\t\t\tif ( timers[ index ].elem === this &&\n+\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n+\n+\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n+\t\t\t\t\tdequeue = false;\n+\t\t\t\t\ttimers.splice( index, 1 );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t\/\/ Start the next in the queue if the last step wasn't forced.\n+\t\t\t\/\/ Timers currently will call their complete callbacks, which\n+\t\t\t\/\/ will dequeue but only if they were gotoEnd.\n+\t\t\tif ( dequeue || !gotoEnd ) {\n+\t\t\t\tjQuery.dequeue( this, type );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\tfinish: function( type ) {\n+\t\tif ( type !== false ) {\n+\t\t\ttype = type || \"fx\";\n+\t\t}\n+\t\treturn this.each( function() {\n+\t\t\tvar index,\n+\t\t\t\tdata = dataPriv.get( this ),\n+\t\t\t\tqueue = data[ type + \"queue\" ],\n+\t\t\t\thooks = data[ type + \"queueHooks\" ],\n+\t\t\t\ttimers = jQuery.timers,\n+\t\t\t\tlength = queue ? queue.length : 0;\n+\n+\t\t\t\/\/ Enable finishing flag on private data\n+\t\t\tdata.finish = true;\n+\n+\t\t\t\/\/ Empty the queue first\n+\t\t\tjQuery.queue( this, type, [] );\n+\n+\t\t\tif ( hooks && hooks.stop ) {\n+\t\t\t\thooks.stop.call( this, true );\n+\t\t\t}\n+\n+\t\t\t\/\/ Look for any active animations, and finish them\n+\t\t\tfor ( index = timers.length; index--; ) {\n+\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n+\t\t\t\t\ttimers[ index ].anim.stop( true );\n+\t\t\t\t\ttimers.splice( index, 1 );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t\/\/ Look for any animations in the old queue and finish them\n+\t\t\tfor ( index = 0; index < length; index++ ) {\n+\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n+\t\t\t\t\tqueue[ index ].finish.call( this );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t\/\/ Turn off finishing flag\n+\t\t\tdelete data.finish;\n+\t\t} );\n+\t}\n+} );\n+\n+jQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( _i, name ) {\n+\tvar cssFn = jQuery.fn[ name ];\n+\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n+\t\treturn speed == null || typeof speed === \"boolean\" ?\n+\t\t\tcssFn.apply( this, arguments ) :\n+\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n+\t};\n+} );\n+\n+\/\/ Generate shortcuts for custom animations\n+jQuery.each( {\n+\tslideDown: genFx( \"show\" ),\n+\tslideUp: genFx( \"hide\" ),\n+\tslideToggle: genFx( \"toggle\" ),\n+\tfadeIn: { opacity: \"show\" },\n+\tfadeOut: { opacity: \"hide\" },\n+\tfadeToggle: { opacity: \"toggle\" }\n+}, function( name, props ) {\n+\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n+\t\treturn this.animate( props, speed, easing, callback );\n+\t};\n+} );\n+\n+jQuery.timers = [];\n+jQuery.fx.tick = function() {\n+\tvar timer,\n+\t\ti = 0,\n+\t\ttimers = jQuery.timers;\n+\n+\tfxNow = Date.now();\n+\n+\tfor ( ; i < timers.length; i++ ) {\n+\t\ttimer = timers[ i ];\n+\n+\t\t\/\/ Run the timer and safely remove it when done (allowing for external removal)\n+\t\tif ( !timer() && timers[ i ] === timer ) {\n+\t\t\ttimers.splice( i--, 1 );\n+\t\t}\n+\t}\n+\n+\tif ( !timers.length ) {\n+\t\tjQuery.fx.stop();\n+\t}\n+\tfxNow = undefined;\n+};\n+\n+jQuery.fx.timer = function( timer ) {\n+\tjQuery.timers.push( timer );\n+\tjQuery.fx.start();\n+};\n+\n+jQuery.fx.interval = 13;\n+jQuery.fx.start = function() {\n+\tif ( inProgress ) {\n+\t\treturn;\n+\t}\n+\n+\tinProgress = true;\n+\tschedule();\n+};\n+\n+jQuery.fx.stop = function() {\n+\tinProgress = null;\n+};\n+\n+jQuery.fx.speeds = {\n+\tslow: 600,\n+\tfast: 200,\n+\n+\t\/\/ Default speed\n+\t_default: 400\n+};\n+\n+\n+\/\/ Based off of the plugin by Clint Helfers, with permission.\n+jQuery.fn.delay = function( time, type ) {\n+\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n+\ttype = type || \"fx\";\n+\n+\treturn this.queue( type, function( next, hooks ) {\n+\t\tvar timeout = window.setTimeout( next, time );\n+\t\thooks.stop = function() {\n+\t\t\twindow.clearTimeout( timeout );\n+\t\t};\n+\t} );\n+};\n+\n+\n+( function() {\n+\tvar input = document.createElement( \"input\" ),\n+\t\tselect = document.createElement( \"select\" ),\n+\t\topt = select.appendChild( document.createElement( \"option\" ) );\n+\n+\tinput.type = \"checkbox\";\n+\n+\t\/\/ Support: Android <=4.3 only\n+\t\/\/ Default value for a checkbox should be \"on\"\n+\tsupport.checkOn = input.value !== \"\";\n+\n+\t\/\/ Support: IE <=11 only\n+\t\/\/ Must access selectedIndex to make default options select\n+\tsupport.optSelected = opt.selected;\n+\n+\t\/\/ Support: IE <=11 only\n+\t\/\/ An input loses its value after becoming a radio\n+\tinput = document.createElement( \"input\" );\n+\tinput.value = \"t\";\n+\tinput.type = \"radio\";\n+\tsupport.radioValue = input.value === \"t\";\n+} )();\n+\n+\n+var boolHook,\n+\tattrHandle = jQuery.expr.attrHandle;\n+\n+jQuery.fn.extend( {\n+\tattr: function( name, value ) {\n+\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n+\t},\n+\n+\tremoveAttr: function( name ) {\n+\t\treturn this.each( function() {\n+\t\t\tjQuery.removeAttr( this, name );\n+\t\t} );\n+\t}\n+} );\n+\n+jQuery.extend( {\n+\tattr: function( elem, name, value ) {\n+\t\tvar ret, hooks,\n+\t\t\tnType = elem.nodeType;\n+\n+\t\t\/\/ Don't get\/set attributes on text, comment and attribute nodes\n+\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ Fallback to prop when attributes are not supported\n+\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n+\t\t\treturn jQuery.prop( elem, name, value );\n+\t\t}\n+\n+\t\t\/\/ Attribute hooks are determined by the lowercase version\n+\t\t\/\/ Grab necessary hook if one is defined\n+\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n+\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n+\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n+\t\t}\n+\n+\t\tif ( value !== undefined ) {\n+\t\t\tif ( value === null ) {\n+\t\t\t\tjQuery.removeAttr( elem, name );\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tif ( hooks && \"set\" in hooks &&\n+\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\n+\t\t\telem.setAttribute( name, value + \"\" );\n+\t\t\treturn value;\n+\t\t}\n+\n+\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n+\t\t\treturn ret;\n+\t\t}\n+\n+\t\tret = jQuery.find.attr( elem, name );\n+\n+\t\t\/\/ Non-existent attributes return null, we normalize to undefined\n+\t\treturn ret == null ? undefined : ret;\n+\t},\n+\n+\tattrHooks: {\n+\t\ttype: {\n+\t\t\tset: function( elem, value ) {\n+\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n+\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n+\t\t\t\t\tvar val = elem.value;\n+\t\t\t\t\telem.setAttribute( \"type\", value );\n+\t\t\t\t\tif ( val ) {\n+\t\t\t\t\t\telem.value = val;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn value;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t},\n+\n+\tremoveAttr: function( elem, value ) {\n+\t\tvar name,\n+\t\t\ti = 0,\n+\n+\t\t\t\/\/ Attribute names can contain non-HTML whitespace characters\n+\t\t\t\/\/ https:\/\/html.spec.whatwg.org\/multipage\/syntax.html#attributes-2\n+\t\t\tattrNames = value && value.match( rnothtmlwhite );\n+\n+\t\tif ( attrNames && elem.nodeType === 1 ) {\n+\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n+\t\t\t\telem.removeAttribute( name );\n+\t\t\t}\n+\t\t}\n+\t}\n+} );\n+\n+\/\/ Hooks for boolean attributes\n+boolHook = {\n+\tset: function( elem, value, name ) {\n+\t\tif ( value === false ) {\n+\n+\t\t\t\/\/ Remove boolean attributes when set to false\n+\t\t\tjQuery.removeAttr( elem, name );\n+\t\t} else {\n+\t\t\telem.setAttribute( name, name );\n+\t\t}\n+\t\treturn name;\n+\t}\n+};\n+\n+jQuery.each( jQuery.expr.match.bool.source.match( \/\\w+\/g ), function( _i, name ) {\n+\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n+\n+\tattrHandle[ name ] = function( elem, name, isXML ) {\n+\t\tvar ret, handle,\n+\t\t\tlowercaseName = name.toLowerCase();\n+\n+\t\tif ( !isXML ) {\n+\n+\t\t\t\/\/ Avoid an infinite loop by temporarily removing this function from the getter\n+\t\t\thandle = attrHandle[ lowercaseName ];\n+\t\t\tattrHandle[ lowercaseName ] = ret;\n+\t\t\tret = getter( elem, name, isXML ) != null ?\n+\t\t\t\tlowercaseName :\n+\t\t\t\tnull;\n+\t\t\tattrHandle[ lowercaseName ] = handle;\n+\t\t}\n+\t\treturn ret;\n+\t};\n+} );\n+\n+\n+\n+\n+var rfocusable = \/^(?:input|select|textarea|button)$\/i,\n+\trclickable = \/^(?:a|area)$\/i;\n+\n+jQuery.fn.extend( {\n+\tprop: function( name, value ) {\n+\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n+\t},\n+\n+\tremoveProp: function( name ) {\n+\t\treturn this.each( function() {\n+\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n+\t\t} );\n+\t}\n+} );\n+\n+jQuery.extend( {\n+\tprop: function( elem, name, value ) {\n+\t\tvar ret, hooks,\n+\t\t\tnType = elem.nodeType;\n+\n+\t\t\/\/ Don't get\/set properties on text, comment and attribute nodes\n+\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n+\n+\t\t\t\/\/ Fix name and attach hooks\n+\t\t\tname = jQuery.propFix[ name ] || name;\n+\t\t\thooks = jQuery.propHooks[ name ];\n+\t\t}\n+\n+\t\tif ( value !== undefined ) {\n+\t\t\tif ( hooks && \"set\" in hooks &&\n+\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\n+\t\t\treturn ( elem[ name ] = value );\n+\t\t}\n+\n+\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n+\t\t\treturn ret;\n+\t\t}\n+\n+\t\treturn elem[ name ];\n+\t},\n+\n+\tpropHooks: {\n+\t\ttabIndex: {\n+\t\t\tget: function( elem ) {\n+\n+\t\t\t\t\/\/ Support: IE <=9 - 11 only\n+\t\t\t\t\/\/ elem.tabIndex doesn't always return the\n+\t\t\t\t\/\/ correct value when it hasn't been explicitly set\n+\t\t\t\t\/\/ Use proper attribute retrieval (trac-12072)\n+\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n+\n+\t\t\t\tif ( tabindex ) {\n+\t\t\t\t\treturn parseInt( tabindex, 10 );\n+\t\t\t\t}\n+\n+\t\t\t\tif (\n+\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n+\t\t\t\t\trclickable.test( elem.nodeName ) &&\n+\t\t\t\t\telem.href\n+\t\t\t\t) {\n+\t\t\t\t\treturn 0;\n+\t\t\t\t}\n+\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t}\n+\t},\n+\n+\tpropFix: {\n+\t\t\"for\": \"htmlFor\",\n+\t\t\"class\": \"className\"\n+\t}\n+} );\n+\n+\/\/ Support: IE <=11 only\n+\/\/ Accessing the selectedIndex property\n+\/\/ forces the browser to respect setting selected\n+\/\/ on the option\n+\/\/ The getter ensures a default option is selected\n+\/\/ when in an optgroup\n+\/\/ eslint rule \"no-unused-expressions\" is disabled for this code\n+\/\/ since it considers such accessions noop\n+if ( !support.optSelected ) {\n+\tjQuery.propHooks.selected = {\n+\t\tget: function( elem ) {\n+\n+\t\t\t\/* eslint no-unused-expressions: \"off\" *\/\n+\n+\t\t\tvar parent = elem.parentNode;\n+\t\t\tif ( parent && parent.parentNode ) {\n+\t\t\t\tparent.parentNode.selectedIndex;\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t},\n+\t\tset: function( elem ) {\n+\n+\t\t\t\/* eslint no-unused-expressions: \"off\" *\/\n+\n+\t\t\tvar parent = elem.parentNode;\n+\t\t\tif ( parent ) {\n+\t\t\t\tparent.selectedIndex;\n+\n+\t\t\t\tif ( parent.parentNode ) {\n+\t\t\t\t\tparent.parentNode.selectedIndex;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t};\n+}\n+\n+jQuery.each( [\n+\t\"tabIndex\",\n+\t\"readOnly\",\n+\t\"maxLength\",\n+\t\"cellSpacing\",\n+\t\"cellPadding\",\n+\t\"rowSpan\",\n+\t\"colSpan\",\n+\t\"useMap\",\n+\t\"frameBorder\",\n+\t\"contentEditable\"\n+], function() {\n+\tjQuery.propFix[ this.toLowerCase() ] = this;\n+} );\n+\n+\n+\n+\n+\t\/\/ Strip and collapse whitespace according to HTML spec\n+\t\/\/ https:\/\/infra.spec.whatwg.org\/#strip-and-collapse-ascii-whitespace\n+\tfunction stripAndCollapse( value ) {\n+\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n+\t\treturn tokens.join( \" \" );\n+\t}\n+\n+\n+function getClass( elem ) {\n+\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n+}\n+\n+function classesToArray( value ) {\n+\tif ( Array.isArray( value ) ) {\n+\t\treturn value;\n+\t}\n+\tif ( typeof value === \"string\" ) {\n+\t\treturn value.match( rnothtmlwhite ) || [];\n+\t}\n+\treturn [];\n+}\n+\n+jQuery.fn.extend( {\n+\taddClass: function( value ) {\n+\t\tvar classNames, cur, curValue, className, i, finalValue;\n+\n+\t\tif ( isFunction( value ) ) {\n+\t\t\treturn this.each( function( j ) {\n+\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n+\t\t\t} );\n+\t\t}\n+\n+\t\tclassNames = classesToArray( value );\n+\n+\t\tif ( classNames.length ) {\n+\t\t\treturn this.each( function() {\n+\t\t\t\tcurValue = getClass( this );\n+\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n+\n+\t\t\t\tif ( cur ) {\n+\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n+\t\t\t\t\t\tclassName = classNames[ i ];\n+\t\t\t\t\t\tif ( cur.indexOf( \" \" + className + \" \" ) < 0 ) {\n+\t\t\t\t\t\t\tcur += className + \" \";\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t\/\/ Only assign if different to avoid unneeded rendering.\n+\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n+\t\t\t\t\tif ( curValue !== finalValue ) {\n+\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} );\n+\t\t}\n+\n+\t\treturn this;\n+\t},\n+\n+\tremoveClass: function( value ) {\n+\t\tvar classNames, cur, curValue, className, i, finalValue;\n+\n+\t\tif ( isFunction( value ) ) {\n+\t\t\treturn this.each( function( j ) {\n+\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n+\t\t\t} );\n+\t\t}\n+\n+\t\tif ( !arguments.length ) {\n+\t\t\treturn this.attr( \"class\", \"\" );\n+\t\t}\n+\n+\t\tclassNames = classesToArray( value );\n+\n+\t\tif ( classNames.length ) {\n+\t\t\treturn this.each( function() {\n+\t\t\t\tcurValue = getClass( this );\n+\n+\t\t\t\t\/\/ This expression is here for better compressibility (see addClass)\n+\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n+\n+\t\t\t\tif ( cur ) {\n+\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n+\t\t\t\t\t\tclassName = classNames[ i ];\n+\n+\t\t\t\t\t\t\/\/ Remove *all* instances\n+\t\t\t\t\t\twhile ( cur.indexOf( \" \" + className + \" \" ) > -1 ) {\n+\t\t\t\t\t\t\tcur = cur.replace( \" \" + className + \" \", \" \" );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t\/\/ Only assign if different to avoid unneeded rendering.\n+\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n+\t\t\t\t\tif ( curValue !== finalValue ) {\n+\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} );\n+\t\t}\n+\n+\t\treturn this;\n+\t},\n+\n+\ttoggleClass: function( value, stateVal ) {\n+\t\tvar classNames, className, i, self,\n+\t\t\ttype = typeof value,\n+\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n+\n+\t\tif ( isFunction( value ) ) {\n+\t\t\treturn this.each( function( i ) {\n+\t\t\t\tjQuery( this ).toggleClass(\n+\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n+\t\t\t\t\tstateVal\n+\t\t\t\t);\n+\t\t\t} );\n+\t\t}\n+\n+\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n+\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n+\t\t}\n+\n+\t\tclassNames = classesToArray( value );\n+\n+\t\treturn this.each( function() {\n+\t\t\tif ( isValidValue ) {\n+\n+\t\t\t\t\/\/ Toggle individual class names\n+\t\t\t\tself = jQuery( this );\n+\n+\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n+\t\t\t\t\tclassName = classNames[ i ];\n+\n+\t\t\t\t\t\/\/ Check each className given, space separated list\n+\t\t\t\t\tif ( self.hasClass( className ) ) {\n+\t\t\t\t\t\tself.removeClass( className );\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tself.addClass( className );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\/\/ Toggle whole class name\n+\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n+\t\t\t\tclassName = getClass( this );\n+\t\t\t\tif ( className ) {\n+\n+\t\t\t\t\t\/\/ Store className if set\n+\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ If the element has a class name or if we're passed `false`,\n+\t\t\t\t\/\/ then remove the whole classname (if there was one, the above saved it).\n+\t\t\t\t\/\/ Otherwise bring back whatever was previously saved (if anything),\n+\t\t\t\t\/\/ falling back to the empty string if nothing was stored.\n+\t\t\t\tif ( this.setAttribute ) {\n+\t\t\t\t\tthis.setAttribute( \"class\",\n+\t\t\t\t\t\tclassName || value === false ?\n+\t\t\t\t\t\t\t\"\" :\n+\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\thasClass: function( selector ) {\n+\t\tvar className, elem,\n+\t\t\ti = 0;\n+\n+\t\tclassName = \" \" + selector + \" \";\n+\t\twhile ( ( elem = this[ i++ ] ) ) {\n+\t\t\tif ( elem.nodeType === 1 &&\n+\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+} );\n+\n+\n+\n+\n+var rreturn = \/\\r\/g;\n+\n+jQuery.fn.extend( {\n+\tval: function( value ) {\n+\t\tvar hooks, ret, valueIsFunction,\n+\t\t\telem = this[ 0 ];\n+\n+\t\tif ( !arguments.length ) {\n+\t\t\tif ( elem ) {\n+\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n+\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n+\n+\t\t\t\tif ( hooks &&\n+\t\t\t\t\t\"get\" in hooks &&\n+\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n+\t\t\t\t) {\n+\t\t\t\t\treturn ret;\n+\t\t\t\t}\n+\n+\t\t\t\tret = elem.value;\n+\n+\t\t\t\t\/\/ Handle most common string cases\n+\t\t\t\tif ( typeof ret === \"string\" ) {\n+\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Handle cases where value is null\/undef or number\n+\t\t\t\treturn ret == null ? \"\" : ret;\n+\t\t\t}\n+\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tvalueIsFunction = isFunction( value );\n+\n+\t\treturn this.each( function( i ) {\n+\t\t\tvar val;\n+\n+\t\t\tif ( this.nodeType !== 1 ) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tif ( valueIsFunction ) {\n+\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n+\t\t\t} else {\n+\t\t\t\tval = value;\n+\t\t\t}\n+\n+\t\t\t\/\/ Treat null\/undefined as \"\"; convert numbers to string\n+\t\t\tif ( val == null ) {\n+\t\t\t\tval = \"\";\n+\n+\t\t\t} else if ( typeof val === \"number\" ) {\n+\t\t\t\tval += \"\";\n+\n+\t\t\t} else if ( Array.isArray( val ) ) {\n+\t\t\t\tval = jQuery.map( val, function( value ) {\n+\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n+\t\t\t\t} );\n+\t\t\t}\n+\n+\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n+\n+\t\t\t\/\/ If set returns undefined, fall back to normal setting\n+\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n+\t\t\t\tthis.value = val;\n+\t\t\t}\n+\t\t} );\n+\t}\n+} );\n+\n+jQuery.extend( {\n+\tvalHooks: {\n+\t\toption: {\n+\t\t\tget: function( elem ) {\n+\n+\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n+\t\t\t\treturn val != null ?\n+\t\t\t\t\tval :\n+\n+\t\t\t\t\t\/\/ Support: IE <=10 - 11 only\n+\t\t\t\t\t\/\/ option.text throws exceptions (trac-14686, trac-14858)\n+\t\t\t\t\t\/\/ Strip and collapse whitespace\n+\t\t\t\t\t\/\/ https:\/\/html.spec.whatwg.org\/#strip-and-collapse-whitespace\n+\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n+\t\t\t}\n+\t\t},\n+\t\tselect: {\n+\t\t\tget: function( elem ) {\n+\t\t\t\tvar value, option, i,\n+\t\t\t\t\toptions = elem.options,\n+\t\t\t\t\tindex = elem.selectedIndex,\n+\t\t\t\t\tone = elem.type === \"select-one\",\n+\t\t\t\t\tvalues = one ? null : [],\n+\t\t\t\t\tmax = one ? index + 1 : options.length;\n+\n+\t\t\t\tif ( index < 0 ) {\n+\t\t\t\t\ti = max;\n+\n+\t\t\t\t} else {\n+\t\t\t\t\ti = one ? index : 0;\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Loop through all the selected options\n+\t\t\t\tfor ( ; i < max; i++ ) {\n+\t\t\t\t\toption = options[ i ];\n+\n+\t\t\t\t\t\/\/ Support: IE <=9 only\n+\t\t\t\t\t\/\/ IE8-9 doesn't update selected after form reset (trac-2551)\n+\t\t\t\t\tif ( ( option.selected || i === index ) &&\n+\n+\t\t\t\t\t\t\t\/\/ Don't return options that are disabled or in a disabled optgroup\n+\t\t\t\t\t\t\t!option.disabled &&\n+\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n+\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n+\n+\t\t\t\t\t\t\/\/ Get the specific value for the option\n+\t\t\t\t\t\tvalue = jQuery( option ).val();\n+\n+\t\t\t\t\t\t\/\/ We don't need an array for one selects\n+\t\t\t\t\t\tif ( one ) {\n+\t\t\t\t\t\t\treturn value;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\/\/ Multi-Selects return an array\n+\t\t\t\t\t\tvalues.push( value );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn values;\n+\t\t\t},\n+\n+\t\t\tset: function( elem, value ) {\n+\t\t\t\tvar optionSet, option,\n+\t\t\t\t\toptions = elem.options,\n+\t\t\t\t\tvalues = jQuery.makeArray( value ),\n+\t\t\t\t\ti = options.length;\n+\n+\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\toption = options[ i ];\n+\n+\t\t\t\t\t\/* eslint-disable no-cond-assign *\/\n+\n+\t\t\t\t\tif ( option.selected =\n+\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n+\t\t\t\t\t) {\n+\t\t\t\t\t\toptionSet = true;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t\/* eslint-enable no-cond-assign *\/\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Force browsers to behave consistently when non-matching value is set\n+\t\t\t\tif ( !optionSet ) {\n+\t\t\t\t\telem.selectedIndex = -1;\n+\t\t\t\t}\n+\t\t\t\treturn values;\n+\t\t\t}\n+\t\t}\n+\t}\n+} );\n+\n+\/\/ Radios and checkboxes getter\/setter\n+jQuery.each( [ \"radio\", \"checkbox\" ], function() {\n+\tjQuery.valHooks[ this ] = {\n+\t\tset: function( elem, value ) {\n+\t\t\tif ( Array.isArray( value ) ) {\n+\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n+\t\t\t}\n+\t\t}\n+\t};\n+\tif ( !support.checkOn ) {\n+\t\tjQuery.valHooks[ this ].get = function( elem ) {\n+\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n+\t\t};\n+\t}\n+} );\n+\n+\n+\n+\n+\/\/ Return jQuery for attributes-only inclusion\n+var location = window.location;\n+\n+var nonce = { guid: Date.now() };\n+\n+var rquery = ( \/\\?\/ );\n+\n+\n+\n+\/\/ Cross-browser xml parsing\n+jQuery.parseXML = function( data ) {\n+\tvar xml, parserErrorElem;\n+\tif ( !data || typeof data !== \"string\" ) {\n+\t\treturn null;\n+\t}\n+\n+\t\/\/ Support: IE 9 - 11 only\n+\t\/\/ IE throws on parseFromString with invalid input.\n+\ttry {\n+\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text\/xml\" );\n+\t} catch ( e ) {}\n+\n+\tparserErrorElem = xml && xml.getElementsByTagName( \"parsererror\" )[ 0 ];\n+\tif ( !xml || parserErrorElem ) {\n+\t\tjQuery.error( \"Invalid XML: \" + (\n+\t\t\tparserErrorElem ?\n+\t\t\t\tjQuery.map( parserErrorElem.childNodes, function( el ) {\n+\t\t\t\t\treturn el.textContent;\n+\t\t\t\t} ).join( \"\\n\" ) :\n+\t\t\t\tdata\n+\t\t) );\n+\t}\n+\treturn xml;\n+};\n+\n+\n+var rfocusMorph = \/^(?:focusinfocus|focusoutblur)$\/,\n+\tstopPropagationCallback = function( e ) {\n+\t\te.stopPropagation();\n+\t};\n+\n+jQuery.extend( jQuery.event, {\n+\n+\ttrigger: function( event, data, elem, onlyHandlers ) {\n+\n+\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n+\t\t\teventPath = [ elem || document ],\n+\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n+\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n+\n+\t\tcur = lastElement = tmp = elem = elem || document;\n+\n+\t\t\/\/ Don't do events on text and comment nodes\n+\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ focus\/blur morphs to focusin\/out; ensure we're not firing them right now\n+\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif ( type.indexOf( \".\" ) > -1 ) {\n+\n+\t\t\t\/\/ Namespaced trigger; create a regexp to match event type in handle()\n+\t\t\tnamespaces = type.split( \".\" );\n+\t\t\ttype = namespaces.shift();\n+\t\t\tnamespaces.sort();\n+\t\t}\n+\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n+\n+\t\t\/\/ Caller can pass in a jQuery.Event object, Object, or just an event type string\n+\t\tevent = event[ jQuery.expando ] ?\n+\t\t\tevent :\n+\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n+\n+\t\t\/\/ Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n+\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n+\t\tevent.namespace = namespaces.join( \".\" );\n+\t\tevent.rnamespace = event.namespace ?\n+\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n+\t\t\tnull;\n+\n+\t\t\/\/ Clean up the event in case it is being reused\n+\t\tevent.result = undefined;\n+\t\tif ( !event.target ) {\n+\t\t\tevent.target = elem;\n+\t\t}\n+\n+\t\t\/\/ Clone any incoming data and prepend the event, creating the handler arg list\n+\t\tdata = data == null ?\n+\t\t\t[ event ] :\n+\t\t\tjQuery.makeArray( data, [ event ] );\n+\n+\t\t\/\/ Allow special events to draw outside the lines\n+\t\tspecial = jQuery.event.special[ type ] || {};\n+\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ Determine event propagation path in advance, per W3C events spec (trac-9951)\n+\t\t\/\/ Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)\n+\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n+\n+\t\t\tbubbleType = special.delegateType || type;\n+\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n+\t\t\t\tcur = cur.parentNode;\n+\t\t\t}\n+\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n+\t\t\t\teventPath.push( cur );\n+\t\t\t\ttmp = cur;\n+\t\t\t}\n+\n+\t\t\t\/\/ Only add window if we got to document (e.g., not plain obj or detached DOM)\n+\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n+\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Fire handlers on the event path\n+\t\ti = 0;\n+\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n+\t\t\tlastElement = cur;\n+\t\t\tevent.type = i > 1 ?\n+\t\t\t\tbubbleType :\n+\t\t\t\tspecial.bindType || type;\n+\n+\t\t\t\/\/ jQuery handler\n+\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || Object.create( null ) )[ event.type ] &&\n+\t\t\t\tdataPriv.get( cur, \"handle\" );\n+\t\t\tif ( handle ) {\n+\t\t\t\thandle.apply( cur, data );\n+\t\t\t}\n+\n+\t\t\t\/\/ Native handler\n+\t\t\thandle = ontype && cur[ ontype ];\n+\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n+\t\t\t\tevent.result = handle.apply( cur, data );\n+\t\t\t\tif ( event.result === false ) {\n+\t\t\t\t\tevent.preventDefault();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tevent.type = type;\n+\n+\t\t\/\/ If nobody prevented the default action, do it now\n+\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n+\n+\t\t\tif ( ( !special._default ||\n+\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n+\t\t\t\tacceptData( elem ) ) {\n+\n+\t\t\t\t\/\/ Call a native DOM method on the target with the same name as the event.\n+\t\t\t\t\/\/ Don't do default actions on window, that's where global variables be (trac-6170)\n+\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n+\n+\t\t\t\t\t\/\/ Don't re-trigger an onFOO event when we call its FOO() method\n+\t\t\t\t\ttmp = elem[ ontype ];\n+\n+\t\t\t\t\tif ( tmp ) {\n+\t\t\t\t\t\telem[ ontype ] = null;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t\/\/ Prevent re-triggering of the same event, since we already bubbled it above\n+\t\t\t\t\tjQuery.event.triggered = type;\n+\n+\t\t\t\t\tif ( event.isPropagationStopped() ) {\n+\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n+\t\t\t\t\t}\n+\n+\t\t\t\t\telem[ type ]();\n+\n+\t\t\t\t\tif ( event.isPropagationStopped() ) {\n+\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tjQuery.event.triggered = undefined;\n+\n+\t\t\t\t\tif ( tmp ) {\n+\t\t\t\t\t\telem[ ontype ] = tmp;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn event.result;\n+\t},\n+\n+\t\/\/ Piggyback on a donor event to simulate a different one\n+\t\/\/ Used only for `focus(in | out)` events\n+\tsimulate: function( type, elem, event ) {\n+\t\tvar e = jQuery.extend(\n+\t\t\tnew jQuery.Event(),\n+\t\t\tevent,\n+\t\t\t{\n+\t\t\t\ttype: type,\n+\t\t\t\tisSimulated: true\n+\t\t\t}\n+\t\t);\n+\n+\t\tjQuery.event.trigger( e, null, elem );\n+\t}\n+\n+} );\n+\n+jQuery.fn.extend( {\n+\n+\ttrigger: function( type, data ) {\n+\t\treturn this.each( function() {\n+\t\t\tjQuery.event.trigger( type, data, this );\n+\t\t} );\n+\t},\n+\ttriggerHandler: function( type, data ) {\n+\t\tvar elem = this[ 0 ];\n+\t\tif ( elem ) {\n+\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n+\t\t}\n+\t}\n+} );\n+\n+\n+var\n+\trbracket = \/\\[\\]$\/,\n+\trCRLF = \/\\r?\\n\/g,\n+\trsubmitterTypes = \/^(?:submit|button|image|reset|file)$\/i,\n+\trsubmittable = \/^(?:input|select|textarea|keygen)\/i;\n+\n+function buildParams( prefix, obj, traditional, add ) {\n+\tvar name;\n+\n+\tif ( Array.isArray( obj ) ) {\n+\n+\t\t\/\/ Serialize array item.\n+\t\tjQuery.each( obj, function( i, v ) {\n+\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n+\n+\t\t\t\t\/\/ Treat each array item as a scalar.\n+\t\t\t\tadd( prefix, v );\n+\n+\t\t\t} else {\n+\n+\t\t\t\t\/\/ Item is non-scalar (array or object), encode its numeric index.\n+\t\t\t\tbuildParams(\n+\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n+\t\t\t\t\tv,\n+\t\t\t\t\ttraditional,\n+\t\t\t\t\tadd\n+\t\t\t\t);\n+\t\t\t}\n+\t\t} );\n+\n+\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n+\n+\t\t\/\/ Serialize object item.\n+\t\tfor ( name in obj ) {\n+\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n+\t\t}\n+\n+\t} else {\n+\n+\t\t\/\/ Serialize scalar item.\n+\t\tadd( prefix, obj );\n+\t}\n+}\n+\n+\/\/ Serialize an array of form elements or a set of\n+\/\/ key\/values into a query string\n+jQuery.param = function( a, traditional ) {\n+\tvar prefix,\n+\t\ts = [],\n+\t\tadd = function( key, valueOrFunction ) {\n+\n+\t\t\t\/\/ If value is a function, invoke it and use its return value\n+\t\t\tvar value = isFunction( valueOrFunction ) ?\n+\t\t\t\tvalueOrFunction() :\n+\t\t\t\tvalueOrFunction;\n+\n+\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n+\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n+\t\t};\n+\n+\tif ( a == null ) {\n+\t\treturn \"\";\n+\t}\n+\n+\t\/\/ If an array was passed in, assume that it is an array of form elements.\n+\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n+\n+\t\t\/\/ Serialize the form elements\n+\t\tjQuery.each( a, function() {\n+\t\t\tadd( this.name, this.value );\n+\t\t} );\n+\n+\t} else {\n+\n+\t\t\/\/ If traditional, encode the \"old\" way (the way 1.3.2 or older\n+\t\t\/\/ did it), otherwise encode params recursively.\n+\t\tfor ( prefix in a ) {\n+\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n+\t\t}\n+\t}\n+\n+\t\/\/ Return the resulting serialization\n+\treturn s.join( \"&\" );\n+};\n+\n+jQuery.fn.extend( {\n+\tserialize: function() {\n+\t\treturn jQuery.param( this.serializeArray() );\n+\t},\n+\tserializeArray: function() {\n+\t\treturn this.map( function() {\n+\n+\t\t\t\/\/ Can add propHook for \"elements\" to filter or add form elements\n+\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n+\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n+\t\t} ).filter( function() {\n+\t\t\tvar type = this.type;\n+\n+\t\t\t\/\/ Use .is( \":disabled\" ) so that fieldset[disabled] works\n+\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n+\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n+\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n+\t\t} ).map( function( _i, elem ) {\n+\t\t\tvar val = jQuery( this ).val();\n+\n+\t\t\tif ( val == null ) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tif ( Array.isArray( val ) ) {\n+\t\t\t\treturn jQuery.map( val, function( val ) {\n+\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n+\t\t\t\t} );\n+\t\t\t}\n+\n+\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n+\t\t} ).get();\n+\t}\n+} );\n+\n+\n+var\n+\tr20 = \/%20\/g,\n+\trhash = \/#.*$\/,\n+\trantiCache = \/([?&])_=[^&]*\/,\n+\trheaders = \/^(.*?):[ \\t]*([^\\r\\n]*)$\/mg,\n+\n+\t\/\/ trac-7653, trac-8125, trac-8152: local protocol detection\n+\trlocalProtocol = \/^(?:about|app|app-storage|.+-extension|file|res|widget):$\/,\n+\trnoContent = \/^(?:GET|HEAD)$\/,\n+\trprotocol = \/^\\\/\\\/\/,\n+\n+\t\/* Prefilters\n+\t * 1) They are useful to introduce custom dataTypes (see ajax\/jsonp.js for an example)\n+\t * 2) These are called:\n+\t *    - BEFORE asking for a transport\n+\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n+\t * 3) key is the dataType\n+\t * 4) the catchall symbol \"*\" can be used\n+\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n+\t *\/\n+\tprefilters = {},\n+\n+\t\/* Transports bindings\n+\t * 1) key is the dataType\n+\t * 2) the catchall symbol \"*\" can be used\n+\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n+\t *\/\n+\ttransports = {},\n+\n+\t\/\/ Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression\n+\tallTypes = \"*\/\".concat( \"*\" ),\n+\n+\t\/\/ Anchor tag for parsing the document origin\n+\toriginAnchor = document.createElement( \"a\" );\n+\n+originAnchor.href = location.href;\n+\n+\/\/ Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n+function addToPrefiltersOrTransports( structure ) {\n+\n+\t\/\/ dataTypeExpression is optional and defaults to \"*\"\n+\treturn function( dataTypeExpression, func ) {\n+\n+\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n+\t\t\tfunc = dataTypeExpression;\n+\t\t\tdataTypeExpression = \"*\";\n+\t\t}\n+\n+\t\tvar dataType,\n+\t\t\ti = 0,\n+\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n+\n+\t\tif ( isFunction( func ) ) {\n+\n+\t\t\t\/\/ For each dataType in the dataTypeExpression\n+\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n+\n+\t\t\t\t\/\/ Prepend if requested\n+\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n+\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n+\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n+\n+\t\t\t\t\/\/ Otherwise append\n+\t\t\t\t} else {\n+\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t};\n+}\n+\n+\/\/ Base inspection function for prefilters and transports\n+function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n+\n+\tvar inspected = {},\n+\t\tseekingTransport = ( structure === transports );\n+\n+\tfunction inspect( dataType ) {\n+\t\tvar selected;\n+\t\tinspected[ dataType ] = true;\n+\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n+\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n+\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n+\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n+\n+\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n+\t\t\t\tinspect( dataTypeOrTransport );\n+\t\t\t\treturn false;\n+\t\t\t} else if ( seekingTransport ) {\n+\t\t\t\treturn !( selected = dataTypeOrTransport );\n+\t\t\t}\n+\t\t} );\n+\t\treturn selected;\n+\t}\n+\n+\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n+}\n+\n+\/\/ A special extend for ajax options\n+\/\/ that takes \"flat\" options (not to be deep extended)\n+\/\/ Fixes trac-9887\n+function ajaxExtend( target, src ) {\n+\tvar key, deep,\n+\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n+\n+\tfor ( key in src ) {\n+\t\tif ( src[ key ] !== undefined ) {\n+\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n+\t\t}\n+\t}\n+\tif ( deep ) {\n+\t\tjQuery.extend( true, target, deep );\n+\t}\n+\n+\treturn target;\n+}\n+\n+\/* Handles responses to an ajax request:\n+ * - finds the right dataType (mediates between content-type and expected dataType)\n+ * - returns the corresponding response\n+ *\/\n+function ajaxHandleResponses( s, jqXHR, responses ) {\n+\n+\tvar ct, type, finalDataType, firstDataType,\n+\t\tcontents = s.contents,\n+\t\tdataTypes = s.dataTypes;\n+\n+\t\/\/ Remove auto dataType and get content-type in the process\n+\twhile ( dataTypes[ 0 ] === \"*\" ) {\n+\t\tdataTypes.shift();\n+\t\tif ( ct === undefined ) {\n+\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n+\t\t}\n+\t}\n+\n+\t\/\/ Check if we're dealing with a known content-type\n+\tif ( ct ) {\n+\t\tfor ( type in contents ) {\n+\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n+\t\t\t\tdataTypes.unshift( type );\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t\/\/ Check to see if we have a response for the expected dataType\n+\tif ( dataTypes[ 0 ] in responses ) {\n+\t\tfinalDataType = dataTypes[ 0 ];\n+\t} else {\n+\n+\t\t\/\/ Try convertible dataTypes\n+\t\tfor ( type in responses ) {\n+\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n+\t\t\t\tfinalDataType = type;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif ( !firstDataType ) {\n+\t\t\t\tfirstDataType = type;\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Or just use first one\n+\t\tfinalDataType = finalDataType || firstDataType;\n+\t}\n+\n+\t\/\/ If we found a dataType\n+\t\/\/ We add the dataType to the list if needed\n+\t\/\/ and return the corresponding response\n+\tif ( finalDataType ) {\n+\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n+\t\t\tdataTypes.unshift( finalDataType );\n+\t\t}\n+\t\treturn responses[ finalDataType ];\n+\t}\n+}\n+\n+\/* Chain conversions given the request and the original response\n+ * Also sets the responseXXX fields on the jqXHR instance\n+ *\/\n+function ajaxConvert( s, response, jqXHR, isSuccess ) {\n+\tvar conv2, current, conv, tmp, prev,\n+\t\tconverters = {},\n+\n+\t\t\/\/ Work with a copy of dataTypes in case we need to modify it for conversion\n+\t\tdataTypes = s.dataTypes.slice();\n+\n+\t\/\/ Create converters map with lowercased keys\n+\tif ( dataTypes[ 1 ] ) {\n+\t\tfor ( conv in s.converters ) {\n+\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n+\t\t}\n+\t}\n+\n+\tcurrent = dataTypes.shift();\n+\n+\t\/\/ Convert to each sequential dataType\n+\twhile ( current ) {\n+\n+\t\tif ( s.responseFields[ current ] ) {\n+\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n+\t\t}\n+\n+\t\t\/\/ Apply the dataFilter if provided\n+\t\tif ( !prev && isSuccess && s.dataFilter ) {\n+\t\t\tresponse = s.dataFilter( response, s.dataType );\n+\t\t}\n+\n+\t\tprev = current;\n+\t\tcurrent = dataTypes.shift();\n+\n+\t\tif ( current ) {\n+\n+\t\t\t\/\/ There's only work to do if current dataType is non-auto\n+\t\t\tif ( current === \"*\" ) {\n+\n+\t\t\t\tcurrent = prev;\n+\n+\t\t\t\/\/ Convert response if prev dataType is non-auto and differs from current\n+\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n+\n+\t\t\t\t\/\/ Seek a direct converter\n+\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n+\n+\t\t\t\t\/\/ If none found, seek a pair\n+\t\t\t\tif ( !conv ) {\n+\t\t\t\t\tfor ( conv2 in converters ) {\n+\n+\t\t\t\t\t\t\/\/ If conv2 outputs current\n+\t\t\t\t\t\ttmp = conv2.split( \" \" );\n+\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n+\n+\t\t\t\t\t\t\t\/\/ If prev can be converted to accepted input\n+\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n+\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n+\t\t\t\t\t\t\tif ( conv ) {\n+\n+\t\t\t\t\t\t\t\t\/\/ Condense equivalence converters\n+\t\t\t\t\t\t\t\tif ( conv === true ) {\n+\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n+\n+\t\t\t\t\t\t\t\t\/\/ Otherwise, insert the intermediate dataType\n+\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n+\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n+\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Apply converter (if not an equivalence)\n+\t\t\t\tif ( conv !== true ) {\n+\n+\t\t\t\t\t\/\/ Unless errors are allowed to bubble, catch and return them\n+\t\t\t\t\tif ( conv && s.throws ) {\n+\t\t\t\t\t\tresponse = conv( response );\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tresponse = conv( response );\n+\t\t\t\t\t\t} catch ( e ) {\n+\t\t\t\t\t\t\treturn {\n+\t\t\t\t\t\t\t\tstate: \"parsererror\",\n+\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n+\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn { state: \"success\", data: response };\n+}\n+\n+jQuery.extend( {\n+\n+\t\/\/ Counter for holding the number of active queries\n+\tactive: 0,\n+\n+\t\/\/ Last-Modified header cache for next request\n+\tlastModified: {},\n+\tetag: {},\n+\n+\tajaxSettings: {\n+\t\turl: location.href,\n+\t\ttype: \"GET\",\n+\t\tisLocal: rlocalProtocol.test( location.protocol ),\n+\t\tglobal: true,\n+\t\tprocessData: true,\n+\t\tasync: true,\n+\t\tcontentType: \"application\/x-www-form-urlencoded; charset=UTF-8\",\n+\n+\t\t\/*\n+\t\ttimeout: 0,\n+\t\tdata: null,\n+\t\tdataType: null,\n+\t\tusername: null,\n+\t\tpassword: null,\n+\t\tcache: null,\n+\t\tthrows: false,\n+\t\ttraditional: false,\n+\t\theaders: {},\n+\t\t*\/\n+\n+\t\taccepts: {\n+\t\t\t\"*\": allTypes,\n+\t\t\ttext: \"text\/plain\",\n+\t\t\thtml: \"text\/html\",\n+\t\t\txml: \"application\/xml, text\/xml\",\n+\t\t\tjson: \"application\/json, text\/javascript\"\n+\t\t},\n+\n+\t\tcontents: {\n+\t\t\txml: \/\\bxml\\b\/,\n+\t\t\thtml: \/\\bhtml\/,\n+\t\t\tjson: \/\\bjson\\b\/\n+\t\t},\n+\n+\t\tresponseFields: {\n+\t\t\txml: \"responseXML\",\n+\t\t\ttext: \"responseText\",\n+\t\t\tjson: \"responseJSON\"\n+\t\t},\n+\n+\t\t\/\/ Data converters\n+\t\t\/\/ Keys separate source (or catchall \"*\") and destination types with a single space\n+\t\tconverters: {\n+\n+\t\t\t\/\/ Convert anything to text\n+\t\t\t\"* text\": String,\n+\n+\t\t\t\/\/ Text to html (true = no transformation)\n+\t\t\t\"text html\": true,\n+\n+\t\t\t\/\/ Evaluate text as a json expression\n+\t\t\t\"text json\": JSON.parse,\n+\n+\t\t\t\/\/ Parse text as xml\n+\t\t\t\"text xml\": jQuery.parseXML\n+\t\t},\n+\n+\t\t\/\/ For options that shouldn't be deep extended:\n+\t\t\/\/ you can add your own custom options here if\n+\t\t\/\/ and when you create one that shouldn't be\n+\t\t\/\/ deep extended (see ajaxExtend)\n+\t\tflatOptions: {\n+\t\t\turl: true,\n+\t\t\tcontext: true\n+\t\t}\n+\t},\n+\n+\t\/\/ Creates a full fledged settings object into target\n+\t\/\/ with both ajaxSettings and settings fields.\n+\t\/\/ If target is omitted, writes into ajaxSettings.\n+\tajaxSetup: function( target, settings ) {\n+\t\treturn settings ?\n+\n+\t\t\t\/\/ Building a settings object\n+\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n+\n+\t\t\t\/\/ Extending ajaxSettings\n+\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n+\t},\n+\n+\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n+\tajaxTransport: addToPrefiltersOrTransports( transports ),\n+\n+\t\/\/ Main method\n+\tajax: function( url, options ) {\n+\n+\t\t\/\/ If url is an object, simulate pre-1.5 signature\n+\t\tif ( typeof url === \"object\" ) {\n+\t\t\toptions = url;\n+\t\t\turl = undefined;\n+\t\t}\n+\n+\t\t\/\/ Force options to be an object\n+\t\toptions = options || {};\n+\n+\t\tvar transport,\n+\n+\t\t\t\/\/ URL without anti-cache param\n+\t\t\tcacheURL,\n+\n+\t\t\t\/\/ Response headers\n+\t\t\tresponseHeadersString,\n+\t\t\tresponseHeaders,\n+\n+\t\t\t\/\/ timeout handle\n+\t\t\ttimeoutTimer,\n+\n+\t\t\t\/\/ Url cleanup var\n+\t\t\turlAnchor,\n+\n+\t\t\t\/\/ Request state (becomes false upon send and true upon completion)\n+\t\t\tcompleted,\n+\n+\t\t\t\/\/ To know if global events are to be dispatched\n+\t\t\tfireGlobals,\n+\n+\t\t\t\/\/ Loop variable\n+\t\t\ti,\n+\n+\t\t\t\/\/ uncached part of the url\n+\t\t\tuncached,\n+\n+\t\t\t\/\/ Create the final options object\n+\t\t\ts = jQuery.ajaxSetup( {}, options ),\n+\n+\t\t\t\/\/ Callbacks context\n+\t\t\tcallbackContext = s.context || s,\n+\n+\t\t\t\/\/ Context for global events is callbackContext if it is a DOM node or jQuery collection\n+\t\t\tglobalEventContext = s.context &&\n+\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n+\t\t\t\tjQuery( callbackContext ) :\n+\t\t\t\tjQuery.event,\n+\n+\t\t\t\/\/ Deferreds\n+\t\t\tdeferred = jQuery.Deferred(),\n+\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n+\n+\t\t\t\/\/ Status-dependent callbacks\n+\t\t\tstatusCode = s.statusCode || {},\n+\n+\t\t\t\/\/ Headers (they are sent all at once)\n+\t\t\trequestHeaders = {},\n+\t\t\trequestHeadersNames = {},\n+\n+\t\t\t\/\/ Default abort message\n+\t\t\tstrAbort = \"canceled\",\n+\n+\t\t\t\/\/ Fake xhr\n+\t\t\tjqXHR = {\n+\t\t\t\treadyState: 0,\n+\n+\t\t\t\t\/\/ Builds headers hashtable if needed\n+\t\t\t\tgetResponseHeader: function( key ) {\n+\t\t\t\t\tvar match;\n+\t\t\t\t\tif ( completed ) {\n+\t\t\t\t\t\tif ( !responseHeaders ) {\n+\t\t\t\t\t\t\tresponseHeaders = {};\n+\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n+\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n+\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n+\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n+\t\t\t\t\t}\n+\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n+\t\t\t\t},\n+\n+\t\t\t\t\/\/ Raw string\n+\t\t\t\tgetAllResponseHeaders: function() {\n+\t\t\t\t\treturn completed ? responseHeadersString : null;\n+\t\t\t\t},\n+\n+\t\t\t\t\/\/ Caches the header\n+\t\t\t\tsetRequestHeader: function( name, value ) {\n+\t\t\t\t\tif ( completed == null ) {\n+\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n+\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n+\t\t\t\t\t\trequestHeaders[ name ] = value;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn this;\n+\t\t\t\t},\n+\n+\t\t\t\t\/\/ Overrides response content-type header\n+\t\t\t\toverrideMimeType: function( type ) {\n+\t\t\t\t\tif ( completed == null ) {\n+\t\t\t\t\t\ts.mimeType = type;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn this;\n+\t\t\t\t},\n+\n+\t\t\t\t\/\/ Status-dependent callbacks\n+\t\t\t\tstatusCode: function( map ) {\n+\t\t\t\t\tvar code;\n+\t\t\t\t\tif ( map ) {\n+\t\t\t\t\t\tif ( completed ) {\n+\n+\t\t\t\t\t\t\t\/\/ Execute the appropriate callbacks\n+\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n+\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t\/\/ Lazy-add the new callbacks in a way that preserves old ones\n+\t\t\t\t\t\t\tfor ( code in map ) {\n+\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\treturn this;\n+\t\t\t\t},\n+\n+\t\t\t\t\/\/ Cancel the request\n+\t\t\t\tabort: function( statusText ) {\n+\t\t\t\t\tvar finalText = statusText || strAbort;\n+\t\t\t\t\tif ( transport ) {\n+\t\t\t\t\t\ttransport.abort( finalText );\n+\t\t\t\t\t}\n+\t\t\t\t\tdone( 0, finalText );\n+\t\t\t\t\treturn this;\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\t\/\/ Attach deferreds\n+\t\tdeferred.promise( jqXHR );\n+\n+\t\t\/\/ Add protocol if not provided (prefilters might expect it)\n+\t\t\/\/ Handle falsy url in the settings object (trac-10093: consistency with old signature)\n+\t\t\/\/ We also use the url parameter if available\n+\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n+\t\t\t.replace( rprotocol, location.protocol + \"\/\/\" );\n+\n+\t\t\/\/ Alias method option to type as per ticket trac-12004\n+\t\ts.type = options.method || options.type || s.method || s.type;\n+\n+\t\t\/\/ Extract dataTypes list\n+\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n+\n+\t\t\/\/ A cross-domain request is in order when the origin doesn't match the current origin.\n+\t\tif ( s.crossDomain == null ) {\n+\t\t\turlAnchor = document.createElement( \"a\" );\n+\n+\t\t\t\/\/ Support: IE <=8 - 11, Edge 12 - 15\n+\t\t\t\/\/ IE throws exception on accessing the href property if url is malformed,\n+\t\t\t\/\/ e.g. http:\/\/example.com:80x\/\n+\t\t\ttry {\n+\t\t\t\turlAnchor.href = s.url;\n+\n+\t\t\t\t\/\/ Support: IE <=8 - 11 only\n+\t\t\t\t\/\/ Anchor's host property isn't correctly set when s.url is relative\n+\t\t\t\turlAnchor.href = urlAnchor.href;\n+\t\t\t\ts.crossDomain = originAnchor.protocol + \"\/\/\" + originAnchor.host !==\n+\t\t\t\t\turlAnchor.protocol + \"\/\/\" + urlAnchor.host;\n+\t\t\t} catch ( e ) {\n+\n+\t\t\t\t\/\/ If there is an error parsing the URL, assume it is crossDomain,\n+\t\t\t\t\/\/ it can be rejected by the transport if it is invalid\n+\t\t\t\ts.crossDomain = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Convert data if not already a string\n+\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n+\t\t\ts.data = jQuery.param( s.data, s.traditional );\n+\t\t}\n+\n+\t\t\/\/ Apply prefilters\n+\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n+\n+\t\t\/\/ If request was aborted inside a prefilter, stop there\n+\t\tif ( completed ) {\n+\t\t\treturn jqXHR;\n+\t\t}\n+\n+\t\t\/\/ We can fire global events as of now if asked to\n+\t\t\/\/ Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)\n+\t\tfireGlobals = jQuery.event && s.global;\n+\n+\t\t\/\/ Watch for a new set of requests\n+\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n+\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n+\t\t}\n+\n+\t\t\/\/ Uppercase the type\n+\t\ts.type = s.type.toUpperCase();\n+\n+\t\t\/\/ Determine if request has content\n+\t\ts.hasContent = !rnoContent.test( s.type );\n+\n+\t\t\/\/ Save the URL in case we're toying with the If-Modified-Since\n+\t\t\/\/ and\/or If-None-Match header later on\n+\t\t\/\/ Remove hash to simplify url manipulation\n+\t\tcacheURL = s.url.replace( rhash, \"\" );\n+\n+\t\t\/\/ More options handling for requests with no content\n+\t\tif ( !s.hasContent ) {\n+\n+\t\t\t\/\/ Remember the hash so we can put it back\n+\t\t\tuncached = s.url.slice( cacheURL.length );\n+\n+\t\t\t\/\/ If data is available and should be processed, append data to url\n+\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n+\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n+\n+\t\t\t\t\/\/ trac-9682: remove data so that it's not used in an eventual retry\n+\t\t\t\tdelete s.data;\n+\t\t\t}\n+\n+\t\t\t\/\/ Add or update anti-cache param if needed\n+\t\t\tif ( s.cache === false ) {\n+\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n+\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce.guid++ ) +\n+\t\t\t\t\tuncached;\n+\t\t\t}\n+\n+\t\t\t\/\/ Put hash and anti-cache on the URL that will be requested (gh-1732)\n+\t\t\ts.url = cacheURL + uncached;\n+\n+\t\t\/\/ Change '%20' to '+' if this is encoded form body content (gh-2658)\n+\t\t} else if ( s.data && s.processData &&\n+\t\t\t( s.contentType || \"\" ).indexOf( \"application\/x-www-form-urlencoded\" ) === 0 ) {\n+\t\t\ts.data = s.data.replace( r20, \"+\" );\n+\t\t}\n+\n+\t\t\/\/ Set the If-Modified-Since and\/or If-None-Match header, if in ifModified mode.\n+\t\tif ( s.ifModified ) {\n+\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n+\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n+\t\t\t}\n+\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n+\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Set the correct header, if data is being sent\n+\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n+\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n+\t\t}\n+\n+\t\t\/\/ Set the Accepts header for the server, depending on the dataType\n+\t\tjqXHR.setRequestHeader(\n+\t\t\t\"Accept\",\n+\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n+\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n+\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n+\t\t\t\ts.accepts[ \"*\" ]\n+\t\t);\n+\n+\t\t\/\/ Check for headers option\n+\t\tfor ( i in s.headers ) {\n+\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n+\t\t}\n+\n+\t\t\/\/ Allow custom headers\/mimetypes and early abort\n+\t\tif ( s.beforeSend &&\n+\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n+\n+\t\t\t\/\/ Abort if not done already and return\n+\t\t\treturn jqXHR.abort();\n+\t\t}\n+\n+\t\t\/\/ Aborting is no longer a cancellation\n+\t\tstrAbort = \"abort\";\n+\n+\t\t\/\/ Install callbacks on deferreds\n+\t\tcompleteDeferred.add( s.complete );\n+\t\tjqXHR.done( s.success );\n+\t\tjqXHR.fail( s.error );\n+\n+\t\t\/\/ Get transport\n+\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n+\n+\t\t\/\/ If no transport, we auto-abort\n+\t\tif ( !transport ) {\n+\t\t\tdone( -1, \"No Transport\" );\n+\t\t} else {\n+\t\t\tjqXHR.readyState = 1;\n+\n+\t\t\t\/\/ Send global event\n+\t\t\tif ( fireGlobals ) {\n+\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n+\t\t\t}\n+\n+\t\t\t\/\/ If request was aborted inside ajaxSend, stop there\n+\t\t\tif ( completed ) {\n+\t\t\t\treturn jqXHR;\n+\t\t\t}\n+\n+\t\t\t\/\/ Timeout\n+\t\t\tif ( s.async && s.timeout > 0 ) {\n+\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n+\t\t\t\t\tjqXHR.abort( \"timeout\" );\n+\t\t\t\t}, s.timeout );\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tcompleted = false;\n+\t\t\t\ttransport.send( requestHeaders, done );\n+\t\t\t} catch ( e ) {\n+\n+\t\t\t\t\/\/ Rethrow post-completion exceptions\n+\t\t\t\tif ( completed ) {\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Propagate others as results\n+\t\t\t\tdone( -1, e );\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Callback for when everything is done\n+\t\tfunction done( status, nativeStatusText, responses, headers ) {\n+\t\t\tvar isSuccess, success, error, response, modified,\n+\t\t\t\tstatusText = nativeStatusText;\n+\n+\t\t\t\/\/ Ignore repeat invocations\n+\t\t\tif ( completed ) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tcompleted = true;\n+\n+\t\t\t\/\/ Clear timeout if it exists\n+\t\t\tif ( timeoutTimer ) {\n+\t\t\t\twindow.clearTimeout( timeoutTimer );\n+\t\t\t}\n+\n+\t\t\t\/\/ Dereference transport for early garbage collection\n+\t\t\t\/\/ (no matter how long the jqXHR object will be used)\n+\t\t\ttransport = undefined;\n+\n+\t\t\t\/\/ Cache response headers\n+\t\t\tresponseHeadersString = headers || \"\";\n+\n+\t\t\t\/\/ Set readyState\n+\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n+\n+\t\t\t\/\/ Determine if successful\n+\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n+\n+\t\t\t\/\/ Get response data\n+\t\t\tif ( responses ) {\n+\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n+\t\t\t}\n+\n+\t\t\t\/\/ Use a noop converter for missing script but not if jsonp\n+\t\t\tif ( !isSuccess &&\n+\t\t\t\tjQuery.inArray( \"script\", s.dataTypes ) > -1 &&\n+\t\t\t\tjQuery.inArray( \"json\", s.dataTypes ) < 0 ) {\n+\t\t\t\ts.converters[ \"text script\" ] = function() {};\n+\t\t\t}\n+\n+\t\t\t\/\/ Convert no matter what (that way responseXXX fields are always set)\n+\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n+\n+\t\t\t\/\/ If successful, handle type chaining\n+\t\t\tif ( isSuccess ) {\n+\n+\t\t\t\t\/\/ Set the If-Modified-Since and\/or If-None-Match header, if in ifModified mode.\n+\t\t\t\tif ( s.ifModified ) {\n+\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n+\t\t\t\t\tif ( modified ) {\n+\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n+\t\t\t\t\t}\n+\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n+\t\t\t\t\tif ( modified ) {\n+\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ if no content\n+\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n+\t\t\t\t\tstatusText = \"nocontent\";\n+\n+\t\t\t\t\/\/ if not modified\n+\t\t\t\t} else if ( status === 304 ) {\n+\t\t\t\t\tstatusText = \"notmodified\";\n+\n+\t\t\t\t\/\/ If we have data, let's convert it\n+\t\t\t\t} else {\n+\t\t\t\t\tstatusText = response.state;\n+\t\t\t\t\tsuccess = response.data;\n+\t\t\t\t\terror = response.error;\n+\t\t\t\t\tisSuccess = !error;\n+\t\t\t\t}\n+\t\t\t} else {\n+\n+\t\t\t\t\/\/ Extract error from statusText and normalize for non-aborts\n+\t\t\t\terror = statusText;\n+\t\t\t\tif ( status || !statusText ) {\n+\t\t\t\t\tstatusText = \"error\";\n+\t\t\t\t\tif ( status < 0 ) {\n+\t\t\t\t\t\tstatus = 0;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t\/\/ Set data for the fake xhr object\n+\t\t\tjqXHR.status = status;\n+\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n+\n+\t\t\t\/\/ Success\/Error\n+\t\t\tif ( isSuccess ) {\n+\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n+\t\t\t} else {\n+\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n+\t\t\t}\n+\n+\t\t\t\/\/ Status-dependent callbacks\n+\t\t\tjqXHR.statusCode( statusCode );\n+\t\t\tstatusCode = undefined;\n+\n+\t\t\tif ( fireGlobals ) {\n+\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n+\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n+\t\t\t}\n+\n+\t\t\t\/\/ Complete\n+\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n+\n+\t\t\tif ( fireGlobals ) {\n+\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n+\n+\t\t\t\t\/\/ Handle the global AJAX counter\n+\t\t\t\tif ( !( --jQuery.active ) ) {\n+\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn jqXHR;\n+\t},\n+\n+\tgetJSON: function( url, data, callback ) {\n+\t\treturn jQuery.get( url, data, callback, \"json\" );\n+\t},\n+\n+\tgetScript: function( url, callback ) {\n+\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n+\t}\n+} );\n+\n+jQuery.each( [ \"get\", \"post\" ], function( _i, method ) {\n+\tjQuery[ method ] = function( url, data, callback, type ) {\n+\n+\t\t\/\/ Shift arguments if data argument was omitted\n+\t\tif ( isFunction( data ) ) {\n+\t\t\ttype = type || callback;\n+\t\t\tcallback = data;\n+\t\t\tdata = undefined;\n+\t\t}\n+\n+\t\t\/\/ The url can be an options object (which then must have .url)\n+\t\treturn jQuery.ajax( jQuery.extend( {\n+\t\t\turl: url,\n+\t\t\ttype: method,\n+\t\t\tdataType: type,\n+\t\t\tdata: data,\n+\t\t\tsuccess: callback\n+\t\t}, jQuery.isPlainObject( url ) && url ) );\n+\t};\n+} );\n+\n+jQuery.ajaxPrefilter( function( s ) {\n+\tvar i;\n+\tfor ( i in s.headers ) {\n+\t\tif ( i.toLowerCase() === \"content-type\" ) {\n+\t\t\ts.contentType = s.headers[ i ] || \"\";\n+\t\t}\n+\t}\n+} );\n+\n+\n+jQuery._evalUrl = function( url, options, doc ) {\n+\treturn jQuery.ajax( {\n+\t\turl: url,\n+\n+\t\t\/\/ Make this explicit, since user can override this through ajaxSetup (trac-11264)\n+\t\ttype: \"GET\",\n+\t\tdataType: \"script\",\n+\t\tcache: true,\n+\t\tasync: false,\n+\t\tglobal: false,\n+\n+\t\t\/\/ Only evaluate the response if it is successful (gh-4126)\n+\t\t\/\/ dataFilter is not invoked for failure responses, so using it instead\n+\t\t\/\/ of the default converter is kludgy but it works.\n+\t\tconverters: {\n+\t\t\t\"text script\": function() {}\n+\t\t},\n+\t\tdataFilter: function( response ) {\n+\t\t\tjQuery.globalEval( response, options, doc );\n+\t\t}\n+\t} );\n+};\n+\n+\n+jQuery.fn.extend( {\n+\twrapAll: function( html ) {\n+\t\tvar wrap;\n+\n+\t\tif ( this[ 0 ] ) {\n+\t\t\tif ( isFunction( html ) ) {\n+\t\t\t\thtml = html.call( this[ 0 ] );\n+\t\t\t}\n+\n+\t\t\t\/\/ The elements to wrap the target around\n+\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n+\n+\t\t\tif ( this[ 0 ].parentNode ) {\n+\t\t\t\twrap.insertBefore( this[ 0 ] );\n+\t\t\t}\n+\n+\t\t\twrap.map( function() {\n+\t\t\t\tvar elem = this;\n+\n+\t\t\t\twhile ( elem.firstElementChild ) {\n+\t\t\t\t\telem = elem.firstElementChild;\n+\t\t\t\t}\n+\n+\t\t\t\treturn elem;\n+\t\t\t} ).append( this );\n+\t\t}\n+\n+\t\treturn this;\n+\t},\n+\n+\twrapInner: function( html ) {\n+\t\tif ( isFunction( html ) ) {\n+\t\t\treturn this.each( function( i ) {\n+\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n+\t\t\t} );\n+\t\t}\n+\n+\t\treturn this.each( function() {\n+\t\t\tvar self = jQuery( this ),\n+\t\t\t\tcontents = self.contents();\n+\n+\t\t\tif ( contents.length ) {\n+\t\t\t\tcontents.wrapAll( html );\n+\n+\t\t\t} else {\n+\t\t\t\tself.append( html );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\twrap: function( html ) {\n+\t\tvar htmlIsFunction = isFunction( html );\n+\n+\t\treturn this.each( function( i ) {\n+\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n+\t\t} );\n+\t},\n+\n+\tunwrap: function( selector ) {\n+\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n+\t\t\tjQuery( this ).replaceWith( this.childNodes );\n+\t\t} );\n+\t\treturn this;\n+\t}\n+} );\n+\n+\n+jQuery.expr.pseudos.hidden = function( elem ) {\n+\treturn !jQuery.expr.pseudos.visible( elem );\n+};\n+jQuery.expr.pseudos.visible = function( elem ) {\n+\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n+};\n+\n+\n+\n+\n+jQuery.ajaxSettings.xhr = function() {\n+\ttry {\n+\t\treturn new window.XMLHttpRequest();\n+\t} catch ( e ) {}\n+};\n+\n+var xhrSuccessStatus = {\n+\n+\t\t\/\/ File protocol always yields status code 0, assume 200\n+\t\t0: 200,\n+\n+\t\t\/\/ Support: IE <=9 only\n+\t\t\/\/ trac-1450: sometimes IE returns 1223 when it should be 204\n+\t\t1223: 204\n+\t},\n+\txhrSupported = jQuery.ajaxSettings.xhr();\n+\n+support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n+support.ajax = xhrSupported = !!xhrSupported;\n+\n+jQuery.ajaxTransport( function( options ) {\n+\tvar callback, errorCallback;\n+\n+\t\/\/ Cross domain only allowed if supported through XMLHttpRequest\n+\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n+\t\treturn {\n+\t\t\tsend: function( headers, complete ) {\n+\t\t\t\tvar i,\n+\t\t\t\t\txhr = options.xhr();\n+\n+\t\t\t\txhr.open(\n+\t\t\t\t\toptions.type,\n+\t\t\t\t\toptions.url,\n+\t\t\t\t\toptions.async,\n+\t\t\t\t\toptions.username,\n+\t\t\t\t\toptions.password\n+\t\t\t\t);\n+\n+\t\t\t\t\/\/ Apply custom fields if provided\n+\t\t\t\tif ( options.xhrFields ) {\n+\t\t\t\t\tfor ( i in options.xhrFields ) {\n+\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Override mime type if needed\n+\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n+\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ X-Requested-With header\n+\t\t\t\t\/\/ For cross-domain requests, seeing as conditions for a preflight are\n+\t\t\t\t\/\/ akin to a jigsaw puzzle, we simply never set it to be sure.\n+\t\t\t\t\/\/ (it can always be set on a per-request basis or even using ajaxSetup)\n+\t\t\t\t\/\/ For same-domain requests, won't change header if already provided.\n+\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n+\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Set headers\n+\t\t\t\tfor ( i in headers ) {\n+\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Callback\n+\t\t\t\tcallback = function( type ) {\n+\t\t\t\t\treturn function() {\n+\t\t\t\t\t\tif ( callback ) {\n+\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n+\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n+\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n+\n+\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n+\t\t\t\t\t\t\t\txhr.abort();\n+\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n+\n+\t\t\t\t\t\t\t\t\/\/ Support: IE <=9 only\n+\t\t\t\t\t\t\t\t\/\/ On a manual native abort, IE9 throws\n+\t\t\t\t\t\t\t\t\/\/ errors on any property access that is not readyState\n+\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n+\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tcomplete(\n+\n+\t\t\t\t\t\t\t\t\t\t\/\/ File: protocol always yields status 0; see trac-8605, trac-14207\n+\t\t\t\t\t\t\t\t\t\txhr.status,\n+\t\t\t\t\t\t\t\t\t\txhr.statusText\n+\t\t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tcomplete(\n+\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n+\t\t\t\t\t\t\t\t\txhr.statusText,\n+\n+\t\t\t\t\t\t\t\t\t\/\/ Support: IE <=9 only\n+\t\t\t\t\t\t\t\t\t\/\/ IE9 has no XHR2 but throws on binary (trac-11426)\n+\t\t\t\t\t\t\t\t\t\/\/ For XHR2 non-text, let the caller handle it (gh-2498)\n+\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n+\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n+\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n+\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n+\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n+\t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t};\n+\t\t\t\t};\n+\n+\t\t\t\t\/\/ Listen to events\n+\t\t\t\txhr.onload = callback();\n+\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n+\n+\t\t\t\t\/\/ Support: IE 9 only\n+\t\t\t\t\/\/ Use onreadystatechange to replace onabort\n+\t\t\t\t\/\/ to handle uncaught aborts\n+\t\t\t\tif ( xhr.onabort !== undefined ) {\n+\t\t\t\t\txhr.onabort = errorCallback;\n+\t\t\t\t} else {\n+\t\t\t\t\txhr.onreadystatechange = function() {\n+\n+\t\t\t\t\t\t\/\/ Check readyState before timeout as it changes\n+\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n+\n+\t\t\t\t\t\t\t\/\/ Allow onerror to be called first,\n+\t\t\t\t\t\t\t\/\/ but that will not handle a native abort\n+\t\t\t\t\t\t\t\/\/ Also, save errorCallback to a variable\n+\t\t\t\t\t\t\t\/\/ as xhr.onerror cannot be accessed\n+\t\t\t\t\t\t\twindow.setTimeout( function() {\n+\t\t\t\t\t\t\t\tif ( callback ) {\n+\t\t\t\t\t\t\t\t\terrorCallback();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t};\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Create the abort callback\n+\t\t\t\tcallback = callback( \"abort\" );\n+\n+\t\t\t\ttry {\n+\n+\t\t\t\t\t\/\/ Do send the request (this may raise an exception)\n+\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n+\t\t\t\t} catch ( e ) {\n+\n+\t\t\t\t\t\/\/ trac-14683: Only rethrow if this hasn't been notified as an error yet\n+\t\t\t\t\tif ( callback ) {\n+\t\t\t\t\t\tthrow e;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t},\n+\n+\t\t\tabort: function() {\n+\t\t\t\tif ( callback ) {\n+\t\t\t\t\tcallback();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t}\n+} );\n+\n+\n+\n+\n+\/\/ Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n+jQuery.ajaxPrefilter( function( s ) {\n+\tif ( s.crossDomain ) {\n+\t\ts.contents.script = false;\n+\t}\n+} );\n+\n+\/\/ Install script dataType\n+jQuery.ajaxSetup( {\n+\taccepts: {\n+\t\tscript: \"text\/javascript, application\/javascript, \" +\n+\t\t\t\"application\/ecmascript, application\/x-ecmascript\"\n+\t},\n+\tcontents: {\n+\t\tscript: \/\\b(?:java|ecma)script\\b\/\n+\t},\n+\tconverters: {\n+\t\t\"text script\": function( text ) {\n+\t\t\tjQuery.globalEval( text );\n+\t\t\treturn text;\n+\t\t}\n+\t}\n+} );\n+\n+\/\/ Handle cache's special case and crossDomain\n+jQuery.ajaxPrefilter( \"script\", function( s ) {\n+\tif ( s.cache === undefined ) {\n+\t\ts.cache = false;\n+\t}\n+\tif ( s.crossDomain ) {\n+\t\ts.type = \"GET\";\n+\t}\n+} );\n+\n+\/\/ Bind script tag hack transport\n+jQuery.ajaxTransport( \"script\", function( s ) {\n+\n+\t\/\/ This transport only deals with cross domain or forced-by-attrs requests\n+\tif ( s.crossDomain || s.scriptAttrs ) {\n+\t\tvar script, callback;\n+\t\treturn {\n+\t\t\tsend: function( _, complete ) {\n+\t\t\t\tscript = jQuery( \"<script>\" )\n+\t\t\t\t\t.attr( s.scriptAttrs || {} )\n+\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n+\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n+\t\t\t\t\t\tscript.remove();\n+\t\t\t\t\t\tcallback = null;\n+\t\t\t\t\t\tif ( evt ) {\n+\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} );\n+\n+\t\t\t\t\/\/ Use native DOM manipulation to avoid our domManip AJAX trickery\n+\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n+\t\t\t},\n+\t\t\tabort: function() {\n+\t\t\t\tif ( callback ) {\n+\t\t\t\t\tcallback();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t}\n+} );\n+\n+\n+\n+\n+var oldCallbacks = [],\n+\trjsonp = \/(=)\\?(?=&|$)|\\?\\?\/;\n+\n+\/\/ Default jsonp settings\n+jQuery.ajaxSetup( {\n+\tjsonp: \"callback\",\n+\tjsonpCallback: function() {\n+\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce.guid++ ) );\n+\t\tthis[ callback ] = true;\n+\t\treturn callback;\n+\t}\n+} );\n+\n+\/\/ Detect, normalize options and install callbacks for jsonp requests\n+jQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n+\n+\tvar callbackName, overwritten, responseContainer,\n+\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n+\t\t\t\"url\" :\n+\t\t\ttypeof s.data === \"string\" &&\n+\t\t\t\t( s.contentType || \"\" )\n+\t\t\t\t\t.indexOf( \"application\/x-www-form-urlencoded\" ) === 0 &&\n+\t\t\t\trjsonp.test( s.data ) && \"data\"\n+\t\t);\n+\n+\t\/\/ Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n+\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n+\n+\t\t\/\/ Get callback name, remembering preexisting value associated with it\n+\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n+\t\t\ts.jsonpCallback() :\n+\t\t\ts.jsonpCallback;\n+\n+\t\t\/\/ Insert callback into url or form data\n+\t\tif ( jsonProp ) {\n+\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n+\t\t} else if ( s.jsonp !== false ) {\n+\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n+\t\t}\n+\n+\t\t\/\/ Use data converter to retrieve json after script execution\n+\t\ts.converters[ \"script json\" ] = function() {\n+\t\t\tif ( !responseContainer ) {\n+\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n+\t\t\t}\n+\t\t\treturn responseContainer[ 0 ];\n+\t\t};\n+\n+\t\t\/\/ Force json dataType\n+\t\ts.dataTypes[ 0 ] = \"json\";\n+\n+\t\t\/\/ Install callback\n+\t\toverwritten = window[ callbackName ];\n+\t\twindow[ callbackName ] = function() {\n+\t\t\tresponseContainer = arguments;\n+\t\t};\n+\n+\t\t\/\/ Clean-up function (fires after converters)\n+\t\tjqXHR.always( function() {\n+\n+\t\t\t\/\/ If previous value didn't exist - remove it\n+\t\t\tif ( overwritten === undefined ) {\n+\t\t\t\tjQuery( window ).removeProp( callbackName );\n+\n+\t\t\t\/\/ Otherwise restore preexisting value\n+\t\t\t} else {\n+\t\t\t\twindow[ callbackName ] = overwritten;\n+\t\t\t}\n+\n+\t\t\t\/\/ Save back as free\n+\t\t\tif ( s[ callbackName ] ) {\n+\n+\t\t\t\t\/\/ Make sure that re-using the options doesn't screw things around\n+\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n+\n+\t\t\t\t\/\/ Save the callback name for future use\n+\t\t\t\toldCallbacks.push( callbackName );\n+\t\t\t}\n+\n+\t\t\t\/\/ Call if it was a function and we have a response\n+\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n+\t\t\t\toverwritten( responseContainer[ 0 ] );\n+\t\t\t}\n+\n+\t\t\tresponseContainer = overwritten = undefined;\n+\t\t} );\n+\n+\t\t\/\/ Delegate to script\n+\t\treturn \"script\";\n+\t}\n+} );\n+\n+\n+\n+\n+\/\/ Support: Safari 8 only\n+\/\/ In Safari 8 documents created via document.implementation.createHTMLDocument\n+\/\/ collapse sibling forms: the second one becomes a child of the first one.\n+\/\/ Because of that, this security measure has to be disabled in Safari 8.\n+\/\/ https:\/\/bugs.webkit.org\/show_bug.cgi?id=137337\n+support.createHTMLDocument = ( function() {\n+\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n+\tbody.innerHTML = \"<form><\/form><form><\/form>\";\n+\treturn body.childNodes.length === 2;\n+} )();\n+\n+\n+\/\/ Argument \"data\" should be string of html\n+\/\/ context (optional): If specified, the fragment will be created in this context,\n+\/\/ defaults to document\n+\/\/ keepScripts (optional): If true, will include scripts passed in the html string\n+jQuery.parseHTML = function( data, context, keepScripts ) {\n+\tif ( typeof data !== \"string\" ) {\n+\t\treturn [];\n+\t}\n+\tif ( typeof context === \"boolean\" ) {\n+\t\tkeepScripts = context;\n+\t\tcontext = false;\n+\t}\n+\n+\tvar base, parsed, scripts;\n+\n+\tif ( !context ) {\n+\n+\t\t\/\/ Stop scripts or inline event handlers from being executed immediately\n+\t\t\/\/ by using document.implementation\n+\t\tif ( support.createHTMLDocument ) {\n+\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n+\n+\t\t\t\/\/ Set the base href for the created document\n+\t\t\t\/\/ so any parsed elements with URLs\n+\t\t\t\/\/ are based on the document's URL (gh-2965)\n+\t\t\tbase = context.createElement( \"base\" );\n+\t\t\tbase.href = document.location.href;\n+\t\t\tcontext.head.appendChild( base );\n+\t\t} else {\n+\t\t\tcontext = document;\n+\t\t}\n+\t}\n+\n+\tparsed = rsingleTag.exec( data );\n+\tscripts = !keepScripts && [];\n+\n+\t\/\/ Single tag\n+\tif ( parsed ) {\n+\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n+\t}\n+\n+\tparsed = buildFragment( [ data ], context, scripts );\n+\n+\tif ( scripts && scripts.length ) {\n+\t\tjQuery( scripts ).remove();\n+\t}\n+\n+\treturn jQuery.merge( [], parsed.childNodes );\n+};\n+\n+\n+\/**\n+ * Load a url into a page\n+ *\/\n+jQuery.fn.load = function( url, params, callback ) {\n+\tvar selector, type, response,\n+\t\tself = this,\n+\t\toff = url.indexOf( \" \" );\n+\n+\tif ( off > -1 ) {\n+\t\tselector = stripAndCollapse( url.slice( off ) );\n+\t\turl = url.slice( 0, off );\n+\t}\n+\n+\t\/\/ If it's a function\n+\tif ( isFunction( params ) ) {\n+\n+\t\t\/\/ We assume that it's the callback\n+\t\tcallback = params;\n+\t\tparams = undefined;\n+\n+\t\/\/ Otherwise, build a param string\n+\t} else if ( params && typeof params === \"object\" ) {\n+\t\ttype = \"POST\";\n+\t}\n+\n+\t\/\/ If we have elements to modify, make the request\n+\tif ( self.length > 0 ) {\n+\t\tjQuery.ajax( {\n+\t\t\turl: url,\n+\n+\t\t\t\/\/ If \"type\" variable is undefined, then \"GET\" method will be used.\n+\t\t\t\/\/ Make value of this field explicit since\n+\t\t\t\/\/ user can override it through ajaxSetup method\n+\t\t\ttype: type || \"GET\",\n+\t\t\tdataType: \"html\",\n+\t\t\tdata: params\n+\t\t} ).done( function( responseText ) {\n+\n+\t\t\t\/\/ Save response for use in complete callback\n+\t\t\tresponse = arguments;\n+\n+\t\t\tself.html( selector ?\n+\n+\t\t\t\t\/\/ If a selector was specified, locate the right elements in a dummy div\n+\t\t\t\t\/\/ Exclude scripts to avoid IE 'Permission Denied' errors\n+\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n+\n+\t\t\t\t\/\/ Otherwise use the full result\n+\t\t\t\tresponseText );\n+\n+\t\t\/\/ If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n+\t\t\/\/ but they are ignored because response was set above.\n+\t\t\/\/ If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n+\t\t} ).always( callback && function( jqXHR, status ) {\n+\t\t\tself.each( function() {\n+\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n+\t\t\t} );\n+\t\t} );\n+\t}\n+\n+\treturn this;\n+};\n+\n+\n+\n+\n+jQuery.expr.pseudos.animated = function( elem ) {\n+\treturn jQuery.grep( jQuery.timers, function( fn ) {\n+\t\treturn elem === fn.elem;\n+\t} ).length;\n+};\n+\n+\n+\n+\n+jQuery.offset = {\n+\tsetOffset: function( elem, options, i ) {\n+\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n+\t\t\tposition = jQuery.css( elem, \"position\" ),\n+\t\t\tcurElem = jQuery( elem ),\n+\t\t\tprops = {};\n+\n+\t\t\/\/ Set position first, in-case top\/left are set even on static elem\n+\t\tif ( position === \"static\" ) {\n+\t\t\telem.style.position = \"relative\";\n+\t\t}\n+\n+\t\tcurOffset = curElem.offset();\n+\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n+\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n+\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n+\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n+\n+\t\t\/\/ Need to be able to calculate position if either\n+\t\t\/\/ top or left is auto and position is either absolute or fixed\n+\t\tif ( calculatePosition ) {\n+\t\t\tcurPosition = curElem.position();\n+\t\t\tcurTop = curPosition.top;\n+\t\t\tcurLeft = curPosition.left;\n+\n+\t\t} else {\n+\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n+\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n+\t\t}\n+\n+\t\tif ( isFunction( options ) ) {\n+\n+\t\t\t\/\/ Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n+\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n+\t\t}\n+\n+\t\tif ( options.top != null ) {\n+\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n+\t\t}\n+\t\tif ( options.left != null ) {\n+\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n+\t\t}\n+\n+\t\tif ( \"using\" in options ) {\n+\t\t\toptions.using.call( elem, props );\n+\n+\t\t} else {\n+\t\t\tcurElem.css( props );\n+\t\t}\n+\t}\n+};\n+\n+jQuery.fn.extend( {\n+\n+\t\/\/ offset() relates an element's border box to the document origin\n+\toffset: function( options ) {\n+\n+\t\t\/\/ Preserve chaining for setter\n+\t\tif ( arguments.length ) {\n+\t\t\treturn options === undefined ?\n+\t\t\t\tthis :\n+\t\t\t\tthis.each( function( i ) {\n+\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n+\t\t\t\t} );\n+\t\t}\n+\n+\t\tvar rect, win,\n+\t\t\telem = this[ 0 ];\n+\n+\t\tif ( !elem ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n+\t\t\/\/ Support: IE <=11 only\n+\t\t\/\/ Running getBoundingClientRect on a\n+\t\t\/\/ disconnected node in IE throws an error\n+\t\tif ( !elem.getClientRects().length ) {\n+\t\t\treturn { top: 0, left: 0 };\n+\t\t}\n+\n+\t\t\/\/ Get document-relative position by adding viewport scroll to viewport-relative gBCR\n+\t\trect = elem.getBoundingClientRect();\n+\t\twin = elem.ownerDocument.defaultView;\n+\t\treturn {\n+\t\t\ttop: rect.top + win.pageYOffset,\n+\t\t\tleft: rect.left + win.pageXOffset\n+\t\t};\n+\t},\n+\n+\t\/\/ position() relates an element's margin box to its offset parent's padding box\n+\t\/\/ This corresponds to the behavior of CSS absolute positioning\n+\tposition: function() {\n+\t\tif ( !this[ 0 ] ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tvar offsetParent, offset, doc,\n+\t\t\telem = this[ 0 ],\n+\t\t\tparentOffset = { top: 0, left: 0 };\n+\n+\t\t\/\/ position:fixed elements are offset from the viewport, which itself always has zero offset\n+\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n+\n+\t\t\t\/\/ Assume position:fixed implies availability of getBoundingClientRect\n+\t\t\toffset = elem.getBoundingClientRect();\n+\n+\t\t} else {\n+\t\t\toffset = this.offset();\n+\n+\t\t\t\/\/ Account for the *real* offset parent, which can be the document or its root element\n+\t\t\t\/\/ when a statically positioned element is identified\n+\t\t\tdoc = elem.ownerDocument;\n+\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n+\t\t\twhile ( offsetParent &&\n+\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n+\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n+\n+\t\t\t\toffsetParent = offsetParent.parentNode;\n+\t\t\t}\n+\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n+\n+\t\t\t\t\/\/ Incorporate borders into its offset, since they are outside its content origin\n+\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n+\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n+\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/\/ Subtract parent offsets and element margins\n+\t\treturn {\n+\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n+\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n+\t\t};\n+\t},\n+\n+\t\/\/ This method will return documentElement in the following cases:\n+\t\/\/ 1) For the element inside the iframe without offsetParent, this method will return\n+\t\/\/    documentElement of the parent window\n+\t\/\/ 2) For the hidden or detached element\n+\t\/\/ 3) For body or html element, i.e. in case of the html node - it will return itself\n+\t\/\/\n+\t\/\/ but those exceptions were never presented as a real life use-cases\n+\t\/\/ and might be considered as more preferable results.\n+\t\/\/\n+\t\/\/ This logic, however, is not guaranteed and can change at any point in the future\n+\toffsetParent: function() {\n+\t\treturn this.map( function() {\n+\t\t\tvar offsetParent = this.offsetParent;\n+\n+\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n+\t\t\t\toffsetParent = offsetParent.offsetParent;\n+\t\t\t}\n+\n+\t\t\treturn offsetParent || documentElement;\n+\t\t} );\n+\t}\n+} );\n+\n+\/\/ Create scrollLeft and scrollTop methods\n+jQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n+\tvar top = \"pageYOffset\" === prop;\n+\n+\tjQuery.fn[ method ] = function( val ) {\n+\t\treturn access( this, function( elem, method, val ) {\n+\n+\t\t\t\/\/ Coalesce documents and windows\n+\t\t\tvar win;\n+\t\t\tif ( isWindow( elem ) ) {\n+\t\t\t\twin = elem;\n+\t\t\t} else if ( elem.nodeType === 9 ) {\n+\t\t\t\twin = elem.defaultView;\n+\t\t\t}\n+\n+\t\t\tif ( val === undefined ) {\n+\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n+\t\t\t}\n+\n+\t\t\tif ( win ) {\n+\t\t\t\twin.scrollTo(\n+\t\t\t\t\t!top ? val : win.pageXOffset,\n+\t\t\t\t\ttop ? val : win.pageYOffset\n+\t\t\t\t);\n+\n+\t\t\t} else {\n+\t\t\t\telem[ method ] = val;\n+\t\t\t}\n+\t\t}, method, val, arguments.length );\n+\t};\n+} );\n+\n+\/\/ Support: Safari <=7 - 9.1, Chrome <=37 - 49\n+\/\/ Add the top\/left cssHooks using jQuery.fn.position\n+\/\/ Webkit bug: https:\/\/bugs.webkit.org\/show_bug.cgi?id=29084\n+\/\/ Blink bug: https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=589347\n+\/\/ getComputedStyle returns percent when specified for top\/left\/bottom\/right;\n+\/\/ rather than make the css module depend on the offset module, just check for it here\n+jQuery.each( [ \"top\", \"left\" ], function( _i, prop ) {\n+\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n+\t\tfunction( elem, computed ) {\n+\t\t\tif ( computed ) {\n+\t\t\t\tcomputed = curCSS( elem, prop );\n+\n+\t\t\t\t\/\/ If curCSS returns percentage, fallback to offset\n+\t\t\t\treturn rnumnonpx.test( computed ) ?\n+\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n+\t\t\t\t\tcomputed;\n+\t\t\t}\n+\t\t}\n+\t);\n+} );\n+\n+\n+\/\/ Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n+jQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n+\tjQuery.each( {\n+\t\tpadding: \"inner\" + name,\n+\t\tcontent: type,\n+\t\t\"\": \"outer\" + name\n+\t}, function( defaultExtra, funcName ) {\n+\n+\t\t\/\/ Margin is only for outerHeight, outerWidth\n+\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n+\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n+\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n+\n+\t\t\treturn access( this, function( elem, type, value ) {\n+\t\t\t\tvar doc;\n+\n+\t\t\t\tif ( isWindow( elem ) ) {\n+\n+\t\t\t\t\t\/\/ $( window ).outerWidth\/Height return w\/h including scrollbars (gh-1729)\n+\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n+\t\t\t\t\t\telem[ \"inner\" + name ] :\n+\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n+\t\t\t\t}\n+\n+\t\t\t\t\/\/ Get document width or height\n+\t\t\t\tif ( elem.nodeType === 9 ) {\n+\t\t\t\t\tdoc = elem.documentElement;\n+\n+\t\t\t\t\t\/\/ Either scroll[Width\/Height] or offset[Width\/Height] or client[Width\/Height],\n+\t\t\t\t\t\/\/ whichever is greatest\n+\t\t\t\t\treturn Math.max(\n+\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n+\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n+\t\t\t\t\t\tdoc[ \"client\" + name ]\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\n+\t\t\t\treturn value === undefined ?\n+\n+\t\t\t\t\t\/\/ Get width or height on the element, requesting but not forcing parseFloat\n+\t\t\t\t\tjQuery.css( elem, type, extra ) :\n+\n+\t\t\t\t\t\/\/ Set width or height on the element\n+\t\t\t\t\tjQuery.style( elem, type, value, extra );\n+\t\t\t}, type, chainable ? margin : undefined, chainable );\n+\t\t};\n+\t} );\n+} );\n+\n+\n+jQuery.each( [\n+\t\"ajaxStart\",\n+\t\"ajaxStop\",\n+\t\"ajaxComplete\",\n+\t\"ajaxError\",\n+\t\"ajaxSuccess\",\n+\t\"ajaxSend\"\n+], function( _i, type ) {\n+\tjQuery.fn[ type ] = function( fn ) {\n+\t\treturn this.on( type, fn );\n+\t};\n+} );\n+\n+\n+\n+\n+jQuery.fn.extend( {\n+\n+\tbind: function( types, data, fn ) {\n+\t\treturn this.on( types, null, data, fn );\n+\t},\n+\tunbind: function( types, fn ) {\n+\t\treturn this.off( types, null, fn );\n+\t},\n+\n+\tdelegate: function( selector, types, data, fn ) {\n+\t\treturn this.on( types, selector, data, fn );\n+\t},\n+\tundelegate: function( selector, types, fn ) {\n+\n+\t\t\/\/ ( namespace ) or ( selector, types [, fn] )\n+\t\treturn arguments.length === 1 ?\n+\t\t\tthis.off( selector, \"**\" ) :\n+\t\t\tthis.off( types, selector || \"**\", fn );\n+\t},\n+\n+\thover: function( fnOver, fnOut ) {\n+\t\treturn this\n+\t\t\t.on( \"mouseenter\", fnOver )\n+\t\t\t.on( \"mouseleave\", fnOut || fnOver );\n+\t}\n+} );\n+\n+jQuery.each(\n+\t( \"blur focus focusin focusout resize scroll click dblclick \" +\n+\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n+\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n+\tfunction( _i, name ) {\n+\n+\t\t\/\/ Handle event binding\n+\t\tjQuery.fn[ name ] = function( data, fn ) {\n+\t\t\treturn arguments.length > 0 ?\n+\t\t\t\tthis.on( name, null, data, fn ) :\n+\t\t\t\tthis.trigger( name );\n+\t\t};\n+\t}\n+);\n+\n+\n+\n+\n+\/\/ Support: Android <=4.0 only\n+\/\/ Make sure we trim BOM and NBSP\n+\/\/ Require that the \"whitespace run\" starts from a non-whitespace\n+\/\/ to avoid O(N^2) behavior when the engine would try matching \"\\s+$\" at each space position.\n+var rtrim = \/^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$\/g;\n+\n+\/\/ Bind a function to a context, optionally partially applying any\n+\/\/ arguments.\n+\/\/ jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n+\/\/ However, it is not slated for removal any time soon\n+jQuery.proxy = function( fn, context ) {\n+\tvar tmp, args, proxy;\n+\n+\tif ( typeof context === \"string\" ) {\n+\t\ttmp = fn[ context ];\n+\t\tcontext = fn;\n+\t\tfn = tmp;\n+\t}\n+\n+\t\/\/ Quick check to determine if target is callable, in the spec\n+\t\/\/ this throws a TypeError, but we will just return undefined.\n+\tif ( !isFunction( fn ) ) {\n+\t\treturn undefined;\n+\t}\n+\n+\t\/\/ Simulated bind\n+\targs = slice.call( arguments, 2 );\n+\tproxy = function() {\n+\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n+\t};\n+\n+\t\/\/ Set the guid of unique handler to the same of original handler, so it can be removed\n+\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n+\n+\treturn proxy;\n+};\n+\n+jQuery.holdReady = function( hold ) {\n+\tif ( hold ) {\n+\t\tjQuery.readyWait++;\n+\t} else {\n+\t\tjQuery.ready( true );\n+\t}\n+};\n+jQuery.isArray = Array.isArray;\n+jQuery.parseJSON = JSON.parse;\n+jQuery.nodeName = nodeName;\n+jQuery.isFunction = isFunction;\n+jQuery.isWindow = isWindow;\n+jQuery.camelCase = camelCase;\n+jQuery.type = toType;\n+\n+jQuery.now = Date.now;\n+\n+jQuery.isNumeric = function( obj ) {\n+\n+\t\/\/ As of jQuery 3.0, isNumeric is limited to\n+\t\/\/ strings and numbers (primitives or objects)\n+\t\/\/ that can be coerced to finite numbers (gh-2662)\n+\tvar type = jQuery.type( obj );\n+\treturn ( type === \"number\" || type === \"string\" ) &&\n+\n+\t\t\/\/ parseFloat NaNs numeric-cast false positives (\"\")\n+\t\t\/\/ ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n+\t\t\/\/ subtraction forces infinities to NaN\n+\t\t!isNaN( obj - parseFloat( obj ) );\n+};\n+\n+jQuery.trim = function( text ) {\n+\treturn text == null ?\n+\t\t\"\" :\n+\t\t( text + \"\" ).replace( rtrim, \"$1\" );\n+};\n+\n+\n+\n+\/\/ Register as a named AMD module, since jQuery can be concatenated with other\n+\/\/ files that may use define, but not via a proper concatenation script that\n+\/\/ understands anonymous AMD modules. A named AMD is safest and most robust\n+\/\/ way to register. Lowercase jquery is used because AMD module names are\n+\/\/ derived from file names, and jQuery is normally delivered in a lowercase\n+\/\/ file name. Do this after creating the global so that if an AMD module wants\n+\/\/ to call noConflict to hide this version of jQuery, it will work.\n+\n+\/\/ Note that for maximum portability, libraries that are not jQuery should\n+\/\/ declare themselves as anonymous modules, and avoid setting a global if an\n+\/\/ AMD loader is present. jQuery is a special case. For more information, see\n+\/\/ https:\/\/github.com\/jrburke\/requirejs\/wiki\/Updating-existing-libraries#wiki-anon\n+\n+if ( typeof define === \"function\" && define.amd ) {\n+\tdefine( \"jquery\", [], function() {\n+\t\treturn jQuery;\n+\t} );\n+}\n+\n+\n+\n+\n+var\n+\n+\t\/\/ Map over jQuery in case of overwrite\n+\t_jQuery = window.jQuery,\n+\n+\t\/\/ Map over the $ in case of overwrite\n+\t_$ = window.$;\n+\n+jQuery.noConflict = function( deep ) {\n+\tif ( window.$ === jQuery ) {\n+\t\twindow.$ = _$;\n+\t}\n+\n+\tif ( deep && window.jQuery === jQuery ) {\n+\t\twindow.jQuery = _jQuery;\n+\t}\n+\n+\treturn jQuery;\n+};\n+\n+\/\/ Expose jQuery and $ identifiers, even in AMD\n+\/\/ (trac-7102#comment:10, https:\/\/github.com\/jquery\/jquery\/pull\/557)\n+\/\/ and CommonJS for browser emulators (trac-13566)\n+if ( typeof noGlobal === \"undefined\" ) {\n+\twindow.jQuery = window.$ = jQuery;\n+}\n+\n+\n+\n+\n+return jQuery;\n+} );\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery\/jquery-3.7.1.js","additions":10716,"deletions":0,"binary":false,"changes":10716,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+\/*! jQuery v3.7.1 | (c) OpenJS Foundation and other contributors | jquery.org\/license *\/\n+!function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(ie,e){\"use strict\";var oe=[],r=Object.getPrototypeOf,ae=oe.slice,g=oe.flat?function(e){return oe.flat.call(e)}:function(e){return oe.concat.apply([],e)},s=oe.push,se=oe.indexOf,n={},i=n.toString,ue=n.hasOwnProperty,o=ue.toString,a=o.call(Object),le={},v=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},y=function(e){return null!=e&&e===e.window},C=ie.document,u={type:!0,src:!0,nonce:!0,noModule:!0};function m(e,t,n){var r,i,o=(n=n||C).createElement(\"script\");if(o.text=e,t)for(r in u)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function x(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[i.call(e)]||\"object\":typeof e}var t=\"3.7.1\",l=\/HTML$\/i,ce=function(e,t){return new ce.fn.init(e,t)};function c(e){var t=!!e&&\"length\"in e&&e.length,n=x(e);return!v(e)&&!y(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0<t&&t-1 in e)}function fe(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}ce.fn=ce.prototype={jquery:t,constructor:ce,length:0,toArray:function(){return ae.call(this)},get:function(e){return null==e?ae.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=ce.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return ce.each(this,e)},map:function(n){return this.pushStack(ce.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(ae.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(ce.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(ce.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:s,sort:oe.sort,splice:oe.splice},ce.extend=ce.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for(\"boolean\"==typeof a&&(l=a,a=arguments[s]||{},s++),\"object\"==typeof a||v(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],\"__proto__\"!==t&&a!==r&&(l&&r&&(ce.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||ce.isPlainObject(n)?n:{},i=!1,a[t]=ce.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},ce.extend({expando:\"jQuery\"+(t+Math.random()).replace(\/\\D\/g,\"\"),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||\"[object Object]\"!==i.call(e))&&(!(t=r(e))||\"function\"==typeof(n=ue.call(t,\"constructor\")&&t.constructor)&&o.call(n)===a)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){m(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(c(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},text:function(e){var t,n=\"\",r=0,i=e.nodeType;if(!i)while(t=e[r++])n+=ce.text(t);return 1===i||11===i?e.textContent:9===i?e.documentElement.textContent:3===i||4===i?e.nodeValue:n},makeArray:function(e,t){var n=t||[];return null!=e&&(c(Object(e))?ce.merge(n,\"string\"==typeof e?[e]:e):s.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:se.call(t,e,n)},isXMLDoc:function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!l.test(t||n&&n.nodeName||\"HTML\")},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(c(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:le}),\"function\"==typeof Symbol&&(ce.fn[Symbol.iterator]=oe[Symbol.iterator]),ce.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(e,t){n[\"[object \"+t+\"]\"]=t.toLowerCase()});var pe=oe.pop,de=oe.sort,he=oe.splice,ge=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",ve=new RegExp(\"^\"+ge+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+ge+\"+$\",\"g\");ce.contains=function(e,t){var n=t&&t.parentNode;return e===n||!(!n||1!==n.nodeType||!(e.contains?e.contains(n):e.compareDocumentPosition&&16&e.compareDocumentPosition(n)))};var f=\/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]\/g;function p(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e}ce.escapeSelector=function(e){return(e+\"\").replace(f,p)};var ye=C,me=s;!function(){var e,b,w,o,a,T,r,C,d,i,k=me,S=ce.expando,E=0,n=0,s=W(),c=W(),u=W(),h=W(),l=function(e,t){return e===t&&(a=!0),0},f=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",t=\"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\"+ge+\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",p=\"\\\\[\"+ge+\"*(\"+t+\")(?:\"+ge+\"*([*^$|!~]?=)\"+ge+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+t+\"))|)\"+ge+\"*\\\\]\",g=\":(\"+t+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+p+\")*)|.*)\\\\)|)\",v=new RegExp(ge+\"+\",\"g\"),y=new RegExp(\"^\"+ge+\"*,\"+ge+\"*\"),m=new RegExp(\"^\"+ge+\"*([>+~]|\"+ge+\")\"+ge+\"*\"),x=new RegExp(ge+\"|>\"),j=new RegExp(g),A=new RegExp(\"^\"+t+\"$\"),D={ID:new RegExp(\"^#(\"+t+\")\"),CLASS:new RegExp(\"^\\\\.(\"+t+\")\"),TAG:new RegExp(\"^(\"+t+\"|[*])\"),ATTR:new RegExp(\"^\"+p),PSEUDO:new RegExp(\"^\"+g),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+ge+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+ge+\"*(?:([+-]|)\"+ge+\"*(\\\\d+)|))\"+ge+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+f+\")$\",\"i\"),needsContext:new RegExp(\"^\"+ge+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+ge+\"*((?:-\\\\d)?\\\\d*)\"+ge+\"*\\\\)|)(?=[^-]|$)\",\"i\")},N=\/^(?:input|select|textarea|button)$\/i,q=\/^h\\d$\/i,L=\/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$\/,H=\/[+~]\/,O=new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\"+ge+\"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\",\"g\"),P=function(e,t){var n=\"0x\"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},M=function(){V()},R=J(function(e){return!0===e.disabled&&fe(e,\"fieldset\")},{dir:\"parentNode\",next:\"legend\"});try{k.apply(oe=ae.call(ye.childNodes),ye.childNodes),oe[ye.childNodes.length].nodeType}catch(e){k={apply:function(e,t){me.apply(e,ae.call(t))},call:function(e){me.apply(e,ae.call(arguments,1))}}}function I(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],\"string\"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(V(e),e=e||T,C)){if(11!==p&&(u=L.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return k.call(n,a),n}else if(f&&(a=f.getElementById(i))&&I.contains(e,a)&&a.id===i)return k.call(n,a),n}else{if(u[2])return k.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&e.getElementsByClassName)return k.apply(n,e.getElementsByClassName(i)),n}if(!(h[t+\" \"]||d&&d.test(t))){if(c=t,f=e,1===p&&(x.test(t)||m.test(t))){(f=H.test(t)&&U(e.parentNode)||e)==e&&le.scope||((s=e.getAttribute(\"id\"))?s=ce.escapeSelector(s):e.setAttribute(\"id\",s=S)),o=(l=Y(t)).length;while(o--)l[o]=(s?\"#\"+s:\":scope\")+\" \"+Q(l[o]);c=l.join(\",\")}try{return k.apply(n,f.querySelectorAll(c)),n}catch(e){h(t,!0)}finally{s===S&&e.removeAttribute(\"id\")}}}return re(t.replace(ve,\"$1\"),e,n,r)}function W(){var r=[];return function e(t,n){return r.push(t+\" \")>b.cacheLength&&delete e[r.shift()],e[t+\" \"]=n}}function F(e){return e[S]=!0,e}function $(e){var t=T.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function B(t){return function(e){return fe(e,\"input\")&&e.type===t}}function _(t){return function(e){return(fe(e,\"input\")||fe(e,\"button\"))&&e.type===t}}function z(t){return function(e){return\"form\"in e?e.parentNode&&!1===e.disabled?\"label\"in e?\"label\"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&R(e)===t:e.disabled===t:\"label\"in e&&e.disabled===t}}function X(a){return F(function(o){return o=+o,F(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function U(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}function V(e){var t,n=e?e.ownerDocument||e:ye;return n!=T&&9===n.nodeType&&n.documentElement&&(r=(T=n).documentElement,C=!ce.isXMLDoc(T),i=r.matches||r.webkitMatchesSelector||r.msMatchesSelector,r.msMatchesSelector&&ye!=T&&(t=T.defaultView)&&t.top!==t&&t.addEventListener(\"unload\",M),le.getById=$(function(e){return r.appendChild(e).id=ce.expando,!T.getElementsByName||!T.getElementsByName(ce.expando).length}),le.disconnectedMatch=$(function(e){return i.call(e,\"*\")}),le.scope=$(function(){return T.querySelectorAll(\":scope\")}),le.cssHas=$(function(){try{return T.querySelector(\":has(*,:jqfake)\"),!1}catch(e){return!0}}),le.getById?(b.filter.ID=function(e){var t=e.replace(O,P);return function(e){return e.getAttribute(\"id\")===t}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&C){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(O,P);return function(e){var t=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return t&&t.value===n}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&C){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),b.find.TAG=function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):t.querySelectorAll(e)},b.find.CLASS=function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&C)return t.getElementsByClassName(e)},d=[],$(function(e){var t;r.appendChild(e).innerHTML=\"<a id='\"+S+\"' href='' disabled='disabled'><\/a><select id='\"+S+\"-\\r\\\\' disabled='disabled'><option selected=''><\/option><\/select>\",e.querySelectorAll(\"[selected]\").length||d.push(\"\\\\[\"+ge+\"*(?:value|\"+f+\")\"),e.querySelectorAll(\"[id~=\"+S+\"-]\").length||d.push(\"~=\"),e.querySelectorAll(\"a#\"+S+\"+*\").length||d.push(\".#.+[+~]\"),e.querySelectorAll(\":checked\").length||d.push(\":checked\"),(t=T.createElement(\"input\")).setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),r.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&d.push(\":enabled\",\":disabled\"),(t=T.createElement(\"input\")).setAttribute(\"name\",\"\"),e.appendChild(t),e.querySelectorAll(\"[name='']\").length||d.push(\"\\\\[\"+ge+\"*name\"+ge+\"*=\"+ge+\"*(?:''|\\\"\\\")\")}),le.cssHas||d.push(\":has\"),d=d.length&&new RegExp(d.join(\"|\")),l=function(e,t){if(e===t)return a=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!le.sortDetached&&t.compareDocumentPosition(e)===n?e===T||e.ownerDocument==ye&&I.contains(ye,e)?-1:t===T||t.ownerDocument==ye&&I.contains(ye,t)?1:o?se.call(o,e)-se.call(o,t):0:4&n?-1:1)}),T}for(e in I.matches=function(e,t){return I(e,null,null,t)},I.matchesSelector=function(e,t){if(V(e),C&&!h[t+\" \"]&&(!d||!d.test(t)))try{var n=i.call(e,t);if(n||le.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){h(t,!0)}return 0<I(t,T,null,[e]).length},I.contains=function(e,t){return(e.ownerDocument||e)!=T&&V(e),ce.contains(e,t)},I.attr=function(e,t){(e.ownerDocument||e)!=T&&V(e);var n=b.attrHandle[t.toLowerCase()],r=n&&ue.call(b.attrHandle,t.toLowerCase())?n(e,t,!C):void 0;return void 0!==r?r:e.getAttribute(t)},I.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},ce.uniqueSort=function(e){var t,n=[],r=0,i=0;if(a=!le.sortStable,o=!le.sortStable&&ae.call(e,0),de.call(e,l),a){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)he.call(e,n[r],1)}return o=null,e},ce.fn.uniqueSort=function(){return this.pushStack(ce.uniqueSort(ae.apply(this)))},(b=ce.expr={cacheLength:50,createPseudo:F,match:D,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(O,P),e[3]=(e[3]||e[4]||e[5]||\"\").replace(O,P),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||I.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&I.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return D.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&j.test(n)&&(t=Y(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(O,P).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return fe(e,t)}},CLASS:function(e){var t=s[e+\" \"];return t||(t=new RegExp(\"(^|\"+ge+\")\"+e+\"(\"+ge+\"|$)\"))&&s(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(n,r,i){return function(e){var t=I.attr(e,n);return null==t?\"!=\"===r:!r||(t+=\"\",\"=\"===r?t===i:\"!=\"===r?t!==i:\"^=\"===r?i&&0===t.indexOf(i):\"*=\"===r?i&&-1<t.indexOf(i):\"$=\"===r?i&&t.slice(-i.length)===i:\"~=\"===r?-1<(\" \"+t.replace(v,\" \")+\" \").indexOf(i):\"|=\"===r&&(t===i||t.slice(0,i.length+1)===i+\"-\"))}},CHILD:function(d,e,t,h,g){var v=\"nth\"!==d.slice(0,3),y=\"last\"!==d.slice(-4),m=\"of-type\"===e;return 1===h&&0===g?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u=v!==y?\"nextSibling\":\"previousSibling\",l=e.parentNode,c=m&&e.nodeName.toLowerCase(),f=!n&&!m,p=!1;if(l){if(v){while(u){o=e;while(o=o[u])if(m?fe(o,c):1===o.nodeType)return!1;s=u=\"only\"===d&&!s&&\"nextSibling\"}return!0}if(s=[y?l.firstChild:l.lastChild],y&&f){p=(a=(r=(i=l[S]||(l[S]={}))[d]||[])[0]===E&&r[1])&&r[2],o=a&&l.childNodes[a];while(o=++a&&o&&o[u]||(p=a=0)||s.pop())if(1===o.nodeType&&++p&&o===e){i[d]=[E,a,p];break}}else if(f&&(p=a=(r=(i=e[S]||(e[S]={}))[d]||[])[0]===E&&r[1]),!1===p)while(o=++a&&o&&o[u]||(p=a=0)||s.pop())if((m?fe(o,c):1===o.nodeType)&&++p&&(f&&((i=o[S]||(o[S]={}))[d]=[E,p]),o===e))break;return(p-=g)===h||p%h==0&&0<=p\/h}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||I.error(\"unsupported pseudo: \"+e);return a[S]?a(o):1<a.length?(t=[e,e,\"\",o],b.setFilters.hasOwnProperty(e.toLowerCase())?F(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=se.call(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:F(function(e){var r=[],i=[],s=ne(e.replace(ve,\"$1\"));return s[S]?F(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:F(function(t){return function(e){return 0<I(t,e).length}}),contains:F(function(t){return t=t.replace(O,P),function(e){return-1<(e.textContent||ce.text(e)).indexOf(t)}}),lang:F(function(n){return A.test(n||\"\")||I.error(\"unsupported lang: \"+n),n=n.replace(O,P).toLowerCase(),function(e){var t;do{if(t=C?e.lang:e.getAttribute(\"xml:lang\")||e.getAttribute(\"lang\"))return(t=t.toLowerCase())===n||0===t.indexOf(n+\"-\")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=ie.location&&ie.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===r},focus:function(e){return e===function(){try{return T.activeElement}catch(e){}}()&&T.hasFocus()&&!!(e.type||e.href||~e.tabIndex)},enabled:z(!1),disabled:z(!0),checked:function(e){return fe(e,\"input\")&&!!e.checked||fe(e,\"option\")&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return q.test(e.nodeName)},input:function(e){return N.test(e.nodeName)},button:function(e){return fe(e,\"input\")&&\"button\"===e.type||fe(e,\"button\")},text:function(e){var t;return fe(e,\"input\")&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||\"text\"===t.toLowerCase())},first:X(function(){return[0]}),last:X(function(e,t){return[t-1]}),eq:X(function(e,t,n){return[n<0?n+t:n]}),even:X(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:X(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:X(function(e,t,n){var r;for(r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:X(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=B(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=_(e);function G(){}function Y(e,t){var n,r,i,o,a,s,u,l=c[e+\" \"];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=y.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=m.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(ve,\" \")}),a=a.slice(n.length)),b.filter)!(r=D[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?I.error(e):c(e,s).slice(0)}function Q(e){for(var t=0,n=e.length,r=\"\";t<n;t++)r+=e[t].value;return r}function J(a,e,t){var s=e.dir,u=e.next,l=u||s,c=t&&\"parentNode\"===l,f=n++;return e.first?function(e,t,n){while(e=e[s])if(1===e.nodeType||c)return a(e,t,n);return!1}:function(e,t,n){var r,i,o=[E,f];if(n){while(e=e[s])if((1===e.nodeType||c)&&a(e,t,n))return!0}else while(e=e[s])if(1===e.nodeType||c)if(i=e[S]||(e[S]={}),u&&fe(e,u))e=e[s]||e;else{if((r=i[l])&&r[0]===E&&r[1]===f)return o[2]=r[2];if((i[l]=o)[2]=a(e,t,n))return!0}return!1}}function K(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Z(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function ee(d,h,g,v,y,e){return v&&!v[S]&&(v=ee(v)),y&&!y[S]&&(y=ee(y,e)),F(function(e,t,n,r){var i,o,a,s,u=[],l=[],c=t.length,f=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)I(e,t[r],n);return n}(h||\"*\",n.nodeType?[n]:n,[]),p=!d||!e&&h?f:Z(f,u,d,n,r);if(g?g(p,s=y||(e?d:c||v)?[]:t,n,r):s=p,v){i=Z(s,l),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(s[l[o]]=!(p[l[o]]=a))}if(e){if(y||d){if(y){i=[],o=s.length;while(o--)(a=s[o])&&i.push(p[o]=a);y(null,s=[],i,r)}o=s.length;while(o--)(a=s[o])&&-1<(i=y?se.call(e,a):u[o])&&(e[i]=!(t[i]=a))}}else s=Z(s===t?s.splice(c,s.length):s),y?y(null,t,s,r):k.apply(t,s)})}function te(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[\" \"],s=o?1:0,u=J(function(e){return e===i},a,!0),l=J(function(e){return-1<se.call(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!=w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[J(K(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return ee(1<s&&K(c),1<s&&Q(e.slice(0,s-1).concat({value:\" \"===e[s-2].type?\"*\":\"\"})).replace(ve,\"$1\"),t,s<n&&te(e.slice(s,n)),n<r&&te(e=e.slice(n)),n<r&&Q(e))}c.push(t)}return K(c)}function ne(e,t){var n,v,y,m,x,r,i=[],o=[],a=u[e+\" \"];if(!a){t||(t=Y(e)),n=t.length;while(n--)(a=te(t[n]))[S]?i.push(a):o.push(a);(a=u(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l=\"0\",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG(\"*\",i),h=E+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==T||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==T||(V(o),n=!C);while(s=v[a++])if(s(o,t||T,n)){k.call(r,o);break}i&&(E=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=pe.call(r));f=Z(f)}k.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&ce.uniqueSort(r)}return i&&(E=h,w=p),c},m?F(r):r))).selector=e}return a}function re(e,t,n,r){var i,o,a,s,u,l=\"function\"==typeof e&&e,c=!r&&Y(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&\"ID\"===(a=o[0]).type&&9===t.nodeType&&C&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(O,P),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=D.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(O,P),H.test(o[0].type)&&U(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&Q(o)))return k.apply(n,r),n;break}}}return(l||ne(e,c))(r,t,!C,n,!t||H.test(e)&&U(t.parentNode)||t),n}G.prototype=b.filters=b.pseudos,b.setFilters=new G,le.sortStable=S.split(\"\").sort(l).join(\"\")===S,V(),le.sortDetached=$(function(e){return 1&e.compareDocumentPosition(T.createElement(\"fieldset\"))}),ce.find=I,ce.expr[\":\"]=ce.expr.pseudos,ce.unique=ce.uniqueSort,I.compile=ne,I.select=re,I.setDocument=V,I.tokenize=Y,I.escape=ce.escapeSelector,I.getText=ce.text,I.isXML=ce.isXMLDoc,I.selectors=ce.expr,I.support=ce.support,I.uniqueSort=ce.uniqueSort}();var d=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&ce(e).is(n))break;r.push(e)}return r},h=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},b=ce.expr.match.needsContext,w=\/^<([a-z][^\\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\\/?>(?:<\\\/\\1>|)$\/i;function T(e,n,r){return v(n)?ce.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?ce.grep(e,function(e){return e===n!==r}):\"string\"!=typeof n?ce.grep(e,function(e){return-1<se.call(n,e)!==r}):ce.filter(n,e,r)}ce.filter=function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?ce.find.matchesSelector(r,e)?[r]:[]:ce.find.matches(e,ce.grep(t,function(e){return 1===e.nodeType}))},ce.fn.extend({find:function(e){var t,n,r=this.length,i=this;if(\"string\"!=typeof e)return this.pushStack(ce(e).filter(function(){for(t=0;t<r;t++)if(ce.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)ce.find(e,i[t],n);return 1<r?ce.uniqueSort(n):n},filter:function(e){return this.pushStack(T(this,e||[],!1))},not:function(e){return this.pushStack(T(this,e||[],!0))},is:function(e){return!!T(this,\"string\"==typeof e&&b.test(e)?ce(e):e||[],!1).length}});var k,S=\/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$\/;(ce.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||k,\"string\"==typeof e){if(!(r=\"<\"===e[0]&&\">\"===e[e.length-1]&&3<=e.length?[null,e,null]:S.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof ce?t[0]:t,ce.merge(this,ce.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:C,!0)),w.test(r[1])&&ce.isPlainObject(t))for(r in t)v(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=C.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):v(e)?void 0!==n.ready?n.ready(e):e(ce):ce.makeArray(e,this)}).prototype=ce.fn,k=ce(C);var E=\/^(?:parents|prev(?:Until|All))\/,j={children:!0,contents:!0,next:!0,prev:!0};function A(e,t){while((e=e[t])&&1!==e.nodeType);return e}ce.fn.extend({has:function(e){var t=ce(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(ce.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a=\"string\"!=typeof e&&ce(e);if(!b.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&ce.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?ce.uniqueSort(o):o)},index:function(e){return e?\"string\"==typeof e?se.call(ce(e),this[0]):se.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(ce.uniqueSort(ce.merge(this.get(),ce(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),ce.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return d(e,\"parentNode\")},parentsUntil:function(e,t,n){return d(e,\"parentNode\",n)},next:function(e){return A(e,\"nextSibling\")},prev:function(e){return A(e,\"previousSibling\")},nextAll:function(e){return d(e,\"nextSibling\")},prevAll:function(e){return d(e,\"previousSibling\")},nextUntil:function(e,t,n){return d(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return d(e,\"previousSibling\",n)},siblings:function(e){return h((e.parentNode||{}).firstChild,e)},children:function(e){return h(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(fe(e,\"template\")&&(e=e.content||e),ce.merge([],e.childNodes))}},function(r,i){ce.fn[r]=function(e,t){var n=ce.map(this,i,e);return\"Until\"!==r.slice(-5)&&(t=e),t&&\"string\"==typeof t&&(n=ce.filter(t,n)),1<this.length&&(j[r]||ce.uniqueSort(n),E.test(r)&&n.reverse()),this.pushStack(n)}});var D=\/[^\\x20\\t\\r\\n\\f]+\/g;function N(e){return e}function q(e){throw e}function L(e,t,n,r){var i;try{e&&v(i=e.promise)?i.call(e).done(t).fail(n):e&&v(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}ce.Callbacks=function(r){var e,n;r=\"string\"==typeof r?(e=r,n={},ce.each(e.match(D)||[],function(e,t){n[t]=!0}),n):ce.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:\"\")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){ce.each(e,function(e,t){v(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&\"string\"!==x(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return ce.each(arguments,function(e,t){var n;while(-1<(n=ce.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<ce.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t=\"\",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=\"\"),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},ce.extend({Deferred:function(e){var o=[[\"notify\",\"progress\",ce.Callbacks(\"memory\"),ce.Callbacks(\"memory\"),2],[\"resolve\",\"done\",ce.Callbacks(\"once memory\"),ce.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",ce.Callbacks(\"once memory\"),ce.Callbacks(\"once memory\"),1,\"rejected\"]],i=\"pending\",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},\"catch\":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return ce.Deferred(function(r){ce.each(o,function(e,t){var n=v(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&v(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+\"With\"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError(\"Thenable self-resolution\");t=e&&(\"object\"==typeof e||\"function\"==typeof e)&&e.then,v(t)?s?t.call(e,l(u,o,N,s),l(u,o,q,s)):(u++,t.call(e,l(u,o,N,s),l(u,o,q,s),l(u,o,N,o.notifyWith))):(a!==N&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){ce.Deferred.exceptionHook&&ce.Deferred.exceptionHook(e,t.error),u<=i+1&&(a!==q&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(ce.Deferred.getErrorHook?t.error=ce.Deferred.getErrorHook():ce.Deferred.getStackHook&&(t.error=ce.Deferred.getStackHook()),ie.setTimeout(t))}}return ce.Deferred(function(e){o[0][3].add(l(0,e,v(r)?r:N,e.notifyWith)),o[1][3].add(l(0,e,v(t)?t:N)),o[2][3].add(l(0,e,v(n)?n:q))}).promise()},promise:function(e){return null!=e?ce.extend(e,a):a}},s={};return ce.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+\"With\"](this===s?void 0:this,arguments),this},s[t[0]+\"With\"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=ae.call(arguments),o=ce.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?ae.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(L(e,o.done(a(t)).resolve,o.reject,!n),\"pending\"===o.state()||v(i[t]&&i[t].then)))return o.then();while(t--)L(i[t],a(t),o.reject);return o.promise()}});var H=\/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$\/;ce.Deferred.exceptionHook=function(e,t){ie.console&&ie.console.warn&&e&&H.test(e.name)&&ie.console.warn(\"jQuery.Deferred exception: \"+e.message,e.stack,t)},ce.readyException=function(e){ie.setTimeout(function(){throw e})};var O=ce.Deferred();function P(){C.removeEventListener(\"DOMContentLoaded\",P),ie.removeEventListener(\"load\",P),ce.ready()}ce.fn.ready=function(e){return O.then(e)[\"catch\"](function(e){ce.readyException(e)}),this},ce.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--ce.readyWait:ce.isReady)||(ce.isReady=!0)!==e&&0<--ce.readyWait||O.resolveWith(C,[ce])}}),ce.ready.then=O.then,\"complete\"===C.readyState||\"loading\"!==C.readyState&&!C.documentElement.doScroll?ie.setTimeout(ce.ready):(C.addEventListener(\"DOMContentLoaded\",P),ie.addEventListener(\"load\",P));var M=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if(\"object\"===x(n))for(s in i=!0,n)M(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,v(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(ce(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},R=\/^-ms-\/,I=\/-([a-z])\/g;function W(e,t){return t.toUpperCase()}function F(e){return e.replace(R,\"ms-\").replace(I,W)}var $=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function B(){this.expando=ce.expando+B.uid++}B.uid=1,B.prototype={cache:function(e){var t=e[this.expando];return t||(t={},$(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if(\"string\"==typeof t)i[F(t)]=n;else for(r in t)i[F(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][F(t)]},access:function(e,t,n){return void 0===t||t&&\"string\"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(F):(t=F(t))in r?[t]:t.match(D)||[]).length;while(n--)delete r[t[n]]}(void 0===t||ce.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!ce.isEmptyObject(t)}};var _=new B,z=new B,X=\/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$\/,U=\/[A-Z]\/g;function V(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r=\"data-\"+t.replace(U,\"-$&\").toLowerCase(),\"string\"==typeof(n=e.getAttribute(r))){try{n=\"true\"===(i=n)||\"false\"!==i&&(\"null\"===i?null:i===+i+\"\"?+i:X.test(i)?JSON.parse(i):i)}catch(e){}z.set(e,t,n)}else n=void 0;return n}ce.extend({hasData:function(e){return z.hasData(e)||_.hasData(e)},data:function(e,t,n){return z.access(e,t,n)},removeData:function(e,t){z.remove(e,t)},_data:function(e,t,n){return _.access(e,t,n)},_removeData:function(e,t){_.remove(e,t)}}),ce.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=z.get(o),1===o.nodeType&&!_.get(o,\"hasDataAttrs\"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf(\"data-\")&&(r=F(r.slice(5)),V(o,r,i[r]));_.set(o,\"hasDataAttrs\",!0)}return i}return\"object\"==typeof n?this.each(function(){z.set(this,n)}):M(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=z.get(o,n))?t:void 0!==(t=V(o,n))?t:void 0;this.each(function(){z.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){z.remove(this,e)})}}),ce.extend({queue:function(e,t,n){var r;if(e)return t=(t||\"fx\")+\"queue\",r=_.get(e,t),n&&(!r||Array.isArray(n)?r=_.access(e,t,ce.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||\"fx\";var n=ce.queue(e,t),r=n.length,i=n.shift(),o=ce._queueHooks(e,t);\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,function(){ce.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return _.get(e,n)||_.access(e,n,{empty:ce.Callbacks(\"once memory\").add(function(){_.remove(e,[t+\"queue\",n])})})}}),ce.fn.extend({queue:function(t,n){var e=2;return\"string\"!=typeof t&&(n=t,t=\"fx\",e--),arguments.length<e?ce.queue(this[0],t):void 0===n?this:this.each(function(){var e=ce.queue(this,t,n);ce._queueHooks(this,t),\"fx\"===t&&\"inprogress\"!==e[0]&&ce.dequeue(this,t)})},dequeue:function(e){return this.each(function(){ce.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,t){var n,r=1,i=ce.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};\"string\"!=typeof e&&(t=e,e=void 0),e=e||\"fx\";while(a--)(n=_.get(o[a],e+\"queueHooks\"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var G=\/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)\/.source,Y=new RegExp(\"^(?:([+-])=|)(\"+G+\")([a-z%]*)$\",\"i\"),Q=[\"Top\",\"Right\",\"Bottom\",\"Left\"],J=C.documentElement,K=function(e){return ce.contains(e.ownerDocument,e)},Z={composed:!0};J.getRootNode&&(K=function(e){return ce.contains(e.ownerDocument,e)||e.getRootNode(Z)===e.ownerDocument});var ee=function(e,t){return\"none\"===(e=t||e).style.display||\"\"===e.style.display&&K(e)&&\"none\"===ce.css(e,\"display\")};function te(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return ce.css(e,t,\"\")},u=s(),l=n&&n[3]||(ce.cssNumber[t]?\"\":\"px\"),c=e.nodeType&&(ce.cssNumber[t]||\"px\"!==l&&+u)&&Y.exec(ce.css(e,t));if(c&&c[3]!==l){u\/=2,l=l||c[3],c=+u||1;while(a--)ce.style(e,t,c+l),(1-o)*(1-(o=s()\/u||.5))<=0&&(a=0),c\/=o;c*=2,ce.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ne={};function re(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?(\"none\"===n&&(l[c]=_.get(r,\"display\")||null,l[c]||(r.style.display=\"\")),\"\"===r.style.display&&ee(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ne[s])||(o=a.body.appendChild(a.createElement(s)),u=ce.css(o,\"display\"),o.parentNode.removeChild(o),\"none\"===u&&(u=\"block\"),ne[s]=u)))):\"none\"!==n&&(l[c]=\"none\",_.set(r,\"display\",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}ce.fn.extend({show:function(){return re(this,!0)},hide:function(){return re(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){ee(this)?ce(this).show():ce(this).hide()})}});var xe,be,we=\/^(?:checkbox|radio)$\/i,Te=\/<([a-z][^\\\/\\0>\\x20\\t\\r\\n\\f]*)\/i,Ce=\/^$|^module$|\\\/(?:java|ecma)script\/i;xe=C.createDocumentFragment().appendChild(C.createElement(\"div\")),(be=C.createElement(\"input\")).setAttribute(\"type\",\"radio\"),be.setAttribute(\"checked\",\"checked\"),be.setAttribute(\"name\",\"t\"),xe.appendChild(be),le.checkClone=xe.cloneNode(!0).cloneNode(!0).lastChild.checked,xe.innerHTML=\"<textarea>x<\/textarea>\",le.noCloneChecked=!!xe.cloneNode(!0).lastChild.defaultValue,xe.innerHTML=\"<option><\/option>\",le.option=!!xe.lastChild;var ke={thead:[1,\"<table>\",\"<\/table>\"],col:[2,\"<table><colgroup>\",\"<\/colgroup><\/table>\"],tr:[2,\"<table><tbody>\",\"<\/tbody><\/table>\"],td:[3,\"<table><tbody><tr>\",\"<\/tr><\/tbody><\/table>\"],_default:[0,\"\",\"\"]};function Se(e,t){var n;return n=\"undefined\"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||\"*\"):\"undefined\"!=typeof e.querySelectorAll?e.querySelectorAll(t||\"*\"):[],void 0===t||t&&fe(e,t)?ce.merge([e],n):n}function Ee(e,t){for(var n=0,r=e.length;n<r;n++)_.set(e[n],\"globalEval\",!t||_.get(t[n],\"globalEval\"))}ke.tbody=ke.tfoot=ke.colgroup=ke.caption=ke.thead,ke.th=ke.td,le.option||(ke.optgroup=ke.option=[1,\"<select multiple='multiple'>\",\"<\/select>\"]);var je=\/<|&#?\\w+;\/;function Ae(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if(\"object\"===x(o))ce.merge(p,o.nodeType?[o]:o);else if(je.test(o)){a=a||f.appendChild(t.createElement(\"div\")),s=(Te.exec(o)||[\"\",\"\"])[1].toLowerCase(),u=ke[s]||ke._default,a.innerHTML=u[1]+ce.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;ce.merge(p,a.childNodes),(a=f.firstChild).textContent=\"\"}else p.push(t.createTextNode(o));f.textContent=\"\",d=0;while(o=p[d++])if(r&&-1<ce.inArray(o,r))i&&i.push(o);else if(l=K(o),a=Se(f.appendChild(o),\"script\"),l&&Ee(a),n){c=0;while(o=a[c++])Ce.test(o.type||\"\")&&n.push(o)}return f}var De=\/^([^.]*)(?:\\.(.+)|)\/;function Ne(){return!0}function qe(){return!1}function Le(e,t,n,r,i,o){var a,s;if(\"object\"==typeof t){for(s in\"string\"!=typeof n&&(r=r||n,n=void 0),t)Le(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&(\"string\"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=qe;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return ce().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=ce.guid++)),e.each(function(){ce.event.add(this,t,i,r,n)})}function He(e,r,t){t?(_.set(e,r,!1),ce.event.add(e,r,{namespace:!1,handler:function(e){var t,n=_.get(this,r);if(1&e.isTrigger&&this[r]){if(n)(ce.event.special[r]||{}).delegateType&&e.stopPropagation();else if(n=ae.call(arguments),_.set(this,r,n),this[r](),t=_.get(this,r),_.set(this,r,!1),n!==t)return e.stopImmediatePropagation(),e.preventDefault(),t}else n&&(_.set(this,r,ce.event.trigger(n[0],n.slice(1),this)),e.stopPropagation(),e.isImmediatePropagationStopped=Ne)}})):void 0===_.get(e,r)&&ce.event.add(e,r,Ne)}ce.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=_.get(t);if($(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&ce.find.matchesSelector(J,i),n.guid||(n.guid=ce.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return\"undefined\"!=typeof ce&&ce.event.triggered!==e.type?ce.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||\"\").match(D)||[\"\"]).length;while(l--)d=g=(s=De.exec(e[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d&&(f=ce.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=ce.event.special[d]||{},c=ce.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&ce.expr.match.needsContext.test(i),namespace:h.join(\".\")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),ce.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=_.hasData(e)&&_.get(e);if(v&&(u=v.events)){l=(t=(t||\"\").match(D)||[\"\"]).length;while(l--)if(d=g=(s=De.exec(t[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d){f=ce.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&(\"**\"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||ce.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)ce.event.remove(e,d+t[l],n,r,!0);ce.isEmptyObject(u)&&_.remove(e,\"handle events\")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=ce.event.fix(e),l=(_.get(this,\"events\")||Object.create(null))[u.type]||[],c=ce.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=ce.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((ce.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!(\"click\"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&(\"click\"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+\" \"]&&(a[i]=r.needsContext?-1<ce(i,this).index(l):ce.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(ce.Event.prototype,t,{enumerable:!0,configurable:!0,get:v(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[ce.expando]?e:new ce.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return we.test(t.type)&&t.click&&fe(t,\"input\")&&He(t,\"click\",!0),!1},trigger:function(e){var t=this||e;return we.test(t.type)&&t.click&&fe(t,\"input\")&&He(t,\"click\"),!0},_default:function(e){var t=e.target;return we.test(t.type)&&t.click&&fe(t,\"input\")&&_.get(t,\"click\")||fe(t,\"a\")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},ce.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},ce.Event=function(e,t){if(!(this instanceof ce.Event))return new ce.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ne:qe,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&ce.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[ce.expando]=!0},ce.Event.prototype={constructor:ce.Event,isDefaultPrevented:qe,isPropagationStopped:qe,isImmediatePropagationStopped:qe,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ne,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ne,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ne,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},ce.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\"char\":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},ce.event.addProp),ce.each({focus:\"focusin\",blur:\"focusout\"},function(r,i){function o(e){if(C.documentMode){var t=_.get(this,\"handle\"),n=ce.event.fix(e);n.type=\"focusin\"===e.type?\"focus\":\"blur\",n.isSimulated=!0,t(e),n.target===n.currentTarget&&t(n)}else ce.event.simulate(i,e.target,ce.event.fix(e))}ce.event.special[r]={setup:function(){var e;if(He(this,r,!0),!C.documentMode)return!1;(e=_.get(this,i))||this.addEventListener(i,o),_.set(this,i,(e||0)+1)},trigger:function(){return He(this,r),!0},teardown:function(){var e;if(!C.documentMode)return!1;(e=_.get(this,i)-1)?_.set(this,i,e):(this.removeEventListener(i,o),_.remove(this,i))},_default:function(e){return _.get(e.target,r)},delegateType:i},ce.event.special[i]={setup:function(){var e=this.ownerDocument||this.document||this,t=C.documentMode?this:e,n=_.get(t,i);n||(C.documentMode?this.addEventListener(i,o):e.addEventListener(r,o,!0)),_.set(t,i,(n||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=C.documentMode?this:e,n=_.get(t,i)-1;n?_.set(t,i,n):(C.documentMode?this.removeEventListener(i,o):e.removeEventListener(r,o,!0),_.remove(t,i))}}}),ce.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(e,i){ce.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||ce.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),ce.fn.extend({on:function(e,t,n,r){return Le(this,e,t,n,r)},one:function(e,t,n,r){return Le(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,ce(e.delegateTarget).off(r.namespace?r.origType+\".\"+r.namespace:r.origType,r.selector,r.handler),this;if(\"object\"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&\"function\"!=typeof t||(n=t,t=void 0),!1===n&&(n=qe),this.each(function(){ce.event.remove(this,e,n,t)})}});var Oe=\/<script|<style|<link\/i,Pe=\/checked\\s*(?:[^=]|=\\s*.checked.)\/i,Me=\/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$\/g;function Re(e,t){return fe(e,\"table\")&&fe(11!==t.nodeType?t:t.firstChild,\"tr\")&&ce(e).children(\"tbody\")[0]||e}function Ie(e){return e.type=(null!==e.getAttribute(\"type\"))+\"\/\"+e.type,e}function We(e){return\"true\/\"===(e.type||\"\").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute(\"type\"),e}function Fe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(_.hasData(e)&&(s=_.get(e).events))for(i in _.remove(t,\"handle events\"),s)for(n=0,r=s[i].length;n<r;n++)ce.event.add(t,i,s[i][n]);z.hasData(e)&&(o=z.access(e),a=ce.extend({},o),z.set(t,a))}}function $e(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=v(d);if(h||1<f&&\"string\"==typeof d&&!le.checkClone&&Pe.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),$e(t,r,i,o)});if(f&&(t=(e=Ae(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=ce.map(Se(e,\"script\"),Ie)).length;c<f;c++)u=e,c!==p&&(u=ce.clone(u,!0,!0),s&&ce.merge(a,Se(u,\"script\"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,ce.map(a,We),c=0;c<s;c++)u=a[c],Ce.test(u.type||\"\")&&!_.access(u,\"globalEval\")&&ce.contains(l,u)&&(u.src&&\"module\"!==(u.type||\"\").toLowerCase()?ce._evalUrl&&!u.noModule&&ce._evalUrl(u.src,{nonce:u.nonce||u.getAttribute(\"nonce\")},l):m(u.textContent.replace(Me,\"\"),u,l))}return n}function Be(e,t,n){for(var r,i=t?ce.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||ce.cleanData(Se(r)),r.parentNode&&(n&&K(r)&&Ee(Se(r,\"script\")),r.parentNode.removeChild(r));return e}ce.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=K(e);if(!(le.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||ce.isXMLDoc(e)))for(a=Se(c),r=0,i=(o=Se(e)).length;r<i;r++)s=o[r],u=a[r],void 0,\"input\"===(l=u.nodeName.toLowerCase())&&we.test(s.type)?u.checked=s.checked:\"input\"!==l&&\"textarea\"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||Se(e),a=a||Se(c),r=0,i=o.length;r<i;r++)Fe(o[r],a[r]);else Fe(e,c);return 0<(a=Se(c,\"script\")).length&&Ee(a,!f&&Se(e,\"script\")),c},cleanData:function(e){for(var t,n,r,i=ce.event.special,o=0;void 0!==(n=e[o]);o++)if($(n)){if(t=n[_.expando]){if(t.events)for(r in t.events)i[r]?ce.event.remove(n,r):ce.removeEvent(n,r,t.handle);n[_.expando]=void 0}n[z.expando]&&(n[z.expando]=void 0)}}}),ce.fn.extend({detach:function(e){return Be(this,e,!0)},remove:function(e){return Be(this,e)},text:function(e){return M(this,function(e){return void 0===e?ce.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return $e(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Re(this,e).appendChild(e)})},prepend:function(){return $e(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Re(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return $e(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return $e(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(ce.cleanData(Se(e,!1)),e.textContent=\"\");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return ce.clone(this,e,t)})},html:function(e){return M(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if(\"string\"==typeof e&&!Oe.test(e)&&!ke[(Te.exec(e)||[\"\",\"\"])[1].toLowerCase()]){e=ce.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(ce.cleanData(Se(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return $e(this,arguments,function(e){var t=this.parentNode;ce.inArray(this,n)<0&&(ce.cleanData(Se(this)),t&&t.replaceChild(e,this))},n)}}),ce.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,a){ce.fn[e]=function(e){for(var t,n=[],r=ce(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),ce(r[o])[a](t),s.apply(n,t.get());return this.pushStack(n)}});var _e=new RegExp(\"^(\"+G+\")(?!px)[a-z%]+$\",\"i\"),ze=\/^--\/,Xe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=ie),t.getComputedStyle(e)},Ue=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Ve=new RegExp(Q.join(\"|\"),\"i\");function Ge(e,t,n){var r,i,o,a,s=ze.test(t),u=e.style;return(n=n||Xe(e))&&(a=n.getPropertyValue(t)||n[t],s&&a&&(a=a.replace(ve,\"$1\")||void 0),\"\"!==a||K(e)||(a=ce.style(e,t)),!le.pixelBoxStyles()&&_e.test(a)&&Ve.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=n.width,u.width=r,u.minWidth=i,u.maxWidth=o)),void 0!==a?a+\"\":a}function Ye(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText=\"position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0\",l.style.cssText=\"position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%\",J.appendChild(u).appendChild(l);var e=ie.getComputedStyle(l);n=\"1%\"!==e.top,s=12===t(e.marginLeft),l.style.right=\"60%\",o=36===t(e.right),r=36===t(e.width),l.style.position=\"absolute\",i=12===t(l.offsetWidth\/3),J.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=C.createElement(\"div\"),l=C.createElement(\"div\");l.style&&(l.style.backgroundClip=\"content-box\",l.cloneNode(!0).style.backgroundClip=\"\",le.clearCloneStyle=\"content-box\"===l.style.backgroundClip,ce.extend(le,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=C.createElement(\"table\"),t=C.createElement(\"tr\"),n=C.createElement(\"div\"),e.style.cssText=\"position:absolute;left:-11111px;border-collapse:separate\",t.style.cssText=\"box-sizing:content-box;border:1px solid\",t.style.height=\"1px\",n.style.height=\"9px\",n.style.display=\"block\",J.appendChild(e).appendChild(t).appendChild(n),r=ie.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,J.removeChild(e)),a}}))}();var Qe=[\"Webkit\",\"Moz\",\"ms\"],Je=C.createElement(\"div\").style,Ke={};function Ze(e){var t=ce.cssProps[e]||Ke[e];return t||(e in Je?e:Ke[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Qe.length;while(n--)if((e=Qe[n]+t)in Je)return e}(e)||e)}var et=\/^(none|table(?!-c[ea]).+)\/,tt={position:\"absolute\",visibility:\"hidden\",display:\"block\"},nt={letterSpacing:\"0\",fontWeight:\"400\"};function rt(e,t,n){var r=Y.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||\"px\"):t}function it(e,t,n,r,i,o){var a=\"width\"===t?1:0,s=0,u=0,l=0;if(n===(r?\"border\":\"content\"))return 0;for(;a<4;a+=2)\"margin\"===n&&(l+=ce.css(e,n+Q[a],!0,i)),r?(\"content\"===n&&(u-=ce.css(e,\"padding\"+Q[a],!0,i)),\"margin\"!==n&&(u-=ce.css(e,\"border\"+Q[a]+\"Width\",!0,i))):(u+=ce.css(e,\"padding\"+Q[a],!0,i),\"padding\"!==n?u+=ce.css(e,\"border\"+Q[a]+\"Width\",!0,i):s+=ce.css(e,\"border\"+Q[a]+\"Width\",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e[\"offset\"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u+l}function ot(e,t,n){var r=Xe(e),i=(!le.boxSizingReliable()||n)&&\"border-box\"===ce.css(e,\"boxSizing\",!1,r),o=i,a=Ge(e,t,r),s=\"offset\"+t[0].toUpperCase()+t.slice(1);if(_e.test(a)){if(!n)return a;a=\"auto\"}return(!le.boxSizingReliable()&&i||!le.reliableTrDimensions()&&fe(e,\"tr\")||\"auto\"===a||!parseFloat(a)&&\"inline\"===ce.css(e,\"display\",!1,r))&&e.getClientRects().length&&(i=\"border-box\"===ce.css(e,\"boxSizing\",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+it(e,t,n||(i?\"border\":\"content\"),o,r,a)+\"px\"}function at(e,t,n,r,i){return new at.prototype.init(e,t,n,r,i)}ce.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Ge(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{animationIterationCount:!0,aspectRatio:!0,borderImageSlice:!0,columnCount:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,scale:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeMiterlimit:!0,strokeOpacity:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=F(t),u=ze.test(t),l=e.style;if(u||(t=Ze(s)),a=ce.cssHooks[t]||ce.cssHooks[s],void 0===n)return a&&\"get\"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];\"string\"===(o=typeof n)&&(i=Y.exec(n))&&i[1]&&(n=te(e,t,i),o=\"number\"),null!=n&&n==n&&(\"number\"!==o||u||(n+=i&&i[3]||(ce.cssNumber[s]?\"\":\"px\")),le.clearCloneStyle||\"\"!==n||0!==t.indexOf(\"background\")||(l[t]=\"inherit\"),a&&\"set\"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=F(t);return ze.test(t)||(t=Ze(s)),(a=ce.cssHooks[t]||ce.cssHooks[s])&&\"get\"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Ge(e,t,r)),\"normal\"===i&&t in nt&&(i=nt[t]),\"\"===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),ce.each([\"height\",\"width\"],function(e,u){ce.cssHooks[u]={get:function(e,t,n){if(t)return!et.test(ce.css(e,\"display\"))||e.getClientRects().length&&e.getBoundingClientRect().width?ot(e,u,n):Ue(e,tt,function(){return ot(e,u,n)})},set:function(e,t,n){var r,i=Xe(e),o=!le.scrollboxSize()&&\"absolute\"===i.position,a=(o||n)&&\"border-box\"===ce.css(e,\"boxSizing\",!1,i),s=n?it(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e[\"offset\"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-it(e,u,\"border\",!1,i)-.5)),s&&(r=Y.exec(t))&&\"px\"!==(r[3]||\"px\")&&(e.style[u]=t,t=ce.css(e,u)),rt(0,t,s)}}}),ce.cssHooks.marginLeft=Ye(le.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Ge(e,\"marginLeft\"))||e.getBoundingClientRect().left-Ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+\"px\"}),ce.each({margin:\"\",padding:\"\",border:\"Width\"},function(i,o){ce.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r=\"string\"==typeof e?e.split(\" \"):[e];t<4;t++)n[i+Q[t]+o]=r[t]||r[t-2]||r[0];return n}},\"margin\"!==i&&(ce.cssHooks[i+o].set=rt)}),ce.fn.extend({css:function(e,t){return M(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Xe(e),i=t.length;a<i;a++)o[t[a]]=ce.css(e,t[a],!1,r);return o}return void 0!==n?ce.style(e,t,n):ce.css(e,t)},e,t,1<arguments.length)}}),((ce.Tween=at).prototype={constructor:at,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||ce.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(ce.cssNumber[n]?\"\":\"px\")},cur:function(){var e=at.propHooks[this.prop];return e&&e.get?e.get(this):at.propHooks._default.get(this)},run:function(e){var t,n=at.propHooks[this.prop];return this.options.duration?this.pos=t=ce.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):at.propHooks._default.set(this),this}}).init.prototype=at.prototype,(at.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=ce.css(e.elem,e.prop,\"\"))&&\"auto\"!==t?t:0},set:function(e){ce.fx.step[e.prop]?ce.fx.step[e.prop](e):1!==e.elem.nodeType||!ce.cssHooks[e.prop]&&null==e.elem.style[Ze(e.prop)]?e.elem[e.prop]=e.now:ce.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=at.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},ce.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)\/2},_default:\"swing\"},ce.fx=at.prototype.init,ce.fx.step={};var st,ut,lt,ct,ft=\/^(?:toggle|show|hide)$\/,pt=\/queueHooks$\/;function dt(){ut&&(!1===C.hidden&&ie.requestAnimationFrame?ie.requestAnimationFrame(dt):ie.setTimeout(dt,ce.fx.interval),ce.fx.tick())}function ht(){return ie.setTimeout(function(){st=void 0}),st=Date.now()}function gt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i[\"margin\"+(n=Q[r])]=i[\"padding\"+n]=e;return t&&(i.opacity=i.width=e),i}function vt(e,t,n){for(var r,i=(yt.tweeners[t]||[]).concat(yt.tweeners[\"*\"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function yt(o,e,t){var n,a,r=0,i=yt.prefilters.length,s=ce.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=st||ht(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t\/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:ce.extend({},e),opts:ce.extend(!0,{specialEasing:{},easing:ce.easing._default},t),originalProperties:e,originalOptions:t,startTime:st||ht(),duration:t.duration,tweens:[],createTween:function(e,t){var n=ce.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=F(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=ce.cssHooks[r])&&\"expand\"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=yt.prefilters[r].call(l,o,c,l.opts))return v(n.stop)&&(ce._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return ce.map(c,vt,l),v(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),ce.fx.timer(ce.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}ce.Animation=ce.extend(yt,{tweeners:{\"*\":[function(e,t){var n=this.createTween(e,t);return te(n.elem,e,Y.exec(t),n),n}]},tweener:function(e,t){v(e)?(t=e,e=[\"*\"]):e=e.match(D);for(var n,r=0,i=e.length;r<i;r++)n=e[r],yt.tweeners[n]=yt.tweeners[n]||[],yt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f=\"width\"in t||\"height\"in t,p=this,d={},h=e.style,g=e.nodeType&&ee(e),v=_.get(e,\"fxshow\");for(r in n.queue||(null==(a=ce._queueHooks(e,\"fx\")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,ce.queue(e,\"fx\").length||a.empty.fire()})})),t)if(i=t[r],ft.test(i)){if(delete t[r],o=o||\"toggle\"===i,i===(g?\"hide\":\"show\")){if(\"show\"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||ce.style(e,r)}if((u=!ce.isEmptyObject(t))||!ce.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=_.get(e,\"display\")),\"none\"===(c=ce.css(e,\"display\"))&&(l?c=l:(re([e],!0),l=e.style.display||l,c=ce.css(e,\"display\"),re([e]))),(\"inline\"===c||\"inline-block\"===c&&null!=l)&&\"none\"===ce.css(e,\"float\")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l=\"none\"===c?\"\":c)),h.display=\"inline-block\")),n.overflow&&(h.overflow=\"hidden\",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?\"hidden\"in v&&(g=v.hidden):v=_.access(e,\"fxshow\",{display:l}),o&&(v.hidden=!g),g&&re([e],!0),p.done(function(){for(r in g||re([e]),_.remove(e,\"fxshow\"),d)ce.style(e,r,d[r])})),u=vt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?yt.prefilters.unshift(e):yt.prefilters.push(e)}}),ce.speed=function(e,t,n){var r=e&&\"object\"==typeof e?ce.extend({},e):{complete:n||!n&&t||v(e)&&e,duration:e,easing:n&&t||t&&!v(t)&&t};return ce.fx.off?r.duration=0:\"number\"!=typeof r.duration&&(r.duration in ce.fx.speeds?r.duration=ce.fx.speeds[r.duration]:r.duration=ce.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){v(r.old)&&r.old.call(this),r.queue&&ce.dequeue(this,r.queue)},r},ce.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ee).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=ce.isEmptyObject(t),o=ce.speed(e,n,r),a=function(){var e=yt(this,ce.extend({},t),o);(i||_.get(this,\"finish\"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return\"string\"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||\"fx\",[]),this.each(function(){var e=!0,t=null!=i&&i+\"queueHooks\",n=ce.timers,r=_.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&pt.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||ce.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||\"fx\"),this.each(function(){var e,t=_.get(this),n=t[a+\"queue\"],r=t[a+\"queueHooks\"],i=ce.timers,o=n?n.length:0;for(t.finish=!0,ce.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),ce.each([\"toggle\",\"show\",\"hide\"],function(e,r){var i=ce.fn[r];ce.fn[r]=function(e,t,n){return null==e||\"boolean\"==typeof e?i.apply(this,arguments):this.animate(gt(r,!0),e,t,n)}}),ce.each({slideDown:gt(\"show\"),slideUp:gt(\"hide\"),slideToggle:gt(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,r){ce.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),ce.timers=[],ce.fx.tick=function(){var e,t=0,n=ce.timers;for(st=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||ce.fx.stop(),st=void 0},ce.fx.timer=function(e){ce.timers.push(e),ce.fx.start()},ce.fx.interval=13,ce.fx.start=function(){ut||(ut=!0,dt())},ce.fx.stop=function(){ut=null},ce.fx.speeds={slow:600,fast:200,_default:400},ce.fn.delay=function(r,e){return r=ce.fx&&ce.fx.speeds[r]||r,e=e||\"fx\",this.queue(e,function(e,t){var n=ie.setTimeout(e,r);t.stop=function(){ie.clearTimeout(n)}})},lt=C.createElement(\"input\"),ct=C.createElement(\"select\").appendChild(C.createElement(\"option\")),lt.type=\"checkbox\",le.checkOn=\"\"!==lt.value,le.optSelected=ct.selected,(lt=C.createElement(\"input\")).value=\"t\",lt.type=\"radio\",le.radioValue=\"t\"===lt.value;var mt,xt=ce.expr.attrHandle;ce.fn.extend({attr:function(e,t){return M(this,ce.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){ce.removeAttr(this,e)})}}),ce.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return\"undefined\"==typeof e.getAttribute?ce.prop(e,t,n):(1===o&&ce.isXMLDoc(e)||(i=ce.attrHooks[t.toLowerCase()]||(ce.expr.match.bool.test(t)?mt:void 0)),void 0!==n?null===n?void ce.removeAttr(e,t):i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+\"\"),n):i&&\"get\"in i&&null!==(r=i.get(e,t))?r:null==(r=ce.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!le.radioValue&&\"radio\"===t&&fe(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(D);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),mt={set:function(e,t,n){return!1===t?ce.removeAttr(e,n):e.setAttribute(n,n),n}},ce.each(ce.expr.match.bool.source.match(\/\\w+\/g),function(e,t){var a=xt[t]||ce.find.attr;xt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=xt[o],xt[o]=r,r=null!=a(e,t,n)?o:null,xt[o]=i),r}});var bt=\/^(?:input|select|textarea|button)$\/i,wt=\/^(?:a|area)$\/i;function Tt(e){return(e.match(D)||[]).join(\" \")}function Ct(e){return e.getAttribute&&e.getAttribute(\"class\")||\"\"}function kt(e){return Array.isArray(e)?e:\"string\"==typeof e&&e.match(D)||[]}ce.fn.extend({prop:function(e,t){return M(this,ce.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[ce.propFix[e]||e]})}}),ce.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&ce.isXMLDoc(e)||(t=ce.propFix[t]||t,i=ce.propHooks[t]),void 0!==n?i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&\"get\"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=ce.find.attr(e,\"tabindex\");return t?parseInt(t,10):bt.test(e.nodeName)||wt.test(e.nodeName)&&e.href?0:-1}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"}}),le.optSelected||(ce.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),ce.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){ce.propFix[this.toLowerCase()]=this}),ce.fn.extend({addClass:function(t){var e,n,r,i,o,a;return v(t)?this.each(function(e){ce(this).addClass(t.call(this,e,Ct(this)))}):(e=kt(t)).length?this.each(function(){if(r=Ct(this),n=1===this.nodeType&&\" \"+Tt(r)+\" \"){for(o=0;o<e.length;o++)i=e[o],n.indexOf(\" \"+i+\" \")<0&&(n+=i+\" \");a=Tt(n),r!==a&&this.setAttribute(\"class\",a)}}):this},removeClass:function(t){var e,n,r,i,o,a;return v(t)?this.each(function(e){ce(this).removeClass(t.call(this,e,Ct(this)))}):arguments.length?(e=kt(t)).length?this.each(function(){if(r=Ct(this),n=1===this.nodeType&&\" \"+Tt(r)+\" \"){for(o=0;o<e.length;o++){i=e[o];while(-1<n.indexOf(\" \"+i+\" \"))n=n.replace(\" \"+i+\" \",\" \")}a=Tt(n),r!==a&&this.setAttribute(\"class\",a)}}):this:this.attr(\"class\",\"\")},toggleClass:function(t,n){var e,r,i,o,a=typeof t,s=\"string\"===a||Array.isArray(t);return v(t)?this.each(function(e){ce(this).toggleClass(t.call(this,e,Ct(this),n),n)}):\"boolean\"==typeof n&&s?n?this.addClass(t):this.removeClass(t):(e=kt(t),this.each(function(){if(s)for(o=ce(this),i=0;i<e.length;i++)r=e[i],o.hasClass(r)?o.removeClass(r):o.addClass(r);else void 0!==t&&\"boolean\"!==a||((r=Ct(this))&&_.set(this,\"__className__\",r),this.setAttribute&&this.setAttribute(\"class\",r||!1===t?\"\":_.get(this,\"__className__\")||\"\"))}))},hasClass:function(e){var t,n,r=0;t=\" \"+e+\" \";while(n=this[r++])if(1===n.nodeType&&-1<(\" \"+Tt(Ct(n))+\" \").indexOf(t))return!0;return!1}});var St=\/\\r\/g;ce.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=v(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,ce(this).val()):n)?t=\"\":\"number\"==typeof t?t+=\"\":Array.isArray(t)&&(t=ce.map(t,function(e){return null==e?\"\":e+\"\"})),(r=ce.valHooks[this.type]||ce.valHooks[this.nodeName.toLowerCase()])&&\"set\"in r&&void 0!==r.set(this,t,\"value\")||(this.value=t))})):t?(r=ce.valHooks[t.type]||ce.valHooks[t.nodeName.toLowerCase()])&&\"get\"in r&&void 0!==(e=r.get(t,\"value\"))?e:\"string\"==typeof(e=t.value)?e.replace(St,\"\"):null==e?\"\":e:void 0}}),ce.extend({valHooks:{option:{get:function(e){var t=ce.find.attr(e,\"value\");return null!=t?t:Tt(ce.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a=\"select-one\"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!fe(n.parentNode,\"optgroup\"))){if(t=ce(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=ce.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<ce.inArray(ce.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),ce.each([\"radio\",\"checkbox\"],function(){ce.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<ce.inArray(ce(e).val(),t)}},le.checkOn||(ce.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})});var Et=ie.location,jt={guid:Date.now()},At=\/\\?\/;ce.parseXML=function(e){var t,n;if(!e||\"string\"!=typeof e)return null;try{t=(new ie.DOMParser).parseFromString(e,\"text\/xml\")}catch(e){}return n=t&&t.getElementsByTagName(\"parsererror\")[0],t&&!n||ce.error(\"Invalid XML: \"+(n?ce.map(n.childNodes,function(e){return e.textContent}).join(\"\\n\"):e)),t};var Dt=\/^(?:focusinfocus|focusoutblur)$\/,Nt=function(e){e.stopPropagation()};ce.extend(ce.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||C],d=ue.call(e,\"type\")?e.type:e,h=ue.call(e,\"namespace\")?e.namespace.split(\".\"):[];if(o=f=a=n=n||C,3!==n.nodeType&&8!==n.nodeType&&!Dt.test(d+ce.event.triggered)&&(-1<d.indexOf(\".\")&&(d=(h=d.split(\".\")).shift(),h.sort()),u=d.indexOf(\":\")<0&&\"on\"+d,(e=e[ce.expando]?e:new ce.Event(d,\"object\"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join(\".\"),e.rnamespace=e.namespace?new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:ce.makeArray(t,[e]),c=ce.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!y(n)){for(s=c.delegateType||d,Dt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||C)&&p.push(a.defaultView||a.parentWindow||ie)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(_.get(o,\"events\")||Object.create(null))[e.type]&&_.get(o,\"handle\"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&$(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!$(n)||u&&v(n[d])&&!y(n)&&((a=n[u])&&(n[u]=null),ce.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Nt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Nt),ce.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=ce.extend(new ce.Event,n,{type:e,isSimulated:!0});ce.event.trigger(r,null,t)}}),ce.fn.extend({trigger:function(e,t){return this.each(function(){ce.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return ce.event.trigger(e,t,n,!0)}});var qt=\/\\[\\]$\/,Lt=\/\\r?\\n\/g,Ht=\/^(?:submit|button|image|reset|file)$\/i,Ot=\/^(?:input|select|textarea|keygen)\/i;function Pt(n,e,r,i){var t;if(Array.isArray(e))ce.each(e,function(e,t){r||qt.test(n)?i(n,t):Pt(n+\"[\"+(\"object\"==typeof t&&null!=t?e:\"\")+\"]\",t,r,i)});else if(r||\"object\"!==x(e))i(n,e);else for(t in e)Pt(n+\"[\"+t+\"]\",e[t],r,i)}ce.param=function(e,t){var n,r=[],i=function(e,t){var n=v(t)?t():t;r[r.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(null==n?\"\":n)};if(null==e)return\"\";if(Array.isArray(e)||e.jquery&&!ce.isPlainObject(e))ce.each(e,function(){i(this.name,this.value)});else for(n in e)Pt(n,e[n],t,i);return r.join(\"&\")},ce.fn.extend({serialize:function(){return ce.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=ce.prop(this,\"elements\");return e?ce.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!ce(this).is(\":disabled\")&&Ot.test(this.nodeName)&&!Ht.test(e)&&(this.checked||!we.test(e))}).map(function(e,t){var n=ce(this).val();return null==n?null:Array.isArray(n)?ce.map(n,function(e){return{name:t.name,value:e.replace(Lt,\"\\r\\n\")}}):{name:t.name,value:n.replace(Lt,\"\\r\\n\")}}).get()}});var Mt=\/%20\/g,Rt=\/#.*$\/,It=\/([?&])_=[^&]*\/,Wt=\/^(.*?):[ \\t]*([^\\r\\n]*)$\/gm,Ft=\/^(?:GET|HEAD)$\/,$t=\/^\\\/\\\/\/,Bt={},_t={},zt=\"*\/\".concat(\"*\"),Xt=C.createElement(\"a\");function Ut(o){return function(e,t){\"string\"!=typeof e&&(t=e,e=\"*\");var n,r=0,i=e.toLowerCase().match(D)||[];if(v(t))while(n=i[r++])\"+\"===n[0]?(n=n.slice(1)||\"*\",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Vt(t,i,o,a){var s={},u=t===_t;function l(e){var r;return s[e]=!0,ce.each(t[e]||[],function(e,t){var n=t(i,o,a);return\"string\"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s[\"*\"]&&l(\"*\")}function Gt(e,t){var n,r,i=ce.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&ce.extend(!0,e,r),e}Xt.href=Et.href,ce.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:\"GET\",isLocal:\/^(?:about|app|app-storage|.+-extension|file|res|widget):$\/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:\"application\/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":zt,text:\"text\/plain\",html:\"text\/html\",xml:\"application\/xml, text\/xml\",json:\"application\/json, text\/javascript\"},contents:{xml:\/\\bxml\\b\/,html:\/\\bhtml\/,json:\/\\bjson\\b\/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":JSON.parse,\"text xml\":ce.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Gt(Gt(e,ce.ajaxSettings),t):Gt(ce.ajaxSettings,e)},ajaxPrefilter:Ut(Bt),ajaxTransport:Ut(_t),ajax:function(e,t){\"object\"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=ce.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?ce(y):ce.event,x=ce.Deferred(),b=ce.Callbacks(\"once memory\"),w=v.statusCode||{},a={},s={},u=\"canceled\",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Wt.exec(p))n[t[1].toLowerCase()+\" \"]=(n[t[1].toLowerCase()+\" \"]||[]).concat(t[2])}t=n[e.toLowerCase()+\" \"]}return null==t?null:t.join(\", \")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+\"\").replace($t,Et.protocol+\"\/\/\"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||\"*\").toLowerCase().match(D)||[\"\"],null==v.crossDomain){r=C.createElement(\"a\");try{r.href=v.url,r.href=r.href,v.crossDomain=Xt.protocol+\"\/\/\"+Xt.host!=r.protocol+\"\/\/\"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&\"string\"!=typeof v.data&&(v.data=ce.param(v.data,v.traditional)),Vt(Bt,v,t,T),h)return T;for(i in(g=ce.event&&v.global)&&0==ce.active++&&ce.event.trigger(\"ajaxStart\"),v.type=v.type.toUpperCase(),v.hasContent=!Ft.test(v.type),f=v.url.replace(Rt,\"\"),v.hasContent?v.data&&v.processData&&0===(v.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&(v.data=v.data.replace(Mt,\"+\")):(o=v.url.slice(f.length),v.data&&(v.processData||\"string\"==typeof v.data)&&(f+=(At.test(f)?\"&\":\"?\")+v.data,delete v.data),!1===v.cache&&(f=f.replace(It,\"$1\"),o=(At.test(f)?\"&\":\"?\")+\"_=\"+jt.guid+++o),v.url=f+o),v.ifModified&&(ce.lastModified[f]&&T.setRequestHeader(\"If-Modified-Since\",ce.lastModified[f]),ce.etag[f]&&T.setRequestHeader(\"If-None-Match\",ce.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader(\"Content-Type\",v.contentType),T.setRequestHeader(\"Accept\",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+(\"*\"!==v.dataTypes[0]?\", \"+zt+\"; q=0.01\":\"\"):v.accepts[\"*\"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u=\"abort\",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Vt(_t,v,t,T)){if(T.readyState=1,g&&m.trigger(\"ajaxSend\",[T,v]),h)return T;v.async&&0<v.timeout&&(d=ie.setTimeout(function(){T.abort(\"timeout\")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,\"No Transport\");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&ie.clearTimeout(d),c=void 0,p=r||\"\",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader(\"Content-Type\"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+\" \"+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<ce.inArray(\"script\",v.dataTypes)&&ce.inArray(\"json\",v.dataTypes)<0&&(v.converters[\"text script\"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if(\"*\"===o)o=u;else if(\"*\"!==u&&u!==o){if(!(a=l[u+\" \"+o]||l[\"* \"+o]))for(i in l)if((s=i.split(\" \"))[1]===o&&(a=l[u+\" \"+s[0]]||l[\"* \"+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(e){return{state:\"parsererror\",error:a?e:\"No conversion from \"+u+\" to \"+o}}}return{state:\"success\",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader(\"Last-Modified\"))&&(ce.lastModified[f]=u),(u=T.getResponseHeader(\"etag\"))&&(ce.etag[f]=u)),204===e||\"HEAD\"===v.type?l=\"nocontent\":304===e?l=\"notmodified\":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l=\"error\",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+\"\",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?\"ajaxSuccess\":\"ajaxError\",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger(\"ajaxComplete\",[T,v]),--ce.active||ce.event.trigger(\"ajaxStop\")))}return T},getJSON:function(e,t,n){return ce.get(e,t,n,\"json\")},getScript:function(e,t){return ce.get(e,void 0,t,\"script\")}}),ce.each([\"get\",\"post\"],function(e,i){ce[i]=function(e,t,n,r){return v(t)&&(r=r||n,n=t,t=void 0),ce.ajax(ce.extend({url:e,type:i,dataType:r,data:t,success:n},ce.isPlainObject(e)&&e))}}),ce.ajaxPrefilter(function(e){var t;for(t in e.headers)\"content-type\"===t.toLowerCase()&&(e.contentType=e.headers[t]||\"\")}),ce._evalUrl=function(e,t,n){return ce.ajax({url:e,type:\"GET\",dataType:\"script\",cache:!0,async:!1,global:!1,converters:{\"text script\":function(){}},dataFilter:function(e){ce.globalEval(e,t,n)}})},ce.fn.extend({wrapAll:function(e){var t;return this[0]&&(v(e)&&(e=e.call(this[0])),t=ce(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return v(n)?this.each(function(e){ce(this).wrapInner(n.call(this,e))}):this.each(function(){var e=ce(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=v(t);return this.each(function(e){ce(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not(\"body\").each(function(){ce(this).replaceWith(this.childNodes)}),this}}),ce.expr.pseudos.hidden=function(e){return!ce.expr.pseudos.visible(e)},ce.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},ce.ajaxSettings.xhr=function(){try{return new ie.XMLHttpRequest}catch(e){}};var Yt={0:200,1223:204},Qt=ce.ajaxSettings.xhr();le.cors=!!Qt&&\"withCredentials\"in Qt,le.ajax=Qt=!!Qt,ce.ajaxTransport(function(i){var o,a;if(le.cors||Qt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e[\"X-Requested-With\"]||(e[\"X-Requested-With\"]=\"XMLHttpRequest\"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,\"abort\"===e?r.abort():\"error\"===e?\"number\"!=typeof r.status?t(0,\"error\"):t(r.status,r.statusText):t(Yt[r.status]||r.status,r.statusText,\"text\"!==(r.responseType||\"text\")||\"string\"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o(\"error\"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&ie.setTimeout(function(){o&&a()})},o=o(\"abort\");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),ce.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),ce.ajaxSetup({accepts:{script:\"text\/javascript, application\/javascript, application\/ecmascript, application\/x-ecmascript\"},contents:{script:\/\\b(?:java|ecma)script\\b\/},converters:{\"text script\":function(e){return ce.globalEval(e),e}}}),ce.ajaxPrefilter(\"script\",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\")}),ce.ajaxTransport(\"script\",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=ce(\"<script>\").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on(\"load error\",i=function(e){r.remove(),i=null,e&&t(\"error\"===e.type?404:200,e.type)}),C.head.appendChild(r[0])},abort:function(){i&&i()}}});var Jt,Kt=[],Zt=\/(=)\\?(?=&|$)|\\?\\?\/;ce.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=Kt.pop()||ce.expando+\"_\"+jt.guid++;return this[e]=!0,e}}),ce.ajaxPrefilter(\"json jsonp\",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Zt.test(e.url)?\"url\":\"string\"==typeof e.data&&0===(e.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&Zt.test(e.data)&&\"data\");if(a||\"jsonp\"===e.dataTypes[0])return r=e.jsonpCallback=v(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Zt,\"$1\"+r):!1!==e.jsonp&&(e.url+=(At.test(e.url)?\"&\":\"?\")+e.jsonp+\"=\"+r),e.converters[\"script json\"]=function(){return o||ce.error(r+\" was not called\"),o[0]},e.dataTypes[0]=\"json\",i=ie[r],ie[r]=function(){o=arguments},n.always(function(){void 0===i?ce(ie).removeProp(r):ie[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Kt.push(r)),o&&v(i)&&i(o[0]),o=i=void 0}),\"script\"}),le.createHTMLDocument=((Jt=C.implementation.createHTMLDocument(\"\").body).innerHTML=\"<form><\/form><form><\/form>\",2===Jt.childNodes.length),ce.parseHTML=function(e,t,n){return\"string\"!=typeof e?[]:(\"boolean\"==typeof t&&(n=t,t=!1),t||(le.createHTMLDocument?((r=(t=C.implementation.createHTMLDocument(\"\")).createElement(\"base\")).href=C.location.href,t.head.appendChild(r)):t=C),o=!n&&[],(i=w.exec(e))?[t.createElement(i[1])]:(i=Ae([e],t,o),o&&o.length&&ce(o).remove(),ce.merge([],i.childNodes)));var r,i,o},ce.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(\" \");return-1<s&&(r=Tt(e.slice(s)),e=e.slice(0,s)),v(t)?(n=t,t=void 0):t&&\"object\"==typeof t&&(i=\"POST\"),0<a.length&&ce.ajax({url:e,type:i||\"GET\",dataType:\"html\",data:t}).done(function(e){o=arguments,a.html(r?ce(\"<div>\").append(ce.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},ce.expr.pseudos.animated=function(t){return ce.grep(ce.timers,function(e){return t===e.elem}).length},ce.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=ce.css(e,\"position\"),c=ce(e),f={};\"static\"===l&&(e.style.position=\"relative\"),s=c.offset(),o=ce.css(e,\"top\"),u=ce.css(e,\"left\"),(\"absolute\"===l||\"fixed\"===l)&&-1<(o+u).indexOf(\"auto\")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),v(t)&&(t=t.call(e,n,ce.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),\"using\"in t?t.using.call(e,f):c.css(f)}},ce.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){ce.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if(\"fixed\"===ce.css(r,\"position\"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&\"static\"===ce.css(e,\"position\"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=ce(e).offset()).top+=ce.css(e,\"borderTopWidth\",!0),i.left+=ce.css(e,\"borderLeftWidth\",!0))}return{top:t.top-i.top-ce.css(r,\"marginTop\",!0),left:t.left-i.left-ce.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&\"static\"===ce.css(e,\"position\"))e=e.offsetParent;return e||J})}}),ce.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(t,i){var o=\"pageYOffset\"===i;ce.fn[t]=function(e){return M(this,function(e,t,n){var r;if(y(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),ce.each([\"top\",\"left\"],function(e,n){ce.cssHooks[n]=Ye(le.pixelPosition,function(e,t){if(t)return t=Ge(e,n),_e.test(t)?ce(e).position()[n]+\"px\":t})}),ce.each({Height:\"height\",Width:\"width\"},function(a,s){ce.each({padding:\"inner\"+a,content:s,\"\":\"outer\"+a},function(r,o){ce.fn[o]=function(e,t){var n=arguments.length&&(r||\"boolean\"!=typeof e),i=r||(!0===e||!0===t?\"margin\":\"border\");return M(this,function(e,t,n){var r;return y(e)?0===o.indexOf(\"outer\")?e[\"inner\"+a]:e.document.documentElement[\"client\"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body[\"scroll\"+a],r[\"scroll\"+a],e.body[\"offset\"+a],r[\"offset\"+a],r[\"client\"+a])):void 0===n?ce.css(e,t,i):ce.style(e,t,n,i)},s,n?e:void 0,n)}})}),ce.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){ce.fn[t]=function(e){return this.on(t,e)}}),ce.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)},hover:function(e,t){return this.on(\"mouseenter\",e).on(\"mouseleave\",t||e)}}),ce.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"),function(e,n){ce.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var en=\/^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$\/g;ce.proxy=function(e,t){var n,r,i;if(\"string\"==typeof t&&(n=e[t],t=e,e=n),v(e))return r=ae.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(ae.call(arguments)))}).guid=e.guid=e.guid||ce.guid++,i},ce.holdReady=function(e){e?ce.readyWait++:ce.ready(!0)},ce.isArray=Array.isArray,ce.parseJSON=JSON.parse,ce.nodeName=fe,ce.isFunction=v,ce.isWindow=y,ce.camelCase=F,ce.type=x,ce.now=Date.now,ce.isNumeric=function(e){var t=ce.type(e);return(\"number\"===t||\"string\"===t)&&!isNaN(e-parseFloat(e))},ce.trim=function(e){return null==e?\"\":(e+\"\").replace(en,\"$1\")},\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return ce});var tn=ie.jQuery,nn=ie.$;return ce.noConflict=function(e){return ie.$===ce&&(ie.$=nn),e&&ie.jQuery===ce&&(ie.jQuery=tn),ce},\"undefined\"==typeof e&&(ie.jQuery=ie.$=ce),ce});\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery\/jquery-3.7.1.min.js","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.function.Predicate;\n@@ -36,0 +37,2 @@\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.TypeElement;\n@@ -103,0 +106,1 @@\n+     * @param enabled   whether this tag is enabled\n@@ -116,0 +120,1 @@\n+     * @param enabled   whether this tag is enabled\n@@ -123,0 +128,31 @@\n+    \/**\n+     * Constructs a {@code SimpleTaglet} that will look for tags on enclosing type elements\n+     * if there are no relevant tags on a nested (member) type element.\n+     *\n+     * @param tagKind   the kind of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     * @param enabled   whether this tag is enabled\n+     *\/\n+    static SimpleTaglet createWithDefaultForNested(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations, boolean enabled) {\n+        return new SimpleTaglet(config, tagKind, header, locations, enabled) {\n+            @Override\n+            protected List<? extends BlockTagTree> getDefaultBlockTags(Element e, Predicate<? super BlockTagTree> accepts) {\n+                while (isNestedType(e)) {\n+                    e = e.getEnclosingElement();\n+                    var tags = utils.getBlockTags(e, accepts);\n+                    if (!tags.isEmpty()) {\n+                        return tags;\n+                    }\n+                }\n+\n+                return List.of();\n+            }\n+\n+            private boolean isNestedType(Element e) {\n+                return e.getKind().isDeclaredType()\n+                        && ((TypeElement) e).getNestingKind() == NestingKind.MEMBER;\n+            }\n+        };\n+    }\n+\n@@ -156,2 +192,2 @@\n-     * The taglet accepts a tree node if it has the same kind, and\n-     * if the kind is {@code UNKNOWN_BLOCK_TAG} the same tag name.\n+     * The taglet accepts a tree node if it has the same kind, or\n+     * if the kind is {@code UNKNOWN_BLOCK_TAG} with the same tag name.\n@@ -171,1 +207,1 @@\n-        List<? extends DocTree> tags = utils.getBlockTags(m, this::accepts);\n+        List<? extends DocTree> tags = getBlockTags(m);\n@@ -182,1 +218,1 @@\n-        List<? extends DocTree> tags = utils.getBlockTags(holder, this::accepts);\n+        List<? extends DocTree> tags = getBlockTags(holder);\n@@ -189,0 +225,12 @@\n+    private List<? extends BlockTagTree> getBlockTags(Element e) {\n+        var tags = utils.getBlockTags(e, this::accepts);\n+        if (tags.isEmpty()) {\n+            tags = getDefaultBlockTags(e, this::accepts);\n+        }\n+        return tags;\n+    }\n+\n+    protected List<? extends BlockTagTree> getDefaultBlockTags(Element e, Predicate<? super BlockTagTree> accepts) {\n+        return List.of();\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SimpleTaglet.java","additions":53,"deletions":5,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -593,1 +593,1 @@\n-                new SimpleTaglet(config, SINCE, resources.getText(\"doclet.Since\"),\n+                SimpleTaglet.createWithDefaultForNested(config, SINCE, resources.getText(\"doclet.Since\"),\n@@ -596,1 +596,1 @@\n-                new SimpleTaglet(config, VERSION, resources.getText(\"doclet.Version\"),\n+                SimpleTaglet.createWithDefaultForNested(config, VERSION, resources.getText(\"doclet.Version\"),\n@@ -599,1 +599,1 @@\n-                new SimpleTaglet(config, AUTHOR, resources.getText(\"doclet.Author\"),\n+                SimpleTaglet.createWithDefaultForNested(config, AUTHOR, resources.getText(\"doclet.Author\"),\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletManager.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    public static final DocPath JQUERY_JS = DocPath.create(\"jquery-3.6.1.min.js\");\n+    public static final DocPath JQUERY_JS = DocPath.create(\"jquery-3.7.1.min.js\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## jQuery v3.6.1\n+## jQuery v3.7.1\n@@ -5,1 +5,1 @@\n-jQuery v 3.6.1\n+jQuery v 3.7.1\n@@ -26,46 +26,0 @@\n-\n-******************************************\n-\n-The jQuery JavaScript Library v3.6.1 also includes Sizzle.js\n-\n-Sizzle.js includes the following license:\n-\n-Copyright JS Foundation and other contributors, https:\/\/js.foundation\/\n-\n-This software consists of voluntary contributions made by many\n-individuals. For exact contribution history, see the revision history\n-available at https:\/\/github.com\/jquery\/sizzle\n-\n-The following license applies to all parts of this software except as\n-documented below:\n-\n-====\n-\n-Permission is hereby granted, free of charge, to any person obtaining\n-a copy of this software and associated documentation files (the\n-\"Software\"), to deal in the Software without restriction, including\n-without limitation the rights to use, copy, modify, merge, publish,\n-distribute, sublicense, and\/or sell copies of the Software, and to\n-permit persons to whom the Software is furnished to do so, subject to\n-the following conditions:\n-\n-The above copyright notice and this permission notice shall be\n-included in all copies or substantial portions of the Software.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-====\n-\n-All files located in the node_modules and external directories are\n-externally maintained libraries used by this software which have their\n-own licenses; we recommend you read them, as their terms may differ from\n-the terms above.\n-\n-*********************\n-\n","filename":"src\/jdk.javadoc\/share\/legal\/jquery.md","additions":2,"deletions":48,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,2 +113,2 @@\n-see \\f[B]Conformance requirements\\f[R]\n-[https:\/\/www.w3.org\/TR\/html5\/infrastructure.html#conformance-requirements]\n+see \\f[B]Conformance requirements for authors\\f[R]\n+[https:\/\/html.spec.whatwg.org\/multipage\/introduction.html#conformance-requirements-for-authors]\n@@ -492,1 +492,2 @@\n-Includes the \\f[V]\\[at]author\\f[R] text in the generated docs.\n+Includes the text of any \\f[V]author\\f[R] tags in the generated\n+documentation.\n@@ -515,2 +516,4 @@\n-This command inserts the following line in the head of every generated\n-page:\n+This command inserts the following line, containing a\n+\\f[B]\\f[VB]meta\\f[B] element\\f[R]\n+[https:\/\/html.spec.whatwg.org\/multipage\/semantics.html#the-meta-element]\n+in the head of every generated page:\n@@ -523,4 +526,0 @@\n-.PP\n-The \\f[V]meta\\f[R] tag is described in the \\f[B]HTML standard (4197265\n-and 4137321), HTML Document Representation\\f[R]\n-[http:\/\/www.w3.org\/TR\/REC-html40\/charset.html#h-5.2.2].\n@@ -726,2 +725,2 @@\n-the \\f[B]URL Memo: Uniform Resource Locators\\f[R]\n-[http:\/\/www.ietf.org\/rfc\/rfc1738.txt].\n+the \\f[B]RFC 1738: Uniform Resource Locators (URL)\\f[R]\n+[https:\/\/www.rfc-editor.org\/info\/rfc1738].\n@@ -953,2 +952,2 @@\n-Omits from the generated documents the \\f[V]Since\\f[R] sections\n-associated with the \\f[V]\\[at]since\\f[R] tags.\n+Omits from the generated documentation the \\f[V]Since\\f[R] sections\n+derived from any \\f[V]since\\f[R] tags.\n@@ -1184,1 +1183,2 @@\n-Includes the version text in the generated docs.\n+Includes the text of any \\f[V]version\\f[R] tags in the generated\n+documentation.\n@@ -1186,2 +1186,2 @@\n-To find out what version of the \\f[V]javadoc\\f[R] tool you are using,\n-use the \\f[V]--version\\f[R] option (with two hyphens).\n+Note: To find out what version of the \\f[V]javadoc\\f[R] tool you are\n+using, use the \\f[V]--version\\f[R] option (with two hyphens).\n","filename":"src\/jdk.javadoc\/share\/man\/javadoc.1","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.time.DateTimeException;\n@@ -31,1 +32,1 @@\n-import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n@@ -84,1 +85,1 @@\n-        ZonedDateTime timestamp = ZonedDateTime.now();\n+        LocalDateTime timestamp = timestamp();\n@@ -96,1 +97,1 @@\n-            String filename = chunkFilename.next(timestamp.toLocalDateTime());\n+            String filename = chunkFilename.next(timestamp);\n@@ -106,0 +107,9 @@\n+    private static LocalDateTime timestamp() {\n+        try {\n+            return LocalDateTime.now();\n+        } catch (DateTimeException d) {\n+            Logger.log(LogTag.JFR, LogLevel.INFO, \"Could not create LocalDateTime with the default time zone. Using UTC time zone for chunk filename.\");\n+            return LocalDateTime.now(ZoneOffset.UTC);\n+        }\n+    }\n+\n@@ -110,1 +120,1 @@\n-        String basename = ValueFormatter.formatDateTime(LocalDateTime.now()) + \"_\" + JVM.getPid();\n+        String basename = ValueFormatter.formatDateTime(timestamp()) + \"_\" + JVM.getPid();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import jdk.jfr.internal.util.Utils;\n@@ -320,0 +321,12 @@\n+    public String[] printStartupHelp() {\n+        Map<String, String> parameters = Map.of(\n+            \"$SYNTAX\", \"-XX:StartFlightRecording:[options]\",\n+            \"$SOURCE\", \"-XX:StartFlightRecording:\",\n+            \"$DELIMITER\", \",\",\n+            \"$DELIMITER_NAME\", \"comma\",\n+            \"$DIRECTORY\", exampleDirectory(),\n+            \"$JFC_OPTIONS\", jfcOptions()\n+        );\n+        return Utils.format(helpTemplate(), parameters).lines().toArray(String[]::new);\n+    }\n+\n@@ -322,0 +335,12 @@\n+        Map<String, String> parameters = Map.of(\n+           \"$SYNTAX\", \"JFR.start [options]\",\n+           \"$SOURCE\", \"$ jcmd <pid> JFR.start \",\n+           \"$DELIMITER\", \" \",\n+           \"$DELIMITER_NAME\", \"whitespace\",\n+           \"$DIRECTORY\", exampleDirectory(),\n+           \"$JFC_OPTIONS\", jfcOptions()\n+        );\n+        return Utils.format(helpTemplate(), parameters).lines().toArray(String[]::new);\n+    }\n+\n+    private static String helpTemplate() {\n@@ -324,1 +349,1 @@\n-               Syntax : JFR.start [options]\n+               Syntax : $SYNTAX\n@@ -355,2 +380,2 @@\n-                                  Note: If a filename is given, '%%p' in the filename will be\n-                                  replaced by the PID, and '%%t' will be replaced by the time in\n+                                  Note: If a filename is given, '%p' in the filename will be\n+                                  replaced by the PID, and '%t' will be replaced by the time in\n@@ -412,2 +437,3 @@\n-               %s\n-               Options must be specified using the <key> or <key>=<value> syntax.\n+               $JFC_OPTIONS\n+               Options must be specified using the <key> or <key>=<value> syntax. Multiple\n+               options are separated with a $DELIMITER_NAME.\n@@ -417,16 +443,16 @@\n-                $ jcmd <pid> JFR.start\n-                $ jcmd <pid> JFR.start filename=dump.jfr\n-                $ jcmd <pid> JFR.start filename=%s\n-                $ jcmd <pid> JFR.start dumponexit=true\n-                $ jcmd <pid> JFR.start maxage=1h maxsize=1000M\n-                $ jcmd <pid> JFR.start settings=profile\n-                $ jcmd <pid> JFR.start delay=5m settings=my.jfc\n-                $ jcmd <pid> JFR.start gc=high method-profiling=high\n-                $ jcmd <pid> JFR.start jdk.JavaMonitorEnter#threshold=1ms\n-                $ jcmd <pid> JFR.start +HelloWorld#enabled=true +HelloWorld#stackTrace=true\n-                $ jcmd <pid> JFR.start settings=user.jfc com.example.UserDefined#enabled=true\n-                $ jcmd <pid> JFR.start settings=none +Hello#enabled=true\n-\n-               Note, if the default event settings are modified, overhead may exceed 1%%.\n-\n-               \"\"\".formatted(jfcOptions(), exampleDirectory()).lines().toArray(String[]::new);\n+                $SOURCE\n+                $SOURCEfilename=dump.jfr\n+                $SOURCEfilename=$DIRECTORY\n+                $SOURCEdumponexit=true\n+                $SOURCEmaxage=1h$DELIMITERmaxsize=1000M\n+                $SOURCEsettings=profile\n+                $SOURCEdelay=5m$DELIMITERsettings=my.jfc\n+                $SOURCEgc=high$DELIMITERmethod-profiling=high\n+                $SOURCEjdk.JavaMonitorEnter#threshold=1ms\n+                $SOURCE+HelloWorld#enabled=true$DELIMITER+HelloWorld#stackTrace=true\n+                $SOURCEsettings=user.jfc$DELIMITERcom.example.UserDefined#enabled=true\n+                $SOURCEsettings=none$DELIMITER+Hello#enabled=true\n+\n+               Note, if the default event settings are modified, overhead may exceed 1%.\n+\n+               \"\"\";\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":47,"deletions":21,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-import jdk.jfr.events.SocketReadEvent;\n-import jdk.jfr.events.SocketWriteEvent;\n@@ -65,2 +63,0 @@\n-        SocketReadEvent.class,\n-        SocketWriteEvent.class,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-; Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+; Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -528,1 +528,1 @@\n-                   'State Syncronization', 'Cleanup',\n+                   'State Syncronization',\n@@ -531,1 +531,1 @@\n-                   S.duration, C.duration,\n+                   S.duration,\n@@ -534,1 +534,1 @@\n-              SafepointCleanup AS C, SafepointStateSynchronization AS S\n+              SafepointStateSynchronization AS S\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Collection;\n@@ -448,0 +449,22 @@\n+\n+    public static String format(String template, Map<String, String> parameters) {\n+        StringBuilder sb = new StringBuilder(3 * template.length() \/ 2);\n+        List<String> keys = new ArrayList<>(parameters.keySet());\n+        \/\/ Sort so longest keys are checked first in case keys overlap.\n+        keys.sort((a, b) -> b.length() - a.length());\n+        for (int i = 0; i < template.length(); i++) {\n+            int index = i;\n+            for (int j = 0; j < keys.size(); j++) {\n+                String key = keys.get(j);\n+                if (template.startsWith(key, i)) {\n+                    sb.append(parameters.get(key));\n+                    i += key.length() - 1;\n+                    break;\n+                }\n+            }\n+            if (i == index) {\n+                sb.append(template.charAt(i));\n+            }\n+        }\n+        return sb.toString();\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -203,10 +203,0 @@\n-    <event name=\"jdk.SafepointCleanup\">\n-      <setting name=\"enabled\">false<\/setting>\n-      <setting name=\"threshold\">10 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.SafepointCleanupTask\">\n-      <setting name=\"enabled\">false<\/setting>\n-      <setting name=\"threshold\">10 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -203,10 +203,0 @@\n-    <event name=\"jdk.SafepointCleanup\">\n-      <setting name=\"enabled\">false<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.SafepointCleanupTask\">\n-      <setting name=\"enabled\">false<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,0 +204,18 @@\n+        libProvidersLookup.setPackageLookup(file -> {\n+            Path realPath = file.toRealPath();\n+\n+            try {\n+                \/\/ Try the real path first as it works better on newer Ubuntu versions\n+                return findProvidingPackages(realPath);\n+            } catch (IOException ex) {\n+                \/\/ Try the default path if differ\n+                if (!realPath.toString().equals(file.toString())) {\n+                    return findProvidingPackages(file);\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        });\n+    }\n+\n+    private static Stream<String> findProvidingPackages(Path file) throws IOException {\n@@ -246,18 +264,16 @@\n-        libProvidersLookup.setPackageLookup(file -> {\n-            Set<String> archPackages = new HashSet<>();\n-            Set<String> otherPackages = new HashSet<>();\n-\n-            Executor.of(TOOL_DPKG, \"-S\", file.toString())\n-                    .saveOutput(true).executeExpectSuccess()\n-                    .getOutput().forEach(line -> {\n-                        Matcher matcher = PACKAGE_NAME_REGEX.matcher(line);\n-                        if (matcher.find()) {\n-                            String name = matcher.group(1);\n-                            if (name.endsWith(\":\" + DEB_ARCH)) {\n-                                \/\/ Strip arch suffix\n-                                name = name.substring(0,\n-                                        name.length() - (DEB_ARCH.length() + 1));\n-                                archPackages.add(name);\n-                            } else {\n-                                otherPackages.add(name);\n-                            }\n+        Set<String> archPackages = new HashSet<>();\n+        Set<String> otherPackages = new HashSet<>();\n+\n+        Executor.of(TOOL_DPKG, \"-S\", file.toString())\n+                .saveOutput(true).executeExpectSuccess()\n+                .getOutput().forEach(line -> {\n+                    Matcher matcher = PACKAGE_NAME_REGEX.matcher(line);\n+                    if (matcher.find()) {\n+                        String name = matcher.group(1);\n+                        if (name.endsWith(\":\" + DEB_ARCH)) {\n+                            \/\/ Strip arch suffix\n+                            name = name.substring(0,\n+                                    name.length() - (DEB_ARCH.length() + 1));\n+                            archPackages.add(name);\n+                        } else {\n+                            otherPackages.add(name);\n@@ -265,1 +281,2 @@\n-                    });\n+                    }\n+                });\n@@ -267,5 +284,4 @@\n-            if (!archPackages.isEmpty()) {\n-                return archPackages.stream();\n-            }\n-            return otherPackages.stream();\n-        });\n+        if (!archPackages.isEmpty()) {\n+            return archPackages.stream();\n+        }\n+        return otherPackages.stream();\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":41,"deletions":25,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    \/**** internal access ****\/\n+    \/\/*** internal access ****\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/DeclarationSnippet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    \/**** internal access ****\/\n+    \/\/**** internal access ****\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ExpressionSnippet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-    \/**** internal access ****\/\n+    \/\/**** internal access ****\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ImportSnippet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-    \/****** private implementation methods ******\/\n+    \/\/****** private implementation methods ******\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/MaskCommentsAndModifiers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    \/**** internal access ****\/\n+    \/\/**** internal access ****\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/MethodSnippet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -596,1 +596,1 @@\n-    \/**** public access ****\/\n+    \/\/**** public access ****\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Snippet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    \/**** internal access ****\/\n+    \/\/**** internal access ****\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TypeDeclSnippet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- *     Generally, this is only package that would be needed for creating tools.\n+ *     Generally, this is the only package that would be needed for creating tools.\n","filename":"src\/jdk.jshell\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,135 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!--\n- Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\n- Redistribution and use in source and binary forms, with or without\n- modification, are permitted provided that the following conditions\n- are met:\n-\n-   - Redistributions of source code must retain the above copyright\n-     notice, this list of conditions and the following disclaimer.\n-\n-   - Redistributions in binary form must reproduce the above copyright\n-     notice, this list of conditions and the following disclaimer in the\n-     documentation and\/or other materials provided with the distribution.\n-\n-   - Neither the name of Oracle nor the names of its\n-     contributors may be used to endorse or promote products derived\n-     from this software without specific prior written permission.\n-\n- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n- IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n- CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n--->\n-\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n-         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <parent>\n-        <artifactId>IdealGraphVisualizer-parent<\/artifactId>\n-        <groupId>com.sun.hotspot.igv<\/groupId>\n-        <version>1.0-SNAPSHOT<\/version>\n-    <\/parent>\n-    <artifactId>ControlFlow<\/artifactId>\n-    <version>1.0-SNAPSHOT<\/version>\n-    <packaging>nbm<\/packaging>\n-    <name>ControlFlow<\/name>\n-    <properties>\n-        <maven.compiler.release>17<\/maven.compiler.release>\n-        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n-    <\/properties>\n-    <dependencies>\n-        <dependency>\n-            <groupId>com.sun.hotspot.igv<\/groupId>\n-            <artifactId>Data<\/artifactId>\n-            <version>${project.version}<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>com.sun.hotspot.igv<\/groupId>\n-            <artifactId>Util<\/artifactId>\n-            <version>${project.version}<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>com.sun.hotspot.igv<\/groupId>\n-            <artifactId>Layout<\/artifactId>\n-            <version>${project.version}<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>com.sun.hotspot.igv<\/groupId>\n-            <artifactId>HierarchicalLayout<\/artifactId>\n-            <version>${project.version}<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>org.netbeans.api<\/groupId>\n-            <artifactId>org-netbeans-api-visual<\/artifactId>\n-            <version>${netbeans.version}<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>net.java.dev.swing-layout<\/groupId>\n-            <artifactId>swing-layout<\/artifactId>\n-            <version>${swinglayouts.version}<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>org.netbeans.api<\/groupId>\n-            <artifactId>org-openide-util<\/artifactId>\n-            <version>${netbeans.version}<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>org.netbeans.api<\/groupId>\n-            <artifactId>org-openide-util-lookup<\/artifactId>\n-            <version>${netbeans.version}<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>org.netbeans.api<\/groupId>\n-            <artifactId>org-openide-util-ui<\/artifactId>\n-            <version>${netbeans.version}<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>org.netbeans.api<\/groupId>\n-            <artifactId>org-openide-windows<\/artifactId>\n-            <version>${netbeans.version}<\/version>\n-        <\/dependency>\n-    <\/dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.codehaus.mojo<\/groupId>\n-                <artifactId>nbm-maven-plugin<\/artifactId>\n-                <version>${nbmmvnplugin.version}<\/version>\n-                <extensions>true<\/extensions>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-compiler-plugin<\/artifactId>\n-                <version>${mvncompilerplugin.version}<\/version>\n-                <configuration>\n-                    <release>17<\/release>\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-jar-plugin<\/artifactId>\n-                <version>${mvnjarplugin.version}<\/version>\n-                <configuration>\n-                    <!-- to have the jar plugin pickup the nbm generated manifest -->\n-                    <archive>\n-                        <manifestFile>${project.build.outputDirectory}\/META-INF\/MANIFEST.MF<\/manifestFile>\n-                    <\/archive>\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-enforcer-plugin<\/artifactId>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-<\/project>\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/pom.xml","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.controlflow;\n-\n-import com.sun.hotspot.igv.data.InputBlockEdge;\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Port;\n-import java.awt.BasicStroke;\n-import java.awt.Point;\n-import java.awt.Stroke;\n-import java.util.ArrayList;\n-import java.util.List;\n-import org.netbeans.api.visual.widget.ConnectionWidget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class BlockConnectionWidget extends ConnectionWidget implements Link {\n-\n-    private static final Stroke NORMAL_STROKE = new BasicStroke(1.0f);\n-    private static final Stroke BOLD_STROKE = new BasicStroke(2.5f);\n-    private static final Stroke DASHED_STROKE = new BasicStroke(1.0f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10.0f, new float[]{5, 5}, 0);\n-    private static final Stroke BOLD_DASHED_STROKE = new BasicStroke(2.5f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10.0f, new float[]{5, 5}, 0);\n-\n-    private final BlockWidget from;\n-    private final BlockWidget to;\n-    private final Port inputSlot;\n-    private final Port outputSlot;\n-    private List<Point> points;\n-    private boolean isDashed = false;\n-    private boolean isBold = false;\n-\n-    public BlockConnectionWidget(ControlFlowScene scene, InputBlockEdge edge) {\n-        super(scene);\n-\n-        this.from = (BlockWidget) scene.findWidget(edge.getFrom());\n-        this.to = (BlockWidget) scene.findWidget(edge.getTo());\n-        inputSlot = to.getInputSlot();\n-        outputSlot = from.getOutputSlot();\n-        points = new ArrayList<>();\n-    }\n-\n-    public Port getTo() {\n-        return inputSlot;\n-    }\n-\n-    public Port getFrom() {\n-        return outputSlot;\n-    }\n-\n-    public Cluster getFromCluster() {\n-        return null;\n-    }\n-\n-    public Cluster getToCluster() {\n-        return null;\n-    }\n-\n-    public void setBold(boolean bold) {\n-        this.isBold = bold;\n-        updateStroke();\n-    }\n-\n-    public void setDashed(boolean dashed) {\n-        this.isDashed = dashed;\n-        updateStroke();\n-    }\n-\n-    private void updateStroke() {\n-        Stroke stroke = NORMAL_STROKE;\n-        if (isBold) {\n-            if (isDashed) {\n-                stroke = BOLD_DASHED_STROKE;\n-            } else {\n-                stroke = BOLD_STROKE;\n-            }\n-        } else if (isDashed) {\n-            stroke = DASHED_STROKE;\n-        }\n-        setStroke(stroke);\n-    }\n-\n-    public void setControlPoints(List<Point> p) {\n-        this.points = p;\n-    }\n-\n-    @Override\n-    public List<Point> getControlPoints() {\n-        return points;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Connection[ \" + from.toString() + \" - \" + to.toString() + \"]\";\n-    }\n-\n-    @Override\n-    public boolean isVIP() {\n-        return isBold;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockConnectionWidget.java","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.controlflow;\n-\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.Port;\n-import com.sun.hotspot.igv.layout.Vertex;\n-import java.awt.*;\n-import org.netbeans.api.visual.border.BorderFactory;\n-import org.netbeans.api.visual.model.ObjectState;\n-import org.netbeans.api.visual.widget.LabelWidget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class BlockWidget extends LabelWidget implements Vertex {\n-\n-    public static final Dimension MIN_SIZE = new Dimension(20, 20);\n-    private final InputBlock block;\n-    private final Port inputSlot;\n-    private final Port outputSlot;\n-    private Cluster cluster;\n-    private static final Font font = new Font(Font.SANS_SERIF, Font.PLAIN, 12);\n-    private static final Font boldFont = font.deriveFont(Font.BOLD);\n-    public static final Color NORMAL_FOREGROUND_COLOR = Color.BLACK;\n-    public static final Color HOVER_FOREGROUND_COLOR = Color.BLUE;\n-\n-    \/** Creates a new instance of BlockWidget *\/\n-    public BlockWidget(ControlFlowScene scene, InputBlock block) {\n-        super(scene);\n-        this.block = block;\n-        this.setLabel(block.getName());\n-        this.setForeground(NORMAL_FOREGROUND_COLOR);\n-        this.setBorder(BorderFactory.createLineBorder(1, NORMAL_FOREGROUND_COLOR));\n-        this.setMinimumSize(MIN_SIZE);\n-\n-        this.setFont(font);\n-        this.setAlignment(Alignment.CENTER);\n-\n-        final BlockWidget widget = this;\n-        inputSlot = new Port() {\n-            public Point getRelativePosition() {\n-                return new Point((int) (getSize().getWidth() \/ 2), (int) (getSize().getHeight() \/ 2));\n-            }\n-            public Vertex getVertex() {\n-                return widget;\n-            }\n-        };\n-        outputSlot = new Port() {\n-            public Point getRelativePosition() {\n-                return new Point((int) (getSize().getWidth() \/ 2), (int) (getSize().getHeight() \/ 2));\n-            }\n-            public Vertex getVertex() {\n-                return widget;\n-            }\n-        };\n-    }\n-\n-    public Port getInputSlot() {\n-        return inputSlot;\n-    }\n-\n-    public Port getOutputSlot() {\n-        return outputSlot;\n-    }\n-\n-    public InputBlock getBlock() {\n-        return block;\n-    }\n-\n-    public Dimension getSize() {\n-        Rectangle bounds = getBounds();\n-        if (bounds != null) {\n-            return bounds.getSize();\n-        } else {\n-            return MIN_SIZE;\n-        }\n-    }\n-\n-    public void setPosition(Point p) {\n-        this.setPreferredLocation(p);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return block.getName();\n-    }\n-\n-    public Point getPosition() {\n-        return this.getPreferredLocation();\n-    }\n-\n-    public Cluster getCluster() {\n-        return cluster;\n-    }\n-\n-    public boolean isRoot() {\n-        return false;\n-    }\n-\n-    public int compareTo(Vertex o) {\n-        return toString().compareTo(o.toString());\n-    }\n-\n-    @Override\n-    protected void notifyStateChanged(ObjectState previousState, ObjectState state) {\n-        super.notifyStateChanged(previousState, state);\n-\n-        if (previousState.isHovered() != state.isHovered()) {\n-            if (state.isHovered()) {\n-                this.setBorder(BorderFactory.createLineBorder(1, HOVER_FOREGROUND_COLOR));\n-            } else {\n-                this.setBorder(BorderFactory.createLineBorder(1, NORMAL_FOREGROUND_COLOR));\n-            }\n-        }\n-\n-        if (previousState.isSelected() != state.isSelected()) {\n-            if (state.isSelected()) {\n-                this.setFont(boldFont);\n-            } else {\n-                this.setFont(font);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockWidget.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.controlflow;\n-\n-import java.awt.event.ActionEvent;\n-import javax.swing.AbstractAction;\n-import org.openide.util.NbBundle;\n-import org.openide.windows.TopComponent;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class ControlFlowAction extends AbstractAction {\n-\n-    public ControlFlowAction() {\n-        super(NbBundle.getMessage(ControlFlowAction.class, \"CTL_ControlFlowAction\"));\n-    }\n-\n-    public void actionPerformed(ActionEvent evt) {\n-        TopComponent win = ControlFlowTopComponent.findInstance();\n-        win.open();\n-        win.requestActive();\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowAction.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.controlflow;\n-\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputBlockEdge;\n-import com.sun.hotspot.igv.data.InputGraph;\n-import com.sun.hotspot.igv.data.InputNode;\n-import com.sun.hotspot.igv.data.services.InputGraphProvider;\n-import com.sun.hotspot.igv.util.LookupHistory;\n-import java.awt.Color;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.Set;\n-import javax.swing.BorderFactory;\n-import org.netbeans.api.visual.action.*;\n-import org.netbeans.api.visual.anchor.AnchorFactory;\n-import org.netbeans.api.visual.anchor.AnchorShape;\n-import org.netbeans.api.visual.graph.GraphScene;\n-import org.netbeans.api.visual.graph.layout.GraphLayout;\n-import org.netbeans.api.visual.layout.LayoutFactory;\n-import org.netbeans.api.visual.layout.SceneLayout;\n-import org.netbeans.api.visual.router.RouterFactory;\n-import org.netbeans.api.visual.widget.ConnectionWidget;\n-import org.netbeans.api.visual.widget.LayerWidget;\n-import org.netbeans.api.visual.widget.Widget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class ControlFlowScene extends GraphScene<InputBlock, InputBlockEdge> implements SelectProvider, MoveProvider, RectangularSelectDecorator, RectangularSelectProvider {\n-\n-    private final HashSet<BlockWidget> selection;\n-    private InputGraph oldGraph;\n-    private final LayerWidget edgeLayer;\n-    private final LayerWidget mainLayer;\n-    private final WidgetAction hoverAction = createWidgetHoverAction();\n-    private final WidgetAction selectAction = new DoubleClickSelectAction(this);\n-    private final WidgetAction moveAction = ActionFactory.createMoveAction(null, this);\n-\n-    public ControlFlowScene() {\n-        selection = new HashSet<>();\n-\n-        getInputBindings().setZoomActionModifiers(0);\n-        setLayout(LayoutFactory.createAbsoluteLayout());\n-\n-        mainLayer = new LayerWidget(this);\n-        addChild(mainLayer);\n-\n-        edgeLayer = new LayerWidget(this);\n-        addChild(edgeLayer);\n-\n-        LayerWidget selectLayer = new LayerWidget(this);\n-        addChild(selectLayer);\n-\n-        getActions().addAction(hoverAction);\n-        getActions().addAction(selectAction);\n-        getActions().addAction(ActionFactory.createRectangularSelectAction(this, selectLayer, this));\n-        getActions().addAction(ActionFactory.createMouseCenteredZoomAction(1.1));\n-    }\n-\n-    public void setGraph(InputGraph g) {\n-        if (g == oldGraph) {\n-            return;\n-        }\n-        oldGraph = g;\n-\n-        ArrayList<InputBlock> blocks = new ArrayList<>(getNodes());\n-        for (InputBlock b : blocks) {\n-            removeNode(b);\n-        }\n-\n-        ArrayList<InputBlockEdge> edges = new ArrayList<>(getEdges());\n-        for (InputBlockEdge e : edges) {\n-            removeEdge(e);\n-        }\n-\n-        edgeLayer.removeChildren();\n-        mainLayer.removeChildren();\n-\n-        for (InputBlock b : g.getBlocks()) {\n-            addNode(b);\n-        }\n-\n-        for (InputBlockEdge e : g.getBlockEdges()) {\n-            addEdge(e);\n-            assert g.getBlocks().contains(e.getFrom());\n-            assert g.getBlocks().contains(e.getTo());\n-            setEdgeSource(e, e.getFrom());\n-            setEdgeTarget(e, e.getTo());\n-        }\n-\n-        GraphLayout<InputBlock, InputBlockEdge> layout = new HierarchicalGraphLayout<>();\n-        SceneLayout sceneLayout = LayoutFactory.createSceneGraphLayout(this, layout);\n-        sceneLayout.invokeLayout();\n-\n-        validate();\n-    }\n-\n-    private void clearSelection() {\n-        for (BlockWidget w : selection) {\n-            w.setState(w.getState().deriveSelected(false));\n-        }\n-        selection.clear();\n-        selectionChanged();\n-    }\n-\n-    private void selectionChanged() {\n-        InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n-        if (p != null) {\n-            Set<InputNode> inputNodes = new HashSet<>();\n-            for (BlockWidget w : selection) {\n-                inputNodes.addAll(w.getBlock().getNodes());\n-            }\n-            p.clearSelectedNodes();\n-            p.addSelectedNodes(inputNodes, true);\n-            p.centerSelectedNodes();\n-        }\n-    }\n-\n-    private void addToSelection(BlockWidget widget) {\n-        widget.setState(widget.getState().deriveSelected(true));\n-        selection.add(widget);\n-        selectionChanged();\n-    }\n-\n-    private void removeFromSelection(BlockWidget widget) {\n-        widget.setState(widget.getState().deriveSelected(false));\n-        selection.remove(widget);\n-        selectionChanged();\n-    }\n-\n-    @Override\n-    public boolean isAimingAllowed(Widget widget, Point point, boolean b) {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isSelectionAllowed(Widget widget, Point point, boolean b) {\n-        return true;\n-    }\n-\n-    @Override\n-    public void select(Widget widget, Point point, boolean change) {\n-        if (widget == this) {\n-            clearSelection();\n-        } else {\n-\n-            assert widget instanceof BlockWidget;\n-            BlockWidget bw = (BlockWidget) widget;\n-            if (change) {\n-                if (selection.contains(bw)) {\n-                    removeFromSelection(bw);\n-                } else {\n-                    addToSelection(bw);\n-                }\n-            } else {\n-                if (!selection.contains(bw)) {\n-                    clearSelection();\n-                    addToSelection(bw);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void movementStarted(Widget widget) {}\n-\n-    @Override\n-\n-    public void movementFinished(Widget widget) {}\n-\n-    @Override\n-    public Point getOriginalLocation(Widget widget) {\n-        return widget.getPreferredLocation();\n-    }\n-\n-    @Override\n-    public void setNewLocation(Widget widget, Point location) {\n-        assert widget instanceof BlockWidget;\n-        if (selection.contains((BlockWidget) widget)) {\n-            \/\/ move entire selection\n-            Point originalLocation = getOriginalLocation(widget);\n-            int xOffset = location.x - originalLocation.x;\n-            int yOffset = location.y - originalLocation.y;\n-            for (Widget w : selection) {\n-                Point p = new Point(w.getPreferredLocation());\n-                p.translate(xOffset, yOffset);\n-                w.setPreferredLocation(p);\n-            }\n-        } else {\n-            widget.setPreferredLocation(location);\n-        }\n-    }\n-\n-    @Override\n-    public Widget createSelectionWidget() {\n-        Widget widget = new Widget(this);\n-        widget.setOpaque(false);\n-        widget.setBorder(BorderFactory.createLineBorder(Color.black, 2));\n-        widget.setForeground(Color.red);\n-        return widget;\n-    }\n-\n-    @Override\n-    public void performSelection(Rectangle rectangle) {\n-\n-        if (rectangle.width < 0) {\n-            rectangle.x += rectangle.width;\n-            rectangle.width *= -1;\n-        }\n-\n-        if (rectangle.height < 0) {\n-            rectangle.y += rectangle.height;\n-            rectangle.height *= -1;\n-        }\n-\n-        boolean changed = false;\n-        for (InputBlock b : getNodes()) {\n-            BlockWidget w = (BlockWidget) findWidget(b);\n-            Rectangle r = new Rectangle(w.getBounds());\n-            r.setLocation(w.getLocation());\n-            if (r.intersects(rectangle)) {\n-                if (!selection.contains(w)) {\n-                    changed = true;\n-                    selection.add(w);\n-                    w.setState(w.getState().deriveSelected(true));\n-                }\n-            } else {\n-                if (selection.contains(w)) {\n-                    changed = true;\n-                    selection.remove(w);\n-                    w.setState(w.getState().deriveSelected(false));\n-                }\n-            }\n-        }\n-\n-        if (changed) {\n-            selectionChanged();\n-        }\n-\n-    }\n-\n-    @Override\n-    protected Widget attachNodeWidget(InputBlock node) {\n-        BlockWidget w = new BlockWidget(this, node);\n-        mainLayer.addChild(w);\n-        w.getActions().addAction(hoverAction);\n-        w.getActions().addAction(selectAction);\n-        w.getActions().addAction(moveAction);\n-        return w;\n-    }\n-\n-    @Override\n-    protected Widget attachEdgeWidget(InputBlockEdge edge) {\n-        BlockConnectionWidget w = new BlockConnectionWidget(this, edge);\n-        switch (edge.getState()) {\n-            case NEW:\n-                w.setBold(true);\n-                break;\n-            case DELETED:\n-                w.setDashed(true);\n-                break;\n-        }\n-        w.setRouter(RouterFactory.createDirectRouter());\n-        w.setTargetAnchorShape(AnchorShape.TRIANGLE_FILLED);\n-        edgeLayer.addChild(w);\n-        return w;\n-    }\n-\n-    @Override\n-    protected void attachEdgeSourceAnchor(InputBlockEdge edge, InputBlock oldSourceNode, InputBlock sourceNode) {\n-        Widget w = findWidget(edge);\n-        assert w instanceof ConnectionWidget;\n-        ConnectionWidget cw = (ConnectionWidget) w;\n-        cw.setSourceAnchor(AnchorFactory.createRectangularAnchor(findWidget(sourceNode)));\n-\n-    }\n-\n-    @Override\n-    protected void attachEdgeTargetAnchor(InputBlockEdge edge, InputBlock oldTargetNode, InputBlock targetNode) {\n-        Widget w = findWidget(edge);\n-        assert w instanceof ConnectionWidget;\n-        ConnectionWidget cw = (ConnectionWidget) w;\n-        cw.setTargetAnchor(AnchorFactory.createRectangularAnchor(findWidget(targetNode)));\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowScene.java","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n-\n-<Form version=\"1.3\" maxVersion=\"1.3\" type=\"org.netbeans.modules.form.forminfo.JPanelFormInfo\">\n-  <AuxValues>\n-    <AuxValue name=\"FormSettings_autoResourcing\" type=\"java.lang.Integer\" value=\"0\"\/>\n-    <AuxValue name=\"FormSettings_autoSetComponentName\" type=\"java.lang.Boolean\" value=\"false\"\/>\n-    <AuxValue name=\"FormSettings_generateFQN\" type=\"java.lang.Boolean\" value=\"true\"\/>\n-    <AuxValue name=\"FormSettings_generateMnemonicsCode\" type=\"java.lang.Boolean\" value=\"true\"\/>\n-    <AuxValue name=\"FormSettings_i18nAutoMode\" type=\"java.lang.Boolean\" value=\"false\"\/>\n-    <AuxValue name=\"FormSettings_layoutCodeTarget\" type=\"java.lang.Integer\" value=\"2\"\/>\n-    <AuxValue name=\"FormSettings_listenerGenerationStyle\" type=\"java.lang.Integer\" value=\"0\"\/>\n-    <AuxValue name=\"FormSettings_variablesLocal\" type=\"java.lang.Boolean\" value=\"false\"\/>\n-    <AuxValue name=\"FormSettings_variablesModifier\" type=\"java.lang.Integer\" value=\"2\"\/>\n-  <\/AuxValues>\n-\n-  <Layout>\n-    <DimensionLayout dim=\"0\">\n-      <Group type=\"103\" groupAlignment=\"0\" attributes=\"0\">\n-          <EmptySpace min=\"0\" pref=\"400\" max=\"32767\" attributes=\"0\"\/>\n-      <\/Group>\n-    <\/DimensionLayout>\n-    <DimensionLayout dim=\"1\">\n-      <Group type=\"103\" groupAlignment=\"0\" attributes=\"0\">\n-          <EmptySpace min=\"0\" pref=\"300\" max=\"32767\" attributes=\"0\"\/>\n-      <\/Group>\n-    <\/DimensionLayout>\n-  <\/Layout>\n-<\/Form>\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowTopComponent.form","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.controlflow;\n-\n-import com.sun.hotspot.igv.data.ChangedListener;\n-import com.sun.hotspot.igv.data.InputGraph;\n-import com.sun.hotspot.igv.data.services.InputGraphProvider;\n-import com.sun.hotspot.igv.util.LookupHistory;\n-import java.awt.BorderLayout;\n-import javax.swing.JScrollPane;\n-import javax.swing.SwingUtilities;\n-import org.openide.ErrorManager;\n-import org.openide.util.NbBundle;\n-import org.openide.windows.TopComponent;\n-import org.openide.windows.WindowManager;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-final class ControlFlowTopComponent extends TopComponent implements ChangedListener<InputGraphProvider> {\n-\n-    private static ControlFlowTopComponent instance;\n-    private static final String PREFERRED_ID = \"ControlFlowTopComponent\";\n-    private final ControlFlowScene scene;\n-\n-    private ControlFlowTopComponent() {\n-        initComponents();\n-        setName(NbBundle.getMessage(ControlFlowTopComponent.class, \"CTL_ControlFlowTopComponent\"));\n-        setToolTipText(NbBundle.getMessage(ControlFlowTopComponent.class, \"HINT_ControlFlowTopComponent\"));\n-\n-        scene = new ControlFlowScene();\n-        setLayout(new BorderLayout());\n-        associateLookup(scene.getLookup());\n-\n-        JScrollPane panel = new JScrollPane(scene.createView());\n-        add(panel, BorderLayout.CENTER);\n-    }\n-\n-    \/**\n-     * Gets default instance. Do not use directly: reserved for *.settings files only,\n-     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.\n-     * To obtain the singleton instance, use {@link #findInstance()}.\n-     *\/\n-    public static synchronized ControlFlowTopComponent getDefault() {\n-        if (instance == null) {\n-            instance = new ControlFlowTopComponent();\n-        }\n-        return instance;\n-    }\n-\n-    \/**\n-     * Obtain the ControlFlowTopComponent instance. Never call {@link #getDefault} directly!\n-     *\/\n-    public static synchronized ControlFlowTopComponent findInstance() {\n-        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);\n-        if (win == null) {\n-            ErrorManager.getDefault().log(ErrorManager.WARNING, \"Cannot find ControlFlow component. It will not be located properly in the window system.\");\n-            return getDefault();\n-        }\n-        if (win instanceof ControlFlowTopComponent) {\n-            return (ControlFlowTopComponent) win;\n-        }\n-        ErrorManager.getDefault().log(ErrorManager.WARNING, \"There seem to be multiple components with the '\" + PREFERRED_ID + \"' ID. That is a potential source of errors and unexpected behavior.\");\n-        return getDefault();\n-    }\n-\n-    @Override\n-    public int getPersistenceType() {\n-        return TopComponent.PERSISTENCE_ALWAYS;\n-    }\n-\n-    @Override\n-    public void componentOpened() {\n-        LookupHistory.addListener(InputGraphProvider.class, this);\n-    }\n-\n-    @Override\n-    public void componentClosed() {\n-        LookupHistory.removeListener(InputGraphProvider.class, this);\n-    }\n-\n-    @Override\n-    public void changed(InputGraphProvider lastProvider) {\n-        SwingUtilities.invokeLater(() -> {\n-            if (lastProvider != null) {\n-                InputGraph graph = lastProvider.getGraph();\n-                if (graph != null) {\n-                    scene.setGraph(graph);\n-                    return;\n-                }\n-            }\n-            scene.setGraph(new InputGraph(\"\"));\n-        });\n-    }\n-\n-    @Override\n-    protected String preferredID() {\n-        return PREFERRED_ID;\n-    }\n-\n-    @Override\n-    public void requestActive() {\n-        super.requestActive();\n-        scene.getView().requestFocus();\n-    }\n-\n-    \/** This method is called from within the constructor to\n-     * initialize the form.\n-     * WARNING: Do NOT modify this code. The content of this method is\n-     * always regenerated by the Form Editor.\n-     *\/\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">\/\/GEN-BEGIN:initComponents\n-    private void initComponents() {\n-\n-        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);\n-        this.setLayout(layout);\n-        layout.setHorizontalGroup(\n-                layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n-                        .add(0, 400, Short.MAX_VALUE)\n-        );\n-        layout.setVerticalGroup(\n-                layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n-                        .add(0, 300, Short.MAX_VALUE)\n-        );\n-    }\/\/ <\/editor-fold>\/\/GEN-END:initComponents\n-    \/\/ Variables declaration - do not modify\/\/GEN-BEGIN:variables\n-    \/\/ End of variables declaration\/\/GEN-END:variables\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowTopComponent.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.controlflow;\n-\n-import java.awt.Point;\n-import java.awt.event.MouseEvent;\n-import org.netbeans.api.visual.action.SelectProvider;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.widget.Widget;\n-import org.openide.util.Utilities;\n-\n-\/**\n- * Selection action that acts on double-click only. Does not support aiming.\n- *\n- * @author Peter Hofer\n- *\/\n-public class DoubleClickSelectAction extends WidgetAction.LockedAdapter {\n-\n-    private final SelectProvider provider;\n-\n-    public DoubleClickSelectAction(SelectProvider provider) {\n-        this.provider = provider;\n-    }\n-\n-    protected int getModifierMask () {\n-        return Utilities.isMac() ? MouseEvent.META_DOWN_MASK : MouseEvent.CTRL_DOWN_MASK;\n-    }\n-\n-    protected boolean isLocked() {\n-        return false;\n-    }\n-\n-    @Override\n-    public State mousePressed(Widget widget, WidgetMouseEvent event) {\n-        if (event.getClickCount() >= 2 && (event.getButton() == MouseEvent.BUTTON1 || event.getButton() == MouseEvent.BUTTON2)) {\n-            boolean invert = (event.getModifiersEx() & getModifierMask()) != 0;\n-            Point point = event.getPoint();\n-            if (provider.isSelectionAllowed(widget, point, invert)) {\n-                provider.select(widget, point, invert);\n-                return State.CHAIN_ONLY;\n-            }\n-        }\n-        return State.REJECTED;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/DoubleClickSelectAction.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.controlflow;\n-\n-import com.sun.hotspot.igv.hierarchicallayout.HierarchicalLayoutManager;\n-import com.sun.hotspot.igv.layout.*;\n-import java.awt.Dimension;\n-import java.awt.Point;\n-import java.util.*;\n-import org.netbeans.api.visual.graph.layout.GraphLayout;\n-import org.netbeans.api.visual.graph.layout.UniversalGraph;\n-import org.netbeans.api.visual.widget.Widget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class HierarchicalGraphLayout<N, E> extends GraphLayout<N, E> {\n-\n-    public HierarchicalGraphLayout() {}\n-\n-    private class LinkWrapper implements Link {\n-\n-        private final VertexWrapper from;\n-        private final VertexWrapper to;\n-\n-        public LinkWrapper(VertexWrapper from, VertexWrapper to) {\n-            this.from = from;\n-            this.to = to;\n-        }\n-\n-        public Port getFrom() {\n-            return from.getSlot();\n-        }\n-\n-        public Port getTo() {\n-            return to.getSlot();\n-        }\n-\n-        public Cluster getFromCluster() {\n-            return null;\n-        }\n-\n-        public Cluster getToCluster() {\n-            return null;\n-        }\n-\n-        public List<Point> getControlPoints() {\n-            return new ArrayList<>();\n-        }\n-\n-        public void setControlPoints(List<Point> list) {\n-        \/\/ Do nothing for now\n-        }\n-\n-        public boolean isVIP() {\n-            return false;\n-        }\n-    }\n-\n-    private class VertexWrapper implements Vertex {\n-\n-        private final N node;\n-        private final UniversalGraph<N, E> graph;\n-        private final Port slot;\n-        private Point position;\n-\n-        public VertexWrapper(N node, UniversalGraph<N, E> graph) {\n-            this.node = node;\n-            this.graph = graph;\n-            final VertexWrapper vertex = this;\n-            this.slot = new Port() {\n-\n-                public Vertex getVertex() {\n-                    return vertex;\n-                }\n-\n-                public Point getRelativePosition() {\n-                    return new Point((int) (vertex.getSize().getWidth() \/ 2), (int) (vertex.getSize().getHeight() \/ 2));\n-                }\n-            };\n-\n-            Widget w = graph.getScene().findWidget(node);\n-            this.position = w.getPreferredLocation();\n-        }\n-\n-        public Cluster getCluster() {\n-            return null;\n-        }\n-\n-        public Dimension getSize() {\n-            Widget w = graph.getScene().findWidget(node);\n-            assert w.getBounds() != null;\n-            return w.getBounds().getSize();\n-        }\n-\n-        public Point getPosition() {\n-            return position;\n-        }\n-\n-        public void setPosition(Point p) {\n-            HierarchicalGraphLayout.this.setResolvedNodeLocation(graph, node, p);\n-            position = p;\n-        }\n-\n-        public boolean isRoot() {\n-            return false;\n-        }\n-\n-        public int compareTo(Vertex o) {\n-            @SuppressWarnings(\"unchecked\")\n-            VertexWrapper vw = (VertexWrapper) o;\n-            return node.toString().compareTo(vw.node.toString());\n-        }\n-\n-        public Port getSlot() {\n-            return slot;\n-        }\n-    }\n-\n-    protected void performGraphLayout(UniversalGraph<N, E> graph) {\n-\n-        Set<LinkWrapper> links = new LinkedHashSet<>();\n-        Set<VertexWrapper> vertices = new LinkedHashSet<>();\n-        Map<N, VertexWrapper> vertexMap = new HashMap<>();\n-\n-        for (N node : graph.getNodes()) {\n-            VertexWrapper v = new VertexWrapper(node, graph);\n-            vertexMap.put(node, v);\n-            vertices.add(v);\n-        }\n-\n-        for (E edge : graph.getEdges()) {\n-            N source = graph.getEdgeSource(edge);\n-            N target = graph.getEdgeTarget(edge);\n-            LinkWrapper l = new LinkWrapper(vertexMap.get(source), vertexMap.get(target));\n-            links.add(l);\n-        }\n-\n-        HierarchicalLayoutManager m = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.NONE);\n-\n-        LayoutGraph layoutGraph = new LayoutGraph(links, vertices);\n-        m.doLayout(layoutGraph);\n-    }\n-\n-    protected void performNodesLayout(UniversalGraph<N, E> graph, Collection<N> nodes) {\n-        throw new UnsupportedOperationException();\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/HierarchicalGraphLayout.java","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-Manifest-Version: 1.0\n-OpenIDE-Module: com.sun.hotspot.igv.controlflow\n-OpenIDE-Module-Layer: com\/sun\/hotspot\/igv\/controlflow\/layer.xml\n-OpenIDE-Module-Localizing-Bundle: com\/sun\/hotspot\/igv\/controlflow\/Bundle.properties\n-OpenIDE-Module-Specification-Version: 1.0\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/nbm\/manifest.mf","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-CTL_ControlFlowAction=Control Flow\n-CTL_ControlFlowTopComponent=Control Flow\n-HINT_ControlFlowTopComponent=Shows the blocks of the current graph.\n-OpenIDE-Module-Name=ControlFlow\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/Bundle.properties","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!DOCTYPE settings PUBLIC \"-\/\/NetBeans\/\/DTD Session settings 1.0\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/sessionsettings-1_0.dtd\">\n-<settings version=\"1.0\">\n-    <module name=\"com.sun.hotspot.igv.controlflow\" spec=\"1.0\"\/>\n-    <instanceof class=\"org.openide.windows.TopComponent\"\/>\n-    <instanceof class=\"com.sun.hotspot.igv.controlflow.ControlFlowTopComponent\"\/>\n-    <instance class=\"com.sun.hotspot.igv.controlflow.ControlFlowTopComponent\" method=\"getDefault\"\/>\n-<\/settings>\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowTopComponentSettings.xml","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!DOCTYPE tc-ref PUBLIC \"-\/\/NetBeans\/\/DTD Top Component in Mode Properties 2.0\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n-<tc-ref version=\"2.0\" >\n-    <module name=\"com.sun.hotspot.igv.controlflow\" spec=\"1.0\"\/>\n-    <tc-id id=\"ControlFlowTopComponent\"\/>\n-    <state opened=\"true\"\/>\n-<\/tc-ref>\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowTopComponentWstcref.xml","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,27 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n-<filesystem>\n-    <folder name=\"Actions\">\n-        <folder name=\"Window\">\n-            <file name=\"com-sun-hotspot-igv-controlflow-ControlFlowAction.instance\"\/>\n-        <\/folder>\n-    <\/folder>\n-    <folder name=\"Menu\">\n-        <folder name=\"Window\">\n-            <file name=\"ControlFlowAction.shadow\">\n-                <attr name=\"originalFile\" stringvalue=\"Actions\/Window\/com-sun-hotspot-igv-controlflow-ControlFlowAction.instance\"\/>\n-                <attr name=\"position\" intvalue=\"2\"\/>\n-            <\/file>\n-        <\/folder>\n-    <\/folder>\n-    <folder name=\"Windows2\">\n-        <folder name=\"Components\">\n-            <file name=\"ControlFlowTopComponent.settings\" url=\"ControlFlowTopComponentSettings.xml\"\/>\n-        <\/folder>\n-        <folder name=\"Modes\">\n-            <folder name=\"customRightTopMode\">\n-                <file name=\"ControlFlowTopComponent.wstcref\" url=\"ControlFlowTopComponentWstcref.xml\"\/>\n-            <\/folder>\n-        <\/folder>\n-    <\/folder>\n-<\/filesystem>\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/layer.xml","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -90,0 +90,5 @@\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.netbeans.api<\/groupId>\n+            <artifactId>org-openide-modules<\/artifactId>\n+            <version>${netbeans.version}<\/version>\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/pom.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,5 @@\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n+import com.sun.hotspot.igv.data.serialization.ParseMonitor;\n+import com.sun.hotspot.igv.data.serialization.Parser;\n+import com.sun.hotspot.igv.data.serialization.Printer;\n+import com.sun.hotspot.igv.data.serialization.Printer.GraphContext;\n+import com.sun.hotspot.igv.data.services.GraphViewer;\n@@ -33,0 +37,1 @@\n+import com.sun.hotspot.igv.settings.Settings;\n@@ -37,6 +42,10 @@\n-import java.io.IOException;\n-import java.io.ObjectInput;\n-import java.io.ObjectOutput;\n-import java.util.HashSet;\n-import java.util.Set;\n-import javax.swing.UIManager;\n+import java.io.*;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.swing.*;\n@@ -44,0 +53,3 @@\n+import javax.swing.filechooser.FileFilter;\n+import org.netbeans.api.progress.ProgressHandle;\n+import org.netbeans.api.progress.ProgressHandleFactory;\n@@ -45,1 +57,0 @@\n-import org.openide.actions.GarbageCollectAction;\n@@ -53,0 +64,1 @@\n+import org.openide.util.Lookup;\n@@ -54,0 +66,1 @@\n+import org.openide.windows.Mode;\n@@ -63,1 +76,0 @@\n-    public static OutlineTopComponent instance;\n@@ -65,0 +77,16 @@\n+    private static final GraphDocument document = new GraphDocument();\n+    private static final int WORK_UNITS = 10000;\n+    private static final FileFilter xmlFileFilter = new FileFilter() {\n+        @Override\n+        public boolean accept(File f) {\n+            return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n+        }\n+\n+        @Override\n+        public String getDescription() {\n+            return \"Graph files (*.xml)\";\n+        }\n+    };\n+    private static final Server server = new Server(document, OutlineTopComponent::loadContext);\n+    public static OutlineTopComponent instance;\n+    private final Set<FolderNode> selectedFolders = new HashSet<>();\n@@ -66,1 +94,0 @@\n-    private final GraphDocument document;\n@@ -68,1 +95,2 @@\n-    private SaveAllAction saveAllAction;\n+    private SaveAction saveAction;\n+    private SaveAsAction saveAsAction;\n@@ -71,1 +99,1 @@\n-    private final Set<FolderNode> selectedFolders = new HashSet<>();\n+    private Path documentPath = null;\n@@ -78,2 +106,0 @@\n-\n-        document = new GraphDocument();\n@@ -82,1 +108,70 @@\n-        initReceivers();\n+        server.startServer();\n+    }\n+\n+    public static GraphDocument getDocument() {\n+        return document;\n+    }\n+\n+    \/**\n+     * Gets default instance. Do not use directly: reserved for *.settings files only,\n+     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.\n+     * To obtain the singleton instance, use {@link #findInstance()}.\n+     *\/\n+    private static synchronized OutlineTopComponent getDefault() {\n+        if (instance == null) {\n+            instance = new OutlineTopComponent();\n+        }\n+        return instance;\n+    }\n+\n+    \/**\n+     * Obtain the OutlineTopComponent instance. Never call {@link #getDefault} directly!\n+     *\/\n+    public static synchronized OutlineTopComponent findInstance() {\n+        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);\n+        if (win == null) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING, \"Cannot find Outline component. It will not be located properly in the window system.\");\n+            return getDefault();\n+        }\n+        if (win instanceof OutlineTopComponent) {\n+            return (OutlineTopComponent) win;\n+        }\n+        ErrorManager.getDefault().log(ErrorManager.WARNING, \"There seem to be multiple components with the '\" + PREFERRED_ID + \"' ID. That is a potential source of errors and unexpected behavior.\");\n+        return getDefault();\n+    }\n+\n+    \/**\n+     * Stores the provided graph document to the designated file path with associated contexts.\n+     *\/\n+    private static void saveGraphDocument(GraphDocument doc, String path) throws IOException {\n+        List<GraphContext> saveContexts = new ArrayList<>();\n+        WindowManager manager = WindowManager.getDefault();\n+        for (Mode mode : manager.getModes()) {\n+            List<TopComponent> compList = new ArrayList<>(Arrays.asList(manager.getOpenedTopComponents(mode)));\n+            for (TopComponent comp : compList) {\n+                if (comp instanceof EditorTopComponent etc) {\n+                    InputGraph graph = etc.getModel().getGraph();\n+                    if (graph.isDiffGraph() && graph.getFirstGraph().getGroup() != graph.getSecondGraph().getGroup()) {\n+                        \/\/ don't save diff graphs comparing graphs from different groups\n+                        continue;\n+                    }\n+                    GraphContext graphContext = getGraphContext(etc);\n+                    saveContexts.add(graphContext);\n+                }\n+            }\n+        }\n+\n+        try (Writer writer = new OutputStreamWriter(new FileOutputStream(path))) {\n+            Printer.exportGraphDocument(writer, doc, saveContexts);\n+        }\n+    }\n+\n+    private static GraphContext getGraphContext(EditorTopComponent etc) {\n+        InputGraph openedGraph = etc.getModel().getFirstGraph();\n+        int posDiff = etc.getModel().getSecondPosition() - etc.getModel().getFirstPosition();\n+        if (etc.getModel().getHiddenNodes().isEmpty()) {\n+            return new GraphContext(openedGraph, new AtomicInteger(posDiff), new HashSet<>(), new AtomicBoolean(true));\n+        } else {\n+            Set<Integer> visibleNodes = new HashSet<>(etc.getModel().getVisibleNodes());\n+            return new GraphContext(openedGraph, new AtomicInteger(posDiff), visibleNodes, new AtomicBoolean(false));\n+        }\n@@ -86,1 +181,3 @@\n-        manager = new ExplorerManager();\n+        setDocumentPath(null);\n+        FolderNode.clearGraphNodeMap();\n+        document.clear();\n@@ -88,0 +185,1 @@\n+        manager = new ExplorerManager();\n@@ -90,1 +188,0 @@\n-\n@@ -97,1 +194,1 @@\n-        toolbar.setMinimumSize(new Dimension(0,0)); \/\/ MacOS BUG with ToolbarWithOverflow\n+        toolbar.setMinimumSize(new Dimension(0, 0)); \/\/ MacOS BUG with ToolbarWithOverflow\n@@ -101,0 +198,1 @@\n+        toolbar.add(OpenAction.get(OpenAction.class));\n@@ -102,1 +200,1 @@\n-        toolbar.add(SaveAsAction.get(SaveAsAction.class).createContextAwareInstance(this.getLookup()));\n+        toolbar.addSeparator();\n@@ -104,3 +202,6 @@\n-        saveAllAction = SaveAllAction.get(SaveAllAction.class);\n-        saveAllAction.setEnabled(false);\n-        toolbar.add(saveAllAction);\n+        saveAction = SaveAction.get(SaveAction.class);\n+        saveAction.setEnabled(false);\n+        toolbar.add(saveAction);\n+        saveAsAction = SaveAsAction.get(SaveAsAction.class);\n+        saveAsAction.setEnabled(false);\n+        toolbar.add(saveAsAction);\n@@ -108,0 +209,1 @@\n+        toolbar.addSeparator();\n@@ -109,1 +211,0 @@\n-\n@@ -114,2 +215,0 @@\n-        toolbar.add(GarbageCollectAction.get(GarbageCollectAction.class).getToolbarPresenter());\n-\n@@ -125,1 +224,2 @@\n-        saveAllAction.setEnabled(enableButton);\n+        saveAction.setEnabled(enableButton);\n+        saveAsAction.setEnabled(enableButton);\n@@ -129,19 +229,0 @@\n-    private void initReceivers() {\n-\n-        final GroupCallback callback = g -> {\n-            synchronized(OutlineTopComponent.this) {\n-                g.setParent(getDocument());\n-                getDocument().addElement(g);\n-            }\n-        };\n-\n-        new Server(callback);\n-    }\n-\n-    public void clear() {\n-        document.clear();\n-        FolderNode.clearGraphNodeMap();\n-        root = new FolderNode(document);\n-        manager.setRootContext(root);\n-    }\n-\n@@ -153,32 +234,0 @@\n-    public GraphDocument getDocument() {\n-        return document;\n-    }\n-\n-    \/**\n-     * Gets default instance. Do not use directly: reserved for *.settings files only,\n-     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.\n-     * To obtain the singleton instance, use {@link #findInstance()}.\n-     *\/\n-    public static synchronized OutlineTopComponent getDefault() {\n-        if (instance == null) {\n-            instance = new OutlineTopComponent();\n-        }\n-        return instance;\n-    }\n-\n-    \/**\n-     * Obtain the OutlineTopComponent instance. Never call {@link #getDefault} directly!\n-     *\/\n-    public static synchronized OutlineTopComponent findInstance() {\n-        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);\n-        if (win == null) {\n-            ErrorManager.getDefault().log(ErrorManager.WARNING, \"Cannot find Outline component. It will not be located properly in the window system.\");\n-            return getDefault();\n-        }\n-        if (win instanceof OutlineTopComponent) {\n-            return (OutlineTopComponent) win;\n-        }\n-        ErrorManager.getDefault().log(ErrorManager.WARNING, \"There seem to be multiple components with the '\" + PREFERRED_ID + \"' ID. That is a potential source of errors and unexpected behavior.\");\n-        return getDefault();\n-    }\n-\n@@ -239,9 +288,6 @@\n-                    EditorTopComponent editor = EditorTopComponent.getActive();\n-                    if (editor != null) {\n-                        InputGraph firstGraph = editor.getModel().getFirstGraph();\n-                        GraphNode firstNode = FolderNode.getGraphNode(firstGraph);\n-                        InputGraph secondGraph = editor.getModel().getSecondGraph();\n-                        GraphNode secondNode = FolderNode.getGraphNode(secondGraph);\n-                        if (firstNode != null && secondNode != null) {\n-                            selectedGraphs = new GraphNode[]{firstNode, secondNode};\n-                        }\n+                    InputGraph firstGraph = graph.getFirstGraph();\n+                    GraphNode firstNode = FolderNode.getGraphNode(firstGraph);\n+                    InputGraph secondGraph = graph.getSecondGraph();\n+                    GraphNode secondNode = FolderNode.getGraphNode(secondGraph);\n+                    if (firstNode != null && secondNode != null) {\n+                        selectedGraphs = new GraphNode[]{firstNode, secondNode};\n@@ -274,4 +320,7 @@\n-    public void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n-        \/\/ Not called when user starts application for the first time\n-        super.readExternal(objectInput);\n-        ((BeanTreeView) this.treeView).setRootVisible(false);\n+    public boolean canClose() {\n+        SwingUtilities.invokeLater(() -> {\n+            clearWorkspace();\n+            open(); \/\/ Reopen the OutlineTopComponent\n+            requestActive();\n+        });\n+        return true;\n@@ -280,3 +329,214 @@\n-    @Override\n-    public void writeExternal(ObjectOutput objectOutput) throws IOException {\n-        super.writeExternal(objectOutput);\n+    private void setDocumentPath(String path) {\n+        if (path != null) {\n+            documentPath = Paths.get(path);\n+            setHtmlDisplayName(\"<html><b>\" + documentPath.getFileName().toString() + \"<\/b><\/html>\");\n+            setToolTipText(\"File: \" + path);\n+        } else {\n+            documentPath = null;\n+            setHtmlDisplayName(\"<html><i>untitled<\/i><\/html>\");\n+            setToolTipText(\"No file\");\n+        }\n+\n+    }\n+\n+    \/**\n+     * Clears the workspace by resetting the document path, clearing the document, and resetting the folder structure.\n+     * After clearing the workspace, it will be ready for new documents.\n+     *\/\n+    public void clearWorkspace() {\n+        setDocumentPath(null);\n+        document.clear();\n+        FolderNode.clearGraphNodeMap();\n+        root = new FolderNode(document);\n+        manager.setRootContext(root);\n+        EditorTopComponent.closeAllInstances();\n+    }\n+\n+    \/**\n+     * Opens a file dialog to select and load a graph document.\n+     * Clears the workspace and adds the loaded document to the workspace.\n+     **\/\n+    public void openFile() {\n+        JFileChooser fc = new JFileChooser(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT));\n+        fc.setFileFilter(xmlFileFilter);\n+        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n+            clearWorkspace();\n+            String path = fc.getSelectedFile().getAbsolutePath();\n+            Settings.get().put(Settings.DIRECTORY, path);\n+            setDocumentPath(path);\n+            try {\n+                loadGraphDocument(path, true);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    private boolean overwriteDialog(String filename) {\n+        JFrame frame = new JFrame();\n+        String message = \"Do you want to overwrite \" + filename + \"?\";\n+        int result = JOptionPane.showConfirmDialog(frame, message, \"Confirm Overwrite\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n+        frame.dispose();\n+        return result == JOptionPane.YES_OPTION;\n+    }\n+\n+    \/**\n+     * Saves the current graph document.\n+     * If the document has no location, let the user specify the file location.\n+     *\/\n+    public void save() {\n+        if (documentPath == null) {\n+            saveAs();\n+            return;\n+        }\n+\n+        String filePath = documentPath.toAbsolutePath().toString();\n+        if (Files.exists(Paths.get(filePath)) && overwriteDialog(documentPath.getFileName().toString())) {\n+            try {\n+                saveGraphDocument(getDocument(), filePath);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        } else {\n+            saveAs();\n+        }\n+    }\n+\n+    public void saveAs() {\n+        JFileChooser fc = new JFileChooser();\n+        fc.setDialogTitle(\"Save As...\");\n+        fc.setFileFilter(xmlFileFilter);\n+        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n+        if (fc.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {\n+            String path = fc.getSelectedFile().getAbsolutePath();\n+\n+            \/\/ Ask if the user wants to overwrite the file if it already exists\n+            if (Files.exists(Paths.get(path)) && !overwriteDialog(fc.getSelectedFile().getName())) {\n+                return; \/\/ user does not want to overwrite\n+            }\n+\n+            Settings.get().put(Settings.DIRECTORY, path);\n+            setDocumentPath(path);\n+            try {\n+                saveGraphDocument(getDocument(), path);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Imports graph documents from one or more XML files.\n+     * Displays a file chooser dialog to select one or multiple XML files for import.\n+     * Each selected file is added to the workspace.\n+     **\/\n+    public void importFromXML() {\n+        JFileChooser fc = new JFileChooser();\n+        fc.setFileFilter(xmlFileFilter);\n+        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n+        fc.setMultiSelectionEnabled(true);\n+        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n+            for (final File file : fc.getSelectedFiles()) {\n+                String path = file.getAbsolutePath();\n+                Settings.get().put(Settings.DIRECTORY, path);\n+                try {\n+                    loadGraphDocument(path, false);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Loads and opens the given graph context (opened graphs and visible nodes).\n+     *\/\n+    private static void loadContext(GraphContext context) {\n+        final GraphViewer viewer = Lookup.getDefault().lookup(GraphViewer.class);\n+        if (viewer != null) {\n+            final int difference = context.posDiff().get();\n+            final InputGraph firstGraph = context.inputGraph();\n+            final Set<Integer> visibleNodes = context.visibleNodes();\n+            final boolean showAll = context.showAll().get();\n+\n+            SwingUtilities.invokeLater(() -> {\n+                InputGraph openedGraph = viewer.view(firstGraph, true);\n+                if (openedGraph != null) {\n+                    EditorTopComponent etc = EditorTopComponent.findEditorForGraph(firstGraph);\n+                    if (etc != null) {\n+                        if (showAll) {\n+                            etc.getModel().setHiddenNodes(new HashSet<>());\n+                        } else {\n+                            etc.getModel().showOnly(visibleNodes);\n+                        }\n+                        int firstGraphIdx = firstGraph.getIndex();\n+                        if (difference > 0) {\n+                            etc.getModel().setPositions(firstGraphIdx, firstGraphIdx + difference);\n+                        } else if (difference < 0) {\n+                            etc.getModel().setPositions(firstGraphIdx + difference, firstGraphIdx);\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Loads a graph document from the given file path, updating progress via a ProgressHandle.\n+     * Parse the XML file, add the parsed document to the workspace, and load associated contexts if specified.\n+     *\/\n+    private void loadGraphDocument(String path, boolean loadContext) throws IOException {\n+        if (Files.notExists(Path.of(path))) {\n+            return;\n+        }\n+        File file = new File(path);\n+        final FileChannel channel;\n+        final long start;\n+        try {\n+            channel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+            start = channel.size();\n+        } catch (Exception ex) {\n+            Exceptions.printStackTrace(ex);\n+            return;\n+        }\n+\n+        final ProgressHandle handle = ProgressHandleFactory.createHandle(\"Opening file \" + file.getName());\n+        handle.start(WORK_UNITS);\n+\n+        ParseMonitor monitor = new ParseMonitor() {\n+            @Override\n+            public void updateProgress() {\n+                try {\n+                    int prog = (int) (WORK_UNITS * (double) channel.position() \/ (double) start);\n+                    handle.progress(prog);\n+                } catch (IOException ignored) {\n+                }\n+            }\n+\n+            @Override\n+            public void setState(String state) {\n+                updateProgress();\n+                handle.progress(state);\n+            }\n+        };\n+        try {\n+            if (file.getName().endsWith(\".xml\")) {\n+                ArrayList<GraphContext> contexts = new ArrayList<>();\n+                final Parser parser = new Parser(channel, monitor, document, loadContext ? contexts::add : null);\n+                parser.parse();\n+                SwingUtilities.invokeLater(() -> {\n+                    for (Node child : manager.getRootContext().getChildren().getNodes(true)) {\n+                        \/\/ Nodes are lazily created. By expanding and collapsing they are all initialized\n+                        ((BeanTreeView) this.treeView).expandNode(child);\n+                        ((BeanTreeView) this.treeView).collapseNode(child);\n+                    }\n+                    requestActive();\n+                });\n+                for (GraphContext ctx : contexts) {\n+                    loadContext(ctx);\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+        handle.finish();\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponent.java","additions":354,"deletions":94,"binary":false,"changes":448,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,11 +28,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n-import com.sun.hotspot.igv.data.serialization.GraphParser;\n-import com.sun.hotspot.igv.data.serialization.ParseMonitor;\n-import com.sun.hotspot.igv.data.serialization.Parser;\n-import com.sun.hotspot.igv.settings.Settings;\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-import java.nio.file.StandardOpenOption;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n@@ -40,6 +29,3 @@\n-import javax.swing.JFileChooser;\n-import javax.swing.SwingUtilities;\n-import javax.swing.filechooser.FileFilter;\n-import org.netbeans.api.progress.ProgressHandle;\n-import org.netbeans.api.progress.ProgressHandleFactory;\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.NbBundle;\n@@ -54,1 +40,0 @@\n-    private static final int WORKUNITS = 10000;\n@@ -56,13 +41,3 @@\n-    public static FileFilter getFileFilter() {\n-        return new FileFilter() {\n-\n-            @Override\n-            public boolean accept(File f) {\n-                return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n-            }\n-\n-            @Override\n-            public String getDescription() {\n-                return \"Graph files (*.xml)\";\n-            }\n-        };\n+    public ImportAction() {\n+        putValue(Action.SHORT_DESCRIPTION, \"Import from XML...\");\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n@@ -73,64 +48,1 @@\n-        JFileChooser fc = new JFileChooser();\n-        fc.setFileFilter(ImportAction.getFileFilter());\n-        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n-        fc.setMultiSelectionEnabled(true);\n-\n-        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n-            for (final File file : fc.getSelectedFiles()) {\n-                File dir = file;\n-                if (!dir.isDirectory()) {\n-                    dir = dir.getParentFile();\n-                }\n-\n-                Settings.get().put(Settings.DIRECTORY, dir.getAbsolutePath());\n-                try {\n-                    final FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n-                    final ProgressHandle handle = ProgressHandleFactory.createHandle(\"Opening file \" + file.getName());\n-                    handle.start(WORKUNITS);\n-                    final long startTime = System.currentTimeMillis();\n-                    final long start = channel.size();\n-                    ParseMonitor monitor = new ParseMonitor() {\n-                            @Override\n-                            public void updateProgress() {\n-                                try {\n-                                    int prog = (int) (WORKUNITS * (double) channel.position() \/ (double) start);\n-                                    handle.progress(prog);\n-                                } catch (IOException ignored) {}\n-                            }\n-                            @Override\n-                            public void setState(String state) {\n-                                updateProgress();\n-                                handle.progress(state);\n-                            }\n-                        };\n-                    final GraphParser parser;\n-                    final OutlineTopComponent component = OutlineTopComponent.findInstance();\n-                    if (file.getName().endsWith(\".xml\")) {\n-                        parser = new Parser(channel, monitor, null);\n-                    } else {\n-                        parser = null;\n-                    }\n-                    RequestProcessor.getDefault().post(new Runnable() {\n-                            @Override\n-                            public void run() {\n-                                try {\n-                                    final GraphDocument document = parser.parse();\n-                                    if (document != null) {\n-                                        SwingUtilities.invokeLater(() -> {\n-                                            component.requestActive();\n-                                            component.getDocument().addGraphDocument(document);\n-                                        });\n-                                    }\n-                                } catch (IOException ex) {\n-                                    Exceptions.printStackTrace(ex);\n-                                }\n-                                handle.finish();\n-                                long stop = System.currentTimeMillis();\n-                                Logger.getLogger(getClass().getName()).log(Level.INFO, \"Loaded in \" + file + \" in \" + ((stop - startTime) \/ 1000.0) + \" seconds\");\n-                            }\n-                        });\n-                } catch (IOException ex) {\n-                    Exceptions.printStackTrace(ex);\n-                }\n-            }\n-        }\n+        OutlineTopComponent.findInstance().importFromXML();\n@@ -144,6 +56,0 @@\n-    public ImportAction() {\n-        putValue(Action.SHORT_DESCRIPTION, \"Open\");\n-        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n-        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-O\"));\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/ImportAction.java","additions":8,"deletions":102,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package com.sun.hotspot.igv.coordinator.actions;\n+\n+import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n+import javax.swing.Action;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.NbBundle;\n+import org.openide.util.Utilities;\n+import org.openide.util.actions.CallableSystemAction;\n+\n+public final class OpenAction extends CallableSystemAction {\n+\n+    public OpenAction() {\n+        putValue(Action.SHORT_DESCRIPTION, \"Open...\");\n+        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n+        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-O\"));\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n+    }\n+\n+    @Override\n+    public void performAction() {\n+        OutlineTopComponent.findInstance().openFile();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NbBundle.getMessage(OpenAction.class, \"CTL_OpenAction\");\n+    }\n+\n+    @Override\n+    public HelpCtx getHelpCtx() {\n+        return HelpCtx.DEFAULT_HELP;\n+    }\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/open.png\";\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/OpenAction.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -40,0 +41,5 @@\n+    public RemoveAction() {\n+        putValue(Action.SHORT_DESCRIPTION, getName());\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n+    }\n+\n@@ -50,4 +56,0 @@\n-    public RemoveAction() {\n-        putValue(Action.SHORT_DESCRIPTION, getName());\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/RemoveAction.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -45,1 +46,2 @@\n-        putValue(Action.SHORT_DESCRIPTION, \"Remove all graphs and groups\");\n+        putValue(Action.SHORT_DESCRIPTION, \"Clear workspace\");\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n@@ -65,1 +67,1 @@\n-        OutlineTopComponent.findInstance().clear();\n+        OutlineTopComponent.findInstance().clearWorkspace();\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/RemoveAllAction.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.hotspot.igv.coordinator.actions;\n+\n+import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n+import javax.swing.Action;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.NbBundle;\n+import org.openide.util.Utilities;\n+import org.openide.util.actions.CallableSystemAction;\n+\n+\n+public final class SaveAction extends CallableSystemAction {\n+\n+    public SaveAction() {\n+        putValue(Action.SHORT_DESCRIPTION, \"Save\");\n+        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n+        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-S\"));\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n+    }\n+\n+    @Override\n+    public void performAction() {\n+        OutlineTopComponent.findInstance().save();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NbBundle.getMessage(SaveAction.class, \"CTL_SaveAction\");\n+    }\n+\n+    @Override\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/save.png\";\n+    }\n+\n+    @Override\n+    public HelpCtx getHelpCtx() {\n+        return HelpCtx.DEFAULT_HELP;\n+    }\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAction.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.coordinator.actions;\n-\n-import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n-import javax.swing.Action;\n-import org.openide.util.HelpCtx;\n-import org.openide.util.NbBundle;\n-import org.openide.util.Utilities;\n-import org.openide.util.actions.CallableSystemAction;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-\n-public final class SaveAllAction extends CallableSystemAction {\n-\n-    @Override\n-    public void performAction() {\n-        final OutlineTopComponent component = OutlineTopComponent.findInstance();\n-        SaveAsAction.save(component.getDocument());\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return NbBundle.getMessage(SaveAllAction.class, \"CTL_SaveAllAction\");\n-    }\n-\n-    public SaveAllAction() {\n-        putValue(Action.SHORT_DESCRIPTION, \"Save all groups to XML file...\");\n-        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n-        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-S\"));\n-    }\n-\n-    @Override\n-    protected String iconResource() {\n-        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/saveall.gif\";\n-    }\n-\n-    @Override\n-    public HelpCtx getHelpCtx() {\n-        return HelpCtx.DEFAULT_HELP;\n-    }\n-\n-    @Override\n-    protected boolean asynchronous() {\n-        return false;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAllAction.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,11 +27,1 @@\n-import com.sun.hotspot.igv.coordinator.FolderNode;\n-import com.sun.hotspot.igv.data.Folder;\n-import com.sun.hotspot.igv.data.GraphDocument;\n-import com.sun.hotspot.igv.data.Group;\n-import com.sun.hotspot.igv.data.serialization.Printer;\n-import com.sun.hotspot.igv.settings.Settings;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.OutputStreamWriter;\n-import java.io.Writer;\n-import java.nio.file.Files;\n+import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n@@ -39,2 +29,0 @@\n-import javax.swing.JFileChooser;\n-import org.openide.nodes.Node;\n@@ -42,0 +30,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -43,1 +32,1 @@\n-import org.openide.util.actions.NodeAction;\n+import org.openide.util.actions.CallableSystemAction;\n@@ -49,1 +38,1 @@\n-public final class SaveAsAction extends NodeAction {\n+public final class SaveAsAction extends CallableSystemAction {\n@@ -52,1 +41,2 @@\n-        putValue(Action.SHORT_DESCRIPTION, \"Save selected groups to XML file...\");\n+        putValue(Action.SHORT_DESCRIPTION, \"Save as...\");\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n@@ -56,40 +46,2 @@\n-    protected void performAction(Node[] activatedNodes) {\n-        GraphDocument doc = new GraphDocument();\n-        for (Node node : activatedNodes) {\n-            if (node instanceof FolderNode) {\n-                FolderNode folderNode = (FolderNode) node;\n-                Folder folder = folderNode.getFolder();\n-                if (folder instanceof Group) {\n-                    Group group = (Group) folder;\n-                    doc.addElement(group);\n-                }\n-            }\n-        }\n-        save(doc);\n-    }\n-\n-    public static void save(GraphDocument doc) {\n-        JFileChooser fc = new JFileChooser();\n-        fc.setFileFilter(ImportAction.getFileFilter());\n-        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n-\n-        if (fc.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {\n-            File file = fc.getSelectedFile();\n-            if (!file.getName().contains(\".\")) {\n-                file = new File(file.getAbsolutePath() + \".xml\");\n-            }\n-\n-            File dir = file;\n-            if (!dir.isDirectory()) {\n-                dir = dir.getParentFile();\n-            }\n-            Settings.get().put(Settings.DIRECTORY, dir.getAbsolutePath());\n-            try {\n-                try (Writer writer = new OutputStreamWriter(Files.newOutputStream(file.toPath()))) {\n-                    Printer p = new Printer();\n-                    p.export(writer, doc);\n-                }\n-            } catch (IOException e) {\n-                e.printStackTrace();\n-            }\n-        }\n+    public void performAction() {\n+        OutlineTopComponent.findInstance().saveAs();\n@@ -105,1 +57,1 @@\n-        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/save.png\";\n+        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/save_as.gif\";\n@@ -117,13 +69,0 @@\n-\n-    @Override\n-    protected boolean enable(Node[] nodes) {\n-        if (nodes.length > 0) {\n-            for (Node n : nodes) {\n-                if (!(n instanceof FolderNode) || ((FolderNode) n).isRootNode()) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAsAction.java","additions":10,"deletions":71,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1,5 +1,2 @@\n-AdvancedOption_DisplayName_Coordinator=Settings\n-AdvancedOption_Tooltip_Coordinator=Visualization Tool Settings\n-CTL_OutlineTopComponent=Outline\n-CTL_SomeAction=test\n-HINT_OutlineTopComponent=Displays loaded groups of graphs.\n+CTL_OutlineTopComponent=Workspace\n+HINT_OutlineTopComponent=Opened groups of graphs.\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/Bundle.properties","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,2 @@\n-CTL_ImportAction=Open...\n+CTL_ImportAction=Import...\n+CTL_OpenAction=Open...\n@@ -4,4 +5,4 @@\n-CTL_RemoveAllAction=Remove all graphs and groups\n-CTL_OutlineAction=Outline\n-CTL_SaveAsAction=Save selected groups...\n-CTL_SaveAllAction=Save all groups...\n+CTL_RemoveAllAction=Clear workspace\n+CTL_OutlineAction=Workspace\n+CTL_SaveAction=Save\n+CTL_SaveAsAction=Save as...\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/actions\/Bundle.properties","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/import.png","binary":true,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/open.png","binary":true,"status":"added"},{"patch":"","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/save_as.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/saveall.gif","status":"renamed"},{"patch":"@@ -29,0 +29,2 @@\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-OpenAction.instance\"\/>\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAction.instance\"\/>\n@@ -30,1 +32,0 @@\n-            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAllAction.instance\"\/>\n@@ -58,0 +59,4 @@\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-OpenAction.shadow\">\n+                <attr name=\"originalFile\" stringvalue=\"Actions\/File\/com-sun-hotspot-igv-coordinator-actions-OpenAction.instance\"\/>\n+                <attr name=\"position\" intvalue=\"50\"\/>\n+            <\/file>\n@@ -74,0 +79,4 @@\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAction.shadow\">\n+                <attr name=\"originalFile\" stringvalue=\"Actions\/File\/com-sun-hotspot-igv-coordinator-actions-SaveAction.instance\"\/>\n+                <attr name=\"position\" intvalue=\"600\"\/>\n+            <\/file>\n@@ -76,5 +85,1 @@\n-                <attr name=\"position\" intvalue=\"500\"\/>\n-            <\/file>\n-            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAllAction.shadow\">\n-                <attr name=\"originalFile\" stringvalue=\"Actions\/File\/com-sun-hotspot-igv-coordinator-actions-SaveAllAction.instance\"\/>\n-                <attr name=\"position\" intvalue=\"600\"\/>\n+                <attr name=\"position\" intvalue=\"650\"\/>\n@@ -108,1 +113,0 @@\n-            <file name=\"org-openide-actions-SaveAllAction.shadow_hidden\"\/>\n@@ -110,0 +114,1 @@\n+            <file name=\"org-openide-actions-SaveAllAction.shadow_hidden\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/layer.xml","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-public interface Folder {\n+public interface Folder extends Properties.Provider {\n@@ -36,0 +36,1 @@\n+    Properties getProperties();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Folder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-public interface FolderElement {\n+public interface FolderElement extends Properties.Provider {\n@@ -33,0 +33,1 @@\n+    Properties getProperties();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/FolderElement.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-            for (FolderElement e : document.elements) {\n+            for (FolderElement e : document.getElements()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/GraphDocument.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-        String displayName = (getParent() == null ? \"\" : getParent().getElements().indexOf(this) + 1 + \" - \") + getName();\n+        String displayName = (getParent() == null ? \"\" : getIndex() + 1 + \" - \") + getName();\n@@ -136,0 +136,9 @@\n+    public int getIndex() {\n+        Folder parent = getParent();\n+        if (parent != null) {\n+            return parent.getElements().indexOf(this);\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Group.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.data.Properties;\n@@ -27,0 +28,2 @@\n+import com.sun.hotspot.igv.data.serialization.Printer.GraphContext;\n+import com.sun.hotspot.igv.data.serialization.Printer.GraphContextAction;\n@@ -30,1 +33,0 @@\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n@@ -34,4 +36,3 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -52,1 +53,0 @@\n-    public static final String INDENT = \"  \";\n@@ -56,0 +56,4 @@\n+    public static final String GRAPH_STATES_ELEMENT = \"graphStates\";\n+    public static final String STATE_ELEMENT = \"state\";\n+    public static final String STATE_POSITION_DIFFERENCE = \"difference\";\n+    public static final String POSITION_DIFFERENCE_PROPERTY = \"value\";\n@@ -63,0 +67,2 @@\n+    public static final String VISIBLE_NODES_ELEMENT = \"visibleNodes\";\n+    public static final String ALL_PROPERTY = \"all\";\n@@ -66,6 +72,0 @@\n-    public static final String GROUP_NAME_PROPERTY = \"name\";\n-    public static final String METHOD_IS_PUBLIC_PROPERTY = \"public\";\n-    public static final String METHOD_IS_STATIC_PROPERTY = \"static\";\n-    public static final String TRUE_VALUE = \"true\";\n-    public static final String NODE_NAME_PROPERTY = \"name\";\n-    public static final String EDGE_NAME_PROPERTY = \"name\";\n@@ -92,1 +92,0 @@\n-    public static final String ASSEMBLY_ELEMENT = \"assembly\";\n@@ -94,1 +93,1 @@\n-    private final TopElementHandler<GraphDocument> xmlDocument = new TopElementHandler<>();\n+    private final TopElementHandler<GraphDocument> xmlData = new TopElementHandler<>();\n@@ -97,1 +96,3 @@\n-    private final GroupCallback groupCallback;\n+    private final GraphDocument callbackDocument;\n+    private final GraphContextAction contextAction;\n+    private final ArrayList<GraphContext> contexts = new ArrayList<>();\n@@ -100,2 +101,0 @@\n-    private int maxId = 0;\n-    private GraphDocument graphDocument;\n@@ -106,55 +105,0 @@\n-    private int lookupID(String i) {\n-        try {\n-            return Integer.parseInt(i);\n-        } catch (NumberFormatException nfe) {\n-            \/\/ ignore\n-        }\n-        Integer id = idCache.get(i);\n-        if (id == null) {\n-            id = maxId++;\n-            idCache.put(i, id);\n-        }\n-        return id;\n-    }\n-\n-    \/\/ <graphDocument>\n-    private ElementHandler<GraphDocument, Object> topHandler = new ElementHandler<GraphDocument, Object>(TOP_ELEMENT) {\n-\n-        @Override\n-        protected GraphDocument start() throws SAXException {\n-            graphDocument = new GraphDocument();\n-            return graphDocument;\n-        }\n-    };\n-    \/\/ <group>\n-    private ElementHandler<Group, Folder> groupHandler = new XMLParser.ElementHandler<Group, Folder>(GROUP_ELEMENT) {\n-\n-        @Override\n-        protected Group start() throws SAXException {\n-            final Group group = new Group(this.getParentObject());\n-\n-            String differenceProperty = this.readAttribute(DIFFERENCE_PROPERTY);\n-            Parser.this.differenceEncoding.put(group, (differenceProperty != null && (differenceProperty.equals(\"1\") || differenceProperty.equals(\"true\"))));\n-\n-            ParseMonitor monitor = getMonitor();\n-            if (monitor != null) {\n-                monitor.setState(group.getName());\n-            }\n-\n-            final Folder parent = getParentObject();\n-            if (groupCallback == null || parent instanceof Group) {\n-                Runnable addToParent = () -> parent.addElement(group);\n-                if (invokeLater) {\n-                    SwingUtilities.invokeLater(addToParent);\n-                } else {\n-                    addToParent.run();\n-                }\n-            }\n-\n-            return group;\n-        }\n-\n-        @Override\n-        protected void end(String text) throws SAXException {\n-        }\n-    };\n@@ -162,1 +106,1 @@\n-    private ElementHandler<InputMethod, Group> methodHandler = new XMLParser.ElementHandler<InputMethod, Group>(METHOD_ELEMENT) {\n+    private final ElementHandler<InputMethod, Group> methodHandler = new XMLParser.ElementHandler<>(METHOD_ELEMENT) {\n@@ -166,3 +110,3 @@\n-\n-            InputMethod method = parseMethod(this, getParentObject());\n-            getParentObject().setMethod(method);\n+            Group group = getParentObject();\n+            InputMethod method = parseMethod(this, group);\n+            group.setMethod(method);\n@@ -172,12 +116,0 @@\n-\n-    private InputMethod parseMethod(XMLParser.ElementHandler<?,?> handler, Group group) throws SAXException {\n-        String s = handler.readRequiredAttribute(METHOD_BCI_PROPERTY);\n-        int bci = 0;\n-        try {\n-            bci = Integer.parseInt(s);\n-        } catch (NumberFormatException e) {\n-            throw new SAXException(e);\n-        }\n-        InputMethod method = new InputMethod(group, handler.readRequiredAttribute(METHOD_NAME_PROPERTY), handler.readRequiredAttribute(METHOD_SHORT_NAME_PROPERTY), bci);\n-        return method;\n-    }\n@@ -185,1 +117,1 @@\n-    private HandoverElementHandler<InputMethod> bytecodesHandler = new XMLParser.HandoverElementHandler<InputMethod>(BYTECODES_ELEMENT, true) {\n+    private final HandoverElementHandler<InputMethod> bytecodesHandler = new XMLParser.HandoverElementHandler<>(BYTECODES_ELEMENT, true) {\n@@ -188,1 +120,1 @@\n-        protected void end(String text) throws SAXException {\n+        protected void end(String text) {\n@@ -193,1 +125,1 @@\n-    private HandoverElementHandler<InputMethod> inlinedHandler = new XMLParser.HandoverElementHandler<>(INLINE_ELEMENT);\n+    private final HandoverElementHandler<InputMethod> inlinedHandler = new XMLParser.HandoverElementHandler<>(INLINE_ELEMENT);\n@@ -195,1 +127,1 @@\n-    private ElementHandler<InputMethod, InputMethod> inlinedMethodHandler = new XMLParser.ElementHandler<InputMethod, InputMethod>(METHOD_ELEMENT) {\n+    private final ElementHandler<InputMethod, InputMethod> inlinedMethodHandler = new XMLParser.ElementHandler<>(METHOD_ELEMENT) {\n@@ -204,2 +136,6 @@\n-    \/\/ <graph>\n-    private ElementHandler<InputGraph, Group> graphHandler = new XMLParser.ElementHandler<InputGraph, Group>(GRAPH_ELEMENT) {\n+    \/\/ <nodes>\n+    private final HandoverElementHandler<InputGraph> nodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n+    \/\/ <controlFlow>\n+    private final HandoverElementHandler<InputGraph> controlFlowHandler = new HandoverElementHandler<>(CONTROL_FLOW_ELEMENT);\n+    private final HandoverElementHandler<InputGraph> graphStatesHandler = new HandoverElementHandler<>(GRAPH_STATES_ELEMENT);\n+    private final ElementHandler<GraphContext, InputGraph> stateHandler = new ElementHandler<>(STATE_ELEMENT) {\n@@ -208,14 +144,5 @@\n-        protected InputGraph start() throws SAXException {\n-            String name = readAttribute(GRAPH_NAME_PROPERTY);\n-            InputGraph curGraph = new InputGraph(name);\n-            if (differenceEncoding.get(getParentObject())) {\n-                InputGraph previous = lastParsedGraph.get(getParentObject());\n-                lastParsedGraph.put(getParentObject(), curGraph);\n-                if (previous != null) {\n-                    for (InputNode n : previous.getNodes()) {\n-                        curGraph.addNode(n);\n-                    }\n-                    for (InputEdge e : previous.getEdges()) {\n-                        curGraph.addEdge(e);\n-                    }\n-                }\n+        protected GraphContext start() {\n+            InputGraph inputGraph = getParentObject();\n+            GraphContext graphContext = new GraphContext(inputGraph, new AtomicInteger(0), new HashSet<>(), new AtomicBoolean(false));\n+            if (contextAction != null) {\n+                contexts.add(graphContext);\n@@ -223,5 +150,1 @@\n-            ParseMonitor monitor = getMonitor();\n-            if (monitor != null) {\n-                monitor.updateProgress();\n-            }\n-            return curGraph;\n+            return graphContext;\n@@ -229,0 +152,2 @@\n+    };\n+    private final ElementHandler<GraphContext, GraphContext> visibleNodesHandler = new ElementHandler<>(VISIBLE_NODES_ELEMENT) {\n@@ -231,38 +156,7 @@\n-        protected void end(String text) throws SAXException {\n-            \/\/ NOTE: Some graphs intentionally don't provide blocks. Instead\n-            \/\/       they later generate the blocks from other information such\n-            \/\/       as node properties (example: ServerCompilerScheduler).\n-            \/\/       Thus, we shouldn't assign nodes that don't belong to any\n-            \/\/       block to some artificial block below unless blocks are\n-            \/\/       defined and nodes are assigned to them.\n-\n-            final InputGraph graph = getObject();\n-            final Group parent = getParentObject();\n-            if (graph.getBlocks().size() > 0) {\n-                boolean blocksContainNodes = false;\n-                for (InputBlock b : graph.getBlocks()) {\n-                    if (b.getNodes().size() > 0) {\n-                        blocksContainNodes = true;\n-                        break;\n-                    }\n-                }\n-\n-                if (!blocksContainNodes) {\n-                    graph.clearBlocks();\n-                    blockConnections.clear();\n-                } else {\n-                    \/\/ Blocks and their nodes defined: add other nodes to an\n-                    \/\/  artificial \"no block\" block\n-                    InputBlock noBlock = null;\n-                    for (InputNode n : graph.getNodes()) {\n-                        if (graph.getBlock(n) == null) {\n-                            if (noBlock == null) {\n-                                noBlock = graph.addArtificialBlock();\n-                            }\n-\n-                            noBlock.addNode(n.getId());\n-                        }\n-\n-                        assert graph.getBlock(n) != null;\n-                    }\n-                }\n+        protected GraphContext start() throws SAXException {\n+            String s = readRequiredAttribute(ALL_PROPERTY);\n+            try {\n+                boolean all = Boolean.parseBoolean(s);\n+                getParentObject().showAll().set(all);\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n@@ -270,0 +164,4 @@\n+            return getParentObject();\n+        }\n+    };\n+    private final ElementHandler<GraphContext, GraphContext> visibleNodeHandler = new ElementHandler<>(NODE_ELEMENT) {\n@@ -271,7 +169,8 @@\n-            \/\/ Resolve block successors\n-            for (Pair<String, String> p : blockConnections) {\n-                final InputBlock left = graph.getBlock(p.getLeft());\n-                assert left != null;\n-                final InputBlock right = graph.getBlock(p.getRight());\n-                assert right != null;\n-                graph.addBlockEdge(left, right);\n+        @Override\n+        protected GraphContext start() throws SAXException {\n+            String s = readRequiredAttribute(NODE_ID_PROPERTY);\n+            int nodeID;\n+            try {\n+                nodeID = Integer.parseInt(s);\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n@@ -279,1 +178,5 @@\n-            blockConnections.clear();\n+            getParentObject().visibleNodes().add(nodeID);\n+            return getParentObject();\n+        }\n+    };\n+    private final ElementHandler<GraphContext, GraphContext> differenceHandler = new ElementHandler<>(STATE_POSITION_DIFFERENCE) {\n@@ -281,5 +184,8 @@\n-            Runnable addToParent = () -> parent.addElement(graph);\n-            if (invokeLater) {\n-                SwingUtilities.invokeLater(addToParent);\n-            } else {\n-                addToParent.run();\n+        @Override\n+        protected GraphContext start() throws SAXException {\n+            String s = readRequiredAttribute(POSITION_DIFFERENCE_PROPERTY);\n+            int posDiff;\n+            try {\n+                posDiff = Integer.parseInt(s);\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n@@ -287,0 +193,2 @@\n+            getParentObject().posDiff().set(posDiff);\n+            return getParentObject();\n@@ -289,4 +197,0 @@\n-    \/\/ <nodes>\n-    private HandoverElementHandler<InputGraph> nodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n-    \/\/ <controlFlow>\n-    private HandoverElementHandler<InputGraph> controlFlowHandler = new HandoverElementHandler<>(CONTROL_FLOW_ELEMENT);\n@@ -294,1 +198,1 @@\n-    private ElementHandler<InputBlock, InputGraph> blockHandler = new ElementHandler<InputBlock, InputGraph>(BLOCK_ELEMENT) {\n+    private final ElementHandler<InputBlock, InputGraph> blockHandler = new ElementHandler<>(BLOCK_ELEMENT) {\n@@ -308,1 +212,50 @@\n-    private HandoverElementHandler<InputBlock> blockNodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n+    private final HandoverElementHandler<InputBlock> blockNodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n+    \/\/ <successors>\n+    private final HandoverElementHandler<InputBlock> successorsHandler = new HandoverElementHandler<>(SUCCESSORS_ELEMENT);\n+    \/\/ <successor>\n+    private final ElementHandler<InputBlock, InputBlock> successorHandler = new ElementHandler<>(SUCCESSOR_ELEMENT) {\n+\n+        @Override\n+        protected InputBlock start() throws SAXException {\n+            String name = readRequiredAttribute(BLOCK_NAME_PROPERTY);\n+            blockConnections.add(new Pair<>(getParentObject().getName(), name));\n+            return getParentObject();\n+        }\n+    };\n+    \/\/ <graph>\n+    private final HandoverElementHandler<InputGraph> edgesHandler = new HandoverElementHandler<>(EDGES_ELEMENT);\n+    \/\/ <edge>\n+    private final EdgeElementHandler edgeHandler = new EdgeElementHandler(EDGE_ELEMENT) {\n+\n+        @Override\n+        protected InputEdge start(InputEdge conn) {\n+            InputGraph inputGraph = getParentObject();\n+            inputGraph.addEdge(conn);\n+            return conn;\n+        }\n+    };\n+    \/\/ <removeEdge>\n+    private final EdgeElementHandler removeEdgeHandler = new EdgeElementHandler(REMOVE_EDGE_ELEMENT) {\n+\n+        @Override\n+        protected InputEdge start(InputEdge conn) {\n+            getParentObject().removeEdge(conn);\n+            return conn;\n+        }\n+    };\n+    \/\/ <properties>\n+    private final HandoverElementHandler<Properties.Provider> propertiesHandler = new HandoverElementHandler<>(PROPERTIES_ELEMENT);\n+    \/\/ <property>\n+    private final ElementHandler<String, Properties.Provider> propertyHandler = new XMLParser.ElementHandler<>(PROPERTY_ELEMENT, true) {\n+\n+        @Override\n+        public String start() throws SAXException {\n+            return readRequiredAttribute(PROPERTY_NAME_PROPERTY);\n+        }\n+\n+        @Override\n+        public void end(String text) {\n+            getParentObject().getProperties().setProperty(getObject(), text.trim());\n+        }\n+    };\n+    private int maxId = 0;\n@@ -310,1 +263,1 @@\n-    private ElementHandler<InputBlock, InputBlock> blockNodeHandler = new ElementHandler<InputBlock, InputBlock>(NODE_ELEMENT) {\n+    private final ElementHandler<InputBlock, InputBlock> blockNodeHandler = new ElementHandler<>(NODE_ELEMENT) {\n@@ -316,1 +269,1 @@\n-            int id = 0;\n+            int id;\n@@ -326,12 +279,0 @@\n-    \/\/ <successors>\n-    private HandoverElementHandler<InputBlock> successorsHandler = new HandoverElementHandler<>(SUCCESSORS_ELEMENT);\n-    \/\/ <successor>\n-    private ElementHandler<InputBlock, InputBlock> successorHandler = new ElementHandler<InputBlock, InputBlock>(SUCCESSOR_ELEMENT) {\n-\n-        @Override\n-        protected InputBlock start() throws SAXException {\n-            String name = readRequiredAttribute(BLOCK_NAME_PROPERTY);\n-            blockConnections.add(new Pair<>(getParentObject().getName(), name));\n-            return getParentObject();\n-        }\n-    };\n@@ -339,1 +280,1 @@\n-    private ElementHandler<InputNode, InputGraph> nodeHandler = new ElementHandler<InputNode, InputGraph>(NODE_ELEMENT) {\n+    private final ElementHandler<InputNode, InputGraph> nodeHandler = new ElementHandler<>(NODE_ELEMENT) {\n@@ -344,1 +285,1 @@\n-            int id = 0;\n+            int id;\n@@ -356,1 +297,1 @@\n-    private ElementHandler<InputNode, InputGraph> removeNodeHandler = new ElementHandler<InputNode, InputGraph>(REMOVE_NODE_ELEMENT) {\n+    private final ElementHandler<InputNode, InputGraph> removeNodeHandler = new ElementHandler<>(REMOVE_NODE_ELEMENT) {\n@@ -361,1 +302,1 @@\n-            int id = 0;\n+            int id;\n@@ -370,5 +311,3 @@\n-    \/\/ <graph>\n-    private HandoverElementHandler<InputGraph> edgesHandler = new HandoverElementHandler<>(EDGES_ELEMENT);\n-\n-    \/\/ Local class for edge elements\n-    private class EdgeElementHandler extends ElementHandler<InputEdge, InputGraph> {\n+    private GraphDocument graphDocument;\n+    \/\/ <graphDocument>\n+    private final ElementHandler<GraphDocument, Object> topHandler = new ElementHandler<>(TOP_ELEMENT) {\n@@ -376,2 +315,4 @@\n-        public EdgeElementHandler(String name) {\n-            super(name);\n+        @Override\n+        protected GraphDocument start() {\n+            graphDocument = new GraphDocument();\n+            return graphDocument;\n@@ -379,0 +320,3 @@\n+    };\n+    \/\/ <group>\n+    private final ElementHandler<Group, Folder> groupHandler = new XMLParser.ElementHandler<>(GROUP_ELEMENT) {\n@@ -381,7 +325,3 @@\n-        protected InputEdge start() throws SAXException {\n-            int fromIndex = 0;\n-            int toIndex = 0;\n-            int from = -1;\n-            int to = -1;\n-            String label = null;\n-            String type = null;\n+        protected Group start() {\n+            final Folder folder = getParentObject();\n+            final Group group = new Group(folder);\n@@ -389,16 +329,2 @@\n-            try {\n-                String fromIndexString = readAttribute(FROM_INDEX_PROPERTY);\n-                if (fromIndexString != null) {\n-                    fromIndex = Integer.parseInt(fromIndexString);\n-                }\n-\n-                String toIndexString = readAttribute(TO_INDEX_PROPERTY);\n-                if (toIndexString == null) {\n-                    toIndexString = readAttribute(TO_INDEX_ALT_PROPERTY);\n-                }\n-                if (toIndexString != null) {\n-                    toIndex = Integer.parseInt(toIndexString);\n-                }\n-\n-                label = readAttribute(LABEL_PROPERTY);\n-                type = readAttribute(TYPE_PROPERTY);\n+            String differenceProperty = this.readAttribute(DIFFERENCE_PROPERTY);\n+            Parser.this.differenceEncoding.put(group, (differenceProperty != null && (differenceProperty.equals(\"1\") || differenceProperty.equals(\"true\"))));\n@@ -406,4 +332,3 @@\n-                from = lookupID(readRequiredAttribute(FROM_PROPERTY));\n-                to = lookupID(readRequiredAttribute(TO_PROPERTY));\n-            } catch (NumberFormatException e) {\n-                throw new SAXException(e);\n+            ParseMonitor monitor = getMonitor();\n+            if (monitor != null) {\n+                monitor.setState(group.getName());\n@@ -412,3 +337,7 @@\n-            InputEdge conn = new InputEdge((char) fromIndex, (char) toIndex, from, to, label, type == null ? \"\" : type);\n-            return start(conn);\n-        }\n+            if (callbackDocument == null || folder instanceof Group) {\n+                if (invokeLater) {\n+                    SwingUtilities.invokeLater(() -> folder.addElement(group));\n+                } else {\n+                    folder.addElement(group);\n+                }\n+            }\n@@ -416,2 +345,1 @@\n-        protected InputEdge start(InputEdge conn) throws SAXException {\n-            return conn;\n+            return group;\n@@ -419,3 +347,0 @@\n-    }\n-    \/\/ <edge>\n-    private EdgeElementHandler edgeHandler = new EdgeElementHandler(EDGE_ELEMENT) {\n@@ -424,3 +349,1 @@\n-        protected InputEdge start(InputEdge conn) throws SAXException {\n-            getParentObject().addEdge(conn);\n-            return conn;\n+        protected void end(String text) {\n@@ -429,2 +352,2 @@\n-    \/\/ <removeEdge>\n-    private EdgeElementHandler removeEdgeHandler = new EdgeElementHandler(REMOVE_EDGE_ELEMENT) {\n+    \/\/ <graph>\n+    private final ElementHandler<InputGraph, Group> graphHandler = new XMLParser.ElementHandler<>(GRAPH_ELEMENT) {\n@@ -433,3 +356,21 @@\n-        protected InputEdge start(InputEdge conn) throws SAXException {\n-            getParentObject().removeEdge(conn);\n-            return conn;\n+        protected InputGraph start() {\n+            Group group = getParentObject();\n+            String name = readAttribute(GRAPH_NAME_PROPERTY);\n+            InputGraph curGraph = new InputGraph(name);\n+            if (differenceEncoding.get(group)) {\n+                InputGraph previous = lastParsedGraph.get(group);\n+                lastParsedGraph.put(group, curGraph);\n+                if (previous != null) {\n+                    for (InputNode n : previous.getNodes()) {\n+                        curGraph.addNode(n);\n+                    }\n+                    for (InputEdge e : previous.getEdges()) {\n+                        curGraph.addEdge(e);\n+                    }\n+                }\n+            }\n+            ParseMonitor monitor = getMonitor();\n+            if (monitor != null) {\n+                monitor.updateProgress();\n+            }\n+            return curGraph;\n@@ -437,5 +378,0 @@\n-    };\n-    \/\/ <properties>\n-    private HandoverElementHandler<Properties.Provider> propertiesHandler = new HandoverElementHandler<>(PROPERTIES_ELEMENT);\n-    \/\/ <properties>\n-    private HandoverElementHandler<Group> groupPropertiesHandler = new HandoverElementHandler<Group>(PROPERTIES_ELEMENT) {\n@@ -444,6 +380,23 @@\n-        public void end(String text) throws SAXException {\n-            if (groupCallback != null && getParentObject().getParent() instanceof GraphDocument) {\n-                final Group group = getParentObject();\n-                Runnable addStarted = () -> groupCallback.started(group);\n-                if (invokeLater) {\n-                    SwingUtilities.invokeLater(addStarted);\n+        protected void end(String text) {\n+            \/\/ NOTE: Some graphs intentionally don't provide blocks. Instead,\n+            \/\/       they later generate the blocks from other information such\n+            \/\/       as node properties (example: ServerCompilerScheduler).\n+            \/\/       Thus, we shouldn't assign nodes that don't belong to any\n+            \/\/       block to some artificial block below unless blocks are\n+            \/\/       defined and nodes are assigned to them.\n+\n+            final InputGraph graph = getObject();\n+\n+            final Group parent = getParentObject();\n+            if (!graph.getBlocks().isEmpty()) {\n+                boolean blocksContainNodes = false;\n+                for (InputBlock b : graph.getBlocks()) {\n+                    if (!b.getNodes().isEmpty()) {\n+                        blocksContainNodes = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!blocksContainNodes) {\n+                    graph.clearBlocks();\n+                    blockConnections.clear();\n@@ -451,1 +404,14 @@\n-                    addStarted.run();\n+                    \/\/ Blocks and their nodes defined: add other nodes to an\n+                    \/\/ artificial \"no block\" block\n+                    InputBlock noBlock = null;\n+                    for (InputNode n : graph.getNodes()) {\n+                        if (graph.getBlock(n) == null) {\n+                            if (noBlock == null) {\n+                                noBlock = graph.addArtificialBlock();\n+                            }\n+\n+                            noBlock.addNode(n.getId());\n+                        }\n+\n+                        assert graph.getBlock(n) != null;\n+                    }\n@@ -454,0 +420,22 @@\n+\n+            \/\/ Resolve block successors\n+            for (Pair<String, String> p : blockConnections) {\n+                final InputBlock left = graph.getBlock(p.getLeft());\n+                assert left != null;\n+                final InputBlock right = graph.getBlock(p.getRight());\n+                assert right != null;\n+                graph.addBlockEdge(left, right);\n+            }\n+            blockConnections.clear();\n+\n+            if (invokeLater) {\n+                SwingUtilities.invokeLater(() -> parent.addElement(graph));\n+            } else {\n+                parent.addElement(graph);\n+            }\n+            if (contextAction != null) {\n+                for (GraphContext ctx : contexts) {\n+                    contextAction.performAction(ctx);\n+                }\n+            }\n+            contexts.clear();\n@@ -456,7 +444,2 @@\n-    \/\/ <property>\n-    private ElementHandler<String, Properties.Provider> propertyHandler = new XMLParser.ElementHandler<String, Properties.Provider>(PROPERTY_ELEMENT, true) {\n-\n-        @Override\n-        public String start() throws SAXException {\n-            return readRequiredAttribute(PROPERTY_NAME_PROPERTY);\n-         }\n+    \/\/ <properties>\n+    private final HandoverElementHandler<Group> groupPropertiesHandler = new HandoverElementHandler<>(PROPERTIES_ELEMENT) {\n@@ -466,1 +449,9 @@\n-            getParentObject().getProperties().setProperty(getObject(), text.trim());\n+            final Group group = getParentObject();\n+            if (callbackDocument != null && group.getParent() instanceof GraphDocument) {\n+                group.setParent(callbackDocument);\n+                if (invokeLater) {\n+                    SwingUtilities.invokeLater(() -> callbackDocument.addElement(group));\n+                } else {\n+                    callbackDocument.addElement(group);\n+                }\n+            }\n@@ -470,7 +461,3 @@\n-    public Parser(ReadableByteChannel channel) {\n-        this(channel, null, null);\n-    }\n-\n-    public Parser(ReadableByteChannel channel, ParseMonitor monitor, GroupCallback groupCallback) {\n-\n-        this.groupCallback = groupCallback;\n+    public Parser(ReadableByteChannel channel, ParseMonitor monitor, GraphDocument callbackDocument, GraphContextAction contextAction) {\n+        this.callbackDocument = callbackDocument;\n+        this.contextAction = contextAction;\n@@ -481,1 +468,1 @@\n-        xmlDocument.addChild(topHandler);\n+        xmlData.addChild(topHandler);\n@@ -498,0 +485,1 @@\n+        graphHandler.addChild(graphStatesHandler);\n@@ -501,0 +489,5 @@\n+        graphStatesHandler.addChild(stateHandler);\n+        stateHandler.addChild(differenceHandler);\n+        stateHandler.addChild(visibleNodesHandler);\n+        visibleNodesHandler.addChild(visibleNodeHandler);\n+\n@@ -521,0 +514,25 @@\n+    private int lookupID(String i) {\n+        try {\n+            return Integer.parseInt(i);\n+        } catch (NumberFormatException nfe) {\n+            \/\/ ignore\n+        }\n+        Integer id = idCache.get(i);\n+        if (id == null) {\n+            id = maxId++;\n+            idCache.put(i, id);\n+        }\n+        return id;\n+    }\n+\n+    private InputMethod parseMethod(XMLParser.ElementHandler<?, ?> handler, Group group) throws SAXException {\n+        String s = handler.readRequiredAttribute(METHOD_BCI_PROPERTY);\n+        int bci;\n+        try {\n+            bci = Integer.parseInt(s);\n+        } catch (NumberFormatException e) {\n+            throw new SAXException(e);\n+        }\n+        return new InputMethod(group, handler.readRequiredAttribute(METHOD_NAME_PROPERTY), handler.readRequiredAttribute(METHOD_SHORT_NAME_PROPERTY), bci);\n+    }\n+\n@@ -531,1 +549,1 @@\n-            reader.setContentHandler(new XMLParser(xmlDocument, monitor));\n+            reader.setContentHandler(new XMLParser(xmlData, monitor));\n@@ -541,0 +559,1 @@\n+\n@@ -552,4 +571,4 @@\n-            SAXParserFactory pfactory = SAXParserFactory.newInstance();\n-            pfactory.setValidating(false);\n-            pfactory.setNamespaceAware(true);\n-            return pfactory.newSAXParser().getXMLReader();\n+            SAXParserFactory pFactory = SAXParserFactory.newInstance();\n+            pFactory.setValidating(false);\n+            pFactory.setNamespaceAware(true);\n+            return pFactory.newSAXParser().getXMLReader();\n@@ -560,0 +579,48 @@\n+\n+    \/\/ Local class for edge elements\n+    private class EdgeElementHandler extends ElementHandler<InputEdge, InputGraph> {\n+\n+        public EdgeElementHandler(String name) {\n+            super(name);\n+        }\n+\n+        @Override\n+        protected InputEdge start() throws SAXException {\n+            int fromIndex = 0;\n+            int toIndex = 0;\n+            int from;\n+            int to;\n+            String label;\n+            String type;\n+\n+            try {\n+                String fromIndexString = readAttribute(FROM_INDEX_PROPERTY);\n+                if (fromIndexString != null) {\n+                    fromIndex = Integer.parseInt(fromIndexString);\n+                }\n+\n+                String toIndexString = readAttribute(TO_INDEX_PROPERTY);\n+                if (toIndexString == null) {\n+                    toIndexString = readAttribute(TO_INDEX_ALT_PROPERTY);\n+                }\n+                if (toIndexString != null) {\n+                    toIndex = Integer.parseInt(toIndexString);\n+                }\n+\n+                label = readAttribute(LABEL_PROPERTY);\n+                type = readAttribute(TYPE_PROPERTY);\n+\n+                from = lookupID(readRequiredAttribute(FROM_PROPERTY));\n+                to = lookupID(readRequiredAttribute(TO_PROPERTY));\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n+            }\n+\n+            InputEdge conn = new InputEdge((char) fromIndex, (char) toIndex, from, to, label, type == null ? \"\" : type);\n+            return start(conn);\n+        }\n+\n+        protected InputEdge start(InputEdge conn) {\n+            return conn;\n+        }\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Parser.java","additions":339,"deletions":272,"binary":false,"changes":611,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.InputStream;\n@@ -31,0 +30,1 @@\n+import java.util.List;\n@@ -32,0 +32,3 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n@@ -39,12 +42,1 @@\n-    private final InputStream in;\n-\n-    public Printer() {\n-        this(null);\n-    }\n-\n-    public Printer(InputStream inputStream) {\n-        this.in = inputStream;\n-    }\n-\n-    public void export(Writer writer, GraphDocument document) {\n-\n+    public static void exportGraphDocument(Writer writer, Folder folder, List<GraphContext> contexts) {\n@@ -52,1 +44,0 @@\n-\n@@ -54,12 +45,8 @@\n-            export(xmlWriter, document);\n-        } catch (IOException ignored) {}\n-    }\n-\n-    private void export(XMLWriter xmlWriter, GraphDocument document) throws IOException {\n-        xmlWriter.startTag(Parser.ROOT_ELEMENT);\n-        xmlWriter.writeProperties(document.getProperties());\n-        for (FolderElement e : document.getElements()) {\n-            if (e instanceof Group) {\n-                export(xmlWriter, (Group) e);\n-            } else if (e instanceof InputGraph) {\n-                export(xmlWriter, (InputGraph)e, null, false);\n+            xmlWriter.startTag(Parser.ROOT_ELEMENT);\n+            xmlWriter.writeProperties(folder.getProperties());\n+            for (FolderElement e : folder.getElements()) {\n+                if (e instanceof Group group) {\n+                    exportGroup(xmlWriter, group, contexts);\n+                } else if (e instanceof InputGraph graph) {\n+                    exportInputGraph(xmlWriter, graph, null, false, contexts);\n+                }\n@@ -67,4 +54,3 @@\n-        }\n-\n-        xmlWriter.endTag();\n-        xmlWriter.flush();\n+            xmlWriter.endTag();\n+            xmlWriter.flush();\n+        } catch (IOException ignored) {}\n@@ -73,1 +59,1 @@\n-    private void export(XMLWriter writer, Group g) throws IOException {\n+    private static void exportGroup(XMLWriter writer, Group g, List<GraphContext> contexts) throws IOException {\n@@ -79,6 +65,2 @@\n-        boolean shouldExport = true;\n-        if (in != null) {\n-            char c = (char) in.read();\n-            if (c != 'y') {\n-                shouldExport = false;\n-            }\n+        if (g.getMethod() != null) {\n+            exportInputMethod(writer, g.getMethod());\n@@ -87,14 +69,7 @@\n-        if (shouldExport) {\n-            if (g.getMethod() != null) {\n-                export(writer, g.getMethod());\n-            }\n-\n-            InputGraph previous = null;\n-            for (FolderElement e : g.getElements()) {\n-                if (e instanceof InputGraph) {\n-                    InputGraph graph = (InputGraph) e;\n-                    export(writer, graph, previous, true);\n-                    previous = graph;\n-                } else if (e instanceof Group) {\n-                    export(writer, (Group) e);\n-                }\n+        InputGraph previous = null;\n+        for (FolderElement e : g.getElements()) {\n+            if (e instanceof InputGraph graph) {\n+                exportInputGraph(writer, graph, previous, true, contexts);\n+                previous = graph;\n+            } else if (e instanceof Group group) {\n+                exportGroup(writer, group, contexts);\n@@ -107,2 +82,1 @@\n-    public void export(XMLWriter writer, InputGraph graph, InputGraph previous, boolean difference) throws IOException {\n-\n+    private static void exportInputGraph(XMLWriter writer, InputGraph graph, InputGraph previous, boolean difference, List<GraphContext> contexts) throws IOException {\n@@ -138,1 +112,1 @@\n-                writer.endTag();\n+                writer.endTag(); \/\/ Parser.NODE_ELEMENT\n@@ -142,1 +116,1 @@\n-        writer.endTag();\n+        writer.endTag(); \/\/ Parser.NODES_ELEMENT\n@@ -172,1 +146,1 @@\n-        writer.endTag();\n+        writer.endTag(); \/\/ Parser.EDGES_ELEMENT\n@@ -178,1 +152,1 @@\n-            if (b.getSuccessors().size() > 0) {\n+            if (!b.getSuccessors().isEmpty()) {\n@@ -183,1 +157,1 @@\n-                writer.endTag();\n+                writer.endTag(); \/\/ Parser.SUCCESSORS_ELEMENT\n@@ -186,2 +160,2 @@\n-            if (b.getNodes().size() > 0) {\n-            writer.startTag(Parser.NODES_ELEMENT);\n+            if (!b.getNodes().isEmpty()) {\n+                writer.startTag(Parser.NODES_ELEMENT);\n@@ -191,1 +165,1 @@\n-                writer.endTag();\n+                writer.endTag(); \/\/ Parser.NODES_ELEMENT\n@@ -194,1 +168,1 @@\n-            writer.endTag();\n+            writer.endTag(); \/\/ Parser.BLOCK_ELEMENT\n@@ -197,2 +171,5 @@\n-        writer.endTag();\n-        writer.endTag();\n+        writer.endTag(); \/\/ Parser.CONTROL_FLOW_ELEMENT\n+\n+        exportStates(writer, graph, contexts);\n+\n+        writer.endTag(); \/\/ Parser.GRAPH_ELEMENT\n@@ -201,1 +178,15 @@\n-    private void export(XMLWriter w, InputMethod method) throws IOException {\n+    private static void exportStates(XMLWriter writer, InputGraph exportingGraph, List<GraphContext> contexts) throws IOException {\n+        List<GraphContext> contextsContainingGraph = contexts.stream()\n+                .filter(context -> context.inputGraph().equals(exportingGraph))\n+                .toList();\n+\n+        if (contextsContainingGraph.isEmpty()) {\n+            return;\n+        }\n+\n+        writer.startTag(Parser.GRAPH_STATES_ELEMENT);\n+\n+        for (GraphContext context : contextsContainingGraph) {\n+            assert exportingGraph == context.inputGraph();\n+\n+            writer.startTag(Parser.STATE_ELEMENT);\n@@ -203,0 +194,16 @@\n+            writer.simpleTag(Parser.STATE_POSITION_DIFFERENCE,\n+                    new Properties(Parser.POSITION_DIFFERENCE_PROPERTY, Integer.toString(context.posDiff().get())));\n+\n+            writer.startTag(Parser.VISIBLE_NODES_ELEMENT, new Properties(Parser.ALL_PROPERTY, Boolean.toString(context.showAll().get())));\n+            for (Integer hiddenNodeID : context.visibleNodes()) {\n+                writer.simpleTag(Parser.NODE_ELEMENT, new Properties(Parser.NODE_ID_PROPERTY, hiddenNodeID.toString()));\n+            }\n+            writer.endTag(); \/\/ Parser.VISIBLE_NODES_ELEMENT\n+\n+            writer.endTag(); \/\/ Parser.STATES_ELEMENT\n+        }\n+\n+        writer.endTag(); \/\/ Parser.GRAPH_STATE_ELEMENT\n+    }\n+\n+    private static void exportInputMethod(XMLWriter w, InputMethod method) throws IOException {\n@@ -207,1 +214,1 @@\n-        if (method.getInlined().size() > 0) {\n+        if (!method.getInlined().isEmpty()) {\n@@ -210,1 +217,1 @@\n-                export(w, m);\n+                exportInputMethod(w, m);\n@@ -232,1 +239,1 @@\n-    private Properties createProperties(InputEdge edge) {\n+    private static Properties createProperties(InputEdge edge) {\n@@ -245,0 +252,6 @@\n+\n+    public record GraphContext(InputGraph inputGraph, AtomicInteger posDiff, Set<Integer> visibleNodes, AtomicBoolean showAll) { }\n+\n+    public interface GraphContextAction {\n+        void performAction(GraphContext context);\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Printer.java","additions":82,"deletions":69,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-    void view(InputGraph graph, boolean newTab);\n+    InputGraph view(InputGraph graph, boolean newTab);\n@@ -36,1 +36,1 @@\n-    void viewDifference(InputGraph firstGraph, InputGraph secondGraph);\n+    InputGraph viewDifference(InputGraph firstGraph, InputGraph secondGraph);\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/services\/GraphViewer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.data.services;\n-\n-import com.sun.hotspot.igv.data.Group;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public interface GroupCallback {\n-\n-    public void started(Group g);\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/services\/GroupCallback.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import java.util.ArrayList;\n+import java.util.HashSet;\n@@ -65,1 +67,0 @@\n-        final Printer printer = new Printer();\n@@ -67,1 +68,1 @@\n-        printer.export(writer, document);\n+        Printer.exportGraphDocument(writer, document, new ArrayList<>());\n@@ -74,1 +75,1 @@\n-            Parser parser = new Parser(Channels.newChannel(in));\n+            Parser parser = new Parser(Channels.newChannel(in), null, null, null);\n@@ -76,2 +77,2 @@\n-            final GraphDocument parsedDocument = parser.parse();\n-            Util.assertGraphDocumentEquals(document, parsedDocument);\n+            final GraphDocument exportData = parser.parse();\n+            Util.assertGraphDocumentEquals(document, exportData);\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/ParserTest.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.connection;\n-\n-import com.sun.hotspot.igv.data.serialization.Parser;\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n-import java.io.IOException;\n-import java.nio.channels.SocketChannel;\n-import org.openide.util.Exceptions;\n-\n-public class Client implements Runnable {\n-    private final SocketChannel socket;\n-    private final GroupCallback callback;\n-\n-    public Client(SocketChannel socket, GroupCallback callback) {\n-        this.callback = callback;\n-        this.socket = socket;\n-    }\n-\n-    @Override\n-    public void run() {\n-\n-        try {\n-            final SocketChannel channel = socket;\n-            channel.configureBlocking(true);\n-            channel.socket().getOutputStream().write('y');\n-            new Parser(channel, null, callback).parse();\n-        } catch (IOException ex) {\n-            Exceptions.printStackTrace(ex);\n-        } finally {\n-            try {\n-                socket.close();\n-            } catch (IOException ex) {\n-                Exceptions.printStackTrace(ex);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Client.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,3 @@\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n+import com.sun.hotspot.igv.data.GraphDocument;\n+import com.sun.hotspot.igv.data.serialization.Parser;\n+import com.sun.hotspot.igv.data.serialization.Printer.GraphContextAction;\n@@ -35,3 +37,0 @@\n-import org.openide.DialogDisplayer;\n-import org.openide.NotifyDescriptor;\n-import org.openide.util.RequestProcessor;\n@@ -45,1 +44,2 @@\n-    private final GroupCallback callback;\n+    private final GraphDocument graphDocument;\n+    private final GraphContextAction contextAction;\n@@ -47,1 +47,0 @@\n-    private Runnable serverRunnable;\n@@ -49,3 +48,6 @@\n-    public Server(GroupCallback callback) {\n-        this.callback = callback;\n-        initializeNetwork();\n+    private volatile boolean isServerRunning;\n+\n+    public Server(GraphDocument graphDocument, GraphContextAction contextAction) {\n+        this.graphDocument = graphDocument;\n+        this.contextAction = contextAction;\n+        port = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n@@ -59,1 +61,3 @@\n-            initializeNetwork();\n+            port = curPort;\n+            shutdownServer();\n+            startServer();\n@@ -63,3 +67,3 @@\n-    private void initializeNetwork() {\n-        int curPort = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n-        this.port = curPort;\n+    public void startServer() {\n+        isServerRunning = true;\n+\n@@ -68,4 +72,3 @@\n-            serverSocket.bind(new InetSocketAddress(curPort));\n-        } catch (Throwable ex) {\n-            NotifyDescriptor message = new NotifyDescriptor.Message(\"Could not create server. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n-            DialogDisplayer.getDefault().notifyLater(message);\n+            serverSocket.bind(new InetSocketAddress(port));\n+        } catch (IOException ex) {\n+            ex.printStackTrace();\n@@ -75,16 +78,6 @@\n-        Runnable runnable = new Runnable() {\n-\n-            @Override\n-            public void run() {\n-                while (true) {\n-                    try {\n-                        SocketChannel clientSocket = serverSocket.accept();\n-                        if (serverRunnable != this) {\n-                            clientSocket.close();\n-                            return;\n-                        }\n-                        RequestProcessor.getDefault().post(new Client(clientSocket, callback), 0, Thread.MAX_PRIORITY);\n-                    } catch (IOException ex) {\n-                        serverSocket = null;\n-                        NotifyDescriptor message = new NotifyDescriptor.Message(\"Error during listening for incoming connections. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n-                        DialogDisplayer.getDefault().notifyLater(message);\n+        Runnable client = () -> {\n+            while (isServerRunning) {\n+                try {\n+                    SocketChannel clientSocket = serverSocket.accept();\n+                    if (!isServerRunning) {\n+                        clientSocket.close();\n@@ -93,0 +86,12 @@\n+                    new Thread(() -> {\n+                        try (clientSocket) {\n+                            clientSocket.configureBlocking(true);\n+                            clientSocket.socket().getOutputStream().write('y');\n+                            new Parser(clientSocket, null, graphDocument, contextAction).parse();\n+                        } catch (IOException ignored) {}\n+                    }).start();\n+                } catch (IOException ex) {\n+                    if (isServerRunning) {\n+                        ex.printStackTrace();\n+                    }\n+                    return;\n@@ -95,0 +100,7 @@\n+            try {\n+                if (serverSocket != null) {\n+                    serverSocket.close();\n+                }\n+            } catch (IOException ex) {\n+                ex.printStackTrace();\n+            }\n@@ -97,1 +109,2 @@\n-        serverRunnable = runnable;\n+        new Thread(client).start();\n+    }\n@@ -99,1 +112,9 @@\n-        RequestProcessor.getDefault().post(runnable, 0, Thread.MAX_PRIORITY);\n+    public void shutdownServer() {\n+        isServerRunning = false;\n+        try {\n+            if (serverSocket != null) {\n+                serverSocket.close();\n+            }\n+        } catch (IOException ex) {\n+            ex.printStackTrace();\n+        }\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Server.java","additions":57,"deletions":36,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -655,1 +655,1 @@\n-                            centerRectangle(new Rectangle(location.x, location.y, bounds.width, bounds.height));\n+                            centerRectangle(new Rectangle(location.x, location.y, bounds.width, bounds.height), false);\n@@ -875,1 +875,1 @@\n-            centerRectangle(bw.getBounds());\n+            centerRectangle(bw.getBounds(), true);\n@@ -922,1 +922,1 @@\n-            centerRectangle(overallRect);\n+            centerRectangle(overallRect, true);\n@@ -926,1 +926,1 @@\n-    private void centerRectangle(Rectangle r) {\n+    private void centerRectangle(Rectangle r, boolean zoomToFit) {\n@@ -929,12 +929,13 @@\n-\n-        double factor = Math.min(viewRect.getWidth() \/ rect.getWidth(),  viewRect.getHeight() \/ rect.getHeight());\n-        double zoomFactor = getZoomFactor();\n-        double newZoomFactor = zoomFactor * factor;\n-        if (factor < 1.0 || zoomFactor < 1.0) {\n-            newZoomFactor = Math.min(1.0, newZoomFactor);\n-            centredZoom(newZoomFactor, null);\n-            factor = newZoomFactor \/ zoomFactor;\n-            rect.x *= factor;\n-            rect.y *= factor;\n-            rect.width *= factor;\n-            rect.height *= factor;\n+        if (zoomToFit) {\n+            double factor = Math.min(viewRect.getWidth() \/ rect.getWidth(),  viewRect.getHeight() \/ rect.getHeight());\n+            double zoomFactor = getZoomFactor();\n+            double newZoomFactor = zoomFactor * factor;\n+            if (factor < 1.0 || zoomFactor < 1.0) {\n+                newZoomFactor = Math.min(1.0, newZoomFactor);\n+                centredZoom(newZoomFactor, null);\n+                factor = newZoomFactor \/ zoomFactor;\n+                rect.x *= factor;\n+                rect.y *= factor;\n+                rect.width *= factor;\n+                rect.height *= factor;\n+            }\n@@ -942,0 +943,1 @@\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -335,0 +335,8 @@\n+\n+\n+    }\n+\n+    public Set<Integer> getVisibleNodes() {\n+        final Set<Integer> visibleNodes = new HashSet<>(getGraph().getNodesAsSet());\n+        visibleNodes.removeAll(hiddenNodes);\n+        return visibleNodes;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,2 +128,1 @@\n-        if (group.getParent() instanceof GraphDocument) {\n-            final GraphDocument doc = (GraphDocument) group.getParent();\n+        if (group.getParent() instanceof GraphDocument doc) {\n@@ -312,2 +311,1 @@\n-                if (t instanceof EditorTopComponent) {\n-                    EditorTopComponent etc = (EditorTopComponent) t;\n+                if (t instanceof EditorTopComponent etc) {\n@@ -323,0 +321,12 @@\n+    public static void closeAllInstances() {\n+        WindowManager manager = WindowManager.getDefault();\n+        for (Mode mode : manager.getModes()) {\n+            TopComponent[] openedTopComponents = manager.getOpenedTopComponents(mode);\n+            for (TopComponent tc : openedTopComponents) {\n+                if (tc instanceof EditorTopComponent etc) {\n+                    etc.close();\n+                }\n+            }\n+        }\n+    }\n+\n@@ -329,5 +339,7 @@\n-        Group group = getModel().getGroup();\n-        if (!group.getParent().getElements().contains(group) ||\n-            group.getGraphs().isEmpty()) {\n-            close();\n-        }\n+        SwingUtilities.invokeLater(() -> {\n+            Group group = getModel().getGroup();\n+            if (!group.getParent().getElements().contains(group) ||\n+                    group.getGraphs().isEmpty()) {\n+                close();\n+            }\n+        });\n@@ -408,2 +420,1 @@\n-                if (topComponent instanceof EditorTopComponent) {\n-                    EditorTopComponent editor = (EditorTopComponent) topComponent;\n+                if (topComponent instanceof EditorTopComponent editor) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import com.sun.hotspot.igv.graph.Diagram;\n-import com.sun.hotspot.igv.settings.Settings;\n@@ -41,1 +39,1 @@\n-    public void viewDifference(InputGraph firstGraph, InputGraph secondGraph) {\n+    public InputGraph viewDifference(InputGraph firstGraph, InputGraph secondGraph) {\n@@ -44,1 +42,1 @@\n-            view(diffGraph, true);\n+            return view(diffGraph, true);\n@@ -46,5 +44,7 @@\n-            view(firstGraph, true);\n-            EditorTopComponent etc = EditorTopComponent.findEditorForGraph(firstGraph);\n-            if (etc != null) {\n-                etc.getModel().selectDiffGraph(secondGraph);\n-                etc.requestActive();\n+            if (view(firstGraph, true) != null) {\n+                EditorTopComponent etc = EditorTopComponent.findEditorForGraph(firstGraph);\n+                if (etc != null) {\n+                    etc.getModel().selectDiffGraph(secondGraph);\n+                    etc.requestActive();\n+                    return etc.getModel().getGraph();\n+                }\n@@ -52,0 +52,1 @@\n+            return null;\n@@ -56,1 +57,1 @@\n-    public void view(InputGraph graph, boolean newTab) {\n+    public InputGraph view(InputGraph graph, boolean newTab) {\n@@ -62,1 +63,1 @@\n-                return;\n+                return etc.getModel().getGraph();\n@@ -69,0 +70,1 @@\n+        return etc.getModel().getGraph();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/GraphViewerImplementation.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -118,5 +118,0 @@\n-        <dependency>\n-            <groupId>${project.groupId}<\/groupId>\n-            <artifactId>ControlFlow<\/artifactId>\n-            <version>${project.version}<\/version>\n-        <\/dependency>\n","filename":"src\/utils\/IdealGraphVisualizer\/application\/pom.xml","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-        <module>ControlFlow<\/module>\n","filename":"src\/utils\/IdealGraphVisualizer\/pom.xml","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-TEST_VM(FreeRegionList, length) {\n+TEST_OTHER_VM(FreeRegionList, length) {\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-TEST_VM(HeapRegion, apply_to_marked_object) {\n+TEST_OTHER_VM(HeapRegion, apply_to_marked_object) {\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_heapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef _WINDOWS\n+\n+#include \"gc\/z\/zAddress.inline.hpp\"\n+#include \"gc\/z\/zGlobals.hpp\"\n+#include \"gc\/z\/zList.inline.hpp\"\n+#include \"gc\/z\/zMemory.inline.hpp\"\n+#include \"gc\/z\/zSyscall_windows.hpp\"\n+#include \"gc\/z\/zVirtualMemory.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+using namespace testing;\n+\n+#define EXPECT_ALLOC_OK(offset) EXPECT_NE(offset, zoffset(UINTPTR_MAX))\n+\n+class ZMapperTest : public Test {\n+private:\n+  static constexpr size_t ZMapperTestReservationSize = 32 * M;\n+\n+  static bool            _initialized;\n+  static ZMemoryManager* _va;\n+\n+  ZVirtualMemoryManager* _vmm;\n+\n+public:\n+  bool reserve_for_test() {\n+    \/\/ Initialize platform specific parts before reserving address space\n+    _vmm->pd_initialize_before_reserve();\n+\n+    \/\/ Reserve address space\n+    if (!_vmm->pd_reserve(ZOffset::address_unsafe(zoffset(0)), ZMapperTestReservationSize)) {\n+      return false;\n+    }\n+\n+    \/\/ Make the address range free before setting up callbacks below\n+    _va->free(zoffset(0), ZMapperTestReservationSize);\n+\n+    \/\/ Initialize platform specific parts after reserving address space\n+    _vmm->pd_initialize_after_reserve();\n+\n+    return true;\n+  }\n+\n+  virtual void SetUp() {\n+    ZSyscall::initialize();\n+    ZGlobalsPointers::initialize();\n+\n+    \/\/ Fake a ZVirtualMemoryManager\n+    _vmm = (ZVirtualMemoryManager*)os::malloc(sizeof(ZVirtualMemoryManager), mtTest);\n+\n+    \/\/ Construct its internal ZMemoryManager\n+    _va = new (&_vmm->_manager) ZMemoryManager();\n+\n+    \/\/ Reserve address space for the test\n+    if (!reserve_for_test()) {\n+      \/\/ Failed to reserve address space\n+      GTEST_SKIP();\n+      return;\n+    }\n+\n+    _initialized = true;\n+  }\n+\n+  virtual void TearDown() {\n+    if (_initialized) {\n+      _vmm->pd_unreserve(ZOffset::address_unsafe(zoffset(0)), 0);\n+    }\n+    os::free(_vmm);\n+  }\n+\n+  static void test_alloc_low_address() {\n+    \/\/ Verify that we get placeholder for first granule\n+    zoffset bottom = _va->alloc_low_address(ZGranuleSize);\n+    EXPECT_ALLOC_OK(bottom);\n+\n+    _va->free(bottom, ZGranuleSize);\n+\n+    \/\/ Alloc something larger than a granule and free it\n+    bottom = _va->alloc_low_address(ZGranuleSize * 3);\n+    EXPECT_ALLOC_OK(bottom);\n+\n+    _va->free(bottom, ZGranuleSize * 3);\n+\n+    \/\/ Free with more memory allocated\n+    bottom = _va->alloc_low_address(ZGranuleSize);\n+    EXPECT_ALLOC_OK(bottom);\n+\n+    zoffset next = _va->alloc_low_address(ZGranuleSize);\n+    EXPECT_ALLOC_OK(next);\n+\n+    _va->free(bottom, ZGranuleSize);\n+    _va->free(next, ZGranuleSize);\n+  }\n+\n+  static void test_alloc_high_address() {\n+    \/\/ Verify that we get placeholder for last granule\n+    zoffset high = _va->alloc_high_address(ZGranuleSize);\n+    EXPECT_ALLOC_OK(high);\n+\n+    zoffset prev = _va->alloc_high_address(ZGranuleSize);\n+    EXPECT_ALLOC_OK(prev);\n+\n+    _va->free(high, ZGranuleSize);\n+    _va->free(prev, ZGranuleSize);\n+\n+    \/\/ Alloc something larger than a granule and return it\n+    high = _va->alloc_high_address(ZGranuleSize * 2);\n+    EXPECT_ALLOC_OK(high);\n+\n+    _va->free(high, ZGranuleSize * 2);\n+  }\n+\n+  static void test_alloc_whole_area() {\n+    \/\/ Alloc the whole reservation\n+    zoffset bottom = _va->alloc_low_address(ZMapperTestReservationSize);\n+    EXPECT_ALLOC_OK(bottom);\n+\n+    \/\/ Free two chunks and then allocate them again\n+    _va->free(bottom, ZGranuleSize * 4);\n+    _va->free(bottom + ZGranuleSize * 6, ZGranuleSize * 6);\n+\n+    zoffset offset = _va->alloc_low_address(ZGranuleSize * 4);\n+    EXPECT_ALLOC_OK(offset);\n+\n+    offset = _va->alloc_low_address(ZGranuleSize * 6);\n+    EXPECT_ALLOC_OK(offset);\n+\n+    \/\/ Now free it all, and verify it can be re-allocated\n+    _va->free(bottom, ZMapperTestReservationSize);\n+\n+    bottom = _va->alloc_low_address(ZMapperTestReservationSize);\n+    EXPECT_ALLOC_OK(bottom);\n+\n+    _va->free(bottom, ZMapperTestReservationSize);\n+  }\n+};\n+\n+bool ZMapperTest::_initialized   = false;\n+ZMemoryManager* ZMapperTest::_va = nullptr;\n+\n+TEST_VM_F(ZMapperTest, test_alloc_low_address) {\n+  test_alloc_low_address();\n+}\n+\n+TEST_VM_F(ZMapperTest, test_alloc_high_address) {\n+  test_alloc_high_address();\n+}\n+\n+TEST_VM_F(ZMapperTest, test_alloc_whole_area) {\n+  test_alloc_whole_area();\n+}\n+\n+#endif \/\/ _WINDOWS\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zMapper_windows.cpp","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -140,0 +140,1 @@\n+serviceability\/jvmti\/vthread\/GetThreadStateMountedTest\/GetThreadStateMountedTest.java 8318090,8318729 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -136,1 +137,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n@@ -138,1 +138,1 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n@@ -140,1 +140,1 @@\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/Test7068051.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,1299 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8318446 8331054\n+ * @summary Test merging of consecutive stores\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main compiler.c2.TestMergeStores aligned\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318446 8331054\n+ * @summary Test merging of consecutive stores\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main compiler.c2.TestMergeStores unaligned\n+ *\/\n+\n+public class TestMergeStores {\n+    static int RANGE = 1000;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/\/ Inputs\n+    byte[] aB = new byte[RANGE];\n+    byte[] bB = new byte[RANGE];\n+    short[] aS = new short[RANGE];\n+    short[] bS = new short[RANGE];\n+    int[] aI = new int[RANGE];\n+    int[] bI = new int[RANGE];\n+    long[] aL = new long[RANGE];\n+    long[] bL = new long[RANGE];\n+\n+    int offset1;\n+    int offset2;\n+    byte vB1;\n+    byte vB2;\n+    short vS1;\n+    short vS2;\n+    int vI1;\n+    int vI2;\n+    long vL1;\n+    long vL2;\n+\n+    interface TestFunction {\n+        Object[] run(boolean isWarmUp, int rnd);\n+    }\n+\n+    Map<String, Map<String, TestFunction>> testGroups = new HashMap<String, Map<String, TestFunction>>();\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMergeStores.class);\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+\n+        switch (args[0]) {\n+            case \"aligned\"     -> { framework.addFlags(\"-XX:-UseUnalignedAccesses\"); }\n+            case \"unaligned\"   -> { framework.addFlags(\"-XX:+UseUnalignedAccesses\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        }\n+        framework.start();\n+    }\n+\n+    public TestMergeStores() {\n+        testGroups.put(\"test1\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test1\").put(\"test1R\", (_,_) -> { return test1R(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1a\", (_,_) -> { return test1a(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1b\", (_,_) -> { return test1b(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1c\", (_,_) -> { return test1c(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1d\", (_,_) -> { return test1d(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1e\", (_,_) -> { return test1e(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1f\", (_,_) -> { return test1f(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1g\", (_,_) -> { return test1g(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1h\", (_,_) -> { return test1h(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1i\", (_,_) -> { return test1i(aB.clone()); });\n+\n+        testGroups.put(\"test2\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test2\").put(\"test2R\", (_,_) -> { return test2R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2a\", (_,_) -> { return test2a(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2b\", (_,_) -> { return test2b(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2c\", (_,_) -> { return test2c(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2d\", (_,_) -> { return test2d(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2e\", (_,_) -> { return test2d(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test3\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test3\").put(\"test3R\", (_,_) -> { return test3R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test3\").put(\"test3a\", (_,_) -> { return test3a(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test4\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test4\").put(\"test4R\", (_,_) -> { return test4R(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n+        testGroups.get(\"test4\").put(\"test4a\", (_,_) -> { return test4a(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n+\n+        testGroups.put(\"test5\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test5\").put(\"test5R\", (_,_) -> { return test5R(aB.clone(), offset1); });\n+        testGroups.get(\"test5\").put(\"test5a\", (_,_) -> { return test5a(aB.clone(), offset1); });\n+\n+        testGroups.put(\"test6\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test6\").put(\"test6R\", (_,_) -> { return test6R(aB.clone(), bB.clone(), offset1, offset2); });\n+        testGroups.get(\"test6\").put(\"test6a\", (_,_) -> { return test6a(aB.clone(), bB.clone(), offset1, offset2); });\n+\n+        testGroups.put(\"test7\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test7\").put(\"test7R\", (_,_) -> { return test7R(aB.clone(), offset1, vI1); });\n+        testGroups.get(\"test7\").put(\"test7a\", (_,_) -> { return test7a(aB.clone(), offset1, vI1); });\n+\n+        testGroups.put(\"test100\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test100\").put(\"test100R\", (_,_) -> { return test100R(aS.clone(), offset1); });\n+        testGroups.get(\"test100\").put(\"test100a\", (_,_) -> { return test100a(aS.clone(), offset1); });\n+\n+        testGroups.put(\"test101\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test101\").put(\"test101R\", (_,_) -> { return test101R(aS.clone(), offset1); });\n+        testGroups.get(\"test101\").put(\"test101a\", (_,_) -> { return test101a(aS.clone(), offset1); });\n+\n+        testGroups.put(\"test102\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test102\").put(\"test102R\", (_,_) -> { return test102R(aS.clone(), offset1, vL1, vI1, vS1); });\n+        testGroups.get(\"test102\").put(\"test102a\", (_,_) -> { return test102a(aS.clone(), offset1, vL1, vI1, vS1); });\n+\n+        testGroups.put(\"test200\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test200\").put(\"test200R\", (_,_) -> { return test200R(aI.clone(), offset1); });\n+        testGroups.get(\"test200\").put(\"test200a\", (_,_) -> { return test200a(aI.clone(), offset1); });\n+\n+        testGroups.put(\"test201\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test201\").put(\"test201R\", (_,_) -> { return test201R(aI.clone(), offset1); });\n+        testGroups.get(\"test201\").put(\"test201a\", (_,_) -> { return test201a(aI.clone(), offset1); });\n+\n+        testGroups.put(\"test202\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test202\").put(\"test202R\", (_,_) -> { return test202R(aI.clone(), offset1, vL1, vI1); });\n+        testGroups.get(\"test202\").put(\"test202a\", (_,_) -> { return test202a(aI.clone(), offset1, vL1, vI1); });\n+\n+        testGroups.put(\"test300\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test300\").put(\"test300R\", (_,_) -> { return test300R(aI.clone()); });\n+        testGroups.get(\"test300\").put(\"test300a\", (_,_) -> { return test300a(aI.clone()); });\n+\n+        testGroups.put(\"test400\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test400\").put(\"test400R\", (_,_) -> { return test400R(aI.clone()); });\n+        testGroups.get(\"test400\").put(\"test400a\", (_,_) -> { return test400a(aI.clone()); });\n+\n+        testGroups.put(\"test500\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test500\").put(\"test500R\", (_,_) -> { return test500R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test500\").put(\"test500a\", (_,_) -> { return test500a(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test501\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test501\").put(\"test500R\", (_,i) -> { return test500R(aB.clone(), RANGE - 20 + (i % 30), vL1); });\n+        testGroups.get(\"test501\").put(\"test501a\", (_,i) -> { return test501a(aB.clone(), RANGE - 20 + (i % 30), vL1); });\n+        \/\/                                                                               +-------------------+\n+        \/\/ Create offsets that are sometimes going to pass all RangeChecks, and sometimes one, and sometimes none.\n+        \/\/ Consequence: all RangeChecks stay in the final compilation.\n+\n+        testGroups.put(\"test502\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test502\").put(\"test500R\", (w,i) -> { return test500R(aB.clone(), w ? offset1 : RANGE - 20 + (i % 30), vL1); });\n+        testGroups.get(\"test502\").put(\"test502a\", (w,i) -> { return test502a(aB.clone(), w ? offset1 : RANGE - 20 + (i % 30), vL1); });\n+        \/\/                                                                                   +-----+   +-------------------+\n+        \/\/ First use something in range, and after warmup randomize going outside the range.\n+        \/\/ Consequence: all RangeChecks stay in the final compilation.\n+\n+        testGroups.put(\"test600\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test600\").put(\"test600R\", (_,i) -> { return test600R(aB.clone(), aI.clone(), i); });\n+        testGroups.get(\"test600\").put(\"test600a\", (_,i) -> { return test600a(aB.clone(), aI.clone(), i); });\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"test1a\",\n+                 \"test1b\",\n+                 \"test1c\",\n+                 \"test1d\",\n+                 \"test1e\",\n+                 \"test1f\",\n+                 \"test1g\",\n+                 \"test1h\",\n+                 \"test1i\",\n+                 \"test2a\",\n+                 \"test2b\",\n+                 \"test2c\",\n+                 \"test2d\",\n+                 \"test2e\",\n+                 \"test3a\",\n+                 \"test4a\",\n+                 \"test5a\",\n+                 \"test6a\",\n+                 \"test7a\",\n+                 \"test100a\",\n+                 \"test101a\",\n+                 \"test102a\",\n+                 \"test200a\",\n+                 \"test201a\",\n+                 \"test202a\",\n+                 \"test300a\",\n+                 \"test400a\",\n+                 \"test500a\",\n+                 \"test501a\",\n+                 \"test502a\",\n+                 \"test600a\"})\n+    public void runTests(RunInfo info) {\n+        \/\/ Repeat many times, so that we also have multiple iterations for post-warmup to potentially recompile\n+        int iters = info.isWarmUp() ? 1_000 : 50_000;\n+        for (int iter = 0; iter < iters; iter++) {\n+            \/\/ Write random values to inputs\n+            set_random(aB);\n+            set_random(bB);\n+            set_random(aS);\n+            set_random(bS);\n+            set_random(aI);\n+            set_random(bI);\n+            set_random(aL);\n+            set_random(bL);\n+\n+            offset1 = Math.abs(RANDOM.nextInt()) % 100;\n+            offset2 = Math.abs(RANDOM.nextInt()) % 100;\n+            vB1 = (byte)RANDOM.nextInt();\n+            vB2 = (byte)RANDOM.nextInt();\n+            vS1 = (short)RANDOM.nextInt();\n+            vS2 = (short)RANDOM.nextInt();\n+            vI1 = RANDOM.nextInt();\n+            vI2 = RANDOM.nextInt();\n+            vL1 = RANDOM.nextLong();\n+            vL2 = RANDOM.nextLong();\n+\n+            \/\/ Run all tests\n+            for (Map.Entry<String, Map<String,TestFunction>> group_entry : testGroups.entrySet()) {\n+                String group_name = group_entry.getKey();\n+                Map<String, TestFunction> group = group_entry.getValue();\n+                Object[] gold = null;\n+                String gold_name = \"NONE\";\n+                for (Map.Entry<String,TestFunction> entry : group.entrySet()) {\n+                    String name = entry.getKey();\n+                    TestFunction test = entry.getValue();\n+                    Object[] result = test.run(info.isWarmUp(), iter);\n+                    if (gold == null) {\n+                        gold = result;\n+                        gold_name = name;\n+                    } else {\n+                        verify(\"group \" + group_name + \", gold \" + gold_name + \", test \" + name, gold, result);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" = \" + String.format(\"%02X\", g[j] & 0xFF) +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j] +\n+                                           \" = \" + String.format(\"%02X\", r[j] & 0xFF));\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void set_random(byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)RANDOM.nextInt();\n+        }\n+    }\n+\n+    static void set_random(short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)RANDOM.nextInt();\n+        }\n+    }\n+\n+    static void set_random(int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n+    static void set_random(long[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+    }\n+\n+    \/\/ -------------------------------------------\n+    \/\/ -------     Little-Endian API    ----------\n+    \/\/ -------------------------------------------\n+    \/\/ Note: I had to add @ForceInline because otherwise it would sometimes\n+    \/\/       not inline nested method calls.\n+\n+    \/\/ Store a short LE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeShortLE(byte[] bytes, int offset, short value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0),\n+                                  (byte)(value >> 8));\n+    }\n+\n+    \/\/ Store an int LE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeIntLE(byte[] bytes, int offset, int value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0 ),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 24));\n+    }\n+\n+    \/\/ Store an int LE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeLongLE(byte[] bytes, int offset, long value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0 ),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 24),\n+                                  (byte)(value >> 32),\n+                                  (byte)(value >> 40),\n+                                  (byte)(value >> 48),\n+                                  (byte)(value >> 56));\n+    }\n+\n+    \/\/ Store 2 bytes into an array\n+    @ForceInline\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+    }\n+\n+    \/\/ Store 4 bytes into an array\n+    @ForceInline\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1, byte b2, byte b3) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+        bytes[offset + 2] = b2;\n+        bytes[offset + 3] = b3;\n+    }\n+\n+    \/\/ Store 8 bytes into an array\n+    @ForceInline\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1, byte b2, byte b3,\n+                                                     byte b4, byte b5, byte b6, byte b7) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+        bytes[offset + 2] = b2;\n+        bytes[offset + 3] = b3;\n+        bytes[offset + 4] = b4;\n+        bytes[offset + 5] = b5;\n+        bytes[offset + 6] = b6;\n+        bytes[offset + 7] = b7;\n+    }\n+\n+    @DontCompile\n+    static Object[] test1R(byte[] a) {\n+        a[0] = (byte)0xbe;\n+        a[1] = (byte)0xba;\n+        a[2] = (byte)0xad;\n+        a[3] = (byte)0xba;\n+        a[4] = (byte)0xef;\n+        a[5] = (byte)0xbe;\n+        a[6] = (byte)0xad;\n+        a[7] = (byte)0xde;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test1a(byte[] a) {\n+        a[0] = (byte)0xbe;\n+        a[1] = (byte)0xba;\n+        a[2] = (byte)0xad;\n+        a[3] = (byte)0xba;\n+        a[4] = (byte)0xef;\n+        a[5] = (byte)0xbe;\n+        a[6] = (byte)0xad;\n+        a[7] = (byte)0xde;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test1b(byte[] a) {\n+        \/\/ Add custom null check, to ensure the unsafe access always recognizes its type as an array store\n+        if (a == null) {return null;}\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, 0xdeadbeefbaadbabeL);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test1c(byte[] a) {\n+        storeLongLE(a, 0, 0xdeadbeefbaadbabeL);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test1d(byte[] a) {\n+        storeIntLE(a, 0, 0xbaadbabe);\n+        storeIntLE(a, 4, 0xdeadbeef);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test1e(byte[] a) {\n+        storeShortLE(a, 0, (short)0xbabe);\n+        storeShortLE(a, 2, (short)0xbaad);\n+        storeShortLE(a, 4, (short)0xbeef);\n+        storeShortLE(a, 6, (short)0xdead);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test1f(byte[] a) {\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ Do not optimize these, just to be sure we do not mess with store ordering.\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test1g(byte[] a) {\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ Do not optimize these, just to be sure we do not mess with store ordering.\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test1h(byte[] a) {\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ Do not optimize these, just to be sure we do not mess with store ordering.\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test1i(byte[] a) {\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test2R(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 32);\n+        a[offset + 5] = (byte)(v >> 40);\n+        a[offset + 6] = (byte)(v >> 48);\n+        a[offset + 7] = (byte)(v >> 56);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test2a(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 32);\n+        a[offset + 5] = (byte)(v >> 40);\n+        a[offset + 6] = (byte)(v >> 48);\n+        a[offset + 7] = (byte)(v >> 56);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test2b(byte[] a, int offset, long v) {\n+        \/\/ Add custom null check, to ensure the unsafe access always recognizes its type as an array store\n+        if (a == null) {return null;}\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test2c(byte[] a, int offset, long v) {\n+        storeLongLE(a, offset, v);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ No optimization, casting long -> int -> byte does not work\n+    static Object[] test2d(byte[] a, int offset, long v) {\n+        storeIntLE(a, offset + 0, (int)(v >> 0));\n+        storeIntLE(a, offset + 4, (int)(v >> 32));\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ No optimization, casting long -> short -> byte does not work\n+    static Object[] test2e(byte[] a, int offset, long v) {\n+        storeShortLE(a, offset + 0, (short)(v >> 0));\n+        storeShortLE(a, offset + 2, (short)(v >> 16));\n+        storeShortLE(a, offset + 4, (short)(v >> 32));\n+        storeShortLE(a, offset + 6, (short)(v >> 48));\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test3R(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 0);\n+        a[offset + 5] = (byte)(v >> 8);\n+        a[offset + 6] = (byte)(v >> 16);\n+        a[offset + 7] = (byte)(v >> 24);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test3a(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 0);\n+        a[offset + 5] = (byte)(v >> 8);\n+        a[offset + 6] = (byte)(v >> 16);\n+        a[offset + 7] = (byte)(v >> 24);\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test4R(byte[] a, int offset, long v1, int v2, short v3, byte v4) {\n+        a[offset +  0] = (byte)0x00;\n+        a[offset +  1] = (byte)0xFF;\n+        a[offset +  2] = v4;\n+        a[offset +  3] = (byte)0x42;\n+        a[offset +  4] = (byte)(v1 >> 0);\n+        a[offset +  5] = (byte)(v1 >> 8);\n+        a[offset +  6] = (byte)0xAB;\n+        a[offset +  7] = (byte)0xCD;\n+        a[offset +  8] = (byte)0xEF;\n+        a[offset +  9] = (byte)0x01;\n+        a[offset + 10] = (byte)(v2 >> 0);\n+        a[offset + 11] = (byte)(v2 >> 8);\n+        a[offset + 12] = (byte)(v2 >> 16);\n+        a[offset + 13] = (byte)(v2 >> 24);\n+        a[offset + 14] = (byte)(v3 >> 0);\n+        a[offset + 15] = (byte)(v3 >> 8);\n+        a[offset + 16] = (byte)0xEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\", \/\/ 3 (+ 1 for uncommon trap)\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test4a(byte[] a, int offset, long v1, int v2, short v3, byte v4) {\n+        a[offset +  0] = (byte)0x00; \/\/ individual load expected to go into state of RC\n+        a[offset +  1] = (byte)0xFF;\n+        a[offset +  2] = v4;\n+        a[offset +  3] = (byte)0x42;\n+        a[offset +  4] = (byte)(v1 >> 0);\n+        a[offset +  5] = (byte)(v1 >> 8);\n+        a[offset +  6] = (byte)0xAB;\n+        a[offset +  7] = (byte)0xCD;\n+        a[offset +  8] = (byte)0xEF;\n+        a[offset +  9] = (byte)0x01;\n+        a[offset + 10] = (byte)(v2 >> 0);\n+        a[offset + 11] = (byte)(v2 >> 8);\n+        a[offset + 12] = (byte)(v2 >> 16);\n+        a[offset + 13] = (byte)(v2 >> 24);\n+        a[offset + 14] = (byte)(v3 >> 0);\n+        a[offset + 15] = (byte)(v3 >> 8);\n+        a[offset + 16] = (byte)0xEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test5R(byte[] a, int offset) {\n+        a[offset +  0] = (byte)0x01;\n+        a[offset +  1] = (byte)0x02;\n+        a[offset +  2] = (byte)0x03;\n+        a[offset +  3] = (byte)0x04;\n+        a[offset +  4] = (byte)0x11;\n+        a[offset +  5] = (byte)0x22;\n+        a[offset +  6] = (byte)0x33;\n+        a[offset +  7] = (byte)0x44;\n+        a[offset +  8] = (byte)0x55;\n+        a[offset +  9] = (byte)0x66;\n+        a[offset + 10] = (byte)0x77;\n+        a[offset + 11] = (byte)0xAA;\n+        a[offset + 12] = (byte)0xBB;\n+        a[offset + 13] = (byte)0xCC;\n+        a[offset + 14] = (byte)0xDD;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test5a(byte[] a, int offset) {\n+        a[offset +  0] = (byte)0x01;\n+        a[offset +  1] = (byte)0x02;\n+        a[offset +  2] = (byte)0x03;\n+        a[offset +  3] = (byte)0x04;\n+        a[offset +  4] = (byte)0x11;\n+        a[offset +  5] = (byte)0x22;\n+        a[offset +  6] = (byte)0x33;\n+        a[offset +  7] = (byte)0x44;\n+        a[offset +  8] = (byte)0x55;\n+        a[offset +  9] = (byte)0x66;\n+        a[offset + 10] = (byte)0x77;\n+        a[offset + 11] = (byte)0xAA;\n+        a[offset + 12] = (byte)0xBB;\n+        a[offset + 13] = (byte)0xCC;\n+        a[offset + 14] = (byte)0xDD;\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test6R(byte[] a, byte[] b, int offset1, int offset2) {\n+        a[offset1 +  1] = (byte)0x02;\n+        a[offset1 +  3] = (byte)0x04;\n+        b[offset1 +  4] = (byte)0x11;\n+        a[offset1 +  5] = (byte)0x22;\n+        a[offset2 +  6] = (byte)0x33;\n+        a[offset1 +  7] = (byte)0x44;\n+        b[offset1 +  8] = (byte)0x55;\n+        b[offset1 + 10] = (byte)0x66;\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test6a(byte[] a, byte[] b, int offset1, int offset2) {\n+        a[offset1 +  1] = (byte)0x02;\n+        a[offset1 +  3] = (byte)0x04;\n+        b[offset1 +  4] = (byte)0x11;\n+        a[offset1 +  5] = (byte)0x22;\n+        a[offset2 +  6] = (byte)0x33;\n+        a[offset1 +  7] = (byte)0x44;\n+        b[offset1 +  8] = (byte)0x55;\n+        b[offset1 + 10] = (byte)0x66;\n+        return new Object[]{ a, b };\n+    }\n+\n+    @DontCompile\n+    static Object[] test7R(byte[] a, int offset1, int v1) {\n+        a[offset1 +  1] = (byte)(v1 >> 8);\n+        a[offset1 +  2] = (byte)(v1 >> 16);\n+        a[offset1 +  3] = (byte)(v1 >> 24);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test7a(byte[] a, int offset1, int v1) {\n+        a[offset1 +  1] = (byte)(v1 >> 8);\n+        a[offset1 +  2] = (byte)(v1 >> 16);\n+        a[offset1 +  3] = (byte)(v1 >> 24);\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test100R(short[] a, int offset) {\n+        a[offset +  0] = (short)0x0100;\n+        a[offset +  1] = (short)0x0200;\n+        a[offset +  2] = (short)0x0311;\n+        a[offset +  3] = (short)0x0400;\n+        a[offset +  4] = (short)0x1100;\n+        a[offset +  5] = (short)0x2233;\n+        a[offset +  6] = (short)0x3300;\n+        a[offset +  7] = (short)0x4400;\n+        a[offset +  8] = (short)0x5599;\n+        a[offset +  9] = (short)0x6600;\n+        a[offset + 10] = (short)0x7700;\n+        a[offset + 11] = (short)0xAACC;\n+        a[offset + 12] = (short)0xBB00;\n+        a[offset + 13] = (short)0xCC00;\n+        a[offset + 14] = (short)0xDDFF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test100a(short[] a, int offset) {\n+        a[offset +  0] = (short)0x0100; \/\/ stays unchanged -> both used for RC and Return path\n+        a[offset +  1] = (short)0x0200; \/\/    I\n+        a[offset +  2] = (short)0x0311; \/\/    I\n+        a[offset +  3] = (short)0x0400; \/\/   L\n+        a[offset +  4] = (short)0x1100; \/\/   L\n+        a[offset +  5] = (short)0x2233; \/\/   L\n+        a[offset +  6] = (short)0x3300; \/\/   L\n+        a[offset +  7] = (short)0x4400; \/\/  L\n+        a[offset +  8] = (short)0x5599; \/\/  L\n+        a[offset +  9] = (short)0x6600; \/\/  L\n+        a[offset + 10] = (short)0x7700; \/\/  L\n+        a[offset + 11] = (short)0xAACC; \/\/ L\n+        a[offset + 12] = (short)0xBB00; \/\/ L\n+        a[offset + 13] = (short)0xCC00; \/\/ L\n+        a[offset + 14] = (short)0xDDFF; \/\/ L\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test101R(short[] a, int offset) {\n+        a[offset +  0] = (short)0x0100;\n+        a[offset +  1] = (short)0x0200;\n+        a[offset +  2] = (short)0x0311;\n+        a[offset +  3] = (short)0x0400;\n+        a[offset +  4] = (short)0x1100;\n+        a[offset +  5] = (short)0x2233;\n+        a[offset +  6] = (short)0x3300;\n+        a[offset +  7] = (short)0x4400;\n+        a[offset +  8] = (short)0x5599;\n+        a[offset +  9] = (short)0x6600;\n+        a[offset + 10] = (short)0x7700;\n+        a[offset + 11] = (short)0xAACC;\n+        a[offset + 12] = (short)0xBB00;\n+        a[offset + 13] = (short)0xCC00;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ only for RC\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test101a(short[] a, int offset) {\n+        a[offset +  0] = (short)0x0100; \/\/    I plus kept unchanged for RC\n+        a[offset +  1] = (short)0x0200; \/\/    I\n+        a[offset +  2] = (short)0x0311; \/\/   L\n+        a[offset +  3] = (short)0x0400; \/\/   L\n+        a[offset +  4] = (short)0x1100; \/\/   L\n+        a[offset +  5] = (short)0x2233; \/\/   L\n+        a[offset +  6] = (short)0x3300; \/\/  L\n+        a[offset +  7] = (short)0x4400; \/\/  L\n+        a[offset +  8] = (short)0x5599; \/\/  L\n+        a[offset +  9] = (short)0x6600; \/\/  L\n+        a[offset + 10] = (short)0x7700; \/\/ L\n+        a[offset + 11] = (short)0xAACC; \/\/ L\n+        a[offset + 12] = (short)0xBB00; \/\/ L\n+        a[offset + 13] = (short)0xCC00; \/\/ L\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test102R(short[] a, int offset, long v1, int v2, short v3) {\n+        a[offset +  0] = (short)0x0000;\n+        a[offset +  1] = (short)0xFFFF;\n+        a[offset +  2] = v3;\n+        a[offset +  3] = (short)0x4242;\n+        a[offset +  4] = (short)(v1 >>  0);\n+        a[offset +  5] = (short)(v1 >> 16);\n+        a[offset +  6] = (short)0xAB11;\n+        a[offset +  7] = (short)0xCD36;\n+        a[offset +  8] = (short)0xEF89;\n+        a[offset +  9] = (short)0x0156;\n+        a[offset + 10] = (short)(v1 >> 0);\n+        a[offset + 11] = (short)(v1 >> 16);\n+        a[offset + 12] = (short)(v1 >> 32);\n+        a[offset + 13] = (short)(v1 >> 48);\n+        a[offset + 14] = (short)(v2 >> 0);\n+        a[offset + 15] = (short)(v2 >> 16);\n+        a[offset + 16] = (short)0xEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\", \/\/ 3 (+1 that goes into RC)\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test102a(short[] a, int offset, long v1, int v2, short v3) {\n+        a[offset +  0] = (short)0x0000; \/\/ store goes into RC\n+        a[offset +  1] = (short)0xFFFF;\n+        a[offset +  2] = v3;\n+        a[offset +  3] = (short)0x4242;\n+        a[offset +  4] = (short)(v1 >>  0);\n+        a[offset +  5] = (short)(v1 >> 16);\n+        a[offset +  6] = (short)0xAB11;\n+        a[offset +  7] = (short)0xCD36;\n+        a[offset +  8] = (short)0xEF89;\n+        a[offset +  9] = (short)0x0156;\n+        a[offset + 10] = (short)(v1 >> 0);\n+        a[offset + 11] = (short)(v1 >> 16);\n+        a[offset + 12] = (short)(v1 >> 32);\n+        a[offset + 13] = (short)(v1 >> 48);\n+        a[offset + 14] = (short)(v2 >> 0);\n+        a[offset + 15] = (short)(v2 >> 16);\n+        a[offset + 16] = (short)0xEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test200R(int[] a, int offset) {\n+        a[offset +  0] = 0x01001236;\n+        a[offset +  1] = 0x02001284;\n+        a[offset +  2] = 0x03111235;\n+        a[offset +  3] = 0x04001294;\n+        a[offset +  4] = 0x11001234;\n+        a[offset +  5] = 0x22331332;\n+        a[offset +  6] = 0x33001234;\n+        a[offset +  7] = 0x44001432;\n+        a[offset +  8] = 0x55991234;\n+        a[offset +  9] = 0x66001233;\n+        a[offset + 10] = 0x77001434;\n+        a[offset + 11] = 0xAACC1234;\n+        a[offset + 12] = 0xBB001434;\n+        a[offset + 13] = 0xCC001236;\n+        a[offset + 14] = 0xDDFF1534;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test200a(int[] a, int offset) {\n+        a[offset +  0] = 0x01001236; \/\/ stays unchanged -> both used for RC and Return path\n+        a[offset +  1] = 0x02001284; \/\/       L\n+        a[offset +  2] = 0x03111235; \/\/       L\n+        a[offset +  3] = 0x04001294; \/\/      L\n+        a[offset +  4] = 0x11001234; \/\/      L\n+        a[offset +  5] = 0x22331332; \/\/     L\n+        a[offset +  6] = 0x33001234; \/\/     L\n+        a[offset +  7] = 0x44001432; \/\/    L\n+        a[offset +  8] = 0x55991234; \/\/    L\n+        a[offset +  9] = 0x66001233; \/\/   L\n+        a[offset + 10] = 0x77001434; \/\/   L\n+        a[offset + 11] = 0xAACC1234; \/\/  L\n+        a[offset + 12] = 0xBB001434; \/\/  L\n+        a[offset + 13] = 0xCC001236; \/\/ L\n+        a[offset + 14] = 0xDDFF1534; \/\/ L\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test201R(int[] a, int offset) {\n+        a[offset +  0] = 0x01001236;\n+        a[offset +  1] = 0x02001284;\n+        a[offset +  2] = 0x03111235;\n+        a[offset +  3] = 0x04001294;\n+        a[offset +  4] = 0x11001234;\n+        a[offset +  5] = 0x22331332;\n+        a[offset +  6] = 0x33001234;\n+        a[offset +  7] = 0x44001432;\n+        a[offset +  8] = 0x55991234;\n+        a[offset +  9] = 0x66001233;\n+        a[offset + 10] = 0x77001434;\n+        a[offset + 11] = 0xAACC1234;\n+        a[offset + 12] = 0xBB001434;\n+        a[offset + 13] = 0xCC001236;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ only for RC\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test201a(int[] a, int offset) {\n+        a[offset +  0] = 0x01001236; \/\/       L and also kept unchanged for RC\n+        a[offset +  1] = 0x02001284; \/\/       L\n+        a[offset +  2] = 0x03111235; \/\/      L\n+        a[offset +  3] = 0x04001294; \/\/      L\n+        a[offset +  4] = 0x11001234; \/\/     L\n+        a[offset +  5] = 0x22331332; \/\/     L\n+        a[offset +  6] = 0x33001234; \/\/    L\n+        a[offset +  7] = 0x44001432; \/\/    L\n+        a[offset +  8] = 0x55991234; \/\/   L\n+        a[offset +  9] = 0x66001233; \/\/   L\n+        a[offset + 10] = 0x77001434; \/\/  L\n+        a[offset + 11] = 0xAACC1234; \/\/  L\n+        a[offset + 12] = 0xBB001434; \/\/ L\n+        a[offset + 13] = 0xCC001236; \/\/ L\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test202R(int[] a, int offset, long v1, int v2) {\n+        a[offset +  0] = 0x00000000;\n+        a[offset +  1] = 0xFFFFFFFF;\n+        a[offset +  2] = v2;\n+        a[offset +  3] = 0x42424242;\n+        a[offset +  4] = (int)(v1 >>  0);\n+        a[offset +  5] = (int)(v1 >> 32);\n+        a[offset +  6] = 0xAB110129;\n+        a[offset +  7] = 0xCD360183;\n+        a[offset +  8] = 0xEF890173;\n+        a[offset +  9] = 0x01560124;\n+        a[offset + 10] = (int)(v1 >> 0);\n+        a[offset + 11] = (int)(v1 >> 32);\n+        a[offset + 12] = (int)(v1 >> 0);\n+        a[offset + 13] = (int)(v1 >> 32);\n+        a[offset + 14] = v2;\n+        a[offset + 15] = v2;\n+        a[offset + 16] = 0xEFEFEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\", \/\/ 5 (+1 that goes into RC)\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test202a(int[] a, int offset, long v1, int v2) {\n+        a[offset +  0] = 0x00000000; \/\/ merged with store below, but also kept unchanged for RC\n+        a[offset +  1] = 0xFFFFFFFF;\n+        a[offset +  2] = v2;\n+        a[offset +  3] = 0x42424242;\n+        a[offset +  4] = (int)(v1 >>  0);\n+        a[offset +  5] = (int)(v1 >> 32);\n+        a[offset +  6] = 0xAB110129;\n+        a[offset +  7] = 0xCD360183;\n+        a[offset +  8] = 0xEF890173;\n+        a[offset +  9] = 0x01560124;\n+        a[offset + 10] = (int)(v1 >> 0);\n+        a[offset + 11] = (int)(v1 >> 32);\n+        a[offset + 12] = (int)(v1 >> 0);\n+        a[offset + 13] = (int)(v1 >> 32);\n+        a[offset + 14] = v2;\n+        a[offset + 15] = v2;\n+        a[offset + 16] = 0xEFEFEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test300R(int[] a) {\n+        a[2] = 42;\n+        a[3] = 42;\n+        a[4] = 42;\n+        a[5] = 42;\n+        int x = a[3]; \/\/ dependent load\n+        return new Object[]{ a, new int[]{ x } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test300a(int[] a) {\n+        a[2] = 42;\n+        a[3] = 42;\n+        a[4] = 42;\n+        a[5] = 42;\n+        int x = a[3]; \/\/ dependent load\n+        return new Object[]{ a, new int[]{ x } };\n+    }\n+\n+    @DontCompile\n+    static Object[] test400R(int[] a) {\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ We must be careful with mismatched accesses on arrays:\n+    \/\/ An int-array can have about 2x max_int size, and hence if we address bytes in it, we can have int-overflows.\n+    \/\/ We might consider addresses (x + 0) and (x + 1) as adjacent, even if x = max_int, and therefore the second\n+    \/\/ address overflows and is not adjacent at all.\n+    \/\/ Therefore, we should only consider stores that have the same size as the element type of the array.\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\", \/\/ no merging\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test400a(int[] a) {\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    \/\/ The 500-series has all the same code, but is executed with different inputs:\n+    \/\/ 500a: never violate a RangeCheck -> expect will always merge stores\n+    \/\/ 501a: randomly violate RangeCheck, also during warmup -> never merge stores\n+    \/\/ 502a: during warmup never violate RangeCheck -> compile once with merged stores\n+    \/\/       but then after warmup violate RangeCheck -> recompile without merged stores\n+    static Object[] test500R(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ for RangeCheck trap\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"}, \/\/ expect merged\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test500a(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\", \/\/ No optimization because of too many RangeChecks\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test501a(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\", \/\/ No optimization because of too many RangeChecks\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test502a(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @DontCompile\n+    static Object[] test600R(byte[] aB, int[] aI, int i) {\n+        Object a = null;\n+        long base = 0;\n+        if (i % 2 == 0) {\n+            a = aB;\n+            base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+        } else {\n+            a = aI;\n+            base = UNSAFE.ARRAY_INT_BASE_OFFSET;\n+        }\n+        UNSAFE.putByte(a, base + 0, (byte)0xbe);\n+        UNSAFE.putByte(a, base + 1, (byte)0xba);\n+        UNSAFE.putByte(a, base + 2, (byte)0xad);\n+        UNSAFE.putByte(a, base + 3, (byte)0xba);\n+        UNSAFE.putByte(a, base + 4, (byte)0xef);\n+        UNSAFE.putByte(a, base + 5, (byte)0xbe);\n+        UNSAFE.putByte(a, base + 6, (byte)0xad);\n+        UNSAFE.putByte(a, base + 7, (byte)0xde);\n+        return new Object[]{ aB, aI };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"bottom\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\"}) \/\/ note: bottom type\n+    static Object[] test600a(byte[] aB, int[] aI, int i) {\n+        Object a = null;\n+        long base = 0;\n+        if (i % 2 == 0) {\n+            a = aB;\n+            base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+        } else {\n+            a = aI;\n+            base = UNSAFE.ARRAY_INT_BASE_OFFSET;\n+        }\n+        \/\/ array a is an aryptr, but its element type is unknown, i.e. bottom.\n+        UNSAFE.putByte(a, base + 0, (byte)0xbe);\n+        UNSAFE.putByte(a, base + 1, (byte)0xba);\n+        UNSAFE.putByte(a, base + 2, (byte)0xad);\n+        UNSAFE.putByte(a, base + 3, (byte)0xba);\n+        UNSAFE.putByte(a, base + 4, (byte)0xef);\n+        UNSAFE.putByte(a, base + 5, (byte)0xbe);\n+        UNSAFE.putByte(a, base + 6, (byte)0xad);\n+        UNSAFE.putByte(a, base + 7, (byte)0xde);\n+        return new Object[]{ aB, aI };\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":1299,"deletions":0,"binary":false,"changes":1299,"status":"added"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8300148\n+ * @summary Test barriers emitted in constructors\n+ * @library \/test\/lib \/\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @run main compiler.c2.irTests.ConstructorBarriers\n+ *\/\n+public class ConstructorBarriers {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    \/\/ Checks the barrier coalescing\/optimization around field initializations.\n+    \/\/ Uses long fields to avoid store merging.\n+\n+    public static class PlainPlain {\n+        long f1;\n+        long f2;\n+        public PlainPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalPlain {\n+        final long f1;\n+        long f2;\n+        public FinalPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainFinal {\n+        long f1;\n+        final long f2;\n+        public PlainFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalFinal {\n+        final long f1;\n+        final long f2;\n+        public FinalFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainVolatile {\n+        long f1;\n+        volatile long f2;\n+        public PlainVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatilePlain {\n+        volatile long f1;\n+        long f2;\n+        public VolatilePlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalVolatile {\n+        final long f1;\n+        volatile long f2;\n+        public FinalVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileFinal {\n+        volatile long f1;\n+        final long f2;\n+        public VolatileFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileVolatile {\n+        volatile long f1;\n+        volatile long f2;\n+        public VolatileVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    long l = 42;\n+\n+    @DontInline\n+    public void consume(Object o) {}\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_plainPlain() {\n+        PlainPlain c = new PlainPlain(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_plainFinal() {\n+        PlainFinal c = new PlainFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_finalPlain() {\n+        FinalPlain c = new FinalPlain(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_finalFinal() {\n+        FinalFinal c = new FinalFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_plainVolatile() {\n+        PlainVolatile c = new PlainVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_volatilePlain() {\n+        VolatilePlain c = new VolatilePlain(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"2\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"2\"})\n+    public long escaping_volatileVolatile() {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_finalVolatile() {\n+        FinalVolatile c = new FinalVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_volatileFinal() {\n+        VolatileFinal c = new VolatileFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_plainPlain() {\n+        PlainPlain c = new PlainPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_plainFinal() {\n+        PlainFinal c = new PlainFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_finalPlain() {\n+        FinalPlain c = new FinalPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_finalFinal() {\n+        FinalFinal c = new FinalFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"1\"})\n+    public long non_escaping_plainVolatile() {\n+        PlainVolatile c = new PlainVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"1\"})\n+    public long non_escaping_volatilePlain() {\n+        VolatilePlain c = new VolatilePlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"2\"})\n+    public long non_escaping_volatileVolatile() {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"1\"})\n+    public long non_escaping_finalVolatile() {\n+        FinalVolatile c = new FinalVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"1\"})\n+    public long non_escaping_volatileFinal() {\n+        VolatileFinal c = new VolatileFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Setup\n+    Object[] stringBuilderSetup() {\n+        return new Object[] { \"foo\", \"bar\", \"baz\" };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"stringBuilderSetup\")\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"3\"})\n+    public String stringBuilder(String s1, String s2, String s3) {\n+        return new StringBuilder().append(s1).append(s2).append(s3).toString();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConstructorBarriers.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8330163\n+ * @summary C2: improve CMoveNode::Value() when condition is always true or false\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestCMoveCCP\n+ *\/\n+\n+\n+public class TestCMoveCCP {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP })\n+    private static void test1() {\n+        int i = -1;\n+        testHelper1(i);\n+    }\n+\n+    @ForceInline\n+    private static void testHelper1(int i) {\n+        do {\n+            if (i != 1) {\n+                if (i < 0) { \/\/ Converted to CMoveI\n+                    i = 50;\n+                }\n+                volatileField = 42;\n+            }\n+            i *= 2;\n+            \/\/ i = 100 on first iteration when called from test1\n+        } while (i != 100);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(10000)\n+    private static void testRunner1() {\n+        test1();\n+        testHelper1(1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestCMoveCCP.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,554 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8324655 8329797\n+ * @key randomness\n+ * @summary Test that if expressions are properly folded into min\/max nodes\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestIfMinMax\n+ *\/\n+public class TestIfMinMax {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI1(int a, int b) {\n+        return a < b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI2(int a, int b) {\n+        return a > b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI1(int a, int b) {\n+        return a > b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI2(int a, int b) {\n+        return a < b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI1E(int a, int b) {\n+        return a <= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI2E(int a, int b) {\n+        return a >= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI1E(int a, int b) {\n+        return a >= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI2E(int a, int b) {\n+        return a <= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n+    public long testMinL1(long a, long b) {\n+        return a < b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n+    public long testMinL2(long a, long b) {\n+        return a > b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n+    public long testMaxL1(long a, long b) {\n+        return a > b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n+    public long testMaxL2(long a, long b) {\n+        return a < b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n+    public long testMinL1E(long a, long b) {\n+        return a <= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n+    public long testMinL2E(long a, long b) {\n+        return a >= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n+    public long testMaxL1E(long a, long b) {\n+        return a >= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n+    public long testMaxL2E(long a, long b) {\n+        return a <= b ? b : a;\n+    }\n+\n+    public class Dummy {\n+        long l;\n+        public Dummy(long l) { this.l = l; }\n+    }\n+\n+    @Setup\n+    Object[] setupDummyArray() {\n+        Dummy[] arr = new Dummy[512];\n+        for (int i = 0; i < 512; i++) {\n+            arr[i] = new Dummy(RANDOM.nextLong());\n+        }\n+        return new Object[] { arr };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setupDummyArray\")\n+    @IR(failOn = { IRNode.MAX_L })\n+    public long testMaxLAndBarrierInLoop(Dummy[] arr) {\n+        long result = 0;\n+        for (int i = 0; i < arr.length; ++i) {\n+            result += Math.max(arr[i].l, 1);\n+        }\n+        return result;\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setupDummyArray\")\n+    @IR(failOn = { IRNode.MIN_L })\n+    public long testMinLAndBarrierInLoop(Dummy[] arr) {\n+        long result = 0;\n+        for (int i = 0; i < arr.length; ++i) {\n+            result += Math.min(arr[i].l, 1);\n+        }\n+        return result;\n+    }\n+\n+    @Setup\n+    static Object[] setupIntArrays() {\n+        int[] a = new int[512];\n+        int[] b = new int[512];\n+\n+        \/\/ Fill from 1 to 50\n+        for (int i = 0; i < 50; i++) {\n+            a[i] = i + 1;\n+            b[i] = 1;\n+        }\n+\n+        \/\/ Fill from -1 to -50\n+        for (int i = 50; i < 100; i++) {\n+            a[i] = -(i - 49);\n+            b[i] = 1;\n+        }\n+\n+        for (int i = 100; i < 512; i++) {\n+            a[i] = RANDOM.nextInt();\n+            b[i] = 1;\n+        }\n+\n+        return new Object[] { a, b };\n+    }\n+\n+    @Setup\n+    static Object[] setupLongArrays() {\n+        long[] a = new long[512];\n+        long[] b = new long[512];\n+\n+        \/\/ Fill from 1 to 50\n+        for (int i = 0; i < 50; i++) {\n+            a[i] = i + 1;\n+            b[i] = 1;\n+        }\n+\n+        \/\/ Fill from -1 to -50\n+        for (int i = 50; i < 100; i++) {\n+            a[i] = -(i - 49);\n+            b[i] = 1;\n+        }\n+\n+        for (int i = 100; i < 512; i++) {\n+            a[i] = RANDOM.nextLong();\n+            b[i] = 1;\n+        }\n+\n+        return new Object[] { a, b };\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n+        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MAX_REDUCTION_V, \"> 0\" })\n+    @Arguments(setup = \"setupIntArrays\")\n+    public Object[] testMaxIntReduction(int[] a, int[] b) {\n+        int r = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i] * b[i];\n+\n+            r = aI > r ? aI : r;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMaxIntReduction\")\n+    public void checkTestMaxIntReduction(Object[] vals) {\n+        int[] a = (int[]) vals[0];\n+        int[] b = (int[]) vals[1];\n+        int testRet = (int) vals[2];\n+\n+        int r = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i] * b[i];\n+\n+            r = aI > r ? aI : r;\n+        }\n+\n+        if (r != testRet) {\n+            throw new IllegalStateException(\"Int max reduction test failed: expected \" + testRet + \" but got \" + r);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n+        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MIN_REDUCTION_V, \"> 0\" })\n+    @Arguments(setup = \"setupIntArrays\")\n+    public Object[] testMinIntReduction(int[] a, int[] b) {\n+        int r = 0;\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i] * b[i];\n+\n+            r = aI < r ? aI : r;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMinIntReduction\")\n+    public void checkTestMinIntReduction(Object[] vals) {\n+        int[] a = (int[]) vals[0];\n+        int[] b = (int[]) vals[1];\n+        int testRet = (int) vals[2];\n+\n+        int r = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i] * b[i];\n+\n+            r = aI < r ? aI : r;\n+        }\n+\n+        if (r != testRet) {\n+            throw new IllegalStateException(\"Int min reduction test failed: expected \" + testRet + \" but got \" + r);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\" },\n+        counts = { IRNode.MAX_REDUCTION_V, \"> 0\" })\n+    @Arguments(setup = \"setupLongArrays\")\n+    public Object[] testMaxLongReduction(long[] a, long[] b) {\n+        long r = 0;\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i] * b[i];\n+\n+            r = aI > r ? aI : r;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMaxLongReduction\")\n+    public void checkTestMaxLongReduction(Object[] vals) {\n+        long[] a = (long[]) vals[0];\n+        long[] b = (long[]) vals[1];\n+        long testRet = (long) vals[2];\n+\n+        long r = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i] * b[i];\n+\n+            r = aI > r ? aI : r;\n+        }\n+\n+        if (r != testRet) {\n+            throw new IllegalStateException(\"Long max reduction test failed: expected \" + testRet + \" but got \" + r);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\" },\n+        counts = { IRNode.MIN_REDUCTION_V, \"> 0\" })\n+    @Arguments(setup = \"setupLongArrays\")\n+    public Object[] testMinLongReduction(long[] a, long[] b) {\n+        long r = 0;\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i] * b[i];\n+\n+            r = aI < r ? aI : r;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMinLongReduction\")\n+    public void checkTestMinLongReduction(Object[] vals) {\n+        long[] a = (long[]) vals[0];\n+        long[] b = (long[]) vals[1];\n+        long testRet = (long) vals[2];\n+\n+        long r = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i] * b[i];\n+\n+            r = aI < r ? aI : r;\n+        }\n+\n+        if (r != testRet) {\n+            throw new IllegalStateException(\"Long min reduction test failed: expected \" + testRet + \" but got \" + r);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MAX_VI, \"> 0\" })\n+    @Arguments(setup = \"setupIntArrays\")\n+    public Object[] testMaxIntVector(int[] a, int[] b) {\n+        int[] r = new int[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i];\n+            int bI = b[i];\n+\n+            r[i] = aI > bI ? aI : bI;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMaxIntVector\")\n+    public void checkTestMaxIntVector(Object[] vals) {\n+        int[] a = (int[]) vals[0];\n+        int[] b = (int[]) vals[1];\n+        int[] testRet = (int[]) vals[2];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i];\n+            int bI = b[i];\n+\n+            int r = aI > bI ? aI : bI;\n+\n+            if (r != testRet[i]) {\n+                throw new IllegalStateException(\"Int max vectorization test failed: expected \" + testRet + \" but got \" + r);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MIN_VI, \"> 0\" })\n+    @Arguments(setup = \"setupIntArrays\")\n+    public Object[] testMinIntVector(int[] a, int[] b) {\n+        int[] r = new int[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i];\n+            int bI = b[i];\n+\n+            r[i] = aI < bI ? aI : bI;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMinIntVector\")\n+    public void checkTestMinIntVector(Object[] vals) {\n+        int[] a = (int[]) vals[0];\n+        int[] b = (int[]) vals[1];\n+        int[] testRet = (int[]) vals[2];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i];\n+            int bI = b[i];\n+\n+            int r = aI < bI ? aI : bI;\n+\n+            if (r != testRet[i]) {\n+                throw new IllegalStateException(\"Int min vectorization test failed: expected \" + testRet + \" but got \" + r);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MAX_VL, \"> 0\" })\n+    @Arguments(setup = \"setupLongArrays\")\n+    public Object[] testMaxLongVector(long[] a, long[] b) {\n+        long[] r = new long[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i];\n+            long bI = b[i];\n+\n+            r[i] = aI > bI ? aI : bI;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMaxLongVector\")\n+    public void checkTestMaxLongVector(Object[] vals) {\n+        long[] a = (long[]) vals[0];\n+        long[] b = (long[]) vals[1];\n+        long[] testRet = (long[]) vals[2];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i];\n+            long bI = b[i];\n+\n+            long r = aI > bI ? aI : bI;\n+\n+            if (r != testRet[i]) {\n+                throw new IllegalStateException(\"Long max vectorization test failed: expected \" + testRet + \" but got \" + r);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MIN_VL, \"> 0\" })\n+    @Arguments(setup = \"setupLongArrays\")\n+    public Object[] testMinLongVector(long[] a, long[] b) {\n+        long[] r = new long[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i];\n+            long bI = b[i];\n+\n+            r[i] = aI < bI ? aI : bI;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMinLongVector\")\n+    public void checkTestMinLongVector(Object[] vals) {\n+        long[] a = (long[]) vals[0];\n+        long[] b = (long[]) vals[1];\n+        long[] testRet = (long[]) vals[2];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i];\n+            long bI = b[i];\n+\n+            long r = aI < bI ? aI : bI;\n+\n+            if (r != testRet[i]) {\n+                throw new IllegalStateException(\"Long min vectorization test failed: expected \" + testRet + \" but got \" + r);\n+            }\n+        }\n+    }\n+\n+    @Run(test = { \"testMinI1\", \"testMinI2\", \"testMaxI1\", \"testMaxI2\", \"testMinI1E\", \"testMinI2E\", \"testMaxI1E\", \"testMaxI2E\" })\n+    public void runTestIntegers() {\n+        testIntegers(10, 20);\n+        testIntegers(20, 10);\n+        testIntegers(10, 10);\n+        testIntegers(Integer.MAX_VALUE, Integer.MIN_VALUE);\n+        testIntegers(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        testIntegers(RANDOM.nextInt(), RANDOM.nextInt());\n+    }\n+\n+    @DontCompile\n+    public void testIntegers(int a, int b) {\n+        Asserts.assertEQ(a < b ? a : b, testMinI1(a, b));\n+        Asserts.assertEQ(a > b ? b : a, testMinI2(a, b));\n+        Asserts.assertEQ(a > b ? a : b, testMaxI1(a, b));\n+        Asserts.assertEQ(a < b ? b : a, testMaxI2(a, b));\n+\n+        Asserts.assertEQ(a <= b ? a : b, testMinI1E(a, b));\n+        Asserts.assertEQ(a >= b ? b : a, testMinI2E(a, b));\n+        Asserts.assertEQ(a >= b ? a : b, testMaxI1E(a, b));\n+        Asserts.assertEQ(a <= b ? b : a, testMaxI2E(a, b));\n+    }\n+\n+    @Run(test = { \"testMinL1\", \"testMinL2\", \"testMaxL1\", \"testMaxL2\", \"testMinL1E\", \"testMinL2E\", \"testMaxL1E\", \"testMaxL2E\" })\n+    public void runTestLongs() {\n+        testLongs(10, 20);\n+        testLongs(20, 10);\n+        testLongs(10, 10);\n+        testLongs(Integer.MAX_VALUE, Integer.MIN_VALUE);\n+        testLongs(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        testLongs(Long.MAX_VALUE, Long.MIN_VALUE);\n+        testLongs(Long.MIN_VALUE, Long.MAX_VALUE);\n+        testLongs(RANDOM.nextLong(), RANDOM.nextLong());\n+    }\n+\n+    @DontCompile\n+    public void testLongs(long a, long b) {\n+        Asserts.assertEQ(a < b ? a : b, testMinL1(a, b));\n+        Asserts.assertEQ(a > b ? b : a, testMinL2(a, b));\n+        Asserts.assertEQ(a > b ? a : b, testMaxL1(a, b));\n+        Asserts.assertEQ(a < b ? b : a, testMaxL2(a, b));\n+\n+        Asserts.assertEQ(a <= b ? a : b, testMinL1E(a, b));\n+        Asserts.assertEQ(a >= b ? b : a, testMinL2E(a, b));\n+        Asserts.assertEQ(a >= b ? a : b, testMaxL1E(a, b));\n+        Asserts.assertEQ(a <= b ? b : a, testMaxL2E(a, b));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIfMinMax.java","additions":554,"deletions":0,"binary":false,"changes":554,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -182,1 +183,1 @@\n-    static void run(String testCaseName, Consumer<OutputAnalyzer> processor) throws IOException {\n+    static void run(String testCaseName, Consumer<OutputAnalyzer> processor) throws Exception {\n@@ -195,1 +196,1 @@\n-        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer analyzer = ProcessTools.executeProcess(pb);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/unloaded\/TestInlineUnloaded.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8329757\n+ * @summary Deoptimization with nested eliminated and not eliminated locks\n+ *          caused reordered lock stacks. This can be handled by the interpreter\n+ *          but when a frame is migrated back to compiled code via OSR the C2\n+ *          assumption about balanced monitorenter-monitorexit is broken.\n+ *\n+ * @requires vm.compMode != \"Xint\"\n+ *\n+ * @run main\/othervm compiler.escapeAnalysis.Test8329757\n+ *\/\n+\n+package compiler.escapeAnalysis;\n+\n+public class Test8329757 {\n+\n+    int a = 400;\n+    Double ddd;\n+\n+    void q() {\n+        int e;\n+        synchronized (new Double(1.1f)) {\n+        int[] f = new int[a];\n+        synchronized (Test8329757.class) {\n+            for (int d = 4; d < 127; d++) {\n+            e = 13;\n+            do switch (d * 5) {\n+                case 0:\n+                case 42:\n+                case 29:\n+                e = d;\n+                default:\n+                f[1] = e;\n+            } while (--e > 0);\n+            }\n+        }\n+        }\n+    }\n+\n+    void n() {\n+        for (int j = 6; j < 274; ++j) q();\n+    }\n+\n+    public static void main(String[] args) {\n+        Test8329757 r = new Test8329757();\n+        for (int i = 0; i < 1000; i++) r.n();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/Test8329757.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8323429\n+ * @summary Test min and max optimizations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.intrinsics.math.TestMinMaxOpt\n+ *\/\n+\n+package compiler.intrinsics.math;\n+\n+import compiler.lib.ir_framework.Argument;\n+import compiler.lib.ir_framework.Arguments;\n+import compiler.lib.ir_framework.Check;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+public class TestMinMaxOpt {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(failOn = {IRNode.MIN_I})\n+    private static int testIntMin(int v) {\n+        return Math.min(v, v);\n+    }\n+\n+    @Check(test = \"testIntMin\")\n+    public static void checkTestIntMin(int result) {\n+        if (result != 42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(failOn = {IRNode.MAX_I})\n+    private static int testIntMax(int v) {\n+        return Math.max(v, v);\n+    }\n+\n+    @Check(test = \"testIntMax\")\n+    public static void checkTestIntMax(int result) {\n+        if (result != 42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(failOn = {IRNode.MIN_L})\n+    private static long testLongMin(long v) {\n+        return Math.min(v, v);\n+    }\n+\n+    @Check(test = \"testLongMin\")\n+    public static void checkTestLongMin(long result) {\n+        if (result != 42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(failOn = {IRNode.MAX_L})\n+    private static long testLongMax(long v) {\n+        return Math.max(v, v);\n+    }\n+\n+    @Check(test = \"testLongMax\")\n+    public static void checkTestLongMax(long result) {\n+        if (result != 42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(failOn = {IRNode.MIN_F})\n+    private static float testFloatMin(float v) {\n+        return Math.min(v, v);\n+    }\n+\n+    @Check(test = \"testFloatMin\")\n+    public static void checkTestFloatMin(float result) {\n+        if (result != 42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(failOn = {IRNode.MAX_F})\n+    private static float testFloatMax(float v) {\n+        return Math.max(v, v);\n+    }\n+\n+    @Check(test = \"testFloatMax\")\n+    public static void checkTestFloatMax(float result) {\n+        if (result != 42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(failOn = {IRNode.MIN_D})\n+    private static double testDoubleMin(double v) {\n+        return Math.min(v, v);\n+    }\n+\n+    @Check(test = \"testDoubleMin\")\n+    public static void checkTestDoubleMin(double result) {\n+        if (result != 42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(failOn = {IRNode.MAX_D})\n+    private static double testDoubleMax(double v) {\n+        return Math.max(v, v);\n+    }\n+\n+    @Check(test = \"testDoubleMax\")\n+    public static void checkTestDoubleMax(double result) {\n+        if (result != 42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestMinMaxOpt.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -54,2 +55,1 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/NonInlinedCall\/Agent.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -147,2 +147,2 @@\n-            ConstantPool constantPool, int cpi) {\n-        return CTVM.lookupAppendixInPool((HotSpotConstantPool) constantPool, cpi);\n+            ConstantPool constantPool, int cpi, int opcode) {\n+        return CTVM.lookupAppendixInPool((HotSpotConstantPool) constantPool, cpi, opcode);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-                        return ~indy_index;\n+                        return indy_index;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/ConstantPoolTestsHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -822,1 +822,6 @@\n-        beforeMatchingNameRegex(MAX, \"Max(I|L)\");\n+        beforeMatchingNameRegex(MAX, \"Max(I|L|F|D)\");\n+    }\n+\n+    public static final String MAX_D = PREFIX + \"MAX_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_D, \"MaxD\");\n@@ -835,0 +840,5 @@\n+    public static final String MAX_F = PREFIX + \"MAX_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_F, \"MaxF\");\n+    }\n+\n@@ -870,0 +880,5 @@\n+    public static final String MAX_VL = VECTOR_PREFIX + \"MAX_VL\" + POSTFIX;\n+    static {\n+        vectorNode(MAX_VL, \"MaxV\", TYPE_LONG);\n+    }\n+\n@@ -875,0 +890,10 @@\n+    public static final String MEMBAR_ACQUIRE = PREFIX + \"MEMBAR_ACQUIRE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MEMBAR_ACQUIRE, \"MemBarAcquire\");\n+    }\n+\n+    public static final String MEMBAR_RELEASE = PREFIX + \"MEMBAR_RELEASE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MEMBAR_RELEASE, \"MemBarRelease\");\n+    }\n+\n@@ -880,0 +905,5 @@\n+    public static final String MEMBAR_VOLATILE = PREFIX + \"MEMBAR_VOLATILE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MEMBAR_VOLATILE, \"MemBarVolatile\");\n+    }\n+\n@@ -885,0 +915,5 @@\n+    public static final String MIN_D = PREFIX + \"MIN_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_D, \"MinD\");\n+    }\n+\n@@ -895,0 +930,5 @@\n+    public static final String MIN_F = PREFIX + \"MIN_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_F, \"MinF\");\n+    }\n+\n@@ -930,0 +970,5 @@\n+    public static final String MIN_VL = VECTOR_PREFIX + \"MIN_VL\" + POSTFIX;\n+    static {\n+        vectorNode(MIN_VL, \"MinV\", TYPE_LONG);\n+    }\n+\n@@ -2069,0 +2114,6 @@\n+    public static final String Z_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"Z_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"zCompareAndSwapP\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(Z_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,525 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.loopopts;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8323220\n+ * @summary Test loop invariant code motion of add\/sub through reassociation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.loopopts.InvariantCodeMotionReassociateAddSub\n+ *\/\n+public class InvariantCodeMotionReassociateAddSub {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private int size;\n+    private int inv1;\n+    private int inv2;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    private int blackhole(int i) { return i; }\n+    @DontInline\n+    private int blackhole(long i) { return (int)i; }\n+\n+    @Setup\n+    public Object[] setup(SetupInfo info) {\n+        int count = info.invocationCounter();\n+        size = count + 500;\n+        inv1 = count;\n+        if (RANDOM.nextInt() % 7 == 0) {\n+            \/\/ Setup inputs to be equals sometimes to avoid uncommon traps\n+            inv2 = inv1;\n+        } else {\n+            inv2 = count * 2;\n+        }\n+        return new Object[] { inv1, inv2, size };\n+    }\n+\n+    public void fail(int returnValue) {\n+        throw new RuntimeException(\"Illegal reassociation: returnValue=\" + returnValue + \", inv1=\" + inv1\n+                + \", inv2=\" + inv2 + \", size=\" + size);\n+    }\n+\n+    public void check(int returnValue, int expected) {\n+        if (returnValue != expected) {\n+            fail(returnValue);\n+        }\n+    }\n+\n+    public void checkAdd(int returnValue) {\n+        check(returnValue, inv1 + inv2 + size - 1);\n+    }\n+\n+    public void checkSubAdd(int returnValue) {\n+        check(returnValue, inv1 - inv2 + size - 1);\n+    }\n+\n+    public void checkNegSubAdd(int returnValue) {\n+        check(returnValue, -inv1 - inv2 + size - 1);\n+    }\n+\n+    public void checkAddSub(int returnValue) {\n+        check(returnValue, inv1 + inv2 - (size - 1));\n+    }\n+\n+    public void checkSubSub(int returnValue) {\n+        check(returnValue, inv1 - inv2 - (size - 1));\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    public int addInt(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 + inv2 + i`\n+            result = blackhole(inv1 + i + inv2);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"addInt\")\n+    public void checkAddInt(int returnValue) {\n+        checkAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"2\"})\n+    public int addLong(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 + inv2 + i`\n+            result = blackhole(inv1 + i + inv2);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"addLong\")\n+    public void checkAddLong(int returnValue) {\n+        checkAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    public int addInt2(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 + inv2 + i`\n+            result = blackhole(inv1 + (i + inv2));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"addInt2\")\n+    public void checkAddInt2(int returnValue) {\n+        checkAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"2\"})\n+    public int addLong2(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 + inv2 + i`\n+            result = blackhole(inv1 + (i + inv2));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"addLong2\")\n+    public void checkAddLong2(int returnValue) {\n+        checkAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int minusAddInt(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 - inv2 + i`\n+            result = blackhole(inv1 + (i - inv2));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"minusAddInt\")\n+    public void checkSubAddInt(int returnValue) {\n+        checkSubAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int minusAddLong(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 - inv2 + i`\n+            result = blackhole(inv1 + (i - inv2));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"minusAddLong\")\n+    public void checkSubAddLong(int returnValue) {\n+        checkSubAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int minusAddInt2(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 - inv2 + i`\n+            result = blackhole(inv1 - (inv2 - i));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"minusAddInt2\")\n+    public void checkSubAddInt2(int returnValue) {\n+        checkSubAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int minusAddLong2(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 - inv2 + i`\n+            result = blackhole(inv1 - (inv2 - i));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"minusAddLong2\")\n+    public void checkSubAddLong2(int returnValue) {\n+        checkSubAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int minusAddInt3(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 - inv2 + i`\n+            result = blackhole(i - inv2 + inv1);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"minusAddInt3\")\n+    public void checkSubAddInt3(int returnValue) {\n+        checkSubAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int minusAddLong3(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 - inv2 + i`\n+            result = blackhole(i - inv2 + inv1);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"minusAddLong3\")\n+    public void checkSubAddLong3(int returnValue) {\n+        checkSubAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int negAddInt(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `-inv2 + inv1 + i`\n+            result = blackhole(i + inv1 - inv2);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"negAddInt\")\n+    public void checkNegAddInt(int returnValue) {\n+        checkSubAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int negAddLong(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `-inv2 + inv1 + i`\n+            result = blackhole(i + inv1 - inv2);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"negAddLong\")\n+    public void checkNegAddLong(int returnValue) {\n+        checkSubAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.SUB_I, \"2\"})\n+    public int negSubAddInt(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `-inv1 - inv2 + i`\n+            result = blackhole(i - inv1 - inv2);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"negSubAddInt\")\n+    public void checkNegSubAddInt(int returnValue) {\n+        checkNegSubAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    @IR(counts = {IRNode.SUB_L, \"2\"})\n+    public int negSubAddLong(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `-inv1 - inv2 + i`\n+            result = blackhole(i - inv1 - inv2);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"negSubAddLong\")\n+    public void checkNegSubAddLong(int returnValue) {\n+        checkNegSubAdd(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int addSubInt(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 + inv2 - i`\n+            result = blackhole(inv1 + (inv2 - i));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"addSubInt\")\n+    public void checkAddSubInt(int returnValue) {\n+        checkAddSub(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int addSubLong(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 + inv2 - i`\n+            result = blackhole(inv1 + (inv2 - i));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"addSubLong\")\n+    public void checkAddSubLong(int returnValue) {\n+        checkAddSub(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int addSubInt2(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 + inv2 - i`\n+            result = blackhole(inv1 - (i - inv2));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"addSubInt2\")\n+    public void checkAddSubInt2(int returnValue) {\n+        checkAddSub(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int addSubLong2(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 + inv2 - i`\n+            result = blackhole(inv1 - (i - inv2));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"addSubLong2\")\n+    public void checkAddSubLong2(int returnValue) {\n+        checkAddSub(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int addSubInt3(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 + inv2 - i`\n+            result = blackhole(inv2 - i + inv1);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"addSubInt3\")\n+    public void checkAddSubInt3(int returnValue) {\n+        checkAddSub(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int addSubLong3(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 + inv2 - i`\n+            result = blackhole(inv2 - i + inv1);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"addSubLong3\")\n+    public void checkAddSubLong3(int returnValue) {\n+        checkAddSub(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.SUB_I, \"2\"})\n+    public int subSubInt(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 - inv2 - i`\n+            result = blackhole(inv1 - (i + inv2));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"subSubInt\")\n+    public void checkSubSubInt(int returnValue) {\n+        checkSubSub(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = {IRNode.ADD_L})\n+    @IR(counts = {IRNode.SUB_L, \"2\"})\n+    public int subSubLong(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 - inv2 - i`\n+            result = blackhole(inv1 - (i + inv2));\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"subSubLong\")\n+    public void checkSubSubLong(int returnValue) {\n+        checkSubSub(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.SUB_I, \"2\"})\n+    public int subSubInt2(int inv1, int inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 - inv2 - i`\n+            result = blackhole(inv1 - i - inv2);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"subSubInt2\")\n+    public void checkSubSubInt2(int returnValue) {\n+        checkSubSub(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = {IRNode.ADD_L})\n+    @IR(counts = {IRNode.SUB_L, \"2\"})\n+    public int subSubLong2(long inv1, long inv2, int size) {\n+        int result = -1;\n+        for (int i = 0; i < size; ++i) {\n+            \/\/ Reassociate to `inv1 - inv2 - i`\n+            result = blackhole(inv1 - i - inv2);\n+        }\n+        return result;\n+    }\n+\n+    @Check(test = \"subSubLong2\")\n+    public void checkSubSubLong2(int returnValue) {\n+        checkSubSub(returnValue);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/InvariantCodeMotionReassociateAddSub.java","additions":525,"deletions":0,"binary":false,"changes":525,"status":"added"},{"patch":"@@ -0,0 +1,412 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.loopopts;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8323220\n+ * @summary Test loop invariant code motion for cmp nodes through reassociation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.loopopts.InvariantCodeMotionReassociateCmp\n+ *\/\n+public class InvariantCodeMotionReassociateCmp {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private int size;\n+    private int inv1;\n+    private int inv2;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    private void blackhole() {}\n+\n+    @Setup\n+    public Object[] setup(SetupInfo info) {\n+        int count = info.invocationCounter();\n+        size = count + 500;\n+        inv1 = count;\n+        if (RANDOM.nextInt() % 7 == 0) {\n+            \/\/ Setup inputs to be equals sometimes to avoid uncommon traps\n+            inv2 = inv1;\n+        } else {\n+            inv2 = count * 2;\n+        }\n+        return new Object[] { inv1, inv2, size };\n+    }\n+\n+    public void fail(int returnValue) {\n+        throw new RuntimeException(\"Illegal reassociation: returnValue=\" + returnValue + \", inv1=\" + inv1\n+                + \", inv2=\" + inv2 + \", size=\" + size);\n+    }\n+\n+    public void checkEq(int returnValue) {\n+        int invDiff = inv2 - inv1;\n+        if ((invDiff < size && returnValue != invDiff) || (invDiff >= size && returnValue != size)) {\n+            fail(returnValue);\n+        }\n+    }\n+\n+    public void checkNe(int returnValue) {\n+        int invDiff = inv2 - inv1;\n+        if ((invDiff != 0 && returnValue != 0) || (invDiff == 0 && returnValue != 1)) {\n+            fail(returnValue);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int equalsAddInt(int inv1, int inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv2 - inv1 == i`\n+            if (inv1 + i == inv2) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"equalsAddInt\")\n+    public void checkEqualsAddInt(int returnValue) {\n+        checkEq(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int equalsAddLong(long inv1, long inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv2 - inv1 == i`\n+            if (inv1 + i == inv2) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"equalsAddLong\")\n+    public void checkEqualsAddLong(int returnValue) {\n+        checkEq(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int equalsInvariantSubVariantInt(int inv1, int inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv1 - inv2 == i`\n+            if (inv2 - i == inv1) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"equalsInvariantSubVariantInt\")\n+    public void checkEqualsInvariantSubVariantInt(int returnValue) {\n+        checkEq(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int equalsInvariantSubVariantLong(long inv1, long inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv2 - inv1 == i`\n+            if (inv2 - i == inv1) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"equalsInvariantSubVariantLong\")\n+    public void checkEqualsInvariantSubVariantLong(int returnValue) {\n+        checkEq(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int equalsVariantSubInvariantInt(int inv1, int inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv2 - inv1 == i`\n+            if (i - inv2 == -inv1) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"equalsVariantSubInvariantInt\")\n+    public void checkEqualsVariantSubInvariantInt(int returnValue) {\n+        checkEq(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int equalsVariantSubInvariantLong(long inv1, long inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv2 - inv1 == i`\n+            if (i - inv2 == -inv1) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"equalsVariantSubInvariantLong\")\n+    public void checkEqualsVariantSubInvariantLong(int returnValue) {\n+        checkEq(returnValue);\n+    }\n+\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int notEqualsAddInt(int inv1, int inv2, int size) {\n+        int i = 0;\n+        for (; i < 500; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv1 - inv2 != i`\n+            if (inv1 + i != inv2) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"notEqualsAddInt\")\n+    public void checkNotEqualsAddInt(int returnValue) {\n+        checkNe(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int notEqualsAddLong(long inv1, long inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv1 - inv2 != i`\n+            if (inv1 + i != inv2) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"notEqualsAddLong\")\n+    public void checkNotEqualsAddLong(int returnValue) {\n+        checkNe(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int notEqualsInvariantSubVariantInt(int inv1, int inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv1 - inv2 != i`\n+            if (inv1 - i != inv2) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"notEqualsInvariantSubVariantInt\")\n+    public void checkNotEqualsInvariantSubVariantInt(int returnValue) {\n+        checkNe(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int notEqualsInvariantSubVariantLong(long inv1, long inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv1 - inv2 != i`\n+            if (inv1 - i != inv2) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"notEqualsInvariantSubVariantLong\")\n+    public void checkNotEqualsInvariantSubVariantLong(int returnValue) {\n+        checkNe(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int notEqualsVariantSubInvariantInt(int inv1, int inv2, int size) {\n+        int i = 0;\n+        for (; i < 500; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv2 - inv1 != i`\n+            if (i - inv2 != -inv1) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"notEqualsVariantSubInvariantInt\")\n+    public void checkNotEqualsVariantSubInvariantInt(int returnValue) {\n+        checkNe(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public int notEqualsVariantSubInvariantLong(long inv1, long inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            \/\/ Reassociate to `inv1 - inv1 != i`\n+            if (i - inv2 != -inv1) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"notEqualsVariantSubInvariantLong\")\n+    public void checkNotEqualsVariantSubInvariantLong(int returnValue) {\n+        checkNe(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = {IRNode.SUB_I})\n+    public int ltDontReassociate(int inv1, int inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            if (inv1 + i < inv2) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"ltDontReassociate\")\n+    public void checkLtDontReassociate(int returnValue) {\n+        int sum = inv1 + returnValue;\n+        if ((returnValue < size && sum >= inv2) || (returnValue > size && sum < inv2)) {\n+            fail(returnValue);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = {IRNode.SUB_I})\n+    public int leDontReassociate(int inv1, int inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            if (inv1 + i <= inv2) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"leDontReassociate\")\n+    public void checkLeDontReassociate(int returnValue) {\n+        int sum = inv1 + returnValue;\n+        if ((returnValue < size && sum > inv2) || (returnValue > size && sum <= inv2)) {\n+            fail(returnValue);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = {IRNode.SUB_I})\n+    public int gtDontReassociate(int inv1, int inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            if (inv1 + i > inv2) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"gtDontReassociate\")\n+    public void checkGtDontReassociate(int returnValue) {\n+        int sum = inv1 + returnValue;\n+        if ((returnValue < size && sum <= inv2) || (returnValue > size && sum > inv2)) {\n+            fail(returnValue);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = {IRNode.SUB_I})\n+    public int geDontReassociate(int inv1, int inv2, int size) {\n+        int i = 0;\n+        for (; i < size; ++i) {\n+            blackhole();\n+            if (inv1 + i >= inv2) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @Check(test = \"geDontReassociate\")\n+    public void checkGeDontReassociate(int returnValue) {\n+        int sum = inv1 + returnValue;\n+        if ((returnValue < size && sum < inv2) || (returnValue > size && sum >= inv2)) {\n+            fail(returnValue);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/InvariantCodeMotionReassociateCmp.java","additions":412,"deletions":0,"binary":false,"changes":412,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8330819\n+ * @summary Case where VPointer finds an \"adr\" CastX2P, which contains a CastLL,\n+ *          that has a ctrl after the pre-loop. This value cannot be used in the\n+ *          pre-loop limit for main-loop adjustment.\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.util\n+ * @run main\/othervm -Xbatch compiler.loopopts.superword.TestMemorySegmentMainLoopAlignment\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.*;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.Preconditions;\n+\n+public class TestMemorySegmentMainLoopAlignment {\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static long RANGE = 6400;\n+\n+    \/\/ Type definition for the lambda\n+    interface MSOp {\n+        int apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/\/ Type definition for the lambda\n+    interface MemoryUnsafeOp {\n+        int apply(long base, long offset, int i);\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Allocate some raw memory:\n+        MemorySegment ms = Arena.ofAuto().allocate(6400, Integer.SIZE);\n+        for (int i = 0; i < 10_000; i++) {\n+            test1(ms, 0, TestMemorySegmentMainLoopAlignment::memorySegmentGet);\n+        }\n+        \/\/ Allocate some raw memory:\n+        long base = UNSAFE.allocateMemory(6400);\n+        for (int i = 0; i < 10_000; i++) {\n+            test2(base, 0, TestMemorySegmentMainLoopAlignment::memoryUnsafeGet);\n+        }\n+    }\n+\n+    \/\/ Somehow, it is necessary to pass this as a lambda\n+    \/\/ the checkIndex inside the \"get\" method produces the CastLL, which eventually pins the index\n+    \/\/ between the pre and main loop.\n+    static int memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 4L);\n+    }\n+\n+    static int test1(MemorySegment a, long offset, MSOp f) {\n+        \/\/ Constant size array size allows a known range for the array access\/loop iv i.\n+        int size = 16;\n+        int[] res = new int[size];\n+        int sum = 0;\n+        for (int i = 0; i < size; i++) {\n+            \/\/ With inlining, this eventually becomes:\n+            \/\/ sum += LoadI(MemorySegment \/ unsafe) + LoadI(array)\n+            \/\/ and we attempt vectorization.\n+            sum += f.apply(a, offset, i) + res[i];\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ Somehow, it is necessary to pass this as a lambda\n+    static int memoryUnsafeGet(long base, long o, int i) {\n+        long index = o + i * 4L;\n+        \/\/ checkIndex -> CastLL: index >= 0.\n+        \/\/ Together with the info about i (known range for phi), this CastLL floats up to\n+        \/\/ the offset. Then we get adr = CastX2P(base + CastLL(offset)), where the CastLL\n+        \/\/ is pinned between the pre and main loop.\n+        Preconditions.checkIndex(index, RANGE, null);\n+        return UNSAFE.getInt(base + index);\n+    }\n+\n+    static int test2(long base, long offset, MemoryUnsafeOp f) {\n+        \/\/ Constant size array size allows a known range for the array access\/loop iv i.\n+        int size = 16;\n+        int[] res = new int[size];\n+        int sum = 0;\n+        for (int i = 0; i < size; i++) {\n+            \/\/ With inlining, this eventually becomes:\n+            \/\/ sum += LoadI(unsafe) + LoadI(array)\n+            \/\/ and we attempt vectorization.\n+            sum += f.apply(base, offset, i) + res[i];\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentMainLoopAlignment.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325494\n+ * @summary C2: Broken graph after not skipping CastII node anymore for Assertion Predicates after JDK-8309902\n+ * @run main\/othervm -XX:-TieredCompilation -Xcomp -XX:CompileOnly=TestAssertionPredicateDoesntConstantFold::test TestAssertionPredicateDoesntConstantFold\n+ *\n+ *\/\n+\n+public class TestAssertionPredicateDoesntConstantFold {\n+    static boolean bFld;\n+    static int iArrFld[];\n+    static long lArrFld[];\n+\n+    public static void main(String[] strArr) {\n+        try {\n+            test();\n+        } catch (NullPointerException npe) {}\n+    }\n+\n+    static long test() {\n+        int i6 = 1, i7, i11;\n+        do {\n+            for (i7 = 1; i7 < 9; ++i7) {\n+                for (i11 = 2; i6 < i11; i11 -= 2) {\n+                    if (bFld) {\n+                        break;\n+                    }\n+\n+                    lArrFld[i11 + 1] = 6;\n+                    iArrFld[i11 % 20] = 3;\n+                }\n+            }\n+        } while (++i6 < 8);\n+\n+        return i6;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestAssertionPredicateDoesntConstantFold.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8328822\n+ * @summary C2: \"negative trip count?\" assert failure in profile predicate code\n+ * @run main\/othervm  -XX:-BackgroundCompilation TestCountedLoopMinJintStride\n+ *\/\n+\n+import java.util.Objects;\n+\n+public class TestCountedLoopMinJintStride {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(Integer.MAX_VALUE-1, Integer.MAX_VALUE, 0);\n+            testHelper1(100, -1, Integer.MAX_VALUE, 0);\n+            test2(Integer.MAX_VALUE-1, Integer.MAX_VALUE, 0);\n+            testHelper2(100, -1, Integer.MAX_VALUE, 0);\n+        }\n+    }\n+\n+    private static void test1(int stop, int range, int start) {\n+        testHelper1(stop, Integer.MIN_VALUE, range, start);\n+    }\n+\n+    private static void testHelper1(int stop, int stride, int range, int start) {\n+        for (int i = stop; i >= start; i += stride) {\n+            Objects.checkIndex(i, range);\n+        }\n+    }\n+\n+    private static void test2(int stop, int range, int start) {\n+        testHelper1(stop, Integer.MIN_VALUE, range, start);\n+    }\n+\n+    private static void testHelper2(int stop, int stride, int range, int start) {\n+        for (int i = stop; i >= start; i += stride) {\n+            if (i < 0 || i >= range) {\n+                throw new RuntimeException(\"out of bounds\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestCountedLoopMinJintStride.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8330004\n+ * @summary Sanity test to exercise code to clone a Template Assertion Predicate down in Split If.\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:LoopMaxUnroll=0\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestSplitIfCloningDown::*\n+ *                   compiler.predicates.assertion.TestSplitIfCloningDown\n+ *\/\n+\n+\/*\n+ * @test id=no-flags\n+ * @bug 8330004\n+ * @summary Sanity test to exercise code to clone a Template Assertion Predicate down in Split If.\n+ * @run main compiler.predicates.assertion.TestSplitIfCloningDown\n+ *\/\n+\n+package compiler.predicates.assertion;\n+\n+public class TestSplitIfCloningDown {\n+    static int[] iArr = new int[100];\n+    static boolean flag;\n+    static int iFld;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            testPhiIntoNonOpaqueLoopExpressionNode();\n+            testPhiIntoOpaqueLoopExpressionNode();\n+        }\n+    }\n+\n+\n+    static void testPhiIntoNonOpaqueLoopExpressionNode() {\n+        int zero = 34;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+\n+        for (int t = 0; t < 100; t++) { \/\/ Use outer loop such that OpaqueLoop* will get an earlier ctrl.\n+            iArr = new int[1000];\n+\n+            \/\/ Replaced by CMove which is an input into Template Assertion Predicate Expression which\n+            \/\/ is not an OpaqueLoop* node. Split If will create a phi and tries to split a Template\n+            \/\/ Assertion Predicate Expression node -> Need to clone template down.\n+            int a;\n+            if (flag) {\n+                a = 4;\n+            } else {\n+                a = 3;\n+            }\n+\n+            for (int i = 0; i < 100; i++) {\n+                iArr[i+a] = 34; \/\/ Hoisted with Hoisted Check Predicate and Template Assertion Predicate\n+                if (i * zero < iFld) { \/\/ Unswitched after Split If to check further template cloning.\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test above but this time the phi inputs into an OpaqueLoop* node and not a node in between.\n+    static void testPhiIntoOpaqueLoopExpressionNode() {\n+        int zero = 34;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        iArr = new int[1000];\n+\n+        \/\/ Replaced by CMove which is an input into Template Assertion Predicate Expression which\n+        \/\/ is not an OpaqueLoop* node. Split If will create a phi and tries to split a Template\n+        \/\/ Assertion Predicate Expression node -> Need to clone template down.\n+        int a;\n+        if (flag) {\n+            a = 4;\n+        } else {\n+            a = 3;\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            iArr[i+a] = 34; \/\/ Hoisted with Hoisted Check Predicate and Template Assertion Predicate\n+            if (i * zero < iFld) { \/\/ Unswitched after Split If to check further template cloning.\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestSplitIfCloningDown.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327741\n+ * @summary JVM crash in hotspot\/share\/opto\/compile.cpp - failed: missing inlining msg\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-BackgroundCompilation -XX:+PrintCompilation -XX:+PrintInlining TestPrintInliningLateVirtualCall\n+ *\/\n+\n+public class TestPrintInliningLateVirtualCall {\n+    static final A fieldA = new A();\n+    static final B fieldB = new B();\n+    static final C fieldC = new C();\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            testHelper(0);\n+            testHelper(10);\n+            testHelper(100);\n+            test();\n+        }\n+    }\n+\n+    private static void testHelper(int i) {\n+        A a;\n+        if (i == 10) {\n+            a = fieldA;\n+        } else if (i > 10) {\n+            a = fieldB;\n+        } else {\n+            a = fieldC;\n+        }\n+        a.m();\n+    }\n+\n+    private static void test() {\n+        int i;\n+        for (i = 0; i < 10; i++) {\n+\n+        }\n+        testHelper(i);\n+    }\n+\n+    static class A {\n+        void m() {\n+\n+        }\n+    }\n+\n+    static class B extends A {\n+        void m() {\n+\n+        }\n+    }\n+\n+    static class C extends A {\n+        void m() {\n+\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/TestPrintInliningLateVirtualCall.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -63,1 +64,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n@@ -65,1 +65,1 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n@@ -67,1 +67,1 @@\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass\/Launcher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -66,1 +67,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n@@ -68,1 +68,1 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n@@ -70,1 +70,1 @@\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass_classloaders\/Launcher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8328480\n+ * @summary Test that SubTypeCheckNode takes improved unique concrete klass constant in order to fold consecutive sub\n+ *          type checks.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.types.TestSubTypeCheckUniqueSubclass\n+ *\/\n+\n+package compiler.types;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestSubTypeCheckUniqueSubclass {\n+    static Object o = new C(); \/\/ Make sure C is loaded.\n+    static Object o2 = new C2(); \/\/ Make sure C2 is loaded while NeverLoaded is not.\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @IR(counts = {IRNode.SUBTYPE_CHECK, \"1\"},\n+        phase = CompilePhase.ITER_GVN1)\n+    static void testAbstractAbstract() {\n+         A a = (A)o;\n+         A a2 = (B)o;\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @IR(counts = {IRNode.SUBTYPE_CHECK, \"1\"},\n+            phase = CompilePhase.ITER_GVN1)\n+    static void testAbstractAbstractWithUnloaded() {\n+        A2 a = (A2)o2;\n+        A2 a2 = (B2)o2;\n+    }\n+}\n+\n+abstract class A {}\n+abstract class B extends A {}\n+class C extends B {}\n+\n+abstract class A2 {}\n+abstract class B2 extends A2 {}\n+class C2 extends B2 {}\n+\n+\/\/ Class never loaded -> C2 looks like unique sub class.\n+class NeverLoaded extends B2 {}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestSubTypeCheckUniqueSubclass.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+\/*\n+ * @test\n+ * @bug 8329555\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run main\/othervm -Xbatch -XX:+TieredCompilation compiler.vectorapi.TestBiMorphicMismatchedMemSegment\n+ *\/\n+\n+\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.IntStream;\n+\n+public class TestBiMorphicMismatchedMemSegment {\n+    public static void main(String[] args) {\n+        AtomicLong aLong = new AtomicLong();\n+\n+        IntStream.range(0, 10000).forEach(j -> {\n+            byte[] bytes = new byte[64];\n+            ThreadLocalRandom.current().nextBytes(bytes);\n+            var byteSegment = MemorySegment.ofArray(bytes);\n+            var byteFragment = ByteVector.SPECIES_PREFERRED.fromMemorySegment(byteSegment, 0, ByteOrder.LITTLE_ENDIAN);\n+            float[] floats = new float[128];\n+            byte[] targetBytes = new byte[512];\n+            var floatSegment = MemorySegment.ofArray(floats);\n+            var targetByteSegment = MemorySegment.ofArray(targetBytes);\n+            byteFragment.intoMemorySegment(floatSegment, ThreadLocalRandom.current().nextInt(0, 448), ByteOrder.LITTLE_ENDIAN);\n+            byteFragment.intoMemorySegment(targetByteSegment, ThreadLocalRandom.current().nextInt(0, 448), ByteOrder.LITTLE_ENDIAN);\n+            var l = 0;\n+            for (int i = 0; i < floats.length; i++) {\n+                l += (int) floats[i];\n+            }\n+            aLong.addAndGet(l);\n+        });\n+\n+        System.out.println(aLong.get());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestBiMorphicMismatchedMemSegment.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -243,1 +243,1 @@\n-        counts = {IRNode.MAX_VD, \">0\"})\n+        counts = {IRNode.MAX_VD, \"0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @modules java.base\/jdk.internal.platform\n@@ -47,0 +48,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -55,0 +57,1 @@\n+    private static boolean isCgroupV1 = false;\n@@ -62,0 +65,8 @@\n+        \/\/ If cgroups is not configured, report success.\n+        Metrics metrics = Metrics.systemMetrics();\n+        if (metrics == null) {\n+            System.out.println(\"TEST PASSED!!!\");\n+            return;\n+        }\n+        isCgroupV1 = \"cgroupv1\".equals(metrics.getProvider());\n+\n@@ -220,6 +231,10 @@\n-         OutputAnalyzer out = DockerTestUtils.dockerRunJava(\n-                                      commonDockerOpts()\n-                                      .addDockerOpts(\"--memory=\" + memValueToSet)\n-                                      .addDockerOpts(\"--memory-swap=\" + swapValueToSet)\n-                                      .addClassOptions(\"jdk.SwapSpace\"));\n-         out.shouldHaveExitValue(0)\n+        DockerRunOptions opts = commonDockerOpts();\n+        opts.addDockerOpts(\"--memory=\" + memValueToSet)\n+            .addDockerOpts(\"--memory-swap=\" + swapValueToSet)\n+            .addClassOptions(\"jdk.SwapSpace\");\n+        if (isCgroupV1) {\n+            \/\/ With Cgroupv1, The default memory-swappiness vaule is inherited from the host machine, which maybe 0\n+            opts.addDockerOpts(\"--memory-swappiness=60\");\n+        }\n+        OutputAnalyzer out = DockerTestUtils.dockerRunJava(opts);\n+        out.shouldHaveExitValue(0)\n@@ -228,18 +243,18 @@\n-         List<String> ls = out.asLinesWithoutVMWarnings();\n-         for (String cur : ls) {\n-             int idx = cur.indexOf(\"freeSize = \");\n-             if (idx != -1) {\n-                 int startNbr = idx+11;\n-                 int endNbr = cur.indexOf(' ', startNbr);\n-                 if (endNbr == -1) endNbr = cur.length();\n-                 String freeSizeStr = cur.substring(startNbr, endNbr);\n-                 long freeval = Long.parseLong(freeSizeStr);\n-                 long totalval = Long.parseLong(expectedTotalValue);\n-                 if (0 <= freeval && freeval <= totalval) {\n-                     System.out.println(\"Found freeSize value \" + freeval + \" is fine\");\n-                 } else {\n-                     System.out.println(\"Found freeSize value \" + freeval + \" is bad\");\n-                     throw new Exception(\"Found free size value is bad\");\n-                 }\n-             }\n-         }\n+        List<String> ls = out.asLinesWithoutVMWarnings();\n+        for (String cur : ls) {\n+            int idx = cur.indexOf(\"freeSize = \");\n+            if (idx != -1) {\n+                int startNbr = idx+11;\n+                int endNbr = cur.indexOf(' ', startNbr);\n+                if (endNbr == -1) endNbr = cur.length();\n+                String freeSizeStr = cur.substring(startNbr, endNbr);\n+                long freeval = Long.parseLong(freeSizeStr);\n+                long totalval = Long.parseLong(expectedTotalValue);\n+                if (0 <= freeval && freeval <= totalval) {\n+                    System.out.println(\"Found freeSize value \" + freeval + \" is fine\");\n+                } else {\n+                    System.out.println(\"Found freeSize value \" + freeval + \" is bad\");\n+                    throw new Exception(\"Found free size value is bad\");\n+                }\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFREvents.java","additions":39,"deletions":24,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -105,4 +105,4 @@\n-        new LogMessageWithLevel(\"Pre Evacuate Collection Set\", Level.INFO),\n-        new LogMessageWithLevel(\"Evacuate Collection Set\", Level.INFO),\n-        new LogMessageWithLevel(\"Post Evacuate Collection Set\", Level.INFO),\n-        new LogMessageWithLevel(\"Other\", Level.INFO),\n+        new LogMessageWithLevel(\"Pre Evacuate Collection Set:\", Level.INFO),\n+        new LogMessageWithLevel(\"Evacuate Collection Set:\", Level.INFO),\n+        new LogMessageWithLevel(\"Post Evacuate Collection Set:\", Level.INFO),\n+        new LogMessageWithLevel(\"Other:\", Level.INFO),\n@@ -111,5 +111,5 @@\n-        new LogMessageWithLevel(\"JT Retire TLABs And Flush Logs\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Non-JT Flush Logs\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Choose Collection Set\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Region Register\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Prepare Heap Roots\", Level.DEBUG),\n+        new LogMessageWithLevel(\"JT Retire TLABs And Flush Logs \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Non-JT Flush Logs \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Choose Collection Set:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Region Register:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Prepare Heap Roots:\", Level.DEBUG),\n@@ -117,16 +117,16 @@\n-        new LogMessageWithLevel(\"Merge Heap Roots\", Level.INFO),\n-        new LogMessageWithLevel(\"Prepare Merge Heap Roots\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Eager Reclaim\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Remembered Sets\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Inline\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged ArrayOfCards\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Howl\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Full\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Howl Inline\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Howl ArrayOfCards\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Howl BitMap\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Howl Full\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Log Buffers\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Dirty Cards\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Cards\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Skipped Cards\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merge Heap Roots:\", Level.INFO),\n+        new LogMessageWithLevel(\"Prepare Merge Heap Roots:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Eager Reclaim \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Remembered Sets \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Inline:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged ArrayOfCards:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Full:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl Inline:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl ArrayOfCards:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl BitMap:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl Full:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Log Buffers \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Dirty Cards:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Cards:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Skipped Cards:\", Level.DEBUG),\n@@ -134,4 +134,4 @@\n-        new LogMessageWithLevel(\"Ext Root Scanning\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Thread Roots\", Level.TRACE),\n-        new LogMessageWithLevel(\"CLDG Roots\", Level.TRACE),\n-        new LogMessageWithLevel(\"CM RefProcessor Roots\", Level.TRACE),\n+        new LogMessageWithLevel(\"Ext Root Scanning \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Thread Roots \\\\(ms\\\\):\", Level.TRACE),\n+        new LogMessageWithLevel(\"CLDG Roots \\\\(ms\\\\):\", Level.TRACE),\n+        new LogMessageWithLevel(\"CM RefProcessor Roots \\\\(ms\\\\):\", Level.TRACE),\n@@ -141,5 +141,5 @@\n-        new LogMessageWithLevel(\"Scan Heap Roots\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Scanned Cards\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Scanned Blocks\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Claimed Chunks\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Found Roots\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Scan Heap Roots \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Scanned Cards:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Scanned Blocks:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Claimed Chunks:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Found Roots:\", Level.DEBUG),\n@@ -147,1 +147,1 @@\n-        new LogMessageWithLevel(\"Code Root Scan\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Code Root Scan \\\\(ms\\\\):\", Level.DEBUG),\n@@ -149,4 +149,4 @@\n-        new LogMessageWithLevel(\"Object Copy\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Copied Bytes\", Level.DEBUG),\n-        new LogMessageWithLevel(\"LAB Waste\", Level.DEBUG),\n-        new LogMessageWithLevel(\"LAB Undo Waste\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Object Copy \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Copied Bytes:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"LAB Waste:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"LAB Undo Waste:\", Level.DEBUG),\n@@ -154,2 +154,2 @@\n-        new LogMessageWithLevel(\"Termination\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Termination Attempts\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Termination \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Termination Attempts:\", Level.DEBUG),\n@@ -158,1 +158,1 @@\n-        new LogMessageWithLevel(\"NMethod List Cleanup\", Level.DEBUG),\n+        new LogMessageWithLevel(\"NMethod List Cleanup:\", Level.DEBUG),\n@@ -160,1 +160,1 @@\n-        new LogMessageWithLevel(\"Reference Processing\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Reference Processing:\", Level.DEBUG),\n@@ -162,1 +162,1 @@\n-        new LogMessageWithLevel(\"Weak Processing\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Weak Processing:\", Level.DEBUG),\n@@ -172,7 +172,7 @@\n-        new LogMessageWithLevel(\"Post Evacuate Cleanup 1\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merge Per-Thread State\", Level.DEBUG),\n-        new LogMessageWithLevel(\"LAB Waste\", Level.DEBUG),\n-        new LogMessageWithLevel(\"LAB Undo Waste\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Evac Fail Extra Cards\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Clear Logged Cards\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Recalculate Used Memory\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Post Evacuate Cleanup 1:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merge Per-Thread State \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"LAB Waste:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"LAB Undo Waste:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Evac Fail Extra Cards:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Clear Logged Cards \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Recalculate Used Memory \\\\(ms\\\\):\", Level.DEBUG),\n@@ -181,1 +181,1 @@\n-        new LogMessageWithLevel(\"Post Evacuate Cleanup 2\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Post Evacuate Cleanup 2:\", Level.DEBUG),\n@@ -183,7 +183,7 @@\n-        new LogMessageWithLevel(\"Redirty Logged Cards\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Redirtied Cards\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Resize TLABs\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Free Collection Set\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Serial Free Collection Set\", Level.TRACE),\n-        new LogMessageWithLevel(\"Young Free Collection Set\", Level.TRACE),\n-        new LogMessageWithLevel(\"Non-Young Free Collection Set\", Level.TRACE),\n+        new LogMessageWithLevel(\"Redirty Logged Cards \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Redirtied Cards:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Resize TLABs \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Free Collection Set \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Serial Free Collection Set:\", Level.TRACE),\n+        new LogMessageWithLevel(\"Young Free Collection Set \\\\(ms\\\\):\", Level.TRACE),\n+        new LogMessageWithLevel(\"Non-Young Free Collection Set \\\\(ms\\\\):\", Level.TRACE),\n@@ -192,5 +192,5 @@\n-        new LogMessageWithLevel(\"Rebuild Free List\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Serial Rebuild Free List\", Level.TRACE),\n-        new LogMessageWithLevel(\"Parallel Rebuild Free List\", Level.TRACE),\n-        new LogMessageWithLevel(\"Prepare For Mutator\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Expand Heap After Collection\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Rebuild Free List:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Serial Rebuild Free List:\", Level.TRACE),\n+        new LogMessageWithLevel(\"Parallel Rebuild Free List \\\\(ms\\\\):\", Level.TRACE),\n+        new LogMessageWithLevel(\"Prepare For Mutator:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Expand Heap After Collection:\", Level.DEBUG),\n@@ -261,7 +261,7 @@\n-        new LogMessageWithLevel(\"Recalculate Used Memory\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Restore Preserved Marks\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Restore Evacuation Failed Regions\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Process Evacuation Failed Regions\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Evacuation Failed Regions\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Pinned Regions\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Allocation Failed Regions\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Recalculate Used Memory \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Restore Preserved Marks \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Restore Evacuation Failed Regions \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Process Evacuation Failed Regions \\\\(ms\\\\):\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Evacuation Failed Regions:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Pinned Regions:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Allocation Failed Regions:\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":71,"deletions":71,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Check that TAMSes are correctly updated for regions dropped from\n+ *          the retained collection set candidates during a Concurrent Start pause.\n+ * @requires vm.gc.G1\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+                     -XX:+WhiteBoxAPI -Xbootclasspath\/a:. -Xmx32m -XX:G1NumCollectionsKeepPinned=1\n+                     -XX:+VerifyBeforeGC -XX:+VerifyAfterGC -XX:G1MixedGCLiveThresholdPercent=100\n+                     -XX:G1HeapWastePercent=0 -Xlog:gc,gc+ergo+cset=trace gc.g1.pinnedobjs.TestDroppedRetainedTAMS\n+ *\/\n+\n+package gc.g1.pinnedobjs;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestDroppedRetainedTAMS {\n+\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    private static final char[] dummy = new char[100];\n+\n+    public static void main(String[] args) {\n+        wb.fullGC(); \/\/ Move the target dummy object to old gen.\n+\n+        wb.pinObject(dummy);\n+\n+        \/\/ After this concurrent cycle the pinned region will be in the the (marking)\n+        \/\/ collection set candidates.\n+        wb.g1RunConcurrentGC();\n+\n+        \/\/ Pass the Prepare mixed gc which will not do anything about the marking\n+        \/\/ candidates.\n+        wb.youngGC();\n+        \/\/ Mixed GC. Will complete. That pinned region is now retained. The mixed gcs\n+        \/\/ will end here.\n+        wb.youngGC();\n+\n+        \/\/ The pinned region will be dropped from the retained candidates during the\n+        \/\/ Concurrent Start GC, leaving that region's TAMS broken.\n+        wb.g1RunConcurrentGC();\n+\n+        \/\/ Verification will find a lot of broken objects.\n+        wb.youngGC();\n+        System.out.println(dummy);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestDroppedRetainedTAMS.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-    final static MethodHandle foo = abi.downcallHandle(lookup.find(\"foo\").get(),\n+    final static MethodHandle foo = abi.downcallHandle(lookup.findOrThrow(\"foo\"),\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-                                                                   \"-Xlog:gc*,stringtable*=debug:gc.log\",\n+                                                                   \"-Xlog:gc*,stringtable*=debug,oopstorage+blocks=debug:gc.log\",\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestReclaimStringsLeaksMemory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,380 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/**\n+ * @test TestRegistersPushPopAtZGCLoadBarrierStub\n+ * @bug 8326541\n+ * @summary Test to verify that registers are saved and restored correctly based on\n+            the actual register usage length on aarch64 when entering load barrier stub.\n+ * @library \/test\/lib \/\n+ * @modules jdk.incubator.vector\n+ *\n+ * @requires vm.gc.ZGenerational & vm.debug\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @run driver gc.z.TestRegistersPushPopAtZGCLoadBarrierStub\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+class Inner {}\n+\n+class InnerFloat extends Inner {\n+    float data;\n+    public InnerFloat(float f) {\n+        data = f;\n+    }\n+}\n+\n+class InnerDouble extends Inner {\n+    double data;\n+    public InnerDouble(double f) {\n+        data = f;\n+    }\n+}\n+\n+class Outer {\n+    volatile Inner field;\n+    public Outer(Inner i) {\n+        field = i;\n+    }\n+}\n+\n+public class TestRegistersPushPopAtZGCLoadBarrierStub {\n+\n+    class Launcher {\n+        private final static int NUM = 1024;\n+        private final static int ITERATIONS = 20_000;\n+        private final static RandomGenerator RANDOM = RandomGeneratorFactory.getDefault().create(0);\n+        private final static Map<String, Runnable> TESTS;\n+\n+        private static float[] f_array;\n+        private static Outer f_outer;\n+        private static Outer d_outer;\n+\n+        static {\n+            f_array = new float[NUM];\n+            for (int i = 0; i < NUM; i++) {\n+                f_array[i] = RANDOM.nextFloat();\n+            }\n+\n+            InnerFloat f_inner = new InnerFloat(RANDOM.nextFloat());\n+            InnerDouble d_inner = new InnerDouble(RANDOM.nextDouble());\n+            f_outer = new Outer(f_inner);\n+            d_outer = new Outer(d_inner);\n+\n+            TESTS = new LinkedHashMap<>();\n+            TESTS.put(\"test_one_float_push_pop_at_load_barrier\", Launcher::test_one_float);\n+            TESTS.put(\"test_two_floats_push_pop_at_load_barrier\", Launcher::test_two_floats);\n+            TESTS.put(\"test_three_floats_push_pop_at_load_barrier\", Launcher::test_three_floats);\n+            TESTS.put(\"test_one_double_push_pop_at_load_barrier\", Launcher::test_one_double);\n+            TESTS.put(\"test_two_doubles_push_pop_at_load_barrier\", Launcher::test_two_doubles);\n+            TESTS.put(\"test_three_doubles_push_pop_at_load_barrier\", Launcher::test_three_doubles);\n+            TESTS.put(\"test_one_vector_128_push_pop_at_load_barrier\", Launcher::test_one_vector_128);\n+            TESTS.put(\"test_two_vectors_128_push_pop_at_load_barrier\", Launcher::test_two_vectors_128);\n+            TESTS.put(\"test_three_vectors_128_push_pop_at_load_barrier\", Launcher::test_three_vectors_128);\n+            TESTS.put(\"test_vector_max_push_pop_at_load_barrier\", Launcher::test_vector_max);\n+            TESTS.put(\"test_float_and_vector_push_pop_at_load_barrier\", Launcher::test_float_and_vector);\n+        }\n+\n+        static float test_one_float_push_pop_at_load_barrier(Outer outer, float f) {\n+            Inner inner = outer.field;\n+            return f + ((InnerFloat)inner).data;\n+        }\n+\n+        static float test_two_floats_push_pop_at_load_barrier(Outer outer, float f1, float f2) {\n+            Inner inner = outer.field;\n+            return f1 + f2 + ((InnerFloat)inner).data;\n+        }\n+\n+        static float test_three_floats_push_pop_at_load_barrier(Outer outer, float f1, float f2, float f3) {\n+            Inner inner = outer.field;\n+            return f1 + f2 + f3 + ((InnerFloat)inner).data;\n+        }\n+\n+        static double test_one_double_push_pop_at_load_barrier(Outer outer, double d) {\n+            Inner inner = outer.field;\n+            return d + ((InnerDouble)inner).data;\n+        }\n+\n+        static double test_two_doubles_push_pop_at_load_barrier(Outer outer, double d1, double d2) {\n+            Inner inner = outer.field;\n+            return d1 + d2 + ((InnerDouble)inner).data;\n+        }\n+\n+        static double test_three_doubles_push_pop_at_load_barrier(Outer outer, double d1, double d2, double d3) {\n+            Inner inner = outer.field;\n+            return d1 + d2 + d3 + ((InnerDouble)inner).data;\n+        }\n+\n+        static void test_one_vector_128_push_pop_at_load_barrier(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_128;\n+\n+            FloatVector av = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av = av.add(bv).add(value);\n+            }\n+        }\n+\n+        static void test_two_vectors_128_push_pop_at_load_barrier(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_128;\n+\n+            FloatVector av1 = FloatVector.zero(float_species);\n+            FloatVector av2 = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av1 = av1.add(bv).add(value);\n+                av2 = av2.add(av1);\n+            }\n+        }\n+\n+        static void test_three_vectors_128_push_pop_at_load_barrier(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_128;\n+\n+            FloatVector av1 = FloatVector.zero(float_species);\n+            FloatVector av2 = FloatVector.zero(float_species);\n+            FloatVector av3 = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av1 = av1.add(bv).add(value);\n+                av2 = av2.add(av1);\n+                av3 = av3.add(av2);\n+            }\n+        }\n+\n+        static void test_vector_max_push_pop_at_load_barrier(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_MAX;\n+\n+            FloatVector av = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av = av.add(bv).add(value);\n+            }\n+        }\n+\n+        static void test_float_and_vector_push_pop_at_load_barrier(float[] b, Outer outer, float f) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_MAX;\n+\n+            FloatVector av = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data + f;\n+                av = av.add(bv).add(value);\n+            }\n+        }\n+\n+        static void test_one_float() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_one_float_push_pop_at_load_barrier(f_outer, RANDOM.nextFloat());\n+            }\n+        }\n+\n+        static void test_two_floats() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_two_floats_push_pop_at_load_barrier(f_outer, RANDOM.nextFloat(), RANDOM.nextFloat());\n+            }\n+        }\n+\n+        static void test_three_floats() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_three_floats_push_pop_at_load_barrier(f_outer, RANDOM.nextFloat(), RANDOM.nextFloat(), RANDOM.nextFloat());\n+            }\n+        }\n+\n+        static void test_one_double() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_one_double_push_pop_at_load_barrier(d_outer, RANDOM.nextDouble());\n+            }\n+        }\n+\n+        static void test_two_doubles() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_two_doubles_push_pop_at_load_barrier(d_outer, RANDOM.nextDouble(), RANDOM.nextDouble());\n+            }\n+        }\n+\n+        static void test_three_doubles() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_three_doubles_push_pop_at_load_barrier(d_outer, RANDOM.nextDouble(), RANDOM.nextDouble(), RANDOM.nextDouble());\n+            }\n+        }\n+\n+        static void test_one_vector_128() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_one_vector_128_push_pop_at_load_barrier(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_two_vectors_128() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_two_vectors_128_push_pop_at_load_barrier(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_three_vectors_128() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_three_vectors_128_push_pop_at_load_barrier(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_vector_max() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_vector_max_push_pop_at_load_barrier(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_float_and_vector() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_float_and_vector_push_pop_at_load_barrier(f_array, f_outer, RANDOM.nextFloat());\n+            }\n+        }\n+\n+        public static void main(String args[]) {\n+            Runnable r = TESTS.get(args[0]);\n+            r.run();\n+        }\n+    }\n+\n+    static boolean containOnlyOneOccuranceOfKeyword(String text, String keyword) {\n+        int firstIndex = text.indexOf(keyword);\n+        int lastIndex = text.lastIndexOf(keyword);\n+        return firstIndex != -1 && firstIndex == lastIndex;\n+    }\n+\n+    \/\/ Check that registers are pushed and poped with correct register type and number\n+    static void checkPushPopRegNumberAndType(String stdout, String keyword, String expected_freg_type,\n+                                             int expected_number_of_fregs) throws Exception {\n+        String expected = keyword + expected_number_of_fregs + \" \" + expected_freg_type + \" registers\";\n+\n+        String regex = keyword + \"(\\\\d+) \" + expected_freg_type + \" registers\";\n+        Pattern p = Pattern.compile(regex);\n+        Matcher m = p.matcher(stdout);\n+\n+        if (m.find()) {\n+            String found = m.group();\n+            Asserts.assertEquals(found, expected, \"found '\" + found + \"' but should print '\" + expected + \"'\");\n+        } else {\n+            throw new RuntimeException(\"'\" + regex + \"' is not found in stdout\");\n+        }\n+\n+        if (m.find()) {\n+            throw new RuntimeException(\"Stdout is expected to contain only one occurance of '\" + regex +\n+                                       \"'. Found another occurance: '\" + m.group() + \"'\");\n+        }\n+    }\n+\n+    static String launchJavaTestProcess(String test_name) throws Exception {\n+        ArrayList<String> command = new ArrayList<String>();\n+        command.add(\"-Xbatch\");\n+        command.add(\"-XX:LoopUnrollLimit=0\");\n+        command.add(\"-XX:-UseOnStackReplacement\");\n+        command.add(\"-XX:-TieredCompilation\");\n+        command.add(\"-XX:+UseZGC\");\n+        command.add(\"-XX:+ZGenerational\");\n+        command.add(\"--add-modules=jdk.incubator.vector\");\n+        command.add(\"-XX:CompileCommand=print,\" +  Launcher.class.getName() + \"::\" + test_name);\n+        command.add(Launcher.class.getName());\n+        command.add(test_name);\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output.getStdout();\n+    }\n+\n+    static void run_test(String test_name, String expected_freg_type, int expected_number_of_fregs,\n+                         String expected_vector_reg_type, int expected_number_of_vector_regs) throws Exception {\n+        String stdout = launchJavaTestProcess(test_name);\n+\n+        String keyword = \"push_fp: \";\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_fregs);\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_vector_reg_type, expected_number_of_vector_regs);\n+\n+        keyword = \"pop_fp: \";\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_fregs);\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_vector_reg_type, expected_number_of_vector_regs);\n+    }\n+\n+    static void run_test(String test_name, String expected_freg_type, int expected_number_of_fregs) throws Exception {\n+        String stdout = launchJavaTestProcess(test_name);\n+\n+        String keyword = \"push_fp: \";\n+        if (!containOnlyOneOccuranceOfKeyword(stdout, keyword)) {\n+            throw new RuntimeException(\"Stdout is expected to contain only one occurance of keyword: \" + \"'\" + keyword + \"'\");\n+        }\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_fregs);\n+\n+        keyword = \"pop_fp: \";\n+        if (!containOnlyOneOccuranceOfKeyword(stdout, keyword)) {\n+            throw new RuntimeException(\"Stdout is expected to contain only one occurance of keyword: \" + \"'\" + keyword + \"'\");\n+        }\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_fregs);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String vector_max_reg_type;\n+        if (VectorShape.S_Max_BIT.vectorBitSize() > 128) {\n+            vector_max_reg_type = \"SVE\";\n+        } else {\n+            vector_max_reg_type = \"Neon\";\n+        }\n+        run_test(\"test_one_float_push_pop_at_load_barrier\", \"fp\", 1);\n+        run_test(\"test_two_floats_push_pop_at_load_barrier\", \"fp\", 2);\n+        run_test(\"test_three_floats_push_pop_at_load_barrier\", \"fp\", 3);\n+        run_test(\"test_one_double_push_pop_at_load_barrier\", \"fp\", 1);\n+        run_test(\"test_two_doubles_push_pop_at_load_barrier\", \"fp\", 2);\n+        run_test(\"test_three_doubles_push_pop_at_load_barrier\", \"fp\", 3);\n+        run_test(\"test_one_vector_128_push_pop_at_load_barrier\", \"Neon\", 1);\n+        run_test(\"test_two_vectors_128_push_pop_at_load_barrier\", \"Neon\", 2);\n+        run_test(\"test_three_vectors_128_push_pop_at_load_barrier\", \"Neon\", 3);\n+        run_test(\"test_vector_max_push_pop_at_load_barrier\", vector_max_reg_type, 1);\n+        run_test(\"test_float_and_vector_push_pop_at_load_barrier\", \"fp\", 1, vector_max_reg_type, 1);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestRegistersPushPopAtZGCLoadBarrierStub.java","additions":380,"deletions":0,"binary":false,"changes":380,"status":"added"},{"patch":"@@ -59,0 +59,2 @@\n+            {\"UseNotificationThread\", \"true\"},\n+            {\"PreserveAllAnnotations\", \"true\"},\n@@ -60,0 +62,1 @@\n+            {\"UseEmptySlotsInSupers\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * @test\n+ * @summary Tests that recursive locking doesn't cause excessive native memory usage\n+ * @library \/test\/lib\n+ * @run driver TestRecursiveMonitorChurn\n+ *\/\n+public class TestRecursiveMonitorChurn {\n+    static class Monitor {\n+        public static volatile int i, j;\n+        synchronized void doSomething() {\n+            i++;\n+            doSomethingElse();\n+        }\n+        synchronized void doSomethingElse() {\n+            j++;\n+        }\n+    }\n+\n+    public static volatile Monitor monitor;\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 1 && args[0].equals(\"test\")) {\n+            \/\/ The actual test, in a forked JVM.\n+            for (int i = 0; i < 100000; i++) {\n+                monitor = new Monitor();\n+                monitor.doSomething();\n+            }\n+            System.out.println(\"i + j = \" + (Monitor.i + Monitor.j));\n+        } else {\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                    \"-Xmx100M\", \"-XX:AsyncDeflationInterval=0\", \"-XX:GuaranteedAsyncDeflationInterval=0\",\n+                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\",\n+                    \"TestRecursiveMonitorChurn\",\n+                    \"test\");\n+            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            output.reportDiagnosticSummary();\n+\n+            output.shouldHaveExitValue(0);\n+\n+            \/\/ We want to see, in the final NMT printout, a committed object monitor size that is reasonably low.\n+            \/\/ Like this:\n+            \/\/ -           Object Monitors (reserved=208, committed=208)\n+            \/\/                             (malloc=208 #1) (at peak)\n+            \/\/\n+            \/\/ Without recursive locking support, this would look more like this:\n+            \/\/ -           Object Monitors (reserved=20800624, committed=20800624)\n+            \/\/                             (malloc=20800624 #100003) (at peak)\n+\n+            Pattern pat = Pattern.compile(\"- *Object Monitors.*reserved=(\\\\d+), committed=(\\\\d+).*\");\n+            for (String line : output.asLines()) {\n+                Matcher m = pat.matcher(line);\n+                if (m.matches()) {\n+                    long reserved = Long.parseLong(m.group(1));\n+                    long committed = Long.parseLong(m.group(2));\n+                    System.out.println(\">>>>> \" + line + \": \" + reserved + \" - \" + committed);\n+                    if (committed > 1000) {\n+                        throw new RuntimeException(\"Allocated too many monitors\");\n+                    }\n+                    return;\n+                }\n+            }\n+            throw new RuntimeException(\"Did not find expected NMT output\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/locking\/TestRecursiveMonitorChurn.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8149991\n- * @summary safepoint+cleanup=info should have output from the code\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver SafepointCleanupTest\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class SafepointCleanupTest {\n-    static void analyzeOutputOn(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"[safepoint,cleanup]\");\n-        output.shouldContain(\"safepoint cleanup tasks\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    static void analyzeOutputOff(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"[safepoint,cleanup]\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:safepoint+cleanup=info\",\n-                                                                             InnerClass.class.getName());\n-        analyzeOutputOn(pb);\n-\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:safepoint+cleanup=off\",\n-                                                              InnerClass.class.getName());\n-        analyzeOutputOff(pb);\n-    }\n-\n-    public static class InnerClass {\n-        public static void main(String[] args) throws Exception {\n-            System.out.println(\"Safepoint Cleanup test\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/SafepointCleanupTest.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -25,0 +28,3 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n@@ -26,0 +32,16 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * Tests that JNI monitors work correctly with virtual threads,\n+ * There are multiple test scenarios that we check using unified logging output\n+ * (both positive and negative tests). Each test case is handled by its own @-test\n+ * definition so that we can run each sub-test independently.\n+ *\n+ * The original bug was only discovered because the ForkJoinPool worker thread terminated\n+ * and trigerred an assertion failure. So we use a custom scheduler to give us control.\n+ *\/\n@@ -28,2 +50,3 @@\n- * @test JNIMonitor\n- * @summary Tests that JNI monitors work correctly with virtual threads\n+ * @test id=normal\n+ * @bug 8327743\n+ * @summary Normal lock then unlock\n@@ -31,2 +54,53 @@\n- * @compile JNIMonitor.java\n- * @run main\/native\/othervm JNIMonitor\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor Normal\n+ *\/\n+\n+\/**\n+ * @test id=multiNormal\n+ * @bug 8327743\n+ * @summary Normal lock then unlock by multiple threads\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor MultiNormal\n+ *\/\n+\n+\/**\n+ * @test id=missingUnlock\n+ * @bug 8327743\n+ * @summary Don't do the unlock and exit normally\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor MissingUnlock\n+ *\/\n+\n+\/**\n+ * @test id=multiMissingUnlock\n+ * @bug 8327743\n+ * @summary Don't do the unlock and exit normally, by multiple threads\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor MultiMissingUnlock\n+ *\/\n+\n+\/**\n+ * @test id=missingUnlockWithThrow\n+ * @bug 8327743\n+ * @summary Don't do the unlock and exit by throwing\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor MissingUnlockWithThrow\n+ *\/\n+\n+\/**\n+ * @test id=multiMissingUnlockWithThrow\n+ * @bug 8327743\n+ * @summary Don't do the unlock and exit by throwing, by multiple threads\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor MultiMissingUnlockWithThrow\n@@ -37,0 +111,75 @@\n+    public static void main(String[] args) throws Exception {\n+        String test = args[0];\n+        String[] cmdArgs = new String[] {\n+            \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+            \/\/ Grant access to ThreadBuilders$VirtualThreadBuilder\n+            \"--add-opens=java.base\/java.lang=ALL-UNNAMED\",\n+            \/\/ Enable the JNI warning\n+            \"-Xcheck:jni\",\n+            \"-Xlog:jni=debug\",\n+            \/\/ Enable thread termination logging as a visual cross-check\n+            \"-Xlog:thread+os=info\",\n+            \"JNIMonitor$\" + test,\n+        };\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(cmdArgs);\n+        oa.shouldHaveExitValue(0);\n+        oa.stdoutShouldMatch(terminated);\n+\n+        switch(test) {\n+            case \"Normal\":\n+            case \"MultiNormal\":\n+                oa.stdoutShouldNotMatch(stillLocked);\n+                break;\n+            case \"MissingUnlock\":\n+                oa.stdoutShouldMatch(stillLocked);\n+                break;\n+            case \"MultiMissingUnlock\":\n+                parseOutputForPattern(oa.stdoutAsLines(), stillLocked, MULTI_THREAD_COUNT);\n+                break;\n+            case \"MissingUnlockWithThrow\":\n+                oa.stdoutShouldMatch(stillLocked);\n+                oa.stderrShouldContain(throwMsg);\n+                break;\n+            case \"MultiMissingUnlockWithThrow\":\n+                parseOutputForPattern(oa.stdoutAsLines(), stillLocked, MULTI_THREAD_COUNT);\n+                parseOutputForPattern(oa.stderrAsLines(), throwMsg, MULTI_THREAD_COUNT);\n+                break;\n+\n+            default: throw new Error(\"Unknown arg: \" + args[0]);\n+        }\n+        oa.reportDiagnosticSummary();\n+    }\n+\n+    \/\/ The number of threads for a multi tests. Arbitrarily chosen to be > 1 but small\n+    \/\/ enough to not waste too much time.\n+    static final int MULTI_THREAD_COUNT = 5;\n+\n+    \/\/ The logging message for leaving a monitor JNI locked has the form\n+    \/\/   [0.187s][debug][jni] VirtualThread (tid: 28, carrier id: 29) exiting with Objects still locked by JNI MonitorEnter.\n+    \/\/ but if the test is run with other logging options then whitespace may get introduced in the\n+    \/\/ log decorator sections, so ignore those.\n+    static final String stillLocked = \"VirtualThread \\\\(tid:.*exiting with Objects still locked by JNI MonitorEnter\";\n+    \/\/ The carrier thread termination logging has the form:\n+    \/\/ [1.394s][info][os,thread] JavaThread exiting (name: \"pool-1-thread-1\", tid: 3090592).\n+    static final String terminated = \"JavaThread exiting \\\\(name: \\\"pool-1-thread-1\\\"\";\n+\n+    static final String throwMsg = \"Terminating via exception as requested\";\n+\n+    \/\/ Check the process logging output for the given pattern to see if the expected number of\n+    \/\/ lines are found.\n+    private static void parseOutputForPattern(List<String> lines, String pattern, int expected) {\n+        Pattern p = Pattern.compile(pattern);\n+        int found = 0;\n+        for (String line : lines) {\n+            Matcher m = p.matcher(line);\n+            if (m.find()) {\n+                found++;\n+            }\n+        }\n+        if (found != expected) {\n+            throw new RuntimeException(\"Checking for pattern \\\"\" + pattern + \"\\\": expected \"\n+                                       + expected + \" but found \" + found);\n+        }\n+    }\n+\n+\n@@ -40,3 +189,0 @@\n-    static {\n-        System.loadLibrary(\"JNIMonitor\");\n-    }\n@@ -44,4 +190,15 @@\n-    public static void main(String[] args) throws Throwable {\n-        final Object monitor = new Object();\n-        final AtomicReference<Throwable> exception = new AtomicReference();\n-        Thread.ofVirtual().start(() -> {\n+    \/\/ Isolate the native library loading to the actual test cases, not the class that\n+    \/\/ jtreg Driver will load and execute.\n+    static class TestBase {\n+\n+        static {\n+            System.loadLibrary(\"JNIMonitor\");\n+        }\n+\n+        \/\/ This gives us a way to control the scheduler used for our virtual threads. The test\n+        \/\/ only works as intended when the virtual threads run on the same carrier thread (as\n+        \/\/ that carrier maintains ownership of the monitor if the virtual thread fails to unlock it).\n+        \/\/ The original issue was also only discovered due to the carrier thread terminating\n+        \/\/ unexpectedly, so we can force that condition too by shutting down our custom scheduler.\n+        private static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n+            Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n@@ -49,7 +206,45 @@\n-                int res = monitorEnter(monitor);\n-                Asserts.assertTrue(res == 0, \"monitorEnter should return 0.\");\n-                Thread.yield();\n-                res = monitorExit(monitor);\n-                Asserts.assertTrue(res == 0, \"monitorExit should return 0.\");\n-            } catch (Throwable t) {\n-                exception.set(t);\n+                Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+                Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+                ctor.setAccessible(true);\n+                return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+            } catch (InvocationTargetException e) {\n+                Throwable cause = e.getCause();\n+                if (cause instanceof RuntimeException re) {\n+                    throw re;\n+                }\n+                throw new RuntimeException(e);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static void runTest(int nThreads, boolean skipUnlock, boolean throwOnExit) throws Throwable {\n+            final Object monitor = new Object();\n+            final AtomicReference<Throwable> exception = new AtomicReference();\n+            \/\/ Ensure all our VT's operate of the same carrier, sequentially.\n+            ExecutorService scheduler = Executors.newSingleThreadExecutor();\n+            ThreadFactory factory = virtualThreadBuilder(scheduler).factory();\n+            for (int i = 0 ; i < nThreads; i++) {\n+                Thread th = factory.newThread(() -> {\n+                        try {\n+                            int res = monitorEnter(monitor);\n+                            Asserts.assertTrue(res == 0, \"monitorEnter should return 0.\");\n+                            Asserts.assertTrue(Thread.holdsLock(monitor), \"monitor should be owned\");\n+                            Thread.yield();\n+                            if (!skipUnlock) {\n+                                res = monitorExit(monitor);\n+                                Asserts.assertTrue(res == 0, \"monitorExit should return 0.\");\n+                                Asserts.assertFalse(Thread.holdsLock(monitor), \"monitor should be unowned\");\n+                            }\n+                        } catch (Throwable t) {\n+                            exception.set(t);\n+                        }\n+                        if (throwOnExit) {\n+                            throw new RuntimeException(throwMsg);\n+                        }\n+                    });\n+                th.start();\n+                th.join();\n+                if (exception.get() != null) {\n+                    throw exception.get();\n+                }\n@@ -57,3 +252,10 @@\n-        }).join();\n-        if (exception.get() != null) {\n-            throw exception.get();\n+            \/\/ Now force carrier thread to shutdown.\n+            scheduler.shutdown();\n+        }\n+    }\n+\n+    \/\/ These are the actual test case classes that get exec'd.\n+\n+    static class Normal extends TestBase {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(1, false, false);\n@@ -62,0 +264,31 @@\n+\n+    static class MultiNormal extends TestBase {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(MULTI_THREAD_COUNT, false, false);\n+        }\n+    }\n+\n+    static class MissingUnlock extends TestBase  {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(1, true, false);\n+        }\n+    }\n+\n+    static class MultiMissingUnlock extends TestBase {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(MULTI_THREAD_COUNT, true, false);\n+        }\n+    }\n+\n+    static class MissingUnlockWithThrow extends TestBase {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(1, true, true);\n+        }\n+    }\n+\n+    static class MultiMissingUnlockWithThrow extends TestBase {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(MULTI_THREAD_COUNT, true, true);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/JNIMonitor\/JNIMonitor.java","additions":255,"deletions":22,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+    static int t_num = 0;\n@@ -81,1 +82,2 @@\n-            Thread.currentThread().setName(\"Worker-Thread\");\n+            Thread.currentThread().setName((isVirtual ? \"Virtual-\" : \"\") + \"Worker-Thread-\" + t_num);\n+            t_num++;\n@@ -84,0 +86,3 @@\n+                System.out.println(\"Thread doing JNI call: \"\n+                                   + Thread.currentThread().getName());\n+\n@@ -95,1 +100,3 @@\n-            System.out.println(\"Main starting worker thread.\");\n+            System.out.print(\"Main starting worker thread for \");\n+            System.out.print(isVirtual ? \"virtual \" : \"non-virtual \");\n+            System.out.println(jni ? \"JNI\" : \"non-JNI\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoTest.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -56,2 +56,0 @@\n-    native static int waitsToEnter();\n-    native static int waitsToBeNotified();\n@@ -59,0 +57,2 @@\n+    native static void ensureBlockedOnEnter(Thread thread);\n+    native static void ensureWaitingToBeNotified(Thread thread);\n@@ -90,4 +90,3 @@\n-            threads[i] = startTask(i, new WaitingTask(), isVirtual, \"Waiting\");\n-        }\n-        while (waitsToBeNotified() < NUMBER_OF_WAITING_THREADS) {\n-            sleep(1);\n+            Thread thread = startTask(i, new WaitingTask(), isVirtual, \"Waiting\");\n+            ensureWaitingToBeNotified(thread);\n+            threads[i] = thread;\n@@ -102,4 +101,3 @@\n-            threads[i] = startTask(i, new EnteringTask(), isVirtual, \"Entering\");\n-        }\n-        while (waitsToEnter() < NUMBER_OF_ENTERING_THREADS) {\n-            sleep(1);\n+            Thread thread = startTask(i, new EnteringTask(), isVirtual, \"Entering\");\n+            ensureBlockedOnEnter(thread);\n+            threads[i] = thread;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ObjectMonitorUsage\/ObjectMonitorUsage.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-static jrawMonitorID event_lock = nullptr;\n@@ -38,2 +37,0 @@\n-static int waits_to_enter = 0;\n-static int waits_to_be_notified = 0;\n@@ -56,36 +53,0 @@\n-JNIEXPORT void JNICALL\n-MonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jobject monitor) {\n-  RawMonitorLocker rml(jvmti, jni, event_lock);\n-  if (is_tested_monitor(jni, monitor)) {\n-    waits_to_enter++;\n-    log_event(jvmti, jni, thread, \"MonitorContendedEnter\", waits_to_enter);\n-  }\n-}\n-\n-JNIEXPORT void JNICALL\n-MonitorContendedEntered(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jobject monitor) {\n-  RawMonitorLocker rml(jvmti, jni, event_lock);\n-  if (is_tested_monitor(jni, monitor)) {\n-    waits_to_enter--;\n-    log_event(jvmti, jni, thread, \"MonitorContendedEntered\", waits_to_enter);\n-  }\n-}\n-\n-JNIEXPORT void JNICALL\n-MonitorWait(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jobject monitor, jlong timeout) {\n-  RawMonitorLocker rml(jvmti, jni, event_lock);\n-  if (is_tested_monitor(jni, monitor)) {\n-    waits_to_be_notified++;\n-    log_event(jvmti, jni, thread, \"MonitorWait\", waits_to_be_notified);\n-  }\n-}\n-\n-JNIEXPORT void JNICALL\n-MonitorWaited(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jobject monitor, jboolean timed_out) {\n-  RawMonitorLocker rml(jvmti, jni, event_lock);\n-  if (is_tested_monitor(jni, monitor)) {\n-    waits_to_be_notified--;\n-    log_event(jvmti, jni, thread, \"MonitorWaited\", waits_to_be_notified);\n-  }\n-}\n-\n@@ -96,1 +57,0 @@\n-  jvmtiEventCallbacks callbacks;\n@@ -119,11 +79,0 @@\n-  memset(&callbacks, 0, sizeof(callbacks));\n-  callbacks.MonitorContendedEnter   = &MonitorContendedEnter;\n-  callbacks.MonitorContendedEntered = &MonitorContendedEntered;\n-  callbacks.MonitorWait = &MonitorWait;\n-  callbacks.MonitorWaited = &MonitorWaited;\n-\n-  err = jvmti->SetEventCallbacks(&callbacks, sizeof(jvmtiEventCallbacks));\n-  check_jvmti_error(err, \"Agent_Initialize: error in JVMTI SetEventCallbacks\");\n-\n-  event_lock = create_raw_monitor(jvmti, \"Events Monitor\");\n-\n@@ -219,5 +168,0 @@\n-  jvmtiError err;\n-  jvmtiEventMode event_mode = (monitor != nullptr) ? JVMTI_ENABLE : JVMTI_DISABLE;\n-\n-  RawMonitorLocker rml(jvmti, jni, event_lock);\n-\n@@ -228,14 +172,0 @@\n-  waits_to_enter = 0;\n-  waits_to_be_notified = 0;\n-\n-  err = jvmti->SetEventNotificationMode(event_mode, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr);\n-  check_jvmti_status(jni, err, \"setTestedMonitor: error in JVMTI SetEventNotificationMode #1\");\n-\n-  err = jvmti->SetEventNotificationMode(event_mode, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr);\n-  check_jvmti_status(jni, err, \"setTestedMonitor: error in JVMTI SetEventNotificationMode #2\");\n-\n-  err = jvmti->SetEventNotificationMode(event_mode, JVMTI_EVENT_MONITOR_WAIT, nullptr);\n-  check_jvmti_status(jni, err, \"setTestedMonitor: error in JVMTI SetEventNotificationMode #3\");\n-\n-  err = jvmti->SetEventNotificationMode(event_mode, JVMTI_EVENT_MONITOR_WAITED, nullptr);\n-  check_jvmti_status(jni, err, \"setTestedMonitor: error in JVMTI SetEventNotificationMode #4\");\n@@ -244,4 +174,3 @@\n-JNIEXPORT jint JNICALL\n-Java_ObjectMonitorUsage_waitsToEnter(JNIEnv *jni, jclass cls) {\n-  RawMonitorLocker rml(jvmti, jni, event_lock);\n-  return waits_to_enter;\n+JNIEXPORT void JNICALL\n+Java_ObjectMonitorUsage_ensureBlockedOnEnter(JNIEnv *jni, jclass cls, jthread thread) {\n+  wait_for_state(jvmti, jni, thread, JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER);\n@@ -250,4 +179,3 @@\n-JNIEXPORT jint JNICALL\n-Java_ObjectMonitorUsage_waitsToBeNotified(JNIEnv *jni, jclass cls) {\n-  RawMonitorLocker rml(jvmti, jni, event_lock);\n-  return waits_to_be_notified;\n+JNIEXPORT void JNICALL\n+Java_ObjectMonitorUsage_ensureWaitingToBeNotified(JNIEnv *jni, jclass cls, jthread thread) {\n+  wait_for_state(jvmti, jni, thread, JVMTI_THREAD_STATE_WAITING_INDEFINITELY);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ObjectMonitorUsage\/libObjectMonitorUsage.cpp","additions":6,"deletions":78,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -219,5 +219,1 @@\n-#ifdef WINDOWS\n-  Sleep(1000);\n-#else\n-  sleep(1);\n-#endif\n+  sleep_sec(1);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResumeAll\/libSuspendResumeAll.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                \"field TenuredGeneration _the_space TenuredSpace*\",\n+                \"field TenuredGeneration _the_space ContiguousSpace*\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.examples;\n+\n+import compiler.lib.ir_framework.*;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.MethodHandles;\n+\n+\/**\n+ * @test\n+ * @bug 8330153\n+ * @summary Example test that illustrates the use of the IR test framework for\n+ *          verification of late-expanded GC barriers.\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.ZGenerational\n+ * @run driver ir_framework.examples.GCBarrierIRExample\n+ *\/\n+\n+public class GCBarrierIRExample {\n+\n+    static class Outer {\n+        Object f;\n+    }\n+\n+    static final VarHandle fVarHandle;\n+    static {\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        try {\n+            fVarHandle = l.findVarHandle(Outer.class, \"f\", Object.class);\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+    }\n+    static Outer o = new Outer();\n+    static Object oldVal = new Object();\n+    static Object newVal = new Object();\n+\n+    public static void main(String[] args) {\n+        \/\/ These rules apply only to collectors that expand barriers at code\n+        \/\/ emission, such as ZGC. Because the collector selection flags are not\n+        \/\/ whitelisted (see IR framework's README.md file), the user (as opposed\n+        \/\/ to jtreg) needs to set these flags here.\n+        TestFramework.runWithFlags(\"-XX:+UseZGC\", \"-XX:+ZGenerational\");\n+    }\n+\n+    @Test\n+    \/\/ IR rules can be used to verify collector-specific barrier info (in this\n+    \/\/ case, that a ZGC barrier corresponds to a strong OOP reference). Barrier\n+    \/\/ info can only be verified after matching, e.g. at the FINAL_CODE phase.\n+    @IR(counts = {IRNode.Z_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG, \"strong\", \"1\"},\n+        phase  = CompilePhase.FINAL_CODE)\n+    static boolean testBarrierOfCompareAndSwap() {\n+        return fVarHandle.compareAndSet(o, oldVal, newVal);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/GCBarrierIRExample.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large001\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large002\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large003\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large004\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large005\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+IgnoreUnrecognizedVMOptions -XX:-ScavengeBeforeFullGC gc.gctests.WeakReference.weak006.weak006 -t 1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+IgnoreUnrecognizedVMOptions gc.gctests.WeakReference.weak006.weak006 -t 1\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak006\/weak006.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-        Map<String,? extends com.sun.jdi.connect.Connector.Argument> cArgs1 = initConnector(argHandler.getTransportPort());\n@@ -99,0 +98,6 @@\n+        \/\/ argHandler.getTransportPort() returns a free port (different from the port allocated by startListen(cArgs2))\n+        Map<String,? extends com.sun.jdi.connect.Connector.Argument> cArgs1 = initConnector(argHandler.getTransportPort());\n+\n+        log.display(\"cArgs1: \" + cArgs1);\n+        log.display(\"cArgs2: \" + cArgs2);\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/stopListening\/stoplis001.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/stopListening\/stoplis001\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -43,3 +43,0 @@\n- *     NOTE: this test is tagged \"nonconcurrent\" because it uses the default\n- *     \"javadebug\" shmem file, as do some other tests.\n- *\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/stopListening\/stoplis001\/TestDescription.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -371,1 +371,7 @@\n-        long comp = Blocker.begin();\n+        if (!Thread.currentThread().isVirtual()) {\n+            wait0(timeoutMillis);\n+            return;\n+        }\n+\n+        \/\/ virtual thread waiting\n+        boolean attempted = Blocker.begin();\n@@ -375,3 +381,2 @@\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual())\n-                thread.getAndClearInterrupt();\n+            \/\/ virtual thread's interrupt status needs to be cleared\n+            Thread.currentThread().getAndClearInterrupt();\n@@ -380,1 +385,1 @@\n-            Blocker.end(comp);\n+            Blocker.end(attempted);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/bcinstr\/BI04\/bi04t002\/newclass02\/java.base\/java\/lang\/Object.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Rectangle;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.BufferedImage;\n+\n+\/*\n+ * @test\n+ * @bug 8328896\n+ * @summary test that using very large font sizes used don't break later uses\n+ *\/\n+\n+public class ExtremeFontSizeTest {\n+\n+    static BufferedImage bi = new BufferedImage(1,1,1);\n+    static Graphics2D g2d = bi.createGraphics();\n+    static String testString = \"M\";\n+    static Font font = new Font(\"SansSerif\", Font.PLAIN, 12);\n+    static int fontSize = 0;\n+    static boolean failed = false;\n+    static int[] fontSizes = { 10, 12, 1000, 2000, 20000, 100000, 8 };\n+    static double[] scales = { 1.0, 900.0};\n+    static boolean[] fms = { false, true };\n+\n+    public static void main(String[] args) {\n+\n+        \/* run tests validating bounds etc are non-zero\n+         * then run with extreme scales for which zero is allowed - but not required\n+         * then run the first tests again to be sure they are still reasonable.\n+        *\/\n+        runTests();\n+        test(5_000_000, 10_000, false, testString, false);\n+        test(5_000_000, 10_000, true, testString, false);\n+        test(0, 0.00000001, false, testString, false);\n+        runTests();\n+\n+        if (failed) {\n+            throw new RuntimeException(\"Test failed. Check stdout log.\");\n+        }\n+    }\n+\n+    static void runTests() {\n+        for (int fontSize : fontSizes) {\n+            for (double scale : scales) {\n+                for (boolean fm : fms) {\n+                    test(fontSize, scale, fm, testString, true);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void test(int size, double scale, boolean fm, String str, boolean checkAll) {\n+\n+        AffineTransform at = AffineTransform.getScaleInstance(scale, scale);\n+        FontRenderContext frc = new FontRenderContext(at, false, fm);\n+        font = font.deriveFont((float)size);\n+        g2d.setTransform(at);\n+        g2d.setFont(font);\n+        FontMetrics metrics = g2d.getFontMetrics();\n+        int height = metrics.getHeight();\n+        double width = font.getStringBounds(str, frc).getWidth();\n+\n+        GlyphVector gv = font.createGlyphVector(frc, str.toCharArray());\n+        Rectangle pixelBounds = gv.getPixelBounds(frc, 0, 0);\n+        Rectangle2D visualBounds = gv.getVisualBounds();\n+\n+        System.out.println(\"Test parameters: size=\"+size+\" scale=\"+scale+\" fm=\"+fm+\" str=\"+str);\n+        System.out.println(\"font height=\"+metrics.getHeight());\n+        System.out.println(\"string bounds width=\"+width);\n+        System.out.println(\"GlyphVector Pixel Bounds=\"+ pixelBounds);\n+        System.out.println(\"GlyphVector Visual Bounds=\"+ visualBounds);\n+\n+\n+        if (height < 0 || width < 0 || pixelBounds.getWidth() < 0 || visualBounds.getWidth() < 0) {\n+            failed = true;\n+            System.out.println(\" *** Unexpected negative size reported  *** \");\n+         }\n+         if (!checkAll) {\n+            System.out.println();\n+            return;\n+        }\n+\n+        if (height == 0 || width == 0 || (pixelBounds.isEmpty()) || visualBounds.isEmpty() ) {\n+            failed = true;\n+            System.out.println(\"Pixel bounds empty=\"+pixelBounds.isEmpty());\n+            System.out.println(\"Visual bounds empty=\"+visualBounds.isEmpty());\n+            System.out.println(\" *** RESULTS NOT AS EXPECTED  *** \");\n+        }\n+        System.out.println();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/FontMetrics\/ExtremeFontSizeTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,12 +24,9 @@\n-\/*\n-  @test\n-  @bug 4236095\n-  @summary  Confirm that the you get three pages of output, one\n-            each in portrait, landscape, and reverse landscape\n-            orientations.\n-  @key printer\n-  @run main\/manual Orient\n-*\/\n-\n-\n-\/\/*** global search and replace Orient with name of the test ***\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.print.Book;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n@@ -37,4 +34,10 @@\n-\/**\n- * Orient.java\n- *\n- * summary:\n+\/*\n+ * @test\n+ * @bug 4236095\n+ * @summary  Confirm that you get three pages of output, one\n+ *           each in portrait, landscape and reverse landscape\n+ *           orientations.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @key printer\n+ * @run main\/manual Orient\n@@ -42,9 +45,0 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.geom.*;\n-import java.awt.print.*;\n-\n-\/\/ This test is a \"main\" test as applets would need Runtime permission\n-\/\/ \"queuePrintJob\".\n-\n@@ -52,0 +46,3 @@\n+    private static final String INSTRUCTIONS =\n+            \"\"\"\n+             This test will automatically initiate a print.\n@@ -53,3 +50,5 @@\n-   private static void init()\n-    {\n-        \/\/*** Create instructions for the user here ***\n+             A passing test will print three pages each containing a large oval\n+             with the text describing the orientation: PORTRAIT, LANDSCAPE\n+             or REVERSE_LANDSCAPE, inside of it. The first page will\n+             be emitted in portrait orientation, the second page in landscape\n+             orientation and the third page in reverse-landscape orientation.\n@@ -57,20 +56,2 @@\n-        String[] instructions =\n-        {\n-         \"On-screen inspection is not possible for this printing-specific\",\n-         \"test therefore its only output is three printed pages.\",\n-         \"To be able to run this test it is required to have a default\",\n-         \"printer configured in your user environment.\",\n-         \"\",\n-         \"Visual inspection of the printed page is needed. A passing\",\n-         \"test will print three pages each containing a large oval \",\n-         \"with the text describing the orientation: PORTRAIT, LANDSCAPE\",\n-         \"or REVERSE_LANDSCAPE, inside of it. The first page will \",\n-         \"be emitted in portait orientation, the second page in landscape \",\n-         \"orientation and the third page in reverse-landscape orientation. \",\n-         \"On each page the oval will be wholly within the imageable area \",\n-         \"of the page. In a failing test the oval on the third page \",\n-         \"will be clipped against the imageable area.\",\n-         \"Axes will indicate the direction of increasing X and Y\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n+             On each page the oval will be wholly within the imageable area of the page.\n+             Axes will indicate the direction of increasing X and Y.\n@@ -78,1 +59,2 @@\n-        PrinterJob pjob = PrinterJob.getPrinterJob();\n+             Test failed if the oval on the page clipped against the imageable area.\n+            \"\"\";\n@@ -80,0 +62,2 @@\n+    private static void printOrientationJob() throws PrinterException {\n+        PrinterJob pjob = PrinterJob.getPrinterJob();\n@@ -81,1 +65,0 @@\n-\n@@ -98,5 +81,0 @@\n-        try {\n-            pjob.print();\n-        } catch (PrinterException e) {\n-            e.printStackTrace();\n-        }\n@@ -104,1 +82,2 @@\n-    }\/\/End  init()\n+        pjob.print();\n+    }\n@@ -106,0 +85,1 @@\n+    @Override\n@@ -107,2 +87,1 @@\n-\n-        Graphics2D g2d = (Graphics2D)g;\n+        Graphics2D g2d = (Graphics2D) g;\n@@ -115,3 +94,6 @@\n-        double iw = pf.getImageableWidth();\n-        double ih = pf.getImageableHeight();\n-\n+        String orientation = switch (pf.getOrientation()) {\n+            case PageFormat.PORTRAIT -> \"PORTRAIT\";\n+            case PageFormat.LANDSCAPE -> \"LANDSCAPE\";\n+            case PageFormat.REVERSE_LANDSCAPE -> \"REVERSE_LANDSCAPE\";\n+            default -> \"INVALID\";\n+        };\n@@ -119,11 +101,0 @@\n-        String orientation;\n-        switch (pf.getOrientation()) {\n-           case PageFormat.PORTRAIT  : orientation = \"PORTRAIT\";\n-                                       break;\n-           case PageFormat.LANDSCAPE : orientation = \"LANDSCAPE\";\n-                                       break;\n-           case PageFormat.REVERSE_LANDSCAPE :\n-                                       orientation = \"REVERSE_LANDSCAPE\";\n-                                       break;\n-           default                   : orientation = \"INVALID\";\n-        }\n@@ -131,217 +102,7 @@\n-        g.draw(new Ellipse2D.Double(0, 0, iw, ih));\n-        g.drawString(\"(0,0)\", 5,15);\n-        g.drawLine(0,0,300,0);\n-        g.drawString(\"X\", 300,15);\n-        g.drawLine(0,0,0,300);\n-        g.drawString(\"Y\",5,300);\n-    }\n-\n-\n-   \/*****************************************************\n-     Standard Test Machinery Section\n-      DO NOT modify anything in this section -- it's a\n-      standard chunk of code which has all of the\n-      synchronisation necessary for the test harness.\n-      By keeping it the same in all tests, it is easier\n-      to read and understand someone else's test, as\n-      well as insuring that all tests behave correctly\n-      with the test harness.\n-     There is a section following this for test-defined\n-      classes\n-   ******************************************************\/\n-   private static boolean theTestPassed = false;\n-   private static boolean testGeneratedInterrupt = false;\n-   private static String failureMessage = \"\";\n-\n-   private static Thread mainThread = null;\n-\n-   private static int sleepTime = 300000;\n-\n-   public static void main( String args[] ) throws InterruptedException\n-    {\n-      mainThread = Thread.currentThread();\n-      try\n-       {\n-         init();\n-       }\n-      catch( TestPassedException e )\n-       {\n-         \/\/The test passed, so just return from main and harness will\n-         \/\/ interepret this return as a pass\n-         return;\n-       }\n-      \/\/At this point, neither test passed nor test failed has been\n-      \/\/ called -- either would have thrown an exception and ended the\n-      \/\/ test, so we know we have multiple threads.\n-\n-      \/\/Test involves other threads, so sleep and wait for them to\n-      \/\/ called pass() or fail()\n-      try\n-       {\n-         Thread.sleep( sleepTime );\n-         \/\/Timed out, so fail the test\n-         throw new RuntimeException( \"Timed out after \" + sleepTime\/1000 + \" seconds\" );\n-       }\n-      catch (InterruptedException e)\n-       {\n-         if( ! testGeneratedInterrupt ) throw e;\n-\n-         \/\/reset flag in case hit this code more than once for some reason (just safety)\n-         testGeneratedInterrupt = false;\n-         if ( theTestPassed == false )\n-          {\n-            throw new RuntimeException( failureMessage );\n-          }\n-       }\n-\n-    }\/\/main\n-\n-   public static synchronized void setTimeoutTo( int seconds )\n-    {\n-      sleepTime = seconds * 1000;\n-    }\n-\n-   public static synchronized void pass()\n-    {\n-      Sysout.println( \"The test passed.\" );\n-      Sysout.println( \"The test is over, hit  Ctl-C to stop Java VM\" );\n-      \/\/first check if this is executing in main thread\n-      if ( mainThread == Thread.currentThread() )\n-       {\n-         \/\/Still in the main thread, so set the flag just for kicks,\n-         \/\/ and throw a test passed exception which will be caught\n-         \/\/ and end the test.\n-         theTestPassed = true;\n-         throw new TestPassedException();\n-       }\n-      \/\/pass was called from a different thread, so set the flag and interrupt\n-      \/\/ the main thead.\n-      theTestPassed = true;\n-      testGeneratedInterrupt = true;\n-      mainThread.interrupt();\n-    }\/\/pass()\n-\n-   public static synchronized void fail()\n-    {\n-      \/\/test writer didn't specify why test failed, so give generic\n-      fail( \"it just plain failed! :-)\" );\n-    }\n-\n-   public static synchronized void fail( String whyFailed )\n-    {\n-      Sysout.println( \"The test failed: \" + whyFailed );\n-      Sysout.println( \"The test is over, hit  Ctl-C to stop Java VM\" );\n-      \/\/check if this called from main thread\n-      if ( mainThread == Thread.currentThread() )\n-       {\n-         \/\/If main thread, fail now 'cause not sleeping\n-         throw new RuntimeException( whyFailed );\n-       }\n-      theTestPassed = false;\n-      testGeneratedInterrupt = true;\n-      failureMessage = whyFailed;\n-      mainThread.interrupt();\n-    }\/\/fail()\n-\n- }\/\/ class Orient\n-\n-\/\/This exception is used to exit from any level of call nesting\n-\/\/ when it's determined that the test has passed, and immediately\n-\/\/ end the test.\n-class TestPassedException extends RuntimeException\n- {\n- }\n-\n-\/\/*********** End Standard Test Machinery Section **********\n-\n-\n-\/\/************ Begin classes defined for the test ****************\n-\n-\/\/ make listeners in a class defined here, and instantiate them in init()\n-\n-\/* Example of a class which may be written as part of a test\n-class NewClass implements anInterface\n- {\n-   static int newVar = 0;\n-\n-   public void eventDispatched(AWTEvent e)\n-    {\n-      \/\/Counting events to see if we get enough\n-      eventCount++;\n-\n-      if( eventCount == 20 )\n-       {\n-         \/\/got enough events, so pass\n-\n-         Orient.pass();\n-       }\n-      else if( tries == 20 )\n-       {\n-         \/\/tried too many times without getting enough events so fail\n-\n-         Orient.fail();\n-       }\n-\n-    }\/\/ eventDispatched()\n-\n- }\/\/ NewClass class\n-\n-*\/\n-\n-\n-\/\/************** End classes defined for the test *******************\n-\n-\n-\n-\n-\/****************************************************\n- Standard Test Machinery\n- DO NOT modify anything below -- it's a standard\n-  chunk of code whose purpose is to make user\n-  interaction uniform, and thereby make it simpler\n-  to read and understand someone else's test.\n- ****************************************************\/\n-\n-\/**\n- This is part of the standard test machinery.\n- It creates a dialog (with the instructions), and is the interface\n-  for sending text messages to the user.\n- To print the instructions, send an array of strings to Sysout.createDialog\n-  WithInstructions method.  Put one line of instructions per array entry.\n- To display a message for the tester to see, simply call Sysout.println\n-  with the string to be displayed.\n- This mimics System.out.println but works within the test harness as well\n-  as standalone.\n- *\/\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n+        g.draw(new Ellipse2D.Double(0, 0,\n+                pf.getImageableWidth(), pf.getImageableHeight()));\n+        g.drawString(\"(0,0)\", 5, 15);\n+        g.drawLine(0, 0, 300, 0);\n+        g.drawString(\"X\", 300, 15);\n+        g.drawLine(0, 0, 0, 300);\n+        g.drawString(\"Y\", 5, 300);\n@@ -350,94 +111,4 @@\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog implements ActionListener\n- {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-   Panel  buttonP = new Panel();\n-   Button passB = new Button( \"pass\" );\n-   Button failB = new Button( \"fail\" );\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      passB = new Button( \"pass\" );\n-      passB.setActionCommand( \"pass\" );\n-      passB.addActionListener( this );\n-      buttonP.add( \"East\", passB );\n-\n-      failB = new Button( \"fail\" );\n-      failB.setActionCommand( \"fail\" );\n-      failB.addActionListener( this );\n-      buttonP.add( \"West\", failB );\n-\n-      add( \"South\", buttonP );\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n+    public static void main(String args[]) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n@@ -445,13 +116,7 @@\n-   \/\/catch presses of the passed and failed buttons.\n-   \/\/simply call the standard pass() or fail() static methods of\n-   \/\/Orient\n-   public void actionPerformed( ActionEvent e )\n-    {\n-      if( e.getActionCommand() == \"pass\" )\n-       {\n-         Orient.pass();\n-       }\n-      else\n-       {\n-         Orient.fail();\n-       }\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+        printOrientationJob();\n+        passFailJFrame.awaitAndCheck();\n@@ -459,2 +124,1 @@\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PageFormat\/Orient.java","additions":63,"deletions":399,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.io.File;\n+import java.io.IOException;\n@@ -32,0 +34,1 @@\n+import java.nio.ByteBuffer;\n@@ -33,0 +36,10 @@\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n@@ -34,0 +47,1 @@\n+import java.util.stream.Stream;\n@@ -127,0 +141,44 @@\n+    @Test(dataProvider = \"alignments\")\n+    public void testActualByteAlignment(long align) {\n+        if (align > (1L << 10)) {\n+            return;\n+        }\n+        try (Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(4, align);\n+            assertTrue(segment.maxByteAlignment() >= align);\n+            \/\/ Power of two?\n+            assertEquals(Long.bitCount(segment.maxByteAlignment()), 1);\n+            assertEquals(segment.asSlice(1).maxByteAlignment(), 1);\n+        }\n+    }\n+\n+    public void testActualByteAlignmentMappedSegment() throws IOException {\n+        File tmp = File.createTempFile(\"tmp\", \"txt\");\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE);\n+             Arena arena = Arena.ofConfined()) {\n+            var segment =channel.map(FileChannel.MapMode.READ_WRITE, 0L, 32L, arena);\n+            \/\/ We do not know anything about mapping alignment other than it should\n+            \/\/ be positive.\n+            assertTrue(segment.maxByteAlignment() >= Byte.BYTES);\n+            \/\/ Power of two?\n+            assertEquals(Long.bitCount(segment.maxByteAlignment()), 1);\n+            assertEquals(segment.asSlice(1).maxByteAlignment(), 1);\n+        } finally {\n+            tmp.delete();\n+        }\n+    }\n+\n+    @Test()\n+    public void testActualByteAlignmentNull() {\n+        long alignment = MemorySegment.NULL.maxByteAlignment();\n+        assertEquals(1L << 62, alignment);\n+    }\n+\n+    @Test(dataProvider = \"heapSegments\")\n+    public void testActualByteAlignmentHeap(MemorySegment segment, int bytes) {\n+        assertEquals(segment.maxByteAlignment(), bytes);\n+        \/\/ A slice at offset 1 should always have an alignment of 1\n+        var segmentSlice = segment.asSlice(1);\n+        assertEquals(segmentSlice.maxByteAlignment(), 1);\n+    }\n+\n@@ -133,0 +191,22 @@\n+\n+    @DataProvider(name = \"heapSegments\")\n+    public Object[][] heapSegments() {\n+        return Stream.of(\n+                        new Object[]{MemorySegment.ofArray(new byte[]{1}), Byte.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new short[]{1}), Short.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new char[]{1}), Character.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new int[]{1}), Integer.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new long[]{1}), Long.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new float[]{1}), Float.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new double[]{1}), Double.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(ByteBuffer.allocate(8)), Byte.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(CharBuffer.allocate(8)), Character.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(ShortBuffer.allocate(8)), Short.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(IntBuffer.allocate(8)), Integer.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(LongBuffer.allocate(8)), Long.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(FloatBuffer.allocate(8)), Float.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(DoubleBuffer.allocate(8)), Double.BYTES}\n+        )\n+                .toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED TestSymbolLookupFindOrThrow\n+ *\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.util.NoSuchElementException;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.Assert.*;\n+\n+final class TestSymbolLookupFindOrThrow {\n+\n+    static {\n+        System.loadLibrary(\"Foo\");\n+    }\n+\n+    @Test\n+    void findOrThrow() {\n+        MemorySegment symbol = SymbolLookup.loaderLookup().findOrThrow(\"foo\");\n+        Assertions.assertNotEquals(0, symbol.address());\n+    }\n+\n+    @Test\n+    void findOrThrowNotFound() {\n+        assertThrows(NoSuchElementException.class, () ->\n+                SymbolLookup.loaderLookup().findOrThrow(\"bar\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestSymbolLookupFindOrThrow.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @bug 8319516\n+ * @summary verify that System.loadLibrary on AIX is able to load libraries from \".a\" (archive) file\n+ * @requires os.family == \"aix\"\n+ * @library \/test\/lib\/\n+ * @build jdk.test.lib.process.ProcessTools\n+ * @run  main\/othervm   LoadAIXLibraryFromArchiveObject\n+ *\/\n+public class LoadAIXLibraryFromArchiveObject {\n+\n+    private static final String TEST_LIBRARY_NAME = \"foobar\";\n+    \/\/ creates a \".a\" archive file in a test specific directory and then\n+    \/\/ launches a java application passing this directory through \"-Djava.library.path\".\n+    \/\/ the java application then attempts to load the library using System.loadLibrary()\n+    public static void main(String[] args) throws Exception {\n+        String javaHome = System.getProperty(\"java.home\");\n+        Path libj2pcscSo = Path.of(javaHome).resolve(\"lib\", \"libj2pcsc.so\");\n+        if (!Files.exists(libj2pcscSo)) {\n+            throw new AssertionError(libj2pcscSo + \" is missing\");\n+        }\n+        String archiveFileName = \"lib\" + TEST_LIBRARY_NAME + \".a\";\n+        \/\/ copy over libj2pcsc.so as an archive file to test specific scratch dir\n+        Path testNativeLibDir = Path.of(\"native\").toAbsolutePath();\n+        Files.createDirectories(testNativeLibDir);\n+        Path libFooBarArchive = testNativeLibDir.resolve(archiveFileName);\n+        Files.copy(libj2pcscSo, libFooBarArchive);\n+        \/\/ launch a java application which calls System.loadLibrary and is passed\n+        \/\/ the directory containing the native library archive file, through\n+        \/\/ -Djava.library.path\n+        ProcessBuilder processBuilder = ProcessTools.createTestJavaProcessBuilder(\n+                \"-Djava.library.path=\" + testNativeLibDir,\n+                LoadAIXLibraryFromArchiveObject.LoadLibraryApp.class.getName());\n+        ProcessTools.executeCommand(processBuilder).shouldHaveExitValue(0);\n+    }\n+\n+    static class LoadLibraryApp {\n+        public static void main(final String[] args) throws Exception {\n+            System.out.println(\"attempting to load library \" + TEST_LIBRARY_NAME);\n+            System.loadLibrary(TEST_LIBRARY_NAME);\n+            System.out.println(TEST_LIBRARY_NAME + \" successfully loaded\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/loadLibrary\/aix\/LoadAIXLibraryFromArchiveObject.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.StringConcatFactory;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-\/**\n- * @test\n- * @summary Test StringConcatFactory.makeConcatWithTemplate... methods.\n- * @enablePreview true\n- *\/\n-\n-public class MakeConcatWithTemplate {\n-    public static void main(String... args) {\n-        makeConcatWithTemplate();\n-        makeConcatWithTemplateCluster();\n-        makeConcatWithTemplateGetters();\n-    }\n-\n-    static List<String> fragments(int n) {\n-        String[] array = new String[n];\n-        Arrays.fill(array, \"abc\");\n-        return Arrays.asList(array);\n-    }\n-\n-    static List<Class<?>> types(int n) {\n-        Class<?>[] array = new Class<?>[n];\n-        Arrays.fill(array, int.class);\n-        return Arrays.asList(array);\n-    }\n-\n-    static List<Integer> values(int n) {\n-        Integer[] array = new Integer[n];\n-        Arrays.fill(array, 123);\n-        return Arrays.asList(array);\n-    }\n-\n-    static List<MethodHandle> getters(int n) {\n-        MethodHandle[] array = new MethodHandle[n];\n-        MethodHandle m = MethodHandles.dropArguments(MethodHandles.constant(int.class, 123), 0, Object.class);\n-        Arrays.fill(array, m);\n-        return Arrays.asList(array);\n-    }\n-\n-    static void makeConcatWithTemplate() {\n-        try {\n-            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS - 1;\n-            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n-            m.invokeWithArguments(values(n));\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        try {\n-            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n-            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n-            m.invokeWithArguments(values(n));\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        boolean threw = false;\n-        try {\n-            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS + 1;\n-            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n-            m.invokeWithArguments(values(n));\n-        } catch (Throwable e) {\n-            threw = true;\n-        }\n-\n-        if (!threw) {\n-            throw new RuntimeException(\"Exception expected - makeConcatWithTemplate\");\n-        }\n-    }\n-\n-    static void makeConcatWithTemplateCluster() {\n-        int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n-        int c = 3;\n-        try {\n-            List<MethodHandle> ms = StringConcatFactory.makeConcatWithTemplateCluster(fragments(c * n + 1), types(c * n), n);\n-            MethodHandle m0 = ms.get(0);\n-            MethodHandle m1 = ms.get(1);\n-            MethodHandle m2 = ms.get(2);\n-            MethodHandle m3 = ms.get(3);\n-\n-            String s = (String)m0.invokeWithArguments(values(n));\n-            List<Object> args = new ArrayList<>();\n-            args.add(s);\n-            args.addAll(values(n - 1)); \/\/ one less for carry over string\n-            s = (String)m1.invokeWithArguments(args);\n-            args.clear();\n-            args.add(s);\n-            args.addAll(values(n - 1)); \/\/ one less for carry over string\n-            s = (String)m2.invokeWithArguments(args);\n-            args.clear();\n-            args.add(s);\n-            args.addAll(values(2)); \/\/ two remaining carry overs\n-            s = (String)m3.invokeWithArguments(args);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static void makeConcatWithTemplateGetters() {\n-        int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n-        int c = 3;\n-        try {\n-            MethodHandle m = StringConcatFactory.makeConcatWithTemplateGetters(fragments(c * n + 1), getters(c * n), n);\n-            String s = (String)m.invoke(null);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/String\/concat\/MakeConcatWithTemplate.java","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n@@ -28,1 +30,0 @@\n-import org.junit.jupiter.api.Test;\n@@ -30,1 +31,0 @@\n-import org.junit.jupiter.params.provider.MethodSource;\n@@ -32,3 +32,1 @@\n-\n-import static java.lang.System.err;\n-import static java.lang.System.out;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -88,1 +86,1 @@\n-        ProcessBuilder processBuilder = ProcessTools.createLimitedTestJavaProcessBuilder(cmd);\n+        ProcessBuilder processBuilder = ProcessTools.createTestJavaProcessBuilder(cmd);\n","filename":"test\/jdk\/java\/lang\/Thread\/UncaughtExceptionsTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        var processBuilder = ProcessTools.createLimitedTestJavaProcessBuilder(command)\n+        var processBuilder = ProcessTools.createTestJavaProcessBuilder(command)\n","filename":"test\/jdk\/java\/lang\/annotation\/LoaderLeakTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8330467\n@@ -81,1 +82,2 @@\n-        compileSources(SRC_DIR, CLASSES_DIR, \"--enable-preview\", \"--release\", \"23\");\n+        compileSources(SRC_DIR, CLASSES_DIR, \"--enable-preview\",\n+                       \"--release\", Integer.toString(Runtime.version().feature()));\n@@ -183,0 +185,14 @@\n+    \/\/ Define a hidden class that uses lambda and contains its implementation\n+    \/\/ This verifies LambdaMetaFactory supports the caller which is a hidden class\n+    @Test\n+    public void testHiddenLambda() throws Throwable {\n+        HiddenTest t = (HiddenTest)defineHiddenClass(\"HiddenLambda\").newInstance();\n+        try {\n+            t.test();\n+        } catch (Error e) {\n+            if (!e.getMessage().equals(\"thrown by \" + t.getClass().getName())) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/BasicTest.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.function.Function;\n+\n+public class HiddenLambda implements HiddenTest {\n+     public void test() {\n+         Function<Object, String> f = o -> o.toString();\n+         String s = f.apply(this);\n+         throw new Error(\"thrown by \" + s);\n+     }\n+\n+     public String toString() {\n+         return getClass().getName();\n+     }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/src\/HiddenLambda.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -1,504 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 0000000\n- * @summary Exercise runtime handing of templated strings.\n- * @enablePreview true\n- *\/\n-\n-import java.lang.StringTemplate.*;\n-import java.util.*;\n-import java.util.concurrent.*;\n-import java.util.function.*;\n-\n-import static java.lang.StringTemplate.RAW;\n-\n-public class Basic {\n-    public static void main(String... arg) {\n-        equalsHashCode();\n-        concatenationTests();\n-        componentTests();\n-        limitsTests();\n-        processorTests();\n-        stringTemplateCoverage();\n-        simpleProcessorCoverage();\n-    }\n-\n-    static void ASSERT(String a, String b) {\n-        if (!Objects.equals(a, b)) {\n-            System.out.println(a);\n-            System.out.println(b);\n-            throw new RuntimeException(\"Test failed\");\n-        }\n-    }\n-\n-    static void ASSERT(Object a, Object b) {\n-        if (!Objects.deepEquals(a, b)) {\n-            System.out.println(a);\n-            System.out.println(b);\n-            throw new RuntimeException(\"Test failed\");\n-        }\n-    }\n-\n-    \/*\n-     * equals and hashCode tests.\n-     *\/\n-    static void equalsHashCode() {\n-        int x = 10;\n-        int y = 20;\n-        int a = 10;\n-        int b = 20;\n-\n-        StringTemplate st0 = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-        StringTemplate st1 = RAW.\"\\{a} + \\{b} = \\{a + b}\";\n-        StringTemplate st2 = RAW.\"\\{x} + \\{y} = \\{x + y}!\";\n-        x++;\n-        StringTemplate st3 = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-\n-        if (!st0.equals(st1)) throw new RuntimeException(\"st0 != st1\");\n-        if (st0.equals(st2)) throw new RuntimeException(\"st0 == st2\");\n-        if (st0.equals(st3)) throw new RuntimeException(\"st0 == st3\");\n-\n-        if (st0.hashCode() != st1.hashCode()) throw new RuntimeException(\"st0.hashCode() != st1.hashCode()\");\n-    }\n-\n-    \/*\n-     * Concatenation tests.\n-     *\/\n-    static void concatenationTests() {\n-        int x = 10;\n-        int y = 20;\n-\n-        ASSERT(STR.\"\\{x} \\{y}\", x + \" \" + y);\n-        ASSERT(STR.\"\\{x + y}\", \"\" + (x + y));\n-        ASSERT(STR.process(RAW.\"\\{x} \\{y}\"), x + \" \" + y);\n-        ASSERT(STR.process(RAW.\"\\{x + y}\"), \"\" + (x + y));\n-        ASSERT((RAW.\"\\{x} \\{y}\").process(STR), x + \" \" + y);\n-        ASSERT((RAW.\"\\{x + y}\").process(STR), \"\" + (x + y));\n-    }\n-\n-    \/*\n-     * Component tests.\n-     *\/\n-    static void componentTests() {\n-        int x = 10;\n-        int y = 20;\n-\n-        StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-        ASSERT(st.values(), List.of(x, y, x + y));\n-        ASSERT(st.fragments(), List.of(\"\", \" + \", \" = \", \"\"));\n-        ASSERT(st.interpolate(), x + \" + \" + y + \" = \" + (x + y));\n-    }\n-\n-    \/*\n-     * Limits tests.\n-     *\/\n-    static void limitsTests() {\n-        int x = 9;\n-\n-        StringTemplate ts250 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts250.values().size(), 250);\n-        ASSERT(ts250.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999\n-               \"\"\");\n-\n-        StringTemplate ts251 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\n-             \"\"\";\n-        ASSERT(ts251.values().size(), 251);\n-        ASSERT(ts251.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9\n-               \"\"\");\n-\n-        StringTemplate ts252 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts252.values().size(), 252);\n-        ASSERT(ts252.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 99\n-               \"\"\");\n-\n-        StringTemplate ts253 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts253.values().size(), 253);\n-        ASSERT(ts253.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 999\n-               \"\"\");\n-\n-        StringTemplate ts254 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts254.values().size(), 254);\n-        ASSERT(ts254.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999\n-               \"\"\");\n-\n-        StringTemplate ts255 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts255.values().size(), 255);\n-        ASSERT(ts255.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 99999\n-               \"\"\");\n-\n-        StringTemplate ts256 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts256.values().size(), 256);\n-        ASSERT(ts256.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 999999\n-               \"\"\");\n-\n-    }\n-\n-    \/*\n-     * Processor tests.\n-     *\/\n-    public static final Processor<StringTemplate, RuntimeException> STRINGIFY = st -> {\n-        List<Object> values = st.values()\n-                .stream()\n-                .map(v -> (Object)String.valueOf(v))\n-                .toList();\n-\n-        return StringTemplate.of(st.fragments(), values);\n-    };\n-\n-    public static final Processor<StringTemplate, RuntimeException> UPPER = st -> {\n-        List<String> fragments = st.fragments()\n-                .stream()\n-                .map(String::toUpperCase)\n-                .toList();\n-\n-        return StringTemplate.of(fragments, st.values());\n-    };\n-\n-    public static final Processor<String, RuntimeException> CHAIN = st -> {\n-        st = STRINGIFY.process(st);\n-        st = UPPER.process(st);\n-        return STR.process(st);\n-    };\n-\n-    static void processorTests() {\n-        String name = \"Joan\";\n-        int age = 25;\n-        ASSERT(CHAIN.\"\\{name} is \\{age} years old\", \"Joan IS 25 YEARS OLD\");\n-    }\n-\n-    \/*\n-     *  StringTemplate coverage\n-     *\/\n-    static void stringTemplateCoverage() {\n-        StringTemplate tsNoValues = StringTemplate.of(\"No Values\");\n-\n-        ASSERT(tsNoValues.values(), List.of());\n-        ASSERT(tsNoValues.fragments(), List.of(\"No Values\"));\n-        ASSERT(tsNoValues.interpolate(), STR.\"No Values\");\n-\n-        int x = 10, y = 20;\n-        StringTemplate src = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-        StringTemplate tsValues = StringTemplate.of(src.fragments(), src.values());\n-        ASSERT(tsValues.fragments(), List.of(\"\", \" + \", \" = \", \"\"));\n-        ASSERT(tsValues.values(), List.of(x, y, x + y));\n-        ASSERT(tsValues.interpolate(), x + \" + \" + y + \" = \" + (x + y));\n-        ASSERT(StringTemplate.combine(src, src).interpolate(),\n-                RAW.\"\\{x} + \\{y} = \\{x + y}\\{x} + \\{y} = \\{x + y}\".interpolate());\n-        ASSERT(StringTemplate.combine(src), src);\n-        ASSERT(StringTemplate.combine().interpolate(), \"\");\n-        ASSERT(StringTemplate.combine(List.of(src, src)).interpolate(),\n-                RAW.\"\\{x} + \\{y} = \\{x + y}\\{x} + \\{y} = \\{x + y}\".interpolate());\n-    }\n-\n-    \/*\n-     * SimpleProcessor coverage.\n-     *\/\n-\n-    static class Processor0 implements Processor<String, IllegalArgumentException> {\n-        @Override\n-        public String process(StringTemplate stringTemplate) throws IllegalArgumentException {\n-            StringBuilder sb = new StringBuilder();\n-            Iterator<String> fragmentsIter = stringTemplate.fragments().iterator();\n-\n-            for (Object value : stringTemplate.values()) {\n-                sb.append(fragmentsIter.next());\n-\n-                if (value instanceof Boolean) {\n-                    throw new IllegalArgumentException(\"I don't like Booleans\");\n-                }\n-\n-                sb.append(value);\n-            }\n-\n-            sb.append(fragmentsIter.next());\n-\n-            return sb.toString();\n-        }\n-    }\n-\n-    static Processor0 processor0 = new Processor0();\n-\n-    static Processor<String, RuntimeException> processor1 =\n-        st -> st.interpolate();\n-\n-    static Processor<String, RuntimeException> processor2 = st -> st.interpolate();\n-\n-    static Processor<String, RuntimeException> processor3 = st -> st.interpolate();\n-\n-    static Processor<String, RuntimeException> processor4 = st ->\n-        StringTemplate.interpolate(st.fragments(), st.values());\n-\n-\n-    static void simpleProcessorCoverage() {\n-        try {\n-            int x = 10;\n-            int y = 20;\n-            ASSERT(processor0.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n-            ASSERT(processor1.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n-            ASSERT(processor2.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n-            ASSERT(processor3.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n-            ASSERT(processor4.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n-        } catch (IllegalArgumentException ex) {\n-            throw new RuntimeException(\"processor fail\");\n-        }\n-    }\n-\n-    static String justify(String string, int width) {\n-        boolean leftJustify = width < 0;\n-        int length = string.length();\n-        width = Math.abs(width);\n-        int diff = width - length;\n-\n-        if (diff < 0) {\n-            string = \"*\".repeat(width);\n-        } else if (0 < diff) {\n-            if (leftJustify) {\n-                string += \" \".repeat(diff);\n-            } else {\n-                string = \" \".repeat(diff) + string;\n-            }\n-        }\n-\n-        return string;\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/template\/Basic.java","additions":0,"deletions":504,"binary":false,"changes":504,"status":"deleted"},{"patch":"@@ -1,961 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 0000000\n- * @summary Exercise format builder.\n- * @enablePreview true\n- *\/\n-\n-import java.util.FormatProcessor;\n-import java.util.Objects;\n-import java.util.Locale;\n-import java.util.MissingFormatArgumentException;\n-import java.util.UnknownFormatConversionException;\n-\n-import static java.util.FormatProcessor.FMT;\n-\n-public class FormatterBuilder {\n-    public static void main(String... args) {\n-        Locale.setDefault(Locale.US);\n-        suite(FMT);\n-        Locale thai = Locale.forLanguageTag(\"th-TH-u-nu-thai\");\n-        FormatProcessor thaiFormat = FormatProcessor.create(thai);\n-        Locale.setDefault(thai);\n-        suite(thaiFormat);\n-    }\n-\n-    static void test(String a, String b) {\n-        if (!Objects.equals(a, b)) {\n-            throw new RuntimeException(\"format and FMT do not match: \" + a + \" : \" + b);\n-        }\n-    }\n-\n-    public interface Executable {\n-        void execute() throws Throwable;\n-    }\n-\n-    static <T extends Throwable> void assertThrows(Class<T> expectedType, Executable executable, String message) {\n-        Throwable actualException = null;\n-        try {\n-            executable.execute();\n-        } catch (Throwable e) {\n-            actualException = e;\n-        }\n-        if (actualException == null) {\n-            throw new RuntimeException(\"Expected \" + expectedType + \" to be thrown, but nothing was thrown.\");\n-        }\n-        if (!expectedType.isInstance(actualException)) {\n-            throw new RuntimeException(\"Expected \" + expectedType + \" to be thrown, but was thrown \" + actualException.getClass());\n-        }\n-        if (message != null && !message.equals(actualException.getMessage())) {\n-            throw new RuntimeException(\"Expected \" + message + \" to be thrown, but was thrown \" + actualException.getMessage());\n-        }\n-    }\n-\n-    static void suite(FormatProcessor fmt) {\n-        Object nullObject = null;\n-        test(String.format(\"%b\", false), fmt.\"%b\\{false}\");\n-        test(String.format(\"%b\", true), fmt.\"%b\\{true}\");\n-        test(String.format(\"%10b\", false), fmt.\"%10b\\{false}\");\n-        test(String.format(\"%10b\", true), fmt.\"%10b\\{true}\");\n-        test(String.format(\"%-10b\", false), fmt.\"%-10b\\{false}\");\n-        test(String.format(\"%-10b\", true), fmt.\"%-10b\\{true}\");\n-        test(String.format(\"%B\", false), fmt.\"%B\\{false}\");\n-        test(String.format(\"%B\", true), fmt.\"%B\\{true}\");\n-        test(String.format(\"%10B\", false), fmt.\"%10B\\{false}\");\n-        test(String.format(\"%10B\", true), fmt.\"%10B\\{true}\");\n-        test(String.format(\"%-10B\", false), fmt.\"%-10B\\{false}\");\n-        test(String.format(\"%-10B\", true), fmt.\"%-10B\\{true}\");\n-\n-        test(String.format(\"%h\", 12345), fmt.\"%h\\{12345}\");\n-        test(String.format(\"%h\", 0xABCDE), fmt.\"%h\\{0xABCDE}\");\n-        test(String.format(\"%10h\", 12345), fmt.\"%10h\\{12345}\");\n-        test(String.format(\"%10h\", 0xABCDE), fmt.\"%10h\\{0xABCDE}\");\n-        test(String.format(\"%-10h\", 12345), fmt.\"%-10h\\{12345}\");\n-        test(String.format(\"%-10h\", 0xABCDE), fmt.\"%-10h\\{0xABCDE}\");\n-        test(String.format(\"%H\", 12345), fmt.\"%H\\{12345}\");\n-        test(String.format(\"%H\", 0xABCDE), fmt.\"%H\\{0xABCDE}\");\n-        test(String.format(\"%10H\", 12345), fmt.\"%10H\\{12345}\");\n-        test(String.format(\"%10H\", 0xABCDE), fmt.\"%10H\\{0xABCDE}\");\n-        test(String.format(\"%-10H\", 12345), fmt.\"%-10H\\{12345}\");\n-        test(String.format(\"%-10H\", 0xABCDE), fmt.\"%-10H\\{0xABCDE}\");\n-\n-        test(String.format(\"%s\", (byte)0xFF), fmt.\"%s\\{(byte)0xFF}\");\n-        test(String.format(\"%s\", (short)0xFFFF), fmt.\"%s\\{(short)0xFFFF}\");\n-        test(String.format(\"%s\", 12345), fmt.\"%s\\{12345}\");\n-        test(String.format(\"%s\", 12345L), fmt.\"%s\\{12345L}\");\n-        test(String.format(\"%s\", 1.33f), fmt.\"%s\\{1.33f}\");\n-        test(String.format(\"%s\", 1.33), fmt.\"%s\\{1.33}\");\n-        test(String.format(\"%s\", \"abcde\"), fmt.\"%s\\{\"abcde\"}\");\n-        test(String.format(\"%s\", nullObject), fmt.\"%s\\{nullObject}\");\n-        test(String.format(\"%10s\", (byte)0xFF), fmt.\"%10s\\{(byte)0xFF}\");\n-        test(String.format(\"%10s\", (short)0xFFFF), fmt.\"%10s\\{(short)0xFFFF}\");\n-        test(String.format(\"%10s\", 12345), fmt.\"%10s\\{12345}\");\n-        test(String.format(\"%10s\", 12345L), fmt.\"%10s\\{12345L}\");\n-        test(String.format(\"%10s\", 1.33f), fmt.\"%10s\\{1.33f}\");\n-        test(String.format(\"%10s\", 1.33), fmt.\"%10s\\{1.33}\");\n-        test(String.format(\"%10s\", \"abcde\"), fmt.\"%10s\\{\"abcde\"}\");\n-        test(String.format(\"%10s\", nullObject), fmt.\"%10s\\{nullObject}\");\n-        test(String.format(\"%-10s\", (byte)0xFF), fmt.\"%-10s\\{(byte)0xFF}\");\n-        test(String.format(\"%-10s\", (short)0xFFFF), fmt.\"%-10s\\{(short)0xFFFF}\");\n-        test(String.format(\"%-10s\", 12345), fmt.\"%-10s\\{12345}\");\n-        test(String.format(\"%-10s\", 12345L), fmt.\"%-10s\\{12345L}\");\n-        test(String.format(\"%-10s\", 1.33f), fmt.\"%-10s\\{1.33f}\");\n-        test(String.format(\"%-10s\", 1.33), fmt.\"%-10s\\{1.33}\");\n-        test(String.format(\"%-10s\", \"abcde\"), fmt.\"%-10s\\{\"abcde\"}\");\n-        test(String.format(\"%-10s\", nullObject), fmt.\"%-10s\\{nullObject}\");\n-        test(String.format(\"%S\", (byte)0xFF), fmt.\"%S\\{(byte)0xFF}\");\n-        test(String.format(\"%S\", (short)0xFFFF), fmt.\"%S\\{(short)0xFFFF}\");\n-        test(String.format(\"%S\", 12345), fmt.\"%S\\{12345}\");\n-        test(String.format(\"%S\", 12345L), fmt.\"%S\\{12345L}\");\n-        test(String.format(\"%S\", 1.33f), fmt.\"%S\\{1.33f}\");\n-        test(String.format(\"%S\", 1.33), fmt.\"%S\\{1.33}\");\n-        test(String.format(\"%S\", \"abcde\"), fmt.\"%S\\{\"abcde\"}\");\n-        test(String.format(\"%S\", nullObject), fmt.\"%S\\{nullObject}\");\n-        test(String.format(\"%10S\", (byte)0xFF), fmt.\"%10S\\{(byte)0xFF}\");\n-        test(String.format(\"%10S\", (short)0xFFFF), fmt.\"%10S\\{(short)0xFFFF}\");\n-        test(String.format(\"%10S\", 12345), fmt.\"%10S\\{12345}\");\n-        test(String.format(\"%10S\", 12345L), fmt.\"%10S\\{12345L}\");\n-        test(String.format(\"%10S\", 1.33f), fmt.\"%10S\\{1.33f}\");\n-        test(String.format(\"%10S\", 1.33), fmt.\"%10S\\{1.33}\");\n-        test(String.format(\"%10S\", \"abcde\"), fmt.\"%10S\\{\"abcde\"}\");\n-        test(String.format(\"%10S\", nullObject), fmt.\"%10S\\{nullObject}\");\n-        test(String.format(\"%-10S\", (byte)0xFF), fmt.\"%-10S\\{(byte)0xFF}\");\n-        test(String.format(\"%-10S\", (short)0xFFFF), fmt.\"%-10S\\{(short)0xFFFF}\");\n-        test(String.format(\"%-10S\", 12345), fmt.\"%-10S\\{12345}\");\n-        test(String.format(\"%-10S\", 12345L), fmt.\"%-10S\\{12345L}\");\n-        test(String.format(\"%-10S\", 1.33f), fmt.\"%-10S\\{1.33f}\");\n-        test(String.format(\"%-10S\", 1.33), fmt.\"%-10S\\{1.33}\");\n-        test(String.format(\"%-10S\", \"abcde\"), fmt.\"%-10S\\{\"abcde\"}\");\n-        test(String.format(\"%-10S\", nullObject), fmt.\"%-10S\\{nullObject}\");\n-\n-        test(String.format(\"%c\", 'a'), fmt.\"%c\\{'a'}\");\n-        test(String.format(\"%10c\", 'a'), fmt.\"%10c\\{'a'}\");\n-        test(String.format(\"%-10c\", 'a'), fmt.\"%-10c\\{'a'}\");\n-        test(String.format(\"%C\", 'a'), fmt.\"%C\\{'a'}\");\n-        test(String.format(\"%10C\", 'a'), fmt.\"%10C\\{'a'}\");\n-        test(String.format(\"%-10C\", 'a'), fmt.\"%-10C\\{'a'}\");\n-\n-        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n-        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n-        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n-        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n-        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n-        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n-        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n-        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n-        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n-        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n-        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n-        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n-        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n-        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n-        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n-        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n-        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n-        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n-        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n-        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n-        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n-        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n-        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n-        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n-\n-        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n-        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n-        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n-        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n-        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n-        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n-        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n-        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n-        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n-        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n-        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n-        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n-        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n-        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n-        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n-        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n-        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n-        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n-        test(String.format(\"% d\", -12345), fmt.\"% d\\{-12345}\");\n-        test(String.format(\"% d\", 0), fmt.\"% d\\{0}\");\n-        test(String.format(\"% d\", 12345), fmt.\"% d\\{12345}\");\n-        test(String.format(\"% 10d\", -12345), fmt.\"% 10d\\{-12345}\");\n-        test(String.format(\"% 10d\", 0), fmt.\"% 10d\\{0}\");\n-        test(String.format(\"% 10d\", 12345), fmt.\"% 10d\\{12345}\");\n-        test(String.format(\"% -10d\", -12345), fmt.\"% -10d\\{-12345}\");\n-        test(String.format(\"% -10d\", 0), fmt.\"% -10d\\{0}\");\n-        test(String.format(\"% -10d\", 12345), fmt.\"% -10d\\{12345}\");\n-        test(String.format(\"%, d\", -12345), fmt.\"%, d\\{-12345}\");\n-        test(String.format(\"%, d\", 0), fmt.\"%, d\\{0}\");\n-        test(String.format(\"%, d\", 12345), fmt.\"%, d\\{12345}\");\n-        test(String.format(\"%, 10d\", -12345), fmt.\"%, 10d\\{-12345}\");\n-        test(String.format(\"%, 10d\", 0), fmt.\"%, 10d\\{0}\");\n-        test(String.format(\"%, 10d\", 12345), fmt.\"%, 10d\\{12345}\");\n-        test(String.format(\"%, -10d\", -12345), fmt.\"%, -10d\\{-12345}\");\n-        test(String.format(\"%, -10d\", 0), fmt.\"%, -10d\\{0}\");\n-        test(String.format(\"%, -10d\", 12345), fmt.\"%, -10d\\{12345}\");\n-        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n-        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n-        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n-        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n-        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n-        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n-        test(String.format(\"% 010d\", -12345), fmt.\"% 010d\\{-12345}\");\n-        test(String.format(\"% 010d\", 0), fmt.\"% 010d\\{0}\");\n-        test(String.format(\"% 010d\", 12345), fmt.\"% 010d\\{12345}\");\n-        test(String.format(\"%, 010d\", -12345), fmt.\"%, 010d\\{-12345}\");\n-        test(String.format(\"%, 010d\", 0), fmt.\"%, 010d\\{0}\");\n-        test(String.format(\"%, 010d\", 12345), fmt.\"%, 010d\\{12345}\");\n-\n-        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n-        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n-        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n-        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n-        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n-        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n-        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n-        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n-        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n-        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n-        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n-        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n-        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n-        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n-        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n-        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n-        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n-        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n-        test(String.format(\"%+d\", -12345), fmt.\"%+d\\{-12345}\");\n-        test(String.format(\"%+d\", 0), fmt.\"%+d\\{0}\");\n-        test(String.format(\"%+d\", 12345), fmt.\"%+d\\{12345}\");\n-        test(String.format(\"%+10d\", -12345), fmt.\"%+10d\\{-12345}\");\n-        test(String.format(\"%+10d\", 0), fmt.\"%+10d\\{0}\");\n-        test(String.format(\"%+10d\", 12345), fmt.\"%+10d\\{12345}\");\n-        test(String.format(\"%+-10d\", -12345), fmt.\"%+-10d\\{-12345}\");\n-        test(String.format(\"%+-10d\", 0), fmt.\"%+-10d\\{0}\");\n-        test(String.format(\"%+-10d\", 12345), fmt.\"%+-10d\\{12345}\");\n-        test(String.format(\"%,+d\", -12345), fmt.\"%,+d\\{-12345}\");\n-        test(String.format(\"%,+d\", 0), fmt.\"%,+d\\{0}\");\n-        test(String.format(\"%,+d\", 12345), fmt.\"%,+d\\{12345}\");\n-        test(String.format(\"%,+10d\", -12345), fmt.\"%,+10d\\{-12345}\");\n-        test(String.format(\"%,+10d\", 0), fmt.\"%,+10d\\{0}\");\n-        test(String.format(\"%,+10d\", 12345), fmt.\"%,+10d\\{12345}\");\n-        test(String.format(\"%,+-10d\", -12345), fmt.\"%,+-10d\\{-12345}\");\n-        test(String.format(\"%,+-10d\", 0), fmt.\"%,+-10d\\{0}\");\n-        test(String.format(\"%,+-10d\", 12345), fmt.\"%,+-10d\\{12345}\");\n-        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n-        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n-        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n-        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n-        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n-        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n-        test(String.format(\"%+010d\", -12345), fmt.\"%+010d\\{-12345}\");\n-        test(String.format(\"%+010d\", 0), fmt.\"%+010d\\{0}\");\n-        test(String.format(\"%+010d\", 12345), fmt.\"%+010d\\{12345}\");\n-        test(String.format(\"%,+010d\", -12345), fmt.\"%,+010d\\{-12345}\");\n-        test(String.format(\"%,+010d\", 0), fmt.\"%,+010d\\{0}\");\n-        test(String.format(\"%,+010d\", 12345), fmt.\"%,+010d\\{12345}\");\n-\n-        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n-        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n-        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n-        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n-        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n-        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n-        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n-        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n-        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n-        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n-        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n-        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n-        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n-        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n-        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n-        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n-        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n-        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n-        test(String.format(\"%(d\", -12345), fmt.\"%(d\\{-12345}\");\n-        test(String.format(\"%(d\", 0), fmt.\"%(d\\{0}\");\n-        test(String.format(\"%(d\", 12345), fmt.\"%(d\\{12345}\");\n-        test(String.format(\"%(10d\", -12345), fmt.\"%(10d\\{-12345}\");\n-        test(String.format(\"%(10d\", 0), fmt.\"%(10d\\{0}\");\n-        test(String.format(\"%(10d\", 12345), fmt.\"%(10d\\{12345}\");\n-        test(String.format(\"%(-10d\", -12345), fmt.\"%(-10d\\{-12345}\");\n-        test(String.format(\"%(-10d\", 0), fmt.\"%(-10d\\{0}\");\n-        test(String.format(\"%(-10d\", 12345), fmt.\"%(-10d\\{12345}\");\n-        test(String.format(\"%,(d\", -12345), fmt.\"%,(d\\{-12345}\");\n-        test(String.format(\"%,(d\", 0), fmt.\"%,(d\\{0}\");\n-        test(String.format(\"%,(d\", 12345), fmt.\"%,(d\\{12345}\");\n-        test(String.format(\"%,(10d\", -12345), fmt.\"%,(10d\\{-12345}\");\n-        test(String.format(\"%,(10d\", 0), fmt.\"%,(10d\\{0}\");\n-        test(String.format(\"%,(10d\", 12345), fmt.\"%,(10d\\{12345}\");\n-        test(String.format(\"%,(-10d\", -12345), fmt.\"%,(-10d\\{-12345}\");\n-        test(String.format(\"%,(-10d\", 0), fmt.\"%,(-10d\\{0}\");\n-        test(String.format(\"%,(-10d\", 12345), fmt.\"%,(-10d\\{12345}\");\n-        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n-        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n-        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n-        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n-        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n-        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n-        test(String.format(\"%(010d\", -12345), fmt.\"%(010d\\{-12345}\");\n-        test(String.format(\"%(010d\", 0), fmt.\"%(010d\\{0}\");\n-        test(String.format(\"%(010d\", 12345), fmt.\"%(010d\\{12345}\");\n-        test(String.format(\"%,(010d\", -12345), fmt.\"%,(010d\\{-12345}\");\n-        test(String.format(\"%,(010d\", 0), fmt.\"%,(010d\\{0}\");\n-        test(String.format(\"%,(010d\", 12345), fmt.\"%,(010d\\{12345}\");\n-\n-        test(String.format(\"%o\", -12345), fmt.\"%o\\{-12345}\");\n-        test(String.format(\"%o\", 0), fmt.\"%o\\{0}\");\n-        test(String.format(\"%o\", 12345), fmt.\"%o\\{12345}\");\n-        test(String.format(\"%10o\", -12345), fmt.\"%10o\\{-12345}\");\n-        test(String.format(\"%10o\", 0), fmt.\"%10o\\{0}\");\n-        test(String.format(\"%10o\", 12345), fmt.\"%10o\\{12345}\");\n-        test(String.format(\"%-10o\", -12345), fmt.\"%-10o\\{-12345}\");\n-        test(String.format(\"%-10o\", 0), fmt.\"%-10o\\{0}\");\n-        test(String.format(\"%-10o\", 12345), fmt.\"%-10o\\{12345}\");\n-        test(String.format(\"%#o\", -12345), fmt.\"%#o\\{-12345}\");\n-        test(String.format(\"%#o\", 0), fmt.\"%#o\\{0}\");\n-        test(String.format(\"%#o\", 12345), fmt.\"%#o\\{12345}\");\n-        test(String.format(\"%#10o\", -12345), fmt.\"%#10o\\{-12345}\");\n-        test(String.format(\"%#10o\", 0), fmt.\"%#10o\\{0}\");\n-        test(String.format(\"%#10o\", 12345), fmt.\"%#10o\\{12345}\");\n-        test(String.format(\"%#-10o\", -12345), fmt.\"%#-10o\\{-12345}\");\n-        test(String.format(\"%#-10o\", 0), fmt.\"%#-10o\\{0}\");\n-        test(String.format(\"%#-10o\", 12345), fmt.\"%#-10o\\{12345}\");\n-        test(String.format(\"%010o\", -12345), fmt.\"%010o\\{-12345}\");\n-        test(String.format(\"%010o\", 0), fmt.\"%010o\\{0}\");\n-        test(String.format(\"%010o\", 12345), fmt.\"%010o\\{12345}\");\n-        test(String.format(\"%#010o\", -12345), fmt.\"%#010o\\{-12345}\");\n-        test(String.format(\"%#010o\", 0), fmt.\"%#010o\\{0}\");\n-        test(String.format(\"%#010o\", 12345), fmt.\"%#010o\\{12345}\");\n-\n-        test(String.format(\"%x\", -12345), fmt.\"%x\\{-12345}\");\n-        test(String.format(\"%x\", 0), fmt.\"%x\\{0}\");\n-        test(String.format(\"%x\", 12345), fmt.\"%x\\{12345}\");\n-        test(String.format(\"%10x\", -12345), fmt.\"%10x\\{-12345}\");\n-        test(String.format(\"%10x\", 0), fmt.\"%10x\\{0}\");\n-        test(String.format(\"%10x\", 12345), fmt.\"%10x\\{12345}\");\n-        test(String.format(\"%-10x\", -12345), fmt.\"%-10x\\{-12345}\");\n-        test(String.format(\"%-10x\", 0), fmt.\"%-10x\\{0}\");\n-        test(String.format(\"%-10x\", 12345), fmt.\"%-10x\\{12345}\");\n-        test(String.format(\"%X\", -12345), fmt.\"%X\\{-12345}\");\n-        test(String.format(\"%X\", 0), fmt.\"%X\\{0}\");\n-        test(String.format(\"%X\", 12345), fmt.\"%X\\{12345}\");\n-        test(String.format(\"%10X\", -12345), fmt.\"%10X\\{-12345}\");\n-        test(String.format(\"%10X\", 0), fmt.\"%10X\\{0}\");\n-        test(String.format(\"%10X\", 12345), fmt.\"%10X\\{12345}\");\n-        test(String.format(\"%-10X\", -12345), fmt.\"%-10X\\{-12345}\");\n-        test(String.format(\"%-10X\", 0), fmt.\"%-10X\\{0}\");\n-        test(String.format(\"%-10X\", 12345), fmt.\"%-10X\\{12345}\");\n-        test(String.format(\"%#x\", -12345), fmt.\"%#x\\{-12345}\");\n-        test(String.format(\"%#x\", 0), fmt.\"%#x\\{0}\");\n-        test(String.format(\"%#x\", 12345), fmt.\"%#x\\{12345}\");\n-        test(String.format(\"%#10x\", -12345), fmt.\"%#10x\\{-12345}\");\n-        test(String.format(\"%#10x\", 0), fmt.\"%#10x\\{0}\");\n-        test(String.format(\"%#10x\", 12345), fmt.\"%#10x\\{12345}\");\n-        test(String.format(\"%#-10x\", -12345), fmt.\"%#-10x\\{-12345}\");\n-        test(String.format(\"%#-10x\", 0), fmt.\"%#-10x\\{0}\");\n-        test(String.format(\"%#-10x\", 12345), fmt.\"%#-10x\\{12345}\");\n-        test(String.format(\"%#X\", -12345), fmt.\"%#X\\{-12345}\");\n-        test(String.format(\"%#X\", 0), fmt.\"%#X\\{0}\");\n-        test(String.format(\"%#X\", 12345), fmt.\"%#X\\{12345}\");\n-        test(String.format(\"%#10X\", -12345), fmt.\"%#10X\\{-12345}\");\n-        test(String.format(\"%#10X\", 0), fmt.\"%#10X\\{0}\");\n-        test(String.format(\"%#10X\", 12345), fmt.\"%#10X\\{12345}\");\n-        test(String.format(\"%#-10X\", -12345), fmt.\"%#-10X\\{-12345}\");\n-        test(String.format(\"%#-10X\", 0), fmt.\"%#-10X\\{0}\");\n-        test(String.format(\"%#-10X\", 12345), fmt.\"%#-10X\\{12345}\");\n-        test(String.format(\"%010x\", -12345), fmt.\"%010x\\{-12345}\");\n-        test(String.format(\"%010x\", 0), fmt.\"%010x\\{0}\");\n-        test(String.format(\"%010x\", 12345), fmt.\"%010x\\{12345}\");\n-        test(String.format(\"%010X\", -12345), fmt.\"%010X\\{-12345}\");\n-        test(String.format(\"%010X\", 0), fmt.\"%010X\\{0}\");\n-        test(String.format(\"%010X\", 12345), fmt.\"%010X\\{12345}\");\n-        test(String.format(\"%#010x\", -12345), fmt.\"%#010x\\{-12345}\");\n-        test(String.format(\"%#010x\", 0), fmt.\"%#010x\\{0}\");\n-        test(String.format(\"%#010x\", 12345), fmt.\"%#010x\\{12345}\");\n-        test(String.format(\"%#010X\", -12345), fmt.\"%#010X\\{-12345}\");\n-        test(String.format(\"%#010X\", 0), fmt.\"%#010X\\{0}\");\n-        test(String.format(\"%#010X\", 12345), fmt.\"%#010X\\{12345}\");\n-\n-        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n-        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n-        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n-        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n-        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n-        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n-        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n-        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n-        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n-        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n-        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n-        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n-        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n-        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n-        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n-        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n-        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n-        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n-\n-        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n-        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n-        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n-        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n-        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n-        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n-        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n-        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n-        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n-        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n-        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n-        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n-        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n-        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n-        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n-        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n-        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n-        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n-        test(String.format(\"% f\", -12345.6), fmt.\"% f\\{-12345.6}\");\n-        test(String.format(\"% f\", 0.0), fmt.\"% f\\{0.0}\");\n-        test(String.format(\"% f\", 12345.6), fmt.\"% f\\{12345.6}\");\n-        test(String.format(\"% 10f\", -12345.6), fmt.\"% 10f\\{-12345.6}\");\n-        test(String.format(\"% 10f\", 0.0), fmt.\"% 10f\\{0.0}\");\n-        test(String.format(\"% 10f\", 12345.6), fmt.\"% 10f\\{12345.6}\");\n-        test(String.format(\"% -10f\", -12345.6), fmt.\"% -10f\\{-12345.6}\");\n-        test(String.format(\"% -10f\", 0.0), fmt.\"% -10f\\{0.0}\");\n-        test(String.format(\"% -10f\", 12345.6), fmt.\"% -10f\\{12345.6}\");\n-        test(String.format(\"%, f\", -12345.6), fmt.\"%, f\\{-12345.6}\");\n-        test(String.format(\"%, f\", 0.0), fmt.\"%, f\\{0.0}\");\n-        test(String.format(\"%, f\", 12345.6), fmt.\"%, f\\{12345.6}\");\n-        test(String.format(\"%, 10f\", -12345.6), fmt.\"%, 10f\\{-12345.6}\");\n-        test(String.format(\"%, 10f\", 0.0), fmt.\"%, 10f\\{0.0}\");\n-        test(String.format(\"%, 10f\", 12345.6), fmt.\"%, 10f\\{12345.6}\");\n-        test(String.format(\"%, -10f\", -12345.6), fmt.\"%, -10f\\{-12345.6}\");\n-        test(String.format(\"%, -10f\", 0.0), fmt.\"%, -10f\\{0.0}\");\n-        test(String.format(\"%, -10f\", 12345.6), fmt.\"%, -10f\\{12345.6}\");\n-\n-        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n-        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n-        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n-        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n-        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n-        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n-        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n-        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n-        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n-        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n-        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n-        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n-        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n-        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n-        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n-        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n-        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n-        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n-        test(String.format(\"%+f\", -12345.6), fmt.\"%+f\\{-12345.6}\");\n-        test(String.format(\"%+f\", 0.0), fmt.\"%+f\\{0.0}\");\n-        test(String.format(\"%+f\", 12345.6), fmt.\"%+f\\{12345.6}\");\n-        test(String.format(\"%+10f\", -12345.6), fmt.\"%+10f\\{-12345.6}\");\n-        test(String.format(\"%+10f\", 0.0), fmt.\"%+10f\\{0.0}\");\n-        test(String.format(\"%+10f\", 12345.6), fmt.\"%+10f\\{12345.6}\");\n-        test(String.format(\"%+-10f\", -12345.6), fmt.\"%+-10f\\{-12345.6}\");\n-        test(String.format(\"%+-10f\", 0.0), fmt.\"%+-10f\\{0.0}\");\n-        test(String.format(\"%+-10f\", 12345.6), fmt.\"%+-10f\\{12345.6}\");\n-        test(String.format(\"%,+f\", -12345.6), fmt.\"%,+f\\{-12345.6}\");\n-        test(String.format(\"%,+f\", 0.0), fmt.\"%,+f\\{0.0}\");\n-        test(String.format(\"%,+f\", 12345.6), fmt.\"%,+f\\{12345.6}\");\n-        test(String.format(\"%,+10f\", -12345.6), fmt.\"%,+10f\\{-12345.6}\");\n-        test(String.format(\"%,+10f\", 0.0), fmt.\"%,+10f\\{0.0}\");\n-        test(String.format(\"%,+10f\", 12345.6), fmt.\"%,+10f\\{12345.6}\");\n-        test(String.format(\"%,+-10f\", -12345.6), fmt.\"%,+-10f\\{-12345.6}\");\n-        test(String.format(\"%,+-10f\", 0.0), fmt.\"%,+-10f\\{0.0}\");\n-        test(String.format(\"%,+-10f\", 12345.6), fmt.\"%,+-10f\\{12345.6}\");\n-\n-        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n-        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n-        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n-        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n-        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n-        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n-        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n-        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n-        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n-        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n-        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n-        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n-        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n-        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n-        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n-        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n-        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n-        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n-        test(String.format(\"%(f\", -12345.6), fmt.\"%(f\\{-12345.6}\");\n-        test(String.format(\"%(f\", 0.0), fmt.\"%(f\\{0.0}\");\n-        test(String.format(\"%(f\", 12345.6), fmt.\"%(f\\{12345.6}\");\n-        test(String.format(\"%(10f\", -12345.6), fmt.\"%(10f\\{-12345.6}\");\n-        test(String.format(\"%(10f\", 0.0), fmt.\"%(10f\\{0.0}\");\n-        test(String.format(\"%(10f\", 12345.6), fmt.\"%(10f\\{12345.6}\");\n-        test(String.format(\"%(-10f\", -12345.6), fmt.\"%(-10f\\{-12345.6}\");\n-        test(String.format(\"%(-10f\", 0.0), fmt.\"%(-10f\\{0.0}\");\n-        test(String.format(\"%(-10f\", 12345.6), fmt.\"%(-10f\\{12345.6}\");\n-        test(String.format(\"%,(f\", -12345.6), fmt.\"%,(f\\{-12345.6}\");\n-        test(String.format(\"%,(f\", 0.0), fmt.\"%,(f\\{0.0}\");\n-        test(String.format(\"%,(f\", 12345.6), fmt.\"%,(f\\{12345.6}\");\n-        test(String.format(\"%,(10f\", -12345.6), fmt.\"%,(10f\\{-12345.6}\");\n-        test(String.format(\"%,(10f\", 0.0), fmt.\"%,(10f\\{0.0}\");\n-        test(String.format(\"%,(10f\", 12345.6), fmt.\"%,(10f\\{12345.6}\");\n-        test(String.format(\"%,(-10f\", -12345.6), fmt.\"%,(-10f\\{-12345.6}\");\n-        test(String.format(\"%,(-10f\", 0.0), fmt.\"%,(-10f\\{0.0}\");\n-        test(String.format(\"%,(-10f\", 12345.6), fmt.\"%,(-10f\\{12345.6}\");\n-        test(String.format(\"%+f\", -12345.6), fmt.\"%+f\\{-12345.6}\");\n-        test(String.format(\"%+f\", 0.0), fmt.\"%+f\\{0.0}\");\n-        test(String.format(\"%+f\", 12345.6), fmt.\"%+f\\{12345.6}\");\n-        test(String.format(\"%+10f\", -12345.6), fmt.\"%+10f\\{-12345.6}\");\n-        test(String.format(\"%+10f\", 0.0), fmt.\"%+10f\\{0.0}\");\n-        test(String.format(\"%+10f\", 12345.6), fmt.\"%+10f\\{12345.6}\");\n-        test(String.format(\"%+-10f\", -12345.6), fmt.\"%+-10f\\{-12345.6}\");\n-        test(String.format(\"%+-10f\", 0.0), fmt.\"%+-10f\\{0.0}\");\n-        test(String.format(\"%+-10f\", 12345.6), fmt.\"%+-10f\\{12345.6}\");\n-        test(String.format(\"%,+f\", -12345.6), fmt.\"%,+f\\{-12345.6}\");\n-        test(String.format(\"%,+f\", 0.0), fmt.\"%,+f\\{0.0}\");\n-        test(String.format(\"%,+f\", 12345.6), fmt.\"%,+f\\{12345.6}\");\n-        test(String.format(\"%,+10f\", -12345.6), fmt.\"%,+10f\\{-12345.6}\");\n-        test(String.format(\"%,+10f\", 0.0), fmt.\"%,+10f\\{0.0}\");\n-        test(String.format(\"%,+10f\", 12345.6), fmt.\"%,+10f\\{12345.6}\");\n-        test(String.format(\"%,+-10f\", -12345.6), fmt.\"%,+-10f\\{-12345.6}\");\n-        test(String.format(\"%,+-10f\", 0.0), fmt.\"%,+-10f\\{0.0}\");\n-        test(String.format(\"%,+-10f\", 12345.6), fmt.\"%,+-10f\\{12345.6}\");\n-        test(String.format(\"%(+f\", -12345.6), fmt.\"%(+f\\{-12345.6}\");\n-        test(String.format(\"%(+f\", 0.0), fmt.\"%(+f\\{0.0}\");\n-        test(String.format(\"%(+f\", 12345.6), fmt.\"%(+f\\{12345.6}\");\n-        test(String.format(\"%(+10f\", -12345.6), fmt.\"%(+10f\\{-12345.6}\");\n-        test(String.format(\"%(+10f\", 0.0), fmt.\"%(+10f\\{0.0}\");\n-        test(String.format(\"%(+10f\", 12345.6), fmt.\"%(+10f\\{12345.6}\");\n-        test(String.format(\"%(+-10f\", -12345.6), fmt.\"%(+-10f\\{-12345.6}\");\n-        test(String.format(\"%(+-10f\", 0.0), fmt.\"%(+-10f\\{0.0}\");\n-        test(String.format(\"%(+-10f\", 12345.6), fmt.\"%(+-10f\\{12345.6}\");\n-        test(String.format(\"%,(+f\", -12345.6), fmt.\"%,(+f\\{-12345.6}\");\n-        test(String.format(\"%,(+f\", 0.0), fmt.\"%,(+f\\{0.0}\");\n-        test(String.format(\"%,(+f\", 12345.6), fmt.\"%,(+f\\{12345.6}\");\n-        test(String.format(\"%,(+10f\", -12345.6), fmt.\"%,(+10f\\{-12345.6}\");\n-        test(String.format(\"%,(+10f\", 0.0), fmt.\"%,(+10f\\{0.0}\");\n-        test(String.format(\"%,(+10f\", 12345.6), fmt.\"%,(+10f\\{12345.6}\");\n-        test(String.format(\"%,(+-10f\", -12345.6), fmt.\"%,(+-10f\\{-12345.6}\");\n-        test(String.format(\"%,(+-10f\", 0.0), fmt.\"%,(+-10f\\{0.0}\");\n-        test(String.format(\"%,(+-10f\", 12345.6), fmt.\"%,(+-10f\\{12345.6}\");\n-\n-        test(String.format(\"%e\", -12345.6), fmt.\"%e\\{-12345.6}\");\n-        test(String.format(\"%e\", 0.0), fmt.\"%e\\{0.0}\");\n-        test(String.format(\"%e\", 12345.6), fmt.\"%e\\{12345.6}\");\n-        test(String.format(\"%10e\", -12345.6), fmt.\"%10e\\{-12345.6}\");\n-        test(String.format(\"%10e\", 0.0), fmt.\"%10e\\{0.0}\");\n-        test(String.format(\"%10e\", 12345.6), fmt.\"%10e\\{12345.6}\");\n-        test(String.format(\"%-10e\", -12345.6), fmt.\"%-10e\\{-12345.6}\");\n-        test(String.format(\"%-10e\", 0.0), fmt.\"%-10e\\{0.0}\");\n-        test(String.format(\"%-10e\", 12345.6), fmt.\"%-10e\\{12345.6}\");\n-        test(String.format(\"%E\", -12345.6), fmt.\"%E\\{-12345.6}\");\n-        test(String.format(\"%E\", 0.0), fmt.\"%E\\{0.0}\");\n-        test(String.format(\"%E\", 12345.6), fmt.\"%E\\{12345.6}\");\n-        test(String.format(\"%10E\", -12345.6), fmt.\"%10E\\{-12345.6}\");\n-        test(String.format(\"%10E\", 0.0), fmt.\"%10E\\{0.0}\");\n-        test(String.format(\"%10E\", 12345.6), fmt.\"%10E\\{12345.6}\");\n-        test(String.format(\"%-10E\", -12345.6), fmt.\"%-10E\\{-12345.6}\");\n-        test(String.format(\"%-10E\", 0.0), fmt.\"%-10E\\{0.0}\");\n-        test(String.format(\"%-10E\", 12345.6), fmt.\"%-10E\\{12345.6}\");\n-\n-        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n-        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n-        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n-        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n-        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n-        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n-        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n-        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n-        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n-        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n-        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n-        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n-        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n-        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n-        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n-        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n-        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n-        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n-        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n-        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n-        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n-        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n-        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n-        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n-        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n-        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n-        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n-        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n-        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n-        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n-        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n-        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n-        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n-        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n-        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n-        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n-\n-        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n-        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n-        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n-        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n-        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n-        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n-        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n-        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n-        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n-        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n-        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n-        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n-        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n-        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n-        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n-        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n-        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n-        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n-        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n-        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n-        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n-        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n-        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n-        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n-        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n-        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n-        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n-        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n-        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n-        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n-        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n-        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n-        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n-        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n-        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n-        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n-        test(String.format(\"% g\", -12345.6), fmt.\"% g\\{-12345.6}\");\n-        test(String.format(\"% g\", 0.0), fmt.\"% g\\{0.0}\");\n-        test(String.format(\"% g\", 12345.6), fmt.\"% g\\{12345.6}\");\n-        test(String.format(\"% 10g\", -12345.6), fmt.\"% 10g\\{-12345.6}\");\n-        test(String.format(\"% 10g\", 0.0), fmt.\"% 10g\\{0.0}\");\n-        test(String.format(\"% 10g\", 12345.6), fmt.\"% 10g\\{12345.6}\");\n-        test(String.format(\"% -10g\", -12345.6), fmt.\"% -10g\\{-12345.6}\");\n-        test(String.format(\"% -10g\", 0.0), fmt.\"% -10g\\{0.0}\");\n-        test(String.format(\"% -10g\", 12345.6), fmt.\"% -10g\\{12345.6}\");\n-        test(String.format(\"% G\", -12345.6), fmt.\"% G\\{-12345.6}\");\n-        test(String.format(\"% G\", 0.0), fmt.\"% G\\{0.0}\");\n-        test(String.format(\"% G\", 12345.6), fmt.\"% G\\{12345.6}\");\n-        test(String.format(\"% 10G\", -12345.6), fmt.\"% 10G\\{-12345.6}\");\n-        test(String.format(\"% 10G\", 0.0), fmt.\"% 10G\\{0.0}\");\n-        test(String.format(\"% 10G\", 12345.6), fmt.\"% 10G\\{12345.6}\");\n-        test(String.format(\"% -10G\", -12345.6), fmt.\"% -10G\\{-12345.6}\");\n-        test(String.format(\"% -10G\", 0.0), fmt.\"% -10G\\{0.0}\");\n-        test(String.format(\"% -10G\", 12345.6), fmt.\"% -10G\\{12345.6}\");\n-        test(String.format(\"%, g\", -12345.6), fmt.\"%, g\\{-12345.6}\");\n-        test(String.format(\"%, g\", 0.0), fmt.\"%, g\\{0.0}\");\n-        test(String.format(\"%, g\", 12345.6), fmt.\"%, g\\{12345.6}\");\n-        test(String.format(\"%, 10g\", -12345.6), fmt.\"%, 10g\\{-12345.6}\");\n-        test(String.format(\"%, 10g\", 0.0), fmt.\"%, 10g\\{0.0}\");\n-        test(String.format(\"%, 10g\", 12345.6), fmt.\"%, 10g\\{12345.6}\");\n-        test(String.format(\"%, -10g\", -12345.6), fmt.\"%, -10g\\{-12345.6}\");\n-        test(String.format(\"%, -10g\", 0.0), fmt.\"%, -10g\\{0.0}\");\n-        test(String.format(\"%, -10g\", 12345.6), fmt.\"%, -10g\\{12345.6}\");\n-        test(String.format(\"%, G\", -12345.6), fmt.\"%, G\\{-12345.6}\");\n-        test(String.format(\"%, G\", 0.0), fmt.\"%, G\\{0.0}\");\n-        test(String.format(\"%, G\", 12345.6), fmt.\"%, G\\{12345.6}\");\n-        test(String.format(\"%, 10G\", -12345.6), fmt.\"%, 10G\\{-12345.6}\");\n-        test(String.format(\"%, 10G\", 0.0), fmt.\"%, 10G\\{0.0}\");\n-        test(String.format(\"%, 10G\", 12345.6), fmt.\"%, 10G\\{12345.6}\");\n-        test(String.format(\"%, -10G\", -12345.6), fmt.\"%, -10G\\{-12345.6}\");\n-        test(String.format(\"%, -10G\", 0.0), fmt.\"%, -10G\\{0.0}\");\n-        test(String.format(\"%, -10G\", 12345.6), fmt.\"%, -10G\\{12345.6}\");\n-\n-        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n-        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n-        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n-        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n-        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n-        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n-        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n-        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n-        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n-        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n-        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n-        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n-        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n-        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n-        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n-        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n-        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n-        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n-        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n-        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n-        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n-        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n-        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n-        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n-        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n-        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n-        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n-        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n-        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n-        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n-        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n-        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n-        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n-        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n-        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n-        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n-        test(String.format(\"%+g\", -12345.6), fmt.\"%+g\\{-12345.6}\");\n-        test(String.format(\"%+g\", 0.0), fmt.\"%+g\\{0.0}\");\n-        test(String.format(\"%+g\", 12345.6), fmt.\"%+g\\{12345.6}\");\n-        test(String.format(\"%+10g\", -12345.6), fmt.\"%+10g\\{-12345.6}\");\n-        test(String.format(\"%+10g\", 0.0), fmt.\"%+10g\\{0.0}\");\n-        test(String.format(\"%+10g\", 12345.6), fmt.\"%+10g\\{12345.6}\");\n-        test(String.format(\"%+-10g\", -12345.6), fmt.\"%+-10g\\{-12345.6}\");\n-        test(String.format(\"%+-10g\", 0.0), fmt.\"%+-10g\\{0.0}\");\n-        test(String.format(\"%+-10g\", 12345.6), fmt.\"%+-10g\\{12345.6}\");\n-        test(String.format(\"%+G\", -12345.6), fmt.\"%+G\\{-12345.6}\");\n-        test(String.format(\"%+G\", 0.0), fmt.\"%+G\\{0.0}\");\n-        test(String.format(\"%+G\", 12345.6), fmt.\"%+G\\{12345.6}\");\n-        test(String.format(\"%+10G\", -12345.6), fmt.\"%+10G\\{-12345.6}\");\n-        test(String.format(\"%+10G\", 0.0), fmt.\"%+10G\\{0.0}\");\n-        test(String.format(\"%+10G\", 12345.6), fmt.\"%+10G\\{12345.6}\");\n-        test(String.format(\"%+-10G\", -12345.6), fmt.\"%+-10G\\{-12345.6}\");\n-        test(String.format(\"%+-10G\", 0.0), fmt.\"%+-10G\\{0.0}\");\n-        test(String.format(\"%+-10G\", 12345.6), fmt.\"%+-10G\\{12345.6}\");\n-        test(String.format(\"%,+g\", -12345.6), fmt.\"%,+g\\{-12345.6}\");\n-        test(String.format(\"%,+g\", 0.0), fmt.\"%,+g\\{0.0}\");\n-        test(String.format(\"%,+g\", 12345.6), fmt.\"%,+g\\{12345.6}\");\n-        test(String.format(\"%,+10g\", -12345.6), fmt.\"%,+10g\\{-12345.6}\");\n-        test(String.format(\"%,+10g\", 0.0), fmt.\"%,+10g\\{0.0}\");\n-        test(String.format(\"%,+10g\", 12345.6), fmt.\"%,+10g\\{12345.6}\");\n-        test(String.format(\"%,+-10g\", -12345.6), fmt.\"%,+-10g\\{-12345.6}\");\n-        test(String.format(\"%,+-10g\", 0.0), fmt.\"%,+-10g\\{0.0}\");\n-        test(String.format(\"%,+-10g\", 12345.6), fmt.\"%,+-10g\\{12345.6}\");\n-        test(String.format(\"%,+G\", -12345.6), fmt.\"%,+G\\{-12345.6}\");\n-        test(String.format(\"%,+G\", 0.0), fmt.\"%,+G\\{0.0}\");\n-        test(String.format(\"%,+G\", 12345.6), fmt.\"%,+G\\{12345.6}\");\n-        test(String.format(\"%,+10G\", -12345.6), fmt.\"%,+10G\\{-12345.6}\");\n-        test(String.format(\"%,+10G\", 0.0), fmt.\"%,+10G\\{0.0}\");\n-        test(String.format(\"%,+10G\", 12345.6), fmt.\"%,+10G\\{12345.6}\");\n-        test(String.format(\"%,+-10G\", -12345.6), fmt.\"%,+-10G\\{-12345.6}\");\n-        test(String.format(\"%,+-10G\", 0.0), fmt.\"%,+-10G\\{0.0}\");\n-        test(String.format(\"%,+-10G\", 12345.6), fmt.\"%,+-10G\\{12345.6}\");\n-\n-        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n-        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n-        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n-        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n-        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n-        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n-        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n-        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n-        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n-        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n-        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n-        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n-        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n-        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n-        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n-        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n-        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n-        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n-        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n-        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n-        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n-        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n-        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n-        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n-        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n-        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n-        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n-        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n-        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n-        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n-        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n-        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n-        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n-        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n-        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n-        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n-        test(String.format(\"%(g\", -12345.6), fmt.\"%(g\\{-12345.6}\");\n-        test(String.format(\"%(g\", 0.0), fmt.\"%(g\\{0.0}\");\n-        test(String.format(\"%(g\", 12345.6), fmt.\"%(g\\{12345.6}\");\n-        test(String.format(\"%(10g\", -12345.6), fmt.\"%(10g\\{-12345.6}\");\n-        test(String.format(\"%(10g\", 0.0), fmt.\"%(10g\\{0.0}\");\n-        test(String.format(\"%(10g\", 12345.6), fmt.\"%(10g\\{12345.6}\");\n-        test(String.format(\"%(-10g\", -12345.6), fmt.\"%(-10g\\{-12345.6}\");\n-        test(String.format(\"%(-10g\", 0.0), fmt.\"%(-10g\\{0.0}\");\n-        test(String.format(\"%(-10g\", 12345.6), fmt.\"%(-10g\\{12345.6}\");\n-        test(String.format(\"%(G\", -12345.6), fmt.\"%(G\\{-12345.6}\");\n-        test(String.format(\"%(G\", 0.0), fmt.\"%(G\\{0.0}\");\n-        test(String.format(\"%(G\", 12345.6), fmt.\"%(G\\{12345.6}\");\n-        test(String.format(\"%(10G\", -12345.6), fmt.\"%(10G\\{-12345.6}\");\n-        test(String.format(\"%(10G\", 0.0), fmt.\"%(10G\\{0.0}\");\n-        test(String.format(\"%(10G\", 12345.6), fmt.\"%(10G\\{12345.6}\");\n-        test(String.format(\"%(-10G\", -12345.6), fmt.\"%(-10G\\{-12345.6}\");\n-        test(String.format(\"%(-10G\", 0.0), fmt.\"%(-10G\\{0.0}\");\n-        test(String.format(\"%(-10G\", 12345.6), fmt.\"%(-10G\\{12345.6}\");\n-        test(String.format(\"%,(g\", -12345.6), fmt.\"%,(g\\{-12345.6}\");\n-        test(String.format(\"%,(g\", 0.0), fmt.\"%,(g\\{0.0}\");\n-        test(String.format(\"%,(g\", 12345.6), fmt.\"%,(g\\{12345.6}\");\n-        test(String.format(\"%,(10g\", -12345.6), fmt.\"%,(10g\\{-12345.6}\");\n-        test(String.format(\"%,(10g\", 0.0), fmt.\"%,(10g\\{0.0}\");\n-        test(String.format(\"%,(10g\", 12345.6), fmt.\"%,(10g\\{12345.6}\");\n-        test(String.format(\"%,(-10g\", -12345.6), fmt.\"%,(-10g\\{-12345.6}\");\n-        test(String.format(\"%,(-10g\", 0.0), fmt.\"%,(-10g\\{0.0}\");\n-        test(String.format(\"%,(-10g\", 12345.6), fmt.\"%,(-10g\\{12345.6}\");\n-        test(String.format(\"%,(G\", -12345.6), fmt.\"%,(G\\{-12345.6}\");\n-        test(String.format(\"%,(G\", 0.0), fmt.\"%,(G\\{0.0}\");\n-        test(String.format(\"%,(G\", 12345.6), fmt.\"%,(G\\{12345.6}\");\n-        test(String.format(\"%,(10G\", -12345.6), fmt.\"%,(10G\\{-12345.6}\");\n-        test(String.format(\"%,(10G\", 0.0), fmt.\"%,(10G\\{0.0}\");\n-        test(String.format(\"%,(10G\", 12345.6), fmt.\"%,(10G\\{12345.6}\");\n-        test(String.format(\"%,(-10G\", -12345.6), fmt.\"%,(-10G\\{-12345.6}\");\n-        test(String.format(\"%,(-10G\", 0.0), fmt.\"%,(-10G\\{0.0}\");\n-        test(String.format(\"%,(-10G\", 12345.6), fmt.\"%,(-10G\\{12345.6}\");\n-        test(String.format(\"%+g\", -12345.6), fmt.\"%+g\\{-12345.6}\");\n-        test(String.format(\"%+g\", 0.0), fmt.\"%+g\\{0.0}\");\n-        test(String.format(\"%+g\", 12345.6), fmt.\"%+g\\{12345.6}\");\n-        test(String.format(\"%+10g\", -12345.6), fmt.\"%+10g\\{-12345.6}\");\n-        test(String.format(\"%+10g\", 0.0), fmt.\"%+10g\\{0.0}\");\n-        test(String.format(\"%+10g\", 12345.6), fmt.\"%+10g\\{12345.6}\");\n-        test(String.format(\"%+-10g\", -12345.6), fmt.\"%+-10g\\{-12345.6}\");\n-        test(String.format(\"%+-10g\", 0.0), fmt.\"%+-10g\\{0.0}\");\n-        test(String.format(\"%+-10g\", 12345.6), fmt.\"%+-10g\\{12345.6}\");\n-        test(String.format(\"%+G\", -12345.6), fmt.\"%+G\\{-12345.6}\");\n-        test(String.format(\"%+G\", 0.0), fmt.\"%+G\\{0.0}\");\n-        test(String.format(\"%+G\", 12345.6), fmt.\"%+G\\{12345.6}\");\n-        test(String.format(\"%+10G\", -12345.6), fmt.\"%+10G\\{-12345.6}\");\n-        test(String.format(\"%+10G\", 0.0), fmt.\"%+10G\\{0.0}\");\n-        test(String.format(\"%+10G\", 12345.6), fmt.\"%+10G\\{12345.6}\");\n-        test(String.format(\"%+-10G\", -12345.6), fmt.\"%+-10G\\{-12345.6}\");\n-        test(String.format(\"%+-10G\", 0.0), fmt.\"%+-10G\\{0.0}\");\n-        test(String.format(\"%+-10G\", 12345.6), fmt.\"%+-10G\\{12345.6}\");\n-        test(String.format(\"%,+g\", -12345.6), fmt.\"%,+g\\{-12345.6}\");\n-        test(String.format(\"%,+g\", 0.0), fmt.\"%,+g\\{0.0}\");\n-        test(String.format(\"%,+g\", 12345.6), fmt.\"%,+g\\{12345.6}\");\n-        test(String.format(\"%,+10g\", -12345.6), fmt.\"%,+10g\\{-12345.6}\");\n-        test(String.format(\"%,+10g\", 0.0), fmt.\"%,+10g\\{0.0}\");\n-        test(String.format(\"%,+10g\", 12345.6), fmt.\"%,+10g\\{12345.6}\");\n-        test(String.format(\"%,+-10g\", -12345.6), fmt.\"%,+-10g\\{-12345.6}\");\n-        test(String.format(\"%,+-10g\", 0.0), fmt.\"%,+-10g\\{0.0}\");\n-        test(String.format(\"%,+-10g\", 12345.6), fmt.\"%,+-10g\\{12345.6}\");\n-        test(String.format(\"%,+G\", -12345.6), fmt.\"%,+G\\{-12345.6}\");\n-        test(String.format(\"%,+G\", 0.0), fmt.\"%,+G\\{0.0}\");\n-        test(String.format(\"%,+G\", 12345.6), fmt.\"%,+G\\{12345.6}\");\n-        test(String.format(\"%,+10G\", -12345.6), fmt.\"%,+10G\\{-12345.6}\");\n-        test(String.format(\"%,+10G\", 0.0), fmt.\"%,+10G\\{0.0}\");\n-        test(String.format(\"%,+10G\", 12345.6), fmt.\"%,+10G\\{12345.6}\");\n-        test(String.format(\"%,+-10G\", -12345.6), fmt.\"%,+-10G\\{-12345.6}\");\n-        test(String.format(\"%,+-10G\", 0.0), fmt.\"%,+-10G\\{0.0}\");\n-        test(String.format(\"%,+-10G\", 12345.6), fmt.\"%,+-10G\\{12345.6}\");\n-        test(String.format(\"%(+g\", -12345.6), fmt.\"%(+g\\{-12345.6}\");\n-        test(String.format(\"%(+g\", 0.0), fmt.\"%(+g\\{0.0}\");\n-        test(String.format(\"%(+g\", 12345.6), fmt.\"%(+g\\{12345.6}\");\n-        test(String.format(\"%(+10g\", -12345.6), fmt.\"%(+10g\\{-12345.6}\");\n-        test(String.format(\"%(+10g\", 0.0), fmt.\"%(+10g\\{0.0}\");\n-        test(String.format(\"%(+10g\", 12345.6), fmt.\"%(+10g\\{12345.6}\");\n-        test(String.format(\"%(+-10g\", -12345.6), fmt.\"%(+-10g\\{-12345.6}\");\n-        test(String.format(\"%(+-10g\", 0.0), fmt.\"%(+-10g\\{0.0}\");\n-        test(String.format(\"%(+-10g\", 12345.6), fmt.\"%(+-10g\\{12345.6}\");\n-        test(String.format(\"%(+G\", -12345.6), fmt.\"%(+G\\{-12345.6}\");\n-        test(String.format(\"%(+G\", 0.0), fmt.\"%(+G\\{0.0}\");\n-        test(String.format(\"%(+G\", 12345.6), fmt.\"%(+G\\{12345.6}\");\n-        test(String.format(\"%(+10G\", -12345.6), fmt.\"%(+10G\\{-12345.6}\");\n-        test(String.format(\"%(+10G\", 0.0), fmt.\"%(+10G\\{0.0}\");\n-        test(String.format(\"%(+10G\", 12345.6), fmt.\"%(+10G\\{12345.6}\");\n-        test(String.format(\"%(+-10G\", -12345.6), fmt.\"%(+-10G\\{-12345.6}\");\n-        test(String.format(\"%(+-10G\", 0.0), fmt.\"%(+-10G\\{0.0}\");\n-        test(String.format(\"%(+-10G\", 12345.6), fmt.\"%(+-10G\\{12345.6}\");\n-        test(String.format(\"%,(+g\", -12345.6), fmt.\"%,(+g\\{-12345.6}\");\n-        test(String.format(\"%,(+g\", 0.0), fmt.\"%,(+g\\{0.0}\");\n-        test(String.format(\"%,(+g\", 12345.6), fmt.\"%,(+g\\{12345.6}\");\n-        test(String.format(\"%,(+10g\", -12345.6), fmt.\"%,(+10g\\{-12345.6}\");\n-        test(String.format(\"%,(+10g\", 0.0), fmt.\"%,(+10g\\{0.0}\");\n-        test(String.format(\"%,(+10g\", 12345.6), fmt.\"%,(+10g\\{12345.6}\");\n-        test(String.format(\"%,(+-10g\", -12345.6), fmt.\"%,(+-10g\\{-12345.6}\");\n-        test(String.format(\"%,(+-10g\", 0.0), fmt.\"%,(+-10g\\{0.0}\");\n-        test(String.format(\"%,(+-10g\", 12345.6), fmt.\"%,(+-10g\\{12345.6}\");\n-        test(String.format(\"%,(+G\", -12345.6), fmt.\"%,(+G\\{-12345.6}\");\n-        test(String.format(\"%,(+G\", 0.0), fmt.\"%,(+G\\{0.0}\");\n-        test(String.format(\"%,(+G\", 12345.6), fmt.\"%,(+G\\{12345.6}\");\n-        test(String.format(\"%,(+10G\", -12345.6), fmt.\"%,(+10G\\{-12345.6}\");\n-        test(String.format(\"%,(+10G\", 0.0), fmt.\"%,(+10G\\{0.0}\");\n-        test(String.format(\"%,(+10G\", 12345.6), fmt.\"%,(+10G\\{12345.6}\");\n-        test(String.format(\"%,(+-10G\", -12345.6), fmt.\"%,(+-10G\\{-12345.6}\");\n-        test(String.format(\"%,(+-10G\", 0.0), fmt.\"%,(+-10G\\{0.0}\");\n-        test(String.format(\"%,(+-10G\", 12345.6), fmt.\"%,(+-10G\\{12345.6}\");\n-\n-        test(String.format(\"%a\", -12345.6), fmt.\"%a\\{-12345.6}\");\n-        test(String.format(\"%a\", 0.0), fmt.\"%a\\{0.0}\");\n-        test(String.format(\"%a\", 12345.6), fmt.\"%a\\{12345.6}\");\n-        test(String.format(\"%10a\", -12345.6), fmt.\"%10a\\{-12345.6}\");\n-        test(String.format(\"%10a\", 0.0), fmt.\"%10a\\{0.0}\");\n-        test(String.format(\"%10a\", 12345.6), fmt.\"%10a\\{12345.6}\");\n-        test(String.format(\"%-10a\", -12345.6), fmt.\"%-10a\\{-12345.6}\");\n-        test(String.format(\"%-10a\", 0.0), fmt.\"%-10a\\{0.0}\");\n-        test(String.format(\"%-10a\", 12345.6), fmt.\"%-10a\\{12345.6}\");\n-        test(String.format(\"%A\", -12345.6), fmt.\"%A\\{-12345.6}\");\n-        test(String.format(\"%A\", 0.0), fmt.\"%A\\{0.0}\");\n-        test(String.format(\"%A\", 12345.6), fmt.\"%A\\{12345.6}\");\n-        test(String.format(\"%10A\", -12345.6), fmt.\"%10A\\{-12345.6}\");\n-        test(String.format(\"%10A\", 0.0), fmt.\"%10A\\{0.0}\");\n-        test(String.format(\"%10A\", 12345.6), fmt.\"%10A\\{12345.6}\");\n-        test(String.format(\"%-10A\", -12345.6), fmt.\"%-10A\\{-12345.6}\");\n-        test(String.format(\"%-10A\", 0.0), fmt.\"%-10A\\{0.0}\");\n-        test(String.format(\"%-10A\", 12345.6), fmt.\"%-10A\\{12345.6}\");\n-\n-        test(\"aaa%false\", fmt.\"aaa%%%b\\{false}\");\n-        test(\"aaa\" + System.lineSeparator() + \"false\", fmt.\"aaa%n%b\\{false}\");\n-\n-        assertThrows(\n-                MissingFormatArgumentException.class,\n-                () -> fmt. \"%10ba\\{ false }\",\n-                \"Format specifier '%10b is not immediately followed by an embedded expression'\");\n-\n-        assertThrows(\n-                MissingFormatArgumentException.class,\n-                () ->fmt. \"%ba\\{ false }\",\n-                \"Format specifier '%b is not immediately followed by an embedded expression'\");\n-\n-        assertThrows(\n-                MissingFormatArgumentException.class,\n-                () ->fmt. \"%b\",\n-                \"Format specifier '%b is not immediately followed by an embedded expression'\");\n-        assertThrows(\n-                UnknownFormatConversionException.class,\n-                () ->fmt. \"%0\",\n-                \"Conversion = '0'\");\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/template\/FormatterBuilder.java","additions":0,"deletions":961,"binary":false,"changes":961,"status":"deleted"},{"patch":"@@ -1,304 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 0000000\n- * @summary Exercise runtime handing of templated strings.\n- * @enablePreview true\n- *\/\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.FilterOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.net.URI;\n-import java.util.*;\n-import java.util.function.Supplier;\n-import javax.tools.FileObject;\n-import javax.tools.ForwardingJavaFileManager;\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import static javax.tools.StandardLocation.CLASS_OUTPUT;\n-import javax.tools.ToolProvider;\n-\n-public class StringTemplateTest {\n-    enum Category{GENERAL, CHARACTER, INTEGRAL, BIG_INT, FLOATING, BIG_FLOAT, DATE};\n-\n-    static final String[] GENERAL = {\"true\", \"false\", \"(Object)null\", \"STR\", \"BO\", \"BOOL\", \"(Boolean)null\"};\n-    static final String[] CHARS = {\"C\", \"CHAR\", \"(Character)null\"};\n-    static final String[] INTS = {\"L\", \"LONG\", \"I\", \"INT\", \"S\", \"SHORT\", \"BY\", \"BYTE\", \"Long.MAX_VALUE\", \"Long.MIN_VALUE\", \"(Long)null\", \"(Integer)null\", \"(Short)null\", \"(Byte)null\"};\n-    static final String[] BIGINTS = {};\n-    static final String[] FLOATS = {\"F\", \"FLOAT\", \"D\", \"DOUBLE\", \"Double.NEGATIVE_INFINITY\", \"Double.NaN\", \"Double.MAX_VALUE\", \"(Double)null\", \"(Float)null\"};\n-    static final String[] BIGFLOATS = {};\n-    static final String[] DATES = {};\n-\n-    final Random r = new Random(1);\n-\n-    String randomValue(Category category) {\n-        return switch (category) {\n-            case GENERAL -> randomChoice(\n-                    GENERAL,\n-                    () -> randomValue(Category.CHARACTER),\n-                    () -> randomValue(Category.INTEGRAL),\n-                    () -> randomValue(Category.BIG_INT),\n-                    () -> randomValue(Category.FLOATING),\n-                    () -> randomValue(Category.BIG_FLOAT),\n-                    () -> randomValue(Category.DATE),\n-                    () -> \"\\\"\" + randomString(r.nextInt(10)) + \"\\\"\");\n-            case CHARACTER -> randomChoice(\n-                    CHARS,\n-                    () -> \"\\'\" + randomString(1) + \"\\'\");\n-            case INTEGRAL -> randomChoice(\n-                    INTS,\n-                    () -> \"(byte)\" + String.valueOf(r.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE)),\n-                    () -> \"(short)\" + String.valueOf(r.nextInt(Short.MIN_VALUE, Short.MAX_VALUE)),\n-                    () -> String.valueOf(r.nextInt()),\n-                    () -> r.nextLong() + \"l\");\n-            case BIG_INT -> randomChoice(\n-                    BIGINTS,\n-                    () -> \"new java.math.BigInteger(\\\"\" + r.nextLong() + \"\\\")\");\n-            case FLOATING -> randomChoice(\n-                    FLOATS,\n-                    () -> String.valueOf(r.nextDouble()),\n-                    () -> r.nextFloat() + \"f\");\n-            case BIG_FLOAT -> randomChoice(\n-                    BIGFLOATS,\n-                    () -> \"new java.math.BigDecimal(\" + r.nextDouble() + \")\");\n-            case DATE -> randomChoice(\n-                    DATES,\n-                    () -> \"new java.util.Date(\" + r.nextLong() + \"l)\",\n-                    () -> r.nextLong() + \"l\");\n-        };\n-    }\n-\n-    String randomChoice(Supplier<String>... suppl) {\n-        return suppl[r.nextInt(suppl.length)].get();\n-    }\n-\n-    String randomChoice(String... values) {\n-        return values[r.nextInt(values.length)];\n-    }\n-\n-    String randomChoice(String[] values, Supplier<String>... suppl) {\n-        int i = r.nextInt(values.length + suppl.length);\n-        return i < values.length ? values[i] : suppl[i - values.length].get();\n-    }\n-\n-    String randomString(int length) {\n-        var sb = new StringBuilder(length << 2);\n-        while (length-- > 0) {\n-            char ch = (char)r.nextInt(9, 128);\n-            var s = switch (ch) {\n-                case '\\t' -> \"\\\\t\";\n-                case '\\'' -> \"\\\\\\'\";\n-                case '\"' -> \"\\\\\\\"\";\n-                case '\\r' -> \"\\\\r\";\n-                case '\\\\' -> \"\\\\\\\\\";\n-                case '\\n' -> \"\\\\n\";\n-                case '\\f' -> \"\\\\f\";\n-                case '\\b' -> \"\\\\b\";\n-                default -> ch + \"\";\n-            };\n-            sb.append(s);\n-        }\n-        return sb.toString();\n-    }\n-\n-    String randomFormat(Category category) {\n-        char c;\n-        return \"%\" + switch (category) {\n-            case GENERAL -> randomWidth(\"-\") + randomPrecision() + randomChar(\"bBhHsS\");\n-            case CHARACTER -> randomWidth(\"-\") + randomChar(\"cC\");\n-            case INTEGRAL -> switch (c = randomChar(\"doxX\")) {\n-                case 'd' -> randomFlags(\"+ ,(\");\n-                default -> randomFlags(\"\");\n-            } + randomWidth(\"-0\") + c;\n-            case BIG_INT -> switch (c = randomChar(\"doxX\")) {\n-                case 'd' -> randomFlags(\"+ ,(\");\n-                default -> randomFlags(\"+ (\");\n-            } + randomWidth(\"-0\") + c;\n-            case FLOATING -> switch (c = randomChar(\"eEfaAgG\")) {\n-                case 'a', 'A' -> randomFlags(\"+ \") + randomWidth(\"-0\");\n-                case 'e', 'E' -> randomFlags(\"+ (\") + randomWidth(\"-0\") + randomPrecision();\n-                default -> randomFlags(\"+ ,(\") + randomWidth(\"-0\") + randomPrecision();\n-            } + c;\n-            case BIG_FLOAT -> switch (c = randomChar(\"eEfgG\")) {\n-                case 'e', 'E' -> randomFlags(\"+ (\") + randomWidth(\"-0\") + randomPrecision();\n-                default -> randomFlags(\"+ ,(\") + randomWidth(\"-0\") + randomPrecision();\n-            } + c;\n-            case DATE ->  randomWidth(\"-\") + randomChar(\"tT\") + randomChar(\"BbhAaCYyjmdeRTrDFc\");\n-        };\n-    }\n-\n-    String randomFlags(String flags) {\n-        var sb = new StringBuilder(flags.length());\n-        for (var f : flags.toCharArray()) {\n-            if (r.nextBoolean() && (f != ' ' || sb.length() == 0 || sb.charAt(sb.length() - 1) != '+')) sb.append(f);\n-        }\n-        return sb.toString();\n-    }\n-\n-    char randomChar(String chars) {\n-        return chars.charAt(r.nextInt(chars.length()));\n-    }\n-\n-    String randomWidth(String flags) {\n-        var f = r.nextInt(flags.length() + 1);\n-        return r.nextBoolean() ? (r.nextBoolean() ? flags.charAt(r.nextInt(flags.length())) : \"\") + String.valueOf(r.nextInt(10) + 1) : \"\";\n-    }\n-\n-    String randomPrecision() {\n-        return r.nextBoolean() ? '.' + String.valueOf(r.nextInt(10) + 1) : \"\";\n-    }\n-\n-    public Class<?> compile() throws Exception {\n-        var classes = new HashMap<String, byte[]>();\n-        var fileManager = new ForwardingJavaFileManager(ToolProvider.getSystemJavaCompiler().getStandardFileManager(null, null, null)) {\n-            @Override\n-            public ClassLoader getClassLoader(JavaFileManager.Location location) {\n-                return new ClassLoader() {\n-                    @Override\n-                    public Class<?> loadClass(String name) throws ClassNotFoundException {\n-                        try {\n-                            return super.loadClass(name);\n-                        } catch (ClassNotFoundException e) {\n-                            byte[] classData = classes.get(name);\n-                            return defineClass(name, classData, 0, classData.length);\n-                        }\n-                    }\n-                };\n-            }\n-            @Override\n-            public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String name, JavaFileObject.Kind kind, FileObject originatingSource) throws UnsupportedOperationException {\n-                return new SimpleJavaFileObject(URI.create(name + \".class\"), JavaFileObject.Kind.CLASS) {\n-                    @Override\n-                    public OutputStream openOutputStream() {\n-                        return new FilterOutputStream(new ByteArrayOutputStream()) {\n-                            @Override\n-                            public void close() throws IOException {\n-                                classes.put(name, ((ByteArrayOutputStream)out).toByteArray());\n-                            }\n-                        };\n-                    }\n-                };\n-            }\n-        };\n-        var source = genSource();\n-\/\/        System.out.println(source);\n-        if (ToolProvider.getSystemJavaCompiler().getTask(null, fileManager, null,\n-                List.of(\"--enable-preview\", \"-source\", String.valueOf(Runtime.version().feature())), null,\n-                List.of(SimpleJavaFileObject.forSource(URI.create(\"StringTemplateTest$.java\"), source))\n-           ).call()) {\n-            return fileManager.getClassLoader(CLASS_OUTPUT).loadClass(\"StringTemplateTest$\");\n-        } else {\n-            throw new AssertionError(\"compilation failed\");\n-        }\n-    }\n-\n-    String genFragments(Category c) {\n-        var fragments = new LinkedList<String>();\n-        for (int i = 0; i < 1500; i++) {\n-            var format = randomFormat(c);\n-            var value = randomValue(c);\n-            var qValue = value.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\");\n-            fragments.add(STR.\"test(FMT.\\\"\\{format}\\\\{\\{value}}\\\", \\\"\\{format}\\\", \\\"\\{qValue}\\\", \\{value}, log);\");\n-        }\n-        return String.join(\"\\n        \", fragments);\n-    }\n-\n-    String genSource() {\n-        return STR.\"\"\"\n-            import java.util.FormatProcessor;\n-            import java.util.Locale;\n-\n-            public class StringTemplateTest$ {\n-                static final FormatProcessor FMT = FormatProcessor.create(Locale.US);\n-                static String STR = \"this is static String\";\n-                static char C = 'c';\n-                static Character CHAR = 'C';\n-                static long L = -12345678910l;\n-                static Long LONG = 9876543210l;\n-                static int I = 42;\n-                static Integer INT = -49;\n-                static boolean BO = true;\n-                static Boolean BOOL = false;\n-                static short S = 13;\n-                static Short SHORT = -17;\n-                static byte BY = -3;\n-                static Byte BYTE = 12;\n-                static float F = 4.789f;\n-                static Float FLOAT = -0.000006f;\n-                static double D = 6545745.6734654563;\n-                static Double DOUBLE = -4323.7645676574;\n-\n-                public static void run(java.util.List<String> log) {\n-                    runGeneral(log);\n-                    runCharacter(log);\n-                    runIntegral(log);\n-                    runBigInt(log);\n-                    runFloating(log);\n-                    runBigFloat(log);\n-                    runDate(log);\n-                }\n-                public static void runGeneral(java.util.List<String> log) {\n-                    \\{genFragments(Category.GENERAL)}\n-                }\n-                public static void runCharacter(java.util.List<String> log) {\n-                    \\{genFragments(Category.CHARACTER)}\n-                }\n-                public static void runIntegral(java.util.List<String> log) {\n-                    \\{genFragments(Category.INTEGRAL)}\n-                }\n-                public static void runBigInt(java.util.List<String> log) {\n-                    \\{genFragments(Category.BIG_INT)}\n-                }\n-                public static void runFloating(java.util.List<String> log) {\n-                    \\{genFragments(Category.FLOATING)}\n-                }\n-                public static void runBigFloat(java.util.List<String> log) {\n-                    \\{genFragments(Category.BIG_FLOAT)}\n-                }\n-                public static void runDate(java.util.List<String> log) {\n-                    \\{genFragments(Category.DATE)}\n-                }\n-                static void test(String fmt, String format, String expression, Object value, java.util.List<String> log) {\n-                    var formatted = String.format(java.util.Locale.US, format, value);\n-                    if (!fmt.equals(formatted)) {\n-                        log.add(\"  format: '%s' expression: '%s' value: '%s' expected: '%s' found: '%s'\".formatted(format, expression, value, formatted, fmt));\n-                    }\n-                }\n-            }\n-            \"\"\";\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        var log = new LinkedList<String>();\n-        new StringTemplateTest().compile().getMethod(\"run\", List.class).invoke(null, log);\n-        if (!log.isEmpty()) {\n-            log.forEach(System.out::println);\n-            throw new AssertionError(STR.\"failed \\{log.size()} tests\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/template\/StringTemplateTest.java","additions":0,"deletions":304,"binary":false,"changes":304,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8313809\n- * @summary String template fails with java.lang.StringIndexOutOfBoundsException if last fragment is UTF16\n-.\n- * @enablePreview true\n- *\/\n-\n-import static java.util.FormatProcessor.FMT;\n-\n-public class T8313809 {\n-    public static void main(final String[] args) throws Exception {\n-        double sum = 12.34;\n-        final String message = FMT.\"The sum is : %f\\{sum} \"; \/\/ this fails\n-        if (!message.equals(\"The sum is : 12.340000 \")) {\n-            throw new RuntimeException(\"Incorrect result\");\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/java\/lang\/template\/T8313809.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8329190\n+ * @summary Test that I\/O operations on a closed network channel throw ClosedChannelException\n+ *    and not AsynchronousCloseException\n+ * @run junit ClosedNetworkChannels\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousCloseException;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.NotYetConnectedException;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ClosedNetworkChannels {\n+\n+    \/**\n+     * An operation that does not return a result but may throw an exception.\n+     *\/\n+    @FunctionalInterface\n+    interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    \/**\n+     * Assert that the given operation throws ClosedChannelException.\n+     *\/\n+    private void assertThrowsCCE(ThrowingRunnable op) throws Exception {\n+        try {\n+            op.run();\n+            fail();\n+        } catch (AsynchronousCloseException e) {\n+            fail(e + \" thrown\");\n+        } catch (ClosedChannelException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/**\n+     * Closes the given SocketChannel and checks that I\/O ops throw ClosedChannelException.\n+     *\/\n+    private void testSocketChannel(SocketChannel sc) throws Exception {\n+        sc.close();\n+\n+        InetAddress lb = InetAddress.getLoopbackAddress();\n+        SocketAddress target = new InetSocketAddress(lb, 7777);  \/\/ any port will do\n+\n+        ByteBuffer bb = ByteBuffer.allocate(100);\n+        ByteBuffer[] bufs = new ByteBuffer[] { bb };\n+\n+        assertThrowsCCE(() -> sc.connect(target));\n+        assertThrowsCCE(() -> sc.finishConnect());\n+        assertThrowsCCE(() -> sc.read(bb));\n+        assertThrowsCCE(() -> sc.read(bufs));\n+        assertThrowsCCE(() -> sc.read(bufs, 0, 1));\n+        assertThrowsCCE(() -> sc.write(bb));\n+        assertThrowsCCE(() -> sc.write(bufs));\n+        assertThrowsCCE(() -> sc.write(bufs, 0, 1));\n+    }\n+\n+    \/**\n+     * Test that I\/O operations on a closed (but previously unconnected) SocketChannel\n+     * throw ClosedChannelException.\n+     *\/\n+    @Test\n+    void testUnconnectedSocketChannel() throws Exception {\n+        SocketChannel sc = SocketChannel.open();\n+        testSocketChannel(sc);\n+    }\n+\n+    \/**\n+     * Test that I\/O operations on a closed (but previously connected) SocketChannel\n+     * throw ClosedChannelException.\n+     *\/\n+    @Test\n+    void testConnectedSocketChannel() throws Exception {\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            try (SocketChannel sc = SocketChannel.open(ssc.getLocalAddress());\n+                 SocketChannel peer = ssc.accept()) {\n+                testSocketChannel(sc);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that the accept operation on a closed (but previously unbound) ServerSocketChannel\n+     * throws ClosedChannelException.\n+     *\/\n+    @Test\n+    void testUnboundServerSocketChannel() throws Exception {\n+        ServerSocketChannel ssc = ServerSocketChannel.open();\n+        ssc.close();\n+        assertThrowsCCE(() -> ssc.accept());\n+    }\n+\n+    \/**\n+     * Test that the accept operation on a closed (but previously bound) ServerSocketChannel\n+     * throws ClosedChannelException.\n+     *\/\n+    @Test\n+    void testBoundServerSocketChannel() throws Exception {\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            ssc.close();\n+            assertThrowsCCE(() -> ssc.accept());\n+        }\n+    }\n+\n+    \/**\n+     * Test that I\/O operations on a closed Pipe.SourceChannel and Pipe.SinkChannel\n+     * throw ClosedChannelException.\n+     *\/\n+    @Test\n+    void testSourceAndSinkChannels() throws Exception {\n+        Pipe p = Pipe.open();\n+        try (Pipe.SourceChannel source = p.source();\n+             Pipe.SinkChannel sink = p.sink()) {\n+            source.close();\n+            sink.close();\n+\n+            ByteBuffer bb = ByteBuffer.allocate(100);\n+            ByteBuffer[] bufs = new ByteBuffer[]{bb};\n+\n+            assertThrowsCCE(() -> source.read(bb));\n+            assertThrowsCCE(() -> source.read(bufs));\n+            assertThrowsCCE(() -> source.read(bufs, 0, 1));\n+            assertThrowsCCE(() -> sink.write(bb));\n+            assertThrowsCCE(() -> sink.write(bufs));\n+            assertThrowsCCE(() -> sink.write(bufs, 0, 1));\n+        }\n+    }\n+\n+    \/**\n+     * Closes the given DatagramChannel and checks that I\/O ops throw ClosedChannelException.\n+     *\/\n+    private void testDatagramChannel(DatagramChannel dc) throws Exception {\n+        dc.close();\n+\n+        InetAddress lb = InetAddress.getLoopbackAddress();\n+        SocketAddress target = new InetSocketAddress(lb, 7777);  \/\/ any port will do\n+\n+        ByteBuffer bb = ByteBuffer.allocate(100);\n+        ByteBuffer[] bufs = new ByteBuffer[] { bb };\n+\n+        assertThrowsCCE(() -> dc.send(bb, target));\n+        assertThrowsCCE(() -> dc.receive(bb));\n+        assertThrowsCCE(() -> dc.read(bb));\n+        assertThrowsCCE(() -> dc.read(bufs));\n+        assertThrowsCCE(() -> dc.read(bufs, 0, 1));\n+        assertThrowsCCE(() -> dc.write(bb));\n+        assertThrowsCCE(() -> dc.write(bufs));\n+        assertThrowsCCE(() -> dc.write(bufs, 0, 1));\n+    }\n+\n+    \/**\n+     * Test that I\/O operations on a closed (but previously unconnected) DatagramChannel\n+     * throw ClosedChannelException.\n+     *\/\n+    @Test\n+    void testUnconnectedDatagramChannel() throws Exception {\n+        DatagramChannel dc = DatagramChannel.open();\n+        testDatagramChannel(dc);\n+    }\n+\n+    \/**\n+     * Test that I\/O operations on a closed (but previously connected) DatagramChannel\n+     * throw ClosedChannelException.\n+     *\/\n+    @Test\n+    void testConnectedDatagramChannel() throws Exception {\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            InetAddress lb = InetAddress.getLoopbackAddress();\n+            dc.bind(new InetSocketAddress(lb, 0));\n+            dc.connect(new InetSocketAddress(lb, 7777));  \/\/ any port will do\n+            testDatagramChannel(dc);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/ClosedNetworkChannels.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library ..\/..\/..\/..\/testlibrary ..\/..\/\n+ * @library ..\/..\/..\/..\/testlibrary ..\/..\/ \/test\/lib\n@@ -34,1 +34,1 @@\n- * @build TestLibrary bench.BenchInfo bench.HtmlReporter bench.Util\n+ * @build TestLibrary bench.BenchInfo bench.HtmlReporter bench.Util jdk.test.lib.process.ProcessTools\n@@ -54,7 +54,0 @@\n-import bench.ConfigFormatException;\n-import bench.Harness;\n-import bench.HtmlReporter;\n-import bench.Reporter;\n-import bench.TextReporter;\n-import bench.XmlReporter;\n-import static bench.rmi.Main.OutputFormat.*;\n@@ -65,1 +58,0 @@\n-import java.io.InputStream;\n@@ -67,0 +59,1 @@\n+import java.io.InputStream;\n@@ -80,0 +73,12 @@\n+import bench.ConfigFormatException;\n+import bench.Harness;\n+import bench.HtmlReporter;\n+import bench.Reporter;\n+import bench.TextReporter;\n+import bench.XmlReporter;\n+import static bench.rmi.Main.OutputFormat.HTML;\n+import static bench.rmi.Main.OutputFormat.TEXT;\n+import static bench.rmi.Main.OutputFormat.XML;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n@@ -237,7 +242,0 @@\n-                    clientProcessStr.add(System.getProperty(\"test.jdk\") +\n-                            File.separator + \"bin\" + File.separator + \"java\");\n-                    String classpath = System.getProperty(\"java.class.path\");\n-                    if (classpath != null) {\n-                        clientProcessStr.add(\"-cp\");\n-                        clientProcessStr.add(classpath);\n-                    }\n@@ -279,11 +277,4 @@\n-                        Process client = new ProcessBuilder(clientProcessStr).\n-                                inheritIO().start();\n-                        try {\n-                            client.waitFor();\n-                            int exitValue = client.exitValue();\n-                            if (0 != exitValue) {\n-                                die(\"Error: error happened in client process, exitValue = \" + exitValue);\n-                            }\n-                        } finally {\n-                            client.destroyForcibly();\n-                        }\n+                        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(clientProcessStr);\n+                        OutputAnalyzer outputAnalyzer = ProcessTools.executeProcess(pb);\n+                        System.out.println(outputAnalyzer.getOutput());\n+                        outputAnalyzer.shouldHaveExitValue(0);\n@@ -292,1 +283,1 @@\n-                    } catch (InterruptedException ex) {\n+                    } catch (Exception ex) {\n","filename":"test\/jdk\/java\/rmi\/reliability\/benchmark\/bench\/rmi\/Main.java","additions":21,"deletions":30,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8177552 8222756\n+ * @bug 8177552 8222756 8327640\n@@ -134,0 +134,12 @@\n+        \/\/ Changing the parseBigDecimal of second object; objects must be equal\n+        cnf2.setParseBigDecimal(true);\n+        checkEquals(cnf1, cnf2, true, \"9th\", \"\");\n+\n+        \/\/ Changing the strict parsing value of first object; objects must not be equal\n+        cnf1.setStrict(true);\n+        checkEquals(cnf1, cnf2, false, \"10th\", \"different strict parsing\");\n+\n+        \/\/ Changing the strict parsing value of second object; objects must be equal\n+        cnf2.setStrict(true);\n+        checkEquals(cnf1, cnf2, true, \"11th\", \"\");\n+\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestEquality.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8177552\n+ * @bug 8177552 8327640\n@@ -74,0 +74,1 @@\n+        FORMAT_FR_FR.setStrict(true);\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/serialization\/TestSerialization.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Check parseStrict correctness for DecimalFormat.equals()\n+ * @run junit EqualityTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.DecimalFormat;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+\n+public class EqualityTest {\n+\n+    private static final DecimalFormat fmt1 = new DecimalFormat();\n+    private static final DecimalFormat fmt2 = new DecimalFormat();\n+\n+    \/\/ Ensure that parseStrict is reflected correctly for DecimalFormat.equals()\n+    @Test\n+    public void checkStrictTest() {\n+        \/\/ parseStrict is false by default\n+        assertEquals(fmt1, fmt2);\n+        fmt1.setStrict(true);\n+        assertNotEquals(fmt1, fmt2);\n+        fmt2.setStrict(true);\n+        assertEquals(fmt1, fmt2);\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/EqualityTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Check parseStrict correctness for DecimalFormat serialization\n+ * @run junit\/othervm SerializationTest\n+ *\/\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class SerializationTest {\n+\n+    private static final NumberFormat FORMAT = NumberFormat.getInstance();\n+\n+    @BeforeAll\n+    public static void mutateFormat() {\n+        FORMAT.setStrict(true);\n+    }\n+\n+    @Test\n+    public void testSerialization() throws IOException, ClassNotFoundException {\n+        \/\/ Serialize\n+        serialize(\"fmt.ser\", FORMAT);\n+        \/\/ Deserialize\n+        deserialize(\"fmt.ser\", FORMAT);\n+    }\n+\n+    private void serialize(String fileName, NumberFormat... formats)\n+            throws IOException {\n+        try (ObjectOutputStream os = new ObjectOutputStream(\n+                new FileOutputStream(fileName))) {\n+            for (NumberFormat fmt : formats) {\n+                os.writeObject(fmt);\n+            }\n+        }\n+    }\n+\n+    private static void deserialize(String fileName, NumberFormat... formats)\n+            throws IOException, ClassNotFoundException {\n+        try (ObjectInputStream os = new ObjectInputStream(\n+                new FileInputStream(fileName))) {\n+            for (NumberFormat fmt : formats) {\n+                NumberFormat obj = (NumberFormat) os.readObject();\n+                assertEquals(fmt, obj, \"Serialized and deserialized\"\n+                        + \" objects do not match\");\n+\n+                String badNumber = \"fooofooo23foo\";\n+                assertThrows(ParseException.class, () -> fmt.parse(badNumber));\n+                assertThrows(ParseException.class, () -> obj.parse(badNumber));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/SerializationTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,417 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Test suite for NumberFormat parsing when lenient.\n+ * @run junit\/othervm -Duser.language=en -Duser.country=US LenientParseTest\n+ * @run junit\/othervm -Duser.language=ja -Duser.country=JP LenientParseTest\n+ * @run junit\/othervm -Duser.language=zh -Duser.country=CN LenientParseTest\n+ * @run junit\/othervm -Duser.language=tr -Duser.country=TR LenientParseTest\n+ * @run junit\/othervm -Duser.language=de -Duser.country=DE LenientParseTest\n+ * @run junit\/othervm -Duser.language=fr -Duser.country=FR LenientParseTest\n+ * @run junit\/othervm -Duser.language=ar -Duser.country=AR LenientParseTest\n+ *\/\n+\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/\/ Tests lenient parsing, this is done by testing the NumberFormat factory instances\n+\/\/ against a number of locales with different formatting conventions. The locales\n+\/\/ used all use a grouping size of 3. When lenient, parsing only fails\n+\/\/ if the prefix and\/or suffix are not found, or the first character after the\n+\/\/ prefix is un-parseable. The tested locales all use groupingSize of 3.\n+public class LenientParseTest {\n+\n+    \/\/ Used to retrieve the locale's expected symbols\n+    private static final DecimalFormatSymbols dfs =\n+            new DecimalFormatSymbols(Locale.getDefault());\n+    private static final DecimalFormat dFmt = (DecimalFormat)\n+            NumberFormat.getNumberInstance(Locale.getDefault());\n+    private static final DecimalFormat cFmt =\n+            (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.getDefault());\n+    private static final DecimalFormat pFmt =\n+            (DecimalFormat) NumberFormat.getPercentInstance(Locale.getDefault());\n+    private static final CompactNumberFormat cmpctFmt =\n+            (CompactNumberFormat) NumberFormat.getCompactNumberInstance(Locale.getDefault(),\n+                    NumberFormat.Style.SHORT);\n+\n+    \/\/ All NumberFormats should parse leniently (which is the default)\n+    static {\n+        \/\/ To effectively test compactNumberFormat, these should be set accordingly\n+        cmpctFmt.setParseIntegerOnly(false);\n+        cmpctFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ ---- NumberFormat tests ----\n+    \/\/ Test prefix\/suffix behavior with a predefined DecimalFormat\n+    \/\/ Non-localized, only run once\n+    @ParameterizedTest\n+    @MethodSource(\"badParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void numFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        \/\/ Format with grouping size = 3, prefix = a, suffix = b\n+        DecimalFormat nonLocalizedDFmt = new DecimalFormat(\"a#,#00.00b\");\n+        failParse(nonLocalizedDFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    \/\/ All input Strings should parse fully and return the expected value.\n+    \/\/ Expected index should be the length of the parse string, since it parses fully\n+    @ParameterizedTest\n+    @MethodSource(\"validFullParseStrings\")\n+    public void numFmtSuccessFullParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ All input Strings should parse partially and return expected value\n+    \/\/ with the expected final index\n+    @ParameterizedTest\n+    @MethodSource(\"validPartialParseStrings\")\n+    public void numFmtSuccessPartialParseTest(String toParse, double expectedValue,\n+                                              int expectedIndex) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+    }\n+\n+    \/\/ Parse partially due to no grouping\n+    @ParameterizedTest\n+    @MethodSource(\"noGroupingParseStrings\")\n+    public void numFmtStrictGroupingNotUsed(String toParse, double expectedValue, int expectedIndex) {\n+        dFmt.setGroupingUsed(false);\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+        dFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ Parse partially due to integer only\n+    @ParameterizedTest\n+    @MethodSource(\"integerOnlyParseStrings\")\n+    public void numFmtStrictIntegerOnlyUsed(String toParse, int expectedValue, int expectedIndex) {\n+        dFmt.setParseIntegerOnly(true);\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+        dFmt.setParseIntegerOnly(false);\n+    }\n+\n+    \/\/ ---- CurrencyFormat tests ----\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidFullParseStrings\")\n+    public void currFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ Strings may parse partially or fail. This is because the mapped\n+    \/\/ data may cause the error to occur before the suffix can be found, (if the locale\n+    \/\/ uses a suffix).\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidPartialParseStrings\")\n+    public void currFmtParseTest(String toParse, double expectedValue,\n+                                 int expectedIndex) {\n+        if (cFmt.getPositiveSuffix().length() > 0) {\n+            \/\/ Since the error will occur before suffix is found, exception is thrown.\n+            failParse(cFmt, toParse, expectedIndex);\n+        } else {\n+            \/\/ Empty suffix, thus even if the error occurs, we have already found the\n+            \/\/ prefix, and simply parse partially\n+            assertEquals(expectedValue, successParse(cFmt, toParse, expectedIndex));\n+        }\n+    }\n+\n+    \/\/ ---- PercentFormat tests ----\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidFullParseStrings\")\n+    public void percentFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(pFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ Strings may parse partially or fail. This is because the mapped\n+    \/\/ data may cause the error to occur before the suffix can be found, (if the locale\n+    \/\/ uses a suffix).\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidPartialParseStrings\")\n+    public void percentFmtParseTest(String toParse, double expectedValue,\n+                                 int expectedIndex) {\n+        if (pFmt.getPositiveSuffix().length() > 0) {\n+            \/\/ Since the error will occur before suffix is found, exception is thrown.\n+            failParse(pFmt, toParse, expectedIndex);\n+        } else {\n+            \/\/ Empty suffix, thus even if the error occurs, we have already found the\n+            \/\/ prefix, and simply parse partially\n+            assertEquals(expectedValue, successParse(pFmt, toParse, expectedIndex));\n+        }\n+    }\n+\n+    \/\/ ---- CompactNumberFormat tests ----\n+    \/\/ Can match to both the decimalFormat patterns and the compact patterns\n+    \/\/ Unlike the other tests, this test is only ran against the US Locale and\n+    \/\/ tests against data built with the thousands format (K).\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidPartialParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtFailParseTest(String toParse, double expectedValue, int expectedErrorIndex) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, expectedErrorIndex));\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidFullParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ ---- Helper test methods ----\n+\n+    \/\/ Method is used when a String should parse successfully. This does not indicate\n+    \/\/ that the entire String was used, however. The index and errorIndex values\n+    \/\/ should be as expected.\n+    private double successParse(NumberFormat fmt, String toParse, int expectedIndex) {\n+        Number parsedValue = assertDoesNotThrow(() -> fmt.parse(toParse));\n+        ParsePosition pp = new ParsePosition(0);\n+        assertDoesNotThrow(() -> fmt.parse(toParse, pp));\n+        assertEquals(-1, pp.getErrorIndex(),\n+                \"ParsePosition ErrorIndex is not in correct location\");\n+        assertEquals(expectedIndex, pp.getIndex(),\n+                \"ParsePosition Index is not in correct location\");\n+        return parsedValue.doubleValue();\n+    }\n+\n+    \/\/ Method is used when a String should fail parsing. Indicated by either a thrown\n+    \/\/ ParseException, or null is returned depending on which parse method is invoked.\n+    \/\/ errorIndex should be as expected.\n+    private void failParse(NumberFormat fmt, String toParse, int expectedErrorIndex) {\n+        ParsePosition pp = new ParsePosition(0);\n+        assertThrows(ParseException.class, () -> fmt.parse(toParse));\n+        assertNull(fmt.parse(toParse, pp));\n+        assertEquals(expectedErrorIndex, pp.getErrorIndex());\n+    }\n+\n+    \/\/ ---- Data Providers ----\n+\n+    \/\/ Strings that should fail when parsed leniently.\n+    \/\/ Given as Arguments<String, expectedErrorIndex>\n+    \/\/ Non-localized data. For reference, the pattern of nonLocalizedDFmt is\n+    \/\/ \"a#,#00.00b\"\n+    private static Stream<Arguments> badParseStrings() {\n+        return Stream.of(\n+                \/\/ No prefix\n+                Arguments.of(\"1,1b\", 0),\n+                \/\/ No suffix\n+                Arguments.of(\"a1,11\", 5),\n+                \/\/ Digit does not follow the last grouping separator\n+                \/\/ Current behavior fails on the grouping separator\n+                Arguments.of(\"a1,11,z\", 5),\n+                \/\/ No suffix after grouping\n+                Arguments.of(\"a1,11,\", 5),\n+                \/\/ No prefix and suffix\n+                Arguments.of(\"1,11\", 0),\n+                \/\/ First character after prefix is un-parseable\n+                \/\/ Behavior is to expect error index at 0, not 1\n+                Arguments.of(\"ac1,11\", 0));\n+    }\n+\n+    \/\/ These data providers use US locale grouping and decimal separators\n+    \/\/ for readability, however, the data is tested against multiple locales\n+    \/\/ and is converted appropriately at runtime.\n+\n+    \/\/ Strings that should parse successfully, and consume the entire String\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber)\n+    private static Stream<Arguments> validFullParseStrings() {\n+        return Stream.of(\n+                \/\/ Many subsequent grouping symbols\n+                Arguments.of(\"1,,,1\", 11d),\n+                Arguments.of(\"11,,,11,,,11\", 111111d),\n+                \/\/ Bad grouping size (with decimal)\n+                Arguments.of(\"1,1.\", 11d),\n+                Arguments.of(\"11,111,11.\", 1111111d),\n+                \/\/ Improper grouping size (with decimal and digits after)\n+                Arguments.of(\"1,1.1\", 11.1d),\n+                Arguments.of(\"1,11.1\", 111.1d),\n+                Arguments.of(\"1,1111.1\", 11111.1d),\n+                Arguments.of(\"11,111,11.1\", 1111111.1d),\n+                \/\/ Starts with grouping symbol\n+                Arguments.of(\",111,,1,1\", 11111d),\n+                Arguments.of(\",1\", 1d),\n+                Arguments.of(\",,1\", 1d),\n+                \/\/ Leading Zeros (not digits)\n+                Arguments.of(\"000,1,1\", 11d),\n+                Arguments.of(\"000,111,11,,1\", 111111d),\n+                Arguments.of(\"0,000,1,,1,1\", 111d),\n+                Arguments.of(\"1,234.00\", 1234d),\n+                Arguments.of(\"1,234.0\", 1234d),\n+                Arguments.of(\"1,234.\", 1234d),\n+                Arguments.of(\"1,234.00123\", 1234.00123d),\n+                Arguments.of(\"1,234.012\", 1234.012d),\n+                Arguments.of(\"1,234.224\", 1234.224d),\n+                Arguments.of(\"1\", 1d),\n+                Arguments.of(\"10\", 10d),\n+                Arguments.of(\"100\", 100d),\n+                Arguments.of(\"1000\", 1000d),\n+                Arguments.of(\"1,000\", 1000d),\n+                Arguments.of(\"10,000\", 10000d),\n+                Arguments.of(\"10000\", 10000d),\n+                Arguments.of(\"100,000\", 100000d),\n+                Arguments.of(\"1,000,000\", 1000000d),\n+                Arguments.of(\"10,000,000\", 10000000d))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n+    }\n+\n+    \/\/ Strings that should parse successfully, but do not use the entire String\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> validPartialParseStrings() {\n+        return Stream.of(\n+                \/\/ End with grouping symbol\n+                Arguments.of(\"11,\", 11d, 2),\n+                Arguments.of(\"11,,\", 11d, 3),\n+                Arguments.of(\"11,,,\", 11d, 4),\n+                \/\/ Random chars that aren't the expected symbols\n+                Arguments.of(\"1,1P111\", 11d, 3),\n+                Arguments.of(\"1.1P111\", 1.1d, 3),\n+                Arguments.of(\"1P,1111\", 1d, 1),\n+                Arguments.of(\"1P.1111\", 1d, 1),\n+                Arguments.of(\"1,1111P\", 11111d, 6),\n+                \/\/ Grouping occurs after decimal separator)\n+                Arguments.of(\"1.11,11\", 1.11d, 4),\n+                Arguments.of(\"1.,11,11\", 1d, 2))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Test data input for when parse integer only is true\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> integerOnlyParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"1234.1234\", 1234, 4),\n+                Arguments.of(\"1234.12\", 1234, 4),\n+                Arguments.of(\"1234.1a\", 1234, 4),\n+                Arguments.of(\"1234.\", 1234, 4))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Test data input for when no grouping is true\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> noGroupingParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"12,34\", 12d, 2),\n+                Arguments.of(\"1234,\", 1234d, 4),\n+                Arguments.of(\"123,456.789\", 123d, 3))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Mappers for respective data providers to adjust values accordingly\n+    \/\/ Localized percent prefix\/suffix is added, with appropriate expected values\n+    \/\/ adjusted. Expected parsed number should be divided by 100.\n+    private static Stream<Arguments> percentValidPartialParseStrings() {\n+        return validPartialParseStrings().map(args ->\n+                Arguments.of(pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                        (double) args.get()[1] \/ 100, (int) args.get()[2] + pFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> percentValidFullParseStrings() {\n+        return validFullParseStrings().map(args -> Arguments.of(\n+                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                (double) args.get()[1] \/ 100)\n+        );\n+    }\n+\n+    \/\/ Mappers for respective data providers to adjust values accordingly\n+    \/\/ Localized percent prefix\/suffix is added, with appropriate expected values\n+    \/\/ adjusted. Separators replaced for monetary versions.\n+    private static Stream<Arguments> currencyValidPartialParseStrings() {\n+        return validPartialParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1], (int) args.get()[2] + cFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> currencyValidFullParseStrings() {\n+        return validFullParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1])\n+        );\n+    }\n+\n+    \/\/ Compact Pattern Data Provider provides test input for both DecimalFormat patterns\n+    \/\/ and the compact patterns. As there is no method to retrieve compact patterns,\n+    \/\/ thus test only against US English locale, and use a hard coded K - 1000\n+    private static Stream<Arguments> compactValidPartialParseStrings() {\n+        return Stream.concat(validPartialParseStrings().map(args -> Arguments.of(args.get()[0],\n+                args.get()[1], args.get()[2])), validPartialParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\",\n+                args.get()[1], args.get()[2]))\n+        );\n+    }\n+\n+    private static Stream<Arguments> compactValidFullParseStrings() {\n+        return Stream.concat(validFullParseStrings().map(args -> Arguments.of(args.get()[0],\n+                args.get()[1])), validFullParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\",\n+                (double)args.get()[1] * 1000.0))\n+        );\n+    }\n+\n+    \/\/ Replace the grouping and decimal separators with localized variants\n+    \/\/ Used during localization of data\n+    private static String localizeText(String text) {\n+        \/\/ As this is a single pass conversion, this is safe for multiple replacement,\n+        \/\/ even if a ',' could be a decimal separator for a locale.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < text.length(); i++) {\n+            char c = text.charAt(i);\n+            if (c == ',') {\n+                sb.append(dfs.getGroupingSeparator());\n+            } else if (c == '.') {\n+                sb.append(dfs.getDecimalSeparator());\n+            } else if (c == '0') {\n+                sb.append(dfs.getZeroDigit());\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientParseTest.java","additions":417,"deletions":0,"binary":false,"changes":417,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Unit test for the isStrict() and setStrict() parsing related methods\n+ * @run junit StrictMethodsTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class StrictMethodsTest {\n+\n+    \/\/ Check that DecimalFormat implements isStrict()\/setStrict()\n+    \/\/ Ensure that the default value is false, and can be set to true via API\n+    @Test\n+    public void decimalFormatTest() {\n+        DecimalFormat dFmt = (DecimalFormat) NumberFormat.getInstance();\n+        assertFalse(dFmt.isStrict());\n+        dFmt.setStrict(true);\n+        assertTrue(dFmt.isStrict());\n+    }\n+\n+    \/\/ Check that CompactNumberFormat implements isStrict()\/setStrict()\n+    \/\/ Ensure that the default value is false, and can be set to true via API\n+    @Test\n+    public void compactFormatTest() {\n+        CompactNumberFormat cFmt = (CompactNumberFormat) NumberFormat.getCompactNumberInstance();\n+        assertFalse(cFmt.isStrict());\n+        cFmt.setStrict(true);\n+        assertTrue(cFmt.isStrict());\n+    }\n+\n+    \/\/ Check that NumberFormat throws exception for isStrict()\/setStrict()\n+    \/\/ when subclass does not implement said methods\n+    @Test\n+    public void numberFormatTest() {\n+        FooFormat fmt = new FooFormat();\n+        assertThrows(UnsupportedOperationException.class, fmt::isStrict);\n+        assertThrows(UnsupportedOperationException.class, () -> fmt.setStrict(false));\n+    }\n+\n+    \/\/ Dummy NumberFormat class to check that isStrict() and setStrict()\n+    \/\/ are not implemented by default\n+    private static class FooFormat extends NumberFormat {\n+\n+        \/\/ Provide overrides for abstract methods\n+        @Override\n+        public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Number parse(String source, ParsePosition parsePosition) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictMethodsTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,525 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Test suite for NumberFormat parsing with strict leniency\n+ * @run junit\/othervm -Duser.language=en -Duser.country=US StrictParseTest\n+ * @run junit\/othervm -Duser.language=ja -Duser.country=JP StrictParseTest\n+ * @run junit\/othervm -Duser.language=zh -Duser.country=CN StrictParseTest\n+ * @run junit\/othervm -Duser.language=tr -Duser.country=TR StrictParseTest\n+ * @run junit\/othervm -Duser.language=de -Duser.country=DE StrictParseTest\n+ * @run junit\/othervm -Duser.language=fr -Duser.country=FR StrictParseTest\n+ * @run junit\/othervm -Duser.language=ar -Duser.country=AR StrictParseTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/\/ Tests strict parsing, this is done by testing the NumberFormat factory instances\n+\/\/ against a number of locales with different formatting conventions. The locales\n+\/\/ used all use a grouping size of 3.\n+public class StrictParseTest {\n+\n+    \/\/ Used to retrieve the locale's expected symbols\n+    private static final DecimalFormatSymbols dfs =\n+            new DecimalFormatSymbols(Locale.getDefault());\n+    \/\/ We re-use these formats for the respective factory tests\n+    private static final DecimalFormat dFmt =\n+            (DecimalFormat) NumberFormat.getNumberInstance(Locale.getDefault());\n+    private static final DecimalFormat cFmt =\n+            (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.getDefault());\n+    private static final DecimalFormat pFmt =\n+            (DecimalFormat) NumberFormat.getPercentInstance(Locale.getDefault());\n+    private static final CompactNumberFormat cmpctFmt =\n+            (CompactNumberFormat) NumberFormat.getCompactNumberInstance(Locale.getDefault(),\n+                    NumberFormat.Style.SHORT);\n+\n+\n+    \/\/ All NumberFormats should parse strictly\n+    static {\n+        dFmt.setStrict(true);\n+        pFmt.setStrict(true);\n+        cFmt.setStrict(true);\n+        cmpctFmt.setStrict(true);\n+        \/\/ To effectively test strict compactNumberFormat parsing\n+        cmpctFmt.setParseIntegerOnly(false);\n+        cmpctFmt.setGroupingUsed(true);\n+        cmpctFmt.setGroupingSize(3);\n+    }\n+\n+    \/\/ ---- NumberFormat tests ----\n+\n+    \/\/ Guarantee some edge case test input\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void uniqueCaseNumberFormatTest() {\n+        \/\/ Format with grouping size = 3, prefix = a, suffix = b\n+        DecimalFormat nonLocalizedDFmt = new DecimalFormat(\"a#,#00.00b\");\n+        nonLocalizedDFmt.setStrict(true);\n+        \/\/ Text after suffix\n+        failParse(nonLocalizedDFmt, \"a12bfoo\", 3);\n+        failParse(nonLocalizedDFmt, \"a123,456.00bc\", 11);\n+        \/\/ Text after prefix\n+        failParse(nonLocalizedDFmt, \"ac123\", 0);\n+        \/\/ Missing suffix\n+        failParse(nonLocalizedDFmt, \"a123\", 4);\n+        \/\/ Prefix contains a decimal separator\n+        failParse(nonLocalizedDFmt, \".a123\", 0);\n+        \/\/ Test non grouping size of 3\n+        nonLocalizedDFmt.setGroupingSize(1);\n+        successParse(nonLocalizedDFmt, \"a1,2,3,4b\");\n+        failParse(nonLocalizedDFmt, \"a1,2,3,45,6b\", 8);\n+        nonLocalizedDFmt.setGroupingSize(5);\n+        successParse(nonLocalizedDFmt, \"a12345,67890b\");\n+        successParse(nonLocalizedDFmt, \"a1234,67890b\");\n+        failParse(nonLocalizedDFmt, \"a123456,7890b\", 6);\n+\n+    }\n+\n+    \/\/ All input Strings should fail\n+    @ParameterizedTest\n+    @MethodSource(\"badParseStrings\")\n+    public void numFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(dFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"validParseStrings\")\n+    public void numFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse));\n+    }\n+\n+    \/\/ All input Strings should fail\n+    @ParameterizedTest\n+    @MethodSource(\"negativeBadParseStrings\")\n+    public void negNumFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(dFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"negativeValidParseStrings\")\n+    public void negNumFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse));\n+    }\n+\n+    \/\/ Exception should be thrown if grouping separator occurs anywhere\n+    \/\/ Don't pass badParseStrings as a data source, since they may fail for other reasons\n+    @ParameterizedTest\n+    @MethodSource({\"validParseStrings\", \"noGroupingParseStrings\"})\n+    public void numFmtStrictGroupingNotUsed(String toParse) {\n+        \/\/ When grouping is not used, if a grouping separator is found,\n+        \/\/ a failure should occur\n+        dFmt.setGroupingUsed(false);\n+        int failIndex = toParse.indexOf(\n+                dFmt.getDecimalFormatSymbols().getGroupingSeparator());\n+        if (failIndex > -1) {\n+            failParse(dFmt, toParse, failIndex);\n+        } else {\n+            successParse(dFmt, toParse);\n+        }\n+        dFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ Exception should be thrown if decimal separator occurs anywhere\n+    \/\/ Don't pass badParseStrings for same reason as previous method.\n+    @ParameterizedTest\n+    @MethodSource({\"validParseStrings\", \"integerOnlyParseStrings\"})\n+    public void numFmtStrictIntegerOnlyUsed(String toParse) {\n+        \/\/ When integer only is true, if a decimal separator is found,\n+        \/\/ a failure should occur\n+        dFmt.setParseIntegerOnly(true);\n+        int failIndex = toParse.indexOf(dfs.getDecimalSeparator());\n+        if (failIndex > -1) {\n+            failParse(dFmt, toParse, failIndex);\n+        } else {\n+            successParse(dFmt, toParse);\n+        }\n+        dFmt.setParseIntegerOnly(false);\n+    }\n+\n+    \/\/ ---- CurrencyFormat tests ----\n+    @ParameterizedTest\n+    @MethodSource(\"currencyBadParseStrings\")\n+    public void currFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(cFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidParseStrings\")\n+    public void currFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cFmt, toParse));\n+    }\n+\n+    \/\/ ---- PercentFormat tests ----\n+    @ParameterizedTest\n+    @MethodSource(\"percentBadParseStrings\")\n+    public void percentFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(pFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidParseStrings\")\n+    public void percentFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(pFmt, toParse));\n+    }\n+\n+    \/\/ ---- CompactNumberFormat tests ----\n+    \/\/ Can match to both the decimalFormat patterns and the compact patterns\n+    \/\/ Thus we test leniency for both. Unlike the other tests, this test\n+    \/\/ is only ran against the US Locale and tests against data built with the\n+    \/\/ thousands format (K).\n+    @ParameterizedTest\n+    @MethodSource(\"compactBadParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(cmpctFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse));\n+    }\n+\n+    \/\/ Checks some odd leniency edge cases between matching of default pattern\n+    \/\/ and compact pattern.\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtEdgeParseTest() {\n+        \/\/ Uses a compact format with unique and non-empty prefix\/suffix for both\n+        \/\/ default and compact patterns\n+        CompactNumberFormat cnf = new CompactNumberFormat(\"a##0.0#b\", DecimalFormatSymbols\n+                .getInstance(Locale.US), new String[]{\"\", \"c0d\"});\n+        cnf.setStrict(true);\n+\n+        \/\/ Existing behavior of failed prefix parsing has errorIndex return\n+        \/\/ the beginning of prefix, even if the error occurred later in the prefix.\n+        \/\/ Prefix empty\n+        failParse(cnf, \"12345d\", 0);\n+        failParse(cnf, \"1b\", 0);\n+        \/\/ Prefix bad\n+        failParse(cnf, \"aa1d\", 0);\n+        failParse(cnf, \"cc1d\", 0);\n+        failParse(cnf, \"aa1b\", 0);\n+        failParse(cnf, \"cc1b\", 0);\n+\n+        \/\/ Suffix error index is always the start of the failed suffix\n+        \/\/ not necessarily where the error occurred in the suffix. This is\n+        \/\/ consistent with the prefix error index behavior.\n+        \/\/ Suffix empty\n+        failParse(cnf, \"a1\", 2);\n+        failParse(cnf, \"c1\", 2);\n+        \/\/ Suffix bad\n+        failParse(cnf, \"a1dd\", 2);\n+        failParse(cnf, \"c1dd\", 2);\n+        failParse(cnf, \"a1bb\", 2);\n+        failParse(cnf, \"c1bb\", 2);\n+    }\n+\n+    \/\/ Ensure that on failure, the original index of the PP remains the same\n+    @Test\n+    public void parsePositionIndexTest() {\n+        failParse(dFmt, localizeText(\"123,456,,789.00\"), 8, 4);\n+    }\n+\n+    \/\/ ---- Helper test methods ----\n+\n+    \/\/ Should parse entire String successfully, and return correctly parsed value.\n+    private double successParse(NumberFormat fmt, String toParse) {\n+        \/\/ For Strings that don't have grouping separators, we test them with\n+        \/\/ grouping off so that they do not fail under the expectation that\n+        \/\/ grouping symbols should occur\n+        if (!toParse.contains(String.valueOf(dfs.getGroupingSeparator())) &&\n+                !toParse.contains(String.valueOf(dfs.getMonetaryGroupingSeparator()))) {\n+            fmt.setGroupingUsed(false);\n+        }\n+        Number parsedValue = assertDoesNotThrow(() -> fmt.parse(toParse));\n+        ParsePosition pp = new ParsePosition(0);\n+        assertDoesNotThrow(() -> fmt.parse(toParse, pp));\n+        assertEquals(-1, pp.getErrorIndex(),\n+                \"ParsePosition ErrorIndex is not in correct location\");\n+        assertEquals(toParse.length(), pp.getIndex(),\n+                \"ParsePosition Index is not in correct location\");\n+        fmt.setGroupingUsed(true);\n+        return parsedValue.doubleValue();\n+    }\n+\n+    \/\/ Method which tests a parsing failure. Either a ParseException is thrown,\n+    \/\/ or null is returned depending on which parse method is invoked. When failing,\n+    \/\/ index should remain the initial index set to the ParsePosition while\n+    \/\/ errorIndex is the index of failure.\n+    private void failParse(NumberFormat fmt, String toParse, int expectedErrorIndex) {\n+        failParse(fmt, toParse, expectedErrorIndex, 0);\n+    }\n+\n+    \/\/ Variant to check non 0 initial parse index\n+    private void failParse(NumberFormat fmt, String toParse,\n+                           int expectedErrorIndex, int initialParseIndex) {\n+        ParsePosition pp = new ParsePosition(initialParseIndex);\n+        assertThrows(ParseException.class, () -> fmt.parse(toParse));\n+        assertNull(fmt.parse(toParse, pp));\n+        assertEquals(expectedErrorIndex, pp.getErrorIndex());\n+        assertEquals(initialParseIndex, pp.getIndex());\n+    }\n+\n+    \/\/ ---- Data Providers ----\n+    \/\/ These data providers use US locale grouping and decimal separators\n+    \/\/ for readability, however, the data is tested against multiple locales\n+    \/\/ and is converted appropriately at runtime.\n+\n+    \/\/ Strings that should fail when parsed with strict leniency.\n+    \/\/ Given as Arguments<String, expectedErrorIndex>\n+    private static Stream<Arguments> badParseStrings() {\n+        return Stream.of(\n+                \/\/ Grouping symbol focus\n+                \/\/ Grouping symbol right before decimal\n+                Arguments.of(\"1,.\", 2),\n+                Arguments.of(\"1,.1\", 2),\n+                \/\/ Does not end with proper grouping size\n+                Arguments.of(\"1,1\", 2),\n+                Arguments.of(\"1,11\", 3),\n+                Arguments.of(\"1,1111\", 5),\n+                Arguments.of(\"11,111,11\", 8),\n+                \/\/ Does not end with proper grouping size (with decimal)\n+                Arguments.of(\"1,1.\", 3),\n+                Arguments.of(\"1,11.\", 4),\n+                Arguments.of(\"1,1111.\", 5),\n+                Arguments.of(\"11,111,11.\", 9),\n+                \/\/ Ends on a grouping symbol\n+                \/\/ Suffix matches correctly, so failure is on the \",\"\n+                Arguments.of(\"11,111,\", 6),\n+                Arguments.of(\"11,\", 2),\n+                Arguments.of(\"11,,\", 3),\n+                \/\/ Ends with grouping symbol. Failure should occur on grouping,\n+                \/\/ even if non recognized char after\n+                Arguments.of(\"11,a\", 2),\n+                \/\/ Improper grouping size (with decimal and digits after)\n+                Arguments.of(\"1,1.1\", 3),\n+                Arguments.of(\"1,11.1\", 4),\n+                Arguments.of(\"1,1111.1\", 5),\n+                Arguments.of(\"11,111,11.1\", 9),\n+                \/\/ Subsequent grouping symbols\n+                Arguments.of(\"1,,1\", 2),\n+                Arguments.of(\"1,1,,1\", 3),\n+                Arguments.of(\"1,,1,1\", 2),\n+                \/\/ Invalid grouping sizes\n+                Arguments.of(\"1,11,111\", 4),\n+                Arguments.of(\"11,11,111\", 5),\n+                Arguments.of(\"111,11,11\", 6),\n+                \/\/ First group is too large\n+                Arguments.of(\"1111,11,111\", 3),\n+                Arguments.of(\"00000,11,111\", 3),\n+                Arguments.of(\"111,1111111111\", 7),\n+                Arguments.of(\"111,11\", 5),\n+                Arguments.of(\"111,1111111111.\", 7),\n+                Arguments.of(\"111,11.\", 6),\n+                Arguments.of(\"111,1111111111.\", 7),\n+                \/\/ Starts with grouping symbol\n+                Arguments.of(\",111,,1,1\", 0),\n+                Arguments.of(\",1\", 0),\n+                Arguments.of(\",,1\", 0),\n+                \/\/ Leading Zeros (not digits)\n+                Arguments.of(\"000,1,1\", 5),\n+                Arguments.of(\"000,111,11,,1\", 10),\n+                Arguments.of(\"0,000,1,,1,1\", 7),\n+                \/\/ Bad suffix\n+                Arguments.of(\"1a\", 1),\n+                \/\/ Bad chars in numerical portion\n+                Arguments.of(\"123a4\", 3),\n+                Arguments.of(\"123.4a5\", 5),\n+                \/\/ Variety of edge cases\n+                Arguments.of(\"123,456.77a\", 10),\n+                Arguments.of(\"1,234a\", 5),\n+                Arguments.of(\"1,.a\", 2),\n+                Arguments.of(\"1.a\", 2),\n+                Arguments.of(\".22a\", 3),\n+                Arguments.of(\".1a1\", 2),\n+                Arguments.of(\"1,234,a\", 5))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n+    }\n+\n+    \/\/ Strings that should parse fully. (Both in lenient and strict)\n+    \/\/ Given as Arguments<String, expectedParsedNumber>\n+    private static Stream<Arguments> validParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"1,234.00\", 1234d),\n+                Arguments.of(\"1,234.0\", 1234d),\n+                Arguments.of(\"1,234.\", 1234d),\n+                Arguments.of(\"1\", 1d),\n+                Arguments.of(\"10\", 10d),\n+                Arguments.of(\"100\", 100d),\n+                Arguments.of(\"1000\", 1000d),\n+                Arguments.of(\"1,000\", 1000d),\n+                Arguments.of(\"10,000\", 10000d),\n+                Arguments.of(\"10000\", 10000d),\n+                Arguments.of(\"100,000\", 100000d),\n+                Arguments.of(\"1,000,000\", 1000000d),\n+                Arguments.of(\"10,000,000\", 10000000d))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n+    }\n+\n+    \/\/ Separate test data set for integer only. Can not use \"badParseStrings\", as\n+    \/\/ there is test data where the failure may occur from some other issue,\n+    \/\/ not related to grouping\n+    private static Stream<Arguments> integerOnlyParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"234.a\"),\n+                Arguments.of(\"234.a1\"),\n+                Arguments.of(\"234.1\"),\n+                Arguments.of(\"234.1a\"),\n+                Arguments.of(\"234.\"))\n+                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0]))));\n+    }\n+\n+    \/\/ Separate test data set for no grouping. Can not use \"badParseStrings\", as\n+    \/\/ there is test data where the failure may occur from some other issue,\n+    \/\/ not related to grouping\n+    private static Stream<Arguments> noGroupingParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"12,34.a\"),\n+                Arguments.of(\"123,.a1\"),\n+                Arguments.of(\",1234\"),\n+                Arguments.of(\"123,\"))\n+                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0]))));\n+    }\n+\n+    \/\/ Negative variant of a numerical format\n+    private static Stream<Arguments> negativeBadParseStrings() {\n+        return badParseStrings().map(args -> Arguments.of(\n+                dFmt.getNegativePrefix() + args.get()[0] + dFmt.getNegativeSuffix(),\n+                (int)args.get()[1] + dFmt.getNegativePrefix().length())\n+        );\n+    }\n+\n+    \/\/ Negative variant of a numerical format\n+    private static Stream<Arguments> negativeValidParseStrings() {\n+        return validParseStrings().map(args -> Arguments.of(\n+                dFmt.getNegativePrefix() + args.get()[0] + dFmt.getNegativeSuffix(),\n+                (double) args.get()[1] * -1)\n+        );\n+    }\n+\n+    \/\/ Same as original with a percent prefix\/suffix.\n+    \/\/ Additionally, increment expected error index if a prefix is added\n+    private static Stream<Arguments> percentBadParseStrings() {\n+        return badParseStrings().map(args -> Arguments.of(\n+                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                        (int)args.get()[1] + pFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    \/\/ Expected parsed value should be \/ 100 as it is a percent format.\n+    private static Stream<Arguments> percentValidParseStrings() {\n+        return validParseStrings().map(args -> Arguments.of(\n+                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                (double)args.get()[1] \/ 100.0)\n+        );\n+    }\n+\n+    \/\/ Same as original with a currency prefix\/suffix, but replace separators\n+    \/\/ with monetary variants. Additionally, increment expected error index\n+    \/\/ if a prefix is added\n+    private static Stream<Arguments> currencyBadParseStrings() {\n+        return badParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                (int)args.get()[1] + cFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> currencyValidParseStrings() {\n+        return validParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1])\n+        );\n+    }\n+\n+    \/\/ Compact Pattern Data Provider provides test input for both DecimalFormat patterns\n+    \/\/ and the compact patterns. As there is no method to retrieve compact patterns,\n+    \/\/ thus test only against US English locale, and use a hard coded K - 1000\n+    private static Stream<Arguments> compactBadParseStrings() {\n+        return Stream.concat(\n+                badParseStrings().map(args -> Arguments.of(args.get()[0], args.get()[1])),\n+                badParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\", args.get()[1]))\n+        );\n+    }\n+\n+    private static Stream<Arguments> compactValidParseStrings() {\n+        return Stream.concat(\n+                validParseStrings().map(args -> Arguments.of(\n+                        args.get()[0], args.get()[1])),\n+                validParseStrings().map(args -> Arguments.of(\n+                        args.get()[0] + \"K\", (double) args.get()[1] * 1000))\n+        );\n+    }\n+\n+    \/\/ Replace the grouping and decimal separators with localized variants\n+    \/\/ Used during localization of data\n+    private static String localizeText(String text) {\n+        \/\/ As this is a single pass conversion, this is safe for multiple replacement,\n+        \/\/ even if a ',' could be a decimal separator for a locale.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < text.length(); i++) {\n+            char c = text.charAt(i);\n+            if (c == ',') {\n+                sb.append(dfs.getGroupingSeparator());\n+            } else if (c == '.') {\n+                sb.append(dfs.getDecimalSeparator());\n+            } else if (c == '0') {\n+                sb.append(dfs.getZeroDigit());\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictParseTest.java","additions":525,"deletions":0,"binary":false,"changes":525,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -35,1 +37,1 @@\n- * @library \/tools\/lib\n+ * @library \/tools\/lib \/test\/lib\n@@ -40,1 +42,1 @@\n- * @build HijrahConfigCheck tests.*\n+ * @build HijrahConfigCheck tests.* jdk.test.lib.compiler.CompilerUtils jdk.test.lib.process.ProcessTools\n@@ -69,8 +71,2 @@\n-        ProcessBuilder builder = new ProcessBuilder(\n-                launcher.toAbsolutePath().toString(), \"-ea\", \"-esa\", \"HijrahConfigCheck\");\n-        Process p = builder.inheritIO().start();\n-        p.waitFor();\n-        int exitValue = p.exitValue();\n-        if (exitValue != 0) {\n-            throw new RuntimeException(\"HijrahConfigTest failed. Exit value: \" + exitValue);\n-        }\n+        OutputAnalyzer analyzer =  ProcessTools.executeCommand(launcher.toAbsolutePath().toString(), \"-ea\", \"-esa\", \"HijrahConfigCheck\");\n+        analyzer.shouldHaveExitValue(0);\n","filename":"test\/jdk\/java\/time\/nontestng\/java\/time\/chrono\/HijrahConfigTest.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,1 @@\n+import java.time.Instant;\n@@ -266,0 +267,10 @@\n+\n+    \/\/ verify the minimum and maximum values of ChronoField.INSTANT_SECONDS\n+    \/\/ matches the minimum and maximum supported epoch second by Instant.\n+    @Test\n+    public void testMinMaxInstantSeconds() {\n+        assertEquals(ChronoField.INSTANT_SECONDS.range().getMinimum(),\n+                Instant.MIN.getLong(ChronoField.INSTANT_SECONDS));\n+        assertEquals(ChronoField.INSTANT_SECONDS.range().getMaximum(),\n+                Instant.MAX.getLong(ChronoField.INSTANT_SECONDS));\n+    }\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/temporal\/TCKChronoField.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8044047 8076458 8075939\n+ * @bug 8044047 8076458 8075939 8196106\n@@ -276,0 +276,27 @@\n+\n+    @Test\n+    public void testTerminationOfNestedInfiniteStreams() {\n+        var refExpected = Stream.generate(() -> \"\").limit(5).toList();\n+        var refResult = Stream.generate(() -> \"\")\n+              .flatMap(c -> Stream.generate(() -> c).flatMap(x -> Stream.generate(() -> x)))\n+              .limit(5).toList();\n+        assertEquals(refResult, refExpected);\n+\n+        var intExpected = IntStream.generate(() -> 1).limit(5).sum();\n+        var intResult = IntStream.generate(() -> 1)\n+                .flatMap(c -> IntStream.generate(() -> c).flatMap(x -> IntStream.generate(() -> x)))\n+                .limit(5).sum();\n+        assertEquals(intResult, intExpected);\n+\n+        var longExpected = LongStream.generate(() -> 1L).limit(5).sum();\n+        var longResult = LongStream.generate(() -> 1L)\n+                .flatMap(c -> LongStream.generate(() -> c).flatMap(x -> LongStream.generate(() -> x)))\n+                .limit(5).sum();\n+        assertEquals(longResult, longExpected);\n+\n+        var doubleExpected = DoubleStream.generate(() -> 0d).limit(5).sum();\n+        var doubleResult = DoubleStream.generate(() -> 0d)\n+                .flatMap(c -> DoubleStream.generate(() -> c).flatMap(x -> DoubleStream.generate(() -> x)))\n+                .limit(5).sum();\n+        assertEquals(doubleResult, doubleExpected);\n+    }\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FlatMapOpTest.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+\n@@ -42,6 +43,0 @@\n-        try {\n-            Class.forName(ManagementFactory.class.getName());\n-        } catch (Throwable t) {\n-            System.out.println(\"TEST CANNOT RUN: needs JDK 5 at least\");\n-            return;\n-        }\n@@ -69,2 +64,1 @@\n-                    System.out.println(\"TEST INCORRECT: block returned\");\n-                    System.exit(1);\n+                    throw new RuntimeException(\"TEST INCORRECT: block returned\");\n@@ -88,2 +82,3 @@\n-        while (t1.getState() != Thread.State.WAITING)\n-            Thread.sleep(1);\n+        while (t1.getState() != Thread.State.WAITING) {\n+            Thread.sleep(100);\n+        }\n@@ -108,2 +103,1 @@\n-        \/* Wait for Thread 2 to be blocked on the monitor or to\n-           succeed.  *\/\n+        \/* Wait for Thread 2 to be blocked on the monitor or to succeed. *\/\n@@ -112,4 +106,3 @@\n-        for (int i = 0; i < 1000\/*ms*\/; i++) {\n-            t2.join(1\/*ms*\/);\n-            switch (t2.getState()) {\n-            case TERMINATED:\n+        for (int i = 0; i < 1000; i++) {\n+            t2.join(100 \/*ms*\/);\n+            if (t2.getState() == Thread.State.TERMINATED) {\n@@ -118,10 +111,0 @@\n-            case BLOCKED:\n-                java.util.Map<Thread,StackTraceElement[]> traces =\n-                    Thread.getAllStackTraces();\n-                showStackTrace(\"Thread 1\", traces.get(t1));\n-                showStackTrace(\"Thread 2\", traces.get(t2));\n-                System.out.println(\"TEST FAILED: deadlock\");\n-                System.exit(1);\n-                break;\n-            default:\n-                break;\n@@ -131,3 +114,9 @@\n-        System.out.println(\"TEST FAILED BUT DID NOT NOTICE DEADLOCK\");\n-        Thread.sleep(10000);\n-        System.exit(1);\n+        if (t2.getState() == Thread.State.BLOCKED) {\n+            System.out.println(\"TEST FAILED: deadlock\");\n+        } else {\n+            System.out.println(\"TEST FAILED BUT DID NOT NOTICE DEADLOCK (state = \" + t2.getState() + \")\");\n+        }\n+        java.util.Map<Thread,StackTraceElement[]> traces = Thread.getAllStackTraces();\n+        showStackTrace(\"Thread 1\", traces.get(t1));\n+        showStackTrace(\"Thread 2\", traces.get(t2));\n+        throw new RuntimeException(\"TEST FAILED\");\n@@ -155,0 +144,1 @@\n+\n@@ -164,3 +154,1 @@\n-                    System.out.println(\"TEST INCORRECT: lock interrupted:\");\n-                    e.printStackTrace(System.out);\n-                    System.exit(1);\n+                    throw new RuntimeException(\"TEST INCORRECT: lock interrupted\");\n","filename":"test\/jdk\/javax\/management\/notification\/BroadcasterSupportDeadlockTest.java","additions":21,"deletions":33,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,12 @@\n-import javax.naming.Context;\n-import java.io.*;\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.SequenceInputStream;\n+import java.io.StringWriter;\n+import java.io.Writer;\n@@ -29,1 +39,1 @@\n-import java.util.*;\n+import java.util.ArrayList;\n@@ -32,0 +42,1 @@\n+import java.util.Iterator;\n@@ -33,0 +44,1 @@\n+import java.util.Map;\n@@ -37,1 +49,2 @@\n-import static java.lang.String.format;\n+import javax.naming.Context;\n+\n@@ -41,0 +54,2 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -48,0 +63,3 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.process.ProcessTools\n+ * @run main InitialContextTest\n@@ -246,3 +264,7 @@\n-        ProcessBuilder p = new ProcessBuilder(jar, \"cf\", jarName.toString(),\n-                \"-C\", jarRoot.toString(), \".\");\n-        quickFail(run(p));\n+        String [] commands = {jar, \"cf\", jarName.toString(),\"-C\", jarRoot.toString(), \".\"};\n+        try {\n+            OutputAnalyzer outputAnalyzer = ProcessTools.executeCommand(commands);\n+            outputAnalyzer.shouldHaveExitValue(0);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n@@ -259,6 +281,6 @@\n-        quickFail(run(new ProcessBuilder(commands)));\n-    }\n-\n-    private static void quickFail(Result r) {\n-        if (r.exitValue != 0)\n-            throw new RuntimeException(r.output);\n+        try {\n+            OutputAnalyzer outputAnalyzer = ProcessTools.executeCommand(commands.toArray(new String[commands.size()]));\n+            outputAnalyzer.shouldHaveExitValue(0);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n@@ -270,3 +292,0 @@\n-\n-        String java = getJDKTool(\"java\");\n-\n@@ -274,1 +293,0 @@\n-        commands.add(java);\n@@ -286,0 +304,1 @@\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(commands);\n@@ -287,13 +306,0 @@\n-        return run(new ProcessBuilder(commands));\n-    }\n-\n-    private static Result run(ProcessBuilder b) {\n-        Process p = null;\n-        try {\n-            p = b.start();\n-        } catch (IOException e) {\n-            throw new RuntimeException(\n-                    format(\"Couldn't start process '%s'\", b.command()), e);\n-        }\n-\n-        String output;\n@@ -301,11 +307,4 @@\n-            output = toString(p.getInputStream(), p.getErrorStream());\n-        } catch (IOException e) {\n-            throw new RuntimeException(\n-                    format(\"Couldn't read process output '%s'\", b.command()), e);\n-        }\n-\n-        try {\n-            p.waitFor();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\n-                    format(\"Process hasn't finished '%s'\", b.command()), e);\n+            OutputAnalyzer outputAnalyzer = ProcessTools.executeProcess(pb);\n+            return new Result(outputAnalyzer.getExitValue(), outputAnalyzer.getOutput());\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n@@ -313,2 +312,0 @@\n-\n-        return new Result(p.exitValue(), output);\n","filename":"test\/jdk\/javax\/naming\/spi\/providers\/InitialContextTest.java","additions":41,"deletions":44,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,7 +24,0 @@\n-\/*\n- * @test\n- * @bug 7093691\n- * @summary Tests if JComboBox has correct font color when disabled\/enabled\n- * @run main\/othervm -Dsun.java2d.uiScale=1 DisabledComboBoxFontTestAuto\n- *\/\n-\n@@ -47,0 +40,8 @@\n+\/*\n+ * @test\n+ * @bug 7093691 8310072\n+ * @summary Tests if JComboBox has correct font color when disabled\/enabled\n+ * @key headful\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 DisabledComboBoxFontTestAuto\n+ *\/\n+\n@@ -50,1 +51,0 @@\n-    private static Path testDir;\n@@ -57,1 +57,2 @@\n-        combo.addItem(\"Simple JComboBox\");\n+        combo.addItem(\"\\u2588\".repeat(5));\n+        combo.setFont(combo.getFont().deriveFont(50.0f));\n@@ -60,1 +61,2 @@\n-        combo2.addItem(\"Simple JComboBox\");\n+        combo2.addItem(\"\\u2588\".repeat(5));\n+        combo2.setFont(combo2.getFont().deriveFont(50.0f));\n@@ -93,10 +95,0 @@\n-        ImageIO.write(enabledImage, \"png\", new File(testDir\n-                + \"\/\" + lafName + \"Enabled.png\"));\n-        ImageIO.write(disabledImage, \"png\", new File(testDir\n-                + \"\/\" + lafName + \"Disabled.png\"));\n-        ImageIO.write(enabledImage2, \"png\", new File(testDir\n-                + \"\/\" + lafName + \"EnabledDLCR.png\"));\n-        ImageIO.write(disabledImage2, \"png\", new File(testDir\n-                + \"\/\" + lafName + \"DisabledDLCR.png\"));\n-\n-        boolean isIdentical = true;\n@@ -104,0 +96,1 @@\n+        Path testDir = Path.of(System.getProperty(\"test.classes\", \".\"));\n@@ -106,1 +99,1 @@\n-        int y = 10;\n+        int y = enabledImage.getHeight() \/ 2;\n@@ -109,13 +102,5 @@\n-            \/\/ Nimbus has a pixel offset in coordinates since Nimbus is 2px\n-            \/\/ smaller in width than other L&F's\n-            if (lafName.equals(\"Nimbus\")) {\n-                eColor1 = new Color(enabledImage.getRGB(x + 1, y));\n-                eColor2 = new Color(enabledImage2.getRGB(x, y));\n-                dColor1 = new Color(disabledImage.getRGB(x + 1, y));\n-                dColor2 = new Color(disabledImage2.getRGB(x, y));\n-            } else {\n-                eColor1 = new Color(enabledImage.getRGB(x, y));\n-                eColor2 = new Color(enabledImage2.getRGB(x, y));\n-                dColor1 = new Color(disabledImage.getRGB(x, y));\n-                dColor2 = new Color(disabledImage2.getRGB(x, y));\n-            }\n+            eColor1 = new Color(enabledImage.getRGB(x, y));\n+            eColor2 = new Color(enabledImage2.getRGB(x, y));\n+            dColor1 = new Color(disabledImage.getRGB(x, y));\n+            dColor2 = new Color(disabledImage2.getRGB(x, y));\n+\n@@ -123,2 +108,10 @@\n-                isIdentical = false;\n-                break;\n+                failingLafs.append(lafName + \", \");\n+                ImageIO.write(enabledImage, \"png\", new File(testDir\n+                        + \"\/\" + lafName + \"Enabled.png\"));\n+                ImageIO.write(disabledImage, \"png\", new File(testDir\n+                        + \"\/\" + lafName + \"Disabled.png\"));\n+                ImageIO.write(enabledImage2, \"png\", new File(testDir\n+                        + \"\/\" + lafName + \"EnabledDLCR.png\"));\n+                ImageIO.write(disabledImage2, \"png\", new File(testDir\n+                        + \"\/\" + lafName + \"DisabledDLCR.png\"));\n+                return;\n@@ -127,6 +120,1 @@\n-\n-        if (isIdentical) {\n-            System.out.println(\"PASSED\");\n-        } else {\n-            failingLafs.append(lafName + \", \");\n-        }\n+        System.out.println(\"Test Passed: \" + lafName);\n@@ -137,3 +125,2 @@\n-                || (c1.getBlue() != c2.getBlue())\n-                || (c1.getGreen() != c2.getGreen())) {\n-\n+            || (c1.getBlue() != c2.getBlue())\n+            || (c1.getGreen() != c2.getGreen())) {\n@@ -166,1 +153,0 @@\n-        testDir = Path.of(System.getProperty(\"test.classes\", \".\"));\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/DisabledComboBoxFontTestAuto.java","additions":33,"deletions":47,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import javax.swing.SwingUtilities;\n@@ -45,1 +44,1 @@\n- * @bug 8210807\n+ * @bug 8210807 8322140 8322135\n@@ -53,3 +52,0 @@\n-    public static JFrame frame;\n-    public static PassFailJFrame passFailJFrame;\n-\n@@ -57,12 +53,1 @@\n-        SwingUtilities.invokeAndWait(() -> {\n-            try {\n-                initialize();\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-        });\n-        passFailJFrame.awaitAndCheck();\n-    }\n-\n-    public static void initialize() throws Exception {\n-        final String INSTRUCTIONS = \"\"\"\n+        String INSTRUCTIONS = \"\"\"\n@@ -75,3 +60,9 @@\n-        TestTable testTable = new TestTable(true);\n-        frame = new JFrame(\"JTable Print Test\");\n-        passFailJFrame = new PassFailJFrame(\"Test Instructions\", INSTRUCTIONS, 5L, 6, 35);\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows(6)\n+                .columns(35)\n+                .testUI(JTableScrollPrintTest::initialize)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -79,0 +70,3 @@\n+    public static JFrame initialize() {\n+        TestTable testTable = new TestTable(true);\n+        JFrame frame = new JFrame(\"JTable Print Test\");\n@@ -86,0 +80,1 @@\n+        return frame;\n@@ -106,1 +101,1 @@\n-            if (useScrollPane == true) {\n+            if (useScrollPane) {\n@@ -120,1 +115,1 @@\n-        private Component componentToBePrinted;\n+        private final Component componentToBePrinted;\n","filename":"test\/jdk\/javax\/swing\/JTable\/JTableScrollPrintTest.java","additions":18,"deletions":23,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8257810\n+ * @bug 8257810 8322135\n","filename":"test\/jdk\/javax\/swing\/JTable\/PrintAllPagesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+* Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\/\n+\n+\/**\n+* @test\n+* @bug 8325469\n+* @summary Test freeze\/thaw with OSR frames\n+* @requires vm.continuations\n+* @requires vm.compMode != \"Xint\" & vm.compMode != \"Xcomp\"\n+* @modules java.base\/jdk.internal.vm\n+* @library \/test\/lib \/test\/hotspot\/jtreg\n+* @build jdk.test.whitebox.WhiteBox\n+* @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+*\n+* @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI OSRTest true true true\n+* @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:CompileCommand=inline,*::yield0 OSRTest true true false\n+* @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:CompileCommand=dontinline,*::yield* OSRTest true true false\n+* @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:CompileCommand=exclude,*::bar() OSRTest true false false\n+* @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI OSRTest false true true\n+* @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI OSRTest false true false\n+* @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:CompileCommand=exclude,*::bar() OSRTest false false false\n+*\n+*\/\n+\n+import jdk.internal.vm.Continuation;\n+import jdk.internal.vm.ContinuationScope;\n+\n+import java.lang.reflect.Method;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class OSRTest {\n+    static final WhiteBox wb = WhiteBox.getWhiteBox();\n+    static final ContinuationScope FOO = new ContinuationScope() {};\n+    static final Method foo = getMethod(\"foo\");\n+    static final Method fooBigFrame = getMethod(\"fooBigFrame\");\n+    boolean osrAtBottom;\n+    boolean freezeFast;\n+    boolean thawFast;\n+    int fooCallCount;\n+\n+    public static void main(String[] args) {\n+        if (args.length != 3) {\n+            throw new Error(\"Error: args.length must be 3\");\n+        }\n+        boolean TEST_OSR_AT_BOTTOM = Boolean.parseBoolean(args[0]);\n+        boolean FREEZE_FAST = Boolean.parseBoolean(args[1]);\n+        boolean THAW_FAST = Boolean.parseBoolean(args[2]);\n+        assert !THAW_FAST || FREEZE_FAST : \"THAW_FAST requires FREEZE_FAST\";\n+\n+        OSRTest test = new OSRTest(TEST_OSR_AT_BOTTOM, FREEZE_FAST, THAW_FAST);\n+        test.runTest();\n+    }\n+\n+    public OSRTest(boolean osrAtBottom, boolean freezeFast, boolean thawFast) {\n+        this.osrAtBottom = osrAtBottom;\n+        this.freezeFast = freezeFast;\n+        this.thawFast = thawFast;\n+    }\n+\n+    public void runTest() {\n+        Runnable testCase =  osrAtBottom ? ()-> testOSRAtStackBottom() : ()-> TestOSRNotAtStackBottom();\n+        Continuation cont = new Continuation(FOO, testCase);\n+\n+        while (!cont.isDone()) {\n+            cont.run();\n+            if (freezeFast && !thawFast && fooCallCount == 2) {\n+                \/\/ All frames frozen in last yield should be compiled\n+                \/\/ including OSR version of foo. Invoke full GC now so\n+                \/\/ that chunk is marked and we force thaw slow path.\n+                System.gc();\n+                fooCallCount++; \/\/ Don't call again\n+            }\n+        }\n+    }\n+\n+    public void testOSRAtStackBottom() {\n+        if (freezeFast) {\n+            \/\/ Trigger compilation of Continuation.yield\/yield0\n+            for (int i = 0; i < 10_000; i++) {\n+                Continuation.yield(FOO);\n+            }\n+        }\n+        for (int i = 0; i < 2; i++) {\n+            if (freezeFast && !thawFast) {\n+                foo(new Object(), new Object(), new Object(), new Object(), new Object(),\n+                    new Object(), new Object(), new Object(), new Object(), new Object(),\n+                    1.1f, 1.2f, 1.3f, 1.4f, 1.5f, 1.6f, 1.7f);\n+            } else {\n+                fooBigFrame(new Object(), new Object(), new Object(), new Object(), new Object(),\n+                            new Object(), new Object(), new Object(), new Object(), new Object(),\n+                            1.1f, 1.2f, 1.3f, 1.4f, 1.5f, 1.6f, 1.7f);\n+            }\n+        }\n+    }\n+\n+    \/\/ Declare many parameters and unused locals so that size of interpreter frame is bigger\n+    \/\/ than size of OSR frame + size of Continuation.yield\/yield0 frames. This is so that once\n+    \/\/ foo is OSR, on yield we clear cont_fastpath() forcing the freeze fast path.\n+    public void foo(Object o1, Object o2, Object o3, Object o4, Object o5,\n+                    Object o6, Object o7, Object o8, Object o9, Object o10,\n+                    float f1, float f2, float f3, float f4, float f5, float f6, float f7) {\n+        int i1 = 1;\n+        int i2 = i1 + 1;\n+        int i3 = i2 + 1;\n+        int i4 = i3 + 1;\n+        int i5 = i4 + 1;\n+        int i6 = i5 + 1;\n+        int i7 = i6 + 1;\n+        long ll = 2*(long)i1;\n+        float ff = ll + 1.2f;\n+        double dd = ff + 1.3D;\n+\n+        if (osrAtBottom) {\n+            \/\/ freeze all frames so that we only run with foo on the stack\n+            Continuation.yield(FOO);\n+        }\n+\n+        \/\/ Provoke OSR compilation. After we verified the method was compiled keep looping\n+        \/\/ until we trigger the _backedge_counter overflow to actually trigger OSR.\n+        for (int i = 0; fooCallCount > 0 && (!wb.isMethodCompiled(foo, true) || i++ < 2_000);) {\n+        }\n+        fooCallCount++;\n+\n+        if (freezeFast) {\n+            Continuation.yield(FOO);\n+        } else {\n+            bar();\n+        }\n+    }\n+\n+    public void bar() {\n+        Continuation.yield(FOO);\n+    }\n+\n+    public double fooBigFrame(Object o1, Object o2, Object o3, Object o4, Object o5,\n+                              Object o6, Object o7, Object o8, Object o9, Object o10,\n+                              float f1, float f2, float f3, float f4, float f5, float f6, float f7) {\n+        double d1=1,d2=2,d3=3,d4=4,d5=5,d6=6,d7=7,d8=8,d9=9,d10=10,d11=11,d12=12,d13=13,d14=14,d15=15,d16=16,d17=17,d18=18,d19=19,d20=20,d21=21,d22=22,d23=23,d24=24,d25=25;\n+        double d26=26,d27=27,d28=28,d29=29,d30=30,d31=31,d32=32,d33=33,d34=34,d35=35,d36=36,d37=37,d38=38,d39=39,d40=40,d41=41,d42=42,d43=43,d44=44,d45=45,d46=46,d47=47,d48=48,d49=49,d50=50;\n+        double d51=51,d52=52,d53=53,d54=54,d55=55,d56=56,d57=57,d58=58,d59=59,d60=60,d61=61,d62=62,d63=63,d64=64,d65=65,d66=66,d67=67,d68=68,d69=69,d70=70,d71=71,d72=72,d73=73,d74=74,d75=75;\n+        double d76=76,d77=77,d78=78,d79=79,d80=80,d81=81,d82=82,d83=83,d84=84,d85=85,d86=86,d87=87,d88=88,d89=89,d90=90,d91=91,d92=92,d93=93,d94=94,d95=95,d96=96,d97=97,d98=98,d99=99,d100=100;\n+        double d101=101,d102=102,d103=103,d104=104,d105=105,d106=106,d107=107,d108=108,d109=109,d110=110,d111=111,d112=112,d113=113,d114=114,d115=115,d116=116,d117=117,d118=118,d119=119,d120=120,d121=121,d122=122,d123=123,d124=124,d125=125;\n+        double d126=126,d127=127,d128=128,d129=129,d130=130,d131=131,d132=132,d133=133,d134=134,d135=135,d136=136,d137=137,d138=138,d139=139,d140=140,d141=141,d142=142,d143=143,d144=144,d145=145,d146=146,d147=147,d148=148,d149=149,d150=150;\n+        double d151=151,d152=152,d153=153,d154=154,d155=155,d156=156,d157=157,d158=158,d159=159,d160=160,d161=161,d162=162,d163=163,d164=164,d165=165,d166=166,d167=167,d168=168,d169=169,d170=170,d171=171,d172=172,d173=173,d174=174,d175=175;\n+        double d176=176,d177=177,d178=178,d179=179,d180=180,d181=181,d182=182,d183=183,d184=184,d185=185,d186=186,d187=187,d188=188,d189=189,d190=190,d191=191,d192=192,d193=193,d194=194,d195=195,d196=196,d197=197,d198=198,d199=199,d200=200;\n+        double d201=201,d202=202,d203=203,d204=204,d205=205,d206=206,d207=207,d208=208,d209=209,d210=210,d211=211,d212=212,d213=213,d214=214,d215=215,d216=216,d217=217,d218=218,d219=219,d220=220,d221=221,d222=222,d223=223,d224=224,d225=225;\n+        double d226=226,d227=227,d228=228,d229=229,d230=230,d231=231,d232=232,d233=233,d234=234,d235=235,d236=236,d237=237,d238=238,d239=239,d240=240,d241=241,d242=242,d243=243,d244=244,d245=245,d246=246,d247=247,d248=248,d249=249,d250=250;\n+        double d251=251,d252=252,d253=253,d254=254,d255=255,d256=256,d257=257,d258=258,d259=259,d260=260,d261=261,d262=262,d263=263,d264=264,d265=265,d266=266,d267=267,d268=268,d269=269,d270=270,d271=271,d272=272,d273=273,d274=274,d275=275;\n+        double d276=276,d277=277,d278=278,d279=279,d280=280,d281=281,d282=282,d283=283,d284=284,d285=285,d286=286,d287=287,d288=288,d289=289,d290=290,d291=291,d292=292,d293=293,d294=294,d295=295,d296=296,d297=297,d298=298,d299=299,d300=300;\n+\n+        \/\/ freeze all frames so that we only run with fooBigFrame on the stack\n+        Continuation.yield(FOO);\n+\n+        \/\/ Provoke OSR compilation. After we verified the method was compiled keep looping\n+        \/\/ until we trigger the _backedge_counter overflow to actually trigger OSR.\n+        for (int i = 0; fooCallCount > 0 && (!wb.isMethodCompiled(fooBigFrame, true) || i++ < 2_000);) {\n+        }\n+        fooCallCount++;\n+\n+        Continuation.yield(FOO);\n+\n+        \/\/ For the thaw fast case we want to trigger the case of thawing one\n+        \/\/ frame at a time. Because the OSR frame is at the bottom we have to\n+        \/\/ make its size > 500 words, so we use a lot of locals. We also want\n+        \/\/ the interpreted frame size be bigger than OSR frame + size of\n+        \/\/ Continuation.yield\/yield0, so that we clear cont_fastpath() on yield\n+        \/\/ forcing the freeze fast path (same as with foo). For that, we just\n+        \/\/ declare more locals than the ones we use after OSR happens.\n+        \/\/ For the freeze slow case we also want the interpreted frame size to\n+        \/\/ be bigger than OSR frame + size of Continuation.yield\/yield0, so the\n+        \/\/ last technique serves for this case too.\n+        double res = d1*d2*d3*d4*d5*d6*d7*d8*d9*d10*d11*d12*d13*d14*d15*d16*d17*d18*d19*d20*d21*d22*d23*d24*d25*d26*d27*d28*d29*d30*d31*d32*d33*d34*d35*d36*d37*d38*d39*d40*d41*d42*d43*d44*d45*d46*d47*d48*d49*d50*\n+                     d51*d52*d53*d54*d55*d56*d57*d58*d59*d60*d61*d62*d63*d64*d65*d66*d67*d68*d69*d70*d71*d72*d73*d74*d75*d76*d77*d78*d79*d80*d81*d82*d83*d84*d85*d86*d87*d88*d89*d90*d91*d92*d93*d94*d95*d96*d97*d98*d99*d100*\n+                     d101*d102*d103*d104*d105*d106*d107*d108*d109*d110*d111*d112*d113*d114*d115*d116*d117*d118*d119*d120*d121*d122*d123*d124*d125*d126*d127*d128*d129*d130*d131*d132*d133*d134*d135*d136*d137*d138*d139*d140*\n+                     d141*d142*d143*d144*d145*d146*d147*d148*d149*d150*d151*d152*d153*d154*d155*d156*d157*d158*d159*d160*d161*d162*d163*d164*d165*d166*d167*d168*d169*d170*d171*d172*d173*d174*d175*d176*d177*d178*d179*d180*\n+                     d181*d182*d183*d184*d185*d186*d187*d188*d189*d190*d191*d192*d193*d194*d195*d196*d197*d198*d199*d200*d201*d202*d203*d204*d205*d206*d207*d208*d209*d210*d211*d212*d213*d214*d215*d216*d217*d218*d219*d220*\n+                     d221*d222*d223*d224*d225*d226*d227*d228*d229*d230*d231*d232*d233*d234*d235*d236*d237*d238*d239*d240*d241*d242*d243*d244*d245*d246*d247*d248*d249*d250*d251*d252*d253*d254*d255*d256*d257*d258*d259*d260*\n+                     d261*d262*d263*d264*d265*d266*d267*d268*d269*d270*d271*d272*d273*d274*d275;\n+        return res;\n+    }\n+\n+    public void TestOSRNotAtStackBottom() {\n+        \/\/ freeze all frames currently in the stack\n+        boolean res = Continuation.yield(FOO);\n+\n+        for (int i = 1; i < 100000; i++) {\n+            \/\/ When testing the thaw fast path make recursion big enough so that\n+            \/\/ the size of all frames at freeze time is more than 500 words. This\n+            \/\/ way we later force thawing one frame at a time.\n+            recurse(thawFast ? 60 : 5, i);\n+        }\n+    }\n+\n+    public void recurse(int depth, int iteration) {\n+        if (depth > 0) {\n+            recurse(depth - 1, iteration);\n+        } else {\n+            \/\/ Make compiler see this branch but not enough times to avoid foo\n+            \/\/ getting compiled, since we want the OSR version.\n+            if (iteration % 45000 == 0) {\n+                foo(new Object(), new Object(), new Object(), new Object(), new Object(),\n+                    new Object(), new Object(), new Object(), new Object(), new Object(),\n+                    1.1f, 1.2f, 1.3f, 1.4f, 1.5f, 1.6f, 1.7f);\n+            } else {\n+                Continuation.yield(FOO);\n+            }\n+        }\n+    }\n+\n+    static Method getMethod(String method) {\n+        try {\n+            return OSRTest.class.getMethod(method, Object.class, Object.class, Object.class, Object.class, Object.class, Object.class, Object.class, Object.class,\n+                                           Object.class, Object.class, Float.TYPE, Float.TYPE, Float.TYPE, Float.TYPE, Float.TYPE, Float.TYPE, Float.TYPE);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Exception: couldn't found method \" + method + \". \" + e.getMessage());\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/OSRTest.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -59,2 +59,1 @@\n-            \"UnsignedIntFlag\", \"UnsignedIntFlagChanged\", \"DoubleFlagChanged\",\n-            \"SafepointCleanupTask\")\n+            \"UnsignedIntFlag\", \"UnsignedIntFlagChanged\", \"DoubleFlagChanged\")\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestLookForUntestedEvents.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-        EventNames.SafepointCleanup,\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestSafepointEvents.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.startupargs;\n+\n+import jdk.jfr.Recording;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main jdk.jfr.startupargs.TestStartHelp\n+ *\/\n+public class TestStartHelp {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"-XX:StartFlightRecording:help\");\n+        OutputAnalyzer out = ProcessTools.executeProcess(pb);\n+        out.shouldContain(\"Syntax : -XX:StartFlightRecording:[options]\");\n+        out.shouldContain(\"options are separated with a comma.\");\n+        out.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestStartHelp.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.process.ProcessTools\n+ * @run main EscapePath\n@@ -29,1 +32,9 @@\n-import java.io.*;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -78,9 +89,14 @@\n-    private static void invokeJava() throws Exception {\n-        String command = System.getProperty(\"java.home\") +\n-                         File.separator + \"bin\" + File.separator +\n-                         \"java -classpath \" + \"a#b\/ Hello\";\n-        Process p = Runtime.getRuntime().exec(command);\n-        p.waitFor();\n-        int result = p.exitValue();\n-        if (result != 0)\n-            throw new RuntimeException(\"Path encoding failure.\");\n+    private static void invokeJava() {\n+        List<String> commands = new ArrayList<>();\n+\n+        commands.add(\"-classpath\");\n+        commands.add(\"a#b\");\n+        commands.add(\"Hello\");\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(commands);\n+\n+        try {\n+            OutputAnalyzer outputAnalyzer = ProcessTools.executeProcess(pb);\n+            outputAnalyzer.shouldHaveExitValue(0);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n","filename":"test\/jdk\/sun\/misc\/EscapePath.java","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307143\n+ * @summary CredentialsCache.cacheName should not be static\n+ * @modules java.security.jgss\/sun.security.krb5\n+ *          java.security.jgss\/sun.security.krb5.internal.ccache\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.krb5.PrincipalName;\n+import sun.security.krb5.internal.ccache.CredentialsCache;\n+\n+public class TwoFiles {\n+    public static void main(String[] args) throws Exception {\n+        PrincipalName pn = new PrincipalName(\"me@HERE\");\n+        CredentialsCache cc1 = CredentialsCache.create(pn, \"cc1\");\n+        CredentialsCache cc2 = CredentialsCache.create(pn, \"cc2\");\n+        \/\/ name is canonicalized\n+        Asserts.assertTrue(cc1.cacheName().endsWith(\"cc1\"), cc1.cacheName());\n+        Asserts.assertTrue(cc2.cacheName().endsWith(\"cc2\"), cc2.cacheName());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/ccache\/TwoFiles.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -236,1 +236,11 @@\n-        PKCS11_BASE = new File(cwd, PKCS11_REL_PATH.replace('\/', SEP)).getAbsolutePath();\n+        File pkcs11 = new File(cwd, PKCS11_REL_PATH.replace('\/', SEP));\n+        if (!new File(pkcs11, \"nss\/p11-nss.txt\").exists()) {\n+            \/\/ this test might be in the closed\n+            pkcs11 = new File(new File(cwd, \"..\/..\/..\/open\/test\/jdk\"),\n+                    PKCS11_REL_PATH.replace('\/', SEP));\n+            if (!new File(pkcs11, \"nss\/p11-nss.txt\").exists()) {\n+                throw new RuntimeException(\"Not a PKCS11 directory\"\n+                        + pkcs11.getAbsolutePath());\n+            }\n+        }\n+        PKCS11_BASE = pkcs11.getAbsolutePath();\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      8202947 8239804\n+ * @bug      8202947 8239804 8324342\n@@ -132,0 +132,100 @@\n+\n+    @Test\n+    public void testAuthorDefault(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * Class C.\n+                 * @author J. Duke\n+                 *\/\n+                 public class C {\n+                     \/** Class Nested, with no explicit at-author. *\/\n+                     public class Nested { }\n+                 }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-author\",\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Author:<\/dt>\n+                    <dd>J. Duke<\/dd>\"\"\");\n+\n+        checkOutput(\"p\/C.Nested.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Author:<\/dt>\n+                    <dd>J. Duke<\/dd>\"\"\");\n+    }\n+\n+    @Test\n+    public void testAuthorDefault_Multiple(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * Class C.\n+                 * @author J. Duke\n+                 * @author A. N. Other\n+                 *\/\n+                 public class C {\n+                     \/** Class Nested, with no explicit at-author. *\/\n+                     public class Nested { }\n+                 }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-author\",\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Author:<\/dt>\n+                    <dd>J. Duke, A. N. Other<\/dd>\"\"\");\n+\n+        checkOutput(\"p\/C.Nested.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Author:<\/dt>\n+                    <dd>J. Duke, A. N. Other<\/dd>\"\"\");\n+    }\n+\n+    @Test\n+    public void testAuthorDefault_Nested(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * Class C.\n+                 * @author J. Duke\n+                 * @author A. N. Other\n+                 *\/\n+                 public class C {\n+                     public class Nested1 {\n+                         \/** Class Nested, with no explicit at-author. *\/\n+                         public class Nested { }\n+                     }\n+                 }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-author\",\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Author:<\/dt>\n+                    <dd>J. Duke, A. N. Other<\/dd>\"\"\");\n+\n+        checkOutput(\"p\/C.Nested1.Nested.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Author:<\/dt>\n+                    <dd>J. Duke, A. N. Other<\/dd>\"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testAuthor\/TestAuthor.java","additions":102,"deletions":2,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -424,1 +424,1 @@\n-                    <script type=\"text\/javascript\" src=\"script-files\/jquery-3.6.1.min.js\"><\/script>\n+                    <script type=\"text\/javascript\" src=\"script-files\/jquery-3.7.1.min.js\"><\/script>\n@@ -675,1 +675,1 @@\n-                \"script-files\/jquery-3.6.1.min.js\",\n+                \"script-files\/jquery-3.7.1.min.js\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-    load(docsPath + \"\/search.js\");\n+    load(docsPath + \"\/script-files\/search.js\");\n@@ -66,0 +66,6 @@\n+            attr: function() {\n+                return this;\n+            },\n+            css: function() {\n+                return this;\n+            },\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearchScript\/javadoc-search.js","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      7180906 8026567 8239804\n+ * @bug      7180906 8026567 8239804 8324342\n@@ -28,1 +28,1 @@\n- * @library  ..\/..\/lib\n+ * @library  \/tools\/lib ..\/..\/lib\n@@ -30,1 +30,1 @@\n- * @build    javadoc.tester.*\n+ * @build    toolbox.ToolBox javadoc.tester.*\n@@ -34,0 +34,2 @@\n+import java.nio.file.Path;\n+\n@@ -35,0 +37,1 @@\n+import toolbox.ToolBox;\n@@ -44,0 +47,2 @@\n+    private final ToolBox tb = new ToolBox();\n+\n@@ -78,0 +83,66 @@\n+\n+    @Test\n+    public void testSinceDefault(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * Class C.\n+                 * @since 99\n+                 *\/\n+                 public class C {\n+                     \/** Class Nested, with no explicit at-since. *\/\n+                     public class Nested { }\n+                 }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Since:<\/dt>\n+                    <dd>99<\/dd>\"\"\");\n+\n+        checkOutput(\"p\/C.Nested.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Since:<\/dt>\n+                    <dd>99<\/dd>\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testSinceDefault_Nested(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * Class C.\n+                 * @since 99\n+                 *\/\n+                 public class C {\n+                     public class Nested1 {\n+                         \/** Class Nested, with no explicit at-since. *\/\n+                         public class Nested { }\n+                     }\n+                 }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Since:<\/dt>\n+                    <dd>99<\/dd>\"\"\");\n+\n+        checkOutput(\"p\/C.Nested1.Nested.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Since:<\/dt>\n+                    <dd>99<\/dd>\"\"\");\n+\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSinceTag\/TestSinceTag.java","additions":75,"deletions":4,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      8202947 8239804\n+ * @bug      8202947 8239804 8324342\n@@ -132,0 +132,33 @@\n+\n+    @Test\n+    public void testVersionDefault(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * Class C.\n+                 * @version 42\n+                 *\/\n+                 public class C {\n+                     \/** Class Nested, with no explicit at-version. *\/\n+                     public class Nested { }\n+                 }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-version\",\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Version:<\/dt>\n+                    <dd>42<\/dd>\"\"\");\n+\n+        checkOutput(\"p\/C.Nested.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Version:<\/dt>\n+                    <dd>42<\/dd>\"\"\");\n+\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testVersionTag\/TestVersionTag.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/EnablePreviewOption.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/ReleaseOption.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/T4696488.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/T4994049\/T4994049.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/T6551367.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/TestScriptInComment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-            \"script-files\/jquery-3.6.1.min.js\",\n+            \"script-files\/jquery-3.7.1.min.js\",\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/modules\/CommandLineFiles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/modules\/FilterOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/modules\/PackageOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/modules\/PatchModules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/modules\/ReleaseOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/nonConstExprs\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/parser\/7091528\/T7091528.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,2 +92,1 @@\n-        \"record.length()\",\n-        \"\\\"\\\\{0}\\\"\"\n+        \"record.length()\"\n@@ -238,4 +237,1 @@\n-        \"\\\"\\\\\",\n-        \"\\\"\\\\{\",\n-        \"\\\"\\\\{0\",\n-        \"\\\"\\\\{0}\",\n+        \"\\\"\\\\\"\n@@ -387,3 +383,0 @@\n-        assertStatus(\"\\\"\\\"\\\"\\n\\\\{\", DEFINITELY_INCOMPLETE, null);\n-        assertStatus(\"\\\"\\\"\\\"\\n\\\\{0\", DEFINITELY_INCOMPLETE, null);\n-        assertStatus(\"\\\"\\\"\\\"\\n\\\\{0}\", DEFINITELY_INCOMPLETE, null);\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/jshell\/HighlightUITest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/jshell\/HistoryUITest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/jshell\/IndentUITest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/jshell\/PasteAndMeasurementsUITest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/jshell\/ToolMultilineSnippetHistoryTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/jshell\/ToolShiftTabTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/jshell\/ToolTabCommandTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/jshell\/ToolTabSnippetTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n","filename":"test\/langtools\/jdk\/jshell\/UndefinedClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8329595\n+ * @summary Verify spurious \"might not have been initialized\" error on static final field\n+ * @run main StaticFinalNestedClass\n+ *\/\n+public class StaticFinalNestedClass {\n+    public class Inner {                    \/\/ note this inner class is NOT static\n+        public static final String NAME;\n+        static {\n+            try {\n+                NAME = \"bob\";\n+            } catch (Exception e) {\n+                throw new Error(e);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new StaticFinalNestedClass().new Inner();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/StaticFinalNestedClass.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-\/\/ options: --enable-preview --source 23\n+\/\/ options: --enable-preview --source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DefaultAndBothBoolean.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.misc.feature.string.templates\n- \/\/ key: compiler.warn.preview.feature.use.plural\n- \/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n-\n-class StringTemplate {\n-    String m() {\n-        int x = 10, y = 20;\n-        return STR.\"\\{x} + \\{y} = \\{x + y}\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplate.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.err.processor.missing.from.string.template.expression\n- \/\/ key: compiler.misc.feature.string.templates\n- \/\/ key: compiler.warn.preview.feature.use.plural\n- \/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n-\n-class StringTemplateNoProcessor {\n-    String m() {\n-        int x = 10, y = 20;\n-        return \"\\{x} + \\{y} = \\{x + y}\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateNoProcessor.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.err.cant.resolve.location.args\n- \/\/ key: compiler.misc.location\n- \/\/ key: compiler.note.preview.recompile\n- \/\/ key: compiler.err.not.a.processor.type\n- \/\/ options: --enable-preview  -source ${jdk.version}\n-\n-import java.lang.*;\n-\n-class StringTemplateNotProcessor {\n-    String m() {\n-        String processor = \"\";\n-        int x = 10, y = 20;\n-        return processor.\"\\{x} + \\{y} = \\{x + y}\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateNotProcessor.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n- \/\/ key: compiler.misc.unexpected.ret.val\n- \/\/ key: compiler.err.prob.found.req\n- \/\/ options: --enable-preview -source ${jdk.version}\n-\n-import java.lang.*;\n-import java.lang.StringTemplate.Processor;\n-\n-class StringTemplateRawProcessor {\n-    void m() {\n-        Processor processor = ts -> ts.interpolate();\n-        try {\n-            int x = 10, y = 20;\n-            return processor.\"\\{x} + \\{y} = \\{x + y}\";\n-        } catch (Throwable x) {\n-            throw new RuntimeException(x);\n-        }\n-    }\n-}\n-\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateRawProcessor.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n- \/\/ key: compiler.err.unclosed.str.lit\n- \/\/ key: compiler.err.string.template.is.not.well.formed\n- \/\/ options: --enable-preview -source ${jdk.version}\n-\n-import java.lang.*;\n-\n-class StringTemplateUnclosedString {\n-    String m() {\n-        int x = 10;\n-        return STR.\"\\{x\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateUnclosedString.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n- \/\/ key: compiler.err.unclosed.text.block\n- \/\/ key: compiler.err.text.block.template.is.not.well.formed\n- \/\/ key: compiler.err.premature.eof\n- \/\/ options: --enable-preview -source ${jdk.version}\n-\n-import java.lang.*;\n-\n-class StringTemplateUnclosedTextBlock {\n-    String m() {\n-        int x = 10;\n-        return STR.\"\"\"\n-                aaa\n-                \\{x\n-                \"\"\"\n-        ;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateUnclosedTextBlock.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n-\/\/ options: --enable-preview --source 23\n+\/\/ options: --enable-preview --source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnconditionalPatternAndBothBoolean.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1920,46 +1920,0 @@\n-    @Test\n-    void testStringTemplate1() throws IOException {\n-        String code = \"\"\"\n-                      package test;\n-                      public class Test {\n-                           Test(int a) {\n-                               String s = \"prefix \\\\{a} suffix\";\n-                           }\n-                      }\n-                      \"\"\";\n-\n-        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,\n-                null, null, Arrays.asList(new MyFileObject(code)));\n-        CompilationUnitTree cut = ct.parse().iterator().next();\n-        ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);\n-        MethodTree constr = (MethodTree) clazz.getMembers().get(0);\n-        VariableTree decl = (VariableTree) constr.getBody().getStatements().get(0);\n-        SourcePositions sp = Trees.instance(ct).getSourcePositions();\n-        int initStart = (int) sp.getStartPosition(cut, decl.getInitializer());\n-        int initEnd   = (int) sp.getEndPosition(cut, decl.getInitializer());\n-        assertEquals(\"correct templated String span expected\", code.substring(initStart, initEnd), \"\\\"prefix \\\\{a} suffix\\\"\");\n-    }\n-\n-    @Test\n-    void testStringTemplate2() throws IOException {\n-        String code = \"\"\"\n-                      package test;\n-                      public class Test {\n-                           Test(int a) {\n-                               String s = STR.\"prefix \\\\{a} suffix\";\n-                           }\n-                      }\n-                      \"\"\";\n-\n-        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,\n-                null, null, Arrays.asList(new MyFileObject(code)));\n-        CompilationUnitTree cut = ct.parse().iterator().next();\n-        ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);\n-        MethodTree constr = (MethodTree) clazz.getMembers().get(0);\n-        VariableTree decl = (VariableTree) constr.getBody().getStatements().get(0);\n-        SourcePositions sp = Trees.instance(ct).getSourcePositions();\n-        int initStart = (int) sp.getStartPosition(cut, decl.getInitializer());\n-        int initEnd   = (int) sp.getEndPosition(cut, decl.getInitializer());\n-        assertEquals(\"correct templated String span expected\", code.substring(initStart, initEnd), \"STR.\\\"prefix \\\\{a} suffix\\\"\");\n-    }\n-\n@@ -2047,57 +2001,0 @@\n-    @Test\n-    void testIncompleteStringTemplate() throws IOException {\n-        String template = \"\\\"\\\\{o.toString()}\\\"\";\n-        String prefix = \"\"\"\n-                      package t;\n-                      class Test {\n-                          void test(Object o) {\n-                              String s = STR.\"\"\";\n-\n-        Worker<Void> verifyParseable = task -> {\n-            try {\n-                task.parse().iterator().next();\n-                return null;\n-            } catch (IOException ex) {\n-                throw new AssertionError(ex);\n-            }\n-        };\n-        JavacTaskPool pool = new JavacTaskPool(1);\n-        DiagnosticListener<JavaFileObject> dl = d -> {};\n-        List<String> options = List.of(\"--enable-preview\",\n-                                       \"-source\", System.getProperty(\"java.specification.version\"));\n-        for (int i = 0; i < template.length(); i++) {\n-            pool.getTask(null, fm, dl, options,\n-                    null, Arrays.asList(new MyFileObject(prefix + template.substring(0, i))),\n-                    verifyParseable\n-            );\n-        }\n-        for (int i = 0; i < template.length() - 1; i++) {\n-            pool.getTask(null, fm, dl, options,\n-                    null, Arrays.asList(new MyFileObject(prefix + template.substring(0, i) + \"\\\"\")),\n-                    verifyParseable);\n-        }\n-        String incomplete = prefix + \"\\\"\\\\{o.\";\n-        pool.getTask(null, fm, dl, options,\n-                null, Arrays.asList(new MyFileObject(incomplete)), task -> {\n-            try {\n-                CompilationUnitTree cut = task.parse().iterator().next();\n-                String result = cut.toString().replaceAll(\"\\\\R\", \"\\n\");\n-                System.out.println(\"RESULT\\n\" + result);\n-                assertEquals(\"incorrect AST\",\n-                             result,\n-                             \"\"\"\n-                             package t;\n-                             \\n\\\n-                             class Test {\n-                                 \\n\\\n-                                 void test(Object o) {\n-                                     String s = STR.<error>;\n-                                 }\n-                             }\"\"\");\n-                return null;\n-            } catch (IOException ex) {\n-                throw new AssertionError(ex);\n-            }\n-        });\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8322992 8331030\n+ * @summary Javac fails with StackOverflowError when compiling deeply nested synchronized blocks\n+ * @run main SOEDeeplyNestedBlocksTest\n+ *\/\n+\n+import java.net.*;\n+import java.util.*;\n+import javax.tools.*;\n+\n+public class SOEDeeplyNestedBlocksTest {\n+\n+    static final int NESTING_DEPTH = 1000;\n+\n+    public static void main(String... args) {\n+        var lines = new ArrayList<String>();\n+        lines.add(\"class Test {\");\n+        lines.add(\"  static { \");\n+        for (int i = 0; i < NESTING_DEPTH; i++) lines.add(\"    synchronized (Test.class) {\");\n+        for (int i = 0; i < NESTING_DEPTH; i++) lines.add(\"    }\");\n+        lines.add(\"  }\");\n+        lines.add(\"}\");\n+\n+        var source = SimpleJavaFileObject.forSource(URI.create(\"mem:\/\/Test.java\"), String.join(\"\\n\", lines));\n+        var compiler = ToolProvider.getSystemJavaCompiler();\n+        var task = compiler.getTask(null, null, noErrors, null, null, List.of(source));\n+        task.call();\n+    }\n+\n+    static DiagnosticListener<? super JavaFileObject> noErrors = d -> {\n+        System.out.println(d);\n+        if (d.getKind() == Diagnostic.Kind.ERROR) {\n+            throw new AssertionError(d.getMessage(null));\n+        }\n+    };\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SOEDeeplyNestedBlocksTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -1,240 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 0000000\n- * @summary Exercise javac handing of templated strings.\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- * @build toolbox.ToolBox toolbox.JavacTask\n- * @run main Basic\n- *\/\n-\n-\n-import toolbox.JavacTask;\n-import toolbox.JavaTask;\n-import toolbox.Task;\n-import toolbox.ToolBox;\n-\n-public class Basic {\n-    private static ToolBox TOOLBOX = new ToolBox();\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n-    public static void main(String... arg) {\n-        primitivesTest();\n-        missingPartsTest();\n-        expressionsTest();\n-        invalidExpressionsTest();\n-        processorTest();\n-    }\n-\n-    \/*\n-     * Primitive types test.\n-     *\/\n-    static void primitivesTest() {\n-        for (String type : new String[] {\n-            \"byte\",\n-            \"short\",\n-            \"int\",\n-            \"long\",\n-            \"float\",\n-            \"double\"\n-        }) {\n-            compPass(type + \" x = 10; \" + type + \"  y = 20; StringTemplate result = RAW.\\\"\\\\{x} + \\\\{y} = \\\\{x + y}\\\";\");\n-        }\n-    }\n-\n-    \/*\n-     * Missing parts test.\n-     *\/\n-    static void missingPartsTest() {\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{x\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{{x}\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{x + }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ * x }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ (x + x }\";\n-        \"\"\");\n-    }\n-\n-    \/*\n-     * Expressions test.\n-     *\/\n-    static void expressionsTest() {\n-        compPass(\"\"\"\n-            int x = 10;\n-            int[] y = new int[] { 10, 20, 30 };\n-            StringTemplate result1 = RAW.\"\\\\{x + 1}\";\n-            StringTemplate result2 = RAW.\"\\\\{x + x}\";\n-            StringTemplate result3 = RAW.\"\\\\{x - x}\";\n-            StringTemplate result4 = RAW.\"\\\\{x * x}\";\n-            StringTemplate result5 = RAW.\"\\\\{x \/ x}\";\n-            StringTemplate result6 = RAW.\"\\\\{x % x}\";\n-            StringTemplate result7 = RAW.\"\\\\{x + (x + x)}\";\n-            StringTemplate result8 = RAW.\"\\\\{y[x - 9]}\";\n-            StringTemplate result9 = RAW.\"\\\\{System.out}\";\n-            StringTemplate result10 = RAW.\\\"\"\"\n-                    \\\\{ \"a string\" }\n-                    \\\"\"\";\n-                    \"\"\");\n-        compPass(\"\"\"\n-            StringTemplate result = RAW.\\\"\"\"\n-                 \\\\{\n-                     new Collection<String>() {\n-                          @Override public int size() { return 0; }\n-                          @Override public boolean isEmpty() { return false; }\n-                          @Override public boolean contains(Object o) { return false; }\n-                          @Override public Iterator<String> iterator() { return null; }\n-                          @Override public Object[] toArray() { return new Object[0]; }\n-                          @Override public <T> T[] toArray(T[] a) { return null; }\n-                          @Override public boolean add(String s) { return false; }\n-                          @Override public boolean remove(Object o) { return false; }\n-                          @Override public boolean containsAll(Collection<?> c) { return false; }\n-                          @Override public boolean addAll(Collection<? extends String> c) { return false; }\n-                          @Override public boolean removeAll(Collection<?> c) { return false; }\n-                          @Override public boolean retainAll(Collection<?> c) { return false; }\n-                          @Override public void clear() { }\n-                      }\n-                 }\n-                 \\\"\"\";\n-         \"\"\");\n-    }\n-\n-    \/*\n-     * Invalid expressions test.\n-     *\/\n-    static void invalidExpressionsTest() {\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ (x == x }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ true ?  : x - 1 }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-             String result = RAW.\"\\\\{ 'a }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ Math.min(, x - 1) }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ \\\\tx }\";\n-        \"\"\");\n-    }\n-\n-    \/*\n-     * Processor test.\n-     *\/\n-    static void processorTest() {\n-        compPass(\"\"\"\n-         int x = 10, y = 20;\n-         String string = STR.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n-         \"\"\");\n-        compFail(\"\"\"\n-         int x = 10, y = 20;\n-         String processor = \"abc\";\n-         String string = processor.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n-         \"\"\");\n-        compFail(\"\"\"\n-         int x = 10, y = 20;\n-         long processor = 100;\n-         String string = processor.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n-         \"\"\");\n-    }\n-\n-    \/*\n-     * Test source for successful compile.\n-     *\/\n-    static void compPass(String code) {\n-        String source = \"\"\"\n-            import java.lang.*;\n-            import java.util.*;\n-            import static java.lang.StringTemplate.RAW;\n-            public class TEST {\n-                public static void main(String... arg) {\n-            \"\"\" +\n-            code.indent(8) +\n-            \"\"\"\n-                }\n-            }\n-            \"\"\";\n-        String output = new JavacTask(TOOLBOX)\n-                .sources(source)\n-                .classpath(\".\")\n-                .options(\"-encoding\", \"utf8\", \"--enable-preview\", \"-source\", JAVA_VERSION)\n-                .run()\n-                .writeAll()\n-                .getOutput(Task.OutputKind.DIRECT);\n-\n-        if (output.contains(\"compiler.err\")) {\n-            throw new RuntimeException(\"Error detected\");\n-        }\n-    }\n-\n-    \/*\n-     * Test source for unsuccessful compile and specific error.\n-     *\/\n-    static void compFail(String code) {\n-        String source = \"\"\"\n-            import java.lang.*;\n-            import java.util.*;\n-            import static java.lang.StringTemplate.RAW;\n-            public class TEST {\n-                public static void main(String... arg) {\n-            \"\"\" +\n-            code.indent(8) +\n-            \"\"\"\n-                }\n-            }\n-            \"\"\";\n-        String errors = new JavacTask(TOOLBOX)\n-                .sources(source)\n-                .classpath(\".\")\n-                .options(\"-XDrawDiagnostics\", \"-encoding\", \"utf8\", \"--enable-preview\", \"-source\", JAVA_VERSION)\n-                .run(Task.Expect.FAIL)\n-                .writeAll()\n-                .getOutput(Task.OutputKind.DIRECT);\n-\n-        if (!errors.contains(\"compiler.err\")) {\n-            throw new RuntimeException(\"No error detected\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/template\/Basic.java","additions":0,"deletions":240,"binary":false,"changes":240,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test T8312814\n- * @summary Verify proper behavior of TransType w.r.t. templated Strings\n- * @enablePreview\n- * @compile T8312814.java\n- *\/\n-\n-\n-import java.util.List;\n-\n-public class T8312814 {\n-    void x(List<? extends StringTemplate.Processor<String, RuntimeException>> list) {\n-        list.get(0).\"\";\n-    }\n-}\n-\n","filename":"test\/langtools\/tools\/javac\/template\/T8312814.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify proper behavior of TreeScanner w.r.t. templated Strings\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.*;\n-import java.util.*;\n-import javax.tools.*;\n-import com.sun.source.tree.*;\n-import com.sun.source.util.*;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-\n-public class TreeScannerTest {\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n-    public static void main(String... args) throws Exception {\n-        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n-        String code = \"\"\"\n-                      public class Test {\n-                          private void test(int a) {\n-                              String s1 = TEST.\"p\\\\{a}s\";\n-                              String s2 = \"p\\\\{a}s\";\n-                          }\n-                      }\n-                      \"\"\";\n-        JavacTask task = (JavacTask) compiler.getTask(null, null, null,\n-            List.of(\"--enable-preview\", \"-source\", JAVA_VERSION), null, List.of(new TestJFO(code)));\n-        StringBuilder output = new StringBuilder();\n-        TreeScanner<Void,Void> checker = new TreeScanner<Void, Void>() {\n-            private boolean log;\n-\n-            @Override\n-            public Void visitStringTemplate(StringTemplateTree node, Void p) {\n-                boolean prevLog = log;\n-                try {\n-                    log = true;\n-                    return super.visitStringTemplate(node, p);\n-                } finally {\n-                    log = prevLog;\n-                }\n-            }\n-\n-            @Override\n-            public Void scan(Tree tree, Void p) {\n-                if (log) {\n-                    output.append(\"(\");\n-                    output.append(tree != null ? tree.getKind() : \"null\");\n-                    try {\n-                        return super.scan(tree, p);\n-                    } finally {\n-                        output.append(\")\");\n-                    }\n-                } else {\n-                    return super.scan(tree, p);\n-                }\n-            }\n-\n-        };\n-\n-        checker.scan(task.parse(), null);\n-\n-        String expected = \"(IDENTIFIER)(IDENTIFIER)(null)(IDENTIFIER)\";\n-        if (!expected.equals(output.toString())) {\n-            throw new AssertionError(\"expected output not found, found: \" + output);\n-        }\n-    }\n-\n-    private static final class TestJFO extends SimpleJavaFileObject {\n-        private final String code;\n-\n-        public TestJFO(String code) throws URISyntaxException, IOException {\n-            super(new URI(\"mem:\/\/Test.java\"), Kind.SOURCE);\n-            this.code = code;\n-        }\n-\n-        @Override\n-        public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-            return code;\n-        }\n-\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/template\/TreeScannerTest.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -126,4 +126,0 @@\n-            case TEMPLATE:\n-                ok = ok & verify(k, i, i == StringTemplateTree.class);\n-                break;\n-\n","filename":"test\/langtools\/tools\/javac\/tree\/TreeKindTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-            public class Inner2 {\n+            public static class Inner2 {\n@@ -588,0 +588,118 @@\n+    \/\/ Verify 'this' escape correctly follows outer instances through member classes\n+    public static class ThisEscapeOuterRef1 {\n+        class Inner {\n+            void foo() {\n+                ThisEscapeOuterRef1.this.hashCode();\n+            }\n+        }\n+        public ThisEscapeOuterRef1() {\n+            new Inner().foo();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape correctly follows outer instances through local classes\n+    public static class ThisEscapeOuterRef2 {\n+        public ThisEscapeOuterRef2() {\n+            class Inner {\n+                void foo() {\n+                    ThisEscapeOuterRef2.this.hashCode();\n+                }\n+            }\n+            new Inner().foo();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape correctly follows outer instances through anonymous classes\n+    public static class ThisEscapeOuterRef3 {\n+        public ThisEscapeOuterRef3() {\n+            new Runnable() {\n+                public void run() {\n+                    ThisEscapeOuterRef3.this.hashCode();    \/\/ leak here\n+                }\n+            }.run();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape knows that enhanced for loops invoke iterator(), etc.\n+    public static class ThisEscapeForeach1 implements Iterable<Object> {\n+        public ThisEscapeForeach1() {\n+            for (Object v : this)\n+                v.hashCode();           \/\/ possible leak here\n+        }\n+        @Override\n+        public final java.util.Iterator<Object> iterator() {\n+            return new java.util.Iterator<Object>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return true;\n+                }\n+                @Override\n+                public Object next() {\n+                    return ThisEscapeForeach1.this;\n+                }\n+            };\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape tracks deferred return values\n+    public static class DeferredReturn {\n+\n+        public DeferredReturn(int x) {\n+            ((Supplier<DeferredReturn>)this::self).get().mightLeak();  \/\/ leak here\n+        }\n+\n+        public DeferredReturn(float x) {\n+            ((Supplier<DeferredReturn>)() -> this).get().mightLeak();  \/\/ leak here\n+        }\n+\n+        private final DeferredReturn self() {\n+            return this;\n+        }\n+\n+        protected void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape properly tracks variable types\n+    public static class TypeTracking {\n+\n+        public TypeTracking() {\n+            Runnable r = new Runnable() {\n+                public void run() {\n+                    TypeTracking.this.mightLeak();\n+                }\n+            };\n+            r.run();        \/\/ leak here - we know \"r\" has type TypeTracking$1\n+        }\n+\n+        protected void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape doesn't warn for outer instances of anonymous classes that don't use them\n+    public static class ThisEscapeOuterRef4 {\n+        public ThisEscapeOuterRef4() {\n+            new Runnable() {\n+                public void run() {\n+                    \/\/ there is no leak in here\n+                }\n+            }.run();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape doesn't warn for doubly-outer instance references\n+    public static class ThisEscapeDoubleOuter {\n+        public class Inner1 {\n+\n+            public Inner1() {\n+                new Inner2().foo();     \/\/ NOT a 'this' leak\n+            }\n+\n+            class Inner2 {\n+                void foo() {\n+                    ThisEscapeDoubleOuter.this.hashCode();\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.java","additions":119,"deletions":1,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,1 +26,13 @@\n-25 warnings\n+ThisEscape.java:596:28: compiler.warn.possible.this.escape\n+ThisEscape.java:592:50: compiler.warn.possible.this.escape.location\n+ThisEscape.java:608:28: compiler.warn.possible.this.escape\n+ThisEscape.java:605:54: compiler.warn.possible.this.escape.location\n+ThisEscape.java:619:18: compiler.warn.possible.this.escape\n+ThisEscape.java:617:54: compiler.warn.possible.this.escape.location\n+ThisEscape.java:627:27: compiler.warn.possible.this.escape\n+ThisEscape.java:648:55: compiler.warn.possible.this.escape\n+ThisEscape.java:652:55: compiler.warn.possible.this.escape\n+ThisEscape.java:672:18: compiler.warn.possible.this.escape\n+ThisEscape.java:669:48: compiler.warn.possible.this.escape.location\n+ThisEscape.java:726:32: compiler.warn.possible.this.escape\n+37 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.out","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-                                \"java.base\/jdk.internal.javac\",\n","filename":"test\/langtools\/tools\/jdeps\/listdeps\/ListModuleDeps.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,2 +68,0 @@\n-    public static final String SafepointCleanup = PREFIX + \"SafepointCleanup\";\n-    public static final String SafepointCleanupTask = PREFIX + \"SafepointCleanupTask\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-\n+void sleep_ms(int millis);\n@@ -383,0 +383,18 @@\n+\/\/ Wait for target thread to reach the required JVMTI thread state.\n+\/\/ The state jint bitmask is returned by the JVMTI GetThreadState.\n+\/\/ Some examples are:\n+\/\/ - JVMTI_THREAD_STATE_WAITING\n+\/\/ - JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\n+\/\/ - JVMTI_THREAD_STATE_SLEEPING\n+static void\n+wait_for_state(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jint exp_state) {\n+  while (true) {\n+    \/\/ Allow a bitmask to designate expected thread state. E.g., if two bits are expected\n+    \/\/ than check they both are present in the state mask returned by JVMTI GetThreadState.\n+    if ((get_thread_state(jvmti, jni, thread) & exp_state) == exp_state) {\n+      break;\n+    }\n+    sleep_ms(100);\n+  }\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+include CopyFiles.gmk\n","filename":"test\/make\/TestCopyFiles.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.util.FormatProcessor.FMT;\n-\n-\/*\n- * This benchmark measures StringTemplate.FMT FormatProcessor performance;\n- * exactly mirroring {@link org.openjdk.bench.java.lang.StringFormat} benchmark\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n-public class StringTemplateFMT {\n-\n-    public String s = \"str\";\n-    public int i = 17;\n-\n-    @Benchmark\n-    public String stringFormat() {\n-        return FMT.\"%s\\{s}\";\n-    }\n-\n-    @Benchmark\n-    public String stringIntFormat() {\n-        return FMT.\"%s\\{s} %d\\{i}\";\n-    }\n-\n-    @Benchmark\n-    public String widthStringFormat() {\n-        return FMT.\"%3s\\{s}\";\n-    }\n-\n-    @Benchmark\n-    public String widthStringIntFormat() {\n-        return FMT.\"%3s\\{s} %d\\{i}\";\n-    }\n-\n-    @Benchmark\n-    public String complexFormat() {\n-        return FMT.\"%3s\\{s} %10d\\{i} %4S\\{s} %04X\\{i} %4S\\{s} %04X\\{i} %4S\\{s} %04X\\{i}\";\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringTemplateFMT.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -91,1 +91,1 @@\n-                        Linker.nativeLinker().defaultLookup().find(\"calloc\").get(),\n+                        Linker.nativeLinker().defaultLookup().findOrThrow(\"calloc\"),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    private static Linker LINKER = Linker.nativeLinker();\n+    private static final Linker LINKER = Linker.nativeLinker();\n@@ -76,1 +76,1 @@\n-            LINKER.defaultLookup().find(\"free\").get(), FunctionDescriptor.ofVoid(C_POINTER));\n+            LINKER.defaultLookup().findOrThrow(\"free\"), FunctionDescriptor.ofVoid(C_POINTER));\n@@ -79,1 +79,1 @@\n-            LINKER.defaultLookup().find(\"malloc\").get(), FunctionDescriptor.of(C_POINTER, ValueLayout.JAVA_LONG));\n+            LINKER.defaultLookup().findOrThrow(\"malloc\"), FunctionDescriptor.of(C_POINTER, ValueLayout.JAVA_LONG));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-            func_addr = loaderLibs.find(\"func\").orElseThrow();\n+            func_addr = loaderLibs.findOrThrow(\"func\");\n@@ -121,1 +121,1 @@\n-            identity_addr = loaderLibs.find(\"identity\").orElseThrow();\n+            identity_addr = loaderLibs.findOrThrow(\"identity\");\n@@ -128,1 +128,1 @@\n-        identity_struct_addr = loaderLibs.find(\"identity_struct\").orElseThrow();\n+        identity_struct_addr = loaderLibs.findOrThrow(\"identity_struct\");\n@@ -133,1 +133,1 @@\n-        identity_struct_3_addr = loaderLibs.find(\"identity_struct_3\").orElseThrow();\n+        identity_struct_3_addr = loaderLibs.findOrThrow(\"identity_struct_3\");\n@@ -138,1 +138,1 @@\n-        identity_memory_address_addr = loaderLibs.find(\"identity_memory_address\").orElseThrow();\n+        identity_memory_address_addr = loaderLibs.findOrThrow(\"identity_memory_address\");\n@@ -143,1 +143,1 @@\n-        identity_memory_address_3_addr = loaderLibs.find(\"identity_memory_address_3\").orElseThrow();\n+        identity_memory_address_3_addr = loaderLibs.findOrThrow(\"identity_memory_address_3\");\n@@ -148,1 +148,1 @@\n-        args1_addr = loaderLibs.find(\"args1\").orElseThrow();\n+        args1_addr = loaderLibs.findOrThrow(\"args1\");\n@@ -153,1 +153,1 @@\n-        args2_addr = loaderLibs.find(\"args2\").orElseThrow();\n+        args2_addr = loaderLibs.findOrThrow(\"args2\");\n@@ -158,1 +158,1 @@\n-        args3_addr = loaderLibs.find(\"args3\").orElseThrow();\n+        args3_addr = loaderLibs.findOrThrow(\"args3\");\n@@ -163,1 +163,1 @@\n-        args4_addr = loaderLibs.find(\"args4\").orElseThrow();\n+        args4_addr = loaderLibs.findOrThrow(\"args4\");\n@@ -168,1 +168,1 @@\n-        args5_addr = loaderLibs.find(\"args5\").orElseThrow();\n+        args5_addr = loaderLibs.findOrThrow(\"args5\");\n@@ -173,1 +173,1 @@\n-        args10_addr = loaderLibs.find(\"args10\").orElseThrow();\n+        args10_addr = loaderLibs.findOrThrow(\"args10\");\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        MemorySegment sumIntsSym = lookup.find(\"sum_ints\").get();\n+        MemorySegment sumIntsSym = lookup.findOrThrow(\"sum_ints\");\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CriticalCalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ package org.openjdk.bench.java.lang.foreign;\n+\n+import sun.misc.Unsafe;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n+public class MemorySegmentZeroUnsafe {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+    long src;\n+\n+    @Param({\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"15\", \"16\", \"63\", \"64\", \"255\", \"256\"})\n+    public int size;\n+\n+    @Param({\"true\", \"false\"})\n+    public boolean aligned;\n+\n+    private MemorySegment segment;\n+    private long address;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        Arena arena = Arena.global();\n+        long alignment = 1;\n+        \/\/ this complex logic is to ensure that if in the future we decide to batch writes with different\n+        \/\/ batches based on alignment, we would spot it here\n+        if (size == 2 || size == 3) {\n+            alignment = 2;\n+        } else if (size >= 4 && size <= 7) {\n+            alignment = 4;\n+        } else {\n+            alignment = 8;\n+        }\n+        if (aligned) {\n+            segment = arena.allocate(size, alignment);\n+        } else {\n+            \/\/ forcibly misaligned in both address AND size, given that would be the worst case\n+            segment = arena.allocate(size + 1, alignment).asSlice(1);\n+        }\n+        address = segment.address();\n+    }\n+\n+    @Benchmark\n+    public void panama() {\n+        segment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void unsafe() {\n+        UNSAFE.setMemory(address, size, (byte) 0);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentZeroUnsafe.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -61,1 +61,1 @@\n-        F_LONG_LONG = abi.downcallHandle(loaderLibs.find(\"id_long_long\").get(),\n+        F_LONG_LONG = abi.downcallHandle(loaderLibs.findOrThrow(\"id_long_long\"),\n@@ -63,1 +63,1 @@\n-        F_PTR_LONG = abi.downcallHandle(loaderLibs.find(\"id_ptr_long\").get(),\n+        F_PTR_LONG = abi.downcallHandle(loaderLibs.findOrThrow(\"id_ptr_long\"),\n@@ -65,1 +65,1 @@\n-        F_LONG_PTR = abi.downcallHandle(loaderLibs.find(\"id_long_ptr\").get(),\n+        F_LONG_PTR = abi.downcallHandle(loaderLibs.findOrThrow(\"id_long_ptr\"),\n@@ -67,1 +67,1 @@\n-        F_PTR_PTR = abi.downcallHandle(loaderLibs.find(\"id_ptr_ptr\").get(),\n+        F_PTR_PTR = abi.downcallHandle(loaderLibs.findOrThrow(\"id_ptr_ptr\"),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    static MemorySegment qsort_addr = abi.defaultLookup().find(\"qsort\").get();\n+    static MemorySegment qsort_addr = abi.defaultLookup().findOrThrow(\"qsort\");\n@@ -77,1 +77,1 @@\n-            native_compar = SymbolLookup.loaderLookup().find(\"compar\").orElseThrow();\n+            native_compar = SymbolLookup.loaderLookup().findOrThrow(\"compar\");\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        STRLEN = abi.downcallHandle(abi.defaultLookup().find(\"strlen\").get(),\n+        STRLEN = abi.downcallHandle(abi.defaultLookup().findOrThrow(\"strlen\"),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        STRLEN = abi.downcallHandle(abi.defaultLookup().find(\"strlen\").get(),\n+        STRLEN = abi.downcallHandle(abi.defaultLookup().findOrThrow(\"strlen\"),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToCStringTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-                SymbolLookup.loaderLookup().find(name).orElseThrow(),\n+                SymbolLookup.loaderLookup().findOrThrow(name),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-                loaderLibs.find(\"distance\").get(),\n+                loaderLibs.findOrThrow(\"distance\"),\n@@ -55,1 +55,1 @@\n-                loaderLibs.find(\"distance_ptrs\").get(),\n+                loaderLibs.findOrThrow(\"distance_ptrs\"),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(true));\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().findOrThrow(\"xor_op\"), xor_op_func, critical(true));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpCriticalImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n-        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(false));\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().findOrThrow(\"xor_op\"), xor_op_func, critical(false));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(false));\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().findOrThrow(\"xor_op\"), xor_op_func, critical(false));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpInitImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(false));\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().findOrThrow(\"xor_op\"), xor_op_func, critical(false));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayUnsafeXorOpImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops;\n+\n+public class DoubleAccumulator {\n+\n+    double acc;\n+\n+    public DoubleAccumulator() {\n+        acc = 0;\n+    }\n+\n+    public void add(double v) {\n+        acc += v;\n+    }\n+\n+    public void merge(DoubleAccumulator other) {\n+        acc += other.acc;\n+    }\n+\n+    public double get() {\n+        return acc;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/DoubleAccumulator.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.DoubleAccumulator;\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.LongFunction;\n+import java.util.function.DoubleFunction;\n+import java.util.stream.Stream;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.IntStream;\n+import java.util.Arrays;\n+\n+\/**\n+ * Benchmark for flatMap() operation.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class FlatMap {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *   - the result of applying consecutive operations is the same, in order to have the same number of elements in sink\n+     *\/\n+\n+    @Param({\"10\", \"100\", \"1000\"})\n+    private int size;\n+\n+    private Function<Long, Stream<Long>> funArrayStream;\n+    private Function<Long, Stream<Long>> funIterateStream;\n+    private LongFunction<LongStream> funLongStream;\n+    private LongFunction<LongStream> funIterateLongStream;\n+    private IntFunction<IntStream> funIntStream;\n+    private IntFunction<IntStream> funIterateIntStream;\n+    private DoubleFunction<DoubleStream> funDoubleStream;\n+    private DoubleFunction<DoubleStream> funIterateDoubleStream;\n+\n+    private Long[] cachedRefArray;\n+    private int[] cachedIntArray;\n+    private long[] cachedLongArray;\n+    private double[] cachedDoubleArray;\n+\n+    @Setup\n+    public void setup() {\n+        final int cachedSize = size;\n+        cachedRefArray = new Long[cachedSize];\n+        cachedIntArray = new int[cachedSize];\n+        cachedLongArray = new long[cachedSize];\n+        cachedDoubleArray = new double[cachedSize];\n+        for(int i = 0;i < cachedRefArray.length;++i) {\n+            cachedRefArray[i]    = Long.valueOf(i);\n+            cachedIntArray[i]    = i;\n+            cachedLongArray[i]   = i;\n+            cachedDoubleArray[i] = i;\n+        }\n+\n+        funArrayStream = new Function<Long, Stream<Long>>() { @Override public Stream<Long> apply(Long l) {\n+            return Arrays.stream(cachedRefArray);\n+        } };\n+        funIterateStream = new Function<Long, Stream<Long>>() { @Override public Stream<Long> apply(Long l) {\n+            return Stream.iterate(0L, i -> i + 1).limit(cachedSize); } };\n+        funLongStream = new LongFunction<LongStream>() { @Override public LongStream apply(long l) {\n+            return Arrays.stream(cachedLongArray); } };\n+        funIterateLongStream = new LongFunction<LongStream>() { @Override public LongStream apply(long l) {\n+            return LongStream.iterate(0L, i -> i + 1).limit(cachedSize); } };\n+        funIntStream = new IntFunction<IntStream>() { @Override public IntStream apply(int i) {\n+            return Arrays.stream(cachedIntArray); } };\n+        funIterateIntStream = new IntFunction<IntStream>() { @Override public IntStream apply(int i) {\n+            return IntStream.iterate(0, ii -> ii + 1).limit(cachedSize); } };\n+        funDoubleStream = new DoubleFunction<DoubleStream>() { @Override public DoubleStream apply(double d) {\n+            return Arrays.stream(cachedDoubleArray); } };\n+        funIterateDoubleStream = new DoubleFunction<DoubleStream>() { @Override public DoubleStream apply(double d) {\n+            return DoubleStream.iterate(0d, i -> i + 1d).limit(cachedSize); } };\n+    }\n+\n+    @Benchmark\n+    public long seq_array_ref() {\n+        return funArrayStream.apply(0L)\n+                .flatMap(funArrayStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_array_ref() {\n+        return funArrayStream.apply(0L)\n+                .parallel()\n+                .flatMap(funArrayStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_array_long() {\n+        return funLongStream.apply(0L)\n+                .flatMap(funLongStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_array_long() {\n+        return funLongStream.apply(0L)\n+                .parallel()\n+                .flatMap(funLongStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_array_int() {\n+        return funIntStream.apply(0)\n+                .flatMap(funIntStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_array_int() {\n+        return funIntStream.apply(0)\n+                .parallel()\n+                .flatMap(funIntStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public double seq_array_double() {\n+        return funDoubleStream.apply(0d)\n+                .flatMap(funDoubleStream)\n+                .collect(DoubleAccumulator::new, DoubleAccumulator::add, DoubleAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public double par_array_double() {\n+        return funDoubleStream.apply(0d)\n+                .parallel()\n+                .flatMap(funDoubleStream)\n+                .collect(DoubleAccumulator::new, DoubleAccumulator::add, DoubleAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_iterate_ref() {\n+        return funIterateStream.apply(0L)\n+                .flatMap(funIterateStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_iterate_ref() {\n+        return funIterateStream.apply(0L)\n+                .parallel()\n+                .flatMap(funIterateStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+\n+    @Benchmark\n+    public long seq_iterate_long() {\n+        return funIterateLongStream.apply(0L)\n+                .flatMap(funIterateLongStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_iterate_long() {\n+        return funIterateLongStream.apply(0L)\n+                .parallel()\n+                .flatMap(funIterateLongStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_iterate_int() {\n+        return funIterateIntStream.apply(0)\n+                .flatMap(funIterateIntStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_iterate_int() {\n+        return funIterateIntStream.apply(0)\n+                .parallel()\n+                .flatMap(funIterateIntStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public double seq_iterate_double() {\n+        return funIterateDoubleStream.apply(0d)\n+                .flatMap(funIterateDoubleStream)\n+                .collect(DoubleAccumulator::new, DoubleAccumulator::add, DoubleAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public double par_iterate_double() {\n+        return funIterateDoubleStream.apply(0d)\n+                .parallel()\n+                .flatMap(funIterateDoubleStream)\n+                .collect(DoubleAccumulator::new, DoubleAccumulator::add, DoubleAccumulator::merge).get();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/FlatMap.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -125,0 +125,1 @@\n+                d.thisClass(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/CodeAttributeTools.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.*;\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class GatherOperationsBenchmark {\n+    @Param({\"64\", \"256\", \"1024\", \"4096\"})\n+    int SIZE;\n+    byte  [] barr;\n+    byte  [] bres;\n+    short [] sarr;\n+    short [] sres;\n+    int   [] index;\n+\n+    static final VectorSpecies<Short> S64 = ShortVector.SPECIES_64;\n+    static final VectorSpecies<Short> S128 = ShortVector.SPECIES_128;\n+    static final VectorSpecies<Short> S256 = ShortVector.SPECIES_256;\n+    static final VectorSpecies<Short> S512 = ShortVector.SPECIES_512;\n+    static final VectorSpecies<Byte> B64 = ByteVector.SPECIES_64;\n+    static final VectorSpecies<Byte> B128 = ByteVector.SPECIES_128;\n+    static final VectorSpecies<Byte> B256 = ByteVector.SPECIES_256;\n+    static final VectorSpecies<Byte> B512 = ByteVector.SPECIES_512;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1245);\n+        index = new int[SIZE];\n+        barr = new byte[SIZE];\n+        bres = new byte[SIZE];\n+        sarr = new short[SIZE];\n+        sres = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+           barr[i] = (byte)i;\n+           sarr[i] = (short)i;\n+           index[i] = r.nextInt(SIZE-1);\n+        }\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void microByteGather64() {\n+        for (int i = 0; i < SIZE; i += B64.length()) {\n+            ByteVector.fromArray(B64, barr, 0, index, i)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microByteGather64_NZ_OFF() {\n+        for (int i = 0; i < SIZE; i += B64.length()) {\n+            ByteVector.fromArray(B64, barr, 1, index, i)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microByteGather64_MASK() {\n+        VectorMask<Byte> VMASK = VectorMask.fromLong(B64, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += B64.length()) {\n+            ByteVector.fromArray(B64, barr, 0, index, i, VMASK)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microByteGather64_MASK_NZ_OFF() {\n+        VectorMask<Byte> VMASK = VectorMask.fromLong(B64, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += B64.length()) {\n+            ByteVector.fromArray(B64, barr, 1, index, i, VMASK)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microByteGather128() {\n+        for (int i = 0; i < SIZE; i += B128.length()) {\n+            ByteVector.fromArray(B128, barr, 0, index, i)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microByteGather128_NZ_OFF() {\n+        for (int i = 0; i < SIZE; i += B128.length()) {\n+            ByteVector.fromArray(B128, barr, 1, index, i)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microByteGather128_MASK() {\n+        VectorMask<Byte> VMASK = VectorMask.fromLong(B128, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += B128.length()) {\n+            ByteVector.fromArray(B128, barr, 0, index, i, VMASK)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microByteGather128_MASK_NZ_OFF() {\n+        VectorMask<Byte> VMASK = VectorMask.fromLong(B128, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += B128.length()) {\n+            ByteVector.fromArray(B128, barr, 1, index, i, VMASK)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microByteGather256() {\n+        for (int i = 0; i < SIZE; i += B256.length()) {\n+            ByteVector.fromArray(B256, barr, 0, index, i)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microByteGather256_NZ_OFF() {\n+        for (int i = 0; i < SIZE; i += B256.length()) {\n+            ByteVector.fromArray(B256, barr, 1, index, i)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microByteGather256_MASK() {\n+        VectorMask<Byte> VMASK = VectorMask.fromLong(B256, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += B256.length()) {\n+            ByteVector.fromArray(B256, barr, 0, index, i, VMASK)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microByteGather256_MASK_NZ_OFF() {\n+        VectorMask<Byte> VMASK = VectorMask.fromLong(B256, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += B256.length()) {\n+            ByteVector.fromArray(B256, barr, 1, index, i, VMASK)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microByteGather512() {\n+        for (int i = 0; i < SIZE; i += B512.length()) {\n+            ByteVector.fromArray(B512, barr, 0, index, i)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microByteGather512_NZ_OFF() {\n+        for (int i = 0; i < SIZE; i += B512.length()) {\n+            ByteVector.fromArray(B512, barr, 1, index, i)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microByteGather512_MASK() {\n+        VectorMask<Byte> VMASK = VectorMask.fromLong(B512, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += B512.length()) {\n+            ByteVector.fromArray(B512, barr, 0, index, i, VMASK)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microByteGather512_MASK_NZ_OFF() {\n+        VectorMask<Byte> VMASK = VectorMask.fromLong(B512, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += B512.length()) {\n+            ByteVector.fromArray(B512, barr, 1, index, i, VMASK)\n+                            .intoArray(bres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microShortGather64() {\n+        for (int i = 0; i < SIZE; i += S64.length()) {\n+            ShortVector.fromArray(S64, sarr, 0, index, i)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microShortGather64_NZ_OFF() {\n+        for (int i = 0; i < SIZE; i += S64.length()) {\n+            ShortVector.fromArray(S64, sarr, 1, index, i)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microShortGather64_MASK() {\n+        VectorMask<Short> VMASK = VectorMask.fromLong(S64, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += S64.length()) {\n+            ShortVector.fromArray(S64, sarr, 0, index, i, VMASK)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microShortGather64_MASK_NZ_OFF() {\n+        VectorMask<Short> VMASK = VectorMask.fromLong(S64, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += S64.length()) {\n+            ShortVector.fromArray(S64, sarr, 1, index, i, VMASK)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microShortGather128() {\n+        for (int i = 0; i < SIZE; i += S128.length()) {\n+            ShortVector.fromArray(S128, sarr, 0, index, i)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microShortGather128_NZ_OFF() {\n+        for (int i = 0; i < SIZE; i += S128.length()) {\n+            ShortVector.fromArray(S128, sarr, 1, index, i)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microShortGather128_MASK() {\n+        VectorMask<Short> VMASK = VectorMask.fromLong(S128, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += S128.length()) {\n+            ShortVector.fromArray(S128, sarr, 0, index, i, VMASK)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microShortGather128_MASK_NZ_OFF() {\n+        VectorMask<Short> VMASK = VectorMask.fromLong(S128, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += S128.length()) {\n+            ShortVector.fromArray(S128, sarr, 1, index, i, VMASK)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microShortGather256() {\n+        for (int i = 0; i < SIZE; i += S256.length()) {\n+            ShortVector.fromArray(S256, sarr, 0, index, i)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microShortGather256_NZ_OFF() {\n+        for (int i = 0; i < SIZE; i += S256.length()) {\n+            ShortVector.fromArray(S256, sarr, 1, index, i)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microShortGather256_MASK() {\n+        VectorMask<Short> VMASK = VectorMask.fromLong(S256, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += S256.length()) {\n+            ShortVector.fromArray(S256, sarr, 0, index, i, VMASK)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microShortGather256_MASK_NZ_OFF() {\n+        VectorMask<Short> VMASK = VectorMask.fromLong(S256, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += S256.length()) {\n+            ShortVector.fromArray(S256, sarr, 1, index, i, VMASK)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microShortGather512() {\n+        for (int i = 0; i < SIZE; i += S512.length()) {\n+            ShortVector.fromArray(S512, sarr, 0, index, i)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microShortGather512_NZ_OFF() {\n+        for (int i = 0; i < SIZE; i += S512.length()) {\n+            ShortVector.fromArray(S512, sarr, 1, index, i)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microShortGather512_MASK() {\n+        VectorMask<Short> VMASK = VectorMask.fromLong(S512, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += S512.length()) {\n+            ShortVector.fromArray(S512, sarr, 0, index, i, VMASK)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microShortGather512_MASK_NZ_OFF() {\n+        VectorMask<Short> VMASK = VectorMask.fromLong(S512, 0x5555555555555555L);\n+        for (int i = 0; i < SIZE; i += S512.length()) {\n+            ShortVector.fromArray(S512, sarr, 1, index, i, VMASK)\n+                            .intoArray(sres, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/GatherOperationsBenchmark.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-Xms512m\", \"-Xmx512m\", \"-XX:+AlwaysPreTouch\", \"-XX:+UseParallelGC\"})\n+public class ConstructorBarriers {\n+\n+    \/\/ Checks the barrier coalescing\/optimization around field initializations.\n+    \/\/ Uses long fields to avoid store merging.\n+\n+    public static class PlainPlain {\n+        long f1;\n+        long f2;\n+        public PlainPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalPlain {\n+        final long f1;\n+        long f2;\n+        public FinalPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainFinal {\n+        long f1;\n+        final long f2;\n+        public PlainFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalFinal {\n+        final long f1;\n+        final long f2;\n+        public FinalFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainVolatile {\n+        long f1;\n+        volatile long f2;\n+        public PlainVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatilePlain {\n+        volatile long f1;\n+        long f2;\n+        public VolatilePlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalVolatile {\n+        final long f1;\n+        volatile long f2;\n+        public FinalVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileFinal {\n+        volatile long f1;\n+        final long f2;\n+        public VolatileFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileVolatile {\n+        volatile long f1;\n+        volatile long f2;\n+        public VolatileVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    long l = 42;\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_plainPlain(Blackhole bh) {\n+        PlainPlain c = new PlainPlain(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_plainFinal(Blackhole bh) {\n+        PlainFinal c = new PlainFinal(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_finalPlain(Blackhole bh) {\n+        FinalPlain c = new FinalPlain(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_finalFinal(Blackhole bh) {\n+        FinalFinal c = new FinalFinal(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_plainVolatile(Blackhole bh) {\n+        PlainVolatile c = new PlainVolatile(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_volatilePlain(Blackhole bh) {\n+        VolatilePlain c = new VolatilePlain(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_volatileVolatile(Blackhole bh) {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_finalVolatile(Blackhole bh) {\n+        FinalVolatile c = new FinalVolatile(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_volatileFinal(Blackhole bh) {\n+        VolatileFinal c = new VolatileFinal(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_plainPlain() {\n+        PlainPlain c = new PlainPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_plainFinal() {\n+        PlainFinal c = new PlainFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_finalPlain() {\n+        FinalPlain c = new FinalPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_finalFinal() {\n+        FinalFinal c = new FinalFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_plainVolatile() {\n+        PlainVolatile c = new PlainVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_volatilePlain() {\n+        VolatilePlain c = new VolatilePlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_volatileVolatile() {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_finalVolatile() {\n+        FinalVolatile c = new FinalVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_volatileFinal() {\n+        VolatileFinal c = new VolatileFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ConstructorBarriers.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class IfMinMax {\n+    private static final int SIZE = 10_000;\n+\n+    @Benchmark\n+    public void testSingleInt(Blackhole blackhole, BenchState state) {\n+        int a = state.i1[state.random.nextInt(SIZE)];\n+        int b = state.i2[state.random.nextInt(SIZE)];\n+        blackhole.consume(a > b ? a : b);\n+    }\n+\n+    @Benchmark\n+    public void testVectorInt(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            state.i3[i] = state.i1[i] > state.i2[i] ? state.i1[i] : state.i2[i];\n+        }\n+\n+        blackhole.consume(state.i3);\n+    }\n+\n+    @Benchmark\n+    public void testReductionInt(Blackhole blackhole, BenchState state) {\n+        int a = 0;\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            if (state.i1[i] > a) {\n+                a = state.i1[i];\n+            }\n+        }\n+\n+        blackhole.consume(a);\n+    }\n+\n+    @Benchmark\n+    public void testSingleLong(Blackhole blackhole, BenchState state) {\n+        long a = state.l1[state.random.nextInt(SIZE)];\n+        long b = state.l2[state.random.nextInt(SIZE)];\n+        blackhole.consume(a > b ? a : b);\n+    }\n+\n+    @Benchmark\n+    public void testVectorLong(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            state.l3[i] = state.l1[i] > state.l2[i] ? state.l1[i] : state.l2[i];\n+        }\n+\n+        blackhole.consume(state.l3);\n+    }\n+\n+    @Benchmark\n+    public void testReductionLong(Blackhole blackhole, BenchState state) {\n+        long a = 0;\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            if (state.l1[i] > a) {\n+                a = state.l1[i];\n+            }\n+        }\n+\n+        blackhole.consume(a);\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        private final int[] i1 = new int[SIZE];\n+        private final int[] i2 = new int[SIZE];\n+        private final int[] i3 = new int[SIZE];\n+\n+        private final long[] l1 = new long[SIZE];\n+        private final long[] l2 = new long[SIZE];\n+        private final long[] l3 = new long[SIZE];\n+\n+        private Random random;\n+\n+        public BenchState() {\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            this.random = new Random(1000);\n+\n+            for (int i = 0; i < SIZE; i++) {\n+                i1[i] = this.random.nextInt();\n+                i2[i] = this.random.nextInt();\n+                i3[i] = this.random.nextInt();\n+\n+                l1[i] = this.random.nextLong();\n+                l2[i] = this.random.nextLong();\n+                l3[i] = this.random.nextLong();\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/IfMinMax.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,696 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 3, time = 3)\n+@Fork(value = 3, jvmArgsAppend = {\n+        \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.util=ALL-UNNAMED\"})\n+@State(Scope.Benchmark)\n+public class MergeStores {\n+\n+    public static final int RANGE = 100;\n+\n+    static Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    @Param(\"1\")\n+    public static short vS;\n+\n+    @Param(\"1\")\n+    public static int vI;\n+\n+    @Param(\"1\")\n+    public static long vL;\n+\n+    public static int offset = 5;\n+    public static byte[]  aB = new byte[RANGE];\n+    public static short[] aS = new short[RANGE];\n+    public static int[]   aI = new int[RANGE];\n+\n+    \/\/ -------------------------------------------\n+    \/\/ -------     Little-Endian API    ----------\n+    \/\/ -------------------------------------------\n+\n+    \/\/ Store a short LE into an array using store bytes in an array\n+    static void storeShortLE(byte[] bytes, int offset, short value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0),\n+                                  (byte)(value >> 8));\n+    }\n+\n+    \/\/ Store an int LE into an array using store bytes in an array\n+    static void storeIntLE(byte[] bytes, int offset, int value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0 ),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 24));\n+    }\n+\n+    \/\/ Store an int LE into an array using store bytes in an array\n+    static void storeLongLE(byte[] bytes, int offset, long value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0 ),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 24),\n+                                  (byte)(value >> 32),\n+                                  (byte)(value >> 40),\n+                                  (byte)(value >> 48),\n+                                  (byte)(value >> 56));\n+    }\n+\n+    \/\/ Store 2 bytes into an array\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+    }\n+\n+    \/\/ Store 4 bytes into an array\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1, byte b2, byte b3) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+        bytes[offset + 2] = b2;\n+        bytes[offset + 3] = b3;\n+    }\n+\n+    \/\/ Store 8 bytes into an array\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1, byte b2, byte b3,\n+                                                     byte b4, byte b5, byte b6, byte b7) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+        bytes[offset + 2] = b2;\n+        bytes[offset + 3] = b3;\n+        bytes[offset + 4] = b4;\n+        bytes[offset + 5] = b5;\n+        bytes[offset + 6] = b6;\n+        bytes[offset + 7] = b7;\n+    }\n+\n+    \/\/ -------------------------------- BENCHMARKS --------------------------------\n+\n+    @Benchmark\n+    public void baseline() {\n+    }\n+\n+    @Benchmark\n+    public byte[] baseline_allocate() {\n+        byte[] aB = new byte[RANGE];\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_adr0_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[0] = (byte)0x01;\n+        aB[1] = (byte)0x02;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_adr1_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[1] = (byte)0x01;\n+        aB[2] = (byte)0x02;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putShortUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setShort(aB, offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeShortLE(aB, offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_nonalloc_unsafe() {\n+        UNSAFE.putShortUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setShort(aB, offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_nonalloc_leapi() {\n+        storeShortLE(aB, offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)(vS >> 0 );\n+        aB[offset + 1] = (byte)(vS >> 8 );\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putShortUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setShort(aB, offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeShortLE(aB, offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)(vS >> 0 );\n+        aB[offset + 1] = (byte)(vS >> 8 );\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_nonalloc_unsafe() {\n+        UNSAFE.putShortUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setShort(aB, offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_nonalloc_leapi() {\n+        storeShortLE(aB, offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_adr0_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[0] = (byte)0x01;\n+        aB[1] = (byte)0x02;\n+        aB[2] = (byte)0x03;\n+        aB[3] = (byte)0x04;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_adr1_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[1] = (byte)0x01;\n+        aB[2] = (byte)0x02;\n+        aB[3] = (byte)0x03;\n+        aB[4] = (byte)0x04;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        aB[offset + 2] = (byte)0x03;\n+        aB[offset + 3] = (byte)0x04;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putIntUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setInt(aB, offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeIntLE(aB, offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        aB[offset + 2] = (byte)0x03;\n+        aB[offset + 3] = (byte)0x04;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_nonalloc_unsafe() {\n+        UNSAFE.putIntUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setInt(aB, offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_nonalloc_leapi() {\n+        storeIntLE(aB, offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)(vI >> 0 );\n+        aB[offset + 1] = (byte)(vI >> 8 );\n+        aB[offset + 2] = (byte)(vI >> 16);\n+        aB[offset + 3] = (byte)(vI >> 24);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putIntUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setInt(aB, offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeIntLE(aB, offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)(vI >> 0 );\n+        aB[offset + 1] = (byte)(vI >> 8 );\n+        aB[offset + 2] = (byte)(vI >> 16);\n+        aB[offset + 3] = (byte)(vI >> 24);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_nonalloc_unsafe() {\n+        UNSAFE.putIntUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setInt(aB, offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_nonalloc_leapi() {\n+        storeIntLE(aB, offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_adr0_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[0] = (byte)0x01;\n+        aB[1] = (byte)0x02;\n+        aB[2] = (byte)0x03;\n+        aB[3] = (byte)0x04;\n+        aB[4] = (byte)0x05;\n+        aB[5] = (byte)0x06;\n+        aB[6] = (byte)0x07;\n+        aB[7] = (byte)0x08;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_adr1_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[1] = (byte)0x01;\n+        aB[2] = (byte)0x02;\n+        aB[3] = (byte)0x03;\n+        aB[4] = (byte)0x04;\n+        aB[5] = (byte)0x05;\n+        aB[6] = (byte)0x06;\n+        aB[7] = (byte)0x07;\n+        aB[8] = (byte)0x08;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        aB[offset + 2] = (byte)0x03;\n+        aB[offset + 3] = (byte)0x04;\n+        aB[offset + 4] = (byte)0x05;\n+        aB[offset + 5] = (byte)0x06;\n+        aB[offset + 6] = (byte)0x07;\n+        aB[offset + 7] = (byte)0x08;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setLong(aB, offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeLongLE(aB, offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        aB[offset + 2] = (byte)0x03;\n+        aB[offset + 3] = (byte)0x04;\n+        aB[offset + 4] = (byte)0x05;\n+        aB[offset + 5] = (byte)0x06;\n+        aB[offset + 6] = (byte)0x07;\n+        aB[offset + 7] = (byte)0x08;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_nonalloc_unsafe() {\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setLong(aB, offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_nonalloc_leapi() {\n+        storeLongLE(aB, offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)(vL >> 0 );\n+        aB[offset + 1] = (byte)(vL >> 8 );\n+        aB[offset + 2] = (byte)(vL >> 16);\n+        aB[offset + 3] = (byte)(vL >> 24);\n+        aB[offset + 4] = (byte)(vL >> 32);\n+        aB[offset + 5] = (byte)(vL >> 40);\n+        aB[offset + 6] = (byte)(vL >> 48);\n+        aB[offset + 7] = (byte)(vL >> 56);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setLong(aB, offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeLongLE(aB, offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)(vL >> 0 );\n+        aB[offset + 1] = (byte)(vL >> 8 );\n+        aB[offset + 2] = (byte)(vL >> 16);\n+        aB[offset + 3] = (byte)(vL >> 24);\n+        aB[offset + 4] = (byte)(vL >> 32);\n+        aB[offset + 5] = (byte)(vL >> 40);\n+        aB[offset + 6] = (byte)(vL >> 48);\n+        aB[offset + 7] = (byte)(vL >> 56);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_nonalloc_unsafe() {\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setLong(aB, offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_nonalloc_leapi() {\n+        storeLongLE(aB, offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)(vI >> 0 );\n+        aB[offset + 1] = (byte)(vI >> 8 );\n+        aB[offset + 2] = (byte)(vI >> 16);\n+        aB[offset + 3] = (byte)(vI >> 24);\n+        aB[offset + 4] = (byte)(vI >> 0 );\n+        aB[offset + 5] = (byte)(vI >> 8 );\n+        aB[offset + 6] = (byte)(vI >> 16);\n+        aB[offset + 7] = (byte)(vI >> 24);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset + 0, vI);\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setInt(aB, offset + 0, vI);\n+        ByteArrayLittleEndian.setInt(aB, offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeIntLE(aB, offset + 0, vI);\n+        storeIntLE(aB, offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)(vI >> 0 );\n+        aB[offset + 1] = (byte)(vI >> 8 );\n+        aB[offset + 2] = (byte)(vI >> 16);\n+        aB[offset + 3] = (byte)(vI >> 24);\n+        aB[offset + 4] = (byte)(vI >> 0 );\n+        aB[offset + 5] = (byte)(vI >> 8 );\n+        aB[offset + 6] = (byte)(vI >> 16);\n+        aB[offset + 7] = (byte)(vI >> 24);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_nonalloc_unsafe() {\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset + 0, vI);\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setInt(aB, offset + 0, vI);\n+        ByteArrayLittleEndian.setInt(aB, offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_nonalloc_leapi() {\n+        storeIntLE(aB, offset + 0, vI);\n+        storeIntLE(aB, offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public short[] store_S2_con_offs_allocate_direct() {\n+        short[] aS = new short[RANGE];\n+        aS[offset + 0] = (short)0x0102;\n+        aS[offset + 1] = (short)0x0304;\n+        return aS;\n+    }\n+\n+    @Benchmark\n+    public short[] store_S2_con_offs_nonalloc_direct() {\n+        aS[offset + 0] = (short)0x0102;\n+        aS[offset + 1] = (short)0x0304;\n+        return aS;\n+    }\n+\n+    @Benchmark\n+    public short[] store_S4_con_offs_allocate_direct() {\n+        short[] aS = new short[RANGE];\n+        aS[offset + 0] = (short)0x0102;\n+        aS[offset + 1] = (short)0x0304;\n+        aS[offset + 2] = (short)0x0506;\n+        aS[offset + 3] = (short)0x0708;\n+        return aS;\n+    }\n+\n+    @Benchmark\n+    public short[] store_S4_con_offs_nonalloc_direct() {\n+        aS[offset + 0] = (short)0x0102;\n+        aS[offset + 1] = (short)0x0304;\n+        aS[offset + 2] = (short)0x0506;\n+        aS[offset + 3] = (short)0x0708;\n+        return aS;\n+    }\n+\n+    @Benchmark\n+    public int[] store_I2_con_offs_allocate_direct() {\n+        int[] aI = new int[RANGE];\n+        aI[offset + 0] = 0x01020304;\n+        aI[offset + 1] = 0x05060708;\n+        return aI;\n+    }\n+\n+    @Benchmark\n+    public int[] store_I2_con_offs_nonalloc_direct() {\n+        aI[offset + 0] = 0x01020304;\n+        aI[offset + 1] = 0x05060708;\n+        return aI;\n+    }\n+\n+    @Benchmark\n+    public int[] store_I2_zero_offs_allocate_direct() {\n+        int[] aI = new int[RANGE];\n+        aI[offset + 0] = 0;\n+        aI[offset + 1] = 0;\n+        return aI;\n+    }\n+\n+    @Benchmark\n+    public int[] store_I2_zero_offs_nonalloc_direct() {\n+        aI[offset + 0] = 0;\n+        aI[offset + 1] = 0;\n+        return aI;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MergeStores.java","additions":696,"deletions":0,"binary":false,"changes":696,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(1)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCacheHits {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    \/\/ The test verifies what happens on a happy path, when we can actually cache\n+    \/\/ the last super and use it effectively.\n+\n+    interface I01 {}\n+    interface I02 {}\n+    interface I03 {}\n+    interface I04 {}\n+    interface I05 {}\n+    interface I06 {}\n+    interface I07 {}\n+    interface I08 {}\n+    interface I09 {}\n+    interface I10 {}\n+    interface I11 {}\n+    interface I12 {}\n+    interface I13 {}\n+    interface I14 {}\n+    interface I15 {}\n+    interface I16 {}\n+    interface I17 {}\n+    interface I18 {}\n+    interface I19 {}\n+    interface I20 {}\n+\n+    class B {}\n+    class C1 extends B implements I01, I02, I03, I04, I05, I06, I07, I08, I09, I10, I11, I12, I13, I14, I15, I16, I17, I18, I19, I20 {}\n+\n+    volatile B o;\n+\n+    @Setup\n+    public void setup() {\n+        o = new C1();\n+    }\n+\n+    static final int ITERS = 10000;\n+\n+    @Benchmark\n+    @OperationsPerInvocation(20*ITERS)\n+    public void test(Blackhole bh) {\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I01);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I02);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I03);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I04);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I05);\n+\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I06);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I07);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I08);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I09);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I10);\n+\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I11);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I12);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I13);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I14);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I15);\n+\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I16);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I17);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I18);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I19);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I20);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCacheHits.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(Threads.MAX)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCacheInterContention {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    \/\/ The test verifies what happens on unhappy path, when we contend a lot over\n+    \/\/ the secondary super cache, where different threads want to update the cache\n+    \/\/ with different value. In tihs test, every thread comes with its own stable\n+    \/\/ cached value. Meaning, this tests the INTER-thread contention.\n+\n+    interface IA {}\n+    interface IB {}\n+    class B {}\n+    class C1 extends B implements IA, IB {}\n+    class C2 extends B implements IA, IB {}\n+\n+    volatile B o1, o2;\n+\n+    @Setup\n+    public void setup() {\n+        o1 = new C1();\n+        o2 = new C2();\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(2)\n+    @Group(\"test\")\n+    @GroupThreads(1)\n+    public void t1(Blackhole bh) {\n+        bh.consume(o1 instanceof IA);\n+        bh.consume(o2 instanceof IA);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(2)\n+    @Group(\"test\")\n+    @GroupThreads(1)\n+    public void t2(Blackhole bh) {\n+        bh.consume(o1 instanceof IB);\n+        bh.consume(o2 instanceof IB);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCacheInterContention.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(Threads.MAX)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCacheIntraContention {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    \/\/ The test verifies what happens on unhappy path, when we contend a lot over\n+    \/\/ the secondary super cache, where different threads want to update the cache\n+    \/\/ with different value. In this test, every thread comes with its own contending\n+    \/\/ value. Meaning, this tests the INTRA-thread contention.\n+\n+    interface IA {}\n+    interface IB {}\n+    class B {}\n+    class C1 extends B implements IA, IB {}\n+    class C2 extends B implements IA, IB {}\n+\n+    volatile B o1, o2;\n+\n+    @Setup\n+    public void setup() {\n+        o1 = new C1();\n+        o2 = new C2();\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(4)\n+    public void test(Blackhole bh) {\n+        bh.consume(o1 instanceof IA);\n+        bh.consume(o2 instanceof IA);\n+        bh.consume(o1 instanceof IB);\n+        bh.consume(o2 instanceof IB);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCacheIntraContention.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,310 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 1, time = 1)\n+@Measurement(iterations = 3, time = 1)\n+@Fork(value = 5)\n+public class SecondarySupersLookup {\n+    interface J  {}\n+    interface I01 {}\n+    interface I02 extends I01 {}\n+    interface I03 extends I02 {}\n+    interface I04 extends I03 {}\n+    interface I05 extends I04 {}\n+    interface I06 extends I05 {}\n+    interface I07 extends I06 {}\n+    interface I08 extends I07 {}\n+    interface I09 extends I08 {}\n+    interface I10 extends I09 {}\n+    interface I11 extends I10 {}\n+    interface I12 extends I11 {}\n+    interface I13 extends I12 {}\n+    interface I14 extends I13 {}\n+    interface I15 extends I14 {}\n+    interface I16 extends I15 {}\n+    interface I17 extends I16 {}\n+    interface I18 extends I17 {}\n+    interface I19 extends I18 {}\n+    interface I20 extends I19 {}\n+    interface I21 extends I20 {}\n+    interface I22 extends I21 {}\n+    interface I23 extends I22 {}\n+    interface I24 extends I23 {}\n+    interface I25 extends I24 {}\n+    interface I26 extends I25 {}\n+    interface I27 extends I26 {}\n+    interface I28 extends I27 {}\n+    interface I29 extends I28 {}\n+    interface I30 extends I29 {}\n+    interface I31 extends I30 {}\n+    interface I32 extends I31 {}\n+    interface I33 extends I32 {}\n+    interface I34 extends I33 {}\n+    interface I35 extends I34 {}\n+    interface I36 extends I35 {}\n+    interface I37 extends I36 {}\n+    interface I38 extends I37 {}\n+    interface I39 extends I38 {}\n+    interface I40 extends I39 {}\n+    interface I41 extends I40 {}\n+    interface I42 extends I41 {}\n+    interface I43 extends I42 {}\n+    interface I44 extends I43 {}\n+    interface I45 extends I44 {}\n+    interface I46 extends I45 {}\n+    interface I47 extends I46 {}\n+    interface I48 extends I47 {}\n+    interface I49 extends I48 {}\n+    interface I50 extends I49 {}\n+    interface I51 extends I50 {}\n+    interface I52 extends I51 {}\n+    interface I53 extends I52 {}\n+    interface I54 extends I53 {}\n+    interface I55 extends I54 {}\n+    interface I56 extends I55 {}\n+    interface I57 extends I56 {}\n+    interface I58 extends I57 {}\n+    interface I59 extends I58 {}\n+    interface I60 extends I59 {}\n+    interface I61 extends I60 {}\n+    interface I62 extends I61 {}\n+    interface I63 extends I62 {}\n+    interface I64 extends I63 {}\n+\n+    final Object obj00 = new Object();\n+    final Object obj01 = new I01() {};\n+    final Object obj02 = new I02() {};\n+    final Object obj03 = new I03() {};\n+    final Object obj04 = new I04() {};\n+    final Object obj05 = new I05() {};\n+    final Object obj06 = new I06() {};\n+    final Object obj07 = new I07() {};\n+    final Object obj08 = new I08() {};\n+    final Object obj09 = new I09() {};\n+    final Object obj10 = new I10() {};\n+    final Object obj16 = new I16() {};\n+    final Object obj20 = new I20() {};\n+    final Object obj30 = new I30() {};\n+    final Object obj32 = new I32() {};\n+    final Object obj40 = new I40() {};\n+    final Object obj50 = new I50() {};\n+    final Object obj55 = new I55() {};\n+    final Object obj56 = new I56() {};\n+    final Object obj57 = new I57() {};\n+    final Object obj58 = new I58() {};\n+    final Object obj59 = new I59() {};\n+    final Object obj60 = new I60() {};\n+    final Object obj61 = new I61() {};\n+    final Object obj62 = new I62() {};\n+    final Object obj63 = new I63() {};\n+    final Object obj64 = new I64() {};\n+\n+    static Class<?> getSuper(int idx) {\n+        int i = Math.abs(idx) % 10;\n+        switch (i) {\n+            case 0: return I01.class;\n+            case 1: return I02.class;\n+            case 2: return I03.class;\n+            case 3: return I04.class;\n+            case 4: return I05.class;\n+            case 5: return I06.class;\n+            case 6: return I07.class;\n+            case 7: return I08.class;\n+            case 8: return I09.class;\n+            case 9: return I10.class;\n+        }\n+        throw new InternalError(\"\" + i);\n+    }\n+\n+    @Setup\n+    public void warmup() {\n+        for (int i = 0; i < 20_000; i++) {\n+            Class<?> s = getSuper(i);\n+            test(obj01, s, s.isInstance(obj01));\n+            test(obj02, s, s.isInstance(obj02));\n+            test(obj03, s, s.isInstance(obj03));\n+            test(obj04, s, s.isInstance(obj04));\n+            test(obj05, s, s.isInstance(obj05));\n+            test(obj06, s, s.isInstance(obj06));\n+            test(obj07, s, s.isInstance(obj07));\n+            test(obj08, s, s.isInstance(obj08));\n+            test(obj09, s, s.isInstance(obj09));\n+        }\n+    }\n+\n+    private static void test(Object obj, Class<?> cls, boolean expected) {\n+        if (cls.isInstance(obj) != expected) {\n+            throw new InternalError(obj.getClass() + \" \" + cls + \" \" + expected);\n+        }\n+    }\n+    @Benchmark\n+    public void testPositive01() {\n+        test(obj01, I01.class, true);\n+    }\n+    @Benchmark public void testPositive02() {\n+        test(obj02, I02.class, true);\n+    }\n+    @Benchmark public void testPositive03() {\n+        test(obj03, I03.class, true);\n+    }\n+    @Benchmark public void testPositive04() {\n+        test(obj04, I04.class, true);\n+    }\n+    @Benchmark public void testPositive05() {\n+        test(obj05, I05.class, true);\n+    }\n+    @Benchmark public void testPositive06() {\n+        test(obj06, I06.class, true);\n+    }\n+    @Benchmark public void testPositive07() {\n+        test(obj07, I07.class, true);\n+    }\n+    @Benchmark public void testPositive08() {\n+        test(obj08, I08.class, true);\n+    }\n+    @Benchmark public void testPositive09() {\n+        test(obj09, I09.class, true);\n+    }\n+    @Benchmark public void testPositive10() {\n+        test(obj10, I10.class, true);\n+    }\n+    @Benchmark public void testPositive16() {\n+        test(obj16, I16.class, true);\n+    }\n+    @Benchmark public void testPositive20() {\n+        test(obj20, I20.class, true);\n+    }\n+    @Benchmark public void testPositive30() {\n+        test(obj30, I30.class, true);\n+    }\n+    @Benchmark public void testPositive32() {\n+        test(obj32, I32.class, true);\n+    }\n+    @Benchmark public void testPositive40() {\n+        test(obj40, I40.class, true);\n+    }\n+    @Benchmark public void testPositive50() {\n+        test(obj50, I50.class, true);\n+    }\n+    @Benchmark public void testPositive60() {\n+        test(obj60, I60.class, true);\n+    }\n+    @Benchmark public void testPositive63() {\n+        test(obj63, I63.class, true);\n+    }\n+    @Benchmark public void testPositive64() {\n+        test(obj64, I64.class, true);\n+    }\n+\n+    @Benchmark public void testNegative00() {\n+        test(obj00, J.class, false);\n+    }\n+    @Benchmark public void testNegative01() {\n+        test(obj01, J.class, false);\n+    }\n+    @Benchmark public void testNegative02() {\n+        test(obj02, J.class, false);\n+    }\n+    @Benchmark public void testNegative03() {\n+        test(obj03, J.class, false);\n+    }\n+    @Benchmark public void testNegative04() {\n+        test(obj04, J.class, false);\n+    }\n+    @Benchmark public void testNegative05() {\n+        test(obj05, J.class, false);\n+    }\n+    @Benchmark public void testNegative06() {\n+        test(obj06, J.class, false);\n+    }\n+    @Benchmark public void testNegative07() {\n+        test(obj07, J.class, false);\n+    }\n+    @Benchmark public void testNegative08() {\n+        test(obj08, J.class, false);\n+    }\n+    @Benchmark public void testNegative09() {\n+        test(obj09, J.class, false);\n+    }\n+    @Benchmark public void testNegative10() {\n+        test(obj10, J.class, false);\n+    }\n+    @Benchmark public void testNegative16() {\n+        test(obj16, J.class, false);\n+    }\n+    @Benchmark public void testNegative20() {\n+        test(obj20, J.class, false);\n+    }\n+    @Benchmark public void testNegative30() {\n+        test(obj30, J.class, false);\n+    }\n+    @Benchmark public void testNegative32() {\n+        test(obj32, J.class, false);\n+    }\n+    @Benchmark public void testNegative40() {\n+        test(obj40, J.class, false);\n+    }\n+    @Benchmark public void testNegative50() {\n+        test(obj50, J.class, false);\n+    }\n+    @Benchmark public void testNegative55() {\n+        test(obj55, J.class, false);\n+    }\n+    @Benchmark public void testNegative56() {\n+        test(obj56, J.class, false);\n+    }\n+    @Benchmark public void testNegative57() {\n+        test(obj57, J.class, false);\n+    }\n+    @Benchmark public void testNegative58() {\n+        test(obj58, J.class, false);\n+    }\n+    @Benchmark public void testNegative59() {\n+        test(obj59, J.class, false);\n+    }\n+    @Benchmark public void testNegative60() {\n+        test(obj60, J.class, false);\n+    }\n+    @Benchmark public void testNegative61() {\n+        test(obj61, J.class, false);\n+    }\n+    @Benchmark public void testNegative62() {\n+        test(obj62, J.class, false);\n+    }\n+    @Benchmark public void testNegative63() {\n+        test(obj63, J.class, false);\n+    }\n+\n+    @Benchmark public void testNegative64() {\n+        test(obj64, J.class, false);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/SecondarySupersLookup.java","additions":310,"deletions":0,"binary":false,"changes":310,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.*;\n+\n+\/*\n+ * A test to demonstrate type pollution.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n+public class TypePollution {\n+\n+    static class DynamicInvocationHandler implements InvocationHandler {\n+\n+        @Override\n+            public Object invoke(Object proxy, Method method, Object[] args) {\n+            return null;\n+        }\n+    }\n+\n+    interface I01 {}\n+    interface I02 {}\n+    interface I03 {}\n+    interface I04 {}\n+    interface I05 {}\n+    interface I06 {}\n+    interface I07 {}\n+    interface I08 {}\n+    interface I09 {}\n+    interface I10 {}\n+    interface I11 {}\n+    interface I12 {}\n+    interface I13 {}\n+    interface I14 {}\n+    interface I15 {}\n+    interface I16 {}\n+    interface I17 {}\n+    interface I18 {}\n+    interface I19 {}\n+    interface I20 {}\n+\n+    static Class<?>[] classes;\n+\n+    static {\n+        classes = new Class<?>[] { I01.class, I02.class, I03.class, I04.class, I05.class,\n+                                   I06.class, I07.class, I08.class, I09.class, I10.class,\n+                                   I11.class, I12.class, I13.class, I14.class, I15.class,\n+                                   I16.class, I17.class, I18.class, I19.class, I20.class };\n+    }\n+\n+    private static final int NOOFOBJECTS = 100;\n+\n+    public Object[] objectArray;\n+\n+    public Random rand = new Random(0);\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        objectArray = new Object[1000];\n+        var loader = getClass().getClassLoader();\n+        Class<?>[] someInterfaces = new Class<?>[0];\n+        for (int i = 0; i < objectArray.length; i++) {\n+            Set<Class<?>> aSet = new HashSet<Class<?>>();\n+            for (int j = 0; j < 6; j++) {\n+                aSet.add(classes[rand.nextInt(classes.length)]);\n+            }\n+            Class<?>[] interfaceArray = new Class[aSet.size()];\n+            interfaceArray = aSet.toArray(interfaceArray);\n+            objectArray[i] = Proxy.newProxyInstance(loader, interfaceArray, new DynamicInvocationHandler());\n+        }\n+    }\n+\n+    int probe = 99;\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long parallelInstanceOfInterfaceSwitchLinearNoSCC() {\n+        return parallelInstanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long parallelInstanceOfInterfaceSwitchLinearSCC() {\n+        return parallelInstanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long parallelInstanceOfInterfaceSwitchTableNoSCC() {\n+        return parallelInstanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long parallelInstanceOfInterfaceSwitchTableSCC() {\n+        return parallelInstanceOfInterfaceSwitch();\n+    }\n+\n+    long parallelInstanceOfInterfaceSwitch() {\n+        Supplier<Long> s = () -> {\n+            long sum = 0;\n+            for (int i = 0; i < 10000; i++) {\n+                sum += instanceOfInterfaceSwitch();\n+            }\n+            return sum;\n+        };\n+        try {\n+            CompletableFuture<Long> future = CompletableFuture.supplyAsync(s);\n+            return s.get() + future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    public int instanceOfInterfaceSwitchLinearNoSCC() {\n+        return instanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    public int instanceOfInterfaceSwitchLinearSCC() {\n+        return instanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    public int instanceOfInterfaceSwitchTableNoSCC() {\n+        return instanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    public int instanceOfInterfaceSwitchTableSCC() {\n+        return instanceOfInterfaceSwitch();\n+    }\n+\n+    int instanceOfInterfaceSwitch() {\n+        int dummy = 0;\n+        for (int i = 0; i < 100; i++) {\n+            probe ^= probe << 13;   \/\/ xorshift\n+            probe ^= probe >>> 17;\n+            probe ^= probe << 5;\n+            dummy += switch(objectArray[Math.abs(probe) % objectArray.length]) {\n+            case I01 inst -> 1;\n+            case I02 inst -> 2;\n+            case I03 inst -> 3;\n+            case I04 inst -> 4;\n+            case I05 inst -> 5;\n+            case I06 inst -> 6;\n+            case I07 inst -> 7;\n+            case I08 inst -> 8;\n+            default -> 10;\n+            };\n+            probe ^= probe << 13;   \/\/ xorshift\n+            probe ^= probe >>> 17;\n+            probe ^= probe << 5;\n+            dummy += switch(objectArray[Math.abs(probe) % objectArray.length]) {\n+            case I18 inst -> 8;\n+            case I17 inst -> 7;\n+            case I16 inst -> 6;\n+            case I15 inst -> 5;\n+            case I14 inst -> 4;\n+            case I13 inst -> 3;\n+            case I12 inst -> 2;\n+            case I11 inst -> 1;\n+            default -> 0;\n+            };\n+        }\n+        return dummy;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/TypePollution.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"}]}