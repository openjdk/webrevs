{"files":[{"patch":"@@ -203,0 +203,7 @@\n+  ifeq ($(call check-jvm-feature, g1gc), true)\n+    AD_SRC_FILES += $(call uniq, $(wildcard $(foreach d, $(AD_SRC_ROOTS), \\\n+        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/gc\/g1\/g1_$(HOTSPOT_TARGET_CPU).ad \\\n+        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/gc\/g1\/g1_$(HOTSPOT_TARGET_CPU_ARCH).ad \\\n+      )))\n+  endif\n+\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -276,1 +276,1 @@\n-                 int regionIndex = Arrays.binarySearch(regionArray, entry.getKey());\n+                 int regionIndex = findRegionIndex(regionArray, entry.getKey());\n@@ -284,2 +284,2 @@\n-                 int aliasIndex = Arrays.binarySearch(regionArray, entry.getKey());\n-                 int regionIndex = Arrays.binarySearch(regionArray, entry.getValue());\n+                 int aliasIndex = findRegionIndex(regionArray, entry.getKey());\n+                 int regionIndex = findRegionIndex(regionArray, entry.getValue());\n@@ -297,0 +297,8 @@\n+    private static int findRegionIndex(String[] regionArray, String region) {\n+        int index = Arrays.binarySearch(regionArray, region);\n+        if (index < 0) {\n+            throw new IllegalArgumentException(\"Unknown region: \" + region);\n+        }\n+        return index;\n+    }\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/tzdb\/TzdbZoneRulesCompiler.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2623,1 +2623,2 @@\n-      is_valid_sve_arith_imm_pattern(n, m)) {\n+      is_valid_sve_arith_imm_pattern(n, m) ||\n+      is_encode_and_store_pattern(n, m)) {\n@@ -6413,1 +6414,1 @@\n-  predicate(!needs_acquiring_load(n));\n+  predicate(!needs_acquiring_load(n) && n->as_Load()->barrier_data() == 0);\n@@ -6842,1 +6843,1 @@\n-  predicate(!needs_releasing_store(n));\n+  predicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\n@@ -6855,1 +6856,1 @@\n-  predicate(!needs_releasing_store(n));\n+  predicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\n@@ -7089,0 +7090,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -7256,0 +7258,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -7268,0 +7271,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -8064,0 +8068,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -8178,1 +8183,1 @@\n-  predicate(needs_acquiring_load_exclusive(n));\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -8283,0 +8288,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -8392,1 +8398,1 @@\n-  predicate(needs_acquiring_load_exclusive(n));\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -8504,0 +8510,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -8623,1 +8630,1 @@\n-  predicate(needs_acquiring_load_exclusive(n));\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -8684,0 +8691,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -8727,1 +8735,1 @@\n-  predicate(needs_acquiring_load_exclusive(n));\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+  Register owner_addr = tmpReg;\n@@ -157,0 +158,1 @@\n+  Label unlocked;\n@@ -207,0 +209,12 @@\n+\n+  \/\/ Compute owner address.\n+  lea(owner_addr, Address(tmp, ObjectMonitor::owner_offset()));\n+\n+  \/\/ Set owner to null.\n+  \/\/ Release to satisfy the JMM\n+  stlr(zr, owner_addr);\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  \/\/ StoreLoad achieves this.\n+  membar(StoreLoad);\n+\n+  \/\/ Check if the entry lists are empty.\n@@ -208,7 +222,21 @@\n-  ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n-  orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n-  cmp(rscratch1, zr); \/\/ Sets flags for result\n-  cbnz(rscratch1, cont);\n-  \/\/ need a release store here\n-  lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n-  stlr(zr, tmp); \/\/ set unowned\n+  ldr(tmpReg, Address(tmp, ObjectMonitor::cxq_offset()));\n+  orr(rscratch1, rscratch1, tmpReg);\n+  cmp(rscratch1, zr);\n+  br(Assembler::EQ, cont);     \/\/ If so we are done.\n+\n+  \/\/ Check if there is a successor.\n+  ldr(rscratch1, Address(tmp, ObjectMonitor::succ_offset()));\n+  cmp(rscratch1, zr);\n+  br(Assembler::NE, unlocked); \/\/ If so we are done.\n+\n+  \/\/ Save the monitor pointer in the current thread, so we can try to\n+  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+  str(tmp, Address(rthread, JavaThread::unlocked_inflated_monitor_offset()));\n+\n+  cmp(zr, rthread); \/\/ Set Flag to NE => slow path\n+  b(cont);\n+\n+  bind(unlocked);\n+  cmp(zr, zr); \/\/ Set Flag to EQ => fast path\n+\n+  \/\/ Intentional fall-through\n@@ -501,1 +529,0 @@\n-    Label release;\n@@ -507,0 +534,7 @@\n+    \/\/ Set owner to null.\n+    \/\/ Release to satisfy the JMM\n+    stlr(zr, t2_owner_addr);\n+    \/\/ We need a full fence after clearing owner to avoid stranding.\n+    \/\/ StoreLoad achieves this.\n+    membar(StoreLoad);\n+\n@@ -512,1 +546,1 @@\n-    br(Assembler::EQ, release);\n+    br(Assembler::EQ, unlocked);  \/\/ If so we are done.\n@@ -514,5 +548,4 @@\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    str(rthread, Address(t2_owner_addr));\n-    b(slow_path);\n+    \/\/ Check if there is a successor.\n+    ldr(rscratch1, Address(t1_monitor, ObjectMonitor::succ_offset()));\n+    cmp(rscratch1, zr);\n+    br(Assembler::NE, unlocked);  \/\/ If so we are done.\n@@ -520,4 +553,6 @@\n-    bind(release);\n-    \/\/ Set owner to null.\n-    \/\/ Release to satisfy the JMM\n-    stlr(zr, t2_owner_addr);\n+    \/\/ Save the monitor pointer in the current thread, so we can try to\n+    \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+    str(t1_monitor, Address(rthread, JavaThread::unlocked_inflated_monitor_offset()));\n+\n+    cmp(zr, rthread); \/\/ Set Flag to NE => slow path\n+    b(slow_path);\n@@ -528,0 +563,1 @@\n+  cmp(zr, zr); \/\/ Set Flags to EQ => fast path\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":54,"deletions":18,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+       $1$6,NAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);),\n@@ -49,0 +50,1 @@\n+       $1,N,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n@@ -125,0 +127,1 @@\n+       $1$6,NAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);),\n@@ -126,0 +129,1 @@\n+       $1,N,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n","filename":"src\/hotspot\/cpu\/aarch64\/cas.m4","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,4 @@\n-#endif\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -98,0 +101,48 @@\n+static void generate_queue_test_and_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                              const Register thread, const Register value, const Register temp1, const Register temp2) {\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ ldr(temp1, Address(thread, in_bytes(index_offset)));   \/\/ temp1 := *(index address)\n+  __ cbz(temp1, runtime);                                   \/\/ jump to runtime if index == 0 (full buffer)\n+  \/\/ The buffer is not full, store value into it.\n+  __ sub(temp1, temp1, wordSize);                           \/\/ temp1 := next index\n+  __ str(temp1, Address(thread, in_bytes(index_offset)));   \/\/ *(index address) := next index\n+  __ ldr(temp2, Address(thread, in_bytes(buffer_offset)));  \/\/ temp2 := buffer address\n+  __ str(value, Address(temp2, temp1));                     \/\/ *(buffer address + next index) := value\n+}\n+\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread,\n+                                           const Register tmp1) {\n+  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n+  \/\/ Is marking active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ ldrw(tmp1, in_progress);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ ldrb(tmp1, in_progress);\n+  }\n+}\n+\n+static void generate_pre_barrier_slow_path(MacroAssembler* masm,\n+                                           const Register obj,\n+                                           const Register pre_val,\n+                                           const Register thread,\n+                                           const Register tmp1,\n+                                           const Register tmp2,\n+                                           Label& done,\n+                                           Label& runtime) {\n+  \/\/ Do we need to load the previous value?\n+  if (obj != noreg) {\n+    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n+  }\n+  \/\/ Is the previous value null?\n+  __ cbz(pre_val, done);\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, pre_val, tmp1, tmp2);\n+  __ b(done);\n+}\n+\n@@ -118,11 +169,2 @@\n-  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n-  Address index(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n-\n-  \/\/ Is marking active?\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ ldrw(tmp1, in_progress);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ ldrb(tmp1, in_progress);\n-  }\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is not active (*(mark queue active address) == 0), jump to done\n@@ -130,25 +172,1 @@\n-\n-  \/\/ Do we need to load the previous value?\n-  if (obj != noreg) {\n-    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n-  }\n-\n-  \/\/ Is the previous value null?\n-  __ cbz(pre_val, done);\n-\n-  \/\/ Can we store original value in the thread's buffer?\n-  \/\/ Is index == 0?\n-  \/\/ (The index field is typed as size_t.)\n-\n-  __ ldr(tmp1, index);                      \/\/ tmp := *index_adr\n-  __ cbz(tmp1, runtime);                    \/\/ tmp == 0?\n-                                        \/\/ If yes, goto runtime\n-\n-  __ sub(tmp1, tmp1, wordSize);             \/\/ tmp := tmp - wordSize\n-  __ str(tmp1, index);                      \/\/ *index_adr := tmp\n-  __ ldr(tmp2, buffer);\n-  __ add(tmp1, tmp1, tmp2);                 \/\/ tmp := tmp + *buffer_adr\n-\n-  \/\/ Record the previous value\n-  __ str(pre_val, Address(tmp1, 0));\n-  __ b(done);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, done, runtime);\n@@ -185,0 +203,44 @@\n+static void generate_post_barrier_fast_path(MacroAssembler* masm,\n+                                            const Register store_addr,\n+                                            const Register new_val,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            bool new_val_may_be_null) {\n+  \/\/ Does store cross heap regions?\n+  __ eor(tmp1, store_addr, new_val);                     \/\/ tmp1 := store address ^ new value\n+  __ lsr(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);   \/\/ tmp1 := ((store address ^ new value) >> LogOfHRGrainBytes)\n+  __ cbz(tmp1, done);\n+  \/\/ Crosses regions, storing null?\n+  if (new_val_may_be_null) {\n+    __ cbz(new_val, done);\n+  }\n+  \/\/ Storing region crossing non-null, is card young?\n+  __ lsr(tmp1, store_addr, CardTable::card_shift());     \/\/ tmp1 := card address relative to card table base\n+  __ load_byte_map_base(tmp2);                           \/\/ tmp2 := card table base address\n+  __ add(tmp1, tmp1, tmp2);                              \/\/ tmp1 := card address\n+  __ ldrb(tmp2, Address(tmp1));                          \/\/ tmp2 := card\n+  __ cmpw(tmp2, (int)G1CardTable::g1_young_card_val());  \/\/ tmp2 := card == young_card_val?\n+}\n+\n+static void generate_post_barrier_slow_path(MacroAssembler* masm,\n+                                            const Register thread,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            Label& runtime) {\n+  __ membar(Assembler::StoreLoad);  \/\/ StoreLoad membar\n+  __ ldrb(tmp2, Address(tmp1));     \/\/ tmp2 := card\n+  __ cbzw(tmp2, done);\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n+  \/\/ Dirty card and log.\n+  STATIC_ASSERT(CardTable::dirty_card_val() == 0);\n+  __ strb(zr, Address(tmp1));       \/\/ *(card address) := dirty_card_val\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, tmp1, tmp2, rscratch1);\n+  __ b(done);\n+}\n+\n@@ -197,7 +259,0 @@\n-  Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));\n-\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n-  CardTable* ct = ctbs->card_table();\n-\n@@ -207,1 +262,4 @@\n-  \/\/ Does store cross heap regions?\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  \/\/ If card is young, jump to done\n+  __ br(Assembler::EQ, done);\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, done, runtime);\n@@ -209,3 +267,6 @@\n-  __ eor(tmp1, store_addr, new_val);\n-  __ lsr(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n-  __ cbz(tmp1, done);\n+  __ bind(runtime);\n+  \/\/ save the live input values\n+  RegSet saved = RegSet::of(store_addr);\n+  __ push(saved, sp);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), tmp1, thread);\n+  __ pop(saved, sp);\n@@ -213,1 +274,2 @@\n-  \/\/ crosses regions, storing null?\n+  __ bind(done);\n+}\n@@ -215,1 +277,1 @@\n-  __ cbz(new_val, done);\n+#if defined(COMPILER2)\n@@ -217,1 +279,9 @@\n-  \/\/ storing region crossing non-null, is card already dirty?\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register arg, const address runtime_path) {\n+  SaveLiveRegisters save_registers(masm, stub);\n+  if (c_rarg0 != arg) {\n+    __ mov(c_rarg0, arg);\n+  }\n+  __ mov(c_rarg1, rthread);\n+  __ mov(rscratch1, runtime_path);\n+  __ blr(rscratch1);\n+}\n@@ -219,1 +289,10 @@\n-  const Register card_addr = tmp1;\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register thread,\n+                                                    Register tmp1,\n+                                                    Register tmp2,\n+                                                    G1PreBarrierStubC2* stub) {\n+  assert(thread == rthread, \"must be\");\n+  assert_different_registers(obj, pre_val, tmp1, tmp2);\n+  assert(pre_val != noreg && tmp1 != noreg && tmp2 != noreg, \"expecting a register\");\n@@ -221,1 +300,1 @@\n-  __ lsr(card_addr, store_addr, CardTable::card_shift());\n+  stub->initialize_registers(obj, pre_val, thread, tmp1, tmp2);\n@@ -223,6 +302,3 @@\n-  \/\/ get the address of the card\n-  __ load_byte_map_base(tmp2);\n-  __ add(card_addr, card_addr, tmp2);\n-  __ ldrb(tmp2, Address(card_addr));\n-  __ cmpw(tmp2, (int)G1CardTable::g1_young_card_val());\n-  __ br(Assembler::EQ, done);\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is active (*(mark queue active address) != 0), jump to stub (slow path)\n+  __ cbnzw(tmp1, *stub->entry());\n@@ -230,1 +306,2 @@\n-  assert((int)CardTable::dirty_card_val() == 0, \"must be 0\");\n+  __ bind(*stub->continuation());\n+}\n@@ -232,1 +309,9 @@\n-  __ membar(Assembler::StoreLoad);\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register obj = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1();\n+  Register tmp2 = stub->tmp2();\n@@ -234,2 +319,2 @@\n-  __ ldrb(tmp2, Address(card_addr));\n-  __ cbzw(tmp2, done);\n+  __ bind(*stub->entry());\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, *stub->continuation(), runtime);\n@@ -237,2 +322,4 @@\n-  \/\/ storing a region crossing, non-null oop, card is clean.\n-  \/\/ dirty card and log.\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry));\n+  __ b(*stub->continuation());\n+}\n@@ -240,1 +327,12 @@\n-  __ strb(zr, Address(card_addr));\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register thread,\n+                                                     Register tmp1,\n+                                                     Register tmp2,\n+                                                     G1PostBarrierStubC2* stub) {\n+  assert(thread == rthread, \"must be\");\n+  assert_different_registers(store_addr, new_val, thread, tmp1, tmp2,\n+                             rscratch1);\n+  assert(store_addr != noreg && new_val != noreg && tmp1 != noreg\n+         && tmp2 != noreg, \"expecting a register\");\n@@ -242,4 +340,1 @@\n-  __ ldr(rscratch1, queue_index);\n-  __ cbz(rscratch1, runtime);\n-  __ sub(rscratch1, rscratch1, wordSize);\n-  __ str(rscratch1, queue_index);\n+  stub->initialize_registers(thread, tmp1, tmp2);\n@@ -247,3 +342,4 @@\n-  __ ldr(tmp2, buffer);\n-  __ str(card_addr, Address(tmp2, rscratch1));\n-  __ b(done);\n+  bool new_val_may_be_null = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, *stub->continuation(), new_val_may_be_null);\n+  \/\/ If card is not young, jump to stub (slow path)\n+  __ br(Assembler::NE, *stub->entry());\n@@ -251,6 +347,2 @@\n-  __ bind(runtime);\n-  \/\/ save the live input values\n-  RegSet saved = RegSet::of(store_addr);\n-  __ push(saved, sp);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);\n-  __ pop(saved, sp);\n+  __ bind(*stub->continuation());\n+}\n@@ -258,1 +350,15 @@\n-  __ bind(done);\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1(); \/\/ tmp1 holds the card address.\n+  Register tmp2 = stub->tmp2();\n+  assert(stub->tmp3() == noreg, \"not needed in this platform\");\n+\n+  __ bind(*stub->entry());\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, tmp1, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry));\n+  __ b(*stub->continuation());\n@@ -261,0 +367,2 @@\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":188,"deletions":80,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+class G1PreBarrierStubC2;\n+class G1PostBarrierStubC2;\n@@ -72,0 +74,21 @@\n+#ifdef COMPILER2\n+  void g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                               Register obj,\n+                               Register pre_val,\n+                               Register thread,\n+                               Register tmp1,\n+                               Register tmp2,\n+                               G1PreBarrierStubC2* c2_stub);\n+  void generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                    G1PreBarrierStubC2* stub) const;\n+  void g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                Register store_addr,\n+                                Register new_val,\n+                                Register thread,\n+                                Register tmp1,\n+                                Register tmp2,\n+                                G1PostBarrierStubC2* c2_stub);\n+  void generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                     G1PostBarrierStubC2* stub) const;\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,680 @@\n+\/\/\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+source_hpp %{\n+\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+\n+%}\n+\n+source %{\n+\n+#include \"gc\/g1\/g1BarrierSetAssembler_aarch64.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+\n+static void write_barrier_pre(MacroAssembler* masm,\n+                              const MachNode* node,\n+                              Register obj,\n+                              Register pre_val,\n+                              Register tmp1,\n+                              Register tmp2,\n+                              RegSet preserve = RegSet(),\n+                              RegSet no_preserve = RegSet()) {\n+  if (!G1PreBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PreBarrierStubC2* const stub = G1PreBarrierStubC2::create(node);\n+  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {\n+    stub->preserve(*reg);\n+  }\n+  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {\n+    stub->dont_preserve(*reg);\n+  }\n+  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, rthread, tmp1, tmp2, stub);\n+}\n+\n+static void write_barrier_post(MacroAssembler* masm,\n+                               const MachNode* node,\n+                               Register store_addr,\n+                               Register new_val,\n+                               Register tmp1,\n+                               Register tmp2) {\n+  if (!G1PostBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PostBarrierStubC2* const stub = G1PostBarrierStubC2::create(node);\n+  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, rthread, tmp1, tmp2, stub);\n+}\n+\n+%}\n+\n+\/\/ BEGIN This section of the file is automatically generated. Do not edit --------------\n+\n+\/\/ This section is generated from g1_aarch64.m4\n+\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1StoreP(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreP mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(INSN_COST);\n+  format %{ \"str  $src, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ str($src$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(istore_reg_mem);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1StorePVolatile(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreP mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlr  $src, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ stlr($src$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1StoreN(indirect mem, iRegN src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(INSN_COST);\n+  format %{ \"strw  $src, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ strw($src$$Register, $mem$$Register);\n+    if ((barrier_data() & G1C2BarrierPost) != 0) {\n+      if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+        __ decode_heap_oop($tmp1$$Register, $src$$Register);\n+      } else {\n+        __ decode_heap_oop_not_null($tmp1$$Register, $src$$Register);\n+      }\n+    }\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(istore_reg_mem);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1StoreNVolatile(indirect mem, iRegN src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrw  $src, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ stlrw($src$$Register, $mem$$Register);\n+    if ((barrier_data() & G1C2BarrierPost) != 0) {\n+      if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+        __ decode_heap_oop($tmp1$$Register, $src$$Register);\n+      } else {\n+        __ decode_heap_oop_not_null($tmp1$$Register, $src$$Register);\n+      }\n+    }\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1EncodePAndStoreN(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem (EncodeP src)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(INSN_COST);\n+  format %{ \"encode_heap_oop $tmp1, $src\\n\\t\"\n+            \"strw  $tmp1, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+      __ encode_heap_oop($tmp1$$Register, $src$$Register);\n+    } else {\n+      __ encode_heap_oop_not_null($tmp1$$Register, $src$$Register);\n+    }\n+    __ strw($tmp1$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(istore_reg_mem);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1EncodePAndStoreNVolatile(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem (EncodeP src)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"encode_heap_oop $tmp1, $src\\n\\t\"\n+            \"stlrw  $tmp1, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+      __ encode_heap_oop($tmp1$$Register, $src$$Register);\n+    } else {\n+      __ encode_heap_oop_not_null($tmp1$$Register, $src$$Register);\n+    }\n+    __ stlrw($tmp1$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $res = $mem, $oldval, $newval\\t# ptr\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    \/\/ Pass $oldval to the pre-barrier (instead of loading from $mem), because\n+    \/\/ $oldval is the only value that can be overwritten.\n+    \/\/ The same holds for g1CompareAndSwapP and its Acq variant.\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::xword,\n+               false \/* acquire *\/, true \/* release *\/, false \/* weak *\/, $res$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# ptr\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    \/\/ Pass $oldval to the pre-barrier (instead of loading from $mem), because\n+    \/\/ $oldval is the only value that can be overwritten.\n+    \/\/ The same holds for g1CompareAndSwapP and its Acq variant.\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::xword,\n+               true \/* acquire *\/, true \/* release *\/, false \/* weak *\/, $res$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $res = $mem, $oldval, $newval\\t# narrow oop\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::word,\n+               false \/* acquire *\/, true \/* release *\/, false \/* weak *\/, $res$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# narrow oop\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::word,\n+               true \/* acquire *\/, true \/* release *\/, false \/* weak *\/, $res$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndSwapP(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegP oldval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $mem, $oldval, $newval\\t# (ptr)\\n\\t\"\n+            \"cset $res, EQ\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::xword,\n+               false \/* acquire *\/, true \/* release *\/, false \/* weak *\/, noreg);\n+    __ cset($res$$Register, Assembler::EQ);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegP oldval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $mem, $oldval, $newval\\t# (ptr)\\n\\t\"\n+            \"cset $res, EQ\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::xword,\n+               true \/* acquire *\/, true \/* release *\/, false \/* weak *\/, noreg);\n+    __ cset($res$$Register, Assembler::EQ);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndSwapN(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $mem, $oldval, $newval\\t# (narrow oop)\\n\\t\"\n+            \"cset $res, EQ\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::word,\n+               false \/* acquire *\/, true \/* release *\/, false \/* weak *\/, noreg);\n+    __ cset($res$$Register, Assembler::EQ);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $mem, $oldval, $newval\\t# (narrow oop)\\n\\t\"\n+            \"cset $res, EQ\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::word,\n+               true \/* acquire *\/, true \/* release *\/, false \/* weak *\/, noreg);\n+    __ cset($res$$Register, Assembler::EQ);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1GetAndSetP(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetP mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg  $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $preval$$Register \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchg($preval$$Register, $newval$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1GetAndSetPAcq(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetP mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg_acq  $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $preval$$Register \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchgal($preval$$Register, $newval$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1GetAndSetN(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetN mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"atomic_xchgw $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchgw($preval$$Register, $newval$$Register, $mem$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1GetAndSetNAcq(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetN mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"atomic_xchgw_acq $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchgalw($preval$$Register, $newval$$Register, $mem$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1LoadP(iRegPNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n+%{\n+  \/\/ This instruction does not need an acquiring counterpart because it is only\n+  \/\/ used for reference loading (Reference::get()). The same holds for g1LoadN.\n+  predicate(UseG1GC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadP mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldr  $dst, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    __ ldr($dst$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(iload_reg_mem);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1LoadN(iRegNNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadN mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldrw  $dst, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    __ ldrw($dst$$Register, $mem$$Register);\n+    if ((barrier_data() & G1C2BarrierPre) != 0) {\n+      __ decode_heap_oop($tmp1$$Register, $dst$$Register);\n+      write_barrier_pre(masm, this,\n+                        noreg \/* obj *\/,\n+                        $tmp1$$Register \/* pre_val *\/,\n+                        $tmp2$$Register \/* tmp1 *\/,\n+                        $tmp3$$Register \/* tmp2 *\/);\n+    }\n+  %}\n+  ins_pipe(iload_reg_mem);\n+%}\n+\n+\/\/ END This section of the file is automatically generated. Do not edit --------------\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1_aarch64.ad","additions":680,"deletions":0,"binary":false,"changes":680,"status":"added"},{"patch":"@@ -0,0 +1,384 @@\n+dnl Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+dnl DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+dnl\n+dnl This code is free software; you can redistribute it and\/or modify it\n+dnl under the terms of the GNU General Public License version 2 only, as\n+dnl published by the Free Software Foundation.\n+dnl\n+dnl This code is distributed in the hope that it will be useful, but WITHOUT\n+dnl ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+dnl FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+dnl version 2 for more details (a copy is included in the LICENSE file that\n+dnl accompanied this code).\n+dnl\n+dnl You should have received a copy of the GNU General Public License version\n+dnl 2 along with this work; if not, write to the Free Software Foundation,\n+dnl Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+dnl\n+dnl Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+dnl or visit www.oracle.com if you need additional information or have any\n+dnl questions.\n+dnl\n+\/\/ BEGIN This section of the file is automatically generated. Do not edit --------------\n+\n+\/\/ This section is generated from g1_aarch64.m4\n+\n+define(`STOREP_INSN',\n+`\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1StoreP$1(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && ifelse($1,Volatile,'needs_releasing_store(n)`,'!needs_releasing_store(n)`) && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreP mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(ifelse($1,Volatile,VOLATILE_REF_COST,INSN_COST));\n+  format %{ \"$2  $src, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ $2($src$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(ifelse($1,Volatile,pipe_class_memory,istore_reg_mem));\n+%}')dnl\n+STOREP_INSN(,str)\n+STOREP_INSN(Volatile,stlr)\n+dnl\n+define(`STOREN_INSN',\n+`\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1StoreN$1(indirect mem, iRegN src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && ifelse($1,Volatile,'needs_releasing_store(n)`,'!needs_releasing_store(n)`) && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(ifelse($1,Volatile,VOLATILE_REF_COST,INSN_COST));\n+  format %{ \"$2  $src, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ $2($src$$Register, $mem$$Register);\n+    if ((barrier_data() & G1C2BarrierPost) != 0) {\n+      if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+        __ decode_heap_oop($tmp1$$Register, $src$$Register);\n+      } else {\n+        __ decode_heap_oop_not_null($tmp1$$Register, $src$$Register);\n+      }\n+    }\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(ifelse($1,Volatile,pipe_class_memory,istore_reg_mem));\n+%}')dnl\n+STOREN_INSN(,strw)\n+STOREN_INSN(Volatile,stlrw)\n+dnl\n+define(`ENCODESTOREN_INSN',\n+`\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1EncodePAndStoreN$1(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && ifelse($1,Volatile,'needs_releasing_store(n)`,'!needs_releasing_store(n)`) && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem (EncodeP src)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(ifelse($1,Volatile,VOLATILE_REF_COST,INSN_COST));\n+  format %{ \"encode_heap_oop $tmp1, $src\\n\\t\"\n+            \"$2  $tmp1, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+      __ encode_heap_oop($tmp1$$Register, $src$$Register);\n+    } else {\n+      __ encode_heap_oop_not_null($tmp1$$Register, $src$$Register);\n+    }\n+    __ $2($tmp1$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(ifelse($1,Volatile,pipe_class_memory,istore_reg_mem));\n+%}')dnl\n+ENCODESTOREN_INSN(,strw)\n+ENCODESTOREN_INSN(Volatile,stlrw)\n+dnl\n+define(`CAEP_INSN',\n+`\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndExchangeP$1(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && ifelse($1,Acq,'needs_acquiring_load_exclusive(n)`,'!needs_acquiring_load_exclusive(n)`) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(ifelse($1,Acq,VOLATILE_REF_COST,2 * VOLATILE_REF_COST));\n+  format %{ \"cmpxchg$2 $res = $mem, $oldval, $newval\\t# ptr\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    \/\/ Pass $oldval to the pre-barrier (instead of loading from $mem), because\n+    \/\/ $oldval is the only value that can be overwritten.\n+    \/\/ The same holds for g1CompareAndSwapP and its Acq variant.\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::xword,\n+               $3 \/* acquire *\/, true \/* release *\/, false \/* weak *\/, $res$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+CAEP_INSN(,,false)\n+CAEP_INSN(Acq,_acq,true)\n+dnl\n+define(`CAEN_INSN',\n+`\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndExchangeN$1(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && ifelse($1,Acq,'needs_acquiring_load_exclusive(n)`,'!needs_acquiring_load_exclusive(n)`) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(ifelse($1,Acq,VOLATILE_REF_COST,2 * VOLATILE_REF_COST));\n+  format %{ \"cmpxchg$2 $res = $mem, $oldval, $newval\\t# narrow oop\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::word,\n+               $3 \/* acquire *\/, true \/* release *\/, false \/* weak *\/, $res$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+CAEN_INSN(,,false)\n+CAEN_INSN(Acq,_acq,true)\n+dnl\n+define(`CASP_INSN',\n+`\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndSwapP$1(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegP oldval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && ifelse($1,Acq,'needs_acquiring_load_exclusive(n)`,'!needs_acquiring_load_exclusive(n)`) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(ifelse($1,Acq,VOLATILE_REF_COST,2 * VOLATILE_REF_COST));\n+  format %{ \"cmpxchg$2 $mem, $oldval, $newval\\t# (ptr)\\n\\t\"\n+            \"cset $res, EQ\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::xword,\n+               $3 \/* acquire *\/, true \/* release *\/, false \/* weak *\/, noreg);\n+    __ cset($res$$Register, Assembler::EQ);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+CASP_INSN(,,false)\n+CASP_INSN(Acq,_acq,true)\n+dnl\n+define(`CASN_INSN',\n+`\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1CompareAndSwapN$1(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && ifelse($1,Acq,'needs_acquiring_load_exclusive(n)`,'!needs_acquiring_load_exclusive(n)`) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(ifelse($1,Acq,VOLATILE_REF_COST,2 * VOLATILE_REF_COST));\n+  format %{ \"cmpxchg$2 $mem, $oldval, $newval\\t# (narrow oop)\\n\\t\"\n+            \"cset $res, EQ\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::word,\n+               $3 \/* acquire *\/, true \/* release *\/, false \/* weak *\/, noreg);\n+    __ cset($res$$Register, Assembler::EQ);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+CASN_INSN(,,false)\n+CASN_INSN(Acq,_acq,true)\n+dnl\n+define(`XCHGP_INSN',\n+`\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1GetAndSetP$1(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && ifelse($1,Acq,'needs_acquiring_load_exclusive(n)`,'!needs_acquiring_load_exclusive(n)`) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetP mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(ifelse($1,Acq,VOLATILE_REF_COST,2 * VOLATILE_REF_COST));\n+  format %{ \"atomic_xchg$2  $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $preval$$Register \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ $3($preval$$Register, $newval$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}')dnl\n+XCHGP_INSN(,,atomic_xchg)\n+XCHGP_INSN(Acq,_acq,atomic_xchgal)\n+dnl\n+define(`XCHGN_INSN',\n+`\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1GetAndSetN$1(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && ifelse($1,Acq,'needs_acquiring_load_exclusive(n)`,'!needs_acquiring_load_exclusive(n)`) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetN mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(ifelse($1,Acq,VOLATILE_REF_COST,2 * VOLATILE_REF_COST));\n+  format %{ \"$2 $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ $3($preval$$Register, $newval$$Register, $mem$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}')dnl\n+XCHGN_INSN(,atomic_xchgw,atomic_xchgw)\n+XCHGN_INSN(Acq,atomic_xchgw_acq,atomic_xchgalw)\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1LoadP(iRegPNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n+%{\n+  \/\/ This instruction does not need an acquiring counterpart because it is only\n+  \/\/ used for reference loading (Reference::get()). The same holds for g1LoadN.\n+  predicate(UseG1GC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadP mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldr  $dst, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    __ ldr($dst$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(iload_reg_mem);\n+%}\n+\n+\/\/ This pattern is generated automatically from g1_aarch64.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct g1LoadN(iRegNNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadN mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldrw  $dst, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    __ ldrw($dst$$Register, $mem$$Register);\n+    if ((barrier_data() & G1C2BarrierPre) != 0) {\n+      __ decode_heap_oop($tmp1$$Register, $dst$$Register);\n+      write_barrier_pre(masm, this,\n+                        noreg \/* obj *\/,\n+                        $tmp1$$Register \/* pre_val *\/,\n+                        $tmp2$$Register \/* tmp1 *\/,\n+                        $tmp3$$Register \/* tmp2 *\/);\n+    }\n+  %}\n+  ins_pipe(iload_reg_mem);\n+%}\n+\n+\/\/ END This section of the file is automatically generated. Do not edit --------------\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1_aarch64.m4","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -72,1 +72,1 @@\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop_entry), src, dst, count);\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop), src, dst, count);\n@@ -74,1 +74,1 @@\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop_entry), src, dst, count);\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop), src, dst, count);\n@@ -176,1 +176,1 @@\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);\n+    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n@@ -178,1 +178,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n@@ -754,1 +754,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2237,1 +2237,1 @@\n-  if (EnableJVMCI && UseJVMCICompiler) {\n+  if (UseJVMCICompiler) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3420,2 +3420,0 @@\n-    __ andw(rscratch3, r2, r4);\n-    __ bicw(rscratch4, r3, r4);\n@@ -3424,1 +3422,0 @@\n-    __ orrw(rscratch3, rscratch3, rscratch4);\n@@ -3427,2 +3424,5 @@\n-    __ addw(rscratch3, rscratch3, rscratch4);\n-    __ rorw(rscratch2, rscratch3, 32 - s);\n+    __ bicw(rscratch2, r3, r4);\n+    __ andw(rscratch3, r2, r4);\n+    __ addw(rscratch2, rscratch2, rscratch4);\n+    __ addw(rscratch2, rscratch2, rscratch3);\n+    __ rorw(rscratch2, rscratch2, 32 - s);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3893,0 +3893,1 @@\n+  predicate(!(UseG1GC && n->as_Load()->barrier_data() != 0));\n@@ -4359,0 +4360,1 @@\n+  predicate(!(UseG1GC && n->as_Store()->barrier_data() != 0));\n@@ -5393,0 +5395,1 @@\n+  predicate(!(UseG1GC && n->as_LoadStore()->barrier_data() != 0));\n@@ -5662,0 +5665,1 @@\n+  predicate(!(UseG1GC && n->as_LoadStore()->barrier_data() != 0));\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,2 +122,3 @@\n-    assert((set1._encoding & set2._encoding) == 0,\n-           \"encoding constraint\");\n+\/\/    why so strong constraint?\n+\/\/    assert((set1._encoding & set2._encoding) == 0,\n+\/\/           \"encoding constraint\");\n@@ -145,0 +146,5 @@\n+\n+  static RegisterSet from(RegSet set) {\n+    assert(set.size(), \"RegSet must not be empty\");\n+    return RegisterSet(set.bits());\n+  }\n@@ -160,0 +166,4 @@\n+  FloatRegisterSet() {\n+    _encoding = 0;\n+  }\n+\n@@ -188,0 +198,9 @@\n+  static FloatRegisterSet from(FloatRegSet set) {\n+    assert(set.size(), \"FloatRegSet must not be empty\");\n+    \/\/ the vector load\/store instructions operate on a set of consecutive registers.\n+    \/\/ for the sake of simplicity, write all registers between the first and last in the set\n+    size_t range =  (*set.rbegin())->encoding() - (*set.begin())->encoding() + 1;\n+    \/\/ push_float stores float regisgters by pairs\n+    return  FloatRegisterSet(*set.begin(), (range+1)\/2);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm_32.hpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,2 +42,4 @@\n-#endif\n-\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -109,24 +111,14 @@\n-\/\/ G1 pre-barrier.\n-\/\/ Blows all volatile registers R0-R3, Rtemp, LR).\n-\/\/ If store_addr != noreg, then previous value is loaded from [store_addr];\n-\/\/ in such case store_addr and new_val registers are preserved;\n-\/\/ otherwise pre_val register is preserved.\n-void G1BarrierSetAssembler::g1_write_barrier_pre(MacroAssembler* masm,\n-                                          Register store_addr,\n-                                          Register new_val,\n-                                          Register pre_val,\n-                                          Register tmp1,\n-                                          Register tmp2) {\n-  Label done;\n-  Label runtime;\n-\n-  if (store_addr != noreg) {\n-    assert_different_registers(store_addr, new_val, pre_val, tmp1, tmp2, noreg);\n-  } else {\n-    assert (new_val == noreg, \"should be\");\n-    assert_different_registers(pre_val, tmp1, tmp2, noreg);\n-  }\n-\n-  Address in_progress(Rthread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n-  Address index(Rthread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n-  Address buffer(Rthread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n+static void generate_queue_test_and_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                              const Register thread, const Register value, const Register temp1, const Register temp2) {\n+  assert_different_registers(value, temp1, temp2);\n+  \/\/ Can we store original value in the thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ ldr(temp1, Address(thread, in_bytes(index_offset)));  \/\/ temp1 := *(index address)\n+  __ cbz(temp1, runtime);                                  \/\/ jump to runtime if index == 0 (full buffer)\n+  \/\/ The buffer is not full, store value into it.\n+  __ sub(temp1, temp1, wordSize);                          \/\/ temp1 := next index\n+  __ str(temp1, Address(thread, in_bytes(index_offset)));  \/\/ *(index address) := next index\n+  __ ldr(temp2, Address(thread, in_bytes(buffer_offset))); \/\/ temp2 := buffer address\n+  \/\/ Record the previous value\n+  __ str(value, Address(temp2, temp1));                    \/\/ *(buffer address + next index) := value\n+ }\n@@ -134,0 +126,4 @@\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread,\n+                                           const Register tmp1) {\n+  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n@@ -137,1 +133,1 @@\n-  __ cbz(tmp1, done);\n+}\n@@ -139,0 +135,8 @@\n+static void generate_pre_barrier_slow_path(MacroAssembler* masm,\n+                                           const Register obj,\n+                                           const Register pre_val,\n+                                           const Register thread,\n+                                           const Register tmp1,\n+                                           const Register tmp2,\n+                                           Label& done,\n+                                           Label& runtime) {\n@@ -140,2 +144,2 @@\n-  if (store_addr != noreg) {\n-    __ load_heap_oop(pre_val, Address(store_addr, 0));\n+  if (obj != noreg) {\n+    __ load_heap_oop(pre_val, Address(obj, 0));\n@@ -147,3 +151,7 @@\n-  \/\/ Can we store original value in the thread's buffer?\n-  \/\/ Is index == 0?\n-  \/\/ (The index field is typed as size_t.)\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, pre_val, tmp1, tmp2);\n+  __ b(done);\n+}\n@@ -151,2 +159,12 @@\n-  __ ldr(tmp1, index);           \/\/ tmp1 := *index_adr\n-  __ ldr(tmp2, buffer);\n+\/\/ G1 pre-barrier.\n+\/\/ Blows all volatile registers R0-R3, LR).\n+\/\/ If obj != noreg, then previous value is loaded from [obj];\n+\/\/ in such case obj and pre_val registers is preserved;\n+\/\/ otherwise pre_val register is preserved.\n+void G1BarrierSetAssembler::g1_write_barrier_pre(MacroAssembler* masm,\n+                                          Register obj,\n+                                          Register pre_val,\n+                                          Register tmp1,\n+                                          Register tmp2) {\n+  Label done;\n+  Label runtime;\n@@ -154,2 +172,1 @@\n-  __ subs(tmp1, tmp1, wordSize); \/\/ tmp1 := tmp1 - wordSize\n-  __ b(runtime, lt);             \/\/ If negative, goto runtime\n+  assert_different_registers(obj, pre_val, tmp1, tmp2, noreg);\n@@ -157,1 +174,3 @@\n-  __ str(tmp1, index);           \/\/ *index_adr := tmp1\n+  generate_pre_barrier_fast_path(masm, Rthread, tmp1);\n+  \/\/ If marking is not active (*(mark queue active address) == 0), jump to done\n+  __ cbz(tmp1, done);\n@@ -159,3 +178,1 @@\n-  \/\/ Record the previous value\n-  __ str(pre_val, Address(tmp2, tmp1));\n-  __ b(done);\n+   generate_pre_barrier_slow_path(masm, obj, pre_val, Rthread, tmp1, tmp2, done, runtime);\n@@ -166,5 +183,5 @@\n-  if (store_addr != noreg) {\n-    \/\/ avoid raw_push to support any ordering of store_addr and new_val\n-    __ push(RegisterSet(store_addr) | RegisterSet(new_val));\n-  } else {\n-    __ push(pre_val);\n+  RegisterSet set = RegisterSet(pre_val) | RegisterSet(R0, R3) | RegisterSet(R12);\n+  \/\/ save the live input values\n+  if (obj != noreg) {\n+    \/\/ avoid raw_push to support any ordering of store_addr and pre_val\n+    set = set | RegisterSet(obj);\n@@ -173,0 +190,2 @@\n+  __ push(set);\n+\n@@ -180,6 +199,1 @@\n-  if (store_addr != noreg) {\n-    __ pop(RegisterSet(store_addr) | RegisterSet(new_val));\n-  } else {\n-    __ pop(pre_val);\n-  }\n-\n+  __ pop(set);\n@@ -189,18 +203,7 @@\n-\/\/ G1 post-barrier.\n-\/\/ Blows all volatile registers R0-R3, Rtemp, LR).\n-void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,\n-                                           Register store_addr,\n-                                           Register new_val,\n-                                           Register tmp1,\n-                                           Register tmp2,\n-                                           Register tmp3) {\n-\n-  Address queue_index(Rthread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));\n-  Address buffer(Rthread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));\n-\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n-  CardTable* ct = ctbs->card_table();\n-  Label done;\n-  Label runtime;\n-\n+static void generate_post_barrier_fast_path(MacroAssembler* masm,\n+                                            const Register store_addr,\n+                                            const Register new_val,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            bool new_val_may_be_null) {\n@@ -214,3 +217,3 @@\n-\n-  __ cbz(new_val, done);\n-\n+  if (new_val_may_be_null) {\n+    __ cbz(new_val, done);\n+  }\n@@ -220,1 +223,2 @@\n-  __ mov_address(tmp2, (address)ct->byte_map_base());\n+  CardTableBarrierSet* ct = barrier_set_cast<CardTableBarrierSet>(BarrierSet::barrier_set());\n+  __ mov_address(tmp2, (address)ct->card_table()->byte_map_base());\n@@ -225,1 +229,1 @@\n-  __ b(done, eq);\n+}\n@@ -227,0 +231,7 @@\n+static void generate_post_barrier_slow_path(MacroAssembler* masm,\n+                                            const Register thread,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            const Register tmp3,\n+                                            Label& done,\n+                                            Label& runtime) {\n@@ -228,1 +239,0 @@\n-\n@@ -230,0 +240,2 @@\n+  \/\/ card_addr is loaded by generate_post_barrier_fast_path\n+  const Register card_addr = tmp1;\n@@ -237,0 +249,7 @@\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, card_addr, tmp2, tmp3);\n+  __ b(done);\n+}\n@@ -238,5 +257,0 @@\n-  __ ldr(tmp2, queue_index);\n-  __ ldr(tmp3, buffer);\n-\n-  __ subs(tmp2, tmp2, wordSize);\n-  __ b(runtime, lt); \/\/ go to runtime if now negative\n@@ -244,1 +258,10 @@\n-  __ str(tmp2, queue_index);\n+\/\/ G1 post-barrier.\n+\/\/ Blows all volatile registers R0-R3,  LR).\n+void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,\n+                                           Register store_addr,\n+                                           Register new_val,\n+                                           Register tmp1,\n+                                           Register tmp2,\n+                                           Register tmp3) {\n+  Label done;\n+  Label runtime;\n@@ -246,2 +269,7 @@\n-  __ str(card_addr, Address(tmp3, tmp2));\n-  __ b(done);\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  \/\/ If card is young, jump to done\n+  \/\/ card_addr and card are loaded by generate_post_barrier_fast_path\n+  const Register card      = tmp2;\n+  const Register card_addr = tmp1;\n+   __ b(done, eq);\n+  generate_post_barrier_slow_path(masm, Rthread, card_addr, tmp2, tmp3, done, runtime);\n@@ -251,0 +279,3 @@\n+  RegisterSet set = RegisterSet(store_addr) | RegisterSet(R0, R3) | RegisterSet(R12);\n+  __ push(set);\n+\n@@ -257,0 +288,2 @@\n+  __ pop(set);\n+\n@@ -260,0 +293,89 @@\n+#if defined(COMPILER2)\n+\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register arg, const address runtime_path, Register tmp1) {\n+  SaveLiveRegisters save_registers(masm, stub);\n+  if (c_rarg0 != arg) {\n+    __ mov(c_rarg0, arg);\n+  }\n+  __ mov(c_rarg1, Rthread);\n+  __ call_VM_leaf(runtime_path, R0, R1);\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register thread,\n+                                                    Register tmp1,\n+                                                    Register tmp2,\n+                                                    G1PreBarrierStubC2* stub) {\n+  assert(thread == Rthread, \"must be\");\n+  assert_different_registers(obj, pre_val, tmp1, tmp2);\n+  assert(pre_val != noreg && tmp1 != noreg && tmp2 != noreg, \"expecting a register\");\n+\n+  stub->initialize_registers(obj, pre_val, thread, tmp1, tmp2);\n+\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is active (*(mark queue active address) != 0), jump to stub (slow path)\n+  __ cbnz(tmp1, *stub->entry());\n+\n+  __ bind(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register obj = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1();\n+  Register tmp2 = stub->tmp2();\n+\n+  __ bind(*stub->entry());\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), tmp1);\n+  __ b(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register thread,\n+                                                     Register tmp1,\n+                                                     Register tmp2,\n+                                                     Register tmp3,\n+                                                     G1PostBarrierStubC2* stub) {\n+  assert(thread == Rthread, \"must be\");\n+  assert_different_registers(store_addr, new_val, thread, tmp1, tmp2, noreg);\n+\n+  stub->initialize_registers(thread, tmp1, tmp2, tmp3);\n+\n+  bool new_val_may_be_null = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, *stub->continuation(), new_val_may_be_null);\n+  \/\/ If card is not young, jump to stub (slow path)\n+  __ b(*stub->entry(), ne);\n+\n+  __ bind(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1(); \/\/ tmp1 holds the card address.\n+  Register tmp2 = stub->tmp2();\n+  Register tmp3 = stub->tmp3();\n+\n+  __ bind(*stub->entry());\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, tmp3,  *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, tmp1, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), tmp2);\n+  __ b(*stub->continuation());\n+}\n+\n+#endif \/\/ COMPILER2\n+\n@@ -271,1 +393,1 @@\n-    g1_write_barrier_pre(masm, noreg, noreg, dst, tmp1, tmp2);\n+    g1_write_barrier_pre(masm, noreg, dst, tmp1, tmp2);\n@@ -298,1 +420,1 @@\n-    g1_write_barrier_pre(masm, store_addr, new_val, tmp1, tmp2, tmp3);\n+    g1_write_barrier_pre(masm, store_addr, tmp3 \/*pre_val*\/, tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.cpp","additions":207,"deletions":85,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+class G1PreBarrierStubC2;\n+class G1PostBarrierStubC2;\n@@ -46,1 +48,0 @@\n-                            Register new_val,\n@@ -73,0 +74,23 @@\n+\n+#ifdef COMPILER2\n+  void g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                               Register obj,\n+                               Register pre_val,\n+                               Register thread,\n+                               Register tmp1,\n+                               Register tmp2,\n+                               G1PreBarrierStubC2* c2_stub);\n+  void generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                    G1PreBarrierStubC2* stub) const;\n+  void g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                Register store_addr,\n+                                Register new_val,\n+                                Register thread,\n+                                Register tmp1,\n+                                Register tmp2,\n+                                Register tmp3,\n+                                G1PostBarrierStubC2* c2_stub);\n+  void generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                     G1PostBarrierStubC2* stub) const;\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/\/\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+source_hpp %{\n+\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+\n+%}\n+\n+source %{\n+\n+#include \"gc\/g1\/g1BarrierSetAssembler_arm.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+\n+static void write_barrier_pre(MacroAssembler* masm,\n+                              const MachNode* node,\n+                              Register obj,\n+                              Register pre_val,\n+                              Register tmp1,\n+                              Register tmp2,\n+                              RegSet preserve = RegSet(),\n+                              RegSet no_preserve = RegSet()) {\n+  if (!G1PreBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PreBarrierStubC2* const stub = G1PreBarrierStubC2::create(node);\n+  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {\n+    stub->preserve(*reg);\n+  }\n+  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {\n+    stub->dont_preserve(*reg);\n+  }\n+  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, Rthread, tmp1, tmp2, stub);\n+}\n+\n+static void write_barrier_post(MacroAssembler* masm,\n+                               const MachNode* node,\n+                               Register store_addr,\n+                               Register new_val,\n+                               Register tmp1,\n+                               Register tmp2,\n+                               Register tmp3) {\n+  if (!G1PostBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PostBarrierStubC2* const stub = G1PostBarrierStubC2::create(node);\n+  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, Rthread, tmp1, tmp2, tmp3, stub);\n+}\n+\n+%}\n+\n+instruct g1StoreP(indirect mem, iRegP src, iRegP tmp1, iRegP tmp2, iRegP tmp3, flagsReg icc)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreP mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL icc);\n+  ins_cost(2 * (MEMORY_REF_COST + BRANCH_COST));\n+  format %{ \"sd  $src, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ str($src$$Register, Address($mem$$Register));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $src$$Register  \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/,\n+                       $tmp3$$Register \/* tmp3 *\/);\n+  %}\n+  ins_pipe(istore_mem_reg);\n+%}\n+\n+instruct g1CompareAndSwapP(iRegI res, indirect mem, iRegP newval, iRegP tmp1, iRegP tmp2, iRegP tmp3, iRegP oldval, flagsReg ccr )\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  effect(KILL ccr, TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(4 * (MEMORY_REF_COST + BRANCH_COST));\n+  format %{ \"loop: \\n\\t\"\n+            \"LDREX    $tmp1, $mem\\t! If $oldval==[$mem] Then store $newval into [$mem]\\n\\t\"\n+            \"CMP      $tmp1, $oldval\\n\\t\"\n+            \"STREX.eq $tmp1, $newval, $mem\\n\\t\"\n+            \"MOV.ne   $tmp1, 0 \\n\\t\"\n+            \"EORS.eq  $tmp1,$tmp1, 1 \\n\\t\"\n+            \"B.eq     loop \\n\\t\"\n+            \"MOV      $res, $tmp1\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp2$$Register   \/* tmp1 *\/,\n+                      $tmp3$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    Label loop;\n+    __ bind(loop);\n+    __ ldrex($tmp1$$Register,$mem$$Address);\n+    __ cmp($tmp1$$Register, $oldval$$Register);\n+    __ strex($tmp1$$Register, $newval$$Register, $mem$$Address, eq);\n+    __ mov($tmp1$$Register, 0, ne);\n+    __ eors($tmp1$$Register, $tmp1$$Register, 1, eq);\n+    __ b(loop, eq);\n+    __ mov($res$$Register, $tmp1$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/,\n+                       $tmp3$$Register \/* tmp3 *\/);\n+  %}\n+  ins_pipe(long_memory_op);\n+%}\n+\n+\n+instruct g1GetAndSetP(indirect mem, iRegP newval, iRegP tmp1, iRegP tmp2, iRegP tmp3, iRegP preval, flagsReg ccr)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetP mem newval));\n+  effect(KILL ccr, TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(4 * (MEMORY_REF_COST + BRANCH_COST));\n+  format %{ \"loop: \\n\\t\"\n+            \"LDREX    $preval, $mem\\n\\t\"\n+            \"STREX    $tmp1, $newval, $mem\\n\\t\"\n+            \"CMP      $tmp1, 0 \\n\\t\"\n+            \"B.ne     loop \\n\\t\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register    \/* obj *\/,\n+                      $preval$$Register \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register   \/* tmp1 *\/,\n+                      $tmp2$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    Label loop;\n+    __ bind(loop);\n+    __ ldrex($preval$$Register,$mem$$Address);\n+    __ strex($tmp1$$Register, $newval$$Register, $mem$$Address);\n+    __ cmp($tmp1$$Register, 0);\n+    __ b(loop, ne);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register    \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register   \/* tmp1 *\/,\n+                       $tmp2$$Register   \/* tmp2 *\/,\n+                       $tmp3$$Register   \/* tmp3 *\/);\n+  %}\n+  ins_pipe(long_memory_op);\n+%}\n+\n+instruct g1LoadP(iRegP dst, indirect mem, iRegP tmp1, iRegP tmp2, flagsReg icc)\n+%{\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadP mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL icc);\n+  ins_cost(MEMORY_REF_COST + BRANCH_COST);\n+  format %{ \"ld  $dst, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    __ ldr($dst$$Register, Address($mem$$Register));\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(iload_mem);\n+%}\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1_arm.ad","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -34,0 +34,4 @@\n+#ifdef COMPILER2\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n+\n@@ -209,1 +213,11 @@\n-  Unimplemented(); \/\/ This must be implemented to support late barrier expansion.\n+  if (!OptoReg::is_reg(opto_reg)) {\n+    return OptoReg::Bad;\n+  }\n+\n+  const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+  if (!vm_reg->is_valid()){\n+    \/\/ skip APSR and FPSCR\n+    return OptoReg::Bad;\n+  }\n+\n+  return opto_reg;\n@@ -212,0 +226,40 @@\n+void SaveLiveRegisters::initialize(BarrierStubC2* stub) {\n+  \/\/ Record registers that needs to be saved\/restored\n+  RegMaskIterator rmi(stub->preserve_set());\n+  while (rmi.has_next()) {\n+    const OptoReg::Name opto_reg = rmi.next();\n+    if (OptoReg::is_reg(opto_reg)) {\n+      const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+      if (vm_reg->is_Register()) {\n+        gp_regs += RegSet::of(vm_reg->as_Register());\n+      } else if (vm_reg->is_FloatRegister()) {\n+        fp_regs += FloatRegSet::of(vm_reg->as_FloatRegister());\n+      } else {\n+        fatal(\"Unknown register type\");\n+      }\n+    }\n+  }\n+  \/\/ Remove C-ABI SOE registers that will be updated\n+  gp_regs -= RegSet::range(R4, R11) + RegSet::of(R13, R15);\n+\n+  \/\/ Remove C-ABI SOE fp registers\n+  fp_regs -= FloatRegSet::range(S16, S31);\n+}\n+\n+SaveLiveRegisters::SaveLiveRegisters(MacroAssembler* masm, BarrierStubC2* stub)\n+  : masm(masm),\n+    gp_regs(),\n+    fp_regs() {\n+  \/\/ Figure out what registers to save\/restore\n+  initialize(stub);\n+\n+  \/\/ Save registers\n+  if (gp_regs.size() > 0) __ push(RegisterSet::from(gp_regs));\n+  if (fp_regs.size() > 0) __ fpush(FloatRegisterSet::from(fp_regs));\n+}\n+\n+SaveLiveRegisters::~SaveLiveRegisters() {\n+  \/\/ Restore registers\n+  if (fp_regs.size() > 0) __ fpop(FloatRegisterSet::from(fp_regs));\n+  if (gp_regs.size() > 0) __ pop(RegisterSet::from(gp_regs));\n+}\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.cpp","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/regmask.hpp\"\n@@ -35,0 +36,1 @@\n+class BarrierStubC2;\n@@ -72,0 +74,22 @@\n+#ifdef COMPILER2\n+\/\/ This class saves and restores the registers that need to be preserved across\n+\/\/ the runtime call represented by a given C2 barrier stub. Use as follows:\n+\/\/ {\n+\/\/   SaveLiveRegisters save(masm, stub);\n+\/\/   ..\n+\/\/   __ bl(...);\n+\/\/   ..\n+\/\/ }\n+class SaveLiveRegisters {\n+private:\n+  MacroAssembler* const masm;\n+  RegSet                gp_regs;\n+  FloatRegSet           fp_regs;\n+\n+public:\n+  void initialize(BarrierStubC2* stub);\n+  SaveLiveRegisters(MacroAssembler* masm, BarrierStubC2* stub);\n+  ~SaveLiveRegisters();\n+};\n+\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -306,0 +306,25 @@\n+typedef AbstractRegSet<Register> RegSet;\n+typedef AbstractRegSet<FloatRegister> FloatRegSet;\n+\n+template <>\n+inline Register AbstractRegSet<Register>::first() {\n+  if (_bitset == 0) { return noreg; }\n+  return as_Register(count_trailing_zeros(_bitset));\n+}\n+\n+\n+template <>\n+inline FloatRegister AbstractRegSet<FloatRegister>::first() {\n+  uint32_t first = _bitset & -_bitset;\n+  return first ? as_FloatRegister(exact_log2(first)) : fnoreg;\n+}\n+\n+template <>\n+inline FloatRegister AbstractRegSet<FloatRegister>::last() {\n+  if (_bitset == 0) { return fnoreg; }\n+  int last = max_size() - 1 - count_leading_zeros(_bitset);\n+  return as_FloatRegister(last);\n+}\n+\n+\n+\n","filename":"src\/hotspot\/cpu\/arm\/register_arm.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+  case Interpreter::java_lang_math_tanh:\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,4 @@\n-#endif\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -48,0 +51,7 @@\n+static void generate_marking_inactive_test(MacroAssembler* masm) {\n+  int active_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n+  assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+  __ lbz(R0, active_offset, R16_thread);  \/\/ tmp1 := *(mark queue active address)\n+  __ cmpwi(CCR0, R0, 0);\n+}\n+\n@@ -61,7 +71,1 @@\n-    if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-      __ lwz(R0, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()), R16_thread);\n-    } else {\n-      guarantee(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-      __ lbz(R0, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()), R16_thread);\n-    }\n-    __ cmpdi(CCR0, R0, 0);\n+    generate_marking_inactive_test(masm);\n@@ -112,0 +116,15 @@\n+static void generate_queue_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                     const Register value, const Register temp) {\n+  assert_different_registers(value, temp);\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ ld(temp, in_bytes(index_offset), R16_thread);  \/\/ temp := *(index address)\n+  __ cmpdi(CCR0, temp, 0);                          \/\/ jump to runtime if index == 0 (full buffer)\n+  __ beq(CCR0, runtime);\n+  \/\/ The buffer is not full, store value into it.\n+  __ ld(R0, in_bytes(buffer_offset), R16_thread);   \/\/ R0 := buffer address\n+  __ addi(temp, temp, -wordSize);                   \/\/ temp := next index\n+  __ std(temp, in_bytes(index_offset), R16_thread); \/\/ *(index address) := next index\n+  __ stdx(value, temp, R0);                         \/\/ *(buffer address + next index) := value\n+}\n+\n@@ -116,0 +135,2 @@\n+  assert_different_registers(pre_val, tmp1, tmp2);\n+\n@@ -120,1 +141,7 @@\n-  if (preloaded) {\n+  \/\/ Determine necessary runtime invocation preservation measures\n+  const bool needs_frame = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR;\n+  const bool preserve_gp_registers = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR_GP_REGS;\n+  const bool preserve_fp_registers = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS;\n+  int nbytes_save = 0;\n+\n+  if (pre_val->is_volatile() && preloaded && !preserve_gp_registers) {\n@@ -124,5 +151,2 @@\n-    assert_different_registers(pre_val, tmp1, tmp2);\n-    if (pre_val->is_volatile()) {\n-      nv_save = !tmp1->is_volatile() ? tmp1 : tmp2;\n-      assert(!nv_save->is_volatile(), \"need one nv temp register if pre_val lives in volatile register\");\n-    }\n+    nv_save = !tmp1->is_volatile() ? tmp1 : tmp2;\n+    assert(!nv_save->is_volatile(), \"need one nv temp register if pre_val lives in volatile register\");\n@@ -133,8 +157,1 @@\n-  \/\/ Is marking active?\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ lwz(tmp1, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()), R16_thread);\n-  } else {\n-    guarantee(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ lbz(tmp1, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()), R16_thread);\n-  }\n-  __ cmpdi(CCR0, tmp1, 0);\n+  generate_marking_inactive_test(masm);\n@@ -178,12 +195,2 @@\n-  const Register Rbuffer = tmp1, Rindex = tmp2;\n-\n-  __ ld(Rindex, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()), R16_thread);\n-  __ cmpdi(CCR0, Rindex, 0);\n-  __ beq(CCR0, runtime); \/\/ If index == 0, goto runtime.\n-  __ ld(Rbuffer, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()), R16_thread);\n-\n-  __ addi(Rindex, Rindex, -wordSize); \/\/ Decrement index.\n-  __ std(Rindex, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()), R16_thread);\n-\n-  \/\/ Record the previous value.\n-  __ stdx(pre_val, Rbuffer, Rindex);\n+  generate_queue_insertion(masm, G1ThreadLocalData::satb_mark_queue_index_offset(), G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                           runtime, pre_val, tmp1);\n@@ -194,6 +201,0 @@\n-  \/\/ Determine necessary runtime invocation preservation measures\n-  const bool needs_frame = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR;\n-  const bool preserve_gp_registers = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR_GP_REGS;\n-  const bool preserve_fp_registers = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS;\n-  int nbytes_save = 0;\n-\n@@ -213,1 +214,1 @@\n-  if (pre_val->is_volatile() && preloaded && !preserve_gp_registers) {\n+  if (nv_save != noreg) {\n@@ -217,1 +218,1 @@\n-  if (pre_val->is_volatile() && preloaded && !preserve_gp_registers) {\n+  if (nv_save != noreg) {\n@@ -233,0 +234,20 @@\n+static void generate_region_crossing_test(MacroAssembler* masm, const Register store_addr, const Register new_val) {\n+  __ xorr(R0, store_addr, new_val);                  \/\/ tmp1 := store address ^ new value\n+  __ srdi_(R0, R0, G1HeapRegion::LogOfHRGrainBytes); \/\/ tmp1 := ((store address ^ new value) >> LogOfHRGrainBytes)\n+}\n+\n+static Address generate_card_young_test(MacroAssembler* masm, const Register store_addr, const Register tmp1, const Register tmp2) {\n+  CardTableBarrierSet* ct = barrier_set_cast<CardTableBarrierSet>(BarrierSet::barrier_set());\n+  __ load_const_optimized(tmp1, (address)(ct->card_table()->byte_map_base()), tmp2);\n+  __ srdi(tmp2, store_addr, CardTable::card_shift());        \/\/ tmp1 := card address relative to card table base\n+  __ lbzx(R0, tmp1, tmp2);                                   \/\/ tmp1 := card address\n+  __ cmpwi(CCR0, R0, (int)G1CardTable::g1_young_card_val());\n+  return Address(tmp1, tmp2); \/\/ return card address\n+}\n+\n+static void generate_card_dirty_test(MacroAssembler* masm, Address card_addr) {\n+  __ membar(Assembler::StoreLoad);                        \/\/ Must reload after StoreLoad membar due to concurrent refinement\n+  __ lbzx(R0, card_addr.base(), card_addr.index());       \/\/ tmp2 := card\n+  __ cmpwi(CCR0, R0, (int)G1CardTable::dirty_card_val()); \/\/ tmp2 := card == dirty_card_val?\n+}\n+\n@@ -244,3 +265,1 @@\n-  \/\/ Does store cross heap regions?\n-  __ xorr(tmp1, store_addr, new_val);\n-  __ srdi_(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n+  generate_region_crossing_test(masm, store_addr, new_val);\n@@ -260,10 +279,1 @@\n-  \/\/ Storing region crossing non-null, is card already dirty?\n-  const Register Rcard_addr = tmp1;\n-  Register Rbase = tmp2;\n-  __ load_const_optimized(Rbase, (address)(ct->card_table()->byte_map_base()), \/*temp*\/ tmp3);\n-\n-  __ srdi(Rcard_addr, store_addr, CardTable::card_shift());\n-\n-  \/\/ Get the address of the card.\n-  __ lbzx(\/*card value*\/ tmp3, Rbase, Rcard_addr);\n-  __ cmpwi(CCR0, tmp3, (int)G1CardTable::g1_young_card_val());\n+  Address card_addr = generate_card_young_test(masm, store_addr, tmp1, tmp2);\n@@ -272,3 +282,1 @@\n-  __ membar(Assembler::StoreLoad);\n-  __ lbzx(\/*card value*\/ tmp3, Rbase, Rcard_addr);  \/\/ Reload after membar.\n-  __ cmpwi(CCR0, tmp3 \/* card value *\/, (int)G1CardTable::dirty_card_val());\n+  generate_card_dirty_test(masm, card_addr);\n@@ -277,15 +285,2 @@\n-  \/\/ Storing a region crossing, non-null oop, card is clean.\n-  \/\/ Dirty card and log.\n-  __ li(tmp3, (int)G1CardTable::dirty_card_val());\n-  \/\/release(); \/\/ G1: oops are allowed to get visible after dirty marking.\n-  __ stbx(tmp3, Rbase, Rcard_addr);\n-\n-  __ add(Rcard_addr, Rbase, Rcard_addr); \/\/ This is the address which needs to get enqueued.\n-  Rbase = noreg; \/\/ end of lifetime\n-\n-  const Register Rqueue_index = tmp2,\n-                 Rqueue_buf   = tmp3;\n-  __ ld(Rqueue_index, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()), R16_thread);\n-  __ cmpdi(CCR0, Rqueue_index, 0);\n-  __ beq(CCR0, runtime); \/\/ index == 0 then jump to runtime\n-  __ ld(Rqueue_buf, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()), R16_thread);\n+  __ li(R0, (int)G1CardTable::dirty_card_val());\n+  __ stbx(R0, card_addr.base(), card_addr.index()); \/\/ *(card address) := dirty_card_val\n@@ -293,2 +288,2 @@\n-  __ addi(Rqueue_index, Rqueue_index, -wordSize); \/\/ decrement index\n-  __ std(Rqueue_index, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()), R16_thread);\n+  Register Rcard_addr = tmp3;\n+  __ add(Rcard_addr, card_addr.base(), card_addr.index()); \/\/ This is the address which needs to get enqueued.\n@@ -296,1 +291,4 @@\n-  __ stdx(Rcard_addr, Rqueue_buf, Rqueue_index); \/\/ store card\n+  generate_queue_insertion(masm,\n+                           G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                           G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                           runtime, Rcard_addr, tmp1);\n@@ -395,0 +393,136 @@\n+#ifdef COMPILER2\n+\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register arg, const address runtime_path) {\n+  SaveLiveRegisters save_registers(masm, stub);\n+  __ call_VM_leaf(runtime_path, arg, R16_thread);\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register tmp1,\n+                                                    Register tmp2,\n+                                                    G1PreBarrierStubC2* stub) {\n+  assert_different_registers(obj, tmp1, tmp2, R0);\n+  assert_different_registers(pre_val, tmp1, R0);\n+  assert(!UseCompressedOops || tmp2 != noreg, \"tmp2 needed with CompressedOops\");\n+\n+  stub->initialize_registers(obj, pre_val, R16_thread, tmp1, tmp2);\n+\n+  generate_marking_inactive_test(masm);\n+  __ bc_far_optimized(Assembler::bcondCRbiIs0, __ bi0(CCR0, Assembler::equal), *stub->entry());\n+\n+  __ bind(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register obj = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register tmp1 = stub->tmp1();\n+\n+  __ bind(*stub->entry());\n+\n+  if (obj != noreg) {\n+    \/\/ Note: C2 currently doesn't use implicit null checks with barriers.\n+    \/\/ Otherwise, obj could be null and the following instruction would raise a SIGSEGV.\n+    if (UseCompressedOops) {\n+      __ lwz(pre_val, 0, obj);\n+    } else {\n+      __ ld(pre_val, 0, obj);\n+    }\n+  }\n+  __ cmpdi(CCR0, pre_val, 0);\n+  __ bc_far_optimized(Assembler::bcondCRbiIs1, __ bi0(CCR0, Assembler::equal), *stub->continuation());\n+\n+  Register pre_val_decoded = pre_val;\n+  if (UseCompressedOops) {\n+    pre_val_decoded = __ decode_heap_oop_not_null(stub->tmp2(), pre_val);\n+  }\n+\n+  generate_queue_insertion(masm,\n+                           G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                           G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                           runtime, pre_val_decoded, tmp1);\n+  __ b(*stub->continuation());\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val_decoded, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry));\n+  __ b(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register tmp1,\n+                                                     Register tmp2,\n+                                                     G1PostBarrierStubC2* stub,\n+                                                     bool decode_new_val) {\n+  assert_different_registers(store_addr, new_val, tmp1, R0);\n+  assert_different_registers(store_addr, tmp1, tmp2, R0);\n+\n+  stub->initialize_registers(R16_thread, tmp1, tmp2);\n+\n+  bool null_check_required = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  Register new_val_decoded = new_val;\n+\n+  if (decode_new_val) {\n+    assert(UseCompressedOops, \"or should not be here\");\n+    if (null_check_required && CompressedOops::base() != nullptr) {\n+      \/\/ We prefer doing the null check after the region crossing check.\n+      \/\/ Only compressed oop modes with base != null require a null check here.\n+      __ cmpwi(CCR0, new_val, 0);\n+      __ beq(CCR0, *stub->continuation());\n+      null_check_required = false;\n+    }\n+    new_val_decoded = __ decode_heap_oop_not_null(tmp2, new_val);\n+  }\n+\n+  generate_region_crossing_test(masm, store_addr, new_val_decoded);\n+  __ beq(CCR0, *stub->continuation());\n+\n+  \/\/ crosses regions, storing null?\n+  if (null_check_required) {\n+    __ cmpdi(CCR0, new_val_decoded, 0);\n+    __ beq(CCR0, *stub->continuation());\n+  }\n+\n+  Address card_addr = generate_card_young_test(masm, store_addr, tmp1, tmp2);\n+  assert(card_addr.base() == tmp1 && card_addr.index() == tmp2, \"needed by post barrier stub\");\n+  __ bc_far_optimized(Assembler::bcondCRbiIs0, __ bi0(CCR0, Assembler::equal), *stub->entry());\n+\n+  __ bind(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Address card_addr(stub->tmp1(), stub->tmp2()); \/\/ See above.\n+\n+  __ bind(*stub->entry());\n+\n+  generate_card_dirty_test(masm, card_addr);\n+  __ bc_far_optimized(Assembler::bcondCRbiIs1, __ bi0(CCR0, Assembler::equal), *stub->continuation());\n+\n+  __ li(R0, (int)G1CardTable::dirty_card_val());\n+  __ stbx(R0, card_addr.base(), card_addr.index()); \/\/ *(card address) := dirty_card_val\n+\n+  Register Rcard_addr = stub->tmp1();\n+  __ add(Rcard_addr, card_addr.base(), card_addr.index()); \/\/ This is the address which needs to get enqueued.\n+\n+  generate_queue_insertion(masm,\n+                           G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                           G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                           runtime, Rcard_addr, stub->tmp2());\n+  __ b(*stub->continuation());\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, Rcard_addr, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry));\n+  __ b(*stub->continuation());\n+}\n+\n+#endif \/\/ COMPILER2\n+\n@@ -473,7 +607,1 @@\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ lwz(tmp, satb_q_active_byte_offset, R16_thread);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ lbz(tmp, satb_q_active_byte_offset, R16_thread);\n-  }\n-  __ cmpdi(CCR0, tmp, 0);\n+  generate_marking_inactive_test(sasm);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":211,"deletions":83,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif\n+\n@@ -37,0 +41,2 @@\n+class G1PreBarrierStubC2;\n+class G1PostBarrierStubC2;\n@@ -62,0 +68,19 @@\n+#ifdef COMPILER2\n+  void g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                               Register obj,\n+                               Register pre_val,\n+                               Register tmp1,\n+                               Register tmp2,\n+                               G1PreBarrierStubC2* c2_stub);\n+  void generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                    G1PreBarrierStubC2* stub) const;\n+  void g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                Register store_addr,\n+                                Register new_val,\n+                                Register tmp1,\n+                                Register tmp2,\n+                                G1PostBarrierStubC2* c2_stub,\n+                                bool decode_new_val);\n+  void generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                     G1PostBarrierStubC2* stub) const;\n+#endif\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,684 @@\n+\/\/\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2024 SAP SE. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+source_hpp %{\n+\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+\n+%}\n+\n+source %{\n+\n+#include \"gc\/g1\/g1BarrierSetAssembler_ppc.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+\n+static void pre_write_barrier(MacroAssembler* masm,\n+                              const MachNode* node,\n+                              Register obj,\n+                              Register pre_val,\n+                              Register tmp1,\n+                              Register tmp2 = noreg, \/\/ only needed with CompressedOops when pre_val needs to be preserved\n+                              RegSet preserve = RegSet(),\n+                              RegSet no_preserve = RegSet()) {\n+  if (!G1PreBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PreBarrierStubC2* const stub = G1PreBarrierStubC2::create(node);\n+  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {\n+    stub->preserve(*reg);\n+  }\n+  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {\n+    stub->dont_preserve(*reg);\n+  }\n+  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, tmp1, (tmp2 != noreg) ? tmp2 : pre_val, stub);\n+}\n+\n+static void post_write_barrier(MacroAssembler* masm,\n+                               const MachNode* node,\n+                               Register store_addr,\n+                               Register new_val,\n+                               Register tmp1,\n+                               Register tmp2,\n+                               bool decode_new_val = false) {\n+  if (!G1PostBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PostBarrierStubC2* const stub = G1PostBarrierStubC2::create(node);\n+  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, tmp1, tmp2, stub, decode_new_val);\n+}\n+\n+%}\n+\n+instruct g1StoreP(indirect mem, iRegPsrc src, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreP mem src));\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr0);\n+  ins_cost(2 * MEMORY_REF_COST);\n+  format %{ \"std    $mem, $src\\t# ptr\" %}\n+  ins_encode %{\n+    pre_write_barrier(masm, this,\n+                      $mem$$Register,\n+                      $tmp1$$Register,\n+                      $tmp2$$Register,\n+                      noreg,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ std($src$$Register, 0, $mem$$Register);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp1$$Register,\n+                       $tmp2$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1StoreN(indirect mem, iRegNsrc src, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem src));\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr0);\n+  ins_cost(2 * MEMORY_REF_COST);\n+  format %{ \"stw    $mem, $src\\t# ptr\" %}\n+  ins_encode %{\n+    pre_write_barrier(masm, this,\n+                      $mem$$Register,\n+                      $tmp1$$Register,\n+                      $tmp2$$Register,\n+                      noreg,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ stw($src$$Register, 0, $mem$$Register);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp1$$Register,\n+                       $tmp2$$Register,\n+                       true \/* decode_new_val *\/);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1EncodePAndStoreN(indirect mem, iRegPsrc src, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem (EncodeP src)));\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr0);\n+  ins_cost(2 * MEMORY_REF_COST);\n+  format %{ \"encode_heap_oop $src\\n\\t\"\n+            \"stw   $mem, $src\\t# ptr\" %}\n+  ins_encode %{\n+    pre_write_barrier(masm, this,\n+                      $mem$$Register,\n+                      $tmp1$$Register,\n+                      $tmp2$$Register,\n+                      noreg,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    Register encoded_oop = noreg;\n+    if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+      encoded_oop = __ encode_heap_oop($tmp2$$Register, $src$$Register);\n+    } else {\n+      encoded_oop = __ encode_heap_oop_not_null($tmp2$$Register, $src$$Register);\n+    }\n+    __ stw(encoded_oop, 0, $mem$$Register);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp1$$Register,\n+                       $tmp2$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1CompareAndExchangeP(iRegPdst res, indirect mem, iRegPsrc oldval, iRegPsrc newval, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndExchangeNode*)n)->order() != MemNode::acquire && ((CompareAndExchangeNode*)n)->order() != MemNode::seqcst));\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr0);\n+  format %{ \"cmpxchgd $newval, $mem\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ cmpxchgd(CCR0, $res$$Register, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register,\n+                      $tmp1$$Register,\n+                      $tmp2$$Register,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp1$$Register,\n+                       $tmp2$$Register);\n+    __ bind(no_update);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1CompareAndExchangeP_acq(iRegPdst res, indirect mem, iRegPsrc oldval, iRegPsrc newval, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndExchangeNode*)n)->order() == MemNode::acquire || ((CompareAndExchangeNode*)n)->order() == MemNode::seqcst));\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr0);\n+  format %{ \"cmpxchgd acq $newval, $mem\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ cmpxchgd(CCR0, $res$$Register, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register,\n+                      $tmp1$$Register,\n+                      $tmp2$$Register,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp1$$Register,\n+                       $tmp2$$Register);\n+    __ bind(no_update);\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n+      __ sync();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1CompareAndExchangeN(iRegNdst res, indirect mem, iRegNsrc oldval, iRegNsrc newval, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndExchangeNode*)n)->order() != MemNode::acquire && ((CompareAndExchangeNode*)n)->order() != MemNode::seqcst));\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr0);\n+  format %{ \"cmpxchgw $newval, $mem\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ cmpxchgw(CCR0, $res$$Register, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register,\n+                      $tmp1$$Register,\n+                      $tmp2$$Register,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp1$$Register,\n+                       $tmp2$$Register,\n+                       true \/* decode_new_val *\/);\n+    __ bind(no_update);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1CompareAndExchangeN_acq(iRegNdst res, indirect mem, iRegNsrc oldval, iRegNsrc newval, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndExchangeNode*)n)->order() == MemNode::acquire || ((CompareAndExchangeNode*)n)->order() == MemNode::seqcst));\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr0);\n+  format %{ \"cmpxchgw acq $newval, $mem\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ cmpxchgw(CCR0, $res$$Register, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register,\n+                      $tmp1$$Register,\n+                      $tmp2$$Register,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp1$$Register,\n+                       $tmp2$$Register,\n+                       true \/* decode_new_val *\/);\n+    __ bind(no_update);\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n+      __ sync();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1CompareAndSwapP(iRegIdst res, indirect mem, iRegPsrc oldval, iRegPsrc newval, iRegPdst tmp, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst));\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr0);\n+  format %{ \"CMPXCHGD $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ li($res$$Register, 0);\n+    __ cmpxchgd(CCR0, R0, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp$$Register,\n+                      $res$$Register \/* temp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp$$Register,\n+                       $res$$Register \/* temp *\/);\n+    __ li($res$$Register, 1);\n+    __ bind(no_update);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1CompareAndSwapP_acq(iRegIdst res, indirect mem, iRegPsrc oldval, iRegPsrc newval, iRegPdst tmp, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst));\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr0);\n+  format %{ \"CMPXCHGD acq $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ li($res$$Register, 0);\n+    __ cmpxchgd(CCR0, R0, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp$$Register,\n+                      $res$$Register \/* temp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp$$Register,\n+                       $res$$Register \/* temp *\/);\n+    __ li($res$$Register, 1);\n+    __ bind(no_update);\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n+      __ sync();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1CompareAndSwapN(iRegIdst res, indirect mem, iRegNsrc oldval, iRegNsrc newval, iRegPdst tmp, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst));\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr0);\n+  format %{ \"CMPXCHGW $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ li($res$$Register, 0);\n+    __ cmpxchgw(CCR0, R0, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp$$Register,\n+                      $res$$Register \/* temp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp$$Register,\n+                       $res$$Register \/* temp *\/,\n+                       true \/* decode_new_val *\/);\n+    __ li($res$$Register, 1);\n+    __ bind(no_update);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1CompareAndSwapN_acq(iRegIdst res, indirect mem, iRegNsrc oldval, iRegNsrc newval, iRegPdst tmp, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst));\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr0);\n+  format %{ \"CMPXCHGW acq $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ li($res$$Register, 0);\n+    __ cmpxchgw(CCR0, R0, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp$$Register,\n+                      $res$$Register \/* temp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp$$Register,\n+                       $res$$Register \/* temp *\/,\n+                       true \/* decode_new_val *\/);\n+    __ li($res$$Register, 1);\n+    __ bind(no_update);\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n+      __ sync();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct weakG1CompareAndSwapP(iRegIdst res, indirect mem, iRegPsrc oldval, iRegPsrc newval, iRegPdst tmp, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr0);\n+  format %{ \"weak CMPXCHGD $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ li($res$$Register, 0);\n+    __ cmpxchgd(CCR0, R0, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp$$Register,\n+                      $res$$Register \/* temp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp$$Register,\n+                       $res$$Register \/* temp *\/);\n+    __ li($res$$Register, 1);\n+    __ bind(no_update);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct weakG1CompareAndSwapP_acq(iRegIdst res, indirect mem, iRegPsrc oldval, iRegPsrc newval, iRegPdst tmp, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr0);\n+  format %{ \"weak CMPXCHGD acq $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ li($res$$Register, 0);\n+    __ cmpxchgd(CCR0, R0, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp$$Register,\n+                      $res$$Register \/* temp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp$$Register,\n+                       $res$$Register \/* temp *\/);\n+    __ li($res$$Register, 1);\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n+      __ sync();\n+    }\n+    __ bind(no_update); \/\/ weak version requires no memory barrier on failure\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct weakG1CompareAndSwapN(iRegIdst res, indirect mem, iRegNsrc oldval, iRegNsrc newval, iRegPdst tmp, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst));\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr0);\n+  format %{ \"weak CMPXCHGW $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ li($res$$Register, 0);\n+    __ cmpxchgw(CCR0, R0, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp$$Register,\n+                      $res$$Register \/* temp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp$$Register,\n+                       $res$$Register \/* temp *\/,\n+                       true \/* decode_new_val *\/);\n+    __ li($res$$Register, 1);\n+    __ bind(no_update);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct weakG1CompareAndSwapN_acq(iRegIdst res, indirect mem, iRegNsrc oldval, iRegNsrc newval, iRegPdst tmp, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0 &&\n+            (((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst));\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr0);\n+  format %{ \"weak CMPXCHGW acq $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    Label no_update;\n+    __ li($res$$Register, 0);\n+    __ cmpxchgw(CCR0, R0, $oldval$$Register, $newval$$Register, $mem$$Register,\n+                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n+                noreg, &no_update, true, true);\n+    \/\/ Pass oldval to SATB which is the only value which can get overwritten.\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp$$Register,\n+                      $res$$Register \/* temp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp$$Register,\n+                       $res$$Register \/* temp *\/,\n+                       true \/* decode_new_val *\/);\n+    __ li($res$$Register, 1);\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n+      __ sync();\n+    }\n+    __ bind(no_update); \/\/ weak version requires no memory barrier on failure\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1GetAndSetP(iRegPdst res, indirect mem, iRegPsrc newval, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (GetAndSetP mem newval));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr0);\n+  format %{ \"GetAndSetP    $newval, $mem\" %}\n+  ins_encode %{\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    __ getandsetd($res$$Register, $newval$$Register, $mem$$Register,\n+                  MacroAssembler::cmpxchgx_hint_atomic_update());\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg \/* obj *\/,\n+                      $res$$Register \/* res *\/,\n+                      $tmp1$$Register,\n+                      $tmp2$$Register,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp1$$Register,\n+                       $tmp2$$Register);\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      __ sync();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1GetAndSetN(iRegNdst res, indirect mem, iRegNsrc newval, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (GetAndSetN mem newval));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr0);\n+  format %{ \"GetAndSetN    $newval, $mem\" %}\n+  ins_encode %{\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    __ getandsetw($res$$Register, $newval$$Register, $mem$$Register,\n+                  MacroAssembler::cmpxchgx_hint_atomic_update());\n+    \/\/ Can be done after cmpxchg because there's no safepoint here.\n+    pre_write_barrier(masm, this,\n+                      noreg \/* obj *\/,\n+                      $res$$Register \/* res *\/,\n+                      $tmp1$$Register,\n+                      $tmp2$$Register,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/);\n+    post_write_barrier(masm, this,\n+                       $mem$$Register,\n+                       $newval$$Register,\n+                       $tmp1$$Register,\n+                       $tmp2$$Register,\n+                       true \/* decode_new_val *\/);\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      __ sync();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1LoadP(iRegPdst dst, memoryAlg4 mem, iRegPdst tmp, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_Load()->is_unordered() && n->as_Load()->barrier_data() != 0);\n+  \/\/ This instruction does not need an acquiring counterpart because it is only\n+  \/\/ used for reference loading (Reference::get()).\n+  match(Set dst (LoadP mem));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr0);\n+  ins_cost(2 * MEMORY_REF_COST);\n+  format %{ \"ld    $dst, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    __ ld($dst$$Register, $mem$$disp, $mem$$base$$Register);\n+    pre_write_barrier(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register \/* pre_val *\/,\n+                      $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct g1LoadN(iRegNdst dst, memoryAlg4 mem, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr0)\n+%{\n+  predicate(UseG1GC && n->as_Load()->is_unordered() && n->as_Load()->barrier_data() != 0);\n+  \/\/ This instruction does not need an acquiring counterpart because it is only\n+  \/\/ used for reference loading (Reference::get()).\n+  match(Set dst (LoadN mem));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, KILL cr0);\n+  ins_cost(2 * MEMORY_REF_COST);\n+  format %{ \"lwz    $dst, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    __ lwz($dst$$Register, $mem$$disp, $mem$$base$$Register);\n+    pre_write_barrier(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register,\n+                      $tmp1$$Register,\n+                      $tmp2$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1_ppc.ad","additions":684,"deletions":0,"binary":false,"changes":684,"status":"added"},{"patch":"@@ -147,1 +147,1 @@\n-    jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop_entry);\n+    jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop);\n@@ -149,1 +149,1 @@\n-    jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop_entry);\n+    jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop);\n@@ -315,1 +315,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, R16_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, R16_thread);\n@@ -977,1 +977,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), R0_pre_val, R16_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), R0_pre_val, R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2718,0 +2718,11 @@\n+\n+  \/\/ Set owner to null.\n+  \/\/ Release to satisfy the JMM\n+  release();\n+  li(temp, 0);\n+  std(temp, in_bytes(ObjectMonitor::owner_offset()), current_header);\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  \/\/ StoreLoad achieves this.\n+  membar(StoreLoad);\n+\n+  \/\/ Check if the entry lists are empty.\n@@ -2722,3 +2733,13 @@\n-  bne(flag, failure);\n-  release();\n-  std(temp, in_bytes(ObjectMonitor::owner_offset()), current_header);\n+  beq(flag, success);  \/\/ If so we are done.\n+\n+  \/\/ Check if there is a successor.\n+  ld(temp, in_bytes(ObjectMonitor::succ_offset()), current_header);\n+  cmpdi(flag, temp, 0);\n+  bne(flag, success);  \/\/ If so we are done.\n+\n+  \/\/ Save the monitor pointer in the current thread, so we can try\n+  \/\/ to reacquire the lock in SharedRuntime::monitor_exit_helper().\n+  std(current_header, in_bytes(JavaThread::unlocked_inflated_monitor_offset()), R16_thread);\n+\n+  crxor(flag, Assembler::equal, flag, Assembler::equal); \/\/ Set flag = NE => slow path\n+  b(failure);\n@@ -3031,1 +3052,1 @@\n-    Label release_;\n+    Label set_eq_unlocked;\n@@ -3034,0 +3055,9 @@\n+    \/\/ Set owner to null.\n+    \/\/ Release to satisfy the JMM\n+    release();\n+    li(t, 0);\n+    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    \/\/ We need a full fence after clearing owner to avoid stranding.\n+    \/\/ StoreLoad achieves this.\n+    membar(StoreLoad);\n+\n@@ -3039,1 +3069,10 @@\n-    beq(CCR0, release_);\n+    beq(CCR0, unlocked); \/\/ If so we are done.\n+\n+    \/\/ Check if there is a successor.\n+    ld(t, in_bytes(ObjectMonitor::succ_offset()), monitor);\n+    cmpdi(CCR0, t, 0);\n+    bne(CCR0, set_eq_unlocked); \/\/ If so we are done.\n+\n+    \/\/ Save the monitor pointer in the current thread, so we can try\n+    \/\/ to reacquire the lock in SharedRuntime::monitor_exit_helper().\n+    std(monitor, in_bytes(JavaThread::unlocked_inflated_monitor_offset()), R16_thread);\n@@ -3041,4 +3080,1 @@\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    crxor(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ Set flag = NE => slow path\n@@ -3047,5 +3083,2 @@\n-    bind(release_);\n-    \/\/ Set owner to null.\n-    release();\n-    \/\/ t contains 0\n-    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    bind(set_eq_unlocked);\n+    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ Set flag = EQ => fast path\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":47,"deletions":14,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1003,0 +1003,4 @@\n+  if (is_encode_and_store_pattern(n, m)) {\n+    mstack.push(m, Visit);\n+    return true;\n+  }\n@@ -5410,1 +5414,1 @@\n-  predicate(n->as_Load()->is_unordered() || followed_by_acquire(n));\n+  predicate((n->as_Load()->is_unordered() || followed_by_acquire(n)) && n->as_Load()->barrier_data() == 0);\n@@ -5422,0 +5426,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -5435,1 +5440,1 @@\n-  predicate(_kids[0]->_leaf->as_Load()->is_unordered() && CompressedOops::shift() == 0);\n+  predicate(_kids[0]->_leaf->as_Load()->is_unordered() && CompressedOops::shift() == 0 && _kids[0]->_leaf->as_Load()->barrier_data() == 0);\n@@ -6426,0 +6431,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -6601,1 +6607,1 @@\n-            CompressedOops::base() ==0);\n+            CompressedOops::base() == nullptr);\n@@ -6698,1 +6704,1 @@\n-            CompressedOops::base() != 0);\n+            CompressedOops::base() != nullptr);\n@@ -6710,1 +6716,1 @@\n-            CompressedOops::base() == 0);\n+            CompressedOops::base() == nullptr);\n@@ -6828,1 +6834,1 @@\n-            CompressedOops::base() != 0);\n+            CompressedOops::base() != nullptr);\n@@ -7480,0 +7486,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -7679,1 +7686,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && n->as_LoadStore()->barrier_data() == 0);\n@@ -7693,1 +7700,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst);\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && n->as_LoadStore()->barrier_data() == 0);\n@@ -7942,1 +7949,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && n->as_LoadStore()->barrier_data() == 0);\n@@ -7956,1 +7963,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst);\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && n->as_LoadStore()->barrier_data() == 0);\n@@ -8265,0 +8272,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/count_trailing_zeros.hpp\"\n@@ -558,0 +559,8 @@\n+template <>\n+inline Register AbstractRegSet<Register>::first() {\n+  if (_bitset == 0) { return noreg; }\n+  return as_Register(count_trailing_zeros(_bitset));\n+}\n+\n+typedef AbstractRegSet<Register> RegSet;\n+\n","filename":"src\/hotspot\/cpu\/ppc\/register_ppc.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -168,0 +168,1 @@\n+  Register owner_addr = tmp1Reg;\n@@ -225,4 +226,2 @@\n-  ld(t0, Address(tmp, ObjectMonitor::EntryList_offset()));\n-  ld(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n-  orr(t0, t0, disp_hdr); \/\/ Will be 0 if both are 0.\n-  bnez(t0, slow_path);\n+  \/\/ Compute owner address.\n+  la(owner_addr, Address(tmp, ObjectMonitor::owner_offset()));\n@@ -230,2 +229,2 @@\n-  \/\/ need a release store here\n-  la(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n+  \/\/ Set owner to null.\n+  \/\/ Release to satisfy the JMM\n@@ -233,1 +232,21 @@\n-  sd(zr, Address(tmp)); \/\/ set unowned\n+  sd(zr, Address(owner_addr));\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  \/\/ StoreLoad achieves this.\n+  membar(StoreLoad);\n+\n+  \/\/ Check if the entry lists are empty.\n+  ld(t0, Address(tmp, ObjectMonitor::EntryList_offset()));\n+  ld(tmp1Reg, Address(tmp, ObjectMonitor::cxq_offset()));\n+  orr(t0, t0, tmp1Reg);\n+  beqz(t0, unlocked); \/\/ If so we are done.\n+\n+  \/\/ Check if there is a successor.\n+  ld(t0, Address(tmp, ObjectMonitor::succ_offset()));\n+  bnez(t0, unlocked); \/\/ If so we are done.\n+\n+  \/\/ Save the monitor pointer in the current thread, so we can try to\n+  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+  sd(tmp, Address(xthread, JavaThread::unlocked_inflated_monitor_offset()));\n+\n+  mv(flag, 1);\n+  j(slow_path);\n@@ -537,1 +556,0 @@\n-    Label release;\n@@ -543,0 +561,8 @@\n+    \/\/ Set owner to null.\n+    \/\/ Release to satisfy the JMM\n+    membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+    sd(zr, Address(tmp2_owner_addr));\n+    \/\/ We need a full fence after clearing owner to avoid stranding.\n+    \/\/ StoreLoad achieves this.\n+    membar(StoreLoad);\n+\n@@ -547,1 +573,1 @@\n-    beqz(t0, release);\n+    beqz(t0, unlocked); \/\/ If so we are done.\n@@ -549,5 +575,3 @@\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    sd(xthread, Address(tmp2_owner_addr));\n-    j(slow_path);\n+    \/\/ Check if there is a successor.\n+    ld(tmp3_t, Address(tmp1_monitor, ObjectMonitor::succ_offset()));\n+    bnez(tmp3_t, unlocked); \/\/ If so we are done.\n@@ -555,4 +579,6 @@\n-    bind(release);\n-    \/\/ Set owner to null.\n-    membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-    sd(zr, Address(tmp2_owner_addr));\n+    \/\/ Save the monitor pointer in the current thread, so we can try\n+    \/\/ to reacquire the lock in SharedRuntime::monitor_exit_helper().\n+    sd(tmp1_monitor, Address(xthread, JavaThread::unlocked_inflated_monitor_offset()));\n+\n+    mv(flag, 1);\n+    j(slow_path);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":44,"deletions":18,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -42,1 +42,4 @@\n-#endif\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -99,0 +102,49 @@\n+static void generate_queue_test_and_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                              const Register thread, const Register value, const Register tmp1, const Register tmp2) {\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ ld(tmp1, Address(thread, in_bytes(index_offset)));   \/\/ tmp1 := *(index address)\n+  __ beqz(tmp1, runtime);                                 \/\/ jump to runtime if index == 0 (full buffer)\n+  \/\/ The buffer is not full, store value into it.\n+  __ sub(tmp1, tmp1, wordSize);                           \/\/ tmp1 := next index\n+  __ sd(tmp1, Address(thread, in_bytes(index_offset)));   \/\/ *(index address) := next index\n+  __ ld(tmp2, Address(thread, in_bytes(buffer_offset)));  \/\/ tmp2 := buffer address\n+  __ add(tmp2, tmp2, tmp1);\n+  __ sd(value, Address(tmp2));                            \/\/ *(buffer address + next index) := value\n+}\n+\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread,\n+                                           const Register tmp1) {\n+  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n+  \/\/ Is marking active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ lwu(tmp1, in_progress);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ lbu(tmp1, in_progress);\n+  }\n+}\n+\n+static void generate_pre_barrier_slow_path(MacroAssembler* masm,\n+                                           const Register obj,\n+                                           const Register pre_val,\n+                                           const Register thread,\n+                                           const Register tmp1,\n+                                           const Register tmp2,\n+                                           Label& done,\n+                                           Label& runtime) {\n+  \/\/ Do we need to load the previous value?\n+  if (obj != noreg) {\n+    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n+  }\n+  \/\/ Is the previous value null?\n+  __ beqz(pre_val, done, true);\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, pre_val, tmp1, tmp2);\n+  __ j(done);\n+}\n+\n@@ -119,11 +171,2 @@\n-  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n-  Address index(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n-\n-  \/\/ Is marking active?\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) { \/\/ 4-byte width\n-    __ lwu(tmp1, in_progress);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ lbu(tmp1, in_progress);\n-  }\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is not active (*(mark queue active address) == 0), jump to done\n@@ -131,25 +174,1 @@\n-\n-  \/\/ Do we need to load the previous value?\n-  if (obj != noreg) {\n-    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n-  }\n-\n-  \/\/ Is the previous value null?\n-  __ beqz(pre_val, done);\n-\n-  \/\/ Can we store original value in the thread's buffer?\n-  \/\/ Is index == 0?\n-  \/\/ (The index field is typed as size_t.)\n-\n-  __ ld(tmp1, index);                  \/\/ tmp := *index_adr\n-  __ beqz(tmp1, runtime);              \/\/ tmp == 0?\n-                                       \/\/ If yes, goto runtime\n-\n-  __ sub(tmp1, tmp1, wordSize);        \/\/ tmp := tmp - wordSize\n-  __ sd(tmp1, index);                  \/\/ *index_adr := tmp\n-  __ ld(tmp2, buffer);\n-  __ add(tmp1, tmp1, tmp2);            \/\/ tmp := tmp + *buffer_adr\n-\n-  \/\/ Record the previous value\n-  __ sd(pre_val, Address(tmp1, 0));\n-  __ j(done);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, done, runtime);\n@@ -174,0 +193,43 @@\n+static void generate_post_barrier_fast_path(MacroAssembler* masm,\n+                                            const Register store_addr,\n+                                            const Register new_val,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            bool new_val_may_be_null) {\n+  \/\/ Does store cross heap regions?\n+  __ xorr(tmp1, store_addr, new_val);                    \/\/ tmp1 := store address ^ new value\n+  __ srli(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);  \/\/ tmp1 := ((store address ^ new value) >> LogOfHRGrainBytes)\n+  __ beqz(tmp1, done);\n+  \/\/ Crosses regions, storing null?\n+  if (new_val_may_be_null) {\n+    __ beqz(new_val, done);\n+  }\n+  \/\/ Storing region crossing non-null, is card young?\n+  __ srli(tmp1, store_addr, CardTable::card_shift());    \/\/ tmp1 := card address relative to card table base\n+  __ load_byte_map_base(tmp2);                           \/\/ tmp2 := card table base address\n+  __ add(tmp1, tmp1, tmp2);                              \/\/ tmp1 := card address\n+  __ lbu(tmp2, Address(tmp1));                           \/\/ tmp2 := card\n+}\n+\n+static void generate_post_barrier_slow_path(MacroAssembler* masm,\n+                                            const Register thread,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            Label& runtime) {\n+  __ membar(MacroAssembler::StoreLoad);  \/\/ StoreLoad membar\n+  __ lbu(tmp2, Address(tmp1));           \/\/ tmp2 := card\n+  __ beqz(tmp2, done, true);\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n+  \/\/ Dirty card and log.\n+  STATIC_ASSERT(CardTable::dirty_card_val() == 0);\n+  __ sb(zr, Address(tmp1));       \/\/ *(card address) := dirty_card_val\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, tmp1, tmp2, t0);\n+  __ j(done);\n+}\n+\n@@ -182,8 +244,2 @@\n-  assert(store_addr != noreg && new_val != noreg && tmp1 != noreg &&\n-         tmp2 != noreg, \"expecting a register\");\n-\n-  Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));\n-\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n+  assert(store_addr != noreg && new_val != noreg && tmp1 != noreg && tmp2 != noreg,\n+         \"expecting a register\");\n@@ -194,1 +250,5 @@\n-  \/\/ Does store cross heap regions?\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  \/\/ If card is young, jump to done (tmp2 holds the card value)\n+  __ mv(t0, (int)G1CardTable::g1_young_card_val());\n+  __ beq(tmp2, t0, done);   \/\/ card == young_card_val?\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, done, runtime);\n@@ -196,3 +256,6 @@\n-  __ xorr(tmp1, store_addr, new_val);\n-  __ srli(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n-  __ beqz(tmp1, done);\n+  __ bind(runtime);\n+  \/\/ save the live input values\n+  RegSet saved = RegSet::of(store_addr);\n+  __ push_reg(saved, sp);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), tmp1, thread);\n+  __ pop_reg(saved, sp);\n@@ -200,1 +263,2 @@\n-  \/\/ crosses regions, storing null?\n+  __ bind(done);\n+}\n@@ -202,1 +266,1 @@\n-  __ beqz(new_val, done);\n+#if defined(COMPILER2)\n@@ -204,1 +268,9 @@\n-  \/\/ storing region crossing non-null, is card already dirty?\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register arg, const address runtime_path) {\n+  SaveLiveRegisters save_registers(masm, stub);\n+  if (c_rarg0 != arg) {\n+    __ mv(c_rarg0, arg);\n+  }\n+  __ mv(c_rarg1, xthread);\n+  __ mv(t0, runtime_path);\n+  __ jalr(t0);\n+}\n@@ -206,1 +278,10 @@\n-  const Register card_addr = tmp1;\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register thread,\n+                                                    Register tmp1,\n+                                                    Register tmp2,\n+                                                    G1PreBarrierStubC2* stub) {\n+  assert(thread == xthread, \"must be\");\n+  assert_different_registers(obj, pre_val, tmp1, tmp2);\n+  assert(pre_val != noreg && tmp1 != noreg && tmp2 != noreg, \"expecting a register\");\n@@ -208,1 +289,1 @@\n-  __ srli(card_addr, store_addr, CardTable::card_shift());\n+  stub->initialize_registers(obj, pre_val, thread, tmp1, tmp2);\n@@ -210,6 +291,3 @@\n-  \/\/ get the address of the card\n-  __ load_byte_map_base(tmp2);\n-  __ add(card_addr, card_addr, tmp2);\n-  __ lbu(tmp2, Address(card_addr));\n-  __ mv(t0, (int)G1CardTable::g1_young_card_val());\n-  __ beq(tmp2, t0, done);\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is active (*(mark queue active address) != 0), jump to stub (slow path)\n+  __ bnez(tmp1, *stub->entry(), true);\n@@ -217,1 +295,2 @@\n-  assert((int)CardTable::dirty_card_val() == 0, \"must be 0\");\n+  __ bind(*stub->continuation());\n+}\n@@ -219,1 +298,9 @@\n-  __ membar(MacroAssembler::StoreLoad);\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register obj = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1();\n+  Register tmp2 = stub->tmp2();\n@@ -221,2 +308,2 @@\n-  __ lbu(tmp2, Address(card_addr));\n-  __ beqz(tmp2, done);\n+  __ bind(*stub->entry());\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, *stub->continuation(), runtime);\n@@ -224,2 +311,4 @@\n-  \/\/ storing a region crossing, non-null oop, card is clean.\n-  \/\/ dirty card and log.\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry));\n+  __ j(*stub->continuation());\n+}\n@@ -227,1 +316,11 @@\n-  __ sb(zr, Address(card_addr));\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register thread,\n+                                                     Register tmp1,\n+                                                     Register tmp2,\n+                                                     G1PostBarrierStubC2* stub) {\n+  assert(thread == xthread, \"must be\");\n+  assert_different_registers(store_addr, new_val, thread, tmp1, tmp2, t0);\n+  assert(store_addr != noreg && new_val != noreg && tmp1 != noreg && tmp2 != noreg,\n+         \"expecting a register\");\n@@ -229,4 +328,1 @@\n-  __ ld(t0, queue_index);\n-  __ beqz(t0, runtime);\n-  __ sub(t0, t0, wordSize);\n-  __ sd(t0, queue_index);\n+  stub->initialize_registers(thread, tmp1, tmp2);\n@@ -234,4 +330,5 @@\n-  __ ld(tmp2, buffer);\n-  __ add(t0, tmp2, t0);\n-  __ sd(card_addr, Address(t0, 0));\n-  __ j(done);\n+  bool new_val_may_be_null = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, *stub->continuation(), new_val_may_be_null);\n+  \/\/ If card is not young, jump to stub (slow path) (tmp2 holds the card value)\n+  __ mv(t0, (int)G1CardTable::g1_young_card_val());\n+  __ bne(tmp2, t0, *stub->entry(), true);\n@@ -239,6 +336,2 @@\n-  __ bind(runtime);\n-  \/\/ save the live input values\n-  RegSet saved = RegSet::of(store_addr);\n-  __ push_reg(saved, sp);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);\n-  __ pop_reg(saved, sp);\n+  __ bind(*stub->continuation());\n+}\n@@ -246,1 +339,14 @@\n-  __ bind(done);\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1(); \/\/ tmp1 holds the card address.\n+  Register tmp2 = stub->tmp2();\n+\n+  __ bind(*stub->entry());\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, tmp1, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry));\n+  __ j(*stub->continuation());\n@@ -249,0 +355,2 @@\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":191,"deletions":83,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -39,0 +39,2 @@\n+class G1PreBarrierStubC2;\n+class G1PostBarrierStubC2;\n@@ -75,0 +77,21 @@\n+#ifdef COMPILER2\n+  void g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                               Register obj,\n+                               Register pre_val,\n+                               Register thread,\n+                               Register tmp1,\n+                               Register tmp2,\n+                               G1PreBarrierStubC2* c2_stub);\n+  void generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                    G1PreBarrierStubC2* stub) const;\n+  void g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                Register store_addr,\n+                                Register new_val,\n+                                Register thread,\n+                                Register tmp1,\n+                                Register tmp2,\n+                                G1PostBarrierStubC2* c2_stub);\n+  void generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                     G1PostBarrierStubC2* stub) const;\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,564 @@\n+\/\/\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2024, Huawei Technologies Co., Ltd. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+source_hpp %{\n+\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+\n+%}\n+\n+source %{\n+\n+#include \"gc\/g1\/g1BarrierSetAssembler_riscv.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+\n+static void write_barrier_pre(MacroAssembler* masm,\n+                              const MachNode* node,\n+                              Register obj,\n+                              Register pre_val,\n+                              Register tmp1,\n+                              Register tmp2,\n+                              RegSet preserve = RegSet(),\n+                              RegSet no_preserve = RegSet()) {\n+  if (!G1PreBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PreBarrierStubC2* const stub = G1PreBarrierStubC2::create(node);\n+  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {\n+    stub->preserve(*reg);\n+  }\n+  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {\n+    stub->dont_preserve(*reg);\n+  }\n+  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, xthread, tmp1, tmp2, stub);\n+}\n+\n+static void write_barrier_post(MacroAssembler* masm,\n+                               const MachNode* node,\n+                               Register store_addr,\n+                               Register new_val,\n+                               Register tmp1,\n+                               Register tmp2) {\n+  if (!G1PostBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PostBarrierStubC2* const stub = G1PostBarrierStubC2::create(node);\n+  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, xthread, tmp1, tmp2, stub);\n+}\n+\n+%}\n+\n+instruct g1StoreP(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreP mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(STORE_COST);\n+  format %{ \"sd  $src, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ sd($src$$Register, Address($mem$$Register));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $src$$Register  \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(istore_reg_mem);\n+%}\n+\n+instruct g1StoreN(indirect mem, iRegN src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(STORE_COST);\n+  format %{ \"sw  $src, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ sw($src$$Register, Address($mem$$Register));\n+    if ((barrier_data() & G1C2BarrierPost) != 0) {\n+      if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+        __ decode_heap_oop($tmp1$$Register, $src$$Register);\n+      } else {\n+        __ decode_heap_oop_not_null($tmp1$$Register, $src$$Register);\n+      }\n+    }\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(istore_reg_mem);\n+%}\n+\n+instruct g1EncodePAndStoreN(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem (EncodeP src)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(STORE_COST);\n+  format %{ \"encode_heap_oop $tmp1, $src\\n\\t\"\n+            \"sw  $tmp1, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+      __ encode_heap_oop($tmp1$$Register, $src$$Register);\n+    } else {\n+      __ encode_heap_oop_not_null($tmp1$$Register, $src$$Register);\n+    }\n+    __ sw($tmp1$$Register, Address($mem$$Register));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $src$$Register  \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(istore_reg_mem);\n+%}\n+\n+instruct g1CompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $res = $mem, $oldval, $newval\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    \/\/ Pass $oldval to the pre-barrier (instead of loading from $mem), because\n+    \/\/ $oldval is the only value that can be overwritten.\n+    \/\/ The same holds for g1CompareAndSwapP and its Acq variant.\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp1$$Register   \/* tmp1 *\/,\n+                      $tmp2$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register    \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register   \/* tmp1 *\/,\n+                       $tmp2$$Register   \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    \/\/ Pass $oldval to the pre-barrier (instead of loading from $mem), because\n+    \/\/ $oldval is the only value that can be overwritten.\n+    \/\/ The same holds for g1CompareAndSwapP and its Acq variant.\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp1$$Register   \/* tmp1 *\/,\n+                      $tmp2$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register    \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register   \/* tmp1 *\/,\n+                       $tmp2$$Register   \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $res = $mem, $oldval, $newval\\t# narrow oop\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# narrow oop\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndSwapP(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegP oldval)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $mem, $oldval, $newval\\t# (ptr)\\n\\t\"\n+            \"mv $res, $res == $oldval\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp1$$Register   \/* tmp1 *\/,\n+                      $tmp2$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register    \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register   \/* tmp1 *\/,\n+                       $tmp2$$Register   \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegP oldval)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $mem, $oldval, $newval\\t# (ptr)\\n\\t\"\n+            \"mv $res, $res == $oldval\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp1$$Register   \/* tmp1 *\/,\n+                      $tmp2$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register    \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register   \/* tmp1 *\/,\n+                       $tmp2$$Register   \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndSwapN(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $mem, $oldval, $newval\\t# (narrow oop)\\n\\t\"\n+            \"mv $res, $res == $oldval\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $mem, $oldval, $newval\\t# (narrow oop)\\n\\t\"\n+            \"mv $res, $res == $oldval\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::uint32,\n+              \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+              \/*result as bool*\/ true);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1GetAndSetP(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetP mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg  $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register    \/* obj *\/,\n+                      $preval$$Register \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register   \/* tmp1 *\/,\n+                      $tmp2$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchg($preval$$Register, $newval$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register    \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register   \/* tmp1 *\/,\n+                       $tmp2$$Register   \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct g1GetAndSetPAcq(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetP mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg_acq  $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register    \/* obj *\/,\n+                      $preval$$Register \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register   \/* tmp1 *\/,\n+                      $tmp2$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchgal($preval$$Register, $newval$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register    \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register   \/* tmp1 *\/,\n+                       $tmp2$$Register   \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct g1GetAndSetN(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetN mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"atomic_xchgwu $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchgwu($preval$$Register, $newval$$Register, $mem$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct g1GetAndSetNAcq(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetN mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"atomic_xchgwu_acq $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchgalwu($preval$$Register, $newval$$Register, $mem$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct g1LoadP(iRegPNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+%{\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadP mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n+  ins_cost(LOAD_COST + BRANCH_COST);\n+  format %{ \"ld  $dst, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    __ ld($dst$$Register, Address($mem$$Register));\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(iload_reg_mem);\n+%}\n+\n+instruct g1LoadN(iRegNNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadN mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(LOAD_COST + BRANCH_COST);\n+  format %{ \"lwu  $dst, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    __ lwu($dst$$Register, Address($mem$$Register));\n+    if ((barrier_data() & G1C2BarrierPre) != 0) {\n+      __ decode_heap_oop($tmp1$$Register, $dst$$Register);\n+      write_barrier_pre(masm, this,\n+                        noreg \/* obj *\/,\n+                        $tmp1$$Register \/* pre_val *\/,\n+                        $tmp2$$Register \/* tmp1 *\/,\n+                        $tmp3$$Register \/* tmp2 *\/);\n+    }\n+  %}\n+  ins_pipe(iload_reg_mem);\n+%}\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1_riscv.ad","additions":564,"deletions":0,"binary":false,"changes":564,"status":"added"},{"patch":"@@ -74,1 +74,1 @@\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop_entry),\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop),\n@@ -77,1 +77,1 @@\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop_entry), src, dst, count);\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop), src, dst, count);\n@@ -176,1 +176,1 @@\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);\n+    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n@@ -178,1 +178,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n@@ -704,1 +704,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1567,1 +1567,4 @@\n-  Label L_by16_loop, L_vector_entry, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+  Label L_vector_entry,\n+        L_unroll_loop,\n+        L_by4_loop_entry, L_by4_loop,\n+        L_by1_loop, L_exit;\n@@ -1588,2 +1591,0 @@\n-  subw(len, len, unroll_words);\n-  bge(len, zr, L_unroll_loop_entry);\n@@ -1591,5 +1592,4 @@\n-  addiw(len, len, unroll_words-4);\n-  bge(len, zr, L_by4_loop);\n-  addiw(len, len, 4);\n-  bgt(len, zr, L_by1_loop);\n-  j(L_exit);\n+  mv(tmp1, unroll_words);\n+  blt(len, tmp1, L_by4_loop_entry);\n+\n+  const Register loop_buf_end = tmp3;\n@@ -1598,3 +1598,2 @@\n-  bind(L_unroll_loop_entry);\n-    const Register buf_end = tmp3;\n-    add(buf_end, buf, len); \/\/ buf_end will be used as endpoint for loop below\n+  \/\/ Entry for L_unroll_loop\n+    add(loop_buf_end, buf, len);    \/\/ loop_buf_end will be used as endpoint for loop below\n@@ -1602,1 +1601,1 @@\n-    sub(len, len, unroll_words); \/\/ Length after all iterations\n+    sub(loop_buf_end, loop_buf_end, len);\n@@ -1611,7 +1610,8 @@\n-    ble(buf, buf_end, L_unroll_loop);\n-    addiw(len, len, unroll_words-4);\n-    bge(len, zr, L_by4_loop);\n-    addiw(len, len, 4);\n-    bgt(len, zr, L_by1_loop);\n-    j(L_exit);\n-\n+    blt(buf, loop_buf_end, L_unroll_loop);\n+\n+  bind(L_by4_loop_entry);\n+    mv(tmp1, 4);\n+    blt(len, tmp1, L_by1_loop);\n+    add(loop_buf_end, buf, len); \/\/ loop_buf_end will be used as endpoint for loop below\n+    andi(len, len, 3);\n+    sub(loop_buf_end, loop_buf_end, len);\n@@ -1621,1 +1621,0 @@\n-    subw(len, len, 4);\n@@ -1623,3 +1622,1 @@\n-    bge(len, zr, L_by4_loop);\n-    addiw(len, len, 4);\n-    ble(len, zr, L_exit);\n+    blt(buf, loop_buf_end, L_by4_loop);\n@@ -1628,0 +1625,2 @@\n+    beqz(len, L_exit);\n+\n@@ -1632,1 +1631,1 @@\n-    ble(len, zr, L_exit);\n+    beqz(len, L_exit);\n@@ -1638,1 +1637,1 @@\n-    ble(len, zr, L_exit);\n+    beqz(len, L_exit);\n@@ -1644,5 +1643,0 @@\n-    ble(len, zr, L_exit);\n-\n-    srli(tmp2, tmp1, 24);\n-    andi(tmp2, tmp2, right_8_bits);\n-    update_byte_crc32(crc, tmp2, table0);\n@@ -1653,1 +1647,2 @@\n-    j(L_exit); \/\/ only need to jump exit when UseRVV == true, it's a jump from end of block `L_by1_loop`.\n+    \/\/ only need to jump exit when UseRVV == true, it's a jump from end of block `L_by1_loop`.\n+    j(L_exit);\n@@ -1658,4 +1653,1 @@\n-    addiw(len, len, -4);\n-    bge(len, zr, L_by4_loop);\n-    addiw(len, len, 4);\n-    bgt(len, zr, L_by1_loop);\n+    bgtz(len, L_by4_loop_entry);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":27,"deletions":35,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2227,1 +2227,2 @@\n-      is_vector_scalar_bitwise_pattern(n, m)) {\n+      is_vector_scalar_bitwise_pattern(n, m) ||\n+      is_encode_and_store_pattern(n, m)) {\n@@ -4788,0 +4789,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -5223,0 +5225,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -5237,0 +5240,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -5427,0 +5431,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5548,1 +5553,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate(needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -5656,0 +5661,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5789,1 +5795,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate(needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -5917,0 +5923,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -6048,1 +6055,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate(needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -6120,0 +6127,2 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+\n@@ -6185,1 +6194,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate(needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2113,1 +2113,1 @@\n-  if (EnableJVMCI && UseJVMCICompiler) {\n+  if (UseJVMCICompiler) {\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6095,0 +6095,1 @@\n+    \/\/ input parameters\n@@ -6098,11 +6099,0 @@\n-    const Register table0 = c_rarg3;  \/\/ crc_table address\n-    const Register table1 = c_rarg4;\n-    const Register table2 = c_rarg5;\n-    const Register table3 = c_rarg6;\n-\n-    const Register tmp1 = c_rarg7;\n-    const Register tmp2 = t2;\n-    const Register tmp3 = x28; \/\/ t3\n-    const Register tmp4 = x29; \/\/ t4\n-    const Register tmp5 = x30; \/\/ t5\n-    const Register tmp6 = x31; \/\/ t6\n@@ -6113,2 +6103,3 @@\n-    __ kernel_crc32(crc, buf, len, table0, table1, table2,\n-                    table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n+    __ kernel_crc32(crc, buf, len,\n+                    c_rarg3, c_rarg4, c_rarg5, c_rarg6, \/\/ tmp's for tables\n+                    c_rarg7, t2, x28, x29, x30, x31);   \/\/ misc tmps\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-      __ membar(MacroAssembler::AnyAny);\n@@ -323,1 +322,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -2192,1 +2190,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -2244,1 +2241,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -2406,1 +2402,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -2421,1 +2416,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -3536,1 +3530,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -3654,1 +3647,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -3710,1 +3702,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n@@ -45,1 +45,4 @@\n-#endif\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -49,1 +52,34 @@\n-#define BLOCK_COMMENT(str) if (PrintAssembly) __ block_comment(str)\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread,\n+                                           const Register tmp1) {\n+  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n+  \/\/ Is marking active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ load_and_test_int(tmp1, in_progress);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ load_and_test_byte(tmp1, in_progress);\n+  }\n+}\n+\n+static void generate_queue_test_and_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                              const Register Z_thread, const Register value, const Register temp) {\n+  BLOCK_COMMENT(\"generate_queue_test_and_insertion {\");\n+\n+  assert_different_registers(temp, value);\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+\n+  __ load_and_test_long(temp, Address(Z_thread, in_bytes(index_offset))); \/\/ temp := *(index address)\n+  __ branch_optimized(Assembler::bcondEqual, runtime);                    \/\/ jump to runtime if index == 0 (full buffer)\n+\n+  \/\/ The buffer is not full, store value into it.\n+  __ add2reg(temp, -wordSize);                                            \/\/ temp := next index\n+  __ z_stg(temp, in_bytes(index_offset), Z_thread);                       \/\/ *(index address) := next index\n+\n+  __ z_ag(temp, Address(Z_thread, in_bytes(buffer_offset)));              \/\/ temp := buffer address + next index\n+  __ z_stg(value, 0, temp);                                               \/\/ *(buffer address + next index) := value\n+  BLOCK_COMMENT(\"} generate_queue_test_and_insertion\");\n+}\n@@ -62,7 +98,2 @@\n-    const int active_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-    if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-      __ load_and_test_int(Rtmp1, Address(Z_thread, active_offset));\n-    } else {\n-      guarantee(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-      __ load_and_test_byte(Rtmp1, Address(Z_thread, active_offset));\n-    }\n+\n+    generate_pre_barrier_fast_path(masm, Z_thread, Rtmp1);\n@@ -103,0 +134,175 @@\n+#if defined(COMPILER2)\n+\n+#undef __\n+#define __ masm->\n+\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register pre_val, const address runtime_path) {\n+  BLOCK_COMMENT(\"generate_c2_barrier_runtime_call {\");\n+  SaveLiveRegisters save_registers(masm, stub);\n+  __ call_VM_leaf(runtime_path, pre_val, Z_thread);\n+  BLOCK_COMMENT(\"} generate_c2_barrier_runtime_call\");\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register thread,\n+                                                    Register tmp1,\n+                                                    G1PreBarrierStubC2* stub) {\n+\n+  BLOCK_COMMENT(\"g1_write_barrier_pre_c2 {\");\n+\n+  assert(thread == Z_thread, \"must be\");\n+  assert_different_registers(obj, pre_val, tmp1);\n+  assert(pre_val != noreg && tmp1 != noreg, \"expecting a register\");\n+\n+  stub->initialize_registers(obj, pre_val, thread, tmp1, noreg);\n+\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  __ branch_optimized(Assembler::bcondNotEqual, *stub->entry()); \/\/ Activity indicator is zero, so there is no marking going on currently.\n+\n+  __ bind(*stub->continuation());\n+\n+  BLOCK_COMMENT(\"} g1_write_barrier_pre_c2\");\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+\n+  BLOCK_COMMENT(\"generate_c2_pre_barrier_stub {\");\n+\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+\n+  Label runtime;\n+  Register obj     = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register thread  = stub->thread();\n+  Register tmp1    = stub->tmp1();\n+\n+  __ bind(*stub->entry());\n+\n+  BLOCK_COMMENT(\"generate_pre_val_not_null_test {\");\n+  if (obj != noreg) {\n+    __ load_heap_oop(pre_val, Address(obj), noreg, noreg, AS_RAW);\n+  }\n+  __ z_ltgr(pre_val, pre_val);\n+  __ branch_optimized(Assembler::bcondEqual, *stub->continuation());\n+  BLOCK_COMMENT(\"} generate_pre_val_not_null_test\");\n+\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    runtime,\n+                                    Z_thread, pre_val, tmp1);\n+\n+  __ branch_optimized(Assembler::bcondAlways, *stub->continuation());\n+\n+  __ bind(runtime);\n+\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry));\n+\n+  __ branch_optimized(Assembler::bcondAlways, *stub->continuation());\n+\n+  BLOCK_COMMENT(\"} generate_c2_pre_barrier_stub\");\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register thread,\n+                                                     Register tmp1,\n+                                                     Register tmp2,\n+                                                     G1PostBarrierStubC2* stub) {\n+  BLOCK_COMMENT(\"g1_write_barrier_post_c2 {\");\n+\n+  assert(thread == Z_thread, \"must be\");\n+  assert_different_registers(store_addr, new_val, thread, tmp1, tmp2, Z_R1_scratch);\n+\n+  assert(store_addr != noreg && new_val != noreg && tmp1 != noreg && tmp2 != noreg, \"expecting a register\");\n+\n+  stub->initialize_registers(thread, tmp1, tmp2);\n+\n+  BLOCK_COMMENT(\"generate_region_crossing_test {\");\n+  if (VM_Version::has_DistinctOpnds()) {\n+    __ z_xgrk(tmp1, store_addr, new_val);\n+  } else {\n+    __ z_lgr(tmp1, store_addr);\n+    __ z_xgr(tmp1, new_val);\n+  }\n+  __ z_srag(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n+  __ branch_optimized(Assembler::bcondEqual, *stub->continuation());\n+  BLOCK_COMMENT(\"} generate_region_crossing_test\");\n+\n+  \/\/ crosses regions, storing null?\n+  if ((stub->barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+    __ z_ltgr(new_val, new_val);\n+    __ branch_optimized(Assembler::bcondEqual, *stub->continuation());\n+  }\n+\n+  BLOCK_COMMENT(\"generate_card_young_test {\");\n+  CardTableBarrierSet* ct = barrier_set_cast<CardTableBarrierSet>(BarrierSet::barrier_set());\n+  \/\/ calculate address of card\n+  __ load_const_optimized(tmp2, (address)ct->card_table()->byte_map_base());      \/\/ Card table base.\n+  __ z_srlg(tmp1, store_addr, CardTable::card_shift());         \/\/ Index into card table.\n+  __ z_algr(tmp1, tmp2);                                      \/\/ Explicit calculation needed for cli.\n+\n+  \/\/ Filter young.\n+  __ z_cli(0, tmp1, G1CardTable::g1_young_card_val());\n+\n+  BLOCK_COMMENT(\"} generate_card_young_test\");\n+\n+  \/\/ From here on, tmp1 holds the card address.\n+  __ branch_optimized(Assembler::bcondNotEqual, *stub->entry());\n+\n+  __ bind(*stub->continuation());\n+\n+  BLOCK_COMMENT(\"} g1_write_barrier_post_c2\");\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+\n+  BLOCK_COMMENT(\"generate_c2_post_barrier_stub {\");\n+\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+\n+  Register thread     = stub->thread();\n+  Register tmp1       = stub->tmp1(); \/\/ tmp1 holds the card address.\n+  Register tmp2       = stub->tmp2();\n+  Register Rcard_addr = tmp1;\n+\n+  __ bind(*stub->entry());\n+\n+  BLOCK_COMMENT(\"generate_card_clean_test {\");\n+  __ z_sync(); \/\/ Required to support concurrent cleaning.\n+  __ z_cli(0, Rcard_addr, 0); \/\/ Reload after membar.\n+  __ branch_optimized(Assembler::bcondEqual, *stub->continuation());\n+  BLOCK_COMMENT(\"} generate_card_clean_test\");\n+\n+  BLOCK_COMMENT(\"generate_dirty_card {\");\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n+  \/\/ Dirty card and log.\n+  STATIC_ASSERT(CardTable::dirty_card_val() == 0);\n+  __ z_mvi(0, Rcard_addr, CardTable::dirty_card_val());\n+  BLOCK_COMMENT(\"} generate_dirty_card\");\n+\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    runtime,\n+                                    Z_thread, tmp1, tmp2);\n+\n+  __ branch_optimized(Assembler::bcondAlways, *stub->continuation());\n+\n+  __ bind(runtime);\n+\n+  generate_c2_barrier_runtime_call(masm, stub, tmp1, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry));\n+\n+  __ branch_optimized(Assembler::bcondAlways, *stub->continuation());\n+\n+  BLOCK_COMMENT(\"} generate_c2_post_barrier_stub\");\n+}\n+\n+#endif \/\/COMPILER2\n+\n@@ -139,3 +345,0 @@\n-  const int active_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-  const int buffer_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset());\n-  const int index_offset  = in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset());\n@@ -150,8 +353,1 @@\n-  \/\/ Is marking active?\n-  \/\/ Note: value is loaded for test purposes only. No further use here.\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ load_and_test_int(Rtmp1, Address(Z_thread, active_offset));\n-  } else {\n-    guarantee(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ load_and_test_byte(Rtmp1, Address(Z_thread, active_offset));\n-  }\n+  generate_pre_barrier_fast_path(masm, Z_thread, Rtmp1);\n@@ -197,7 +393,0 @@\n-  Register Rbuffer = Rtmp1, Rindex = Rtmp2;\n-  assert_different_registers(Rbuffer, Rindex, Rpre_val);\n-\n-  __ z_lg(Rbuffer, buffer_offset, Z_thread);\n-\n-  __ load_and_test_long(Rindex, Address(Z_thread, index_offset));\n-  __ z_bre(callRuntime); \/\/ If index == 0, goto runtime.\n@@ -205,5 +394,5 @@\n-  __ add2reg(Rindex, -wordSize); \/\/ Decrement index.\n-  __ z_stg(Rindex, index_offset, Z_thread);\n-\n-  \/\/ Record the previous value.\n-  __ z_stg(Rpre_val, 0, Rbuffer, Rindex);\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    callRuntime,\n+                                    Z_thread, Rpre_val, Rtmp2);\n@@ -212,3 +401,0 @@\n-  Rbuffer = noreg;  \/\/ end of life\n-  Rindex  = noreg;  \/\/ end of life\n-\n@@ -329,4 +515,1 @@\n-  Register Rqueue_buf   = (Rtmp3 != Z_R0_scratch) ? Rtmp3 : Rtmp1;\n-  const int qidx_off    = in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset());\n-  const int qbuf_off    = in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset());\n-  if ((Rcard_addr == Rqueue_buf) || (Rcard_addr == Rqueue_index)) {\n+  if (Rcard_addr == Rqueue_index) {\n@@ -337,9 +520,5 @@\n-  __ load_and_test_long(Rqueue_index, Address(Z_thread, qidx_off));\n-  __ z_bre(callRuntime); \/\/ Index == 0 then jump to runtime.\n-\n-  __ z_lg(Rqueue_buf, qbuf_off, Z_thread);\n-\n-  __ add2reg(Rqueue_index, -wordSize); \/\/ Decrement index.\n-  __ z_stg(Rqueue_index, qidx_off, Z_thread);\n-\n-  __ z_stg(Rcard_addr_x, 0, Rqueue_index, Rqueue_buf); \/\/ Store card.\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    callRuntime,\n+                                    Z_thread, Rcard_addr_x, Rqueue_index);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":229,"deletions":50,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n@@ -37,0 +37,2 @@\n+class G1PreBarrierStubC2;\n+class G1PostBarrierStubC2;\n@@ -65,1 +67,21 @@\n-#endif\n+#endif \/\/ COMPILER1\n+\n+#ifdef COMPILER2\n+  void g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                               Register obj,\n+                               Register pre_val,\n+                               Register thread,\n+                               Register tmp1,\n+                               G1PreBarrierStubC2* c2_stub);\n+  void generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                    G1PreBarrierStubC2* stub) const;\n+  void g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                Register store_addr,\n+                                Register new_val,\n+                                Register thread,\n+                                Register tmp1,\n+                                Register tmp2,\n+                                G1PostBarrierStubC2* c2_stub);\n+  void generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                     G1PostBarrierStubC2* stub) const;\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.hpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,457 @@\n+\/\/\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright 2024 IBM Corporation. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+source_hpp %{\n+\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+\n+%}\n+\n+source %{\n+\n+#include \"gc\/g1\/g1BarrierSetAssembler_s390.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+\n+static void write_barrier_pre(MacroAssembler* masm,\n+                              const MachNode* node,\n+                              Register obj,\n+                              Register pre_val,\n+                              Register tmp1,\n+                              RegSet preserve = RegSet(),\n+                              RegSet no_preserve = RegSet()) {\n+  if (!G1PreBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PreBarrierStubC2* const stub = G1PreBarrierStubC2::create(node);\n+  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {\n+    stub->preserve(*reg);\n+  }\n+  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {\n+    stub->dont_preserve(*reg);\n+  }\n+  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, Z_thread, tmp1, stub);\n+}\n+\n+static void write_barrier_post(MacroAssembler* masm,\n+                               const MachNode* node,\n+                               Register store_addr,\n+                               Register new_val,\n+                               Register tmp1,\n+                               Register tmp2) {\n+  if (!G1PostBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PostBarrierStubC2* const stub = G1PostBarrierStubC2::create(node);\n+  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, Z_thread, tmp1, tmp2, stub);\n+}\n+\n+%} \/\/ source\n+\n+\/\/ store pointer\n+instruct g1StoreP(indirect dst, memoryRegP src, iRegL tmp1, iRegL tmp2, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set dst (StoreP dst src));\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(MEMORY_REF_COST);\n+  format %{ \"STG     $src,$dst\\t # ptr\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1StoreP {\");\n+    write_barrier_pre(masm, this,\n+                      $dst$$Register  \/* obj     *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1    *\/,\n+                      RegSet::of($dst$$Register, $src$$Register) \/* preserve *\/);\n+\n+    __ z_stg($src$$Register, Address($dst$$Register));\n+\n+    write_barrier_post(masm, this,\n+                       $dst$$Register, \/* store_addr *\/\n+                       $src$$Register  \/* new_val    *\/,\n+                       $tmp1$$Register \/* tmp1       *\/,\n+                       $tmp2$$Register \/* tmp2       *\/);\n+    __ block_comment(\"} g1StoreP\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Store Compressed Pointer\n+instruct g1StoreN(indirect mem, iRegN_P2N src, iRegL tmp1, iRegL tmp2, iRegL tmp3, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(MEMORY_REF_COST);\n+  format %{ \"STY     $src,$mem\\t # (cOop)\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1StoreN {\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj     *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1    *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+\n+    __ z_sty($src$$Register, Address($mem$$Register));\n+\n+    if ((barrier_data() & G1C2BarrierPost) != 0) {\n+      if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+        __ oop_decoder($tmp1$$Register, $src$$Register, true \/* maybe_null *\/);\n+      } else {\n+        __ oop_decoder($tmp1$$Register, $src$$Register, false \/* maybe_null *\/);\n+      }\n+    }\n+\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val    *\/,\n+                       $tmp2$$Register \/* tmp1       *\/,\n+                       $tmp3$$Register \/* tmp2       *\/);\n+    __ block_comment(\"} g1StoreN\");\n+  %}\n+\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1CompareAndSwapN(indirect mem_ptr, rarg5RegN oldval, iRegN_P2N newval, iRegI res, iRegL tmp1, iRegL tmp2, iRegL tmp3, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));\n+  effect(USE mem_ptr, TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL oldval, KILL cr);\n+  format %{ \"$res = CompareAndSwapN $oldval,$newval,$mem_ptr\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem_ptr$$Register);\n+    assert_different_registers($newval$$Register, $mem_ptr$$Register);\n+    __ block_comment(\"g1compareAndSwapN {\");\n+\n+    Register Rcomp = reg_to_register_object($oldval$$reg);\n+    Register Rnew  = reg_to_register_object($newval$$reg);\n+    Register Raddr = reg_to_register_object($mem_ptr$$reg);\n+    Register Rres  = reg_to_register_object($res$$reg);\n+\n+    write_barrier_pre(masm, this,\n+                      Raddr           \/* obj     *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1    *\/,\n+                      RegSet::of(Raddr, Rcomp, Rnew) \/* preserve *\/,\n+                      RegSet::of(Rres) \/* no_preserve *\/);\n+\n+    __ z_cs(Rcomp, Rnew, 0, Raddr);\n+\n+    assert_different_registers(Rres, Raddr);\n+    if (VM_Version::has_LoadStoreConditional()) {\n+      __ load_const_optimized(Z_R0_scratch, 0L); \/\/ false (failed)\n+      __ load_const_optimized(Rres, 1L);         \/\/ true  (succeed)\n+      __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);\n+    } else {\n+      Label done;\n+      __ load_const_optimized(Rres, 0L); \/\/ false (failed)\n+      __ z_brne(done);                   \/\/ Assume true to be the common case.\n+      __ load_const_optimized(Rres, 1L); \/\/ true  (succeed)\n+      __ bind(done);\n+    }\n+\n+    __ oop_decoder($tmp3$$Register, Rnew, true \/* maybe_null *\/);\n+\n+    write_barrier_post(masm, this,\n+                       Raddr            \/* store_addr *\/,\n+                       $tmp3$$Register  \/* new_val    *\/,\n+                       $tmp1$$Register  \/* tmp1       *\/,\n+                       $tmp2$$Register  \/* tmp2       *\/);\n+    __ block_comment(\"} g1compareAndSwapN\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1CompareAndExchangeN(iRegP mem_ptr, rarg5RegN oldval, iRegN_P2N newval, iRegN res, iRegL tmp1, iRegL tmp2, iRegL tmp3, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeN mem_ptr (Binary oldval newval)));\n+  effect(USE mem_ptr, TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL oldval, KILL cr);\n+  format %{ \"$res = CompareAndExchangeN $oldval,$newval,$mem_ptr\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem_ptr$$Register);\n+    assert_different_registers($newval$$Register, $mem_ptr$$Register);\n+    __ block_comment(\"g1CompareAndExchangeN {\");\n+    write_barrier_pre(masm, this,\n+                      $mem_ptr$$Register \/* obj     *\/,\n+                      $tmp1$$Register    \/* pre_val *\/,\n+                      $tmp2$$Register    \/* tmp1    *\/,\n+                      RegSet::of($mem_ptr$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+\n+    Register Rcomp = reg_to_register_object($oldval$$reg);\n+    Register Rnew  = reg_to_register_object($newval$$reg);\n+    Register Raddr = reg_to_register_object($mem_ptr$$reg);\n+\n+    Register Rres = reg_to_register_object($res$$reg);\n+    assert_different_registers(Rres, Raddr);\n+\n+    __ z_lgr(Rres, Rcomp);  \/\/ previous contents\n+    __ z_csy(Rres, Rnew, 0, Raddr); \/\/ Try to store new value.\n+\n+    __ oop_decoder($tmp1$$Register, Rnew, true \/* maybe_null *\/);\n+\n+    write_barrier_post(masm, this,\n+                       Raddr           \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val    *\/,\n+                       $tmp2$$Register \/* tmp1       *\/,\n+                       $tmp3$$Register \/* tmp2       *\/);\n+    __ block_comment(\"} g1CompareAndExchangeN\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Load narrow oop\n+instruct g1LoadN(iRegN dst, indirect mem, iRegP tmp1, iRegP tmp2, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadN mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(MEMORY_REF_COST);\n+  format %{ \"LoadN   $dst,$mem\\t # (cOop)\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1LoadN {\");\n+    __ z_llgf($dst$$Register, Address($mem$$Register));\n+    if ((barrier_data() & G1C2BarrierPre) != 0) {\n+      __ oop_decoder($tmp1$$Register, $dst$$Register, true);\n+      write_barrier_pre(masm, this,\n+                        noreg           \/* obj     *\/,\n+                        $tmp1$$Register \/* pre_val *\/,\n+                        $tmp2$$Register );\n+    }\n+    __ block_comment(\"} g1LoadN\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1GetAndSetN(indirect mem, iRegN dst, iRegI tmp, iRegL tmp1, iRegL tmp2, iRegL tmp3, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set dst (GetAndSetN mem dst));\n+  effect(KILL cr, TEMP tmp, TEMP tmp1, TEMP tmp2, TEMP tmp3); \/\/ USE_DEF dst by match rule.\n+  format %{ \"XCHGN   $dst,[$mem]\\t # EXCHANGE (coop, atomic), temp $tmp\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1GetAndSetN {\");\n+    assert_different_registers($mem$$Register, $dst$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj     *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1    *\/,\n+                      RegSet::of($mem$$Register, $dst$$Register) \/* preserve *\/);\n+\n+    Register Rdst = reg_to_register_object($dst$$reg);\n+    Register Rtmp = reg_to_register_object($tmp$$reg);\n+    guarantee(Rdst != Rtmp, \"Fix match rule to use TEMP_DEF\");\n+    Label    retry;\n+\n+    \/\/ Iterate until swap succeeds.\n+    __ z_llgf(Rtmp, Address($mem$$Register)); \/\/ current contents\n+    __ bind(retry);\n+    \/\/ Calculate incremented value.\n+    __ z_csy(Rtmp, Rdst, Address($mem$$Register)); \/\/ Try to store new value.\n+    __ z_brne(retry); \/\/ Yikes, concurrent update, need to retry.\n+\n+    __ oop_decoder($tmp1$$Register, $dst$$Register, true \/* maybe_null *\/);\n+\n+    __ z_lgr(Rdst, Rtmp);  \/\/ Exchanged value from memory is return value.\n+\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val    *\/,\n+                       $tmp2$$Register \/* tmp1       *\/,\n+                       $tmp3$$Register \/* tmp2       *\/);\n+\n+    __ block_comment(\"} g1GetAndSetN\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1CompareAndSwapP(iRegP mem_ptr, rarg5RegP oldval, iRegP_N2P newval, iRegI res, iRegL tmp1, iRegL tmp2, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, USE mem_ptr, USE_KILL oldval, KILL cr);\n+  format %{ \"$res = CompareAndSwapP $oldval,$newval,$mem_ptr\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1CompareAndSwapP {\");\n+    assert_different_registers($oldval$$Register, $mem_ptr$$Register);\n+    assert_different_registers($newval$$Register, $mem_ptr$$Register);\n+\n+    Register Rcomp = reg_to_register_object($oldval$$reg);\n+    Register Rnew  = reg_to_register_object($newval$$reg);\n+    Register Raddr = reg_to_register_object($mem_ptr$$reg);\n+    Register Rres  = reg_to_register_object($res$$reg);\n+\n+    write_barrier_pre(masm, this,\n+                      noreg           \/* obj     *\/,\n+                      Rcomp           \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1    *\/,\n+                      RegSet::of(Raddr, Rcomp, Rnew) \/* preserve *\/,\n+                      RegSet::of(Rres) \/* no_preserve *\/);\n+\n+    __ z_csg(Rcomp, Rnew, 0, Raddr);\n+\n+    if (VM_Version::has_LoadStoreConditional()) {\n+      __ load_const_optimized(Z_R0_scratch, 0L); \/\/ false (failed)\n+      __ load_const_optimized(Rres, 1L);         \/\/ true  (succeed)\n+      __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);\n+    } else {\n+      Label done;\n+      __ load_const_optimized(Rres, 0L); \/\/ false (failed)\n+      __ z_brne(done);                   \/\/ Assume true to be the common case.\n+      __ load_const_optimized(Rres, 1L); \/\/ true  (succeed)\n+      __ bind(done);\n+    }\n+\n+    write_barrier_post(masm, this,\n+                       Raddr           \/* store_addr *\/,\n+                       Rnew            \/* new_val    *\/,\n+                       $tmp1$$Register \/* tmp1       *\/,\n+                       $tmp2$$Register \/* tmp2       *\/);\n+    __ block_comment(\"} g1CompareAndSwapP\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1CompareAndExchangeP(iRegP mem_ptr, rarg5RegP oldval, iRegP_N2P newval, iRegP res, iRegL tmp1, iRegL tmp2, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeP mem_ptr (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, USE mem_ptr, USE_KILL oldval, KILL cr);\n+  format %{ \"$res = CompareAndExchangeP $oldval,$newval,$mem_ptr\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1CompareAndExchangeP {\");\n+    assert_different_registers($oldval$$Register, $mem_ptr$$Register);\n+    assert_different_registers($newval$$Register, $mem_ptr$$Register);\n+\n+    \/\/ Pass $oldval to the pre-barrier (instead of loading from $mem), because\n+    \/\/ $oldval is the only value that can be overwritten.\n+    \/\/ The same holds for g1CompareAndSwapP.\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj     *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp2$$Register   \/* tmp1    *\/,\n+                      RegSet::of($mem_ptr$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+\n+    __ z_lgr($res$$Register, $oldval$$Register); \/\/ previous content\n+\n+    __ z_csg($oldval$$Register, $newval$$Register, 0, $mem_ptr$$reg);\n+\n+    write_barrier_post(masm, this,\n+                       $mem_ptr$$Register \/* store_addr *\/,\n+                       $newval$$Register  \/* new_val    *\/,\n+                       $tmp1$$Register    \/* tmp1       *\/,\n+                       $tmp2$$Register    \/* tmp2       *\/);\n+    __ block_comment(\"} g1CompareAndExchangeP\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Load Pointer\n+instruct g1LoadP(iRegP dst, memory mem, iRegL tmp1, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadP mem));\n+  effect(TEMP dst, TEMP tmp1, KILL cr);\n+  ins_cost(MEMORY_REF_COST);\n+  format %{ \"LG      $dst,$mem\\t # ptr\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1LoadP {\");\n+    __ z_lg($dst$$Register, $mem$$Address);\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register \/* pre_val *\/,\n+                      $tmp1$$Register );\n+    __ block_comment(\"} g1LoadP\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1GetAndSetP(indirect mem, iRegP dst, iRegL tmp, iRegL tmp1, iRegL tmp2, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set dst (GetAndSetP mem dst));\n+  effect(KILL cr, TEMP tmp, TEMP tmp1, TEMP tmp2); \/\/ USE_DEF dst by match rule.\n+  format %{ \"XCHGP   $dst,[$mem]\\t # EXCHANGE (oop, atomic), temp $tmp\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1GetAndSetP {\");\n+\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj  *\/,\n+                      $tmp$$Register  \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      RegSet::of($mem$$Register, $dst$$Register) \/* preserve *\/);\n+\n+    __ z_lgr($tmp1$$Register, $dst$$Register);\n+    Register Rdst = reg_to_register_object($dst$$reg);\n+    Register Rtmp = reg_to_register_object($tmp$$reg);\n+    guarantee(Rdst != Rtmp, \"Fix match rule to use TEMP_DEF\");\n+    Label    retry;\n+\n+    \/\/ Iterate until swap succeeds.\n+    __ z_lg(Rtmp, Address($mem$$Register));  \/\/ current contents\n+    __ bind(retry);\n+    \/\/ Calculate incremented value.\n+    __ z_csg(Rtmp, Rdst, Address($mem$$Register)); \/\/ Try to store new value.\n+    __ z_brne(retry);                              \/\/ Yikes, concurrent update, need to retry.\n+    __ z_lgr(Rdst, Rtmp);                          \/\/ Exchanged value from memory is return value.\n+\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val    *\/,\n+                       $tmp2$$Register \/* tmp1       *\/,\n+                       $tmp$$Register  \/* tmp2       *\/);\n+    __ block_comment(\"} g1GetAndSetP\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1EncodePAndStoreN(indirect mem, iRegP src, iRegL tmp1, iRegL tmp2, flagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem (EncodeP src)));\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr);\n+  \/\/ ins_cost(INSN_COST);\n+  format %{ \"encode_heap_oop $tmp1, $src\\n\\t\"\n+            \"st  $tmp1, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1EncodePAndStoreN {\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj     *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1    *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+      __ oop_encoder($tmp1$$Register, $src$$Register, true \/* maybe_null *\/);\n+    } else {\n+      __ oop_encoder($tmp1$$Register, $src$$Register, false \/* maybe_null *\/);\n+    }\n+    __ z_st($tmp1$$Register, Address($mem$$Register));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $src$$Register  \/* new_val    *\/,\n+                       $tmp1$$Register \/* tmp1       *\/,\n+                       $tmp2$$Register \/* tmp2       *\/);\n+    __ block_comment(\"} g1EncodePAndStoreN\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1_s390.ad","additions":457,"deletions":0,"binary":false,"changes":457,"status":"added"},{"patch":"@@ -36,0 +36,3 @@\n+#ifdef COMPILER2\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -197,2 +200,87 @@\n-OptoReg::Name BarrierSetAssembler::refine_register(const Node* node, OptoReg::Name opto_reg) {\n-  Unimplemented(); \/\/ This must be implemented to support late barrier expansion.\n+OptoReg::Name BarrierSetAssembler::refine_register(const Node* node, OptoReg::Name opto_reg) const {\n+  if (!OptoReg::is_reg(opto_reg)) {\n+    return OptoReg::Bad;\n+  }\n+\n+  VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+  if ((vm_reg->is_Register() || vm_reg ->is_FloatRegister()) && (opto_reg & 1) != 0) {\n+    return OptoReg::Bad;\n+  }\n+\n+  return opto_reg;\n+}\n+\n+#undef __\n+#define __ _masm->\n+\n+SaveLiveRegisters::SaveLiveRegisters(MacroAssembler *masm, BarrierStubC2 *stub)\n+  : _masm(masm), _reg_mask(stub->preserve_set()) {\n+\n+  const int register_save_size = iterate_over_register_mask(ACTION_COUNT_ONLY) * BytesPerWord;\n+\n+  _frame_size = align_up(register_save_size, frame::alignment_in_bytes) + frame::z_abi_160_size; \/\/ FIXME: this could be restricted to argument only\n+\n+  __ save_return_pc();\n+  __ push_frame(_frame_size, Z_R14); \/\/ FIXME: check if Z_R1_scaratch can do a job here;\n+\n+  __ z_lg(Z_R14, _z_common_abi(return_pc) + _frame_size, Z_SP);\n+\n+  iterate_over_register_mask(ACTION_SAVE, _frame_size);\n+}\n+\n+SaveLiveRegisters::~SaveLiveRegisters() {\n+  iterate_over_register_mask(ACTION_RESTORE, _frame_size);\n+\n+  __ pop_frame();\n+\n+  __ restore_return_pc();\n+}\n+\n+int SaveLiveRegisters::iterate_over_register_mask(IterationAction action, int offset) {\n+  int reg_save_index = 0;\n+  RegMaskIterator live_regs_iterator(_reg_mask);\n+\n+  while(live_regs_iterator.has_next()) {\n+    const OptoReg::Name opto_reg = live_regs_iterator.next();\n+\n+    \/\/ Filter out stack slots (spilled registers, i.e., stack-allocated registers).\n+    if (!OptoReg::is_reg(opto_reg)) {\n+      continue;\n+    }\n+\n+    const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+    if (vm_reg->is_Register()) {\n+      Register std_reg = vm_reg->as_Register();\n+\n+      if (std_reg->encoding() >= Z_R2->encoding() && std_reg->encoding() <= Z_R15->encoding()) {\n+        reg_save_index++;\n+\n+        if (action == ACTION_SAVE) {\n+          __ z_stg(std_reg, offset - reg_save_index * BytesPerWord, Z_SP);\n+        } else if (action == ACTION_RESTORE) {\n+          __ z_lg(std_reg, offset - reg_save_index * BytesPerWord, Z_SP);\n+        } else {\n+          assert(action == ACTION_COUNT_ONLY, \"Sanity\");\n+        }\n+      }\n+    } else if (vm_reg->is_FloatRegister()) {\n+      FloatRegister fp_reg = vm_reg->as_FloatRegister();\n+      if (fp_reg->encoding() >= Z_F0->encoding() && fp_reg->encoding() <= Z_F15->encoding()\n+          && fp_reg->encoding() != Z_F1->encoding()) {\n+        reg_save_index++;\n+\n+        if (action == ACTION_SAVE) {\n+          __ z_std(fp_reg, offset - reg_save_index * BytesPerWord, Z_SP);\n+        } else if (action == ACTION_RESTORE) {\n+          __ z_ld(fp_reg, offset - reg_save_index * BytesPerWord, Z_SP);\n+        } else {\n+          assert(action == ACTION_COUNT_ONLY, \"Sanity\");\n+        }\n+      }\n+    } else if (false \/* vm_reg->is_VectorRegister() *\/){\n+      fatal(\"Vector register support is not there yet!\");\n+    } else {\n+      fatal(\"Register type is not known\");\n+    }\n+  }\n+  return reg_save_index;\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":90,"deletions":2,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"opto\/regmask.hpp\"\n@@ -36,0 +37,1 @@\n+class BarrierStubC2;\n@@ -65,1 +67,1 @@\n-                                OptoReg::Name opto_reg);\n+                                OptoReg::Name opto_reg) const;\n@@ -69,0 +71,34 @@\n+#ifdef COMPILER2\n+\n+\/\/ This class saves and restores the registers that need to be preserved across\n+\/\/ the runtime call represented by a given C2 barrier stub. Use as follows:\n+\/\/ {\n+\/\/   SaveLiveRegisters save(masm, stub);\n+\/\/   ..\n+\/\/   __ call_VM_leaf(...);\n+\/\/   ..\n+\/\/ }\n+\n+class SaveLiveRegisters {\n+  MacroAssembler* _masm;\n+  RegMask _reg_mask;\n+  Register _result_reg;\n+  int _frame_size;\n+\n+ public:\n+  SaveLiveRegisters(MacroAssembler *masm, BarrierStubC2 *stub);\n+\n+  ~SaveLiveRegisters();\n+\n+ private:\n+  enum IterationAction : int {\n+    ACTION_SAVE,\n+    ACTION_RESTORE,\n+    ACTION_COUNT_ONLY\n+  };\n+\n+  int iterate_over_register_mask(IterationAction action, int offset = 0);\n+};\n+\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2130,1 +2130,1 @@\n-  BLOCK_COMMENT(\"pop_frame:\");\n+  BLOCK_COMMENT(\"pop_frame {\");\n@@ -2132,0 +2132,1 @@\n+  BLOCK_COMMENT(\"} pop_frame\");\n@@ -3658,0 +3659,11 @@\n+  NearLabel check_succ, set_eq_unlocked;\n+\n+  \/\/ Set owner to null.\n+  \/\/ Release to satisfy the JMM\n+  z_release();\n+  z_lghi(temp, 0);\n+  z_stg(temp, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  z_fence();\n+\n+  \/\/ Check if the entry lists are empty.\n@@ -3659,1 +3671,1 @@\n-  z_brne(done);\n+  z_brne(check_succ);\n@@ -3661,3 +3673,18 @@\n-  z_brne(done);\n-  z_release();\n-  z_stg(temp\/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n+  z_bre(done); \/\/ If so we are done.\n+\n+  bind(check_succ);\n+\n+  \/\/ Check if there is a successor.\n+  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)));\n+  z_brne(set_eq_unlocked); \/\/ If so we are done.\n+\n+  \/\/ Save the monitor pointer in the current thread, so we can try to\n+  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+  z_xilf(currentHeader, markWord::monitor_value);\n+  z_stg(currentHeader, Address(Z_thread, JavaThread::unlocked_inflated_monitor_offset()));\n+\n+  z_ltgr(oop, oop); \/\/ Set flag = NE\n+  z_bru(done);\n+\n+  bind(set_eq_unlocked);\n+  z_cr(temp, temp); \/\/ Set flag = EQ\n@@ -6457,0 +6484,1 @@\n+    const Address succ_address{monitor, ObjectMonitor::succ_offset() - monitor_tag};\n@@ -6474,1 +6502,10 @@\n-    NearLabel not_ok;\n+    NearLabel check_succ, set_eq_unlocked;\n+\n+    \/\/ Set owner to null.\n+    \/\/ Release to satisfy the JMM\n+    z_release();\n+    z_lghi(tmp2, 0);\n+    z_stg(tmp2 \/*=0*\/, owner_address);\n+    \/\/ We need a full fence after clearing owner to avoid stranding.\n+    z_fence();\n+\n@@ -6477,1 +6514,1 @@\n-    z_brne(not_ok);\n+    z_brne(check_succ);\n@@ -6479,1 +6516,1 @@\n-    z_brne(not_ok);\n+    z_bre(unlocked); \/\/ If so we are done.\n@@ -6481,2 +6518,1 @@\n-    z_release();\n-    z_stg(tmp2 \/*=0*\/, owner_address);\n+    bind(check_succ);\n@@ -6484,1 +6520,3 @@\n-    z_bru(unlocked); \/\/ CC = EQ here\n+    \/\/ Check if there is a successor.\n+    load_and_test_long(tmp2, succ_address);\n+    z_brne(set_eq_unlocked); \/\/ If so we are done.\n@@ -6486,1 +6524,9 @@\n-    bind(not_ok);\n+    \/\/ Save the monitor pointer in the current thread, so we can try to\n+    \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+    if (!UseObjectMonitorTable) {\n+      z_xilf(monitor, markWord::monitor_value);\n+    }\n+    z_stg(monitor, Address(Z_thread, JavaThread::unlocked_inflated_monitor_offset()));\n+\n+    z_ltgr(obj, obj); \/\/ Set flag = NE\n+    z_bru(slow_path);\n@@ -6488,5 +6534,2 @@\n-    \/\/ The owner may be anonymous, and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    z_stg(Z_thread, owner_address);\n-    z_bru(slow_path); \/\/ CC = NE here\n+    bind(set_eq_unlocked);\n+    z_cr(tmp2, tmp2); \/\/ Set flag = EQ\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":60,"deletions":17,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -451,0 +451,8 @@\n+typedef AbstractRegSet<Register> RegSet;\n+\n+template <>\n+inline Register AbstractRegSet<Register>::first() {\n+  if (_bitset == 0) { return noreg; }\n+  return as_Register(count_trailing_zeros(_bitset));\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/register_s390.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1647,0 +1647,4 @@\n+  if (is_encode_and_store_pattern(n, m)) {\n+    mstack.push(m, Visit);\n+    return true;\n+  }\n@@ -3916,0 +3920,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -3927,0 +3932,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -4289,0 +4295,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -4391,0 +4398,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -4420,0 +4428,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -4483,1 +4492,1 @@\n-  predicate(false && (CompressedOops::base()==nullptr)&&(CompressedOops::shift()==0));\n+  predicate(false && (CompressedOops::base()==nullptr) && (CompressedOops::shift()==0));\n@@ -4631,1 +4640,1 @@\n-            (CompressedOops::base() == 0 ||\n+            (CompressedOops::base() == nullptr ||\n@@ -4654,1 +4663,1 @@\n-            (CompressedOops::base() == 0 ||\n+            (CompressedOops::base() == nullptr ||\n@@ -4738,0 +4747,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -5149,0 +5159,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5159,0 +5170,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5446,0 +5458,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5455,0 +5468,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5929,1 +5943,1 @@\n-  predicate(VM_Version::has_MemWithImmALUOps());\n+  predicate(VM_Version::has_MemWithImmALUOps() && n->as_LoadStore()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1922,0 +1922,5 @@\n+void Assembler::cmpb(Register dst, int imm8) {\n+  prefix(dst);\n+  emit_arith_b(0x80, 0xF8, dst, imm8);\n+}\n+\n@@ -9670,0 +9675,9 @@\n+void Assembler::evinserti64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len) {\n+   assert(VM_Version::supports_avx512dq(), \"\");\n+   assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+   InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+   attributes.set_is_evex_instruction();\n+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+   emit_int24(0x38, (0xC0 | encode), imm8 & 0x03);\n+}\n+\n@@ -11734,0 +11748,15 @@\n+void Assembler::evbroadcastf64x2(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512dq(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T2, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  \/\/ swap src<->dst for encoding\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x1A);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1242,0 +1242,1 @@\n+  void cmpb(Register reg, int imm8);\n@@ -2989,0 +2990,1 @@\n+  void evinserti64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len);\n@@ -3038,0 +3040,1 @@\n+  void evbroadcastf64x2(XMMRegister dst, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,2 +83,0 @@\n-  Label restore_held_monitor_count_and_slow_path;\n-\n@@ -94,9 +92,1 @@\n-  }\n-\n-  { \/\/ Restore held monitor count and slow path.\n-\n-    __ bind(restore_held_monitor_count_and_slow_path);\n-    __ bind(_slow_path);\n-    \/\/ Restore held monitor count.\n-    __ increment(Address(_thread, JavaThread::held_monitor_count_offset()));\n-    \/\/ increment will always result in ZF = 0 (no overflows).\n+    \/\/ addl will always result in ZF = 0 (no overflows).\n@@ -105,44 +95,0 @@\n-\n-  { \/\/ Handle monitor medium path.\n-\n-    __ bind(_check_successor);\n-\n-    Label fix_zf_and_unlocked;\n-    const Register monitor = _mark;\n-\n-#ifndef _LP64\n-    __ jmpb(restore_held_monitor_count_and_slow_path);\n-#else \/\/ _LP64\n-    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n-    const Address succ_address(monitor, ObjectMonitor::succ_offset() - monitor_tag);\n-    const Address owner_address(monitor, ObjectMonitor::owner_offset() - monitor_tag);\n-\n-    \/\/ successor null check.\n-    __ cmpptr(succ_address, NULL_WORD);\n-    __ jccb(Assembler::equal, restore_held_monitor_count_and_slow_path);\n-\n-    \/\/ Release lock.\n-    __ movptr(owner_address, NULL_WORD);\n-\n-    \/\/ Fence.\n-    \/\/ Instead of MFENCE we use a dummy locked add of 0 to the top-of-stack.\n-    __ lock(); __ addl(Address(rsp, 0), 0);\n-\n-    \/\/ Recheck successor.\n-    __ cmpptr(succ_address, NULL_WORD);\n-    \/\/ Observed a successor after the release -> fence we have handed off the monitor\n-    __ jccb(Assembler::notEqual, fix_zf_and_unlocked);\n-\n-    \/\/ Try to relock, if it fails the monitor has been handed over\n-    \/\/ TODO: Caveat, this may fail due to deflation, which does\n-    \/\/       not handle the monitor handoff. Currently only works\n-    \/\/       due to the responsible thread.\n-    __ xorptr(rax, rax);\n-    __ lock(); __ cmpxchgptr(_thread, owner_address);\n-    __ jccb  (Assembler::equal, restore_held_monitor_count_and_slow_path);\n-#endif\n-\n-    __ bind(fix_zf_and_unlocked);\n-    __ xorl(rax, rax);\n-    __ jmp(unlocked_continuation());\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":1,"deletions":55,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -462,16 +462,1 @@\n-#ifndef _LP64\n-  \/\/ Note that we could employ various encoding schemes to reduce\n-  \/\/ the number of loads below (currently 4) to just 2 or 3.\n-  \/\/ Refer to the comments in synchronizer.cpp.\n-  \/\/ In practice the chain of fetches doesn't seem to impact performance, however.\n-  xorptr(boxReg, boxReg);\n-  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  jccb  (Assembler::notZero, DONE_LABEL);\n-  movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-  jccb  (Assembler::notZero, DONE_LABEL);\n-  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n-  jmpb  (DONE_LABEL);\n-#else \/\/ _LP64\n-  \/\/ It's inflated\n-  Label CheckSucc, LNotRecursive, LSuccess, LGoSlowPath;\n+  Label LSuccess, LNotRecursive;\n@@ -483,1 +468,1 @@\n-  decq(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+  decrement(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n@@ -487,4 +472,3 @@\n-  movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-  jccb  (Assembler::notZero, CheckSucc);\n-  \/\/ Without cast to int32_t this style of movptr will destroy r10 which is typically obj.\n+\n+  \/\/ Set owner to null.\n+  \/\/ Release to satisfy the JMM\n@@ -492,1 +476,3 @@\n-  jmpb  (DONE_LABEL);\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  \/\/ StoreLoad achieves this.\n+  membar(StoreLoad);\n@@ -494,2 +480,4 @@\n-  \/\/ Try to avoid passing control into the slow_path ...\n-  bind  (CheckSucc);\n+  \/\/ Check if the entry lists are empty.\n+  movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+  jccb(Assembler::zero, LSuccess);    \/\/ If so we are done.\n@@ -497,4 +485,1 @@\n-  \/\/ The following optional optimization can be elided if necessary\n-  \/\/ Effectively: if (succ == null) goto slow path\n-  \/\/ The code reduces the window for a race, however,\n-  \/\/ and thus benefits performance.\n+  \/\/ Check if there is a successor.\n@@ -502,5 +487,1 @@\n-  jccb  (Assembler::zero, LGoSlowPath);\n-\n-  xorptr(boxReg, boxReg);\n-  \/\/ Without cast to int32_t this style of movptr will destroy r10 which is typically obj.\n-  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+  jccb(Assembler::notZero, LSuccess); \/\/ If so we are done.\n@@ -508,8 +489,9 @@\n-  \/\/ Memory barrier\/fence\n-  \/\/ Dekker pivot point -- fulcrum : ST Owner; MEMBAR; LD Succ\n-  \/\/ Instead of MFENCE we use a dummy locked add of 0 to the top-of-stack.\n-  \/\/ This is faster on Nehalem and AMD Shanghai\/Barcelona.\n-  \/\/ See https:\/\/blogs.oracle.com\/dave\/entry\/instruction_selection_for_volatile_fences\n-  \/\/ We might also restructure (ST Owner=0;barrier;LD _Succ) to\n-  \/\/ (mov box,0; xchgq box, &m->Owner; LD _succ) .\n-  lock(); addl(Address(rsp, 0), 0);\n+  \/\/ Save the monitor pointer in the current thread, so we can try to\n+  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+  andptr(tmpReg, ~(int32_t)markWord::monitor_value);\n+#ifndef _LP64\n+  get_thread(boxReg);\n+  movptr(Address(boxReg, JavaThread::unlocked_inflated_monitor_offset()), tmpReg);\n+#else \/\/ _LP64\n+  movptr(Address(r15_thread, JavaThread::unlocked_inflated_monitor_offset()), tmpReg);\n+#endif\n@@ -517,26 +499,0 @@\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n-  jccb  (Assembler::notZero, LSuccess);\n-\n-  \/\/ Rare inopportune interleaving - race.\n-  \/\/ The successor vanished in the small window above.\n-  \/\/ The lock is contended -- (cxq|EntryList) != null -- and there's no apparent successor.\n-  \/\/ We need to ensure progress and succession.\n-  \/\/ Try to reacquire the lock.\n-  \/\/ If that fails then the new owner is responsible for succession and this\n-  \/\/ thread needs to take no further action and can exit via the fast path (success).\n-  \/\/ If the re-acquire succeeds then pass control into the slow path.\n-  \/\/ As implemented, this latter mode is horrible because we generated more\n-  \/\/ coherence traffic on the lock *and* artificially extended the critical section\n-  \/\/ length while by virtue of passing control into the slow path.\n-\n-  \/\/ box is really RAX -- the following CMPXCHG depends on that binding\n-  \/\/ cmpxchg R,[M] is equivalent to rax = CAS(M,rax,R)\n-  lock();\n-  cmpxchgptr(r15_thread, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  \/\/ There's no successor so we tried to regrab the lock.\n-  \/\/ If that didn't work, then another thread grabbed the\n-  \/\/ lock so we're done (and exit was a success).\n-  jccb  (Assembler::notEqual, LSuccess);\n-  \/\/ Intentional fall-through into slow path\n-\n-  bind  (LGoSlowPath);\n@@ -550,1 +506,0 @@\n-#endif\n@@ -747,4 +702,1 @@\n-  Label unlocked;\n-\n-  \/\/ Assume success.\n-  decrement(Address(thread, JavaThread::held_monitor_count_offset()));\n+  Label unlocked, slow_path;\n@@ -766,2 +718,0 @@\n-  Label& check_successor = stub == nullptr ? dummy : stub->check_successor();\n-  Label& slow_path = stub == nullptr ? dummy : stub->slow_path();\n@@ -842,0 +792,1 @@\n+    const Address succ_address{monitor, ObjectMonitor::succ_offset() - monitor_tag};\n@@ -849,1 +800,8 @@\n-    jccb(Assembler::notEqual, recursive);\n+    jccb(Assembler::notZero, recursive);\n+\n+    \/\/ Set owner to null.\n+    \/\/ Release to satisfy the JMM\n+    movptr(owner_address, NULL_WORD);\n+    \/\/ We need a full fence after clearing owner to avoid stranding.\n+    \/\/ StoreLoad achieves this.\n+    membar(StoreLoad);\n@@ -854,1 +812,1 @@\n-    jcc(Assembler::notZero, check_successor);\n+    jccb(Assembler::zero, unlocked);    \/\/ If so we are done.\n@@ -856,3 +814,13 @@\n-    \/\/ Release lock.\n-    movptr(owner_address, NULL_WORD);\n-    jmpb(unlocked);\n+    \/\/ Check if there is a successor.\n+    cmpptr(succ_address, NULL_WORD);\n+    jccb(Assembler::notZero, unlocked); \/\/ If so we are done.\n+\n+    \/\/ Save the monitor pointer in the current thread, so we can try to\n+    \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+    if (!UseObjectMonitorTable) {\n+      andptr(monitor, ~(int32_t)markWord::monitor_value);\n+    }\n+    movptr(Address(thread, JavaThread::unlocked_inflated_monitor_offset()), monitor);\n+\n+    testl(monitor, monitor);            \/\/ Fast Unlock ZF = 0\n+    jmpb(slow_path);\n@@ -863,1 +831,0 @@\n-    xorl(t, t);\n@@ -867,3 +834,2 @@\n-  if (stub != nullptr) {\n-    bind(stub->unlocked_continuation());\n-  }\n+  decrement(Address(thread, JavaThread::held_monitor_count_offset()));\n+  xorl(t, t); \/\/ Fast Unlock ZF = 1\n@@ -878,0 +844,1 @@\n+  bind(slow_path);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":50,"deletions":83,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -41,1 +41,4 @@\n-#endif\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -163,0 +166,50 @@\n+static void generate_queue_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                     const Register thread, const Register value, const Register temp) {\n+  \/\/ This code assumes that buffer index is pointer sized.\n+  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ movptr(temp, Address(thread, in_bytes(index_offset)));   \/\/ temp := *(index address)\n+  __ testptr(temp, temp);                                     \/\/ index == 0?\n+  __ jcc(Assembler::zero, runtime);                           \/\/ jump to runtime if index == 0 (full buffer)\n+  \/\/ The buffer is not full, store value into it.\n+  __ subptr(temp, wordSize);                                  \/\/ temp := next index\n+  __ movptr(Address(thread, in_bytes(index_offset)), temp);   \/\/ *(index address) := next index\n+  __ addptr(temp, Address(thread, in_bytes(buffer_offset)));  \/\/ temp := buffer address + next index\n+  __ movptr(Address(temp, 0), value);                         \/\/ *(buffer address + next index) := value\n+}\n+\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread) {\n+  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n+  \/\/ Is marking active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ cmpl(in_progress, 0);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ cmpb(in_progress, 0);\n+  }\n+}\n+\n+static void generate_pre_barrier_slow_path(MacroAssembler* masm,\n+                                           const Register obj,\n+                                           const Register pre_val,\n+                                           const Register thread,\n+                                           const Register tmp,\n+                                           Label& done,\n+                                           Label& runtime) {\n+  \/\/ Do we need to load the previous value?\n+  if (obj != noreg) {\n+    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n+  }\n+  \/\/ Is the previous value null?\n+  __ cmpptr(pre_val, NULL_WORD);\n+  __ jcc(Assembler::equal, done);\n+  generate_queue_insertion(masm,\n+                           G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                           G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                           runtime,\n+                           thread, pre_val, tmp);\n+  __ jmp(done);\n+}\n+\n@@ -188,20 +241,2 @@\n-  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n-  Address index(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n-\n-  \/\/ Is marking active?\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ cmpl(in_progress, 0);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ cmpb(in_progress, 0);\n-  }\n-  __ jcc(Assembler::equal, done);\n-\n-  \/\/ Do we need to load the previous value?\n-  if (obj != noreg) {\n-    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n-  }\n-\n-  \/\/ Is the previous value null?\n-  __ cmpptr(pre_val, NULL_WORD);\n+  generate_pre_barrier_fast_path(masm, thread);\n+  \/\/ If marking is not active (*(mark queue active address) == 0), jump to done\n@@ -209,16 +244,1 @@\n-\n-  \/\/ Can we store original value in the thread's buffer?\n-  \/\/ Is index == 0?\n-  \/\/ (The index field is typed as size_t.)\n-\n-  __ movptr(tmp, index);                   \/\/ tmp := *index_adr\n-  __ cmpptr(tmp, 0);                       \/\/ tmp == 0?\n-  __ jcc(Assembler::equal, runtime);       \/\/ If yes, goto runtime\n-\n-  __ subptr(tmp, wordSize);                \/\/ tmp := tmp - wordSize\n-  __ movptr(index, tmp);                   \/\/ *index_adr := tmp\n-  __ addptr(tmp, buffer);                  \/\/ tmp := tmp + *buffer_adr\n-\n-  \/\/ Record the previous value\n-  __ movptr(Address(tmp, 0), pre_val);\n-  __ jmp(done);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, done, runtime);\n@@ -266,0 +286,48 @@\n+static void generate_post_barrier_fast_path(MacroAssembler* masm,\n+                                            const Register store_addr,\n+                                            const Register new_val,\n+                                            const Register tmp,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            bool new_val_may_be_null) {\n+  CardTableBarrierSet* ct = barrier_set_cast<CardTableBarrierSet>(BarrierSet::barrier_set());\n+  \/\/ Does store cross heap regions?\n+  __ movptr(tmp, store_addr);                                    \/\/ tmp := store address\n+  __ xorptr(tmp, new_val);                                       \/\/ tmp := store address ^ new value\n+  __ shrptr(tmp, G1HeapRegion::LogOfHRGrainBytes);               \/\/ ((store address ^ new value) >> LogOfHRGrainBytes) == 0?\n+  __ jcc(Assembler::equal, done);\n+  \/\/ Crosses regions, storing null?\n+  if (new_val_may_be_null) {\n+    __ cmpptr(new_val, NULL_WORD);                               \/\/ new value == null?\n+    __ jcc(Assembler::equal, done);\n+  }\n+  \/\/ Storing region crossing non-null, is card young?\n+  __ movptr(tmp, store_addr);                                    \/\/ tmp := store address\n+  __ shrptr(tmp, CardTable::card_shift());                       \/\/ tmp := card address relative to card table base\n+  \/\/ Do not use ExternalAddress to load 'byte_map_base', since 'byte_map_base' is NOT\n+  \/\/ a valid address and therefore is not properly handled by the relocation code.\n+  __ movptr(tmp2, (intptr_t)ct->card_table()->byte_map_base());  \/\/ tmp2 := card table base address\n+  __ addptr(tmp, tmp2);                                          \/\/ tmp := card address\n+  __ cmpb(Address(tmp, 0), G1CardTable::g1_young_card_val());    \/\/ *(card address) == young_card_val?\n+}\n+\n+static void generate_post_barrier_slow_path(MacroAssembler* masm,\n+                                            const Register thread,\n+                                            const Register tmp,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            Label& runtime) {\n+  __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));  \/\/ StoreLoad membar\n+  __ cmpb(Address(tmp, 0), G1CardTable::dirty_card_val());       \/\/ *(card address) == dirty_card_val?\n+  __ jcc(Assembler::equal, done);\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n+  \/\/ Dirty card and log.\n+  __ movb(Address(tmp, 0), G1CardTable::dirty_card_val());       \/\/ *(card address) := dirty_card_val\n+  generate_queue_insertion(masm,\n+                           G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                           G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                           runtime,\n+                           thread, tmp, tmp2);\n+  __ jmp(done);\n+}\n+\n@@ -276,6 +344,0 @@\n-  Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));\n-\n-  CardTableBarrierSet* ct =\n-    barrier_set_cast<CardTableBarrierSet>(BarrierSet::barrier_set());\n-\n@@ -285,5 +347,2 @@\n-  \/\/ Does store cross heap regions?\n-\n-  __ movptr(tmp, store_addr);\n-  __ xorptr(tmp, new_val);\n-  __ shrptr(tmp, G1HeapRegion::LogOfHRGrainBytes);\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp, tmp2, done, true \/* new_val_may_be_null *\/);\n+  \/\/ If card is young, jump to done\n@@ -291,0 +350,1 @@\n+  generate_post_barrier_slow_path(masm, thread, tmp, tmp2, done, runtime);\n@@ -292,1 +352,6 @@\n-  \/\/ crosses regions, storing null?\n+  __ bind(runtime);\n+  \/\/ save the live input values\n+  RegSet saved = RegSet::of(store_addr NOT_LP64(COMMA thread));\n+  __ push_set(saved);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), tmp, thread);\n+  __ pop_set(saved);\n@@ -294,2 +359,2 @@\n-  __ cmpptr(new_val, NULL_WORD);\n-  __ jcc(Assembler::equal, done);\n+  __ bind(done);\n+}\n@@ -297,1 +362,1 @@\n-  \/\/ storing region crossing non-null, is card already dirty?\n+#if defined(COMPILER2)\n@@ -299,2 +364,17 @@\n-  const Register card_addr = tmp;\n-  const Register cardtable = tmp2;\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register arg, const address runtime_path) {\n+#ifdef _LP64\n+  SaveLiveRegisters save_registers(masm, stub);\n+  if (c_rarg0 != arg) {\n+    __ mov(c_rarg0, arg);\n+  }\n+  __ mov(c_rarg1, r15_thread);\n+  \/\/ rax is a caller-saved, non-argument-passing register, so it does not\n+  \/\/ interfere with c_rarg0 or c_rarg1. If it contained any live value before\n+  \/\/ entering this stub, it is saved at this point, and restored after the\n+  \/\/ call. If it did not contain any live value, it is free to be used. In\n+  \/\/ either case, it is safe to use it here as a call scratch register.\n+  __ call(RuntimeAddress(runtime_path), rax);\n+#else\n+  Unimplemented();\n+#endif \/\/ _LP64\n+}\n@@ -302,6 +382,13 @@\n-  __ movptr(card_addr, store_addr);\n-  __ shrptr(card_addr, CardTable::card_shift());\n-  \/\/ Do not use ExternalAddress to load 'byte_map_base', since 'byte_map_base' is NOT\n-  \/\/ a valid address and therefore is not properly handled by the relocation code.\n-  __ movptr(cardtable, (intptr_t)ct->card_table()->byte_map_base());\n-  __ addptr(card_addr, cardtable);\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register thread,\n+                                                    Register tmp,\n+                                                    G1PreBarrierStubC2* stub) {\n+#ifdef _LP64\n+  assert(thread == r15_thread, \"must be\");\n+#endif \/\/ _LP64\n+  assert(pre_val != noreg, \"check this code\");\n+  if (obj != noreg) {\n+    assert_different_registers(obj, pre_val, tmp);\n+  }\n@@ -309,2 +396,1 @@\n-  __ cmpb(Address(card_addr, 0), G1CardTable::g1_young_card_val());\n-  __ jcc(Assembler::equal, done);\n+  stub->initialize_registers(obj, pre_val, thread, tmp);\n@@ -312,3 +398,3 @@\n-  __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));\n-  __ cmpb(Address(card_addr, 0), G1CardTable::dirty_card_val());\n-  __ jcc(Assembler::equal, done);\n+  generate_pre_barrier_fast_path(masm, thread);\n+  \/\/ If marking is active (*(mark queue active address) != 0), jump to stub (slow path)\n+  __ jcc(Assembler::notEqual, *stub->entry());\n@@ -316,0 +402,2 @@\n+  __ bind(*stub->continuation());\n+}\n@@ -317,2 +405,9 @@\n-  \/\/ storing a region crossing, non-null oop, card is clean.\n-  \/\/ dirty card and log.\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register obj = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register thread = stub->thread();\n+  Register tmp = stub->tmp1();\n+  assert(stub->tmp2() == noreg, \"not needed in this platform\");\n@@ -320,1 +415,2 @@\n-  __ movb(Address(card_addr, 0), G1CardTable::dirty_card_val());\n+  __ bind(*stub->entry());\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, *stub->continuation(), runtime);\n@@ -322,2 +418,4 @@\n-  \/\/ The code below assumes that buffer index is pointer sized.\n-  STATIC_ASSERT(in_bytes(G1DirtyCardQueue::byte_width_of_index()) == sizeof(intptr_t));\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry));\n+  __ jmp(*stub->continuation());\n+}\n@@ -325,8 +423,10 @@\n-  __ movptr(tmp2, queue_index);\n-  __ testptr(tmp2, tmp2);\n-  __ jcc(Assembler::zero, runtime);\n-  __ subptr(tmp2, wordSize);\n-  __ movptr(queue_index, tmp2);\n-  __ addptr(tmp2, buffer);\n-  __ movptr(Address(tmp2, 0), card_addr);\n-  __ jmp(done);\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register thread,\n+                                                     Register tmp,\n+                                                     Register tmp2,\n+                                                     G1PostBarrierStubC2* stub) {\n+#ifdef _LP64\n+  assert(thread == r15_thread, \"must be\");\n+#endif \/\/ _LP64\n@@ -334,6 +434,1 @@\n-  __ bind(runtime);\n-  \/\/ save the live input values\n-  RegSet saved = RegSet::of(store_addr NOT_LP64(COMMA thread));\n-  __ push_set(saved);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);\n-  __ pop_set(saved);\n+  stub->initialize_registers(thread, tmp, tmp2);\n@@ -341,1 +436,6 @@\n-  __ bind(done);\n+  bool new_val_may_be_null = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp, tmp2, *stub->continuation(), new_val_may_be_null);\n+  \/\/ If card is not young, jump to stub (slow path)\n+  __ jcc(Assembler::notEqual, *stub->entry());\n+\n+  __ bind(*stub->continuation());\n@@ -344,0 +444,19 @@\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register thread = stub->thread();\n+  Register tmp = stub->tmp1(); \/\/ tmp holds the card address.\n+  Register tmp2 = stub->tmp2();\n+  assert(stub->tmp3() == noreg, \"not needed in this platform\");\n+\n+  __ bind(*stub->entry());\n+  generate_post_barrier_slow_path(masm, thread, tmp, tmp2, *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, tmp, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry));\n+  __ jmp(*stub->continuation());\n+}\n+\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":204,"deletions":85,"binary":false,"changes":289,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+class G1BarrierStubC2;\n+class G1PreBarrierStubC2;\n+class G1PostBarrierStubC2;\n@@ -68,0 +71,20 @@\n+\n+#ifdef COMPILER2\n+  void g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                               Register obj,\n+                               Register pre_val,\n+                               Register thread,\n+                               Register tmp,\n+                               G1PreBarrierStubC2* c2_stub);\n+  void generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                    G1PreBarrierStubC2* stub) const;\n+  void g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                Register store_addr,\n+                                Register new_val,\n+                                Register thread,\n+                                Register tmp,\n+                                Register tmp2,\n+                                G1PostBarrierStubC2* c2_stub);\n+  void generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                     G1PostBarrierStubC2* stub) const;\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,371 @@\n+\/\/\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+source_hpp %{\n+\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+\n+%}\n+\n+source %{\n+\n+#include \"gc\/g1\/g1BarrierSetAssembler_x86.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+\n+static void write_barrier_pre(MacroAssembler* masm,\n+                              const MachNode* node,\n+                              Register obj,\n+                              Register pre_val,\n+                              Register tmp,\n+                              RegSet preserve = RegSet(),\n+                              RegSet no_preserve = RegSet()) {\n+  if (!G1PreBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PreBarrierStubC2* const stub = G1PreBarrierStubC2::create(node);\n+  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {\n+    stub->preserve(*reg);\n+  }\n+  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {\n+    stub->dont_preserve(*reg);\n+  }\n+  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, r15_thread, tmp, stub);\n+}\n+\n+static void write_barrier_post(MacroAssembler* masm,\n+                               const MachNode* node,\n+                               Register store_addr,\n+                               Register new_val,\n+                               Register tmp1,\n+                               Register tmp2) {\n+  if (!G1PostBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PostBarrierStubC2* const stub = G1PostBarrierStubC2::create(node);\n+  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, r15_thread, tmp1, tmp2, stub);\n+}\n+\n+%}\n+\n+instruct g1StoreP(memory mem, any_RegP src, rRegP tmp1, rRegP tmp2, rRegP tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreP mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movq    $mem, $src\\t# ptr\" %}\n+  ins_encode %{\n+    \/\/ Materialize the store address internally (as opposed to defining 'mem' as\n+    \/\/ an indirect memory operand) to reduce the overhead of LCM when processing\n+    \/\/ large basic blocks with many stores. Such basic blocks arise, for\n+    \/\/ instance, from static initializations of large String arrays.\n+    \/\/ The same holds for g1StoreN and g1EncodePAndStoreN.\n+    __ lea($tmp1$$Register, $mem$$Address);\n+    write_barrier_pre(masm, this,\n+                      $tmp1$$Register \/* obj *\/,\n+                      $tmp2$$Register \/* pre_val *\/,\n+                      $tmp3$$Register \/* tmp *\/,\n+                      RegSet::of($tmp1$$Register, $src$$Register) \/* preserve *\/);\n+    __ movq(Address($tmp1$$Register, 0), $src$$Register);\n+    write_barrier_post(masm, this,\n+                       $tmp1$$Register \/* store_addr *\/,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp3$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct g1StoreN(memory mem, rRegN src, rRegP tmp1, rRegP tmp2, rRegP tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $mem, $src\\t# ptr\" %}\n+  ins_encode %{\n+    __ lea($tmp1$$Register, $mem$$Address);\n+    write_barrier_pre(masm, this,\n+                      $tmp1$$Register \/* obj *\/,\n+                      $tmp2$$Register \/* pre_val *\/,\n+                      $tmp3$$Register \/* tmp *\/,\n+                      RegSet::of($tmp1$$Register, $src$$Register) \/* preserve *\/);\n+    __ movl(Address($tmp1$$Register, 0), $src$$Register);\n+    if ((barrier_data() & G1C2BarrierPost) != 0) {\n+      __ movl($tmp2$$Register, $src$$Register);\n+      if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+        __ decode_heap_oop($tmp2$$Register);\n+      } else {\n+        __ decode_heap_oop_not_null($tmp2$$Register);\n+      }\n+    }\n+    write_barrier_post(masm, this,\n+                       $tmp1$$Register \/* store_addr *\/,\n+                       $tmp2$$Register \/* new_val *\/,\n+                       $tmp3$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct g1EncodePAndStoreN(memory mem, any_RegP src, rRegP tmp1, rRegP tmp2, rRegP tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem (EncodeP src)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"encode_heap_oop $src\\n\\t\"\n+            \"movl   $mem, $src\\t# ptr\" %}\n+  ins_encode %{\n+    __ lea($tmp1$$Register, $mem$$Address);\n+    write_barrier_pre(masm, this,\n+                      $tmp1$$Register \/* obj *\/,\n+                      $tmp2$$Register \/* pre_val *\/,\n+                      $tmp3$$Register \/* tmp *\/,\n+                      RegSet::of($tmp1$$Register, $src$$Register) \/* preserve *\/);\n+    __ movq($tmp2$$Register, $src$$Register);\n+    if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+      __ encode_heap_oop($tmp2$$Register);\n+    } else {\n+      __ encode_heap_oop_not_null($tmp2$$Register);\n+    }\n+    __ movl(Address($tmp1$$Register, 0), $tmp2$$Register);\n+    write_barrier_post(masm, this,\n+                       $tmp1$$Register \/* store_addr *\/,\n+                       $src$$Register \/* new_val *\/,\n+                       $tmp3$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct g1CompareAndExchangeP(indirect mem, rRegP newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rax_RegP oldval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set oldval (CompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  format %{ \"lock\\n\\t\"\n+            \"cmpxchgq $newval, $mem\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    \/\/ Pass $oldval to the pre-barrier (instead of loading from $mem), because\n+    \/\/ $oldval is the only value that can be overwritten.\n+    \/\/ The same holds for g1CompareAndSwapP.\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp3$$Register \/* tmp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register, $oldval$$Register) \/* preserve *\/);\n+    __ movq($tmp1$$Register, $newval$$Register);\n+    __ lock();\n+    __ cmpxchgq($tmp1$$Register, Address($mem$$Register, 0));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct g1CompareAndExchangeN(indirect mem, rRegN newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rax_RegN oldval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set oldval (CompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  format %{ \"lock\\n\\t\"\n+            \"cmpxchgq $newval, $mem\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp2$$Register \/* pre_val *\/,\n+                      $tmp3$$Register \/* tmp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register, $oldval$$Register) \/* preserve *\/);\n+    __ movl($tmp1$$Register, $newval$$Register);\n+    __ lock();\n+    __ cmpxchgl($tmp1$$Register, Address($mem$$Register, 0));\n+    __ decode_heap_oop($tmp1$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct g1CompareAndSwapP(rRegI res, indirect mem, rRegP newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rax_RegP oldval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL oldval, KILL cr);\n+  format %{ \"lock\\n\\t\"\n+            \"cmpxchgq $newval, $mem\\n\\t\"\n+            \"sete     $res\\n\\t\"\n+            \"movzbl   $res, $res\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp3$$Register \/* tmp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register, $oldval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ movq($tmp1$$Register, $newval$$Register);\n+    __ lock();\n+    __ cmpxchgq($tmp1$$Register, Address($mem$$Register, 0));\n+    __ setb(Assembler::equal, $res$$Register);\n+    __ movzbl($res$$Register, $res$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct g1CompareAndSwapN(rRegI res, indirect mem, rRegN newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rax_RegN oldval, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL oldval, KILL cr);\n+  format %{ \"lock\\n\\t\"\n+            \"cmpxchgq $newval, $mem\\n\\t\"\n+            \"sete     $res\\n\\t\"\n+            \"movzbl   $res, $res\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp2$$Register \/* pre_val *\/,\n+                      $tmp3$$Register \/* tmp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register, $oldval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ movl($tmp1$$Register, $newval$$Register);\n+    __ lock();\n+    __ cmpxchgl($tmp1$$Register, Address($mem$$Register, 0));\n+    __ setb(Assembler::equal, $res$$Register);\n+    __ movzbl($res$$Register, $res$$Register);\n+    __ decode_heap_oop($tmp1$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct g1GetAndSetP(indirect mem, rRegP newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set newval (GetAndSetP mem newval));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  format %{ \"xchgq    $newval, $mem\" %}\n+  ins_encode %{\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp2$$Register \/* pre_val *\/,\n+                      $tmp3$$Register \/* tmp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/);\n+    __ movq($tmp1$$Register, $newval$$Register);\n+    __ xchgq($newval$$Register, Address($mem$$Register, 0));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct g1GetAndSetN(indirect mem, rRegN newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set newval (GetAndSetN mem newval));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  format %{ \"xchgq    $newval, $mem\" %}\n+  ins_encode %{\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register \/* obj *\/,\n+                      $tmp2$$Register \/* pre_val *\/,\n+                      $tmp3$$Register \/* tmp *\/,\n+                      RegSet::of($mem$$Register, $newval$$Register) \/* preserve *\/);\n+    __ movl($tmp1$$Register, $newval$$Register);\n+    __ decode_heap_oop($tmp1$$Register);\n+    __ xchgl($newval$$Register, Address($mem$$Register, 0));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct g1LoadP(rRegP dst, memory mem, rRegP tmp, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadP mem));\n+  effect(TEMP dst, TEMP tmp, KILL cr);\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movq    $dst, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    __ movq($dst$$Register, $mem$$Address);\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register \/* pre_val *\/,\n+                      $tmp$$Register \/* tmp *\/);\n+  %}\n+  ins_pipe(ialu_reg_mem); \/\/ XXX\n+%}\n+\n+instruct g1LoadN(rRegN dst, memory mem, rRegP tmp1, rRegP tmp2, rFlagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadN mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $dst, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $mem$$Address);\n+    __ movl($tmp1$$Register, $dst$$Register);\n+    __ decode_heap_oop($tmp1$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp *\/);\n+  %}\n+  ins_pipe(ialu_reg_mem); \/\/ XXX\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1_x86_64.ad","additions":371,"deletions":0,"binary":false,"changes":371,"status":"added"},{"patch":"@@ -191,1 +191,1 @@\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop_entry),\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop),\n@@ -196,1 +196,1 @@\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop_entry),\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop),\n@@ -354,1 +354,1 @@\n-    __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), 2);\n+    __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), 2);\n@@ -356,1 +356,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), LP64_ONLY(c_rarg0) NOT_LP64(pre_val), thread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), LP64_ONLY(c_rarg0) NOT_LP64(pre_val), thread);\n@@ -1089,1 +1089,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), rcx, thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), rcx, thread);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-  orl(rsi, rdi);                                 \\\n@@ -86,0 +85,1 @@\n+  addl(r1, rdi);                                 \\\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_md5.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2677,1 +2677,1 @@\n-  if (EnableJVMCI && UseJVMCICompiler) {\n+  if (UseJVMCICompiler) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -379,5 +379,16 @@\n-  void generateHtbl_48_block_zmm(Register htbl, Register avx512_subkeyHtbl, Register rscratch);\n-  void ghash16_encrypt16_parallel(Register key, Register subkeyHtbl, XMMRegister ctr_blockx,\n-                                  XMMRegister aad_hashx, Register in, Register out, Register data, Register pos, bool reduction,\n-                                  XMMRegister addmask, bool no_ghash_input, Register rounds, Register ghash_pos,\n-                                  bool final_reduction, int index, XMMRegister counter_inc_mask);\n+  void ghash16_encrypt_parallel16_avx512(Register in, Register out, Register ct, Register pos, Register avx512_subkeyHtbl,\n+                                         Register CTR_CHECK, Register NROUNDS, Register key, XMMRegister CTR, XMMRegister GHASH,\n+                                         XMMRegister ADDBE_4x4, XMMRegister ADDBE_1234, XMMRegister ADD_1234, XMMRegister SHUF_MASK,\n+                                         bool hk_broadcast, bool is_hash_start, bool do_hash_reduction, bool do_hash_hxor,\n+                                         bool no_ghash_in, int ghashin_offset, int aesout_offset, int hashkey_offset);\n+  void generateHtbl_32_blocks_avx512(Register htbl, Register avx512_htbl);\n+  void initial_blocks_16_avx512(Register in, Register out, Register ct, Register pos, Register key, Register avx512_subkeyHtbl,\n+                                Register CTR_CHECK, Register rounds, XMMRegister CTR, XMMRegister GHASH,  XMMRegister ADDBE_4x4,\n+                                XMMRegister ADDBE_1234, XMMRegister ADD_1234, XMMRegister SHUF_MASK, int stack_offset);\n+  void gcm_enc_dec_last_avx512(Register len, Register in, Register pos, XMMRegister HASH, XMMRegister SHUFM, Register subkeyHtbl,\n+                               int ghashin_offset, int hashkey_offset, bool start_ghash, bool do_reduction);\n+  void ghash16_avx512(bool start_ghash, bool do_reduction, bool uload_shuffle, bool hk_broadcast, bool do_hxor,\n+                      Register in, Register pos, Register subkeyHtbl, XMMRegister HASH, XMMRegister SHUFM, int in_offset,\n+                      int in_disp, int displacement, int hashkey_offset);\n+  void aesgcm_avx512(Register in, Register len, Register ct, Register out, Register key,\n+                     Register state, Register subkeyHtbl, Register avx512_subkeyHtbl, Register counter);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2019, 2023, Intel Corporation. All rights reserved.\n+* Copyright (c) 2019, 2024, Intel Corporation. All rights reserved.\n@@ -175,0 +175,32 @@\n+\/\/ This mask is used for incrementing counter value\n+ATTRIBUTE_ALIGNED(64) static const uint64_t COUNTER_MASK_ADDBE_4444[] = {\n+    0x0000000000000000ULL, 0x0400000000000000ULL,\n+    0x0000000000000000ULL, 0x0400000000000000ULL,\n+    0x0000000000000000ULL, 0x0400000000000000ULL,\n+    0x0000000000000000ULL, 0x0400000000000000ULL,\n+};\n+static address counter_mask_addbe_4444_addr() {\n+    return (address)COUNTER_MASK_ADDBE_4444;\n+}\n+\n+\/\/ This mask is used for incrementing counter value\n+ATTRIBUTE_ALIGNED(64) static const uint64_t COUNTER_MASK_ADDBE_1234[] = {\n+    0x0000000000000000ULL, 0x0100000000000000ULL,\n+    0x0000000000000000ULL, 0x0200000000000000ULL,\n+    0x0000000000000000ULL, 0x0300000000000000ULL,\n+    0x0000000000000000ULL, 0x0400000000000000ULL,\n+};\n+static address counter_mask_addbe_1234_addr() {\n+    return (address)COUNTER_MASK_ADDBE_1234;\n+}\n+\n+\/\/ This mask is used for incrementing counter value\n+ATTRIBUTE_ALIGNED(64) static const uint64_t COUNTER_MASK_ADD_1234[] = {\n+    0x0000000000000001ULL, 0x0000000000000000ULL,\n+    0x0000000000000002ULL, 0x0000000000000000ULL,\n+    0x0000000000000003ULL, 0x0000000000000000ULL,\n+    0x0000000000000004ULL, 0x0000000000000000ULL,\n+};\n+static address counter_mask_add_1234_addr() {\n+    return (address)COUNTER_MASK_ADD_1234;\n+}\n@@ -212,4 +244,4 @@\n-\/\/   key        = r10           | r8  (c_rarg4)\n-\/\/   state      = r13           | r9  (c_rarg5)\n-\/\/   subkeyHtbl = r14           | r11\n-\/\/   counter    = rsi           | r12\n+\/\/   key        = rsi           | r8  (c_rarg4)\n+\/\/   state      = rdi           | r9  (c_rarg5)\n+\/\/   subkeyHtbl = r10           | r10\n+\/\/   counter    = r11           | r11\n@@ -233,2 +265,2 @@\n-  const Register subkeyHtbl = r11;\n-  const Register avx512_subkeyHtbl = r13;\n+  const Register subkeyHtbl = r10;\n+  const Register avx512_subkeyHtbl = r12;\n@@ -236,1 +268,1 @@\n-  const Register counter = r12;\n+  const Register counter = r11;\n@@ -239,1 +271,1 @@\n-  const Register key = r10;\n+  const Register key = rsi;\n@@ -241,1 +273,1 @@\n-  const Register state = r13;\n+  const Register state = rdi;\n@@ -243,1 +275,1 @@\n-  const Register subkeyHtbl = r14;\n+  const Register subkeyHtbl = r10;\n@@ -246,1 +278,1 @@\n-  const Register counter = rsi;\n+  const Register counter = r11;\n@@ -250,5 +282,4 @@\n-  __ push(r12);\n-  __ push(r13);\n-  __ push(r14);\n-  __ push(r15);\n-  __ push(rbx);\n+  __ push(r12);\/\/holds pointer to avx512_subkeyHtbl\n+  __ push(r14);\/\/holds CTR_CHECK value to check for overflow\n+  __ push(r15);\/\/holds number of rounds\n+  __ push(rbx);\/\/scratch register\n@@ -258,0 +289,1 @@\n+  __ push(rdi);\n@@ -265,1 +297,1 @@\n-  __ subptr(rsp, 96 * longSize); \/\/ Create space on the stack for htbl entries\n+  __ subptr(rsp, 200 * longSize); \/\/ Create space on the stack for 64 htbl entries and 8 zmm AES entries\n@@ -268,1 +300,1 @@\n-  aesgcm_encrypt(in, len, ct, out, key, state, subkeyHtbl, avx512_subkeyHtbl, counter);\n+  aesgcm_avx512(in, len, ct, out, key, state, subkeyHtbl, avx512_subkeyHtbl, counter);\n@@ -275,0 +307,1 @@\n+  __ pop(rdi);\n@@ -277,1 +310,1 @@\n-  __ lea(rsp, Address(rbp, -5 * wordSize));\n+  __ lea(rsp, Address(rbp, -4 * wordSize));\n@@ -282,1 +315,0 @@\n-  __ pop(r13);\n@@ -2711,1 +2743,2 @@\n-void StubGenerator::generateHtbl_48_block_zmm(Register htbl, Register avx512_htbl, Register rscratch) {\n+\/\/ Holds 64 Htbl entries, 32 HKey and 32 HkKey (derived from HKey)\n+void StubGenerator::generateHtbl_32_blocks_avx512(Register htbl, Register avx512_htbl) {\n@@ -2713,5 +2746,3 @@\n-  const XMMRegister ZT5 = xmm4;\n-  const XMMRegister ZT7 = xmm7;\n-  const XMMRegister ZT8 = xmm8;\n-\n-  Label GFMUL_AVX512;\n+  const XMMRegister ZT1 = xmm0, ZT2 = xmm1, ZT3 = xmm2, ZT4 = xmm3;\n+  const XMMRegister ZT5 = xmm4, ZT6 = xmm5, ZT7 = xmm7, ZT8 = xmm8;\n+  const XMMRegister ZT10 = xmm10, ZT11 = xmm11, ZT12 = xmm12;\n@@ -2720,5 +2751,4 @@\n-  __ movdqu(xmm10, ExternalAddress(ghash_long_swap_mask_addr()), rscratch);\n-  __ vpshufb(HK, HK, xmm10, Assembler::AVX_128bit);\n-\n-  __ movdqu(xmm11, ExternalAddress(ghash_polynomial_addr()), rscratch);\n-  __ movdqu(xmm12, ExternalAddress(ghash_polynomial_two_one_addr()), rscratch);\n+  __ movdqu(ZT10, ExternalAddress(ghash_long_swap_mask_addr()), r15);\n+  __ vpshufb(HK, HK, ZT10, Assembler::AVX_128bit);\n+  __ movdqu(ZT11, ExternalAddress(ghash_polynomial_addr()), r15);\n+  __ movdqu(ZT12, ExternalAddress(ghash_polynomial_two_one_addr()), r15);\n@@ -2726,14 +2756,13 @@\n-  __ movdqu(xmm2, xmm6);\n-  __ vpsllq(xmm6, xmm6, 1, Assembler::AVX_128bit);\n-  __ vpsrlq(xmm2, xmm2, 63, Assembler::AVX_128bit);\n-  __ movdqu(xmm1, xmm2);\n-  __ vpslldq(xmm2, xmm2, 8, Assembler::AVX_128bit);\n-  __ vpsrldq(xmm1, xmm1, 8, Assembler::AVX_128bit);\n-  __ vpor(xmm6, xmm6, xmm2, Assembler::AVX_128bit);\n-\n-  __ vpshufd(xmm2, xmm1, 0x24, Assembler::AVX_128bit);\n-  __ vpcmpeqd(xmm2, xmm2, xmm12, Assembler::AVX_128bit);\n-  __ vpand(xmm2, xmm2, xmm11, Assembler::AVX_128bit);\n-  __ vpxor(xmm6, xmm6, xmm2, Assembler::AVX_128bit);\n-  __ movdqu(Address(avx512_htbl, 16 * 47), xmm6); \/\/ H ^ 2\n-  \/\/ Compute the remaining three powers of H using XMM registers and all following powers using ZMM\n+  __ movdqu(ZT3, HK);\n+  __ vpsllq(HK, HK, 1, Assembler::AVX_128bit);\n+  __ vpsrlq(ZT3, ZT3, 63, Assembler::AVX_128bit);\n+  __ movdqu(ZT2, ZT3);\n+  __ vpslldq(ZT3, ZT3, 8, Assembler::AVX_128bit);\n+  __ vpsrldq(ZT2, ZT2, 8, Assembler::AVX_128bit);\n+  __ vpor(HK, HK, ZT3, Assembler::AVX_128bit);\n+  __ vpshufd(ZT3, ZT2, 0x24, Assembler::AVX_128bit);\n+  __ vpcmpeqd(ZT3, ZT3, ZT12, Assembler::AVX_128bit);\n+  __ vpand(ZT3, ZT3, ZT11, Assembler::AVX_128bit);\n+  __ vpxor(HK, HK, ZT3, Assembler::AVX_128bit);\n+  __ movdqu(Address(avx512_htbl, 16 * 31), HK); \/\/ H ^ 2\n+\n@@ -2741,1 +2770,1 @@\n-  __ vinserti32x4(ZT7, ZT7, HK, 3);\n+  __ evinserti64x2(ZT7, ZT7, HK, 3, Assembler::AVX_512bit);\n@@ -2743,0 +2772,1 @@\n+  \/\/calculate HashKey ^ 2 << 1 mod poly\n@@ -2744,2 +2774,2 @@\n-  __ movdqu(Address(avx512_htbl, 16 * 46), ZT5); \/\/ H ^ 2 * 2\n-  __ vinserti32x4(ZT7, ZT7, ZT5, 2);\n+  __ movdqu(Address(avx512_htbl, 16 * 30), ZT5);\n+  __ evinserti64x2(ZT7, ZT7, ZT5, 2, Assembler::AVX_512bit);\n@@ -2747,0 +2777,1 @@\n+  \/\/calculate HashKey ^ 3 << 1 mod poly\n@@ -2748,2 +2779,2 @@\n-  __ movdqu(Address(avx512_htbl, 16 * 45), ZT5); \/\/ H ^ 2 * 3\n-  __ vinserti32x4(ZT7, ZT7, ZT5, 1);\n+  __ movdqu(Address(avx512_htbl, 16 * 29), ZT5);\n+  __ evinserti64x2(ZT7, ZT7, ZT5, 1, Assembler::AVX_512bit);\n@@ -2751,0 +2782,1 @@\n+  \/\/calculate HashKey ^ 4 << 1 mod poly\n@@ -2752,14 +2784,17 @@\n-  __ movdqu(Address(avx512_htbl, 16 * 44), ZT5); \/\/ H ^ 2 * 4\n-  __ vinserti32x4(ZT7, ZT7, ZT5, 0);\n-\n-  __ evshufi64x2(ZT5, ZT5, ZT5, 0x00, Assembler::AVX_512bit);\n-  __ evmovdquq(ZT8, ZT7, Assembler::AVX_512bit);\n-  gfmul_avx512(ZT7, ZT5);\n-  __ evmovdquq(Address(avx512_htbl, 16 * 40), ZT7, Assembler::AVX_512bit);\n-  __ evshufi64x2(ZT5, ZT7, ZT7, 0x00, Assembler::AVX_512bit);\n-  gfmul_avx512(ZT8, ZT5);\n-  __ evmovdquq(Address(avx512_htbl, 16 * 36), ZT8, Assembler::AVX_512bit);\n-  gfmul_avx512(ZT7, ZT5);\n-  __ evmovdquq(Address(avx512_htbl, 16 * 32), ZT7, Assembler::AVX_512bit);\n-  gfmul_avx512(ZT8, ZT5);\n-  __ evmovdquq(Address(avx512_htbl, 16 * 28), ZT8, Assembler::AVX_512bit);\n+  __ movdqu(Address(avx512_htbl, 16 * 28), ZT5);\n+  __ evinserti64x2(ZT7, ZT7, ZT5, 0, Assembler::AVX_512bit);\n+  \/\/ ZT5 amd ZT7 to be cleared(hash key)\n+  \/\/calculate HashKeyK = HashKey x POLY\n+  __ evmovdquq(xmm11, ExternalAddress(ghash_polynomial_addr()), Assembler::AVX_512bit, r15);\n+  __ evpclmulqdq(ZT1, ZT7, xmm11, 0x10, Assembler::AVX_512bit);\n+  __ vpshufd(ZT2, ZT7, 78, Assembler::AVX_512bit);\n+  __ evpxorq(ZT1, ZT1, ZT2, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(avx512_htbl, 16 * 60), ZT1, Assembler::AVX_512bit);\n+  \/\/**ZT1 amd ZT2 to be cleared(hash key)\n+\n+  \/\/switch to 4x128 - bit computations now\n+  __ evshufi64x2(ZT5, ZT5, ZT5, 0x00, Assembler::AVX_512bit); \/\/;; broadcast HashKey ^ 4 across all ZT5\n+  __ evmovdquq(ZT8, ZT7, Assembler::AVX_512bit);\/\/; save HashKey ^ 4 to HashKey ^ 1 in ZT8\n+  \/\/**ZT8 to be cleared(hash key)\n+\n+  \/\/calculate HashKey ^ 5 << 1 mod poly, HashKey ^ 6 << 1 mod poly, ... HashKey ^ 8 << 1 mod poly\n@@ -2767,25 +2802,35 @@\n-  __ evmovdquq(Address(avx512_htbl, 16 * 24), ZT7, Assembler::AVX_512bit);\n-  gfmul_avx512(ZT8, ZT5);\n-  __ evmovdquq(Address(avx512_htbl, 16 * 20), ZT8, Assembler::AVX_512bit);\n-  gfmul_avx512(ZT7, ZT5);\n-  __ evmovdquq(Address(avx512_htbl, 16 * 16), ZT7, Assembler::AVX_512bit);\n-  gfmul_avx512(ZT8, ZT5);\n-  __ evmovdquq(Address(avx512_htbl, 16 * 12), ZT8, Assembler::AVX_512bit);\n-  gfmul_avx512(ZT7, ZT5);\n-  __ evmovdquq(Address(avx512_htbl, 16 * 8), ZT7, Assembler::AVX_512bit);\n-  gfmul_avx512(ZT8, ZT5);\n-  __ evmovdquq(Address(avx512_htbl, 16 * 4), ZT8, Assembler::AVX_512bit);\n-  gfmul_avx512(ZT7, ZT5);\n-  __ evmovdquq(Address(avx512_htbl, 16 * 0), ZT7, Assembler::AVX_512bit);\n-  __ ret(0);\n-}\n-\n-#define vclmul_reduce(out, poly, hi128, lo128, tmp0, tmp1)      \\\n-__ evpclmulqdq(tmp0, poly, lo128, 0x01, Assembler::AVX_512bit); \\\n-__ vpslldq(tmp0, tmp0, 8, Assembler::AVX_512bit);               \\\n-__ evpxorq(tmp0, lo128, tmp0, Assembler::AVX_512bit);           \\\n-__ evpclmulqdq(tmp1, poly, tmp0, 0x00, Assembler::AVX_512bit);  \\\n-__ vpsrldq(tmp1, tmp1, 4, Assembler::AVX_512bit);               \\\n-__ evpclmulqdq(out, poly, tmp0, 0x10, Assembler::AVX_512bit);   \\\n-__ vpslldq(out, out, 4, Assembler::AVX_512bit);                 \\\n-__ vpternlogq(out, 0x96, tmp1, hi128, Assembler::AVX_512bit);   \\\n+  __ evmovdquq(Address(avx512_htbl, 16 * 24), ZT7, Assembler::AVX_512bit);\/\/; HashKey ^ 8 to HashKey ^ 5 in ZT7 now\n+\n+  \/\/calculate HashKeyX = HashKey x POLY\n+  __ evpclmulqdq(ZT1, ZT7, xmm11, 0x10, Assembler::AVX_512bit);\n+  __ vpshufd(ZT2, ZT7, 78, Assembler::AVX_512bit);\n+  __ evpxorq(ZT1, ZT1, ZT2, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(avx512_htbl, 16 * 56), ZT1, Assembler::AVX_512bit);\n+\n+  __ evshufi64x2(ZT5, ZT7, ZT7, 0x00, Assembler::AVX_512bit);\/\/;; broadcast HashKey ^ 8 across all ZT5\n+\n+  for (int i = 20, j = 52; i > 0;) {\n+    gfmul_avx512(ZT8, ZT5);\n+    __ evmovdquq(Address(avx512_htbl, 16 * i), ZT8, Assembler::AVX_512bit);\n+    \/\/calculate HashKeyK = HashKey x POLY\n+    __ evpclmulqdq(ZT1, ZT8, xmm11, 0x10, Assembler::AVX_512bit);\n+    __ vpshufd(ZT2, ZT8, 78, Assembler::AVX_512bit);\n+    __ evpxorq(ZT1, ZT1, ZT2, Assembler::AVX_512bit);\n+    __ evmovdquq(Address(avx512_htbl, 16 * j), ZT1, Assembler::AVX_512bit);\n+\n+    i -= 4;\n+    j -= 4;\n+    \/\/compute HashKey ^ (8 + n), HashKey ^ (7 + n), ... HashKey ^ (5 + n)\n+    gfmul_avx512(ZT7, ZT5);\n+    __ evmovdquq(Address(avx512_htbl, 16 * i), ZT7, Assembler::AVX_512bit);\n+\n+    \/\/calculate HashKeyK = HashKey x POLY\n+    __ evpclmulqdq(ZT1, ZT7, xmm11, 0x10, Assembler::AVX_512bit);\n+    __ vpshufd(ZT2, ZT7, 78, Assembler::AVX_512bit);\n+    __ evpxorq(ZT1, ZT1, ZT2, Assembler::AVX_512bit);\n+    __ evmovdquq(Address(avx512_htbl, 16 * j), ZT1, Assembler::AVX_512bit);\n+\n+    i -= 4;\n+    j -= 4;\n+  }\n+ }\n@@ -2823,15 +2868,11 @@\n-#define carrylessMultiply(dst00, dst01, dst10, dst11, ghdata, hkey) \\\n-__ evpclmulqdq(dst00, ghdata, hkey, 0x00, Assembler::AVX_512bit); \\\n-__ evpclmulqdq(dst01, ghdata, hkey, 0x01, Assembler::AVX_512bit); \\\n-__ evpclmulqdq(dst10, ghdata, hkey, 0x10, Assembler::AVX_512bit); \\\n-__ evpclmulqdq(dst11, ghdata, hkey, 0x11, Assembler::AVX_512bit); \\\n-\n-#define shuffleExorRnd1Key(dst0, dst1, dst2, dst3, shufmask, rndkey) \\\n-__ vpshufb(dst0, dst0, shufmask, Assembler::AVX_512bit); \\\n-__ evpxorq(dst0, dst0, rndkey, Assembler::AVX_512bit); \\\n-__ vpshufb(dst1, dst1, shufmask, Assembler::AVX_512bit); \\\n-__ evpxorq(dst1, dst1, rndkey, Assembler::AVX_512bit); \\\n-__ vpshufb(dst2, dst2, shufmask, Assembler::AVX_512bit); \\\n-__ evpxorq(dst2, dst2, rndkey, Assembler::AVX_512bit); \\\n-__ vpshufb(dst3, dst3, shufmask, Assembler::AVX_512bit); \\\n-__ evpxorq(dst3, dst3, rndkey, Assembler::AVX_512bit); \\\n+#define carrylessMultiply(dst00, dst01, dst10, dst11, ghdata, hkey2, hkey1) \\\n+__ evpclmulqdq(dst00, ghdata, hkey2, 0x00, Assembler::AVX_512bit); \\\n+__ evpclmulqdq(dst01, ghdata, hkey2, 0x10, Assembler::AVX_512bit); \\\n+__ evpclmulqdq(dst10, ghdata, hkey1, 0x01, Assembler::AVX_512bit); \\\n+__ evpclmulqdq(dst11, ghdata, hkey1, 0x11, Assembler::AVX_512bit); \\\n+\n+#define shuffle(dst0, dst1, dst2, dst3, src0, src1, src2, src3, shufmask) \\\n+__ vpshufb(dst0, src0, shufmask, Assembler::AVX_512bit); \\\n+__ vpshufb(dst1, src1, shufmask, Assembler::AVX_512bit); \\\n+__ vpshufb(dst2, src2, shufmask, Assembler::AVX_512bit); \\\n+__ vpshufb(dst3, src3, shufmask, Assembler::AVX_512bit); \\\n@@ -2851,4 +2892,5 @@\n-void StubGenerator::ghash16_encrypt16_parallel(Register key, Register subkeyHtbl, XMMRegister ctr_blockx, XMMRegister aad_hashx,\n-                                               Register in, Register out, Register data, Register pos, bool first_time_reduction, XMMRegister addmask, bool ghash_input, Register rounds,\n-                                               Register ghash_pos, bool final_reduction, int i, XMMRegister counter_inc_mask) {\n-  Label AES_192, AES_256, LAST_AES_RND;\n+\/\/schoolbook multiply of 16 blocks(8 x 16 bytes)\n+\/\/it is assumed that data read is already shuffledand\n+void StubGenerator::ghash16_avx512(bool start_ghash, bool do_reduction, bool uload_shuffle, bool hk_broadcast, bool do_hxor,\n+                                   Register in, Register pos, Register subkeyHtbl, XMMRegister HASH, XMMRegister SHUFM, int in_offset,\n+                                   int in_disp, int displacement, int hashkey_offset) {\n@@ -2859,0 +2901,1 @@\n+  const XMMRegister ZTMP4 = xmm6;\n@@ -2864,3 +2907,12 @@\n-  const XMMRegister ZTMP10 = xmm15;\n-  const XMMRegister ZTMP11 = xmm16;\n-  const XMMRegister ZTMP12 = xmm17;\n+  const XMMRegister ZTMPA = xmm26;\n+  const XMMRegister ZTMPB = xmm23;\n+  const XMMRegister GH = xmm24;\n+  const XMMRegister GL = xmm25;\n+  const int hkey_gap = 16 * 32;\n+\n+  if (uload_shuffle) {\n+    __ evmovdquq(ZTMP9, Address(subkeyHtbl,  in_offset * 16 + in_disp), Assembler::AVX_512bit);\n+    __ vpshufb(ZTMP9, ZTMP9, SHUFM, Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(ZTMP9, Address(subkeyHtbl, in_offset * 16 + in_disp), Assembler::AVX_512bit);\n+  }\n@@ -2868,10 +2920,12 @@\n-  const XMMRegister ZTMP13 = xmm19;\n-  const XMMRegister ZTMP14 = xmm20;\n-  const XMMRegister ZTMP15 = xmm21;\n-  const XMMRegister ZTMP16 = xmm30;\n-  const XMMRegister ZTMP17 = xmm31;\n-  const XMMRegister ZTMP18 = xmm1;\n-  const XMMRegister ZTMP19 = xmm2;\n-  const XMMRegister ZTMP20 = xmm8;\n-  const XMMRegister ZTMP21 = xmm22;\n-  const XMMRegister ZTMP22 = xmm23;\n+  if (start_ghash) {\n+    __ evpxorq(ZTMP9, ZTMP9, HASH, Assembler::AVX_512bit);\n+  }\n+  if (hk_broadcast) {\n+    __ evbroadcastf64x2(ZTMP8, Address(subkeyHtbl, hashkey_offset + displacement + 0 * 64), Assembler::AVX_512bit);\n+    __ evbroadcastf64x2(ZTMPA, Address(subkeyHtbl, hashkey_offset + displacement + hkey_gap + 0 * 64), Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(ZTMP8, Address(subkeyHtbl, hashkey_offset + displacement + 0 * 64), Assembler::AVX_512bit);\n+    __ evmovdquq(ZTMPA, Address(subkeyHtbl, hashkey_offset + displacement + hkey_gap + 0 * 64), Assembler::AVX_512bit);\n+  }\n+\n+  carrylessMultiply(ZTMP0, ZTMP1, ZTMP2, ZTMP3, ZTMP9, ZTMPA, ZTMP8);\n@@ -2879,24 +2933,6 @@\n-  \/\/ Pre increment counters\n-  __ vpaddd(ZTMP0, ctr_blockx, counter_inc_mask, Assembler::AVX_512bit);\n-  __ vpaddd(ZTMP1, ZTMP0, counter_inc_mask, Assembler::AVX_512bit);\n-  __ vpaddd(ZTMP2, ZTMP1, counter_inc_mask, Assembler::AVX_512bit);\n-  __ vpaddd(ZTMP3, ZTMP2, counter_inc_mask, Assembler::AVX_512bit);\n-  \/\/ Save counter value\n-  __ evmovdquq(ctr_blockx, ZTMP3, Assembler::AVX_512bit);\n-\n-  \/\/ Reuse ZTMP17 \/ ZTMP18 for loading AES Keys\n-  \/\/ Pre-load AES round keys\n-  ev_load_key(ZTMP17, key, 0, xmm29);\n-  ev_load_key(ZTMP18, key, 1 * 16, xmm29);\n-\n-  \/\/ ZTMP19 & ZTMP20 used for loading hash key\n-  \/\/ Pre-load hash key\n-  __ evmovdquq(ZTMP19, Address(subkeyHtbl, i * 64), Assembler::AVX_512bit);\n-  __ evmovdquq(ZTMP20, Address(subkeyHtbl, ++i * 64), Assembler::AVX_512bit);\n-  \/\/ Load data for computing ghash\n-  __ evmovdquq(ZTMP21, Address(data, ghash_pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);\n-  __ vpshufb(ZTMP21, ZTMP21, xmm24, Assembler::AVX_512bit);\n-\n-  \/\/ Xor cipher block 0 with input ghash, if available\n-  if (ghash_input) {\n-    __ evpxorq(ZTMP21, ZTMP21, aad_hashx, Assembler::AVX_512bit);\n+  \/\/ghash blocks 4 - 7\n+  if (uload_shuffle) {\n+    __ evmovdquq(ZTMP9, Address(subkeyHtbl, in_offset * 16 + in_disp + 64), Assembler::AVX_512bit);\n+    __ vpshufb(ZTMP9, ZTMP9, SHUFM, Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(ZTMP9, Address(subkeyHtbl, in_offset * 16 + in_disp + 64), Assembler::AVX_512bit);\n@@ -2904,65 +2940,7 @@\n-  \/\/ Load data for computing ghash\n-  __ evmovdquq(ZTMP22, Address(data, ghash_pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);\n-  __ vpshufb(ZTMP22, ZTMP22, xmm24, Assembler::AVX_512bit);\n-\n-  \/\/ stitch AES rounds with GHASH\n-  \/\/ AES round 0, xmm24 has shuffle mask\n-  shuffleExorRnd1Key(ZTMP0, ZTMP1, ZTMP2, ZTMP3, xmm24, ZTMP17);\n-  \/\/ Reuse ZTMP17 \/ ZTMP18 for loading remaining AES Keys\n-  ev_load_key(ZTMP17, key, 2 * 16, xmm29);\n-  \/\/ GHASH 4 blocks\n-  carrylessMultiply(ZTMP6, ZTMP7, ZTMP8, ZTMP5, ZTMP21, ZTMP19);\n-  \/\/ Load the next hkey and Ghash data\n-  __ evmovdquq(ZTMP19, Address(subkeyHtbl, ++i * 64), Assembler::AVX_512bit);\n-  __ evmovdquq(ZTMP21, Address(data, ghash_pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);\n-  __ vpshufb(ZTMP21, ZTMP21, xmm24, Assembler::AVX_512bit);\n-\n-  \/\/ AES round 1\n-  roundEncode(ZTMP18, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP18, key, 3 * 16, xmm29);\n-\n-  \/\/ GHASH 4 blocks(11 to 8)\n-  carrylessMultiply(ZTMP10, ZTMP12, ZTMP11, ZTMP9, ZTMP22, ZTMP20);\n-  \/\/ Load the next hkey and GDATA\n-  __ evmovdquq(ZTMP20, Address(subkeyHtbl, ++i * 64), Assembler::AVX_512bit);\n-  __ evmovdquq(ZTMP22, Address(data, ghash_pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);\n-  __ vpshufb(ZTMP22, ZTMP22, xmm24, Assembler::AVX_512bit);\n-\n-  \/\/ AES round 2\n-  roundEncode(ZTMP17, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP17, key, 4 * 16, xmm29);\n-\n-  \/\/ GHASH 4 blocks(7 to 4)\n-  carrylessMultiply(ZTMP14, ZTMP16, ZTMP15, ZTMP13, ZTMP21, ZTMP19);\n-  \/\/ AES rounds 3\n-  roundEncode(ZTMP18, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP18, key, 5 * 16, xmm29);\n-\n-  \/\/ Gather(XOR) GHASH for 12 blocks\n-  xorGHASH(ZTMP5, ZTMP6, ZTMP8, ZTMP7, ZTMP9, ZTMP13, ZTMP10, ZTMP14, ZTMP12, ZTMP16, ZTMP11, ZTMP15);\n-\n-  \/\/ AES rounds 4\n-  roundEncode(ZTMP17, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP17, key, 6 * 16, xmm29);\n-\n-  \/\/ load plain \/ cipher text(recycle registers)\n-  loadData(in, pos, ZTMP13, ZTMP14, ZTMP15, ZTMP16);\n-\n-  \/\/ AES rounds 5\n-  roundEncode(ZTMP18, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP18, key, 7 * 16, xmm29);\n-  \/\/ GHASH 4 blocks(3 to 0)\n-  carrylessMultiply(ZTMP10, ZTMP12, ZTMP11, ZTMP9, ZTMP22, ZTMP20);\n-\n-  \/\/  AES round 6\n-  roundEncode(ZTMP17, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP17, key, 8 * 16, xmm29);\n-\n-  \/\/ gather GHASH in ZTMP6(low) and ZTMP5(high)\n-  if (first_time_reduction) {\n-    __ vpternlogq(ZTMP7, 0x96, ZTMP8, ZTMP12, Assembler::AVX_512bit);\n-    __ evpxorq(xmm25, ZTMP7, ZTMP11, Assembler::AVX_512bit);\n-    __ evpxorq(xmm27, ZTMP5, ZTMP9, Assembler::AVX_512bit);\n-    __ evpxorq(xmm26, ZTMP6, ZTMP10, Assembler::AVX_512bit);\n-  } else if (!first_time_reduction && !final_reduction) {\n-    xorGHASH(ZTMP7, xmm25, xmm27, xmm26, ZTMP8, ZTMP12, ZTMP7, ZTMP11, ZTMP5, ZTMP9, ZTMP6, ZTMP10);\n+\n+  if (hk_broadcast) {\n+    __ evbroadcastf64x2(ZTMP8, Address(subkeyHtbl, hashkey_offset + displacement + 1 * 64), Assembler::AVX_512bit);;\n+    __ evbroadcastf64x2(ZTMPA, Address(subkeyHtbl, hashkey_offset + displacement + hkey_gap + 1 * 64), Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(ZTMP8, Address(subkeyHtbl, hashkey_offset + displacement + 1 * 64), Assembler::AVX_512bit);\n+    __ evmovdquq(ZTMPA, Address(subkeyHtbl, hashkey_offset + displacement + hkey_gap + 1 * 64), Assembler::AVX_512bit);\n@@ -2971,8 +2949,9 @@\n-  if (final_reduction) {\n-    \/\/ Phase one: Add mid products together\n-    \/\/ Also load polynomial constant for reduction\n-    __ vpternlogq(ZTMP7, 0x96, ZTMP8, ZTMP12, Assembler::AVX_512bit);\n-    __ vpternlogq(ZTMP7, 0x96, xmm25, ZTMP11, Assembler::AVX_512bit);\n-    __ vpsrldq(ZTMP11, ZTMP7, 8, Assembler::AVX_512bit);\n-    __ vpslldq(ZTMP7, ZTMP7, 8, Assembler::AVX_512bit);\n-    __ evmovdquq(ZTMP12, ExternalAddress(ghash_polynomial_reduction_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n+  carrylessMultiply(ZTMP4, ZTMP5, ZTMP6, ZTMP7, ZTMP9, ZTMPA, ZTMP8);\n+\n+  \/\/update sums\n+  if (start_ghash) {\n+    __ evpxorq(GL, ZTMP0, ZTMP2, Assembler::AVX_512bit);\/\/T2 = THL + TLL\n+    __ evpxorq(GH, ZTMP1, ZTMP3, Assembler::AVX_512bit);\/\/T1 = THH + TLH\n+  } else { \/\/mid, end, end_reduce\n+    __ vpternlogq(GL, 0x96, ZTMP0, ZTMP2, Assembler::AVX_512bit);\/\/T2 = THL + TLL\n+    __ vpternlogq(GH, 0x96, ZTMP1, ZTMP3, Assembler::AVX_512bit);\/\/T1 = THH + TLH\n@@ -2980,8 +2959,6 @@\n-  \/\/ AES round 7\n-  roundEncode(ZTMP18, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP18, key, 9 * 16, xmm29);\n-  if (final_reduction) {\n-    __ vpternlogq(ZTMP5, 0x96, ZTMP9, ZTMP11, Assembler::AVX_512bit);\n-    __ evpxorq(ZTMP5, ZTMP5, xmm27, Assembler::AVX_512bit);\n-    __ vpternlogq(ZTMP6, 0x96, ZTMP10, ZTMP7, Assembler::AVX_512bit);\n-    __ evpxorq(ZTMP6, ZTMP6, xmm26, Assembler::AVX_512bit);\n+  \/\/ghash blocks 8 - 11\n+  if (uload_shuffle) {\n+    __ evmovdquq(ZTMP9, Address(subkeyHtbl, in_offset * 16 + in_disp + 128), Assembler::AVX_512bit);\n+    __ vpshufb(ZTMP9, ZTMP9, SHUFM, Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(ZTMP9, Address(subkeyHtbl, in_offset * 16 + in_disp + 128), Assembler::AVX_512bit);\n@@ -2989,8 +2966,6 @@\n-  \/\/ AES round 8\n-  roundEncode(ZTMP17, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP17, key, 10 * 16, xmm29);\n-\n-  \/\/ Horizontal xor of low and high 4*128\n-  if (final_reduction) {\n-    vhpxori4x128(ZTMP5, ZTMP9);\n-    vhpxori4x128(ZTMP6, ZTMP10);\n+  if (hk_broadcast) {\n+    __ evbroadcastf64x2(ZTMP8, Address(subkeyHtbl, hashkey_offset + displacement + 2 * 64), Assembler::AVX_512bit);\n+    __ evbroadcastf64x2(ZTMPA, Address(subkeyHtbl, hashkey_offset + displacement + hkey_gap + 2 * 64), Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(ZTMP8, Address(subkeyHtbl, hashkey_offset + displacement + 2 * 64), Assembler::AVX_512bit);\n+    __ evmovdquq(ZTMPA, Address(subkeyHtbl, hashkey_offset + displacement + hkey_gap + 2 * 64), Assembler::AVX_512bit);\n@@ -2998,7 +2973,20 @@\n-  \/\/ AES round 9\n-  roundEncode(ZTMP18, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  \/\/ First phase of reduction\n-  if (final_reduction) {\n-      __ evpclmulqdq(ZTMP10, ZTMP12, ZTMP6, 0x01, Assembler::AVX_128bit);\n-      __ vpslldq(ZTMP10, ZTMP10, 8, Assembler::AVX_128bit);\n-      __ evpxorq(ZTMP10, ZTMP6, ZTMP10, Assembler::AVX_128bit);\n+\n+  carrylessMultiply(ZTMP0, ZTMP1, ZTMP2, ZTMP3, ZTMP9, ZTMPA, ZTMP8);\n+\n+  \/\/update sums\n+  __ vpternlogq(GL, 0x96, ZTMP6, ZTMP4, Assembler::AVX_512bit);\/\/T2 = THL + TLL\n+  __ vpternlogq(GH, 0x96, ZTMP7, ZTMP5, Assembler::AVX_512bit);\/\/T1 = THH + TLH\n+  \/\/ghash blocks 12 - 15\n+  if (uload_shuffle) {\n+    __ evmovdquq(ZTMP9, Address(subkeyHtbl, in_offset * 16 + in_disp + 192), Assembler::AVX_512bit);\n+    __ vpshufb(ZTMP9, ZTMP9, SHUFM, Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(ZTMP9, Address(subkeyHtbl, in_offset * 16 + in_disp + 192), Assembler::AVX_512bit);\n+  }\n+\n+  if (hk_broadcast) {\n+    __ evbroadcastf64x2(ZTMP8, Address(subkeyHtbl, hashkey_offset + displacement + 3 * 64), Assembler::AVX_512bit);\n+    __ evbroadcastf64x2(ZTMPA, Address(subkeyHtbl, hashkey_offset + displacement + hkey_gap + 3 * 64), Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(ZTMP8, Address(subkeyHtbl, hashkey_offset + displacement + 3 * 64), Assembler::AVX_512bit);\n+    __ evmovdquq(ZTMPA, Address(subkeyHtbl, hashkey_offset + displacement + hkey_gap + 3 * 64), Assembler::AVX_512bit);\n@@ -3006,0 +2994,304 @@\n+  carrylessMultiply(ZTMP4, ZTMP5, ZTMP6, ZTMP7, ZTMP9, ZTMPA, ZTMP8);\n+\n+  \/\/update sums\n+  xorGHASH(GL, GH, GL, GH, ZTMP0, ZTMP2, ZTMP1, ZTMP3, ZTMP6, ZTMP4, ZTMP7, ZTMP5);\n+\n+  if (do_reduction) {\n+  \/\/new reduction\n+    __ evmovdquq(ZTMPB, ExternalAddress(ghash_polynomial_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n+    __ evpclmulqdq(HASH, GL, ZTMPB, 0x10, Assembler::AVX_512bit);\n+    __ vpshufd(ZTMP0, GL, 78, Assembler::AVX_512bit);\n+    __ vpternlogq(HASH, 0x96, GH, ZTMP0, Assembler::AVX_512bit);\n+    if (do_hxor) {\n+      vhpxori4x128(HASH, ZTMP0);\n+    }\n+  }\n+}\n+\n+\/\/Stitched GHASH of 16 blocks(with reduction) with encryption of 0 blocks\n+void StubGenerator::gcm_enc_dec_last_avx512(Register len, Register in, Register pos, XMMRegister HASH, XMMRegister SHUFM, Register subkeyHtbl,\n+                                            int ghashin_offset, int hashkey_offset, bool start_ghash, bool do_reduction) {\n+  \/\/there is 0 blocks to cipher so there are only 16 blocks for ghash and reduction\n+  ghash16_avx512(start_ghash, do_reduction, false, false, true, in, pos, subkeyHtbl, HASH, SHUFM, ghashin_offset, 0, 0, hashkey_offset);\n+}\n+\n+\/\/Main GCM macro stitching cipher with GHASH\n+\/\/encrypts 16 blocks at a time\n+\/\/ghash the 16 previously encrypted ciphertext blocks\n+void StubGenerator::ghash16_encrypt_parallel16_avx512(Register in, Register out, Register ct, Register pos, Register avx512_subkeyHtbl,\n+                                                      Register CTR_CHECK, Register NROUNDS, Register key, XMMRegister CTR_BE, XMMRegister GHASH_IN,\n+                                                      XMMRegister ADDBE_4x4, XMMRegister ADDBE_1234, XMMRegister ADD_1234, XMMRegister SHFMSK,\n+                                                      bool hk_broadcast, bool is_hash_start, bool do_hash_reduction, bool do_hash_hxor,\n+                                                      bool no_ghash_in, int ghashin_offset, int aesout_offset, int hashkey_offset) {\n+  const XMMRegister B00_03 = xmm0;\n+  const XMMRegister B04_07 = xmm3;\n+  const XMMRegister B08_11 = xmm4;\n+  const XMMRegister B12_15 = xmm5;\n+  const XMMRegister THH1 = xmm6;\n+  const XMMRegister THL1 = xmm7;\n+  const XMMRegister TLH1 = xmm10;\n+  const XMMRegister TLL1 = xmm11, THH2 = xmm12, THL2 = xmm13, TLH2 = xmm15;\n+  const XMMRegister TLL2 = xmm16, THH3 = xmm17, THL3 = xmm19, TLH3 = xmm20;\n+  const XMMRegister TLL3 = xmm21, DATA1 = xmm17, DATA2 = xmm19, DATA3 = xmm20, DATA4 = xmm21;\n+  const XMMRegister AESKEY1 = xmm30, AESKEY2 = xmm31;\n+  const XMMRegister GHKEY1 = xmm1, GHKEY2 = xmm18, GHDAT1 = xmm8, GHDAT2 = xmm22;\n+  const XMMRegister ZT = xmm23, TO_REDUCE_L = xmm25, TO_REDUCE_H = xmm24;\n+  const int hkey_gap = 16 * 32;\n+\n+  Label blocks_overflow, blocks_ok, skip_shuffle, cont, aes_256, aes_192, last_aes_rnd;\n+\n+  __ cmpb(CTR_CHECK, (256 - 16));\n+  __ jcc(Assembler::aboveEqual, blocks_overflow);\n+  __ vpaddd(B00_03, CTR_BE, ADDBE_1234, Assembler::AVX_512bit);\n+  __ vpaddd(B04_07, B00_03, ADDBE_4x4, Assembler::AVX_512bit);\n+  __ vpaddd(B08_11, B04_07, ADDBE_4x4, Assembler::AVX_512bit);\n+  __ vpaddd(B12_15, B08_11, ADDBE_4x4, Assembler::AVX_512bit);\n+  __ jmp(blocks_ok);\n+  __ bind(blocks_overflow);\n+  __ vpshufb(CTR_BE, CTR_BE, SHFMSK, Assembler::AVX_512bit);\n+  __ evmovdquq(B12_15, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n+  __ vpaddd(B00_03, CTR_BE, ADD_1234, Assembler::AVX_512bit);\n+  __ vpaddd(B04_07, B00_03, B12_15, Assembler::AVX_512bit);\n+  __ vpaddd(B08_11, B04_07, B12_15, Assembler::AVX_512bit);\n+  __ vpaddd(B12_15, B08_11, B12_15, Assembler::AVX_512bit);\n+  shuffle(B00_03, B04_07, B08_11, B12_15, B00_03, B04_07, B08_11, B12_15, SHFMSK);\n+\n+  __ bind(blocks_ok);\n+\n+  \/\/pre - load constants\n+  ev_load_key(AESKEY1, key, 0, rbx);\n+  if (!no_ghash_in) {\n+    __ evpxorq(GHDAT1, GHASH_IN, Address(avx512_subkeyHtbl, 16 * ghashin_offset), Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(GHDAT1, Address(avx512_subkeyHtbl, 16 * ghashin_offset), Assembler::AVX_512bit);\n+  }\n+\n+  if (hk_broadcast) {\n+    __ evbroadcastf64x2(GHKEY1, Address(avx512_subkeyHtbl, hashkey_offset + 0 * 64), Assembler::AVX_512bit);\n+    __ evbroadcastf64x2(GHKEY2, Address(avx512_subkeyHtbl, hashkey_offset + hkey_gap + 0 * 64), Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(GHKEY1, Address(avx512_subkeyHtbl, hashkey_offset + 0 * 64), Assembler::AVX_512bit);\n+    __ evmovdquq(GHKEY2, Address(avx512_subkeyHtbl, hashkey_offset + hkey_gap + 0 * 64), Assembler::AVX_512bit);\n+  }\n+\n+  \/\/save counter for the next round\n+  \/\/increment counter overflow check register\n+  __ evshufi64x2(CTR_BE, B12_15, B12_15, 255, Assembler::AVX_512bit);\n+  __ addb(CTR_CHECK, 16);\n+\n+  \/\/pre - load constants\n+  ev_load_key(AESKEY2, key, 1 * 16, rbx);\n+  __ evmovdquq(GHDAT2, Address(avx512_subkeyHtbl, 16 * (ghashin_offset +4)), Assembler::AVX_512bit);\n+\n+  \/\/stitch AES rounds with GHASH\n+  \/\/AES round 0\n+  __ evpxorq(B00_03, B00_03, AESKEY1, Assembler::AVX_512bit);\n+  __ evpxorq(B04_07, B04_07, AESKEY1, Assembler::AVX_512bit);\n+  __ evpxorq(B08_11, B08_11, AESKEY1, Assembler::AVX_512bit);\n+  __ evpxorq(B12_15, B12_15, AESKEY1, Assembler::AVX_512bit);\n+  ev_load_key(AESKEY1, key, 2 * 16, rbx);\n+\n+  \/\/GHASH 4 blocks(15 to 12)\n+  carrylessMultiply(TLL1, TLH1, THL1, THH1, GHDAT1, GHKEY2, GHKEY1);\n+\n+  if (hk_broadcast) {\n+    __ evbroadcastf64x2(GHKEY1, Address(avx512_subkeyHtbl, hashkey_offset + 1 * 64), Assembler::AVX_512bit);\n+    __ evbroadcastf64x2(GHKEY2, Address(avx512_subkeyHtbl, hashkey_offset + hkey_gap + 1 * 64), Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(GHKEY1, Address(avx512_subkeyHtbl, hashkey_offset + 1 * 64), Assembler::AVX_512bit);\n+    __ evmovdquq(GHKEY2, Address(avx512_subkeyHtbl, hashkey_offset + hkey_gap + 1 * 64), Assembler::AVX_512bit);\n+  }\n+\n+  __ evmovdquq(GHDAT1, Address(avx512_subkeyHtbl, 16 * (ghashin_offset + 8)), Assembler::AVX_512bit);\n+\n+  \/\/AES round 1\n+  roundEncode(AESKEY2, B00_03, B04_07, B08_11, B12_15);\n+\n+  ev_load_key(AESKEY2, key, 3 * 16, rbx);\n+\n+  \/\/GHASH 4 blocks(11 to 8)\n+  carrylessMultiply(TLL2, TLH2, THL2, THH2, GHDAT2, GHKEY2, GHKEY1);\n+\n+  if (hk_broadcast) {\n+    __ evbroadcastf64x2(GHKEY1, Address(avx512_subkeyHtbl, hashkey_offset + 2 * 64), Assembler::AVX_512bit);\n+    __ evbroadcastf64x2(GHKEY2, Address(avx512_subkeyHtbl, hashkey_offset + hkey_gap + 2 * 64), Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(GHKEY1, Address(avx512_subkeyHtbl, hashkey_offset + 2 * 64 ), Assembler::AVX_512bit);\n+    __ evmovdquq(GHKEY2, Address(avx512_subkeyHtbl, hashkey_offset + hkey_gap + 2 * 64), Assembler::AVX_512bit);\n+  }\n+  __ evmovdquq(GHDAT2, Address(avx512_subkeyHtbl, 16 * (ghashin_offset + 12)), Assembler::AVX_512bit);\n+\n+  \/\/AES round 2\n+  roundEncode(AESKEY1, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(AESKEY1, key, 4 * 16, rbx);\n+\n+  \/\/GHASH 4 blocks(7 to 4)\n+  carrylessMultiply(TLL3, TLH3, THL3, THH3, GHDAT1, GHKEY2, GHKEY1);\n+\n+  if (hk_broadcast) {\n+    __ evbroadcastf64x2(GHKEY1, Address(avx512_subkeyHtbl, hashkey_offset + 3 * 64), Assembler::AVX_512bit);\n+    __ evbroadcastf64x2(GHKEY2, Address(avx512_subkeyHtbl, hashkey_offset + hkey_gap + 3 * 64), Assembler::AVX_512bit);\n+  } else {\n+    __ evmovdquq(GHKEY1, Address(avx512_subkeyHtbl, hashkey_offset + 3 * 64), Assembler::AVX_512bit);\n+    __ evmovdquq(GHKEY2, Address(avx512_subkeyHtbl, hashkey_offset + hkey_gap + 3 * 64), Assembler::AVX_512bit);\n+  }\n+\n+  \/\/AES rounds 3\n+  roundEncode(AESKEY2, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(AESKEY2, key, 5 * 16, rbx);\n+\n+  \/\/Gather(XOR) GHASH for 12 blocks\n+  xorGHASH(TLL1, TLH1, THL1, THH1, TLL2, TLL3, TLH2, TLH3, THL2, THL3, THH2, THH3);\n+\n+  \/\/AES rounds 4\n+  roundEncode(AESKEY1, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(AESKEY1, key, 6 * 16, rbx);\n+\n+  \/\/load plain \/ cipher text(recycle GH3xx registers)\n+  loadData(in, pos, DATA1, DATA2, DATA3, DATA4);\n+\n+  \/\/AES rounds 5\n+  roundEncode(AESKEY2, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(AESKEY2, key, 7 * 16, rbx);\n+\n+  \/\/GHASH 4 blocks(3 to 0)\n+  carrylessMultiply(TLL2, TLH2, THL2, THH2, GHDAT2, GHKEY2, GHKEY1);\n+\n+  \/\/AES round 6\n+  roundEncode(AESKEY1, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(AESKEY1, key, 8 * 16, rbx);\n+\n+  \/\/gather GHASH in TO_REDUCE_H \/ L\n+  if (is_hash_start) {\n+    __ evpxorq(TO_REDUCE_L, TLL2, THL2, Assembler::AVX_512bit);\n+    __ evpxorq(TO_REDUCE_H, THH2, TLH2, Assembler::AVX_512bit);\n+    __ vpternlogq(TO_REDUCE_L, 0x96, TLL1, THL1, Assembler::AVX_512bit);\n+    __ vpternlogq(TO_REDUCE_H, 0x96, THH1, TLH1, Assembler::AVX_512bit);\n+  } else {\n+    \/\/not the first round so sums need to be updated\n+    xorGHASH(TO_REDUCE_L, TO_REDUCE_H, TO_REDUCE_L, TO_REDUCE_H, TLL2, THL2, THH2, TLH2, TLL1, THL1, THH1, TLH1);\n+  }\n+\n+  \/\/AES round 7\n+  roundEncode(AESKEY2, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(AESKEY2, key, 9 * 16, rbx);\n+\n+  \/\/new reduction\n+  if (do_hash_reduction) {\n+    __ evmovdquq(ZT, ExternalAddress(ghash_polynomial_reduction_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n+    __ evpclmulqdq(THH1, TO_REDUCE_L, ZT, 0x10, Assembler::AVX_512bit);\n+    __ vpshufd(TO_REDUCE_L, TO_REDUCE_L, 78, Assembler::AVX_512bit);\n+    __ vpternlogq(THH1, 0x96, TO_REDUCE_H, TO_REDUCE_L, Assembler::AVX_512bit);\n+  }\n+\n+  \/\/AES round 8\n+  roundEncode(AESKEY1, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(AESKEY1, key, 10 * 16, rbx);\n+\n+  \/\/horizontalxor of 4 reduced hashes\n+  if (do_hash_hxor) {\n+    vhpxori4x128(THH1, TLL1);\n+  }\n+\n+  \/\/AES round 9\n+  roundEncode(AESKEY2, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(AESKEY2, key, 11 * 16, rbx);\n+  \/\/AES rounds up to 11 (AES192) or 13 (AES256)\n+  \/\/AES128 is done\n+  __ cmpl(NROUNDS, 52);\n+  __ jcc(Assembler::less, last_aes_rnd);\n+  __ bind(aes_192);\n+  roundEncode(AESKEY1, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(AESKEY1, key, 12 * 16, rbx);\n+  roundEncode(AESKEY2, B00_03, B04_07, B08_11, B12_15);\n+  __ cmpl(NROUNDS, 60);\n+  __ jcc(Assembler::less, last_aes_rnd);\n+  __ bind(aes_256);\n+  ev_load_key(AESKEY2, key, 13 * 16, rbx);\n+  roundEncode(AESKEY1, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(AESKEY1, key, 14 * 16, rbx);\n+  roundEncode(AESKEY2, B00_03, B04_07, B08_11, B12_15);\n+\n+  __ bind(last_aes_rnd);\n+  \/\/the last AES round\n+  lastroundEncode(AESKEY1, B00_03, B04_07, B08_11, B12_15);\n+  \/\/AESKEY1and AESKEY2 contain AES round keys\n+\n+  \/\/XOR against plain \/ cipher text\n+  xorBeforeStore(B00_03, B04_07, B08_11, B12_15, DATA1, DATA2, DATA3, DATA4);\n+\n+  \/\/store cipher \/ plain text\n+  storeData(out, pos, B00_03, B04_07, B08_11, B12_15);\n+  \/\/**B00_03, B04_07, B08_011, B12_B15 may contain sensitive data\n+\n+  \/\/shuffle cipher text blocks for GHASH computation\n+  __ cmpptr(ct, out);\n+  __ jcc(Assembler::notEqual, skip_shuffle);\n+  shuffle(B00_03, B04_07, B08_11, B12_15, B00_03, B04_07, B08_11, B12_15, SHFMSK);\n+  __ jmp(cont);\n+  __ bind(skip_shuffle);\n+  shuffle(B00_03, B04_07, B08_11, B12_15, DATA1, DATA2, DATA3, DATA4, SHFMSK);\n+\n+  \/\/**B00_03, B04_07, B08_011, B12_B15 overwritten with shuffled cipher text\n+  __ bind(cont);\n+  \/\/store shuffled cipher text for ghashing\n+  __ evmovdquq(Address(avx512_subkeyHtbl, 16 * aesout_offset), B00_03, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(avx512_subkeyHtbl, 16 * (aesout_offset + 4)), B04_07, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(avx512_subkeyHtbl, 16 * (aesout_offset + 8)), B08_11, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(avx512_subkeyHtbl, 16 * (aesout_offset + 12)), B12_15, Assembler::AVX_512bit);\n+}\n+\n+\n+\/\/Encrypt \/ decrypt the initial 16 blocks\n+void StubGenerator::initial_blocks_16_avx512(Register in, Register out, Register ct, Register pos, Register key, Register avx512_subkeyHtbl,\n+                                             Register CTR_CHECK, Register rounds, XMMRegister CTR, XMMRegister GHASH,  XMMRegister ADDBE_4x4,\n+                                             XMMRegister ADDBE_1234, XMMRegister ADD_1234, XMMRegister SHUF_MASK, int stack_offset) {\n+  const XMMRegister B00_03 = xmm7;\n+  const XMMRegister B04_07 = xmm10;\n+  const XMMRegister B08_11 = xmm11;\n+  const XMMRegister B12_15 = xmm12;\n+  const XMMRegister T0 = xmm0;\n+  const XMMRegister T1 = xmm3;\n+  const XMMRegister T2 = xmm4;\n+  const XMMRegister T3 = xmm5;\n+  const XMMRegister T4 = xmm6;\n+  const XMMRegister T5 = xmm30;\n+\n+  Label next_16_overflow, next_16_ok, cont, skip_shuffle, aes_256, aes_192, last_aes_rnd;\n+  \/\/prepare counter blocks\n+  __ cmpb(CTR_CHECK, (256 - 16));\n+  __ jcc(Assembler::aboveEqual, next_16_overflow);\n+  __ vpaddd(B00_03, CTR, ADDBE_1234, Assembler::AVX_512bit);\n+  __ vpaddd(B04_07, B00_03, ADDBE_4x4, Assembler::AVX_512bit);\n+  __ vpaddd(B08_11, B04_07, ADDBE_4x4, Assembler::AVX_512bit);\n+  __ vpaddd(B12_15, B08_11, ADDBE_4x4, Assembler::AVX_512bit);\n+  __ jmp(next_16_ok);\n+  __ bind(next_16_overflow);\n+  __ vpshufb(CTR, CTR, SHUF_MASK, Assembler::AVX_512bit);\n+  __ evmovdquq(B12_15, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, rbx);\n+  __ vpaddd(B00_03, CTR, ADD_1234, Assembler::AVX_512bit);\n+  __ vpaddd(B04_07, B00_03, B12_15, Assembler::AVX_512bit);\n+  __ vpaddd(B08_11, B04_07, B12_15, Assembler::AVX_512bit);\n+  __ vpaddd(B12_15, B08_11, B12_15, Assembler::AVX_512bit);\n+  shuffle(B00_03, B04_07, B08_11, B12_15, B00_03, B04_07, B08_11, B12_15, SHUF_MASK);\n+  __ bind(next_16_ok);\n+  __ evshufi64x2(CTR, B12_15, B12_15, 255, Assembler::AVX_512bit);\n+  __ addb(CTR_CHECK, 16);\n+\n+  \/\/load 16 blocks of data\n+  loadData(in, pos, T0, T1, T2, T3);\n+\n+  \/\/move to AES encryption rounds\n+  __ movdqu(T5, ExternalAddress(key_shuffle_mask_addr()), rbx \/*rscratch*\/);\n+  ev_load_key(T4, key, 0, T5);\n+  __ evpxorq(B00_03, B00_03, T4, Assembler::AVX_512bit);\n+  __ evpxorq(B04_07, B04_07, T4, Assembler::AVX_512bit);\n+  __ evpxorq(B08_11, B08_11, T4, Assembler::AVX_512bit);\n+  __ evpxorq(B12_15, B12_15, T4, Assembler::AVX_512bit);\n+\n+  for (int i = 1; i < 10; i++) {\n+    ev_load_key(T4, key, i * 16, T5);\n+    roundEncode(T4, B00_03, B04_07, B08_11, B12_15);\n+  }\n+\n+  ev_load_key(T4, key, 10 * 16, T5);\n@@ -3007,8 +3299,6 @@\n-  __ jcc(Assembler::greaterEqual, AES_192);\n-  __ jmp(LAST_AES_RND);\n-  \/\/ AES rounds up to 11 (AES192) or 13 (AES256)\n-  __ bind(AES_192);\n-  roundEncode(ZTMP17, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP18, key, 11 * 16, xmm29);\n-  roundEncode(ZTMP18, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP17, key, 12 * 16, xmm29);\n+  __ jcc(Assembler::less, last_aes_rnd);\n+  __ bind(aes_192);\n+  roundEncode(T4, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(T4, key, 16 * 11, T5);\n+  roundEncode(T4, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(T4, key, 16 * 12, T5);\n@@ -3016,25 +3306,30 @@\n-  __ jcc(Assembler::aboveEqual, AES_256);\n-  __ jmp(LAST_AES_RND);\n-\n-  __ bind(AES_256);\n-  roundEncode(ZTMP17, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP18, key, 13 * 16, xmm29);\n-  roundEncode(ZTMP18, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  ev_load_key(ZTMP17, key, 14 * 16, xmm29);\n-\n-  __ bind(LAST_AES_RND);\n-  \/\/ Second phase of reduction\n-  if (final_reduction) {\n-    __ evpclmulqdq(ZTMP9, ZTMP12, ZTMP10, 0x00, Assembler::AVX_128bit);\n-    __ vpsrldq(ZTMP9, ZTMP9, 4, Assembler::AVX_128bit); \/\/ Shift-R 1-DW to obtain 2-DWs shift-R\n-    __ evpclmulqdq(ZTMP11, ZTMP12, ZTMP10, 0x10, Assembler::AVX_128bit);\n-    __ vpslldq(ZTMP11, ZTMP11, 4, Assembler::AVX_128bit); \/\/ Shift-L 1-DW for result\n-    \/\/ ZTMP5 = ZTMP5 X ZTMP11 X ZTMP9\n-    __ vpternlogq(ZTMP5, 0x96, ZTMP11, ZTMP9, Assembler::AVX_128bit);\n-  }\n-  \/\/ Last AES round\n-  lastroundEncode(ZTMP17, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  \/\/ XOR against plain \/ cipher text\n-  xorBeforeStore(ZTMP0, ZTMP1, ZTMP2, ZTMP3, ZTMP13, ZTMP14, ZTMP15, ZTMP16);\n-  \/\/ store cipher \/ plain text\n-  storeData(out, pos, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n+  __ jcc(Assembler::less, last_aes_rnd);\n+  __ bind(aes_256);\n+  roundEncode(T4, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(T4, key, 16 * 13, T5);\n+  roundEncode(T4, B00_03, B04_07, B08_11, B12_15);\n+  ev_load_key(T4, key, 16 * 14, T5);\n+\n+  __ bind(last_aes_rnd);\n+  lastroundEncode(T4, B00_03, B04_07, B08_11, B12_15);\n+\n+  \/\/xor against text\n+  xorBeforeStore(B00_03, B04_07, B08_11, B12_15, T0, T1, T2, T3);\n+\n+  \/\/store\n+  storeData(out, pos, B00_03, B04_07, B08_11, B12_15);\n+\n+  __ cmpptr(ct, out);\n+  __ jcc(Assembler::equal, skip_shuffle);\n+  \/\/decryption - cipher text needs to go to GHASH phase\n+  shuffle(B00_03, B04_07, B08_11, B12_15, T0, T1, T2, T3, SHUF_MASK);\n+  __ jmp(cont);\n+  __ bind(skip_shuffle);\n+  shuffle(B00_03, B04_07, B08_11, B12_15, B00_03, B04_07, B08_11, B12_15, SHUF_MASK);\n+\n+  \/\/B00_03, B04_07, B08_11, B12_15 overwritten with shuffled cipher text\n+  __ bind(cont);\n+  __ evmovdquq(Address(avx512_subkeyHtbl, 16 * stack_offset), B00_03, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(avx512_subkeyHtbl, 16 * (stack_offset + 4)), B04_07, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(avx512_subkeyHtbl, 16 * (stack_offset + 8)), B08_11, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(avx512_subkeyHtbl, 16 * (stack_offset + 12)), B12_15, Assembler::AVX_512bit);\n@@ -3043,5 +3338,5 @@\n-void StubGenerator::aesgcm_encrypt(Register in, Register len, Register ct, Register out, Register key,\n-                                   Register state, Register subkeyHtbl, Register avx512_subkeyHtbl, Register counter) {\n-  Label ENC_DEC_DONE, GENERATE_HTBL_48_BLKS, AES_192, AES_256, STORE_CT, GHASH_LAST_32,\n-        AES_32_BLOCKS, GHASH_AES_PARALLEL, LOOP, ACCUMULATE, GHASH_16_AES_16;\n-  const XMMRegister CTR_BLOCKx = xmm9;\n+void StubGenerator::aesgcm_avx512(Register in, Register len, Register ct, Register out, Register key, Register state,\n+                                  Register subkeyHtbl, Register avx512_subkeyHtbl, Register counter) {\n+  Label ENC_DEC_DONE, MESG_BELOW_32_BLKS, NO_BIG_BLKS, ENCRYPT_BIG_BLKS_NO_HXOR,\n+        ENCRYPT_BIG_NBLKS, ENCRYPT_16_BLKS, ENCRYPT_N_GHASH_32_N_BLKS, GHASH_DONE;\n+  const XMMRegister CTR_BLOCKx = xmm2;\n@@ -3049,3 +3344,0 @@\n-  const Register pos = rax;\n-  const Register rounds = r15;\n-  const Register ghash_pos = NOT_WIN64( r14) WIN64_ONLY( r11 );\n@@ -3053,3 +3345,3 @@\n-  const XMMRegister ZTMP1 = xmm3;\n-  const XMMRegister ZTMP2 = xmm4;\n-  const XMMRegister ZTMP3 = xmm5;\n+  const XMMRegister ZTMP1 = xmm3; \/\/**sensitive\n+  const XMMRegister ZTMP2 = xmm4; \/\/**sensitive(small data)\n+  const XMMRegister ZTMP3 = xmm5; \/\/**sensitive(small data)\n@@ -3069,6 +3361,17 @@\n-  const XMMRegister COUNTER_INC_MASK = xmm18;\n-\n-  __ movl(pos, 0); \/\/ Total length processed\n-  \/\/ Min data size processed = 768 bytes\n-  __ cmpl(len, 768);\n-  __ jcc(Assembler::less, ENC_DEC_DONE);\n+  const XMMRegister ZTMP17 = xmm31;\n+  const XMMRegister ZTMP18 = xmm1;\n+  const XMMRegister ZTMP19 = xmm18;\n+  const XMMRegister ZTMP20 = xmm8;\n+  const XMMRegister ZTMP21 = xmm22;\n+  const XMMRegister ZTMP22 = xmm23;\n+  const XMMRegister ZTMP23 = xmm26;\n+  const XMMRegister GH = xmm24;\n+  const XMMRegister GL = xmm25;\n+  const XMMRegister SHUF_MASK = xmm29;\n+  const XMMRegister ADDBE_4x4 = xmm27;\n+  const XMMRegister ADDBE_1234 = xmm28;\n+  const XMMRegister ADD_1234 = xmm9;\n+  const KRegister MASKREG = k1;\n+  const Register pos = rax;\n+  const Register rounds = r15;\n+  const Register CTR_CHECK = r14;\n@@ -3076,4 +3379,7 @@\n-  \/\/ Generate 48 constants for htbl\n-  __ call(GENERATE_HTBL_48_BLKS, relocInfo::none);\n-  int index = 0; \/\/ Index for choosing subkeyHtbl entry\n-  __ movl(ghash_pos, 0); \/\/ Pointer for ghash read and store operations\n+  const int stack_offset = 64;\n+  const int ghashin_offset = 64;\n+  const int aesout_offset = 64;\n+  const int hashkey_offset = 0;\n+  const int hashkey_gap = 16 * 32;\n+  const int HashKey_32 = 0;\n+  const int HashKey_16 = 16 * 16;\n@@ -3081,1 +3387,34 @@\n-  \/\/ Move initial counter value and STATE value into variables\n+  __ movl(pos, 0);\n+  __ cmpl(len, 256);\n+  __ jcc(Assembler::lessEqual, ENC_DEC_DONE);\n+\n+  \/* Structure of the Htbl is as follows:\n+  *   Where 0 - 31 we have 32 Hashkey's and 32-63 we have 32 HashKeyK (derived from HashKey)\n+  *   Rest 8 entries are for storing CTR values post AES rounds\n+  * ----------------------------------------------------------------------------------------\n+      Hashkey32 -> 16 * 0\n+      Hashkey31 -> 16 * 1\n+      Hashkey30 -> 16 * 2\n+      ........\n+      Hashkey1 -> 16 * 31\n+      ---------------------\n+      HaskeyK32 -> 16 * 32\n+      HashkeyK31 -> 16 * 33\n+      .........\n+      HashkeyK1 -> 16 * 63\n+      ---------------------\n+      1st set of AES Entries\n+      B00_03 -> 16 * 64\n+      B04_07 -> 16 * 68\n+      B08_11 -> 16 * 72\n+      B12_15 -> 16 * 80\n+      ---------------------\n+      2nd set of AES Entries\n+      B00_03 -> 16 * 84\n+      B04_07 -> 16 * 88\n+      B08_11 -> 16 * 92\n+      B12_15 -> 16 * 96\n+      ---------------------*\/\n+  generateHtbl_32_blocks_avx512(subkeyHtbl, avx512_subkeyHtbl);\n+\n+  \/\/Move initial counter value and STATE value into variables\n@@ -3084,1 +3423,2 @@\n-  \/\/ Load lswap mask for ghash\n+\n+  \/\/Load lswap mask for ghash\n@@ -3086,1 +3426,1 @@\n-  \/\/ Shuffle input state using lswap mask\n+  \/\/Shuffle input state using lswap mask\n@@ -3092,1 +3432,8 @@\n-  \/\/ Broadcast counter value to 512 bit register\n+  __ evmovdquq(ADDBE_4x4, ExternalAddress(counter_mask_addbe_4444_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n+  __ evmovdquq(ADDBE_1234, ExternalAddress(counter_mask_addbe_1234_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n+  __ evmovdquq(SHUF_MASK, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n+  __ evmovdquq(ADD_1234, ExternalAddress(counter_mask_add_1234_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n+\n+  \/\/Shuffle counter, subtract 1 from the pre-incremented counter value and broadcast counter value to 512 bit register\n+  __ vpshufb(CTR_BLOCKx, CTR_BLOCKx, SHUF_MASK, Assembler::AVX_128bit);\n+  __ vpsubd(CTR_BLOCKx, CTR_BLOCKx, ADD_1234, Assembler::AVX_128bit);\n@@ -3094,171 +3441,0 @@\n-  \/\/ Load counter shuffle mask\n-  __ evmovdquq(xmm24, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n-  \/\/ Shuffle counter\n-  __ vpshufb(CTR_BLOCKx, CTR_BLOCKx, xmm24, Assembler::AVX_512bit);\n-\n-  \/\/ Load mask for incrementing counter\n-  __ evmovdquq(COUNTER_INC_MASK, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n-  \/\/ Pre-increment counter\n-  __ vpaddd(ZTMP5, CTR_BLOCKx, ExternalAddress(counter_mask_linc0_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n-  __ vpaddd(ZTMP6, ZTMP5, COUNTER_INC_MASK, Assembler::AVX_512bit);\n-  __ vpaddd(ZTMP7, ZTMP6, COUNTER_INC_MASK, Assembler::AVX_512bit);\n-  __ vpaddd(ZTMP8, ZTMP7, COUNTER_INC_MASK, Assembler::AVX_512bit);\n-\n-  \/\/ Begin 32 blocks of AES processing\n-  __ bind(AES_32_BLOCKS);\n-  \/\/ Save incremented counter before overwriting it with AES data\n-  __ evmovdquq(CTR_BLOCKx, ZTMP8, Assembler::AVX_512bit);\n-\n-  \/\/ Move 256 bytes of data\n-  loadData(in, pos, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  \/\/ Load key shuffle mask\n-  __ movdqu(xmm29, ExternalAddress(key_shuffle_mask_addr()), rbx \/*rscratch*\/);\n-  \/\/ Load 0th AES round key\n-  ev_load_key(ZTMP4, key, 0, xmm29);\n-  \/\/ AES-ROUND0, xmm24 has the shuffle mask\n-  shuffleExorRnd1Key(ZTMP5, ZTMP6, ZTMP7, ZTMP8, xmm24, ZTMP4);\n-\n-  for (int j = 1; j < 10; j++) {\n-      ev_load_key(ZTMP4, key, j * 16, xmm29);\n-      roundEncode(ZTMP4, ZTMP5, ZTMP6, ZTMP7, ZTMP8);\n-  }\n-  ev_load_key(ZTMP4, key, 10 * 16, xmm29);\n-  \/\/ AES rounds up to 11 (AES192) or 13 (AES256)\n-  __ cmpl(rounds, 52);\n-  __ jcc(Assembler::greaterEqual, AES_192);\n-  lastroundEncode(ZTMP4, ZTMP5, ZTMP6, ZTMP7, ZTMP8);\n-  __ jmp(STORE_CT);\n-\n-  __ bind(AES_192);\n-  roundEncode(ZTMP4, ZTMP5, ZTMP6, ZTMP7, ZTMP8);\n-  ev_load_key(ZTMP4, key, 11 * 16, xmm29);\n-  roundEncode(ZTMP4, ZTMP5, ZTMP6, ZTMP7, ZTMP8);\n-  __ cmpl(rounds, 60);\n-  __ jcc(Assembler::aboveEqual, AES_256);\n-  ev_load_key(ZTMP4, key, 12 * 16, xmm29);\n-  lastroundEncode(ZTMP4, ZTMP5, ZTMP6, ZTMP7, ZTMP8);\n-  __ jmp(STORE_CT);\n-\n-  __ bind(AES_256);\n-  ev_load_key(ZTMP4, key, 12 * 16, xmm29);\n-  roundEncode(ZTMP4, ZTMP5, ZTMP6, ZTMP7, ZTMP8);\n-  ev_load_key(ZTMP4, key, 13 * 16, xmm29);\n-  roundEncode(ZTMP4, ZTMP5, ZTMP6, ZTMP7, ZTMP8);\n-  ev_load_key(ZTMP4, key, 14 * 16, xmm29);\n-  \/\/ Last AES round\n-  lastroundEncode(ZTMP4, ZTMP5, ZTMP6, ZTMP7, ZTMP8);\n-\n-  __ bind(STORE_CT);\n-  \/\/ Xor the encrypted key with PT to obtain CT\n-  xorBeforeStore(ZTMP5, ZTMP6, ZTMP7, ZTMP8, ZTMP0, ZTMP1, ZTMP2, ZTMP3);\n-  storeData(out, pos, ZTMP5, ZTMP6, ZTMP7, ZTMP8);\n-  \/\/ 16 blocks encryption completed\n-  __ addl(pos, 256);\n-  __ cmpl(pos, 512);\n-  __ jcc(Assembler::aboveEqual, GHASH_AES_PARALLEL);\n-  __ vpaddd(ZTMP5, CTR_BLOCKx, COUNTER_INC_MASK, Assembler::AVX_512bit);\n-  __ vpaddd(ZTMP6, ZTMP5, COUNTER_INC_MASK, Assembler::AVX_512bit);\n-  __ vpaddd(ZTMP7, ZTMP6, COUNTER_INC_MASK, Assembler::AVX_512bit);\n-  __ vpaddd(ZTMP8, ZTMP7, COUNTER_INC_MASK, Assembler::AVX_512bit);\n-  __ jmp(AES_32_BLOCKS);\n-\n-  __ bind(GHASH_AES_PARALLEL);\n-  \/\/ Ghash16_encrypt16_parallel takes place in the order with three reduction values:\n-  \/\/ 1) First time -> cipher xor input ghash\n-  \/\/ 2) No reduction -> accumulate multiplication values\n-  \/\/ 3) Final reduction post 48 blocks -> new ghash value is computed for the next round\n-  \/\/ Reduction value = first time\n-  ghash16_encrypt16_parallel(key, avx512_subkeyHtbl, CTR_BLOCKx, AAD_HASHx, in, out, ct, pos, true, xmm24, true, rounds, ghash_pos, false, index, COUNTER_INC_MASK);\n-  __ addl(pos, 256);\n-  __ addl(ghash_pos, 256);\n-  index += 4;\n-\n-  \/\/ At this point we have processed 768 bytes of AES and 256 bytes of GHASH.\n-  \/\/ If the remaining length is less than 768, process remaining 512 bytes of ghash in GHASH_LAST_32 code\n-  __ subl(len, 768);\n-  __ cmpl(len, 768);\n-  __ jcc(Assembler::less, GHASH_LAST_32);\n-\n-  \/\/ AES 16 blocks and GHASH 16 blocks in parallel\n-  \/\/ For multiples of 48 blocks we will do ghash16_encrypt16 interleaved multiple times\n-  \/\/ Reduction value = no reduction means that the carryless multiplication values are accumulated for further calculations\n-  \/\/ Each call uses 4 subkeyHtbl values, so increment the index by 4.\n-  __ bind(GHASH_16_AES_16);\n-  \/\/ Reduction value = no reduction\n-  ghash16_encrypt16_parallel(key, avx512_subkeyHtbl, CTR_BLOCKx, AAD_HASHx, in, out, ct, pos, false, xmm24, false, rounds, ghash_pos, false, index, COUNTER_INC_MASK);\n-  __ addl(pos, 256);\n-  __ addl(ghash_pos, 256);\n-  index += 4;\n-  \/\/ Reduction value = final reduction means that the accumulated values have to be reduced as we have completed 48 blocks of ghash\n-  ghash16_encrypt16_parallel(key, avx512_subkeyHtbl, CTR_BLOCKx, AAD_HASHx, in, out, ct, pos, false, xmm24, false, rounds, ghash_pos, true, index, COUNTER_INC_MASK);\n-  __ addl(pos, 256);\n-  __ addl(ghash_pos, 256);\n-  \/\/ Calculated ghash value needs to be __ moved to AAD_HASHX so that we can restart the ghash16-aes16 pipeline\n-  __ movdqu(AAD_HASHx, ZTMP5);\n-  index = 0; \/\/ Reset subkeyHtbl index\n-\n-  \/\/ Restart the pipeline\n-  \/\/ Reduction value = first time\n-  ghash16_encrypt16_parallel(key, avx512_subkeyHtbl, CTR_BLOCKx, AAD_HASHx, in, out, ct, pos, true, xmm24, true, rounds, ghash_pos, false, index, COUNTER_INC_MASK);\n-  __ addl(pos, 256);\n-  __ addl(ghash_pos, 256);\n-  index += 4;\n-\n-  __ subl(len, 768);\n-  __ cmpl(len, 768);\n-  __ jcc(Assembler::greaterEqual, GHASH_16_AES_16);\n-\n-  \/\/ GHASH last 32 blocks processed here\n-  \/\/ GHASH products accumulated in ZMM27, ZMM25 and ZMM26 during GHASH16-AES16 operation is used\n-  __ bind(GHASH_LAST_32);\n-  \/\/ Use rbx as a pointer to the htbl; For last 32 blocks of GHASH, use key# 4-11 entry in subkeyHtbl\n-  __ movl(rbx, 256);\n-  \/\/ Load cipher blocks\n-  __ evmovdquq(ZTMP13, Address(ct, ghash_pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);\n-  __ evmovdquq(ZTMP14, Address(ct, ghash_pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);\n-  __ vpshufb(ZTMP13, ZTMP13, xmm24, Assembler::AVX_512bit);\n-  __ vpshufb(ZTMP14, ZTMP14, xmm24, Assembler::AVX_512bit);\n-  \/\/ Load ghash keys\n-  __ evmovdquq(ZTMP15, Address(avx512_subkeyHtbl, rbx, Address::times_1, 0 * 64), Assembler::AVX_512bit);\n-  __ evmovdquq(ZTMP16, Address(avx512_subkeyHtbl, rbx, Address::times_1, 1 * 64), Assembler::AVX_512bit);\n-\n-  \/\/ Ghash blocks 0 - 3\n-  carrylessMultiply(ZTMP2, ZTMP3, ZTMP4, ZTMP1, ZTMP13, ZTMP15);\n-  \/\/ Ghash blocks 4 - 7\n-  carrylessMultiply(ZTMP6, ZTMP7, ZTMP8, ZTMP5, ZTMP14, ZTMP16);\n-\n-  __ vpternlogq(ZTMP1, 0x96, ZTMP5, xmm27, Assembler::AVX_512bit); \/\/ ZTMP1 = ZTMP1 + ZTMP5 + zmm27\n-  __ vpternlogq(ZTMP2, 0x96, ZTMP6, xmm26, Assembler::AVX_512bit); \/\/ ZTMP2 = ZTMP2 + ZTMP6 + zmm26\n-  __ vpternlogq(ZTMP3, 0x96, ZTMP7, xmm25, Assembler::AVX_512bit); \/\/ ZTMP3 = ZTMP3 + ZTMP7 + zmm25\n-  __ evpxorq(ZTMP4, ZTMP4, ZTMP8, Assembler::AVX_512bit);          \/\/ ZTMP4 = ZTMP4 + ZTMP8\n-\n-  __ addl(ghash_pos, 128);\n-  __ addl(rbx, 128);\n-\n-  \/\/ Ghash remaining blocks\n-  __ bind(LOOP);\n-  __ cmpl(ghash_pos, pos);\n-  __ jcc(Assembler::aboveEqual, ACCUMULATE);\n-  \/\/ Load next cipher blocks and corresponding ghash keys\n-  __ evmovdquq(ZTMP13, Address(ct, ghash_pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);\n-  __ evmovdquq(ZTMP14, Address(ct, ghash_pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);\n-  __ vpshufb(ZTMP13, ZTMP13, xmm24, Assembler::AVX_512bit);\n-  __ vpshufb(ZTMP14, ZTMP14, xmm24, Assembler::AVX_512bit);\n-  __ evmovdquq(ZTMP15, Address(avx512_subkeyHtbl, rbx, Address::times_1, 0 * 64), Assembler::AVX_512bit);\n-  __ evmovdquq(ZTMP16, Address(avx512_subkeyHtbl, rbx, Address::times_1, 1 * 64), Assembler::AVX_512bit);\n-\n-  \/\/ ghash blocks 0 - 3\n-  carrylessMultiply(ZTMP6, ZTMP7, ZTMP8, ZTMP5, ZTMP13, ZTMP15);\n-\n-  \/\/ ghash blocks 4 - 7\n-  carrylessMultiply(ZTMP10, ZTMP11, ZTMP12, ZTMP9, ZTMP14, ZTMP16);\n-\n-  \/\/ update sums\n-  \/\/ ZTMP1 = ZTMP1 + ZTMP5 + ZTMP9\n-  \/\/ ZTMP2 = ZTMP2 + ZTMP6 + ZTMP10\n-  \/\/ ZTMP3 = ZTMP3 + ZTMP7 xor ZTMP11\n-  \/\/ ZTMP4 = ZTMP4 + ZTMP8 xor ZTMP12\n-  xorGHASH(ZTMP1, ZTMP2, ZTMP3, ZTMP4, ZTMP5, ZTMP9, ZTMP6, ZTMP10, ZTMP7, ZTMP11, ZTMP8, ZTMP12);\n-  __ addl(ghash_pos, 128);\n-  __ addl(rbx, 128);\n-  __ jmp(LOOP);\n@@ -3266,19 +3442,68 @@\n-  \/\/ Integrate ZTMP3\/ZTMP4 into ZTMP1 and ZTMP2\n-  __ bind(ACCUMULATE);\n-  __ evpxorq(ZTMP3, ZTMP3, ZTMP4, Assembler::AVX_512bit);\n-  __ vpsrldq(ZTMP7, ZTMP3, 8, Assembler::AVX_512bit);\n-  __ vpslldq(ZTMP8, ZTMP3, 8, Assembler::AVX_512bit);\n-  __ evpxorq(ZTMP1, ZTMP1, ZTMP7, Assembler::AVX_512bit);\n-  __ evpxorq(ZTMP2, ZTMP2, ZTMP8, Assembler::AVX_512bit);\n-\n-  \/\/ Add ZTMP1 and ZTMP2 128 - bit words horizontally\n-  vhpxori4x128(ZTMP1, ZTMP11);\n-  vhpxori4x128(ZTMP2, ZTMP12);\n-  \/\/ Load reduction polynomial and compute final reduction\n-  __ evmovdquq(ZTMP15, ExternalAddress(ghash_polynomial_reduction_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n-  vclmul_reduce(AAD_HASHx, ZTMP15, ZTMP1, ZTMP2, ZTMP3, ZTMP4);\n-\n-  \/\/ Pre-increment counter for next operation\n-  __ vpaddd(CTR_BLOCKx, CTR_BLOCKx, xmm18, Assembler::AVX_128bit);\n-  \/\/ Shuffle counter and save the updated value\n-  __ vpshufb(CTR_BLOCKx, CTR_BLOCKx, xmm24, Assembler::AVX_512bit);\n+  __ movdl(CTR_CHECK, CTR_BLOCKx);\n+  __ andl(CTR_CHECK, 255);\n+\n+  \/\/ Reshuffle counter\n+  __ vpshufb(CTR_BLOCKx, CTR_BLOCKx, SHUF_MASK, Assembler::AVX_512bit);\n+\n+  initial_blocks_16_avx512(in, out, ct, pos, key, avx512_subkeyHtbl, CTR_CHECK, rounds, CTR_BLOCKx, AAD_HASHx,  ADDBE_4x4, ADDBE_1234, ADD_1234, SHUF_MASK, stack_offset);\n+  __ addl(pos, 16 * 16);\n+  __ cmpl(len, 32 * 16);\n+  __ jcc(Assembler::below, MESG_BELOW_32_BLKS);\n+\n+  initial_blocks_16_avx512(in, out, ct, pos, key, avx512_subkeyHtbl, CTR_CHECK, rounds, CTR_BLOCKx, AAD_HASHx, ADDBE_4x4, ADDBE_1234, ADD_1234, SHUF_MASK, stack_offset + 16);\n+  __ addl(pos, 16 * 16);\n+  __ subl(len, 32 * 16);\n+\n+  __ cmpl(len, 32 * 16);\n+  __ jcc(Assembler::below, NO_BIG_BLKS);\n+\n+  __ bind(ENCRYPT_BIG_BLKS_NO_HXOR);\n+  __ cmpl(len, 2 * 32 * 16);\n+  __ jcc(Assembler::below, ENCRYPT_BIG_NBLKS);\n+  ghash16_encrypt_parallel16_avx512(in, out, ct, pos, avx512_subkeyHtbl, CTR_CHECK, rounds, key, CTR_BLOCKx, AAD_HASHx, ADDBE_4x4, ADDBE_1234, ADD_1234, SHUF_MASK,\n+                                    true, true, false, false, false, ghashin_offset, aesout_offset, HashKey_32);\n+  __ addl(pos, 16 * 16);\n+\n+  ghash16_encrypt_parallel16_avx512(in, out, ct, pos, avx512_subkeyHtbl, CTR_CHECK, rounds, key, CTR_BLOCKx, AAD_HASHx, ADDBE_4x4, ADDBE_1234, ADD_1234, SHUF_MASK,\n+                                    true, false, true, false, true, ghashin_offset + 16, aesout_offset + 16, HashKey_16);\n+  __ evmovdquq(AAD_HASHx, ZTMP4, Assembler::AVX_512bit);\n+  __ addl(pos, 16 * 16);\n+  __ subl(len, 32 * 16);\n+  __ jmp(ENCRYPT_BIG_BLKS_NO_HXOR);\n+\n+  __ bind(ENCRYPT_BIG_NBLKS);\n+  ghash16_encrypt_parallel16_avx512(in, out, ct, pos, avx512_subkeyHtbl, CTR_CHECK, rounds, key, CTR_BLOCKx, AAD_HASHx, ADDBE_4x4, ADDBE_1234, ADD_1234, SHUF_MASK,\n+                                    false, true, false, false, false, ghashin_offset, aesout_offset, HashKey_32);\n+  __ addl(pos, 16 * 16);\n+  ghash16_encrypt_parallel16_avx512(in, out, ct, pos, avx512_subkeyHtbl, CTR_CHECK, rounds, key, CTR_BLOCKx, AAD_HASHx, ADDBE_4x4, ADDBE_1234, ADD_1234, SHUF_MASK,\n+                                    false, false, true, true, true, ghashin_offset + 16, aesout_offset + 16, HashKey_16);\n+\n+  __ movdqu(AAD_HASHx, ZTMP4);\n+  __ addl(pos, 16 * 16);\n+  __ subl(len, 32 * 16);\n+\n+  __ bind(NO_BIG_BLKS);\n+  __ cmpl(len, 16 * 16);\n+  __ jcc(Assembler::aboveEqual, ENCRYPT_16_BLKS);\n+\n+  __ bind(ENCRYPT_N_GHASH_32_N_BLKS);\n+  ghash16_avx512(true, false, false, false, true, in, pos, avx512_subkeyHtbl, AAD_HASHx, SHUF_MASK, stack_offset, 0, 0, HashKey_32);\n+  gcm_enc_dec_last_avx512(len, in, pos, AAD_HASHx, SHUF_MASK, avx512_subkeyHtbl, ghashin_offset + 16, HashKey_16, false, true);\n+  __ jmp(GHASH_DONE);\n+\n+  __ bind(ENCRYPT_16_BLKS);\n+  ghash16_encrypt_parallel16_avx512(in, out, ct, pos, avx512_subkeyHtbl, CTR_CHECK, rounds, key, CTR_BLOCKx, AAD_HASHx, ADDBE_4x4, ADDBE_1234, ADD_1234, SHUF_MASK,\n+                                    false, true, false, false, false, ghashin_offset, aesout_offset, HashKey_32);\n+\n+  ghash16_avx512(false, true, false, false, true, in, pos, avx512_subkeyHtbl, AAD_HASHx, SHUF_MASK, stack_offset, 16 * 16, 0, HashKey_16);\n+\n+  __ bind(MESG_BELOW_32_BLKS);\n+  __ subl(len, 16 * 16);\n+  __ addl(pos, 16 * 16);\n+  gcm_enc_dec_last_avx512(len, in, pos, AAD_HASHx, SHUF_MASK, avx512_subkeyHtbl, ghashin_offset, HashKey_16, true, true);\n+\n+  __ bind(GHASH_DONE);\n+  \/\/Pre-increment counter for next operation, make sure that counter value is incremented on the LSB\n+  __ vpshufb(CTR_BLOCKx, CTR_BLOCKx, SHUF_MASK, Assembler::AVX_128bit);\n+  __ vpaddd(CTR_BLOCKx, CTR_BLOCKx, ADD_1234, Assembler::AVX_128bit);\n+  __ vpshufb(CTR_BLOCKx, CTR_BLOCKx, SHUF_MASK, Assembler::AVX_128bit);\n@@ -3286,1 +3511,1 @@\n-  \/\/ Load ghash lswap mask\n+  \/\/Load ghash lswap mask\n@@ -3288,1 +3513,1 @@\n-  \/\/ Shuffle ghash using lbswap_mask and store it\n+  \/\/Shuffle ghash using lbswap_mask and store it\n@@ -3291,1 +3516,0 @@\n-  __ jmp(ENC_DEC_DONE);\n@@ -3293,2 +3517,6 @@\n-  __ bind(GENERATE_HTBL_48_BLKS);\n-  generateHtbl_48_block_zmm(subkeyHtbl, avx512_subkeyHtbl, rbx \/*rscratch*\/);\n+  \/\/Zero out sensitive data\n+  __ evpxorq(ZTMP21, ZTMP21, ZTMP21, Assembler::AVX_512bit);\n+  __ evpxorq(ZTMP0, ZTMP0, ZTMP0, Assembler::AVX_512bit);\n+  __ evpxorq(ZTMP1, ZTMP1, ZTMP1, Assembler::AVX_512bit);\n+  __ evpxorq(ZTMP2, ZTMP2, ZTMP2, Assembler::AVX_512bit);\n+  __ evpxorq(ZTMP3, ZTMP3, ZTMP3, Assembler::AVX_512bit);\n@@ -3297,1 +3525,0 @@\n-  __ movq(rax, pos);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":723,"deletions":496,"binary":false,"changes":1219,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2019, 2021, Intel Corporation. All rights reserved.\n+* Copyright (c) 2019, 2024, Intel Corporation. All rights reserved.\n@@ -60,1 +60,4 @@\n-    0x0000000000000001UL, 0xC200000000000000UL,\n+    0x0000000000000001ULL, 0xC200000000000000ULL,\n+    0x0000000000000001ULL, 0xC200000000000000ULL,\n+    0x0000000000000001ULL, 0xC200000000000000ULL,\n+    0x0000000000000001ULL, 0xC200000000000000ULL\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_ghash.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2460,0 +2460,4 @@\n+  if (is_encode_and_store_pattern(n, m)) {\n+    mstack.push(m, Visit);\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4344,0 +4344,1 @@\n+   predicate(n->as_Load()->barrier_data() == 0);\n@@ -5129,0 +5130,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -5153,1 +5155,1 @@\n-  predicate(CompressedOops::base() == nullptr);\n+  predicate(CompressedOops::base() == nullptr && n->as_Store()->barrier_data() == 0);\n@@ -5166,0 +5168,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -7165,0 +7168,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -7252,0 +7256,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -7473,0 +7478,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -11662,0 +11668,1 @@\n+  predicate(n->in(2)->as_Load()->barrier_data() == 0);\n@@ -11683,0 +11690,1 @@\n+  predicate(n->in(2)->as_Load()->barrier_data() == 0);\n@@ -11723,1 +11731,2 @@\n-  predicate(CompressedOops::base() != nullptr);\n+  predicate(CompressedOops::base() != nullptr &&\n+            n->in(1)->as_Load()->barrier_data() == 0);\n@@ -11736,1 +11745,2 @@\n-  predicate(CompressedOops::base() == nullptr);\n+  predicate(CompressedOops::base() == nullptr &&\n+            n->in(1)->as_Load()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -119,5 +119,0 @@\n-  if ((LockingMode != LM_LEGACY) && (LockingMode != LM_MONITOR)) {\n-    warning(\"Unsupported locking mode for this CPU.\");\n-    FLAG_SET_DEFAULT(LockingMode, LM_LEGACY);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -488,12 +488,16 @@\n-    BasicLock *lock = monitor->lock();\n-    markWord header = lock->displaced_header();\n-    oop rcvr = monitor->obj();\n-    monitor->set_obj(nullptr);\n-\n-    bool dec_monitor_count = true;\n-    if (header.to_pointer() != nullptr) {\n-      markWord old_header = markWord::encode(lock);\n-      if (rcvr->cas_set_mark(header, old_header) != old_header) {\n-        monitor->set_obj(rcvr);\n-        dec_monitor_count = false;\n-        InterpreterRuntime::monitorexit(monitor);\n+    bool success = false;\n+    if (LockingMode == LM_LEGACY) {\n+      BasicLock* lock = monitor->lock();\n+      oop rcvr = monitor->obj();\n+      monitor->set_obj(nullptr);\n+      success = true;\n+      markWord header = lock->displaced_header();\n+      if (header.to_pointer() != nullptr) { \/\/ Check for recursive lock\n+        markWord old_header = markWord::encode(lock);\n+        if (rcvr->cas_set_mark(header, old_header) != old_header) {\n+          monitor->set_obj(rcvr);\n+          success = false;\n+        }\n+      }\n+      if (success) {\n+        THREAD->dec_held_monitor_count();\n@@ -502,2 +506,2 @@\n-    if (dec_monitor_count) {\n-      THREAD->dec_held_monitor_count();\n+    if (!success) {\n+      InterpreterRuntime::monitorexit(monitor);\n@@ -507,1 +511,1 @@\n- unwind_and_return:\n+  unwind_and_return:\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"gc\/shared\/gcLogPrecious.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"gc\/z\/zInitialize.hpp\"\n@@ -85,1 +85,1 @@\n-    log_error_pd(gc)(\"Failed to reserve address space for backing memory\");\n+    ZInitialize::error(\"Failed to reserve address space for backing memory\");\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zPhysicalMemoryBacking_bsd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zInitialize.hpp\"\n@@ -132,0 +133,1 @@\n+    ZInitialize::error(\"Failed to create heap backing file\");\n@@ -139,1 +141,1 @@\n-      log_error_p(gc)(\"Failed to truncate backing file (%s)\", err.to_string());\n+      ZInitialize::error(\"Failed to truncate backing file (%s)\", err.to_string());\n@@ -148,1 +150,1 @@\n-    log_error_p(gc)(\"Failed to determine filesystem type for backing file (%s)\", err.to_string());\n+    ZInitialize::error(\"Failed to determine filesystem type for backing file (%s)\", err.to_string());\n@@ -161,2 +163,2 @@\n-    log_error_p(gc)(\"-XX:+UseTransparentHugePages can only be enabled when using a %s filesystem\",\n-                    ZFILESYSTEM_TMPFS);\n+    ZInitialize::error(\"-XX:+UseTransparentHugePages can only be enabled when using a %s filesystem\",\n+                       ZFILESYSTEM_TMPFS);\n@@ -167,2 +169,2 @@\n-    log_error_p(gc)(\"-XX:+UseTransparentHugePages on a %s filesystem not supported by kernel\",\n-                    ZFILESYSTEM_TMPFS);\n+    ZInitialize::error(\"-XX:+UseTransparentHugePages on a %s filesystem not supported by kernel\",\n+                       ZFILESYSTEM_TMPFS);\n@@ -173,2 +175,2 @@\n-    log_error_p(gc)(\"-XX:+UseLargePages (without -XX:+UseTransparentHugePages) can only be enabled \"\n-                    \"when using a %s filesystem\", ZFILESYSTEM_HUGETLBFS);\n+    ZInitialize::error(\"-XX:+UseLargePages (without -XX:+UseTransparentHugePages) can only be enabled \"\n+                       \"when using a %s filesystem\", ZFILESYSTEM_HUGETLBFS);\n@@ -179,2 +181,2 @@\n-    log_error_p(gc)(\"-XX:+UseLargePages must be enabled when using a %s filesystem\",\n-                    ZFILESYSTEM_HUGETLBFS);\n+    ZInitialize::error(\"-XX:+UseLargePages must be enabled when using a %s filesystem\",\n+                       ZFILESYSTEM_HUGETLBFS);\n@@ -186,2 +188,2 @@\n-    log_error_p(gc)(\"Filesystem backing the heap has incompatible block size (\" SIZE_FORMAT \")\",\n-                    _block_size);\n+    ZInitialize::error(\"Filesystem backing the heap has incompatible block size (\" SIZE_FORMAT \")\",\n+                       _block_size);\n@@ -192,2 +194,2 @@\n-    log_error_p(gc)(\"%s filesystem has unexpected block size \" SIZE_FORMAT \" (expected \" SIZE_FORMAT \")\",\n-                    ZFILESYSTEM_HUGETLBFS, _block_size, ZGranuleSize);\n+    ZInitialize::error(\"%s filesystem has unexpected block size \" SIZE_FORMAT \" (expected \" SIZE_FORMAT \")\",\n+                       ZFILESYSTEM_HUGETLBFS, _block_size, ZGranuleSize);\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -66,2 +66,0 @@\n-    \/\/ clear out this chunk (to detect allocation bugs)\n-    memset(k, 0xBE, k->_len);\n","filename":"src\/hotspot\/share\/adlc\/adlArena.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4360,1 +4360,1 @@\n-    \"VectorRearrange\",\"VectorLoadShuffle\", \"VectorLoadConst\",\n+    \"VectorRearrange\", \"VectorLoadShuffle\", \"VectorLoadConst\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -1125,1 +1126,1 @@\n-  virtual const char * name() const PRODUCT_RETURN0;\n+  virtual const char * name() const PRODUCT_RETURN_NULL;\n@@ -1403,1 +1404,1 @@\n-  virtual const char * name() const PRODUCT_RETURN0;\n+  virtual const char * name() const PRODUCT_RETURN_NULL;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -379,1 +379,1 @@\n-    \/\/ The byte size of each segment (except for the last one) is max_size.\n+    \/\/ The size of each segment (except for the last one) is max_size_in_{elems,bytes}.\n@@ -381,2 +381,1 @@\n-    int max_size = segments.max_size_in_bytes();\n-    HeapShared::init_root_segment_sizes(max_size);\n+    HeapShared::init_root_segment_sizes(segments.max_size_in_elems());\n@@ -385,1 +384,1 @@\n-      oop segment_oop = cast_to_oop(first_segment_addr + (c * max_size));\n+      oop segment_oop = cast_to_oop(first_segment_addr + (c * segments.max_size_in_bytes()));\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -226,0 +226,1 @@\n+  int root_index = 0;\n@@ -238,1 +239,0 @@\n-    int root_index = 0;\n@@ -248,0 +248,2 @@\n+  assert(root_index == roots->length(), \"Post-condition: All roots are handled\");\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -280,1 +280,0 @@\n-    assert(is_power_of_2(max_size_in_bytes), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-  if (Arguments::is_internal_module_property(key)) {\n+  if (Arguments::is_internal_module_property(key) && !Arguments::is_module_path_property(key)) {\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -511,1 +511,3 @@\n-  InstanceKlass* k = UnregisteredClasses::load_class(class_name, _source, CHECK_NULL);\n+  ResourceMark rm;\n+  char * source_path = os::strdup_check_oom(ClassLoader::uri_to_path(_source));\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path, CHECK_NULL);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,0 +177,2 @@\n+    \/\/ NB: the string following \"source: \" is not really a proper file name, but rather\n+    \/\/ a truncated URI referring to a file. It must be decoded after reading.\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -584,1 +584,1 @@\n-  const char* file = ClassLoader::skip_uri_protocol(location->as_C_string());\n+  const char* file = ClassLoader::uri_to_path(location->as_C_string());\n@@ -784,1 +784,1 @@\n-      return true;\n+      return false;\n@@ -789,1 +789,1 @@\n-  return false;\n+  return true;\n@@ -813,1 +813,1 @@\n-  bool mismatch = false;\n+  bool match = true;\n@@ -826,1 +826,1 @@\n-        mismatch = true;\n+        match = false;\n@@ -843,1 +843,1 @@\n-      mismatch = check_paths(1, num, rp_array, 0, 0);\n+      match = check_paths(1, num, rp_array, 0, 0);\n@@ -848,1 +848,1 @@\n-      mismatch = true;\n+      match = false;\n@@ -852,1 +852,1 @@\n-  if (mismatch) {\n+  if (!match) {\n@@ -863,1 +863,1 @@\n-  bool mismatch = false;\n+  bool match = false;\n@@ -892,2 +892,2 @@\n-    mismatch = check_paths(j, shared_app_paths_len, rp_array, 0, 0);\n-    if (mismatch) {\n+    match = check_paths(j, shared_app_paths_len, rp_array, 0, 0);\n+    if (!match) {\n@@ -904,1 +904,1 @@\n-        mismatch = check_paths(j, shared_app_paths_len, rp_array,\n+        match = check_paths(j, shared_app_paths_len, rp_array,\n@@ -907,1 +907,1 @@\n-      if (mismatch) {\n+      if (!match) {\n@@ -929,0 +929,11 @@\n+void FileMapInfo::extract_module_paths(const char* runtime_path, GrowableArray<const char*>* module_paths) {\n+  GrowableArray<const char*>* path_array = create_path_array(runtime_path);\n+  int num_paths = path_array->length();\n+  for (int i = 0; i < num_paths; i++) {\n+    const char* name = path_array->at(i);\n+    ClassLoaderExt::extract_jar_files_from_path(name, module_paths);\n+  }\n+  \/\/ module paths are stored in sorted order in the CDS archive.\n+  module_paths->sort(ClassLoaderExt::compare_module_path_by_name);\n+}\n+\n@@ -930,3 +941,7 @@\n-  const char* rp = Arguments::get_property(\"jdk.module.path\");\n-  int num_paths = CDSConfig::num_archives(rp);\n-  if (num_paths != header()->num_module_paths()) {\n+  const char* runtime_path = Arguments::get_property(\"jdk.module.path\");\n+  int archived_num_module_paths = header()->num_module_paths();\n+  if (runtime_path == nullptr && archived_num_module_paths == 0) {\n+    return true;\n+  }\n+  if ((runtime_path == nullptr && archived_num_module_paths > 0) ||\n+      (runtime_path != nullptr && archived_num_module_paths == 0)) {\n@@ -936,2 +951,7 @@\n-  GrowableArray<const char*>* rp_array = create_path_array(rp);\n-  return check_paths(header()->app_module_paths_start_index(), num_paths, rp_array, 0, 0);\n+  GrowableArray<const char*>* module_paths = new GrowableArray<const char*>(3);\n+  extract_module_paths(runtime_path, module_paths);\n+  int num_paths = module_paths->length();\n+  if (num_paths != archived_num_module_paths) {\n+    return false;\n+  }\n+  return check_paths(header()->app_module_paths_start_index(), num_paths, module_paths, 0, 0);\n@@ -947,0 +967,10 @@\n+\n+  bool matched_module_paths = true;\n+  if (CDSConfig::is_dumping_dynamic_archive() || header()->has_full_module_graph()) {\n+    matched_module_paths = check_module_paths();\n+  }\n+  if (header()->has_full_module_graph() && !matched_module_paths) {\n+    CDSConfig::stop_using_optimized_module_handling();\n+    log_info(cds)(\"optimized module handling: disabled because of mismatched module paths\");\n+  }\n+\n@@ -962,1 +992,1 @@\n-      if (!check_module_paths()) {\n+      if (!matched_module_paths) {\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":49,"deletions":19,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -274,0 +274,1 @@\n+  bool has_full_module_graph()             const { return _has_full_module_graph; }\n@@ -557,0 +558,1 @@\n+  void  extract_module_paths(const char* runtime_path, GrowableArray<const char*>* module_paths);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"classfile\/classLoaderExt.hpp\"\n@@ -58,0 +59,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -137,2 +139,1 @@\n-int HeapShared::_root_segment_max_size_shift;\n-int HeapShared::_root_segment_max_size_mask;\n+int HeapShared::_root_segment_max_size_elems;\n@@ -245,0 +246,16 @@\n+void HeapShared::get_segment_indexes(int idx, int& seg_idx, int& int_idx) {\n+  assert(_root_segment_max_size_elems > 0, \"sanity\");\n+\n+  \/\/ Try to avoid divisions for the common case.\n+  if (idx < _root_segment_max_size_elems) {\n+    seg_idx = 0;\n+    int_idx = idx;\n+  } else {\n+    seg_idx = idx \/ _root_segment_max_size_elems;\n+    int_idx = idx % _root_segment_max_size_elems;\n+  }\n+\n+  assert(idx == seg_idx * _root_segment_max_size_elems + int_idx,\n+         \"sanity: %d index maps to %d segment and %d internal\", idx, seg_idx, int_idx);\n+}\n+\n@@ -247,2 +264,0 @@\n-  assert(_root_segment_max_size_shift > 0, \"sanity\");\n-  assert(_root_segment_max_size_mask  > 0, \"sanity\");\n@@ -252,2 +267,2 @@\n-  int seg_idx = index >> _root_segment_max_size_shift;\n-  int int_idx = index &  _root_segment_max_size_mask;\n+  int seg_idx, int_idx;\n+  get_segment_indexes(index, seg_idx, int_idx);\n@@ -265,4 +280,2 @@\n-    assert(_root_segment_max_size_shift > 0, \"sanity\");\n-    assert(_root_segment_max_size_mask  > 0, \"sanity\");\n-    int seg_idx = index >> _root_segment_max_size_shift;\n-    int int_idx = index &  _root_segment_max_size_mask;\n+    int seg_idx, int_idx;\n+    get_segment_indexes(index, seg_idx, int_idx);\n@@ -788,4 +801,2 @@\n-void HeapShared::init_root_segment_sizes(int max_size) {\n-  assert(is_power_of_2(max_size), \"must be\");\n-  _root_segment_max_size_shift = log2i_exact(max_size);\n-  _root_segment_max_size_mask = max_size - 1;\n+void HeapShared::init_root_segment_sizes(int max_size_elems) {\n+  _root_segment_max_size_elems = max_size_elems;\n@@ -878,0 +889,11 @@\n+  if (k->name()->equals(\"jdk\/internal\/module\/ArchivedModuleGraph\") &&\n+      !CDSConfig::is_using_optimized_module_handling() &&\n+      \/\/ archive was created with --module-path\n+      ClassLoaderExt::num_module_paths() > 0) {\n+    \/\/ ArchivedModuleGraph was created with a --module-path that's different than the runtime --module-path.\n+    \/\/ Thus, it might contain references to modules that do not exist at runtime. We cannot use it.\n+    log_info(cds, heap)(\"Skip initializing ArchivedModuleGraph subgraph: is_using_optimized_module_handling=%s num_module_paths=%d\",\n+                        BOOL_TO_STR(CDSConfig::is_using_optimized_module_handling()), ClassLoaderExt::num_module_paths());\n+    return;\n+  }\n+\n@@ -1126,0 +1148,7 @@\n+    if (log_is_enabled(Trace, cds, heap)) {\n+      WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n+      if (walker != nullptr) {\n+        LogStream ls(Log(cds, heap)::trace());\n+        CDSHeapVerifier::trace_to_root(&ls, walker->referencing_obj());\n+      }\n+    }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":43,"deletions":14,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -294,2 +294,1 @@\n-  static int _root_segment_max_size_shift;\n-  static int _root_segment_max_size_mask;\n+  static int _root_segment_max_size_elems;\n@@ -410,0 +409,2 @@\n+  static void get_segment_indexes(int index, int& segment_index, int& internal_index);\n+\n@@ -428,1 +429,1 @@\n-  static void init_root_segment_sizes(int max_size) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void init_root_segment_sizes(int max_size_elems) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -303,0 +304,1 @@\n+        ClassLoaderExt::init_num_module_paths(info->header()->num_module_paths());\n@@ -794,0 +796,3 @@\n+  } else {\n+    log_info(cds)(\"Not dumping heap, reset CDSConfig::_is_using_optimized_module_handling\");\n+    CDSConfig::stop_using_optimized_module_handling();\n@@ -797,0 +802,10 @@\n+  \/\/ Dummy call to load classes used at CDS runtime\n+  JavaValue result(T_OBJECT);\n+  Handle path_string = java_lang_String::create_from_str(\"dummy.jar\", CHECK);\n+  JavaCalls::call_static(&result,\n+                         vmClasses::jdk_internal_loader_ClassLoaders_klass(),\n+                         vmSymbols::toFileURL_name(),\n+                         vmSymbols::toFileURL_signature(),\n+                         path_string,\n+                         CHECK);\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1619,1 +1619,4 @@\n-  dump_compile_data(out);\n+\n+  if (this->task() != nullptr) {\n+    dump_compile_data(out);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,0 +84,3 @@\n+#include <stdlib.h>\n+#include <ctype.h>\n+\n@@ -582,0 +585,2 @@\n+    \/\/ ClassLoaderExt::process_module_table() filters out non-jar entries before calling this function.\n+    assert(new_entry->is_jar_file(), \"module path entry %s is not a jar file\", new_entry->name());\n@@ -1212,1 +1217,1 @@\n-char* ClassLoader::skip_uri_protocol(char* source) {\n+static const char* skip_uri_protocol(const char* source) {\n@@ -1231,0 +1236,41 @@\n+static char decode_percent_encoded(const char *str, size_t& index) {\n+  if (str[index] == '%'\n+      && isxdigit(str[index + 1])\n+      && isxdigit(str[index + 2])) {\n+    char hex[3];\n+    hex[0] = str[index + 1];\n+    hex[1] = str[index + 2];\n+    hex[2] = '\\0';\n+    index += 2;\n+    return (char) strtol(hex, NULL, 16);\n+  }\n+  return str[index];\n+}\n+\n+char* ClassLoader::uri_to_path(const char* uri) {\n+  const size_t len = strlen(uri) + 1;\n+  char* path = NEW_RESOURCE_ARRAY(char, len);\n+\n+  uri = skip_uri_protocol(uri);\n+\n+  if (strncmp(uri, \"\/\/\", 2) == 0) {\n+    \/\/ Skip the empty \"authority\" part\n+    uri += 2;\n+  }\n+\n+#ifdef _WINDOWS\n+  if (uri[0] == '\/') {\n+    \/\/ Absolute path name on Windows does not begin with a slash\n+    uri += 1;\n+  }\n+#endif\n+\n+  size_t path_index = 0;\n+  for (size_t i = 0; i < strlen(uri); ++i) {\n+    char decoded = decode_percent_encoded(uri, i);\n+    path[path_index++] = decoded;\n+  }\n+  path[path_index] = '\\0';\n+  return path;\n+}\n+\n@@ -1264,1 +1310,1 @@\n-    char* path = skip_uri_protocol(src);\n+    const char* path = ClassLoader::uri_to_path(src);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -385,1 +385,1 @@\n-  static char* skip_uri_protocol(char* source);\n+  static char* uri_to_path(const char* uri);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+int ClassLoaderExt::_num_module_paths = 0;\n@@ -92,0 +93,4 @@\n+int ClassLoaderExt::compare_module_path_by_name(const char** p1, const char** p2) {\n+  return strcmp(*p1, *p2);\n+}\n+\n@@ -94,1 +99,1 @@\n-  GrowableArray<char*>* module_paths = new GrowableArray<char*>(5);\n+  GrowableArray<const char*>* module_paths = new GrowableArray<const char*>(5);\n@@ -98,1 +103,1 @@\n-    GrowableArray<char*>* _module_paths;\n+    GrowableArray<const char*>* _module_paths;\n@@ -100,1 +105,1 @@\n-    ModulePathsGatherer(JavaThread* current, GrowableArray<char*>* module_paths) :\n+    ModulePathsGatherer(JavaThread* current, GrowableArray<const char*>* module_paths) :\n@@ -103,6 +108,4 @@\n-      char* path = m->location()->as_C_string();\n-      if (strncmp(path, \"file:\", 5) == 0) {\n-        path = ClassLoader::skip_uri_protocol(path);\n-        char* path_copy = NEW_RESOURCE_ARRAY(char, strlen(path) + 1);\n-        strcpy(path_copy, path);\n-        _module_paths->append(path_copy);\n+      char* uri = m->location()->as_C_string();\n+      if (strncmp(uri, \"file:\", 5) == 0) {\n+        char* path = ClassLoader::uri_to_path(uri);\n+        extract_jar_files_from_path(path, _module_paths);\n@@ -119,0 +122,4 @@\n+  \/\/ Sort the module paths before storing into CDS archive for simpler\n+  \/\/ checking at runtime.\n+  module_paths->sort(compare_module_path_by_name);\n+\n@@ -134,0 +141,32 @@\n+bool ClassLoaderExt::has_jar_suffix(const char* filename) {\n+  \/\/ In jdk.internal.module.ModulePath.readModule(), it checks for the \".jar\" suffix.\n+  \/\/ Performing the same check here.\n+  const char* dot = strrchr(filename, '.');\n+  if (dot != nullptr && strcmp(dot + 1, \"jar\") == 0) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void ClassLoaderExt::extract_jar_files_from_path(const char* path, GrowableArray<const char*>* module_paths) {\n+  DIR* dirp = os::opendir(path);\n+  if (dirp == nullptr && errno == ENOTDIR && has_jar_suffix(path)) {\n+    module_paths->append(path);\n+  } else {\n+    if (dirp != nullptr) {\n+      struct dirent* dentry;\n+      while ((dentry = os::readdir(dirp)) != nullptr) {\n+        const char* file_name = dentry->d_name;\n+        if (has_jar_suffix(file_name)) {\n+          size_t full_name_len = strlen(path) + strlen(file_name) + strlen(os::file_separator()) + 1;\n+          char* full_name = NEW_RESOURCE_ARRAY(char, full_name_len);\n+          int n = os::snprintf(full_name, full_name_len, \"%s%s%s\", path, os::file_separator(), file_name);\n+          assert((size_t)n == full_name_len - 1, \"Unexpected number of characters in string\");\n+          module_paths->append(full_name);\n+        }\n+      }\n+      os::closedir(dirp);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":48,"deletions":9,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+  \/\/ number of module paths\n+  static int _num_module_paths;\n@@ -62,0 +64,1 @@\n+  static bool has_jar_suffix(const char* filename);\n@@ -71,0 +74,2 @@\n+  static void extract_jar_files_from_path(const char* path, GrowableArray<const char*>* module_paths);\n+  static int compare_module_path_by_name(const char** p1, const char** p2);\n@@ -90,0 +95,2 @@\n+  static int num_module_paths() { return _num_module_paths; }\n+\n@@ -102,0 +109,4 @@\n+  static void init_num_module_paths(int num_module_paths) {\n+    _num_module_paths = num_module_paths;\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3055,1 +3055,1 @@\n-  if (m->is_initializer()) {\n+  if (m->is_object_initializer()) {\n@@ -3058,0 +3058,1 @@\n+    \/\/ Note: Static initializers can be here. Record them as plain methods.\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1072,1 +1072,1 @@\n-                                                    class_loader, protection_domain, is_superclass, CHECK_0);\n+                                                    class_loader, protection_domain, is_superclass, CHECK_false);\n@@ -1091,4 +1091,7 @@\n-  if (ik->super() != nullptr &&\n-      !check_shared_class_super_type(ik, InstanceKlass::cast(ik->super()),\n-                                     class_loader, protection_domain, true, THREAD)) {\n-    return false;\n+  if (ik->super() != nullptr) {\n+    bool check_super = check_shared_class_super_type(ik, InstanceKlass::cast(ik->super()),\n+                                                     class_loader, protection_domain, true,\n+                                                     CHECK_false);\n+    if (!check_super) {\n+      return false;\n+    }\n@@ -1100,1 +1103,3 @@\n-    if (!check_shared_class_super_type(ik, interfaces->at(index), class_loader, protection_domain, false, THREAD)) {\n+    bool check_interface = check_shared_class_super_type(ik, interfaces->at(index), class_loader, protection_domain, false,\n+                                                         CHECK_false);\n+    if (!check_interface) {\n@@ -1156,1 +1161,2 @@\n-  if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {\n+  bool check = check_shared_class_super_types(ik, class_loader, protection_domain, CHECK_NULL);\n+  if (!check) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1011,0 +1011,9 @@\n+  do_intrinsic(_VectorWrapShuffleIndexes, jdk_internal_vm_vector_VectorSupport, vector_wrap_shuffle_indexes_name,                              \\\n+                                                                                                         vector_wrap_shuffle_indexes_sig, F_S) \\\n+   do_signature(vector_wrap_shuffle_indexes_sig, \"(Ljava\/lang\/Class;\"                                                                          \\\n+                                                  \"Ljava\/lang\/Class;\"                                                                          \\\n+                                                  \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\"                                       \\\n+                                                  \"ILjdk\/internal\/vm\/vector\/VectorSupport$WrapShuffleIndexesOperation;)\"                       \\\n+                                                  \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\")                                      \\\n+   do_name(vector_wrap_shuffle_indexes_name, \"wrapShuffleIndexes\")                                                                             \\\n+                                                                                                                                               \\\n@@ -1132,0 +1141,12 @@\n+  do_intrinsic(_VectorSelectFrom, jdk_internal_vm_vector_VectorSupport, vector_select_from_name, vector_select_from_sig, F_S)                  \\\n+   do_signature(vector_select_from_sig, \"(Ljava\/lang\/Class;\"                                                                                   \\\n+                                        \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                        \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                        \"I\"                                                                                                     \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                         \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                         \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\"                                                     \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSelectFromOp;)\"                                            \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                        \\\n+   do_name(vector_select_from_name, \"selectFromOp\")                                                                                              \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-  return VtableStubs::entry_point(destination()) != nullptr;;\n+  return VtableStubs::entry_point(destination()) != nullptr;\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,0 +230,4 @@\n+bool DependencyContext::is_empty() {\n+  return dependencies() == nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,1 @@\n+  bool is_empty();\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -500,5 +500,0 @@\n-  } else if (InlineCacheBufferSize > NonNMethodCodeHeapSize \/ 2) {\n-    jio_fprintf(defaultStream::error_stream(),\n-                \"Invalid InlineCacheBufferSize=\" SIZE_FORMAT \"K. Must be less than or equal to \" SIZE_FORMAT \"K.\\n\",\n-                InlineCacheBufferSize\/K, NonNMethodCodeHeapSize\/2\/K);\n-    status = false;\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-      COMPILER1_PRESENT(ShouldNotReachHere();)\n@@ -71,3 +70,1 @@\n-      if (UseJVMCICompiler) {\n-        ShouldNotReachHere();\n-      }\n+      if (!EnableJVMCI)\n@@ -75,0 +72,1 @@\n+        ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/compiler\/oopMap.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"code\/vmreg.inline.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"gc\/g1\/g1BarrierSetAssembler.hpp\"\n@@ -34,0 +36,1 @@\n+#include \"opto\/block.hpp\"\n@@ -38,0 +41,1 @@\n+#include \"opto\/machnode.hpp\"\n@@ -39,0 +43,4 @@\n+#include \"opto\/memnode.hpp\"\n+#include \"opto\/node.hpp\"\n+#include \"opto\/output.hpp\"\n+#include \"opto\/regalloc.hpp\"\n@@ -40,0 +48,1 @@\n+#include \"opto\/runtime.hpp\"\n@@ -41,0 +50,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -43,27 +53,0 @@\n-const TypeFunc *G1BarrierSetC2::write_ref_field_pre_entry_Type() {\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; \/\/ original field value\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; \/\/ thread\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n-\n-  return TypeFunc::make(domain, range);\n-}\n-\n-const TypeFunc *G1BarrierSetC2::write_ref_field_post_entry_Type() {\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL;  \/\/ Card addr\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL;  \/\/ thread\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);\n-\n-  return TypeFunc::make(domain, range);\n-}\n-\n-#define __ ideal.\n@@ -87,2 +70,0 @@\n- *\n- * Returns true if the pre-barrier can be removed\n@@ -100,1 +81,1 @@\n-    return false; \/\/ cannot unalias unless there are precise offsets\n+    return false; \/\/ Cannot unalias unless there are precise offsets.\n@@ -102,1 +83,0 @@\n-\n@@ -104,1 +84,1 @@\n-    return false; \/\/ No allocation found\n+    return false; \/\/ No allocation found.\n@@ -108,2 +88,1 @@\n-\n-  Node* mem = kit->memory(adr_idx); \/\/ start searching here...\n+  Node* mem = kit->memory(adr_idx); \/\/ Start searching here.\n@@ -112,1 +91,0 @@\n-\n@@ -114,1 +92,0 @@\n-\n@@ -120,1 +97,1 @@\n-        break; \/\/ inscrutable pointer\n+        break; \/\/ Inscrutable pointer.\n@@ -122,2 +99,0 @@\n-\n-      \/\/ Break we have found a store with same base and offset as ours so break\n@@ -125,0 +100,1 @@\n+        \/\/ We have found a store with same base and offset as ours.\n@@ -127,1 +103,0 @@\n-\n@@ -139,1 +114,1 @@\n-          continue; \/\/ advance through independent store memory\n+          continue; \/\/ Advance through independent store memory.\n@@ -142,1 +117,0 @@\n-\n@@ -147,1 +121,1 @@\n-        \/\/ Success:  The bases are provably independent.\n+        \/\/ Success: the bases are provably independent.\n@@ -149,1 +123,1 @@\n-        continue; \/\/ advance through independent store memory\n+        continue; \/\/ Advance through independent store memory.\n@@ -152,1 +126,0 @@\n-\n@@ -160,1 +133,1 @@\n-        \/\/ has been moved up and directly write a reference\n+        \/\/ has been moved up and directly write a reference.\n@@ -169,1 +142,0 @@\n-\n@@ -174,1 +146,0 @@\n-\n@@ -178,102 +149,0 @@\n-\/\/ G1 pre\/post barriers\n-void G1BarrierSetC2::pre_barrier(GraphKit* kit,\n-                                 bool do_load,\n-                                 Node* ctl,\n-                                 Node* obj,\n-                                 Node* adr,\n-                                 uint alias_idx,\n-                                 Node* val,\n-                                 const TypeOopPtr* val_type,\n-                                 Node* pre_val,\n-                                 BasicType bt) const {\n-  \/\/ Some sanity checks\n-  \/\/ Note: val is unused in this routine.\n-\n-  if (do_load) {\n-    \/\/ We need to generate the load of the previous value\n-    assert(obj != nullptr, \"must have a base\");\n-    assert(adr != nullptr, \"where are loading from?\");\n-    assert(pre_val == nullptr, \"loaded already?\");\n-    assert(val_type != nullptr, \"need a type\");\n-\n-    if (use_ReduceInitialCardMarks()\n-        && g1_can_remove_pre_barrier(kit, &kit->gvn(), adr, bt, alias_idx)) {\n-      return;\n-    }\n-\n-  } else {\n-    \/\/ In this case both val_type and alias_idx are unused.\n-    assert(pre_val != nullptr, \"must be loaded already\");\n-    \/\/ Nothing to be done if pre_val is null.\n-    if (pre_val->bottom_type() == TypePtr::NULL_PTR) return;\n-    assert(pre_val->bottom_type()->basic_type() == T_OBJECT, \"or we shouldn't be here\");\n-  }\n-  assert(bt == T_OBJECT, \"or we shouldn't be here\");\n-\n-  IdealKit ideal(kit, true);\n-\n-  Node* tls = __ thread(); \/\/ ThreadLocalStorage\n-\n-  Node* no_base = __ top();\n-  Node* zero  = __ ConI(0);\n-  Node* zeroX = __ ConX(0);\n-\n-  float likely  = PROB_LIKELY(0.999);\n-  float unlikely  = PROB_UNLIKELY(0.999);\n-\n-  BasicType active_type = in_bytes(SATBMarkQueue::byte_width_of_active()) == 4 ? T_INT : T_BYTE;\n-  assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 4 || in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"flag width\");\n-\n-  \/\/ Offsets into the thread\n-  const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-  const int index_offset   = in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset());\n-  const int buffer_offset  = in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset());\n-\n-  \/\/ Now the actual pointers into the thread\n-  Node* marking_adr = __ AddP(no_base, tls, __ ConX(marking_offset));\n-  Node* buffer_adr  = __ AddP(no_base, tls, __ ConX(buffer_offset));\n-  Node* index_adr   = __ AddP(no_base, tls, __ ConX(index_offset));\n-\n-  \/\/ Now some of the values\n-  Node* marking = __ load(__ ctrl(), marking_adr, TypeInt::INT, active_type, Compile::AliasIdxRaw);\n-\n-  \/\/ if (!marking)\n-  __ if_then(marking, BoolTest::ne, zero, unlikely); {\n-    BasicType index_bt = TypeX_X->basic_type();\n-    assert(sizeof(size_t) == type2aelembytes(index_bt), \"Loading G1 SATBMarkQueue::_index with wrong size.\");\n-    Node* index   = __ load(__ ctrl(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);\n-\n-    if (do_load) {\n-      \/\/ load original value\n-      pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx, false, MemNode::unordered, LoadNode::Pinned);\n-    }\n-\n-    \/\/ if (pre_val != nullptr)\n-    __ if_then(pre_val, BoolTest::ne, kit->null()); {\n-      Node* buffer  = __ load(__ ctrl(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);\n-\n-      \/\/ is the queue for this thread full?\n-      __ if_then(index, BoolTest::ne, zeroX, likely); {\n-\n-        \/\/ decrement the index\n-        Node* next_index = kit->gvn().transform(new SubXNode(index, __ ConX(sizeof(intptr_t))));\n-\n-        \/\/ Now get the buffer location we will log the previous value into and store it\n-        Node *log_addr = __ AddP(no_base, buffer, next_index);\n-        __ store(__ ctrl(), log_addr, pre_val, T_OBJECT, Compile::AliasIdxRaw, MemNode::unordered);\n-        \/\/ update the index\n-        __ store(__ ctrl(), index_adr, next_index, index_bt, Compile::AliasIdxRaw, MemNode::unordered);\n-\n-      } __ else_(); {\n-\n-        \/\/ logging buffer is full, call the runtime\n-        const TypeFunc *tf = write_ref_field_pre_entry_Type();\n-        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), \"write_ref_field_pre_entry\", pre_val, tls);\n-      } __ end_if();  \/\/ (!index)\n-    } __ end_if();  \/\/ (pre_val != nullptr)\n-  } __ end_if();  \/\/ (!marking)\n-\n-  \/\/ Final sync IdealKit and GraphKit.\n-  kit->final_sync(ideal);\n-}\n-\n@@ -281,2 +150,2 @@\n- * G1 similar to any GC with a Young Generation requires a way to keep track of\n- * references from Old Generation to Young Generation to make sure all live\n+ * G1, similar to any GC with a Young Generation, requires a way to keep track\n+ * of references from Old Generation to Young Generation to make sure all live\n@@ -285,3 +154,3 @@\n- * as part of mixed collections. References are tracked in remembered sets and\n- * is continuously updated as reference are written to with the help of the\n- * post-barrier.\n+ * as part of mixed collections. References are tracked in remembered sets,\n+ * which are continuously updated as references are written to with the help of\n+ * the post-barrier.\n@@ -289,4 +158,4 @@\n- * To reduce the number of updates to the remembered set the post-barrier\n- * filters updates to fields in objects located in the Young Generation,\n- * the same region as the reference, when the null is being written or\n- * if the card is already marked as dirty by an earlier write.\n+ * To reduce the number of updates to the remembered set, the post-barrier\n+ * filters out updates to fields in objects located in the Young Generation, the\n+ * same region as the reference, when null is being written, or if the card is\n+ * already marked as dirty by an earlier write.\n@@ -295,7 +164,4 @@\n- * post-barrier completely if it is possible during compile time to prove\n- * the object is newly allocated and that no safepoint exists between the\n- * allocation and the store.\n- *\n- * In the case of slow allocation the allocation code must handle the barrier\n- * as part of the allocation in the case the allocated object is not located\n- * in the nursery; this would happen for humongous objects.\n+ * post-barrier completely, if it is possible during compile time to prove the\n+ * object is newly allocated and that no safepoint exists between the allocation\n+ * and the store. This can be seen as a compile-time version of the\n+ * above-mentioned Young Generation filter.\n@@ -303,1 +169,3 @@\n- * Returns true if the post barrier can be removed\n+ * In the case of a slow allocation, the allocation code must handle the barrier\n+ * as part of the allocation if the allocated object is not located in the\n+ * nursery; this would happen for humongous objects.\n@@ -306,1 +174,1 @@\n-                                                PhaseValues* phase, Node* store,\n+                                                PhaseValues* phase, Node* store_ctrl,\n@@ -313,1 +181,1 @@\n-    return false; \/\/ cannot unalias unless there are precise offsets\n+    return false; \/\/ Cannot unalias unless there are precise offsets.\n@@ -315,1 +183,0 @@\n-\n@@ -317,1 +184,1 @@\n-     return false; \/\/ No allocation found\n+    return false; \/\/ No allocation found.\n@@ -320,2 +187,1 @@\n-  \/\/ Start search from Store node\n-  Node* mem = store->in(MemNode::Control);\n+  Node* mem = store_ctrl;   \/\/ Start search from Store node.\n@@ -323,1 +189,0 @@\n-\n@@ -326,1 +191,0 @@\n-\n@@ -336,33 +200,14 @@\n-\/\/\n-\/\/ Update the card table and add card address to the queue\n-\/\/\n-void G1BarrierSetC2::g1_mark_card(GraphKit* kit,\n-                                  IdealKit& ideal,\n-                                  Node* card_adr,\n-                                  Node* oop_store,\n-                                  uint oop_alias_idx,\n-                                  Node* index,\n-                                  Node* index_adr,\n-                                  Node* buffer,\n-                                  const TypeFunc* tf) const {\n-  Node* zero  = __ ConI(0);\n-  Node* zeroX = __ ConX(0);\n-  Node* no_base = __ top();\n-  BasicType card_bt = T_BYTE;\n-  \/\/ Smash zero into card. MUST BE ORDERED WRT TO STORE\n-  __ storeCM(__ ctrl(), card_adr, zero, oop_store, oop_alias_idx, card_bt, Compile::AliasIdxRaw);\n-\n-  \/\/  Now do the queue work\n-  __ if_then(index, BoolTest::ne, zeroX); {\n-\n-    Node* next_index = kit->gvn().transform(new SubXNode(index, __ ConX(sizeof(intptr_t))));\n-    Node* log_addr = __ AddP(no_base, buffer, next_index);\n-\n-    \/\/ Order, see storeCM.\n-    __ store(__ ctrl(), log_addr, card_adr, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered);\n-    __ store(__ ctrl(), index_adr, next_index, TypeX_X->basic_type(), Compile::AliasIdxRaw, MemNode::unordered);\n-\n-  } __ else_(); {\n-    __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), \"write_ref_field_post_entry\", card_adr, __ thread());\n-  } __ end_if();\n-\n+Node* G1BarrierSetC2::load_at_resolved(C2Access& access, const Type* val_type) const {\n+  DecoratorSet decorators = access.decorators();\n+  bool on_weak = (decorators & ON_WEAK_OOP_REF) != 0;\n+  bool on_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n+  \/\/ If we are reading the value of the referent field of a Reference object, we\n+  \/\/ need to record the referent in an SATB log buffer using the pre-barrier\n+  \/\/ mechanism. Also we need to add a memory barrier to prevent commoning reads\n+  \/\/ from this field across safepoints, since GC can change its value.\n+  bool need_read_barrier = ((on_weak || on_phantom) && !no_keepalive);\n+  if (access.is_oop() && need_read_barrier) {\n+    access.set_barrier_data(G1C2BarrierPre);\n+  }\n+  return CardTableBarrierSetC2::load_at_resolved(access, val_type);\n@@ -371,10 +216,3 @@\n-void G1BarrierSetC2::post_barrier(GraphKit* kit,\n-                                  Node* ctl,\n-                                  Node* oop_store,\n-                                  Node* obj,\n-                                  Node* adr,\n-                                  uint alias_idx,\n-                                  Node* val,\n-                                  BasicType bt,\n-                                  bool use_precise) const {\n-  \/\/ If we are writing a null then we need no post barrier\n+void G1BarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {\n+  eliminate_gc_barrier_data(node);\n+}\n@@ -382,6 +220,7 @@\n-  if (val != nullptr && val->is_Con() && val->bottom_type() == TypePtr::NULL_PTR) {\n-    \/\/ Must be null\n-    const Type* t = val->bottom_type();\n-    assert(t == Type::TOP || t == TypePtr::NULL_PTR, \"must be null\");\n-    \/\/ No post barrier if writing null\n-    return;\n+void G1BarrierSetC2::eliminate_gc_barrier_data(Node* node) const {\n+  if (node->is_LoadStore()) {\n+    LoadStoreNode* loadstore = node->as_LoadStore();\n+    loadstore->set_barrier_data(0);\n+  } else if (node->is_Mem()) {\n+    MemNode* mem = node->as_Mem();\n+    mem->set_barrier_data(0);\n@@ -389,0 +228,1 @@\n+}\n@@ -390,6 +230,3 @@\n-  if (use_ReduceInitialCardMarks() && obj == kit->just_allocated_object(kit->control())) {\n-    \/\/ We can skip marks on a freshly-allocated object in Eden.\n-    \/\/ Keep this code in sync with CardTableBarrierSet::on_slowpath_allocation_exit.\n-    \/\/ That routine informs GC to take appropriate compensating steps,\n-    \/\/ upon a slow-path allocation, so as to make this card-mark\n-    \/\/ elision safe.\n+static void refine_barrier_by_new_val_type(const Node* n) {\n+  if (n->Opcode() != Op_StoreP &&\n+      n->Opcode() != Op_StoreN) {\n@@ -398,3 +235,11 @@\n-\n-  if (use_ReduceInitialCardMarks()\n-      && g1_can_remove_post_barrier(kit, &kit->gvn(), oop_store, adr)) {\n+  MemNode* store = n->as_Mem();\n+  const Node* newval = n->in(MemNode::ValueIn);\n+  assert(newval != nullptr, \"\");\n+  const Type* newval_bottom = newval->bottom_type();\n+  TypePtr::PTR newval_type = newval_bottom->make_ptr()->ptr();\n+  uint8_t barrier_data = store->barrier_data();\n+  if (!newval_bottom->isa_oopptr() &&\n+      !newval_bottom->isa_narrowoop() &&\n+      newval_type != TypePtr::Null) {\n+    \/\/ newval is neither an OOP nor null, so there is no barrier to refine.\n+    assert(barrier_data == 0, \"non-OOP stores should have no barrier data\");\n@@ -403,4 +248,3 @@\n-\n-  if (!use_precise) {\n-    \/\/ All card marks for a (non-array) instance are in one place:\n-    adr = obj;\n+  if (barrier_data == 0) {\n+    \/\/ No barrier to refine.\n+    return;\n@@ -408,84 +252,10 @@\n-  \/\/ (Else it's an array (or unknown), and we want more precise card marks.)\n-  assert(adr != nullptr, \"\");\n-\n-  IdealKit ideal(kit, true);\n-\n-  Node* tls = __ thread(); \/\/ ThreadLocalStorage\n-\n-  Node* no_base = __ top();\n-  float likely = PROB_LIKELY_MAG(3);\n-  float unlikely = PROB_UNLIKELY_MAG(3);\n-  Node* young_card = __ ConI((jint)G1CardTable::g1_young_card_val());\n-  Node* dirty_card = __ ConI((jint)G1CardTable::dirty_card_val());\n-  Node* zeroX = __ ConX(0);\n-\n-  const TypeFunc *tf = write_ref_field_post_entry_Type();\n-\n-  \/\/ Offsets into the thread\n-  const int index_offset  = in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset());\n-  const int buffer_offset = in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset());\n-\n-  \/\/ Pointers into the thread\n-\n-  Node* buffer_adr = __ AddP(no_base, tls, __ ConX(buffer_offset));\n-  Node* index_adr =  __ AddP(no_base, tls, __ ConX(index_offset));\n-\n-  \/\/ Now some values\n-  \/\/ Use ctrl to avoid hoisting these values past a safepoint, which could\n-  \/\/ potentially reset these fields in the JavaThread.\n-  Node* index  = __ load(__ ctrl(), index_adr, TypeX_X, TypeX_X->basic_type(), Compile::AliasIdxRaw);\n-  Node* buffer = __ load(__ ctrl(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);\n-\n-  \/\/ Convert the store obj pointer to an int prior to doing math on it\n-  \/\/ Must use ctrl to prevent \"integerized oop\" existing across safepoint\n-  Node* cast =  __ CastPX(__ ctrl(), adr);\n-\n-  \/\/ Divide pointer by card size\n-  Node* card_offset = __ URShiftX( cast, __ ConI(CardTable::card_shift()) );\n-\n-  \/\/ Combine card table base and card offset\n-  Node* card_adr = __ AddP(no_base, byte_map_base_node(kit), card_offset );\n-\n-  \/\/ If we know the value being stored does it cross regions?\n-\n-  if (val != nullptr) {\n-    \/\/ Does the store cause us to cross regions?\n-\n-    \/\/ Should be able to do an unsigned compare of region_size instead of\n-    \/\/ and extra shift. Do we have an unsigned compare??\n-    \/\/ Node* region_size = __ ConI(1 << G1HeapRegion::LogOfHRGrainBytes);\n-    Node* xor_res =  __ URShiftX ( __ XorX( cast,  __ CastPX(__ ctrl(), val)), __ ConI(checked_cast<jint>(G1HeapRegion::LogOfHRGrainBytes)));\n-\n-    \/\/ if (xor_res == 0) same region so skip\n-    __ if_then(xor_res, BoolTest::ne, zeroX, likely); {\n-\n-      \/\/ No barrier if we are storing a null.\n-      __ if_then(val, BoolTest::ne, kit->null(), likely); {\n-\n-        \/\/ Ok must mark the card if not already dirty\n-\n-        \/\/ load the original value of the card\n-        Node* card_val = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);\n-\n-        __ if_then(card_val, BoolTest::ne, young_card, unlikely); {\n-          kit->sync_kit(ideal);\n-          kit->insert_mem_bar(Op_MemBarVolatile, oop_store);\n-          __ sync_kit(kit);\n-\n-          Node* card_val_reload = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);\n-          __ if_then(card_val_reload, BoolTest::ne, dirty_card); {\n-            g1_mark_card(kit, ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);\n-          } __ end_if();\n-        } __ end_if();\n-      } __ end_if();\n-    } __ end_if();\n-  } else {\n-    \/\/ The Object.clone() intrinsic uses this path if !ReduceInitialCardMarks.\n-    \/\/ We don't need a barrier here if the destination is a newly allocated object\n-    \/\/ in Eden. Otherwise, GC verification breaks because we assume that cards in Eden\n-    \/\/ are set to 'g1_young_gen' (see G1CardTable::verify_g1_young_region()).\n-    assert(!use_ReduceInitialCardMarks(), \"can only happen with card marking\");\n-    Node* card_val = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);\n-    __ if_then(card_val, BoolTest::ne, young_card); {\n-      g1_mark_card(kit, ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);\n-    } __ end_if();\n+  if (newval_type == TypePtr::Null) {\n+    \/\/ Simply elide post-barrier if writing null.\n+    barrier_data &= ~G1C2BarrierPost;\n+    barrier_data &= ~G1C2BarrierPostNotNull;\n+  } else if (((barrier_data & G1C2BarrierPost) != 0) &&\n+             newval_type == TypePtr::NotNull) {\n+    \/\/ If the post-barrier has not been elided yet (e.g. due to newval being\n+    \/\/ freshly allocated), mark it as not-null (simplifies barrier tests and\n+    \/\/ compressed OOPs logic).\n+    barrier_data |= G1C2BarrierPostNotNull;\n@@ -493,3 +263,2 @@\n-\n-  \/\/ Final sync IdealKit and GraphKit.\n-  kit->final_sync(ideal);\n+  store->set_barrier_data(barrier_data);\n+  return;\n@@ -498,26 +267,11 @@\n-\/\/ Helper that guards and inserts a pre-barrier.\n-void G1BarrierSetC2::insert_pre_barrier(GraphKit* kit, Node* base_oop, Node* offset,\n-                                        Node* pre_val, bool need_mem_bar) const {\n-  \/\/ We could be accessing the referent field of a reference object. If so, when G1\n-  \/\/ is enabled, we need to log the value in the referent field in an SATB buffer.\n-  \/\/ This routine performs some compile time filters and generates suitable\n-  \/\/ runtime filters that guard the pre-barrier code.\n-  \/\/ Also add memory barrier for non volatile load from the referent field\n-  \/\/ to prevent commoning of loads across safepoint.\n-\n-  \/\/ Some compile time checks.\n-\n-  \/\/ If offset is a constant, is it java_lang_ref_Reference::_reference_offset?\n-  const TypeX* otype = offset->find_intptr_t_type();\n-  if (otype != nullptr && otype->is_con() &&\n-      otype->get_con() != java_lang_ref_Reference::referent_offset()) {\n-    \/\/ Constant offset but not the reference_offset so just return\n-    return;\n-  }\n-\n-  \/\/ We only need to generate the runtime guards for instances.\n-  const TypeOopPtr* btype = base_oop->bottom_type()->isa_oopptr();\n-  if (btype != nullptr) {\n-    if (btype->isa_aryptr()) {\n-      \/\/ Array type so nothing to do\n-      return;\n+\/\/ Refine (not really expand) G1 barriers by looking at the new value type\n+\/\/ (whether it is necessarily null or necessarily non-null).\n+bool G1BarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN& igvn) const {\n+  ResourceMark rm;\n+  VectorSet visited;\n+  Node_List worklist;\n+  worklist.push(C->root());\n+  while (worklist.size() > 0) {\n+    Node* n = worklist.pop();\n+    if (visited.test_set(n->_idx)) {\n+      continue;\n@@ -525,10 +279,5 @@\n-\n-    const TypeInstPtr* itype = btype->isa_instptr();\n-    if (itype != nullptr) {\n-      \/\/ Can the klass of base_oop be statically determined to be\n-      \/\/ _not_ a sub-class of Reference and _not_ Object?\n-      ciKlass* klass = itype->instance_klass();\n-      if (klass->is_loaded() &&\n-          !klass->is_subtype_of(kit->env()->Reference_klass()) &&\n-          !kit->env()->Object_klass()->is_subtype_of(klass)) {\n-        return;\n+    refine_barrier_by_new_val_type(n);\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* in = n->in(j);\n+      if (in != nullptr) {\n+        worklist.push(in);\n@@ -538,0 +287,2 @@\n+  return false;\n+}\n@@ -539,6 +290,5 @@\n-  \/\/ The compile time filters did not reject base_oop\/offset so\n-  \/\/ we need to generate the following runtime filters\n-  \/\/\n-  \/\/ if (offset == java_lang_ref_Reference::_reference_offset) {\n-  \/\/   if (instance_of(base, java.lang.ref.Reference)) {\n-  \/\/     pre_barrier(_, pre_val, ...);\n+uint G1BarrierSetC2::estimated_barrier_size(const Node* node) const {\n+  \/\/ These Ideal node counts are extracted from the pre-matching Ideal graph\n+  \/\/ generated when compiling the following method with early barrier expansion:\n+  \/\/   static void write(MyObject obj1, Object o) {\n+  \/\/     obj1.o1 = o;\n@@ -546,42 +296,10 @@\n-  \/\/ }\n-\n-  float likely   = PROB_LIKELY(  0.999);\n-  float unlikely = PROB_UNLIKELY(0.999);\n-\n-  IdealKit ideal(kit);\n-\n-  Node* referent_off = __ ConX(java_lang_ref_Reference::referent_offset());\n-\n-  __ if_then(offset, BoolTest::eq, referent_off, unlikely); {\n-      \/\/ Update graphKit memory and control from IdealKit.\n-      kit->sync_kit(ideal);\n-\n-      Node* ref_klass_con = kit->makecon(TypeKlassPtr::make(kit->env()->Reference_klass()));\n-      Node* is_instof = kit->gen_instanceof(base_oop, ref_klass_con);\n-\n-      \/\/ Update IdealKit memory and control from graphKit.\n-      __ sync_kit(kit);\n-\n-      Node* one = __ ConI(1);\n-      \/\/ is_instof == 0 if base_oop == nullptr\n-      __ if_then(is_instof, BoolTest::eq, one, unlikely); {\n-\n-        \/\/ Update graphKit from IdeakKit.\n-        kit->sync_kit(ideal);\n-\n-        \/\/ Use the pre-barrier to record the value in the referent field\n-        pre_barrier(kit, false \/* do_load *\/,\n-                    __ ctrl(),\n-                    nullptr \/* obj *\/, nullptr \/* adr *\/, max_juint \/* alias_idx *\/, nullptr \/* val *\/, nullptr \/* val_type *\/,\n-                    pre_val \/* pre_val *\/,\n-                    T_OBJECT);\n-        if (need_mem_bar) {\n-          \/\/ Add memory barrier to prevent commoning reads from this field\n-          \/\/ across safepoint since GC can change its value.\n-          kit->insert_mem_bar(Op_MemBarCPUOrder);\n-        }\n-        \/\/ Update IdealKit from graphKit.\n-        __ sync_kit(kit);\n-\n-      } __ end_if(); \/\/ _ref_type != ref_none\n-  } __ end_if(); \/\/ offset == referent_offset\n+  uint8_t barrier_data = MemNode::barrier_data(node);\n+  uint nodes = 0;\n+  if ((barrier_data & G1C2BarrierPre) != 0) {\n+    nodes += 50;\n+  }\n+  if ((barrier_data & G1C2BarrierPost) != 0) {\n+    nodes += 60;\n+  }\n+  return nodes;\n+}\n@@ -589,2 +307,7 @@\n-  \/\/ Final sync IdealKit and GraphKit.\n-  kit->final_sync(ideal);\n+bool G1BarrierSetC2::can_initialize_object(const StoreNode* store) const {\n+  assert(store->Opcode() == Op_StoreP || store->Opcode() == Op_StoreN, \"OOP store expected\");\n+  \/\/ It is OK to move the store across the object initialization boundary only\n+  \/\/ if it does not have any barrier, or if it has barriers that can be safely\n+  \/\/ elided (because of the compensation steps taken on the allocation slow path\n+  \/\/ when ReduceInitialCardMarks is enabled).\n+  return (MemNode::barrier_data(store) == 0) || use_ReduceInitialCardMarks();\n@@ -593,1 +316,7 @@\n-#undef __\n+void G1BarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {\n+  if (ac->is_clone_inst() && !use_ReduceInitialCardMarks()) {\n+    clone_in_runtime(phase, ac, G1BarrierSetRuntime::clone_addr(), \"G1BarrierSetRuntime::clone\");\n+    return;\n+  }\n+  BarrierSetC2::clone_at_expansion(phase, ac);\n+}\n@@ -595,1 +324,1 @@\n-Node* G1BarrierSetC2::load_at_resolved(C2Access& access, const Type* val_type) const {\n+Node* G1BarrierSetC2::store_at_resolved(C2Access& access, C2AccessValue& val) const {\n@@ -597,6 +326,1 @@\n-  Node* adr = access.addr().node();\n-  Node* obj = access.base();\n-\n-  bool anonymous = (decorators & C2_UNSAFE_ACCESS) != 0;\n-  bool mismatched = (decorators & C2_MISMATCHED) != 0;\n-  bool unknown = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+  bool anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n@@ -604,19 +328,12 @@\n-  bool in_native = (decorators & IN_NATIVE) != 0;\n-  bool on_weak = (decorators & ON_WEAK_OOP_REF) != 0;\n-  bool on_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n-  bool is_unordered = (decorators & MO_UNORDERED) != 0;\n-  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n-  bool is_mixed = !in_heap && !in_native;\n-  bool need_cpu_mem_bar = !is_unordered || mismatched || is_mixed;\n-\n-  Node* top = Compile::current()->top();\n-  Node* offset = adr->is_AddP() ? adr->in(AddPNode::Offset) : top;\n-\n-  \/\/ If we are reading the value of the referent field of a Reference\n-  \/\/ object (either by using Unsafe directly or through reflection)\n-  \/\/ then, if G1 is enabled, we need to record the referent in an\n-  \/\/ SATB log buffer using the pre-barrier mechanism.\n-  \/\/ Also we need to add memory barrier to prevent commoning reads\n-  \/\/ from this field across safepoint since GC can change its value.\n-  bool need_read_barrier = (((on_weak || on_phantom) && !no_keepalive) ||\n-                            (in_heap && unknown && offset != top && obj != top));\n+  bool tightly_coupled_alloc = (decorators & C2_TIGHTLY_COUPLED_ALLOC) != 0;\n+  bool need_store_barrier = !(tightly_coupled_alloc && use_ReduceInitialCardMarks()) && (in_heap || anonymous);\n+  if (access.is_oop() && need_store_barrier) {\n+    access.set_barrier_data(get_store_barrier(access));\n+    if (tightly_coupled_alloc) {\n+      assert(!use_ReduceInitialCardMarks(),\n+             \"post-barriers are only needed for tightly-coupled initialization stores when ReduceInitialCardMarks is disabled\");\n+      access.set_barrier_data(access.barrier_data() ^ G1C2BarrierPre);\n+    }\n+  }\n+  return BarrierSetC2::store_at_resolved(access, val);\n+}\n@@ -624,2 +341,5 @@\n-  if (!access.is_oop() || !need_read_barrier) {\n-    return CardTableBarrierSetC2::load_at_resolved(access, val_type);\n+Node* G1BarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                     Node* new_val, const Type* value_type) const {\n+  GraphKit* kit = access.kit();\n+  if (!access.is_oop()) {\n+    return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n@@ -627,0 +347,3 @@\n+  access.set_barrier_data(G1C2BarrierPre | G1C2BarrierPost);\n+  return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n+}\n@@ -628,1 +351,9 @@\n-  assert(access.is_parse_access(), \"entry not supported at optimization time\");\n+Node* G1BarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                      Node* new_val, const Type* value_type) const {\n+  GraphKit* kit = access.kit();\n+  if (!access.is_oop()) {\n+    return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n+  }\n+  access.set_barrier_data(G1C2BarrierPre | G1C2BarrierPost);\n+  return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n+}\n@@ -630,3 +361,8 @@\n-  C2ParseAccess& parse_access = static_cast<C2ParseAccess&>(access);\n-  GraphKit* kit = parse_access.kit();\n-  Node* load;\n+Node* G1BarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const {\n+  GraphKit* kit = access.kit();\n+  if (!access.is_oop()) {\n+    return BarrierSetC2::atomic_xchg_at_resolved(access, new_val, value_type);\n+  }\n+  access.set_barrier_data(G1C2BarrierPre | G1C2BarrierPost);\n+  return BarrierSetC2::atomic_xchg_at_resolved(access, new_val, value_type);\n+}\n@@ -634,10 +370,3 @@\n-  Node* control =  kit->control();\n-  const TypePtr* adr_type = access.addr().type();\n-  MemNode::MemOrd mo = access.mem_node_mo();\n-  bool requires_atomic_access = (decorators & MO_UNORDERED) == 0;\n-  bool unaligned = (decorators & C2_UNALIGNED) != 0;\n-  bool unsafe = (decorators & C2_UNSAFE_ACCESS) != 0;\n-  \/\/ Pinned control dependency is the strictest. So it's ok to substitute it for any other.\n-  load = kit->make_load(control, adr, val_type, access.type(), adr_type, mo,\n-      LoadNode::Pinned, requires_atomic_access, unaligned, mismatched, unsafe,\n-      access.barrier_data());\n+class G1BarrierSetC2State : public BarrierSetC2State {\n+private:\n+  GrowableArray<G1BarrierStubC2*>* _stubs;\n@@ -645,0 +374,4 @@\n+public:\n+  G1BarrierSetC2State(Arena* arena)\n+    : BarrierSetC2State(arena),\n+      _stubs(new (arena) GrowableArray<G1BarrierStubC2*>(arena, 8,  0, nullptr)) {}\n@@ -646,13 +379,2 @@\n-  if (on_weak || on_phantom) {\n-    \/\/ Use the pre-barrier to record the value in the referent field\n-    pre_barrier(kit, false \/* do_load *\/,\n-                kit->control(),\n-                nullptr \/* obj *\/, nullptr \/* adr *\/, max_juint \/* alias_idx *\/, nullptr \/* val *\/, nullptr \/* val_type *\/,\n-                load \/* pre_val *\/, T_OBJECT);\n-    \/\/ Add memory barrier to prevent commoning reads from this field\n-    \/\/ across safepoint since GC can change its value.\n-    kit->insert_mem_bar(Op_MemBarCPUOrder);\n-  } else if (unknown) {\n-    \/\/ We do not require a mem bar inside pre_barrier if need_mem_bar\n-    \/\/ is set: the barriers would be emitted by us.\n-    insert_pre_barrier(kit, obj, offset, load, !need_cpu_mem_bar);\n+  GrowableArray<G1BarrierStubC2*>* stubs() {\n+    return _stubs;\n@@ -661,6 +383,3 @@\n-  return load;\n-}\n-\n-bool G1BarrierSetC2::is_gc_barrier_node(Node* node) const {\n-  if (CardTableBarrierSetC2::is_gc_barrier_node(node)) {\n-    return true;\n+  bool needs_liveness_data(const MachNode* mach) const {\n+    return G1PreBarrierStubC2::needs_barrier(mach) ||\n+           G1PostBarrierStubC2::needs_barrier(mach);\n@@ -668,5 +387,2 @@\n-  if (node->Opcode() != Op_CallLeaf) {\n-    return false;\n-  }\n-  CallLeafNode *call = node->as_CallLeaf();\n-  if (call->_name == nullptr) {\n+\n+  bool needs_livein_data() const {\n@@ -675,0 +391,1 @@\n+};\n@@ -676,1 +393,2 @@\n-  return strcmp(call->_name, \"write_ref_field_pre_entry\") == 0 || strcmp(call->_name, \"write_ref_field_post_entry\") == 0;\n+static G1BarrierSetC2State* barrier_set_state() {\n+  return reinterpret_cast<G1BarrierSetC2State*>(Compile::current()->barrier_set_state());\n@@ -679,3 +397,1 @@\n-bool G1BarrierSetC2::is_g1_pre_val_load(Node* n) {\n-  if (n->is_Load() && n->as_Load()->has_pinned_control_dependency()) {\n-    \/\/ Make sure the only users of it are: CmpP, StoreP, and a call to write_ref_field_pre_entry\n+G1BarrierStubC2::G1BarrierStubC2(const MachNode* node) : BarrierStubC2(node) {}\n@@ -683,4 +399,1 @@\n-    \/\/ Skip possible decode\n-    if (n->outcnt() == 1 && n->unique_out()->is_DecodeN()) {\n-      n = n->unique_out();\n-    }\n+G1PreBarrierStubC2::G1PreBarrierStubC2(const MachNode* node) : G1BarrierStubC2(node) {}\n@@ -688,17 +401,8 @@\n-    if (n->outcnt() == 3) {\n-      int found = 0;\n-      for (SimpleDUIterator iter(n); iter.has_next(); iter.next()) {\n-        Node* use = iter.get();\n-        if (use->is_Cmp() || use->is_Store()) {\n-          ++found;\n-        } else if (use->is_CallLeaf()) {\n-          CallLeafNode* call = use->as_CallLeaf();\n-          if (strcmp(call->_name, \"write_ref_field_pre_entry\") == 0) {\n-            ++found;\n-          }\n-        }\n-      }\n-      if (found == 3) {\n-        return true;\n-      }\n-    }\n+bool G1PreBarrierStubC2::needs_barrier(const MachNode* node) {\n+  return (node->barrier_data() & G1C2BarrierPre) != 0;\n+}\n+\n+G1PreBarrierStubC2* G1PreBarrierStubC2::create(const MachNode* node) {\n+  G1PreBarrierStubC2* const stub = new (Compile::current()->comp_arena()) G1PreBarrierStubC2(node);\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    barrier_set_state()->stubs()->append(stub);\n@@ -706,1 +410,1 @@\n-  return false;\n+  return stub;\n@@ -709,2 +413,6 @@\n-bool G1BarrierSetC2::is_gc_pre_barrier_node(Node *node) const {\n-  return is_g1_pre_val_load(node);\n+void G1PreBarrierStubC2::initialize_registers(Register obj, Register pre_val, Register thread, Register tmp1, Register tmp2) {\n+  _obj = obj;\n+  _pre_val = pre_val;\n+  _thread = thread;\n+  _tmp1 = tmp1;\n+  _tmp2 = tmp2;\n@@ -713,9 +421,3 @@\n-void G1BarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {\n-  if (is_g1_pre_val_load(node)) {\n-    macro->replace_node(node, macro->zerocon(node->as_Load()->bottom_type()->basic_type()));\n-  } else {\n-    assert(node->Opcode() == Op_CastP2X, \"ConvP2XNode required\");\n-    assert(node->outcnt() <= 2, \"expects 1 or 2 users: Xor and URShift nodes\");\n-    \/\/ It could be only one user, URShift node, in Object.clone() intrinsic\n-    \/\/ but the new allocation is passed to arraycopy stub and it could not\n-    \/\/ be scalar replaced. So we don't check the case.\n+Register G1PreBarrierStubC2::obj() const {\n+  return _obj;\n+}\n@@ -723,3 +425,3 @@\n-    \/\/ An other case of only one user (Xor) is when the value check for null\n-    \/\/ in G1 post barrier is folded after CCP so the code which used URShift\n-    \/\/ is removed.\n+Register G1PreBarrierStubC2::pre_val() const {\n+  return _pre_val;\n+}\n@@ -727,4 +429,3 @@\n-    \/\/ Take Region node before eliminating post barrier since it also\n-    \/\/ eliminates CastP2X node when it has only one user.\n-    Node* this_region = node->in(0);\n-    assert(this_region != nullptr, \"\");\n+Register G1PreBarrierStubC2::thread() const {\n+  return _thread;\n+}\n@@ -732,1 +433,7 @@\n-    \/\/ Remove G1 post barrier.\n+Register G1PreBarrierStubC2::tmp1() const {\n+  return _tmp1;\n+}\n+\n+Register G1PreBarrierStubC2::tmp2() const {\n+  return _tmp2;\n+}\n@@ -734,11 +441,4 @@\n-    \/\/ Search for CastP2X->Xor->URShift->Cmp path which\n-    \/\/ checks if the store done to a different from the value's region.\n-    \/\/ And replace Cmp with #0 (false) to collapse G1 post barrier.\n-    Node* xorx = node->find_out_with(Op_XorX);\n-    if (xorx != nullptr) {\n-      Node* shift = xorx->unique_out();\n-      Node* cmpx = shift->unique_out();\n-      assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n-          cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n-          \"missing region check in G1 post barrier\");\n-      macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+void G1PreBarrierStubC2::emit_code(MacroAssembler& masm) {\n+  G1BarrierSetAssembler* bs = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  bs->generate_c2_pre_barrier_stub(&masm, this);\n+}\n@@ -746,1 +446,1 @@\n-      \/\/ Remove G1 pre barrier.\n+G1PostBarrierStubC2::G1PostBarrierStubC2(const MachNode* node) : G1BarrierStubC2(node) {}\n@@ -748,48 +448,2 @@\n-      \/\/ Search \"if (marking != 0)\" check and set it to \"false\".\n-      \/\/ There is no G1 pre barrier if previous stored value is null\n-      \/\/ (for example, after initialization).\n-      if (this_region->is_Region() && this_region->req() == 3) {\n-        int ind = 1;\n-        if (!this_region->in(ind)->is_IfFalse()) {\n-          ind = 2;\n-        }\n-        if (this_region->in(ind)->is_IfFalse() &&\n-            this_region->in(ind)->in(0)->Opcode() == Op_If) {\n-          Node* bol = this_region->in(ind)->in(0)->in(1);\n-          assert(bol->is_Bool(), \"\");\n-          cmpx = bol->in(1);\n-          if (bol->as_Bool()->_test._test == BoolTest::ne &&\n-              cmpx->is_Cmp() && cmpx->in(2) == macro->intcon(0) &&\n-              cmpx->in(1)->is_Load()) {\n-            Node* adr = cmpx->in(1)->as_Load()->in(MemNode::Address);\n-            const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-            if (adr->is_AddP() && adr->in(AddPNode::Base) == macro->top() &&\n-                adr->in(AddPNode::Address)->Opcode() == Op_ThreadLocal &&\n-                adr->in(AddPNode::Offset) == macro->MakeConX(marking_offset)) {\n-              macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n-            }\n-          }\n-        }\n-      }\n-    } else {\n-      assert(!use_ReduceInitialCardMarks(), \"can only happen with card marking\");\n-      \/\/ This is a G1 post barrier emitted by the Object.clone() intrinsic.\n-      \/\/ Search for the CastP2X->URShiftX->AddP->LoadB->Cmp path which checks if the card\n-      \/\/ is marked as young_gen and replace the Cmp with 0 (false) to collapse the barrier.\n-      Node* shift = node->find_out_with(Op_URShiftX);\n-      assert(shift != nullptr, \"missing G1 post barrier\");\n-      Node* addp = shift->unique_out();\n-      Node* load = addp->find_out_with(Op_LoadB);\n-      assert(load != nullptr, \"missing G1 post barrier\");\n-      Node* cmpx = load->unique_out();\n-      assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n-          cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n-          \"missing card value check in G1 post barrier\");\n-      macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n-      \/\/ There is no G1 pre barrier in this case\n-    }\n-    \/\/ Now CastP2X can be removed since it is used only on dead path\n-    \/\/ which currently still alive until igvn optimize it.\n-    assert(node->outcnt() == 0 || node->unique_out()->Opcode() == Op_URShiftX, \"\");\n-    macro->replace_node(node, macro->top());\n-  }\n+bool G1PostBarrierStubC2::needs_barrier(const MachNode* node) {\n+  return (node->barrier_data() & G1C2BarrierPost) != 0;\n@@ -798,31 +452,4 @@\n-Node* G1BarrierSetC2::step_over_gc_barrier(Node* c) const {\n-  if (!use_ReduceInitialCardMarks() &&\n-      c != nullptr && c->is_Region() && c->req() == 3) {\n-    for (uint i = 1; i < c->req(); i++) {\n-      if (c->in(i) != nullptr && c->in(i)->is_Region() &&\n-          c->in(i)->req() == 3) {\n-        Node* r = c->in(i);\n-        for (uint j = 1; j < r->req(); j++) {\n-          if (r->in(j) != nullptr && r->in(j)->is_Proj() &&\n-              r->in(j)->in(0) != nullptr &&\n-              r->in(j)->in(0)->Opcode() == Op_CallLeaf &&\n-              r->in(j)->in(0)->as_Call()->entry_point() == CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry)) {\n-            Node* call = r->in(j)->in(0);\n-            c = c->in(i == 1 ? 2 : 1);\n-            if (c != nullptr && c->Opcode() != Op_Parm) {\n-              c = c->in(0);\n-              if (c != nullptr) {\n-                c = c->in(0);\n-                assert(call->in(0) == nullptr ||\n-                       call->in(0)->in(0) == nullptr ||\n-                       call->in(0)->in(0)->in(0) == nullptr ||\n-                       call->in(0)->in(0)->in(0)->in(0) == nullptr ||\n-                       call->in(0)->in(0)->in(0)->in(0)->in(0) == nullptr ||\n-                       c == call->in(0)->in(0)->in(0)->in(0)->in(0), \"bad barrier shape\");\n-                return c;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n+G1PostBarrierStubC2* G1PostBarrierStubC2::create(const MachNode* node) {\n+  G1PostBarrierStubC2* const stub = new (Compile::current()->comp_arena()) G1PostBarrierStubC2(node);\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    barrier_set_state()->stubs()->append(stub);\n@@ -830,1 +457,1 @@\n-  return c;\n+  return stub;\n@@ -833,12 +460,6 @@\n-#ifdef ASSERT\n-bool G1BarrierSetC2::has_cas_in_use_chain(Node *n) const {\n-  Unique_Node_List visited;\n-  Node_List worklist;\n-  worklist.push(n);\n-  while (worklist.size() > 0) {\n-    Node* x = worklist.pop();\n-    if (visited.member(x)) {\n-      continue;\n-    } else {\n-      visited.push(x);\n-    }\n+void G1PostBarrierStubC2::initialize_registers(Register thread, Register tmp1, Register tmp2, Register tmp3) {\n+  _thread = thread;\n+  _tmp1 = tmp1;\n+  _tmp2 = tmp2;\n+  _tmp3 = tmp3;\n+}\n@@ -846,16 +467,2 @@\n-    if (x->is_LoadStore()) {\n-      int op = x->Opcode();\n-      if (op == Op_CompareAndExchangeP || op == Op_CompareAndExchangeN ||\n-          op == Op_CompareAndSwapP     || op == Op_CompareAndSwapN     ||\n-          op == Op_WeakCompareAndSwapP || op == Op_WeakCompareAndSwapN) {\n-        return true;\n-      }\n-    }\n-    if (!x->is_CFG()) {\n-      for (SimpleDUIterator iter(x); iter.has_next(); iter.next()) {\n-        Node* use = iter.get();\n-        worklist.push(use);\n-      }\n-    }\n-  }\n-  return false;\n+Register G1PostBarrierStubC2::thread() const {\n+  return _thread;\n@@ -864,7 +471,3 @@\n-void G1BarrierSetC2::verify_pre_load(Node* marking_if, Unique_Node_List& loads \/*output*\/) const {\n-  assert(loads.size() == 0, \"Loads list should be empty\");\n-  Node* pre_val_if = marking_if->find_out_with(Op_IfTrue)->find_out_with(Op_If);\n-  if (pre_val_if != nullptr) {\n-    Unique_Node_List visited;\n-    Node_List worklist;\n-    Node* pre_val = pre_val_if->in(1)->in(1)->in(1);\n+Register G1PostBarrierStubC2::tmp1() const {\n+  return _tmp1;\n+}\n@@ -872,8 +475,3 @@\n-    worklist.push(pre_val);\n-    while (worklist.size() > 0) {\n-      Node* x = worklist.pop();\n-      if (visited.member(x)) {\n-        continue;\n-      } else {\n-        visited.push(x);\n-      }\n+Register G1PostBarrierStubC2::tmp2() const {\n+  return _tmp2;\n+}\n@@ -881,4 +479,3 @@\n-      if (has_cas_in_use_chain(x)) {\n-        loads.clear();\n-        return;\n-      }\n+Register G1PostBarrierStubC2::tmp3() const {\n+  return _tmp3;\n+}\n@@ -886,21 +483,3 @@\n-      if (x->is_Con()) {\n-        continue;\n-      }\n-      if (x->is_EncodeP() || x->is_DecodeN()) {\n-        worklist.push(x->in(1));\n-        continue;\n-      }\n-      if (x->is_Load() || x->is_LoadStore()) {\n-        assert(x->in(0) != nullptr, \"Pre-val load has to have a control\");\n-        loads.push(x);\n-        continue;\n-      }\n-      if (x->is_Phi()) {\n-        for (uint i = 1; i < x->req(); i++) {\n-          worklist.push(x->in(i));\n-        }\n-        continue;\n-      }\n-      assert(false, \"Pre-val anomaly\");\n-    }\n-  }\n+void G1PostBarrierStubC2::emit_code(MacroAssembler& masm) {\n+  G1BarrierSetAssembler* bs = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  bs->generate_c2_post_barrier_stub(&masm, this);\n@@ -909,4 +488,3 @@\n-void G1BarrierSetC2::verify_no_safepoints(Compile* compile, Node* marking_check_if, const Unique_Node_List& loads) const {\n-  if (loads.size() == 0) {\n-    return;\n-  }\n+void* G1BarrierSetC2::create_barrier_state(Arena* comp_arena) const {\n+  return new (comp_arena) G1BarrierSetC2State(comp_arena);\n+}\n@@ -914,7 +492,4 @@\n-  if (loads.size() == 1) { \/\/ Handle the typical situation when there a single pre-value load\n-                           \/\/ that is dominated by the marking_check_if, that's true when the\n-                           \/\/ barrier itself does the pre-val load.\n-    Node *pre_val = loads.at(0);\n-    if (pre_val->in(0)->in(0) == marking_check_if) { \/\/ IfTrue->If\n-      return;\n-    }\n+int G1BarrierSetC2::get_store_barrier(C2Access& access) const {\n+  if (!access.is_parse_access()) {\n+    \/\/ Only support for eliding barriers at parse time for now.\n+    return G1C2BarrierPre | G1C2BarrierPost;\n@@ -922,6 +497,25 @@\n-\n-  \/\/ All other cases are when pre-value loads dominate the marking check.\n-  Unique_Node_List controls;\n-  for (uint i = 0; i < loads.size(); i++) {\n-    Node *c = loads.at(i)->in(0);\n-    controls.push(c);\n+  GraphKit* kit = (static_cast<C2ParseAccess&>(access)).kit();\n+  Node* ctl = kit->control();\n+  Node* adr = access.addr().node();\n+  uint adr_idx = kit->C->get_alias_index(access.addr().type());\n+  assert(adr_idx != Compile::AliasIdxTop, \"use other store_to_memory factory\");\n+\n+  bool can_remove_pre_barrier = g1_can_remove_pre_barrier(kit, &kit->gvn(), adr, access.type(), adr_idx);\n+\n+  \/\/ We can skip marks on a freshly-allocated object in Eden. Keep this code in\n+  \/\/ sync with CardTableBarrierSet::on_slowpath_allocation_exit. That routine\n+  \/\/ informs GC to take appropriate compensating steps, upon a slow-path\n+  \/\/ allocation, so as to make this card-mark elision safe.\n+  \/\/ The post-barrier can also be removed if null is written. This case is\n+  \/\/ handled by G1BarrierSetC2::expand_barriers, which runs at the end of C2's\n+  \/\/ platform-independent optimizations to exploit stronger type information.\n+  bool can_remove_post_barrier = use_ReduceInitialCardMarks() &&\n+    ((access.base() == kit->just_allocated_object(ctl)) ||\n+     g1_can_remove_post_barrier(kit, &kit->gvn(), ctl, adr));\n+\n+  int barriers = 0;\n+  if (!can_remove_pre_barrier) {\n+    barriers |= G1C2BarrierPre;\n+  }\n+  if (!can_remove_post_barrier) {\n+    barriers |= G1C2BarrierPost;\n@@ -930,4 +524,2 @@\n-  Unique_Node_List visited;\n-  Unique_Node_List safepoints;\n-  Node_List worklist;\n-  uint found = 0;\n+  return barriers;\n+}\n@@ -935,9 +527,3 @@\n-  worklist.push(marking_check_if);\n-  while (worklist.size() > 0 && found < controls.size()) {\n-    Node* x = worklist.pop();\n-    if (x == nullptr || x == compile->top()) continue;\n-    if (visited.member(x)) {\n-      continue;\n-    } else {\n-      visited.push(x);\n-    }\n+void G1BarrierSetC2::late_barrier_analysis() const {\n+  compute_liveness_at_stubs();\n+}\n@@ -945,13 +531,8 @@\n-    if (controls.member(x)) {\n-      found++;\n-    }\n-    if (x->is_Region()) {\n-      for (uint i = 1; i < x->req(); i++) {\n-        worklist.push(x->in(i));\n-      }\n-    } else {\n-      if (!x->is_SafePoint()) {\n-        worklist.push(x->in(0));\n-      } else {\n-        safepoints.push(x);\n-      }\n+void G1BarrierSetC2::emit_stubs(CodeBuffer& cb) const {\n+  MacroAssembler masm(&cb);\n+  GrowableArray<G1BarrierStubC2*>* const stubs = barrier_set_state()->stubs();\n+  for (int i = 0; i < stubs->length(); i++) {\n+    \/\/ Make sure there is enough space in the code buffer\n+    if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == nullptr) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n@@ -959,0 +540,1 @@\n+    stubs->at(i)->emit_code(masm);\n@@ -960,1 +542,1 @@\n-  assert(found == controls.size(), \"Pre-barrier structure anomaly or possible safepoint\");\n+  masm.flush();\n@@ -963,3 +545,4 @@\n-void G1BarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {\n-  if (phase != BarrierSetC2::BeforeCodeGen) {\n-    return;\n+#ifndef PRODUCT\n+void G1BarrierSetC2::dump_barrier_data(const MachNode* mach, outputStream* st) const {\n+  if ((mach->barrier_data() & G1C2BarrierPre) != 0) {\n+    st->print(\"pre \");\n@@ -967,59 +550,2 @@\n-  \/\/ Verify G1 pre-barriers\n-  const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-\n-  Unique_Node_List visited;\n-  Node_List worklist;\n-  \/\/ We're going to walk control flow backwards starting from the Root\n-  worklist.push(compile->root());\n-  while (worklist.size() > 0) {\n-    Node* x = worklist.pop();\n-    if (x == nullptr || x == compile->top()) continue;\n-    if (visited.member(x)) {\n-      continue;\n-    } else {\n-      visited.push(x);\n-    }\n-\n-    if (x->is_Region()) {\n-      for (uint i = 1; i < x->req(); i++) {\n-        worklist.push(x->in(i));\n-      }\n-    } else {\n-      worklist.push(x->in(0));\n-      \/\/ We are looking for the pattern:\n-      \/\/                            \/->ThreadLocal\n-      \/\/ If->Bool->CmpI->LoadB->AddP->ConL(marking_offset)\n-      \/\/              \\->ConI(0)\n-      \/\/ We want to verify that the If and the LoadB have the same control\n-      \/\/ See GraphKit::g1_write_barrier_pre()\n-      if (x->is_If()) {\n-        IfNode *iff = x->as_If();\n-        if (iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp()) {\n-          CmpNode *cmp = iff->in(1)->in(1)->as_Cmp();\n-          if (cmp->Opcode() == Op_CmpI && cmp->in(2)->is_Con() && cmp->in(2)->bottom_type()->is_int()->get_con() == 0\n-              && cmp->in(1)->is_Load()) {\n-            LoadNode* load = cmp->in(1)->as_Load();\n-            if (load->Opcode() == Op_LoadB && load->in(2)->is_AddP() && load->in(2)->in(2)->Opcode() == Op_ThreadLocal\n-                && load->in(2)->in(3)->is_Con()\n-                && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == marking_offset) {\n-\n-              Node* if_ctrl = iff->in(0);\n-              Node* load_ctrl = load->in(0);\n-\n-              if (if_ctrl != load_ctrl) {\n-                \/\/ Skip possible CProj->NeverBranch in infinite loops\n-                if ((if_ctrl->is_Proj() && if_ctrl->Opcode() == Op_CProj)\n-                    && if_ctrl->in(0)->is_NeverBranch()) {\n-                  if_ctrl = if_ctrl->in(0)->in(0);\n-                }\n-              }\n-              assert(load_ctrl != nullptr && if_ctrl == load_ctrl, \"controls must match\");\n-\n-              Unique_Node_List loads;\n-              verify_pre_load(iff, loads);\n-              verify_no_safepoints(compile, iff, loads);\n-            }\n-          }\n-        }\n-      }\n-    }\n+  if ((mach->barrier_data() & G1C2BarrierPost) != 0) {\n+    st->print(\"post \");\n@@ -1027,28 +553,2 @@\n-}\n-#endif\n-\n-bool G1BarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {\n-  if (opcode == Op_StoreP) {\n-    Node* adr = n->in(MemNode::Address);\n-    const Type* adr_type = gvn->type(adr);\n-    \/\/ Pointer stores in G1 barriers looks like unsafe access.\n-    \/\/ Ignore such stores to be able scalar replace non-escaping\n-    \/\/ allocations.\n-    if (adr_type->isa_rawptr() && adr->is_AddP()) {\n-      Node* base = conn_graph->get_addp_base(adr);\n-      if (base->Opcode() == Op_LoadP &&\n-          base->in(MemNode::Address)->is_AddP()) {\n-        adr = base->in(MemNode::Address);\n-        Node* tls = conn_graph->get_addp_base(adr);\n-        if (tls->Opcode() == Op_ThreadLocal) {\n-          int offs = (int) gvn->find_intptr_t_con(adr->in(AddPNode::Offset), Type::OffsetBot);\n-          const int buf_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset());\n-          if (offs == buf_offset) {\n-            return true; \/\/ G1 pre barrier previous oop value store.\n-          }\n-          if (offs == in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset())) {\n-            return true; \/\/ G1 post barrier card address store.\n-          }\n-        }\n-      }\n-    }\n+  if ((mach->barrier_data() & G1C2BarrierPostNotNull) != 0) {\n+    st->print(\"notnull \");\n@@ -1056,1 +556,0 @@\n-  return false;\n@@ -1058,0 +557,1 @@\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":317,"deletions":817,"binary":false,"changes":1134,"status":"modified"},{"patch":"@@ -34,1 +34,40 @@\n-class G1BarrierSetC2: public CardTableBarrierSetC2 {\n+const int G1C2BarrierPre         = 1;\n+const int G1C2BarrierPost        = 2;\n+const int G1C2BarrierPostNotNull = 4;\n+\n+class G1BarrierStubC2 : public BarrierStubC2 {\n+public:\n+  G1BarrierStubC2(const MachNode* node);\n+  virtual void emit_code(MacroAssembler& masm) = 0;\n+};\n+\n+class G1PreBarrierStubC2 : public G1BarrierStubC2 {\n+private:\n+  Register _obj;\n+  Register _pre_val;\n+  Register _thread;\n+  Register _tmp1;\n+  Register _tmp2;\n+\n+protected:\n+  G1PreBarrierStubC2(const MachNode* node);\n+\n+public:\n+  static bool needs_barrier(const MachNode* node);\n+  static G1PreBarrierStubC2* create(const MachNode* node);\n+  void initialize_registers(Register obj, Register pre_val, Register thread, Register tmp1 = noreg, Register tmp2 = noreg);\n+  Register obj() const;\n+  Register pre_val() const;\n+  Register thread() const;\n+  Register tmp1() const;\n+  Register tmp2() const;\n+  virtual void emit_code(MacroAssembler& masm);\n+};\n+\n+class G1PostBarrierStubC2 : public G1BarrierStubC2 {\n+private:\n+  Register _thread;\n+  Register _tmp1;\n+  Register _tmp2;\n+  Register _tmp3;\n+\n@@ -36,20 +75,1 @@\n-  virtual void pre_barrier(GraphKit* kit,\n-                           bool do_load,\n-                           Node* ctl,\n-                           Node* obj,\n-                           Node* adr,\n-                           uint adr_idx,\n-                           Node* val,\n-                           const TypeOopPtr* val_type,\n-                           Node* pre_val,\n-                           BasicType bt) const;\n-\n-  virtual void post_barrier(GraphKit* kit,\n-                            Node* ctl,\n-                            Node* store,\n-                            Node* obj,\n-                            Node* adr,\n-                            uint adr_idx,\n-                            Node* val,\n-                            BasicType bt,\n-                            bool use_precise) const;\n+  G1PostBarrierStubC2(const MachNode* node);\n@@ -57,0 +77,13 @@\n+public:\n+  static bool needs_barrier(const MachNode* node);\n+  static G1PostBarrierStubC2* create(const MachNode* node);\n+  void initialize_registers(Register thread, Register tmp1 = noreg, Register tmp2 = noreg, Register tmp3 = noreg);\n+  Register thread() const;\n+  Register tmp1() const;\n+  Register tmp2() const;\n+  Register tmp3() const;\n+  virtual void emit_code(MacroAssembler& masm);\n+};\n+\n+class G1BarrierSetC2: public CardTableBarrierSetC2 {\n+protected:\n@@ -67,17 +100,1 @@\n-  void g1_mark_card(GraphKit* kit,\n-                    IdealKit& ideal,\n-                    Node* card_adr,\n-                    Node* oop_store,\n-                    uint oop_alias_idx,\n-                    Node* index,\n-                    Node* index_adr,\n-                    Node* buffer,\n-                    const TypeFunc* tf) const;\n-\n-  \/\/ Helper for unsafe accesses, that may or may not be on the referent field.\n-  \/\/ Generates the guards that check whether the result of\n-  \/\/ Unsafe.getReference should be recorded in an SATB log buffer.\n-  void insert_pre_barrier(GraphKit* kit, Node* base_oop, Node* offset, Node* pre_val, bool need_mem_bar) const;\n-\n-  static const TypeFunc* write_ref_field_pre_entry_Type();\n-  static const TypeFunc* write_ref_field_post_entry_Type();\n+  int get_store_barrier(C2Access& access) const;\n@@ -86,0 +103,6 @@\n+  virtual Node* store_at_resolved(C2Access& access, C2AccessValue& val) const;\n+  virtual Node* atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                               Node* new_val, const Type* value_type) const;\n+  virtual Node* atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                Node* new_val, const Type* value_type) const;\n+  virtual Node* atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const;\n@@ -87,7 +110,0 @@\n-#ifdef ASSERT\n-  bool has_cas_in_use_chain(Node* x) const;\n-  void verify_pre_load(Node* marking_check_if, Unique_Node_List& loads \/*output*\/) const;\n-  void verify_no_safepoints(Compile* compile, Node* marking_load, const Unique_Node_List& loads) const;\n-#endif\n-\n-  static bool is_g1_pre_val_load(Node* n);\n@@ -95,2 +111,0 @@\n-  virtual bool is_gc_pre_barrier_node(Node* node) const;\n-  virtual bool is_gc_barrier_node(Node* node) const;\n@@ -98,4 +112,12 @@\n-  virtual Node* step_over_gc_barrier(Node* c) const;\n-\n-#ifdef ASSERT\n-  virtual void verify_gc_barriers(Compile* compile, CompilePhase phase) const;\n+  virtual void eliminate_gc_barrier_data(Node* node) const;\n+  virtual bool expand_barriers(Compile* C, PhaseIterGVN& igvn) const;\n+  virtual uint estimated_barrier_size(const Node* node) const;\n+  virtual bool can_initialize_object(const StoreNode* store) const;\n+  virtual void clone_at_expansion(PhaseMacroExpand* phase,\n+                                  ArrayCopyNode* ac) const;\n+  virtual void* create_barrier_state(Arena* comp_arena) const;\n+  virtual void emit_stubs(CodeBuffer& cb) const;\n+  virtual void late_barrier_analysis() const;\n+\n+#ifndef PRODUCT\n+  virtual void dump_barrier_data(const MachNode* mach, outputStream* st) const;\n@@ -103,2 +125,0 @@\n-\n-  virtual bool escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":73,"deletions":53,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -64,0 +64,8 @@\n+\n+JRT_LEAF(void, G1BarrierSetRuntime::clone(oopDesc* src, oopDesc* dst, size_t size))\n+  HeapAccess<>::clone(src, dst, size);\n+JRT_END\n+\n+address G1BarrierSetRuntime::clone_addr() {\n+  return reinterpret_cast<address>(clone);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSetRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+private:\n+  static void clone(oopDesc* src, oopDesc* dst, size_t size);\n@@ -49,0 +51,2 @@\n+\n+  static address clone_addr();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSetRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-class ReferenceProcessor;\n@@ -39,1 +38,0 @@\n-class ParallelScavengeTracer;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,0 +112,4 @@\n+uint8_t BarrierStubC2::barrier_data() const {\n+  return _node->barrier_data();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -257,0 +257,2 @@\n+  \/\/ High-level, GC-specific barrier flags.\n+  uint8_t barrier_data() const;\n@@ -343,0 +345,2 @@\n+  \/\/ Whether the given store can be used to initialize a newly allocated object.\n+  virtual bool can_initialize_object(const StoreNode* store) const { return true; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,25 +128,0 @@\n-void CardTableBarrierSetC2::clone(GraphKit* kit, Node* src, Node* dst, Node* size, bool is_array) const {\n-  BarrierSetC2::clone(kit, src, dst, size, is_array);\n-  const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;\n-\n-  \/\/ If necessary, emit some card marks afterwards.  (Non-arrays only.)\n-  bool card_mark = !is_array && !use_ReduceInitialCardMarks();\n-  if (card_mark) {\n-    assert(!is_array, \"\");\n-    \/\/ Put in store barrier for any and all oops we are sticking\n-    \/\/ into this object.  (We could avoid this if we could prove\n-    \/\/ that the object type contains no oop fields at all.)\n-    Node* no_particular_value = nullptr;\n-    Node* no_particular_field = nullptr;\n-    int raw_adr_idx = Compile::AliasIdxRaw;\n-    post_barrier(kit, kit->control(),\n-                 kit->memory(raw_adr_type),\n-                 dst,\n-                 no_particular_field,\n-                 raw_adr_idx,\n-                 no_particular_value,\n-                 T_OBJECT,\n-                 false);\n-  }\n-}\n-\n@@ -157,4 +132,0 @@\n-bool CardTableBarrierSetC2::is_gc_barrier_node(Node* node) const {\n-  return ModRefBarrierSetC2::is_gc_barrier_node(node) || node->Opcode() == Op_StoreCM;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-  virtual void clone(GraphKit* kit, Node* src, Node* dst, Node* size, bool is_array) const;\n-  virtual bool is_gc_barrier_node(Node* node) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,3 @@\n-      if (storage->print_containing((oop*) aligned_addr, st)) {\n+      \/\/ Check for null for extra safety: might get here while handling error\n+      \/\/ before storage initialization.\n+      if ((storage != nullptr) && storage->print_containing((oop*) aligned_addr, st)) {\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -254,2 +254,3 @@\n-        const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type();\n-        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), \"shenandoah_wb_pre\", pre_val, tls);\n+        const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_Type();\n+        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), \"shenandoah_wb_pre\",\n+                          pre_val, tls);\n@@ -273,1 +274,1 @@\n-         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry);\n+         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre);\n@@ -278,1 +279,1 @@\n-         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier);\n+         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::clone_barrier);\n@@ -522,1 +523,1 @@\n-const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type() {\n+const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_Type() {\n@@ -535,1 +536,1 @@\n-const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {\n+const TypeFunc* ShenandoahBarrierSetC2::clone_barrier_Type() {\n@@ -547,1 +548,1 @@\n-const TypeFunc* ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type() {\n+const TypeFunc* ShenandoahBarrierSetC2::load_reference_barrier_Type() {\n@@ -796,1 +797,2 @@\n-  return is_shenandoah_lrb_call(node) ||\n+  return (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) ||\n+         is_shenandoah_lrb_call(node) ||\n@@ -912,5 +914,5 @@\n-                    ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),\n-                    CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),\n-                    \"shenandoah_clone\",\n-                    TypeRawPtr::BOTTOM,\n-                    src_base);\n+                                       ShenandoahBarrierSetC2::clone_barrier_Type(),\n+                                       CAST_FROM_FN_PTR(address, ShenandoahRuntime::clone_barrier),\n+                                       \"shenandoah_clone\",\n+                                       TypeRawPtr::BOTTOM,\n+                                       src_base);\n@@ -1107,1 +1109,1 @@\n-    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain()->cnt();\n+    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_Type()->domain()->cnt();\n@@ -1193,1 +1195,1 @@\n-        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain()->cnt();\n+        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_Type()->domain()->cnt();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -108,3 +108,3 @@\n-  static const TypeFunc* write_ref_field_pre_entry_Type();\n-  static const TypeFunc* shenandoah_clone_barrier_Type();\n-  static const TypeFunc* shenandoah_load_reference_barrier_Type();\n+  static const TypeFunc* write_ref_field_pre_Type();\n+  static const TypeFunc* clone_barrier_Type();\n+  static const TypeFunc* load_reference_barrier_Type();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -998,1 +998,1 @@\n-  Node* call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type(), calladdr, name, TypeRawPtr::BOTTOM);\n+  Node* call = new CallLeafNode(ShenandoahBarrierSetC2::load_reference_barrier_Type(), calladdr, name, TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -745,1 +745,1 @@\n-      pacer()->claim_for_alloc(waste, true);\n+      pacer()->claim_for_alloc<true>(waste);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,2 @@\n-bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {\n+template<bool FORCE>\n+bool ShenandoahPacer::claim_for_alloc(size_t words) {\n@@ -201,1 +202,1 @@\n-    if (cur < tax && !force) {\n+    if (cur < tax && !FORCE) {\n@@ -210,0 +211,3 @@\n+template bool ShenandoahPacer::claim_for_alloc<true>(size_t words);\n+template bool ShenandoahPacer::claim_for_alloc<false>(size_t words);\n+\n@@ -230,1 +234,1 @@\n-  bool claimed = claim_for_alloc(words, false);\n+  bool claimed = claim_for_alloc<false>(words);\n@@ -235,7 +239,0 @@\n-  \/\/ Forcefully claim the budget: it may go negative at this point, and\n-  \/\/ GC should replenish for this and subsequent allocations. After this claim,\n-  \/\/ we would wait a bit until our claim is matched by additional progress,\n-  \/\/ or the time budget depletes.\n-  claimed = claim_for_alloc(words, true);\n-  assert(claimed, \"Should always succeed\");\n-\n@@ -252,0 +249,1 @@\n+    claim_for_alloc<true>(words);\n@@ -255,6 +253,3 @@\n-  double start = os::elapsedTime();\n-\n-  size_t max_ms = ShenandoahPacingMaxDelay;\n-  size_t total_ms = 0;\n-\n-  while (true) {\n+  jlong const max_delay = ShenandoahPacingMaxDelay * NANOSECS_PER_MILLISEC;\n+  jlong const start_time = os::elapsed_counter();\n+  while (!claimed && (os::elapsed_counter() - start_time) < max_delay) {\n@@ -262,15 +257,9 @@\n-    size_t cur_ms = (max_ms > total_ms) ? (max_ms - total_ms) : 1;\n-    wait(cur_ms);\n-\n-    double end = os::elapsedTime();\n-    total_ms = (size_t)((end - start) * 1000);\n-\n-    if (total_ms > max_ms || Atomic::load(&_budget) >= 0) {\n-      \/\/ Exiting if either:\n-      \/\/  a) Spent local time budget to wait for enough GC progress.\n-      \/\/     Breaking out and allocating anyway, which may mean we outpace GC,\n-      \/\/     and start Degenerated GC cycle.\n-      \/\/  b) The budget had been replenished, which means our claim is satisfied.\n-      ShenandoahThreadLocalData::add_paced_time(JavaThread::current(), end - start);\n-      break;\n-    }\n+    wait(1);\n+    claimed = claim_for_alloc<false>(words);\n+  }\n+  if (!claimed) {\n+    \/\/ Spent local time budget to wait for enough GC progress.\n+    \/\/ Force allocating anyway, which may mean we outpace GC,\n+    \/\/ and start Degenerated GC cycle.\n+    claimed = claim_for_alloc<true>(words);\n+    assert(claimed, \"Should always succeed\");\n@@ -278,0 +267,1 @@\n+  ShenandoahThreadLocalData::add_paced_time(current, (double)(os::elapsed_counter() - start_time) \/ NANOSECS_PER_SEC);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":21,"deletions":31,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -110,1 +110,3 @@\n-  bool claim_for_alloc(size_t words, bool force);\n+  template<bool FORCE>\n+  bool claim_for_alloc(size_t words);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,4 +34,3 @@\n-void ShenandoahRuntime::arraycopy_barrier_oop_entry(oop* src, oop* dst, size_t length) {\n-  ShenandoahBarrierSet *bs = ShenandoahBarrierSet::barrier_set();\n-  bs->arraycopy_barrier(src, dst, length);\n-}\n+JRT_LEAF(void, ShenandoahRuntime::arraycopy_barrier_oop(oop* src, oop* dst, size_t length))\n+  ShenandoahBarrierSet::barrier_set()->arraycopy_barrier(src, dst, length);\n+JRT_END\n@@ -39,4 +38,3 @@\n-void ShenandoahRuntime::arraycopy_barrier_narrow_oop_entry(narrowOop* src, narrowOop* dst, size_t length) {\n-  ShenandoahBarrierSet *bs = ShenandoahBarrierSet::barrier_set();\n-  bs->arraycopy_barrier(src, dst, length);\n-}\n+JRT_LEAF(void, ShenandoahRuntime::arraycopy_barrier_narrow_oop(narrowOop* src, narrowOop* dst, size_t length))\n+  ShenandoahBarrierSet::barrier_set()->arraycopy_barrier(src, dst, length);\n+JRT_END\n@@ -44,2 +42,1 @@\n-\/\/ Shenandoah pre write barrier slowpath\n-JRT_LEAF(void, ShenandoahRuntime::write_ref_field_pre_entry(oopDesc* orig, JavaThread *thread))\n+JRT_LEAF(void, ShenandoahRuntime::write_ref_field_pre(oopDesc * orig, JavaThread * thread))\n@@ -49,1 +46,1 @@\n-  \/\/ store the original value that was in the field reference\n+  \/\/ Capture the original value that was in the field reference.\n@@ -63,9 +60,1 @@\n-\/\/ Shenandoah clone barrier: makes sure that references point to to-space\n-\/\/ in cloned objects.\n-JRT_LEAF(void, ShenandoahRuntime::shenandoah_clone_barrier(oopDesc* src))\n-  oop s = oop(src);\n-  shenandoah_assert_correct(nullptr, s);\n-  ShenandoahBarrierSet::barrier_set()->clone_barrier(s);\n-JRT_END\n-\n-JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_weak(oopDesc * src, oop* load_addr))\n+JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_weak(oopDesc* src, oop* load_addr))\n@@ -75,1 +64,1 @@\n-JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_weak_narrow(oopDesc * src, narrowOop* load_addr))\n+JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_weak_narrow(oopDesc* src, narrowOop* load_addr))\n@@ -79,1 +68,1 @@\n-JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_phantom(oopDesc * src, oop* load_addr))\n+JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_phantom(oopDesc* src, oop* load_addr))\n@@ -83,1 +72,1 @@\n-JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_phantom_narrow(oopDesc * src, narrowOop* load_addr))\n+JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_phantom_narrow(oopDesc* src, narrowOop* load_addr))\n@@ -86,0 +75,6 @@\n+\n+JRT_LEAF(void, ShenandoahRuntime::clone_barrier(oopDesc* src))\n+  oop s = oop(src);\n+  shenandoah_assert_correct(nullptr, s);\n+  ShenandoahBarrierSet::barrier_set()->clone_barrier(s);\n+JRT_END\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.cpp","additions":18,"deletions":23,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-  static void arraycopy_barrier_oop_entry(oop* src, oop* dst, size_t length);\n-  static void arraycopy_barrier_narrow_oop_entry(narrowOop* src, narrowOop* dst, size_t length);\n+  static void arraycopy_barrier_oop(oop* src, oop* dst, size_t length);\n+  static void arraycopy_barrier_narrow_oop(narrowOop* src, narrowOop* dst, size_t length);\n@@ -39,1 +39,1 @@\n-  static void write_ref_field_pre_entry(oopDesc* orig, JavaThread* thread);\n+  static void write_ref_field_pre(oopDesc* orig, JavaThread* thread);\n@@ -50,1 +50,1 @@\n-  static void shenandoah_clone_barrier(oopDesc* src);\n+  static void clone_barrier(oopDesc* src);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp\"\n@@ -46,2 +46,2 @@\n-  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n-  uintx mask = ~right_n_bits(bit_number);\n+  uintx bit_number = start_idx & (BitsPerWord - 1);\n+  uintx mask = ~tail_mask(bit_number);\n@@ -57,1 +57,1 @@\n-    \/\/ Constant folding:                  bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+    \/\/ Constant folding:                  bit_number = start_idx & (BitsPerWord - 1);\n@@ -73,1 +73,1 @@\n-  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  uintx bit_number = last_idx & (BitsPerWord - 1);\n@@ -75,1 +75,1 @@\n-  uintx mask = right_n_bits(bit_number + 1);\n+  uintx mask = tail_mask(bit_number + 1);\n@@ -84,1 +84,1 @@\n-    \/\/ Constant folding:                  bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+    \/\/ Constant folding:                  bit_number = last_idx & (BitsPerWord - 1);\n@@ -102,1 +102,1 @@\n-    uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+    uintx bit_number = start_idx & (BitsPerWord - 1);\n@@ -131,1 +131,1 @@\n-    uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+    uintx bit_number = last_idx & (BitsPerWord - 1);\n@@ -164,1 +164,1 @@\n-  uintx bit_number = beg & right_n_bits(LogBitsPerWord);\n+  uintx bit_number = beg & (BitsPerWord - 1);\n@@ -167,1 +167,1 @@\n-    uintx mask_out = right_n_bits(bit_number);\n+    uintx mask_out = tail_mask(bit_number);\n@@ -225,1 +225,1 @@\n-      bit_number = beg & right_n_bits(LogBitsPerWord);\n+      bit_number = beg & (BitsPerWord - 1);\n@@ -227,1 +227,1 @@\n-        size_t mask_out = right_n_bits(bit_number);\n+        size_t mask_out = tail_mask(bit_number);\n@@ -245,1 +245,1 @@\n-  uintx bit_number = end & right_n_bits(LogBitsPerWord);\n+  uintx bit_number = end & (BitsPerWord - 1);\n@@ -248,1 +248,1 @@\n-    uintx mask_in = right_n_bits(bit_number + 1);\n+    uintx mask_in = tail_mask(bit_number + 1);\n@@ -283,1 +283,1 @@\n-      bit_number = end & right_n_bits(LogBitsPerWord);\n+      bit_number = end & (BitsPerWord - 1);\n@@ -286,1 +286,1 @@\n-        size_t mask_in = right_n_bits(bit_number + 1);\n+        size_t mask_in = tail_mask(bit_number + 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-\/\/ might be violatee through future software maintenance.\n+\/\/ might be violated through future software maintenance.\n@@ -87,1 +87,1 @@\n-    idx_t array_idx = idx & ~right_n_bits(LogBitsPerWord);\n+    idx_t array_idx = idx & ~(BitsPerWord - 1);\n@@ -110,1 +110,1 @@\n-    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx bit_number = idx & (BitsPerWord - 1);\n@@ -119,1 +119,1 @@\n-    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx bit_number = idx & (BitsPerWord - 1);\n@@ -128,1 +128,1 @@\n-    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx bit_number = idx & (BitsPerWord - 1);\n@@ -130,1 +130,1 @@\n-    return (_bitmap[array_idx] & the_bit)? true: false;\n+    return (_bitmap[array_idx] & the_bit) != 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,7 @@\n+inline uintx tail_mask(uintx bit_number) {\n+  if (bit_number >= BitsPerWord) {\n+    return -1;\n+  }\n+  return (uintx(1) << bit_number) - 1;\n+}\n+\n@@ -35,1 +42,1 @@\n-    uintx bit_number = beg & right_n_bits(LogBitsPerWord);\n+    uintx bit_number = beg & (BitsPerWord - 1);\n@@ -38,1 +45,1 @@\n-      uintx mask_out = right_n_bits(bit_number);\n+      uintx mask_out = tail_mask(bit_number);\n@@ -65,1 +72,1 @@\n-    uintx bit_number = end & right_n_bits(LogBitsPerWord);\n+    uint8_t bit_number = end & (BitsPerWord - 1);\n@@ -68,1 +75,1 @@\n-      uintx mask_in = right_n_bits(bit_number + 1);\n+      uintx mask_in = tail_mask(bit_number + 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -63,1 +64,1 @@\n-    _initialize(&_barrier_set),\n+    _initializer(&_barrier_set),\n@@ -81,0 +82,1 @@\n+    vm_shutdown_during_initialization(ZInitialize::error_message());\n@@ -86,0 +88,2 @@\n+  ZInitialize::finish();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  ZInitialize       _initialize;\n+  ZInitializer      _initializer;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/z\/zInitialize.hpp\"\n@@ -77,1 +78,1 @@\n-    log_error_p(gc)(\"Failed to allocate initial Java heap (\" SIZE_FORMAT \"M)\", InitialHeapSize \/ M);\n+    ZInitialize::error(\"Failed to allocate initial Java heap (\" SIZE_FORMAT \"M)\", InitialHeapSize \/ M);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n@@ -41,0 +42,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -42,0 +44,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -43,1 +46,9 @@\n-ZInitialize::ZInitialize(ZBarrierSet* barrier_set) {\n+char ZInitialize::_error_message[ErrorMessageLength] = {};\n+bool ZInitialize::_had_error                         = false;\n+bool ZInitialize::_finished                          = false;\n+\n+ZInitializer::ZInitializer(ZBarrierSet* barrier_set) {\n+  ZInitialize::initialize(barrier_set);\n+}\n+\n+void ZInitialize::initialize(ZBarrierSet* barrier_set) {\n@@ -65,0 +76,48 @@\n+\n+void ZInitialize::register_error(bool debug, const char *error_msg) {\n+  guarantee(!_finished, \"Only register errors during initialization\");\n+\n+  if (!_had_error) {\n+    strncpy(_error_message, error_msg, ErrorMessageLength - 1);\n+    _had_error = true;\n+  }\n+\n+  if (debug) {\n+    log_error_pd(gc)(\"%s\", error_msg);\n+  } else {\n+    log_error_p(gc)(\"%s\", error_msg);\n+  }\n+}\n+\n+void ZInitialize::error(const char* msg_format, ...) {\n+  va_list argp;\n+  va_start(argp, msg_format);\n+  const FormatBuffer<ErrorMessageLength> error_msg(FormatBufferDummy(), msg_format, argp);\n+  va_end(argp);\n+  register_error(false \/* debug *\/, error_msg);\n+}\n+\n+void ZInitialize::error_d(const char* msg_format, ...) {\n+  va_list argp;\n+  va_start(argp, msg_format);\n+  const FormatBuffer<ErrorMessageLength> error_msg(FormatBufferDummy(), msg_format, argp);\n+  va_end(argp);\n+  register_error(true \/* debug *\/, error_msg);\n+}\n+\n+bool ZInitialize::had_error() {\n+  return _had_error;\n+}\n+\n+const char* ZInitialize::error_message() {\n+  assert(had_error(), \"Should have registered an error\");\n+  if (had_error()) {\n+    return _error_message;\n+  }\n+  return \"Unknown error, check error GC logs\";\n+}\n+\n+void ZInitialize::finish() {\n+  guarantee(!_finished, \"Only finish initialization once\");\n+  _finished = true;\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zInitialize.cpp","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -27,1 +27,4 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/compilerWarnings.hpp\"\n+\n+#include <cstddef>\n@@ -31,1 +34,6 @@\n-class ZInitialize {\n+class ZInitializer {\n+public:\n+  ZInitializer(ZBarrierSet* barrier_set);\n+};\n+\n+class ZInitialize : public AllStatic {\n@@ -33,1 +41,9 @@\n-  void pd_initialize();\n+  static constexpr size_t ErrorMessageLength = 256;\n+\n+  static char _error_message[ErrorMessageLength];\n+  static bool _had_error;\n+  static bool _finished;\n+\n+  static void register_error(bool debug, const char *error_msg);\n+\n+  static void pd_initialize();\n@@ -36,1 +52,8 @@\n-  ZInitialize(ZBarrierSet* barrier_set);\n+  static void error(const char* msg_format, ...) ATTRIBUTE_PRINTF(1, 2);\n+  static void error_d(const char* msg_format, ...) ATTRIBUTE_PRINTF(1, 2);\n+\n+  static bool had_error();\n+  static const char* error_message();\n+\n+  static void initialize(ZBarrierSet* barrier_set);\n+  static void finish();\n","filename":"src\/hotspot\/share\/gc\/z\/zInitialize.hpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"gc\/shared\/gcLogPrecious.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"gc\/z\/zInitialize.hpp\"\n@@ -46,1 +46,1 @@\n-    log_error_pd(gc, marking)(\"Failed to reserve address space for mark stacks\");\n+    ZInitialize::error_d(\"Failed to reserve address space for mark stacks\");\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zInitialize.hpp\"\n@@ -47,1 +48,1 @@\n-    log_error_pd(gc)(\"Failed to reserve enough address space for Java heap\");\n+    ZInitialize::error_d(\"Failed to reserve enough address space for Java heap\");\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemory.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-  address generate_trace_code(TosState state)   PRODUCT_RETURN0;\n+  address generate_trace_code(TosState state)   PRODUCT_RETURN_NULL;\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -487,0 +487,3 @@\n+  if (klass->is_instance_klass() && InstanceKlass::cast(klass)->is_scratch_class()) {\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jvmci\/jvmci.hpp\"\n@@ -93,2 +94,1 @@\n-      char path[JVM_MAXPATHLEN];\n-      if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {\n+      if (JVMCI::shared_library_exists()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-          \"Enable JVMCI\")                                                   \\\n+          \"Enable JVMCI. Defaults to true if UseJVMCICompiler is true.\")    \\\n@@ -143,2 +143,2 @@\n-          \"on the HotSpot heap. Defaults to true if EnableJVMCI is \"        \\\n-          \"true and a JVMCI native library is available.\")                  \\\n+          \"on the HotSpot heap. Defaults to true if UseJVMCICompiler or \"   \\\n+          \"EnableJVMCI is true and a JVMCI native library is available.\")   \\\n@@ -146,1 +146,1 @@\n-  product(double, JVMCINativeLibraryThreadFraction, 0.33, EXPERIMENTAL,     \\\n+  product(double, JVMCINativeLibraryThreadFraction, 0.66, EXPERIMENTAL,     \\\n@@ -148,1 +148,3 @@\n-          \"The remaining compiler threads are used by C1.\")                 \\\n+          \"The remaining compiler threads are used by C1. \"                 \\\n+          \"Reducing this value could reduce the max RSS but \"               \\\n+          \"also increase the warmup time.\")                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -249,0 +249,1 @@\n+  nonstatic_field(JavaThread,                  _unlocked_inflated_monitor,                    ObjectMonitor*)                        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    set_base(0);\n+    set_base(nullptr);\n@@ -118,1 +118,1 @@\n-  if (base() != 0) {\n+  if (base() != nullptr) {\n@@ -169,1 +169,1 @@\n-  if (base() != 0) {\n+  if (base() != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/compressedOops.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -784,1 +785,1 @@\n-  const char* printable_name_at(int cp_index) PRODUCT_RETURN0;\n+  const char* printable_name_at(int cp_index) PRODUCT_RETURN_NULL;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2724,0 +2724,7 @@\n+\n+  if (ik->is_scratch_class()) {\n+    assert(ik->dependencies().is_empty(), \"dependencies should be empty for scratch classes\");\n+    return;\n+  }\n+  assert(ik->is_loaded(), \"class should be loaded \" PTR_FORMAT, p2i(ik));\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -238,0 +238,7 @@\n+    if (def->is_MachTemp()) {\n+      assert(!def->bottom_type()->isa_oop_ptr(),\n+             \"ADLC only assigns OOP types to MachTemp defs corresponding to xRegN operands\");\n+      \/\/ Exclude MachTemp definitions even if they are typed as oops.\n+      continue;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-  Label _check_successor;\n@@ -117,1 +116,0 @@\n-  Label& check_successor() { return _check_successor; }\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -814,0 +814,1 @@\n+  case vmIntrinsics::_VectorWrapShuffleIndexes:\n@@ -824,0 +825,1 @@\n+  case vmIntrinsics::_VectorSelectFrom:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,0 +164,8 @@\n+    if (mach->barrier_data() != 0) {\n+      \/\/ Using memory accesses with barriers to perform implicit null checks is\n+      \/\/ not supported. These operations might expand into multiple assembly\n+      \/\/ instructions during code emission, including new memory accesses (e.g.\n+      \/\/ in G1's pre-barrier), which would invalidate the implicit null\n+      \/\/ exception table.\n+      continue;\n+    }\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -720,0 +720,2 @@\n+  case vmIntrinsics::_VectorWrapShuffleIndexes:\n+    return inline_vector_wrap_shuffle_indexes();\n@@ -740,0 +742,2 @@\n+  case vmIntrinsics::_VectorSelectFrom:\n+    return inline_vector_select_from();\n@@ -2051,1 +2055,1 @@\n-  } else if (base_type == TypePtr::NULL_PTR) {\n+  } else if (_gvn.type(base->uncast()) == TypePtr::NULL_PTR) {\n@@ -2369,0 +2373,1 @@\n+  assert(!stopped(), \"Inlining of unsafe access failed: address construction stopped unexpectedly\");\n@@ -2370,1 +2375,1 @@\n-  if (_gvn.type(base)->isa_ptr() == TypePtr::NULL_PTR) {\n+  if (_gvn.type(base->uncast())->isa_ptr() == TypePtr::NULL_PTR) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -356,0 +356,1 @@\n+  bool inline_vector_wrap_shuffle_indexes();\n@@ -366,0 +367,1 @@\n+  bool inline_vector_select_from();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1597,0 +1597,8 @@\n+    if (!shared && Matcher::is_encode_and_store_pattern(n, m)) {\n+      \/\/ Make it possible to match \"encode and store\" patterns with non-shared\n+      \/\/ encode operations that are pinned to a control node (e.g. by CastPP\n+      \/\/ node removal in final graph reshaping). The matched instruction cannot\n+      \/\/ float above the encode's control node because it is pinned to the\n+      \/\/ store's control node.\n+      return false;\n+    }\n@@ -2836,0 +2844,12 @@\n+bool Matcher::is_encode_and_store_pattern(const Node* n, const Node* m) {\n+  if (n == nullptr ||\n+      m == nullptr ||\n+      n->Opcode() != Op_StoreN ||\n+      !m->is_EncodeP() ||\n+      n->as_Store()->barrier_data() == 0) {\n+    return false;\n+  }\n+  assert(m == n->in(MemNode::ValueIn), \"m should be input to n\");\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -388,0 +388,2 @@\n+  static bool is_encode_and_store_pattern(const Node* n, const Node* m);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4647,0 +4647,5 @@\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  if ((st->Opcode() == Op_StoreP || st->Opcode() == Op_StoreN) &&\n+      !bs->can_initialize_object(st)) {\n+    return FAIL;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -127,5 +127,1 @@\n-#ifdef ASSERT\n-    return _adr_type;\n-#else\n-    return 0;\n-#endif\n+    return DEBUG_ONLY(_adr_type) NOT_DEBUG(nullptr);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2025,0 +2025,2 @@\n+      assert(n->in(1)->as_Mach()->barrier_data() == 0,\n+             \"Implicit null checks on memory accesses with barriers are not yet supported\");\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3263,2 +3263,2 @@\n-TypeInterfaces::TypeInterfaces()\n-        : Type(Interfaces), _list(Compile::current()->type_arena(), 0, 0, nullptr),\n+TypeInterfaces::TypeInterfaces(ciInstanceKlass** interfaces_base, int nb_interfaces)\n+        : Type(Interfaces), _interfaces(interfaces_base, nb_interfaces),\n@@ -3266,9 +3266,1 @@\n-  DEBUG_ONLY(_initialized = true);\n-}\n-\n-TypeInterfaces::TypeInterfaces(GrowableArray<ciInstanceKlass*>* interfaces)\n-        : Type(Interfaces), _list(Compile::current()->type_arena(), interfaces->length(), 0, nullptr),\n-          _hash(0), _exact_klass(nullptr) {\n-  for (int i = 0; i < interfaces->length(); i++) {\n-    add(interfaces->at(i));\n-  }\n+  _interfaces.sort(compare);\n@@ -3279,1 +3271,14 @@\n-  TypeInterfaces* result = (interfaces == nullptr) ? new TypeInterfaces() : new TypeInterfaces(interfaces);\n+  \/\/ hashcons() can only delete the last thing that was allocated: to\n+  \/\/ make sure all memory for the newly created TypeInterfaces can be\n+  \/\/ freed if an identical one exists, allocate space for the array of\n+  \/\/ interfaces right after the TypeInterfaces object so that they\n+  \/\/ form a contiguous piece of memory.\n+  int nb_interfaces = interfaces == nullptr ? 0 : interfaces->length();\n+  size_t total_size = sizeof(TypeInterfaces) + nb_interfaces * sizeof(ciInstanceKlass*);\n+\n+  void* allocated_mem = operator new(total_size);\n+  ciInstanceKlass** interfaces_base = (ciInstanceKlass**)((char*)allocated_mem + sizeof(TypeInterfaces));\n+  for (int i = 0; i < nb_interfaces; ++i) {\n+    interfaces_base[i] = interfaces->at(i);\n+  }\n+  TypeInterfaces* result = ::new (allocated_mem) TypeInterfaces(interfaces_base, nb_interfaces);\n@@ -3298,4 +3303,2 @@\n-void TypeInterfaces::add(ciInstanceKlass* interface) {\n-  assert(interface->is_interface(), \"for interfaces only\");\n-  _list.insert_sorted<compare>(interface);\n-  verify();\n+int TypeInterfaces::compare(ciInstanceKlass** k1, ciInstanceKlass** k2) {\n+  return compare(*k1, *k2);\n@@ -3306,1 +3309,1 @@\n-  if (_list.length() != other->_list.length()) {\n+  if (_interfaces.length() != other->_interfaces.length()) {\n@@ -3309,3 +3312,3 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* k1 = _list.at(i);\n-    ciKlass* k2 = other->_list.at(i);\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    ciKlass* k1 = _interfaces.at(i);\n+    ciKlass* k2 = other->_interfaces.at(i);\n@@ -3322,1 +3325,1 @@\n-  if (_list.length() != interfaces->length()) {\n+  if (_interfaces.length() != interfaces->length()) {\n@@ -3327,1 +3330,1 @@\n-    _list.find_sorted<ciInstanceKlass*, compare>(interfaces->at(i), found);\n+    _interfaces.find_sorted<ciInstanceKlass*, compare>(interfaces->at(i), found);\n@@ -3347,2 +3350,2 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* k = _list.at(i);\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    ciKlass* k = _interfaces.at(i);\n@@ -3359,1 +3362,1 @@\n-  if (_list.length() == 0) {\n+  if (_interfaces.length() == 0) {\n@@ -3365,1 +3368,1 @@\n-  interfaces.appendAll(&_list);\n+  interfaces.appendAll(&_interfaces);\n@@ -3380,3 +3383,3 @@\n-  for (int i = 1; i < _list.length(); i++) {\n-    ciInstanceKlass* k1 = _list.at(i-1);\n-    ciInstanceKlass* k2 = _list.at(i);\n+  for (int i = 1; i < _interfaces.length(); i++) {\n+    ciInstanceKlass* k1 = _interfaces.at(i-1);\n+    ciInstanceKlass* k2 = _interfaces.at(i);\n@@ -3393,5 +3396,5 @@\n-  while (i < _list.length() || j < other->_list.length()) {\n-    while (i < _list.length() &&\n-           (j >= other->_list.length() ||\n-            compare(_list.at(i), other->_list.at(j)) < 0)) {\n-      result_list.push(_list.at(i));\n+  while (i < _interfaces.length() || j < other->_interfaces.length()) {\n+    while (i < _interfaces.length() &&\n+           (j >= other->_interfaces.length() ||\n+            compare(_interfaces.at(i), other->_interfaces.at(j)) < 0)) {\n+      result_list.push(_interfaces.at(i));\n@@ -3400,4 +3403,4 @@\n-    while (j < other->_list.length() &&\n-           (i >= _list.length() ||\n-            compare(other->_list.at(j), _list.at(i)) < 0)) {\n-      result_list.push(other->_list.at(j));\n+    while (j < other->_interfaces.length() &&\n+           (i >= _interfaces.length() ||\n+            compare(other->_interfaces.at(j), _interfaces.at(i)) < 0)) {\n+      result_list.push(other->_interfaces.at(j));\n@@ -3406,4 +3409,4 @@\n-    if (i < _list.length() &&\n-        j < other->_list.length() &&\n-        _list.at(i) == other->_list.at(j)) {\n-      result_list.push(_list.at(i));\n+    if (i < _interfaces.length() &&\n+        j < other->_interfaces.length() &&\n+        _interfaces.at(i) == other->_interfaces.at(j)) {\n+      result_list.push(_interfaces.at(i));\n@@ -3417,2 +3420,2 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    assert(result->_list.contains(_list.at(i)), \"missing\");\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    assert(result->_interfaces.contains(_interfaces.at(i)), \"missing\");\n@@ -3420,2 +3423,2 @@\n-  for (int i = 0; i < other->_list.length(); i++) {\n-    assert(result->_list.contains(other->_list.at(i)), \"missing\");\n+  for (int i = 0; i < other->_interfaces.length(); i++) {\n+    assert(result->_interfaces.contains(other->_interfaces.at(i)), \"missing\");\n@@ -3423,2 +3426,2 @@\n-  for (int i = 0; i < result->_list.length(); i++) {\n-    assert(_list.contains(result->_list.at(i)) || other->_list.contains(result->_list.at(i)), \"missing\");\n+  for (int i = 0; i < result->_interfaces.length(); i++) {\n+    assert(_interfaces.contains(result->_interfaces.at(i)) || other->_interfaces.contains(result->_interfaces.at(i)), \"missing\");\n@@ -3434,4 +3437,4 @@\n-  while (i < _list.length() || j < other->_list.length()) {\n-    while (i < _list.length() &&\n-           (j >= other->_list.length() ||\n-            compare(_list.at(i), other->_list.at(j)) < 0)) {\n+  while (i < _interfaces.length() || j < other->_interfaces.length()) {\n+    while (i < _interfaces.length() &&\n+           (j >= other->_interfaces.length() ||\n+            compare(_interfaces.at(i), other->_interfaces.at(j)) < 0)) {\n@@ -3440,3 +3443,3 @@\n-    while (j < other->_list.length() &&\n-           (i >= _list.length() ||\n-            compare(other->_list.at(j), _list.at(i)) < 0)) {\n+    while (j < other->_interfaces.length() &&\n+           (i >= _interfaces.length() ||\n+            compare(other->_interfaces.at(j), _interfaces.at(i)) < 0)) {\n@@ -3445,4 +3448,4 @@\n-    if (i < _list.length() &&\n-        j < other->_list.length() &&\n-        _list.at(i) == other->_list.at(j)) {\n-      result_list.push(_list.at(i));\n+    if (i < _interfaces.length() &&\n+        j < other->_interfaces.length() &&\n+        _interfaces.at(i) == other->_interfaces.at(j)) {\n+      result_list.push(_interfaces.at(i));\n@@ -3456,2 +3459,2 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    assert(!other->_list.contains(_list.at(i)) || result->_list.contains(_list.at(i)), \"missing\");\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    assert(!other->_interfaces.contains(_interfaces.at(i)) || result->_interfaces.contains(_interfaces.at(i)), \"missing\");\n@@ -3459,2 +3462,2 @@\n-  for (int i = 0; i < other->_list.length(); i++) {\n-    assert(!_list.contains(other->_list.at(i)) || result->_list.contains(other->_list.at(i)), \"missing\");\n+  for (int i = 0; i < other->_interfaces.length(); i++) {\n+    assert(!_interfaces.contains(other->_interfaces.at(i)) || result->_interfaces.contains(other->_interfaces.at(i)), \"missing\");\n@@ -3462,2 +3465,2 @@\n-  for (int i = 0; i < result->_list.length(); i++) {\n-    assert(_list.contains(result->_list.at(i)) && other->_list.contains(result->_list.at(i)), \"missing\");\n+  for (int i = 0; i < result->_interfaces.length(); i++) {\n+    assert(_interfaces.contains(result->_interfaces.at(i)) && other->_interfaces.contains(result->_interfaces.at(i)), \"missing\");\n@@ -3476,1 +3479,1 @@\n-  if (_list.length() == 0) {\n+  if (_interfaces.length() == 0) {\n@@ -3481,2 +3484,2 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciInstanceKlass* interface = _list.at(i);\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    ciInstanceKlass* interface = _interfaces.at(i);\n@@ -3493,2 +3496,2 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* interface = _list.at(i);\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    ciKlass* interface = _interfaces.at(i);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":73,"deletions":70,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-  GrowableArray<ciInstanceKlass*> _list;\n+  GrowableArrayFromArray<ciInstanceKlass*> _interfaces;\n@@ -887,1 +887,0 @@\n-  void add(ciInstanceKlass* interface);\n@@ -891,2 +890,2 @@\n-  TypeInterfaces();\n-  TypeInterfaces(GrowableArray<ciInstanceKlass*>* interfaces);\n+\n+  TypeInterfaces(ciInstanceKlass** interfaces_base, int nb_interfaces);\n@@ -907,1 +906,1 @@\n-  bool empty() const { return _list.length() == 0; }\n+  bool empty() const { return _interfaces.length() == 0; }\n@@ -913,0 +912,1 @@\n+  static int compare(ciInstanceKlass** k1, ciInstanceKlass** k2);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -760,0 +760,58 @@\n+\/\/ public static\n+\/\/ <E,\n+\/\/  SH extends VectorShuffle<E>>\n+\/\/ SH wrapShuffleIndexes(Class<E> eClass, Class<? extends SH> shClass, SH sh, int length,\n+\/\/                       ShuffleWrapIndexesOperation<SH> defaultImpl)\n+bool LibraryCallKit::inline_vector_wrap_shuffle_indexes() {\n+  const TypeInstPtr* elem_klass    = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();\n+  Node*              shuffle       = argument(2);\n+  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n+\n+  if (elem_klass == nullptr || shuffle_klass == nullptr || shuffle->is_top() || vlen == nullptr ||\n+      !vlen->is_con() || shuffle_klass->const_oop() == nullptr) {\n+    \/\/ not enough info for intrinsification\n+    return false;\n+  }\n+\n+  if (!is_klass_initialized(shuffle_klass)) {\n+    log_if_needed(\"  ** klass argument not initialized\");\n+    return false;\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  if ((num_elem < 4) || !is_power_of_2(num_elem)) {\n+    log_if_needed(\"  ** vlen < 4 or not power of two=%d\", num_elem);\n+    return false;\n+  }\n+\n+  \/\/ Shuffles use byte array based backing storage\n+  BasicType shuffle_bt = T_BYTE;\n+  if (!arch_supports_vector(Op_AndV, num_elem, shuffle_bt, VecMaskNotUsed) ||\n+      !arch_supports_vector(Op_Replicate, num_elem, shuffle_bt, VecMaskNotUsed)) {\n+    log_if_needed(\"  ** not supported: op=wrapShuffleIndexes vlen=%d etype=%s\",\n+                  num_elem, type2name(shuffle_bt));\n+    return false;\n+  }\n+\n+  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n+\n+  \/\/ Unbox shuffle with true flag to indicate its load shuffle to vector\n+  \/\/ shuffle is a byte array\n+  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, shuffle_bt, num_elem, true);\n+\n+  const TypeVect* vt  = TypeVect::make(shuffle_bt, num_elem);\n+  const Type* shuffle_type_bt = Type::get_const_basic_type(shuffle_bt);\n+  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem-1));\n+  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, shuffle_type_bt));\n+  \/\/ Wrap the indices greater than lane count.\n+  Node* res = gvn().transform(VectorNode::make(Op_AndV, shuffle_vec, bcast_mod_mask, vt));\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  res = box_vector(res, shuffle_box_type, shuffle_bt, num_elem);\n+  set_result(res);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(shuffle_bt))));\n+  return true;\n+}\n+\n@@ -2047,0 +2105,144 @@\n+\/\/    public static\n+\/\/    <V extends Vector<E>,\n+\/\/     M  extends VectorMask<E>,\n+\/\/     E>\n+\/\/    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+\/\/                   int length, V v1, V v2, M m,\n+\/\/                   VectorSelectFromOp<V, M> defaultImpl)\n+bool LibraryCallKit::inline_vector_select_from() {\n+  const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* mask_klass    = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass    = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n+\n+  if (vector_klass == nullptr  || elem_klass == nullptr || vlen == nullptr ||\n+      vector_klass->const_oop()  == nullptr ||\n+      elem_klass->const_oop()    == nullptr ||\n+      !vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()]);\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+  if (!is_klass_initialized(vector_klass)) {\n+    log_if_needed(\"  ** klass argument not initialized\");\n+    return false;\n+  }\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    return false; \/\/ should be primitive type\n+  }\n+  BasicType elem_bt = elem_type->basic_type();\n+  int num_elem = vlen->get_con();\n+  if (!is_power_of_2(num_elem)) {\n+    log_if_needed(\"  ** vlen not power of two=%d\", num_elem);\n+    return false;\n+  }\n+\n+  int cast_vopc = VectorCastNode::opcode(-1, elem_bt); \/\/ from vector of type elem_bt\n+  if (!arch_supports_vector(Op_VectorLoadShuffle, num_elem, elem_bt, VecMaskNotUsed)||\n+      !arch_supports_vector(Op_AndV, num_elem, T_BYTE, VecMaskNotUsed)              ||\n+      !arch_supports_vector(Op_Replicate, num_elem, T_BYTE, VecMaskNotUsed)         ||\n+      !arch_supports_vector(cast_vopc, num_elem, T_BYTE, VecMaskNotUsed)) {\n+    log_if_needed(\"  ** not supported: arity=0 op=selectFrom vlen=%d etype=%s ismask=no\",\n+                    num_elem, type2name(elem_bt));\n+    return false; \/\/ not supported\n+  }\n+\n+  bool is_masked_op = argument(6)->bottom_type() != TypePtr::NULL_PTR;\n+  bool use_predicate = is_masked_op;\n+  if (is_masked_op &&\n+      (mask_klass == nullptr ||\n+       mask_klass->const_oop() == nullptr ||\n+       !is_klass_initialized(mask_klass))) {\n+    log_if_needed(\"  ** mask_klass argument not initialized\");\n+    return false; \/\/ not supported\n+  }\n+  VectorMaskUseType checkFlags = (VectorMaskUseType)(is_masked_op ? (VecMaskUseLoad | VecMaskUsePred) : VecMaskNotUsed);\n+  if (!arch_supports_vector(Op_VectorRearrange, num_elem, elem_bt, checkFlags)) {\n+    use_predicate = false;\n+    if(!is_masked_op ||\n+       (!arch_supports_vector(Op_VectorRearrange, num_elem, elem_bt, VecMaskNotUsed) ||\n+        !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)     ||\n+        !arch_supports_vector(Op_Replicate, num_elem, elem_bt, VecMaskNotUsed))) {\n+      log_if_needed(\"  ** not supported: op=selectFrom vlen=%d etype=%s is_masked_op=%d\",\n+                      num_elem, type2name(elem_bt), is_masked_op);\n+      return false; \/\/ not supported\n+    }\n+  }\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  \/\/ v1 is the index vector\n+  Node* v1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  \/\/ v2 is the vector being rearranged\n+  Node* v2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+\n+  if (v1 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(4)->Opcode()]);\n+    return false; \/\/ operand unboxing failed\n+  }\n+\n+  if (v2 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(5)->Opcode()]);\n+    return false; \/\/ operand unboxing failed\n+  }\n+\n+  Node* mask = nullptr;\n+  if (is_masked_op) {\n+    ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+    const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);\n+    mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);\n+    if (mask == nullptr) {\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(6)->Opcode()]);\n+      return false;\n+    }\n+  }\n+\n+  \/\/ cast index vector from elem_bt vector to byte vector\n+  const Type * byte_bt = Type::get_const_basic_type(T_BYTE);\n+  const TypeVect * byte_vt  = TypeVect::make(byte_bt, num_elem);\n+  Node* byte_shuffle = gvn().transform(VectorCastNode::make(cast_vopc, v1, T_BYTE, num_elem));\n+\n+  \/\/ wrap the byte vector lanes to (num_elem - 1) to form the shuffle vector where num_elem is vector length\n+  \/\/ this is a simple AND operation as we come here only for power of two vector length\n+  Node* mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n+  Node* bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, byte_bt));\n+  byte_shuffle = gvn().transform(VectorNode::make(Op_AndV, byte_shuffle, bcast_mod, byte_vt));\n+\n+  \/\/ load the shuffle to use in rearrange\n+  const TypeVect * shuffle_vt  = TypeVect::make(elem_bt, num_elem);\n+  Node* load_shuffle = gvn().transform(new VectorLoadShuffleNode(byte_shuffle, shuffle_vt));\n+\n+  \/\/ and finally rearrange\n+  Node* rearrange = new VectorRearrangeNode(v2, load_shuffle);\n+  if (is_masked_op) {\n+    if (use_predicate) {\n+      \/\/ masked rearrange is supported so use that directly\n+      rearrange->add_req(mask);\n+      rearrange->add_flag(Node::Flag_is_predicated_vector);\n+    } else {\n+      \/\/ masked rearrange is not supported so emulate usig blend\n+      const TypeVect* vt = v1->bottom_type()->is_vect();\n+      rearrange = gvn().transform(rearrange);\n+\n+      \/\/ create a zero vector with each lane element set as zero\n+      Node* zero = gvn().makecon(Type::get_zero_type(elem_bt));\n+      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, Type::get_const_basic_type(elem_bt)));\n+\n+      \/\/ For each lane for which mask is set, blend in the rearranged lane into zero vector\n+      rearrange = new VectorBlendNode(zerovec, rearrange, mask);\n+    }\n+  }\n+  rearrange = gvn().transform(rearrange);\n+\n+  \/\/ box the result\n+  Node* box = box_vector(rearrange, vbox_type, elem_bt, num_elem);\n+  set_result(box);\n+\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":202,"deletions":0,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-  if (m->is_initializer()) {\n+  if (m->is_object_initializer()) {\n@@ -450,0 +450,2 @@\n+    \/\/ Note: Static initializers can theoretically be here, if JNI users manage\n+    \/\/ to get their jmethodID. Record them as plain methods.\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1829,8 +1829,0 @@\n-static bool select_method(const methodHandle& method, bool want_constructor) {\n-  if (want_constructor) {\n-    return (method->is_initializer() && !method->is_static());\n-  } else {\n-    return  (!method->is_initializer() && !method->is_overpass());\n-  }\n-}\n-\n@@ -1869,0 +1861,1 @@\n+  \/\/ Select methods matching the criteria.\n@@ -1870,6 +1863,8 @@\n-    methodHandle method(THREAD, methods->at(i));\n-    if (select_method(method, want_constructor)) {\n-      if (!publicOnly || method->is_public()) {\n-        idnums->push(method->method_idnum());\n-        ++num_methods;\n-      }\n+    Method* method = methods->at(i);\n+    if (want_constructor && !method->is_object_initializer()) {\n+      continue;\n+    }\n+    if (!want_constructor &&\n+        (method->is_object_initializer() || method->is_static_initializer() ||\n+         method->is_overpass())) {\n+      continue;\n@@ -1877,0 +1872,5 @@\n+    if (publicOnly && !method->is_public()) {\n+      continue;\n+    }\n+    idnums->push(method->method_idnum());\n+    ++num_methods;\n@@ -2178,3 +2178,1 @@\n-  if (!m->is_initializer() || m->is_static()) {\n-    method = Reflection::new_method(m, true, CHECK_NULL);\n-  } else {\n+  if (m->is_object_initializer()) {\n@@ -2182,0 +2180,3 @@\n+  } else {\n+    \/\/ new_method accepts <clinit> as Method here\n+    method = Reflection::new_method(m, true, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+      assert(!m->is_static_initializer(), \"Cannot be static initializer\");\n@@ -317,1 +318,1 @@\n-    } else if (m->is_initializer()) {\n+    } else if (m->is_object_initializer()) {\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -339,0 +339,5 @@\n+\/\/ Return true if the key matches the --module-path property name (\"jdk.module.path\").\n+bool Arguments::is_module_path_property(const char* key) {\n+  return (strcmp(key, MODULE_PROPERTY_PREFIX PATH) == 0);\n+}\n+\n@@ -1820,11 +1825,0 @@\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    FLAG_SET_CMDLINE(LockingMode, LM_LEGACY);\n-    warning(\"New lightweight locking not supported on this platform\");\n-  }\n-  if (UseObjectMonitorTable) {\n-    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n-    warning(\"UseObjectMonitorTable not supported on this platform\");\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -464,0 +464,1 @@\n+  static bool is_module_path_property(const char* key);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64) || defined(S390)\n+#if !defined(ZERO) && (defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64) || defined(S390))\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  bool const jvmci_enabled = JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false);\n+  bool const jvmci_enabled = JVMCI_ONLY(EnableJVMCI) NOT_JVMCI(false);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-      _barrier_active(barrier_active && (JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false)\n+      _barrier_active(barrier_active && (JVMCI_ONLY(EnableJVMCI) NOT_JVMCI(false)\n@@ -83,1 +83,1 @@\n-      _barrier_active(barrier_active && (JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false)\n+      _barrier_active(barrier_active && (JVMCI_ONLY(EnableJVMCI) NOT_JVMCI(false)\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -292,3 +292,0 @@\n-  product(size_t, InlineCacheBufferSize, 10*K, EXPERIMENTAL,                \\\n-          \"InlineCacheBuffer size\")                                         \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -490,0 +490,1 @@\n+  _unlocked_inflated_monitor(nullptr),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -467,0 +467,1 @@\n+  ObjectMonitor* _unlocked_inflated_monitor;\n@@ -618,0 +619,6 @@\n+  \/\/ Support for SharedRuntime::monitor_exit_helper()\n+  ObjectMonitor* unlocked_inflated_monitor() const { return _unlocked_inflated_monitor; }\n+  void clear_unlocked_inflated_monitor() {\n+    _unlocked_inflated_monitor = nullptr;\n+  }\n+\n@@ -831,0 +838,1 @@\n+  static ByteSize unlocked_inflated_monitor_offset() { return byte_offset_of(JavaThread, _unlocked_inflated_monitor); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-Mutex*   InlineCacheBuffer_lock       = nullptr;\n@@ -265,1 +264,1 @@\n-  MUTEX_DEFN(CompiledIC_lock                 , PaddedMutex  , nosafepoint);  \/\/ locks VtableStubs_lock, InlineCacheBuffer_lock\n+  MUTEX_DEFN(CompiledIC_lock                 , PaddedMutex  , nosafepoint);  \/\/ locks VtableStubs_lock\n@@ -322,1 +321,0 @@\n-  MUTEX_DEFL(InlineCacheBuffer_lock         , PaddedMutex  , CompiledIC_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-extern Mutex*   InlineCacheBuffer_lock;          \/\/ a lock used to guard the InlineCacheBuffer\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-\/\/   a singly-linked LIFO.  We drain _cxq into EntryList  at unlock-time when\n+\/\/   a singly-linked LIFO.  We drain _cxq into EntryList at unlock-time when\n@@ -213,13 +213,0 @@\n-\/\/\n-\/\/ * An interesting alternative is to encode cxq as (List,LockByte) where\n-\/\/   the LockByte is 0 iff the monitor is owned.  _owner is simply an auxiliary\n-\/\/   variable, like _recursions, in the scheme.  The threads or Events that form\n-\/\/   the list would have to be aligned in 256-byte addresses.  A thread would\n-\/\/   try to acquire the lock or enqueue itself with CAS, but exiting threads\n-\/\/   could use a 1-0 protocol and simply STB to set the LockByte to 0.\n-\/\/   Note that is is *not* word-tearing, but it does presume that full-word\n-\/\/   CAS operations are coherent with intermix with STB operations.  That's true\n-\/\/   on most common processors.\n-\/\/\n-\/\/ * See also http:\/\/blogs.sun.com\/dave\n-\n@@ -260,1 +247,0 @@\n-  _Responsible(nullptr),\n@@ -323,5 +309,1 @@\n-void ObjectMonitor::enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark) {\n-  \/\/ Used by ObjectSynchronizer::enter_for to enter for another thread.\n-  \/\/ The monitor is private to or already owned by locking_thread which must be suspended.\n-  \/\/ So this code may only contend with deflation.\n-  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+bool ObjectMonitor::TryLockWithContentionMark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark) {\n@@ -331,1 +313,0 @@\n-\n@@ -333,1 +314,0 @@\n-\n@@ -346,2 +326,10 @@\n-      \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n-      add_to_contentions(1);\n+      \/\/ We successfully cancelled the in-progress async deflation by\n+      \/\/ changing owner from DEFLATER_MARKER to current.  We now extend\n+      \/\/ the lifetime of the contention_mark (e.g. contentions++) here\n+      \/\/ to prevent the deflater thread from winning the last part of\n+      \/\/ the 2-part async deflation protocol after the regular\n+      \/\/ decrement occurs when the contention_mark goes out of\n+      \/\/ scope. ObjectMonitor::deflate_monitor() which is called by\n+      \/\/ the deflater thread will decrement contentions after it\n+      \/\/ recognizes that the async deflation was cancelled.\n+      contention_mark.extend();\n@@ -363,0 +351,12 @@\n+  assert(!success || owner_raw() == locking_thread, \"must be\");\n+\n+  return success;\n+}\n+\n+void ObjectMonitor::enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark) {\n+  \/\/ Used by LightweightSynchronizer::inflate_and_enter in deoptimization path to enter for another thread.\n+  \/\/ The monitor is private to or already owned by locking_thread which must be suspended.\n+  \/\/ So this code may only contend with deflation.\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+  bool success = TryLockWithContentionMark(locking_thread, contention_mark);\n+\n@@ -364,2 +364,2 @@\n-          \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n-          p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n+         \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}\",\n+         p2i(locking_thread), p2i(this), p2i(owner_raw()));\n@@ -369,0 +369,4 @@\n+  \/\/ Used by ObjectSynchronizer::enter_for() to enter for another thread.\n+  \/\/ The monitor is private to or already owned by locking_thread which must be suspended.\n+  \/\/ So this code may only contend with deflation.\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n@@ -378,1 +382,5 @@\n-  enter_for_with_contention_mark(locking_thread, contention_mark);\n+  bool success = TryLockWithContentionMark(locking_thread, contention_mark);\n+\n+  assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n+         \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}\",\n+         p2i(locking_thread), p2i(this), p2i(owner_raw()));\n@@ -383,2 +391,2 @@\n-bool ObjectMonitor::try_enter(JavaThread* current) {\n-  \/\/ TryLock avoids the CAS\n+bool ObjectMonitor::try_enter(JavaThread* current, bool check_for_recursion) {\n+  \/\/ TryLock avoids the CAS and handles deflation.\n@@ -391,0 +399,6 @@\n+  \/\/ If called from SharedRuntime::monitor_exit_helper(), we know that\n+  \/\/ this thread doesn't already own the lock.\n+  if (!check_for_recursion) {\n+    return false;\n+  }\n+\n@@ -403,1 +417,0 @@\n-\n@@ -564,4 +577,32 @@\n-  if (own != nullptr) return TryLockResult::HasOwner;\n-  if (try_set_owner_from(nullptr, current) == nullptr) {\n-    assert(_recursions == 0, \"invariant\");\n-    return TryLockResult::Success;\n+  void* first_own = own;\n+\n+  for (;;) {\n+    if (own == DEFLATER_MARKER) {\n+      \/\/ Block out deflation as soon as possible.\n+      ObjectMonitorContentionMark contention_mark(this);\n+\n+      \/\/ Check for deflation.\n+      if (enter_is_async_deflating()) {\n+        \/\/ Treat deflation as interference.\n+        return TryLockResult::Interference;\n+      }\n+      if (TryLockWithContentionMark(current, contention_mark)) {\n+        assert(_recursions == 0, \"invariant\");\n+        return TryLockResult::Success;\n+      } else {\n+        \/\/ Deflation won or change of owner; dont spin\n+        break;\n+      }\n+    } else if (own == nullptr) {\n+      void* prev_own = try_set_owner_from(nullptr, current);\n+      if (prev_own == nullptr) {\n+        assert(_recursions == 0, \"invariant\");\n+        return TryLockResult::Success;\n+      } else {\n+        \/\/ The lock had been free momentarily, but we lost the race to the lock.\n+        own = prev_own;\n+      }\n+    } else {\n+      \/\/ Retry doesn't make as much sense because the lock was just acquired.\n+      break;\n+    }\n@@ -569,5 +610,1 @@\n-  \/\/ The lock had been free momentarily, but we lost the race to the lock.\n-  \/\/ Interference -- the CAS failed.\n-  \/\/ We can either return -1 or retry.\n-  \/\/ Retry doesn't make as much sense because the lock was just acquired.\n-  return TryLockResult::Interference;\n+  return first_own == own ? TryLockResult::HasOwner : TryLockResult::Interference;\n@@ -749,2 +786,0 @@\n-#define MAX_RECHECK_INTERVAL 1000\n-\n@@ -758,19 +793,0 @@\n-    assert(_Responsible != current, \"invariant\");\n-    return;\n-  }\n-\n-  if (try_set_owner_from(DEFLATER_MARKER, current) == DEFLATER_MARKER) {\n-    \/\/ Cancelled the in-progress async deflation by changing owner from\n-    \/\/ DEFLATER_MARKER to current. As part of the contended enter protocol,\n-    \/\/ contentions was incremented to a positive value before EnterI()\n-    \/\/ was called and that prevents the deflater thread from winning the\n-    \/\/ last part of the 2-part async deflation protocol. After EnterI()\n-    \/\/ returns to enter(), contentions is decremented because the caller\n-    \/\/ now owns the monitor. We bump contentions an extra time here to\n-    \/\/ prevent the deflater thread from winning the last part of the\n-    \/\/ 2-part async deflation protocol after the regular decrement\n-    \/\/ occurs in enter(). The deflater thread will decrement contentions\n-    \/\/ after it recognizes that the async deflation was cancelled.\n-    add_to_contentions(1);\n-    assert(_succ != current, \"invariant\");\n-    assert(_Responsible != current, \"invariant\");\n@@ -792,1 +808,0 @@\n-    assert(_Responsible != current, \"invariant\");\n@@ -799,1 +814,0 @@\n-  assert(_Responsible != current, \"invariant\");\n@@ -829,1 +843,0 @@\n-      assert(_Responsible != current, \"invariant\");\n@@ -834,29 +847,0 @@\n-  \/\/ Check for cxq|EntryList edge transition to non-null.  This indicates\n-  \/\/ the onset of contention.  While contention persists exiting threads\n-  \/\/ will use a ST:MEMBAR:LD 1-1 exit protocol.  When contention abates exit\n-  \/\/ operations revert to the faster 1-0 mode.  This enter operation may interleave\n-  \/\/ (race) a concurrent 1-0 exit operation, resulting in stranding, so we\n-  \/\/ arrange for one of the contending thread to use a timed park() operations\n-  \/\/ to detect and recover from the race.  (Stranding is form of progress failure\n-  \/\/ where the monitor is unlocked but all the contending threads remain parked).\n-  \/\/ That is, at least one of the contended threads will periodically poll _owner.\n-  \/\/ One of the contending threads will become the designated \"Responsible\" thread.\n-  \/\/ The Responsible thread uses a timed park instead of a normal indefinite park\n-  \/\/ operation -- it periodically wakes and checks for and recovers from potential\n-  \/\/ strandings admitted by 1-0 exit operations.   We need at most one Responsible\n-  \/\/ thread per-monitor at any given moment.  Only threads on cxq|EntryList may\n-  \/\/ be responsible for a monitor.\n-  \/\/\n-  \/\/ Currently, one of the contended threads takes on the added role of \"Responsible\".\n-  \/\/ A viable alternative would be to use a dedicated \"stranding checker\" thread\n-  \/\/ that periodically iterated over all the threads (or active monitors) and unparked\n-  \/\/ successors where there was risk of stranding.  This would help eliminate the\n-  \/\/ timer scalability issues we see on some platforms as we'd only have one thread\n-  \/\/ -- the checker -- parked on a timer.\n-\n-  if (nxt == nullptr && _EntryList == nullptr) {\n-    \/\/ Try to assume the role of responsible thread for the monitor.\n-    \/\/ CONSIDER:  ST vs CAS vs { if (Responsible==null) Responsible=current }\n-    Atomic::replace_if_null(&_Responsible, current);\n-  }\n-\n@@ -874,2 +858,0 @@\n-  int recheckInterval = 1;\n-\n@@ -884,10 +866,1 @@\n-    if (_Responsible == current) {\n-      current->_ParkEvent->park((jlong) recheckInterval);\n-      \/\/ Increase the recheckInterval, but clamp the value.\n-      recheckInterval *= 8;\n-      if (recheckInterval > MAX_RECHECK_INTERVAL) {\n-        recheckInterval = MAX_RECHECK_INTERVAL;\n-      }\n-    } else {\n-      current->_ParkEvent->park();\n-    }\n+    current->_ParkEvent->park();\n@@ -899,16 +872,0 @@\n-    if (try_set_owner_from(DEFLATER_MARKER, current) == DEFLATER_MARKER) {\n-      \/\/ Cancelled the in-progress async deflation by changing owner from\n-      \/\/ DEFLATER_MARKER to current. As part of the contended enter protocol,\n-      \/\/ contentions was incremented to a positive value before EnterI()\n-      \/\/ was called and that prevents the deflater thread from winning the\n-      \/\/ last part of the 2-part async deflation protocol. After EnterI()\n-      \/\/ returns to enter(), contentions is decremented because the caller\n-      \/\/ now owns the monitor. We bump contentions an extra time here to\n-      \/\/ prevent the deflater thread from winning the last part of the\n-      \/\/ 2-part async deflation protocol after the regular decrement\n-      \/\/ occurs in enter(). The deflater thread will decrement contentions\n-      \/\/ after it recognizes that the async deflation was cancelled.\n-      add_to_contentions(1);\n-      break;\n-    }\n-\n@@ -956,25 +913,4 @@\n-  if (_succ == current) _succ = nullptr;\n-\n-  assert(_succ != current, \"invariant\");\n-  if (_Responsible == current) {\n-    _Responsible = nullptr;\n-    OrderAccess::fence(); \/\/ Dekker pivot-point\n-\n-    \/\/ We may leave threads on cxq|EntryList without a designated\n-    \/\/ \"Responsible\" thread.  This is benign.  When this thread subsequently\n-    \/\/ exits the monitor it can \"see\" such preexisting \"old\" threads --\n-    \/\/ threads that arrived on the cxq|EntryList before the fence, above --\n-    \/\/ by LDing cxq|EntryList.  Newly arrived threads -- that is, threads\n-    \/\/ that arrive on cxq after the ST:MEMBAR, above -- will set Responsible\n-    \/\/ non-null and elect a new \"Responsible\" timer thread.\n-    \/\/\n-    \/\/ This thread executes:\n-    \/\/    ST Responsible=null; MEMBAR    (in enter epilogue - here)\n-    \/\/    LD cxq|EntryList               (in subsequent exit)\n-    \/\/\n-    \/\/ Entering threads in the slow\/contended path execute:\n-    \/\/    ST cxq=nonnull; MEMBAR; LD Responsible (in enter prolog)\n-    \/\/    The (ST cxq; MEMBAR) is accomplished with CAS().\n-    \/\/\n-    \/\/ The MEMBAR, above, prevents the LD of cxq|EntryList in the subsequent\n-    \/\/ exit operation from floating above the ST Responsible=null.\n+  if (_succ == current) {\n+    _succ = nullptr;\n+    \/\/ Note that we don't need to do OrderAccess::fence() after clearing\n+    \/\/ _succ here, since we own the lock.\n@@ -986,1 +922,1 @@\n-  \/\/ EntryList, cxq or Responsible.  These meta-data updates must be\n+  \/\/ EntryList or cxq.  These meta-data updates must be\n@@ -993,1 +929,1 @@\n-  \/\/ To that end, the 1-0 exit() operation must have at least STST|LDST\n+  \/\/ To that end, the exit() operation must have at least STST|LDST\n@@ -1003,2 +939,1 @@\n-  \/\/ monitorexit.  Recall too, that in 1-0 mode monitorexit does not necessarily\n-  \/\/ execute a serializing instruction.\n+  \/\/ monitorexit.\n@@ -1177,14 +1112,19 @@\n-\/\/ 1-0 exit\n-\/\/ ~~~~~~~~\n-\/\/ ::exit() uses a canonical 1-1 idiom with a MEMBAR although some of\n-\/\/ the fast-path operators have been optimized so the common ::exit()\n-\/\/ operation is 1-0, e.g., see macroAssembler_x86.cpp: fast_unlock().\n-\/\/ The code emitted by fast_unlock() elides the usual MEMBAR.  This\n-\/\/ greatly improves latency -- MEMBAR and CAS having considerable local\n-\/\/ latency on modern processors -- but at the cost of \"stranding\".  Absent the\n-\/\/ MEMBAR, a thread in fast_unlock() can race a thread in the slow\n-\/\/ ::enter() path, resulting in the entering thread being stranding\n-\/\/ and a progress-liveness failure.   Stranding is extremely rare.\n-\/\/ We use timers (timed park operations) & periodic polling to detect\n-\/\/ and recover from stranding.  Potentially stranded threads periodically\n-\/\/ wake up and poll the lock.  See the usage of the _Responsible variable.\n+\/\/ This is the exit part of the locking protocol, often implemented in\n+\/\/ C2_MacroAssembler::fast_unlock()\n+\/\/\n+\/\/   1. A release barrier ensures that changes to monitor meta-data\n+\/\/      (_succ, _EntryList, _cxq) and data protected by the lock will be\n+\/\/      visible before we release the lock.\n+\/\/   2. Release the lock by clearing the owner.\n+\/\/   3. A storeload MEMBAR is needed between releasing the owner and\n+\/\/      subsequently reading meta-data to safely determine if the lock is\n+\/\/      contended (step 4) without an elected successor (step 5).\n+\/\/   4. If both _EntryList and _cxq are null, we are done, since there is no\n+\/\/      other thread waiting on the lock to wake up. I.e. there is no\n+\/\/      contention.\n+\/\/   5. If there is a successor (_succ is non-null), we are done. The\n+\/\/      responsibility for guaranteeing progress-liveness has now implicitly\n+\/\/      been moved from the exiting thread to the successor.\n+\/\/   6. There are waiters in the entry list (_EntryList and\/or cxq are\n+\/\/      non-null), but there is no successor (_succ is null), so we need to\n+\/\/      wake up (unpark) a waiting thread to avoid stranding.\n@@ -1192,4 +1132,3 @@\n-\/\/ The CAS() in enter provides for safety and exclusion, while the CAS or\n-\/\/ MEMBAR in exit provides for progress and avoids stranding.  1-0 locking\n-\/\/ eliminates the CAS\/MEMBAR from the exit path, but it admits stranding.\n-\/\/ We detect and recover from stranding with timers.\n+\/\/ Note that since only the current lock owner can manipulate the _EntryList\n+\/\/ or drain _cxq, we need to reacquire the lock before we can wake up\n+\/\/ (unpark) a waiting thread.\n@@ -1197,13 +1136,2 @@\n-\/\/ If a thread transiently strands it'll park until (a) another\n-\/\/ thread acquires the lock and then drops the lock, at which time the\n-\/\/ exiting thread will notice and unpark the stranded thread, or, (b)\n-\/\/ the timer expires.  If the lock is high traffic then the stranding latency\n-\/\/ will be low due to (a).  If the lock is low traffic then the odds of\n-\/\/ stranding are lower, although the worst-case stranding latency\n-\/\/ is longer.  Critically, we don't want to put excessive load in the\n-\/\/ platform's timer subsystem.  We want to minimize both the timer injection\n-\/\/ rate (timers created\/sec) as well as the number of timers active at\n-\/\/ any one time.  (more precisely, we want to minimize timer-seconds, which is\n-\/\/ the integral of the # of active timers at any instant over time).\n-\/\/ Both impinge on OS scalability.  Given that, at most one thread parked on\n-\/\/ a monitor will use a timer.\n+\/\/ The CAS() in enter provides for safety and exclusion, while the\n+\/\/ MEMBAR in exit provides for progress and avoids stranding.\n@@ -1251,4 +1179,0 @@\n-  \/\/ Invariant: after setting Responsible=null an thread must execute\n-  \/\/ a MEMBAR or other serializing instruction before fetching EntryList|cxq.\n-  _Responsible = nullptr;\n-\n@@ -1281,8 +1205,9 @@\n-    \/\/ but if other successors are ready or other entering threads are spinning\n-    \/\/ then this thread can simply store null into _owner and exit without\n-    \/\/ waking a successor.  The existence of spinners or ready successors\n-    \/\/ guarantees proper succession (liveness).  Responsibility passes to the\n-    \/\/ ready or running successors.  The exiting thread delegates the duty.\n-    \/\/ More precisely, if a successor already exists this thread is absolved\n-    \/\/ of the responsibility of waking (unparking) one.\n-    \/\/\n+    \/\/ but if this thread observes other successors are ready or other\n+    \/\/ entering threads are spinning after it has stored null into _owner\n+    \/\/ then it can exit without waking a successor.  The existence of\n+    \/\/ spinners or ready successors guarantees proper succession (liveness).\n+    \/\/ Responsibility passes to the ready or running successors.  The exiting\n+    \/\/ thread delegates the duty.  More precisely, if a successor already\n+    \/\/ exists this thread is absolved of the responsibility of waking\n+    \/\/ (unparking) one.\n+\n@@ -1299,10 +1224,4 @@\n-    \/\/ Another less appealing alternative would be for the exiting thread\n-    \/\/ to drop the lock and then spin briefly to see if a spinner managed\n-    \/\/ to acquire the lock.  If so, the exiting thread could exit\n-    \/\/ immediately without waking a successor, otherwise the exiting\n-    \/\/ thread would need to dequeue and wake a successor.\n-    \/\/ (Note that we'd need to make the post-drop spin short, but no\n-    \/\/ shorter than the worst-case round-trip cache-line migration time.\n-    \/\/ The dropped lock needs to become visible to the spinner, and then\n-    \/\/ the acquisition of the lock by the spinner must become visible to\n-    \/\/ the exiting thread).\n+    \/\/ Which means that the exiting thread could exit immediately without\n+    \/\/ waking a successor, if it observes a successor after it has dropped\n+    \/\/ the lock.  Note that the dropped lock needs to become visible to the\n+    \/\/ spinner.\n@@ -1315,2 +1234,4 @@\n-    \/\/\n-    if (try_set_owner_from(nullptr, current) != nullptr) {\n+\n+    if (TryLock(current) != TryLockResult::Success) {\n+      \/\/ Some other thread acquired the lock (or the monitor was\n+      \/\/ deflated). Either way we are done.\n@@ -1379,1 +1300,1 @@\n-    \/\/ In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = nullptr\n+    \/\/ We need to: ST EntryList; MEMBAR #storestore; ST _owner = nullptr\n@@ -1569,2 +1490,0 @@\n-  _Responsible = nullptr;\n-\n@@ -2248,1 +2167,0 @@\n-\/\/   _Responsible = 0x0000000000000000\n@@ -2277,1 +2195,0 @@\n-  st->print_cr(\"  _Responsible = \" INTPTR_FORMAT, p2i(_Responsible));\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":126,"deletions":209,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -182,1 +182,0 @@\n-  JavaThread* volatile _Responsible;\n@@ -351,1 +350,1 @@\n-  bool      try_enter(JavaThread* current);\n+  bool      try_enter(JavaThread* current, bool check_for_recursion = true);\n@@ -380,0 +379,1 @@\n+  bool           TryLockWithContentionMark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark);\n@@ -398,0 +398,1 @@\n+  bool _extended;\n@@ -404,0 +405,4 @@\n+\n+  \/\/ Extends the contention scope beyond this objects lifetime.\n+  \/\/ Requires manual decrement of the contentions counter.\n+  void extend();\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -209,0 +209,1 @@\n+\/\/ Block out deflation.\n@@ -210,1 +211,6 @@\n-  : _monitor(monitor) {\n+  : _monitor(monitor), _extended(false) {\n+  \/\/ Contentions is incremented to a positive value as part of the\n+  \/\/ contended enter protocol, which prevents the deflater thread from\n+  \/\/ winning the last part of the 2-part async deflation\n+  \/\/ protocol. See: ObjectMonitor::deflate_monitor() and\n+  \/\/ ObjectMonitor::TryLockWithContentionMark().\n@@ -215,0 +221,3 @@\n+  \/\/ Decrement contentions when the contention mark goes out of\n+  \/\/ scope. This opens up for deflation, if the contention mark\n+  \/\/ hasn't been extended.\n@@ -218,0 +227,8 @@\n+inline void ObjectMonitorContentionMark::extend() {\n+  \/\/ Used by ObjectMonitor::TryLockWithContentionMark() to \"extend the\n+  \/\/ lifetime\" of the contention mark.\n+  assert(!_extended, \"extending twice is probably a bad design\");\n+  _monitor->add_to_contentions(1);\n+  _extended = true;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -769,4 +769,4 @@\n-  \/\/ Allow sun.reflect.ConstantPool to refer to <clinit> methods as java.lang.reflect.Methods.\n-  assert(!method()->is_initializer() ||\n-         (for_constant_pool_access && method()->is_static()),\n-         \"should call new_constructor instead\");\n+  \/\/ Allow jdk.internal.reflect.ConstantPool to refer to <clinit> methods as java.lang.reflect.Methods.\n+  assert(!method()->is_object_initializer() &&\n+         (for_constant_pool_access || !method()->is_static_initializer()),\n+         \"Should not be the initializer\");\n@@ -820,1 +820,1 @@\n-  assert(method()->is_initializer(), \"should call new_method instead\");\n+  assert(method()->is_object_initializer(), \"Should be the initializer\");\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-  if (EnableJVMCI && UseJVMCICompiler) {\n+  if (EnableJVMCI) {\n@@ -1966,0 +1966,20 @@\n+\n+  \/\/ Check if C2_MacroAssembler::fast_unlock() or\n+  \/\/ C2_MacroAssembler::fast_unlock_lightweight() unlocked an inflated\n+  \/\/ monitor before going slow path.  Since there is no safepoint\n+  \/\/ polling when calling into the VM, we can be sure that the monitor\n+  \/\/ hasn't been deallocated.\n+  ObjectMonitor* m = current->unlocked_inflated_monitor();\n+  if (m != nullptr) {\n+    assert(m->owner_raw() != current, \"must be\");\n+    current->clear_unlocked_inflated_monitor();\n+\n+    \/\/ We need to reacquire the lock before we can call ObjectSynchronizer::exit().\n+    if (!m->try_enter(current, \/*check_for_recursion*\/ false)) {\n+      \/\/ Some other thread acquired the lock (or the monitor was\n+      \/\/ deflated). Either way we are done.\n+      current->dec_held_monitor_count();\n+      return;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-  DEBUG_ONLY(_missed_ic_stub_refill_verifier = nullptr);\n@@ -148,0 +147,10 @@\n+#ifdef ASSERT\n+address Thread::stack_base() const {\n+  \/\/ Note: can't report Thread::name() here as that can require a ResourceMark which we\n+  \/\/ can't use because this gets called too early in the thread initialization.\n+  assert(_stack_base != nullptr, \"Stack base not yet set for thread id:%d (0 if not set)\",\n+         osthread() != nullptr ? osthread()->thread_id() : 0);\n+  return _stack_base;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-class ICRefillVerifier;\n@@ -245,14 +244,0 @@\n- private:\n-\n-#ifdef ASSERT\n-  ICRefillVerifier* _missed_ic_stub_refill_verifier;\n-\n- public:\n-  ICRefillVerifier* missed_ic_stub_refill_verifier() {\n-    return _missed_ic_stub_refill_verifier;\n-  }\n-\n-  void set_missed_ic_stub_refill_verifier(ICRefillVerifier* verifier) {\n-    _missed_ic_stub_refill_verifier = verifier;\n-  }\n-#endif \/\/ ASSERT\n@@ -535,1 +520,1 @@\n-  address stack_base() const           { assert(_stack_base != nullptr,\"Sanity check\"); return _stack_base; }\n+  address stack_base() const DEBUG_ONLY(;) NOT_DEBUG({ return _stack_base; })\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-  template(ICBufferFull)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,6 +63,0 @@\n-\/\/ empty vm op, when forcing a safepoint due to inline cache buffers being full\n-class VM_ICBufferFull: public VM_EmptyOperation {\n- public:\n-  VMOp_Type type() const { return VMOp_ICBufferFull; }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1515,0 +1515,32 @@\n+\/\/ Support class used to generate HPROF_LOAD_CLASS records\n+\n+class LoadedClassDumper : public LockedClassesDo {\n+ private:\n+  AbstractDumpWriter* _writer;\n+  GrowableArray<Klass*>* _klass_map;\n+  u4 _class_serial_num;\n+  AbstractDumpWriter* writer() const { return _writer; }\n+  void add_class_serial_number(Klass* k, int serial_num) {\n+    _klass_map->at_put_grow(serial_num, k);\n+  }\n+ public:\n+  LoadedClassDumper(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map)\n+    : _writer(writer), _klass_map(klass_map), _class_serial_num(0) {}\n+\n+  void do_klass(Klass* k) {\n+    \/\/ len of HPROF_LOAD_CLASS record\n+    u4 remaining = 2 * oopSize + 2 * sizeof(u4);\n+    DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);\n+    \/\/ class serial number is just a number\n+    writer()->write_u4(++_class_serial_num);\n+    \/\/ class ID\n+    writer()->write_classID(k);\n+    \/\/ add the Klass* and class serial number pair\n+    add_class_serial_number(k, _class_serial_num);\n+    writer()->write_u4(STACK_TRACE_ID);\n+    \/\/ class name ID\n+    Symbol* name = k->name();\n+    writer()->write_symbolID(name);\n+  }\n+};\n+\n@@ -2193,3 +2225,1 @@\n-  static VM_HeapDumper*   _global_dumper;\n-  static DumpWriter*      _global_writer;\n-  DumpWriter*             _local_writer;\n+  DumpWriter*             _writer;\n@@ -2221,14 +2251,1 @@\n-  \/\/ accessors and setters\n-  static VM_HeapDumper* dumper()         {  assert(_global_dumper != nullptr, \"Error\"); return _global_dumper; }\n-  static DumpWriter* writer()            {  assert(_global_writer != nullptr, \"Error\"); return _global_writer; }\n-\n-  void set_global_dumper() {\n-    assert(_global_dumper == nullptr, \"Error\");\n-    _global_dumper = this;\n-  }\n-  void set_global_writer() {\n-    assert(_global_writer == nullptr, \"Error\");\n-    _global_writer = _local_writer;\n-  }\n-  void clear_global_dumper() { _global_dumper = nullptr; }\n-  void clear_global_writer() { _global_writer = nullptr; }\n+  DumpWriter* writer() const { return _writer; }\n@@ -2238,3 +2255,0 @@\n-  \/\/ writes a HPROF_LOAD_CLASS record to global writer\n-  static void do_load_class(Klass* k);\n-\n@@ -2244,4 +2258,0 @@\n-  void add_class_serial_number(Klass* k, int serial_num) {\n-    _klass_map->at_put_grow(serial_num, k);\n-  }\n-\n@@ -2262,1 +2272,1 @@\n-    _local_writer = writer;\n+    _writer = writer;\n@@ -2316,3 +2326,0 @@\n-VM_HeapDumper* VM_HeapDumper::_global_dumper = nullptr;\n-DumpWriter*    VM_HeapDumper::_global_writer = nullptr;\n-\n@@ -2332,25 +2339,0 @@\n-\/\/ writes a HPROF_LOAD_CLASS record for the class\n-void VM_HeapDumper::do_load_class(Klass* k) {\n-  static u4 class_serial_num = 0;\n-\n-  \/\/ len of HPROF_LOAD_CLASS record\n-  u4 remaining = 2*oopSize + 2*sizeof(u4);\n-\n-  DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);\n-\n-  \/\/ class serial number is just a number\n-  writer()->write_u4(++class_serial_num);\n-\n-  \/\/ class ID\n-  writer()->write_classID(k);\n-\n-  \/\/ add the Klass* and class serial number pair\n-  dumper()->add_class_serial_number(k, class_serial_num);\n-\n-  writer()->write_u4(STACK_TRACE_ID);\n-\n-  \/\/ class name ID\n-  Symbol* name = k->name();\n-  writer()->write_symbolID(name);\n-}\n-\n@@ -2433,5 +2415,0 @@\n-  \/\/ At this point we should be the only dumper active, so\n-  \/\/ the following should be safe.\n-  set_global_dumper();\n-  set_global_writer();\n-\n@@ -2449,4 +2426,0 @@\n-\n-  \/\/ Now we clear the global variables, so that a future dumper can run.\n-  clear_global_dumper();\n-  clear_global_writer();\n@@ -2483,2 +2456,2 @@\n-      LockedClassesDo locked_load_classes(&do_load_class);\n-      ClassLoaderDataGraph::classes_do(&locked_load_classes);\n+      LoadedClassDumper loaded_class_dumper(writer(), _klass_map);\n+      ClassLoaderDataGraph::classes_do(&loaded_class_dumper);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":37,"deletions":64,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -341,0 +341,1 @@\n+#define PRODUCT_RETURN_NULL { return nullptr; }\n@@ -348,0 +349,1 @@\n+#define PRODUCT_RETURN_NULL \/* next token must be ;*\/\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -300,0 +300,1 @@\n+    int rc;\n@@ -312,2 +313,3 @@\n-    if (pthread_create(&main_thr, NULL, &apple_main, &args) != 0) {\n-        JLI_ReportErrorMessageSys(\"Could not create main thread: %s\\n\", strerror(errno));\n+    rc = pthread_create(&main_thr, NULL, &apple_main, &args);\n+    if (rc != 0) {\n+        JLI_ReportErrorMessageSys(\"Could not create main thread, return code: %d\\n\", rc);\n@@ -316,2 +318,3 @@\n-    if (pthread_detach(main_thr)) {\n-        JLI_ReportErrorMessageSys(\"pthread_detach() failed: %s\\n\", strerror(errno));\n+    rc = pthread_detach(main_thr);\n+    if (rc != 0) {\n+        JLI_ReportErrorMessage(\"pthread_detach() failed, return code: %d\\n\", rc);\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    private static final int PARALLEL_LEN = 7680;\n+    private static final int PARALLEL_LEN = 512;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,5 @@\n+ * @apiNote\n+ * Once wrapped in a {@code BufferedInputStream}, the underlying\n+ * {@code InputStream} should not be used directly nor wrapped with\n+ * another stream.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,5 @@\n+ * @apiNote\n+ * Once wrapped in a {@code BufferedOutputStream}, the underlying\n+ * {@code OutputStream} should not be used directly nor wrapped with\n+ * another stream.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedOutputStream.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,3 @@\n- * therefore advisable to wrap a BufferedReader around any Reader whose read()\n- * operations may be costly, such as FileReaders and InputStreamReaders.  For\n+ * therefore advisable to wrap a {@code BufferedReader} around any\n+ * {@code Reader} whose {@code read()} operations may be costly, such as\n+ * {@code FileReader}s and {@code InputStreamReader}s.  For\n@@ -55,3 +56,3 @@\n- * invocation of read() or readLine() could cause bytes to be read from the\n- * file, converted into characters, and then returned, which can be very\n- * inefficient.\n+ * invocation of {@code read()} or {@code readLine()} could cause bytes to be\n+ * read from the file, converted into characters, and then returned, which can\n+ * be very inefficient.\n@@ -59,2 +60,8 @@\n- * <p> Programs that use DataInputStreams for textual input can be localized by\n- * replacing each DataInputStream with an appropriate BufferedReader.\n+ * <p> Programs that use {@code DataInputStream}s for textual input can be\n+ * localized by replacing each {@code DataInputStream} with an appropriate\n+ * {@code BufferedReader}.\n+ *\n+ * @apiNote\n+ * Once wrapped in a {@code BufferedReader}, the underlying\n+ * {@code Reader} should not be used directly nor wrapped with\n+ * another reader.\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedReader.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,5 +40,5 @@\n- * <p> A newLine() method is provided, which uses the platform's own notion of\n- * line separator as defined by the system property {@code line.separator}.\n- * Not all platforms use the newline character ('\\n') to terminate lines.\n- * Calling this method to terminate each output line is therefore preferred to\n- * writing a newline character directly.\n+ * <p> A {@code newLine()} method is provided, which uses the platform's own\n+ * notion of line separator as defined by the system property\n+ * {@linkplain System#lineSeparator() line.separator}. Not all platforms use the newline character ('\\n')\n+ * to terminate lines. Calling this method to terminate each output line is\n+ * therefore preferred to writing a newline character directly.\n@@ -46,4 +46,5 @@\n- * <p> In general, a Writer sends its output immediately to the underlying\n- * character or byte stream.  Unless prompt output is required, it is advisable\n- * to wrap a BufferedWriter around any Writer whose write() operations may be\n- * costly, such as FileWriters and OutputStreamWriters.  For example,\n+ * <p> In general, a {@code Writer} sends its output immediately to the\n+ * underlying character or byte stream.  Unless prompt output is required, it\n+ * is advisable to wrap a {@code BufferedWriter} around any {@code Writer} whose\n+ * {@code write()} operations may be costly, such as {@code FileWriter}s and\n+ * {@code OutputStreamWriter}s.  For example,\n@@ -55,4 +56,9 @@\n- * will buffer the PrintWriter's output to the file.  Without buffering, each\n- * invocation of a print() method would cause characters to be converted into\n- * bytes that would then be written immediately to the file, which can be very\n- * inefficient.\n+ * will buffer the {@code PrintWriter}'s output to the file.  Without buffering,\n+ * each invocation of a {@code print()} method would cause characters to be\n+ * converted into bytes that would then be written immediately to the file,\n+ * which can be very inefficient.\n+ *\n+ * @apiNote\n+ * Once wrapped in a {@code BufferedWriter}, the underlying\n+ * {@code Writer} should not be used directly nor wrapped with\n+ * another writer.\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedWriter.java","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.ArraysSupport;\n+\n@@ -308,4 +310,1 @@\n-     * The maximum size of array to allocate.\n-     * Some VMs reserve some header words in an array.\n-     * Attempts to allocate larger arrays may result in\n-     * OutOfMemoryError: Requested array size exceeds VM limit\n+     * The maximum size of array to allocate\n@@ -313,1 +312,1 @@\n-    private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n+    private static final int MAX_BUFFER_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStream.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,4 +40,4 @@\n- * The Boolean class wraps a value of the primitive type\n- * {@code boolean} in an object. An object of type\n- * {@code Boolean} contains a single field whose type is\n- * {@code boolean}.\n+ * The {@code Boolean} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code boolean}. An object of type {@code Boolean} contains a\n+ * single field whose type is {@code boolean}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Boolean.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,4 +42,4 @@\n- *\n- * The {@code Byte} class wraps a value of primitive type {@code byte}\n- * in an object.  An object of type {@code Byte} contains a single\n- * field whose type is {@code byte}.\n+ * The {@code Byte} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code byte}. An object of type {@code Byte} contains a\n+ * single field whose type is {@code byte}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,6 +46,6 @@\n- * The {@code Character} class wraps a value of the primitive\n- * type {@code char} in an object. An object of class\n- * {@code Character} contains a single field whose type is\n- * {@code char}.\n- * <p>\n- * In addition, this class provides a large number of static methods for\n+ * The {@code Character} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code char}. An object of type {@code Character} contains a\n+ * single field whose type is {@code char}.\n+ *\n+ * <p>In addition, this class provides a large number of static methods for\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -143,1 +143,2 @@\n- * class or interface (or for {@code void}) using a <i>class literal<\/i>.\n+ * class or interface (or for {@code void}) using a <dfn>class literal<\/dfn>\n+ * (JLS {@jls 15.8.2}).\n@@ -147,1 +148,1 @@\n- * System.out.println(\"The name of class Foo is: \"+Foo.class.getName());\n+ * System.out.println(\"The name of class Foo is: \" + Foo.class.getName()); \/\/ @highlight substring=\"Foo.class\"\n@@ -153,1 +154,1 @@\n- * is situated in a <em>nest<\/em>. A <a id=\"nest\">nest<\/a> is a set of\n+ * is situated in a <dfn>{@index \"nest\"}<\/dfn>. A <a id=\"nest\">nest<\/a> is a set of\n@@ -156,1 +157,2 @@\n- * The classes and interfaces are known as <em>nestmates<\/em>.\n+ * The classes and interfaces are known as <dfn>{@index \"nestmates\"}<\/dfn>\n+ * (JVMS {@jvms 4.7.29}).\n@@ -158,1 +160,1 @@\n- * <em>nest host<\/em>, and enumerates the other nestmates which\n+ * <dfn>nest host<\/dfn> (JVMS {@jvms 4.7.28}), and enumerates the other nestmates which\n@@ -170,1 +172,1 @@\n- * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() <em>hidden<\/em>}\n+ * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() <dfn>hidden<\/dfn>}\n@@ -219,1 +221,0 @@\n- * @jls 15.8.2 Class Literals\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,4 +39,4 @@\n- * The {@code Double} class wraps a value of the primitive type\n- * {@code double} in an object. An object of type\n- * {@code Double} contains a single field whose type is\n- * {@code double}.\n+ * The {@code Double} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code double}. An object of type {@code Double} contains a\n+ * single field whose type is {@code double}.\n@@ -151,1 +151,1 @@\n- * <dt><a id=fpNumericalEq><i>numerical equality<\/i><\/a> ({@code ==}\n+ * <dt><a id=fpNumericalEq><\/a><dfn>{@index \"numerical equality\"}<\/dfn> ({@code ==}\n@@ -161,1 +161,1 @@\n- * <dt><i>bit-wise equivalence<\/i>:<\/dt>\n+ * <dt><dfn>{@index \"bit-wise equivalence\"}<\/dfn>:<\/dt>\n@@ -171,1 +171,1 @@\n- * <dt><i><a id=repEquivalence>representation equivalence<\/a><\/i>:<\/dt>\n+ * <dt><dfn><a id=repEquivalence><\/a>{@index \"representation equivalence\"}<\/dfn>:<\/dt>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,4 +39,4 @@\n- * The {@code Float} class wraps a value of primitive type\n- * {@code float} in an object. An object of type\n- * {@code Float} contains a single field whose type is\n- * {@code float}.\n+ * The {@code Float} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code float}. An object of type {@code Float} contains a\n+ * single field whose type is {@code float}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,4 @@\n- * The {@code Integer} class wraps a value of the primitive type\n- * {@code int} in an object. An object of type {@code Integer}\n- * contains a single field whose type is {@code int}.\n+ * The {@code Integer} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code int}. An object of type {@code Integer} contains a\n+ * single field whose type is {@code int}.\n@@ -66,2 +67,3 @@\n- * based on material from Henry S. Warren, Jr.'s <i>Hacker's\n- * Delight<\/i>, (Addison Wesley, 2002).\n+ * based on material from Henry S. Warren, Jr.'s <cite>Hacker's\n+ * Delight<\/cite>, (Addison Wesley, 2002) and <cite>Hacker's\n+ * Delight, Second Edition<\/cite>, (Pearson Education, 2013).\n@@ -1739,1 +1741,1 @@\n-     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, Second Edition, section 7.7)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,3 @@\n- * The {@code Long} class wraps a value of the primitive type {@code\n- * long} in an object. An object of type {@code Long} contains a\n+ * The {@code Long} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code long}. An object of type {@code Long} contains a\n@@ -66,2 +67,3 @@\n- * based on material from Henry S. Warren, Jr.'s <i>Hacker's\n- * Delight<\/i>, (Addison Wesley, 2002).\n+ * based on material from Henry S. Warren, Jr.'s <cite>Hacker's\n+ * Delight<\/cite>, (Addison Wesley, 2002) and <cite>Hacker's\n+ * Delight, Second Edition<\/cite>, (Pearson Education, 2013).\n@@ -1752,1 +1754,1 @@\n-     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, Second Edition, section 7.7)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-     * The {@code equals} method implements an equivalence relation\n+     * The {@code equals} method implements an <dfn>{@index \"equivalence relation\"}<\/dfn>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,3 @@\n- * The {@code Short} class wraps a value of primitive type {@code\n- * short} in an object.  An object of type {@code Short} contains a\n+ * The {@code Short} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code short}. An object of type {@code Short} contains a\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -432,0 +432,2 @@\n+     * @throws IllegalArgumentException if {@code tk} is {@link TypeKind#VOID void}\n+     *         or {@code slot} is out of range\n@@ -443,0 +445,2 @@\n+     * @throws IllegalArgumentException if {@code tk} is {@link TypeKind#VOID void}\n+     *         or {@code slot} is out of range\n@@ -796,0 +800,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -809,0 +814,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -825,0 +831,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -838,0 +845,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -880,0 +888,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -928,0 +937,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -961,0 +971,1 @@\n+     * @throws IllegalArgumentException if {@code b} is out of range of byte\n@@ -1097,0 +1108,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -1142,0 +1154,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -1309,0 +1322,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -1354,0 +1368,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -1729,0 +1744,1 @@\n+     * @throws IllegalArgumentException if {@code slot} or {@code val} is out of range\n@@ -1742,0 +1758,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -2000,0 +2017,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -2162,0 +2180,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -2231,0 +2250,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -2281,0 +2301,1 @@\n+     * @throws IllegalArgumentException if {@code dims} is out of range\n@@ -2292,0 +2313,1 @@\n+     * or if {@code dims} is out of range\n@@ -2330,0 +2352,2 @@\n+     * @throws IllegalArgumentException when the {@code typeKind} is not a legal\n+     *         primitive array component type\n@@ -2426,0 +2450,1 @@\n+     * @throws IllegalArgumentException if {@code s} is out of range of short\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n@@ -115,1 +116,1 @@\n-         *         {@link Opcode.Kind#DISCONTINUED_RET}.\n+         *         {@link Opcode.Kind#DISCONTINUED_RET} or if {@code slot} is out of range\n@@ -118,1 +119,1 @@\n-            Util.checkKind(op, Opcode.Kind.DISCONTINUED_RET);\n+            BytecodeHelpers.validateRet(op, slot);\n@@ -126,0 +127,1 @@\n+         * @throws IllegalArgumentException if {@code slot} is out of range\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+     * @throws IllegalArgumentException if {@code slot} or {@code constant} is out of range\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/IncrementInstruction.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+     * @throws IllegalArgumentException if {@code kind} is\n+     *         {@link TypeKind#VOID void} or {@code slot} is out of range\n@@ -67,1 +69,2 @@\n-        return of(BytecodeHelpers.loadOpcode(kind, slot), slot);\n+        var opcode = BytecodeHelpers.loadOpcode(kind, slot); \/\/ validates slot, trusted\n+        return new AbstractInstruction.UnboundLoadInstruction(opcode, slot);\n@@ -77,1 +80,1 @@\n-     *         {@link Opcode.Kind#LOAD}.\n+     *         {@link Opcode.Kind#LOAD} or {@code slot} is out of range\n@@ -81,0 +84,1 @@\n+        BytecodeHelpers.validateSlot(op, slot, true);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LoadInstruction.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -109,0 +110,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariable.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -106,0 +107,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariableType.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n@@ -61,0 +62,1 @@\n+     * @throws IllegalArgumentException if {@code dimensions} is out of range\n@@ -64,0 +66,1 @@\n+        BytecodeHelpers.validateMultiArrayDimensions(dimensions);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewMultiArrayInstruction.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+     * @throws IllegalArgumentException if {@code kind} is {@link\n+     *         TypeKind#VOID void} or {@code slot} is out of range\n@@ -66,1 +68,2 @@\n-        return of(BytecodeHelpers.storeOpcode(kind, slot), slot);\n+        var opcode = BytecodeHelpers.storeOpcode(kind, slot); \/\/ validates slot\n+        return new AbstractInstruction.UnboundStoreInstruction(opcode, slot);\n@@ -76,1 +79,1 @@\n-     *         {@link Opcode.Kind#STORE}.\n+     *         {@link Opcode.Kind#STORE} or {@code slot} is out of range\n@@ -80,0 +83,1 @@\n+        BytecodeHelpers.validateSlot(op, slot, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/StoreInstruction.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1529,1 +1529,1 @@\n-                        cb.ldc(length);\n+                        cb.loadConstant(length);\n@@ -1552,1 +1552,1 @@\n-                        cb.ldc(constants[paramCount].length())\n+                        cb.loadConstant(constants[paramCount].length())\n@@ -1560,1 +1560,1 @@\n-                          .ldc(paramCount)\n+                          .loadConstant(paramCount)\n@@ -1575,1 +1575,1 @@\n-                        cb.ldc(constants[paramCount]);\n+                        cb.loadConstant(constants[paramCount]);\n@@ -1762,1 +1762,1 @@\n-                            cb.ldc(constants[i - 3]);\n+                            cb.loadConstant(constants[i - 3]);\n@@ -1765,1 +1765,1 @@\n-                              .ldc(i - 4)\n+                              .loadConstant(i - 4)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * programming language. The most important classes are {@code\n- * Object}, which is the root of the class hierarchy, and {@code\n+ * programming language. The most important classes are {@link\n+ * Object}, which is the root of the class hierarchy, and {@link\n@@ -33,10 +33,15 @@\n- * type as if it were an object. The wrapper classes {@code Boolean},\n- * {@code Character}, {@code Integer}, {@code Long}, {@code Float},\n- * and {@code Double} serve this purpose.  An object of type {@code\n- * Double}, for example, contains a field whose type is double,\n- * representing that value in such a way that a reference to it can be\n- * stored in a variable of reference type.  These classes also provide\n- * a number of methods for converting among primitive values, as well\n- * as supporting such standard methods as equals and hashCode.  The\n- * {@code Void} class is a non-instantiable class that holds a\n- * reference to a {@code Class} object representing the type void.\n+ * type as if it were an object.The <dfn id=wrapperClasses>{@index\n+ * \"wrapper classes\"}<\/dfn> {@link Boolean}, {@link Byte}, {@link\n+ * Character}, {@link Short}, {@link Integer}, {@link Long}, {@link\n+ * Float}, and {@link Double} serve this purpose.  An object of type\n+ * {@code Double}, for example, contains a field whose type is {@code\n+ * double}, representing that value in such a way that a reference to\n+ * it can be stored in a variable of reference type. As discussed in\n+ * <cite>The Java Language Specification<\/cite>, the wrapper classes\n+ * are involved in boxing (JLS {@jls 5.1.7}) and unboxing (JLS {@jls\n+ * 5.1.8}) conversions. These classes provide a number of methods for\n+ * converting among primitive values, as well as methods supporting\n+ * such standard functionality as {@code equals} and {@code hashCode}.\n+ * The {@link Void} class is a non-instantiable class that holds a\n+ * reference to a {@code Class} object representing the type {@code\n+ * void}.\n@@ -44,4 +49,6 @@\n- * <p>The class {@code Math} provides commonly used mathematical\n- * functions such as sine, cosine, and square root. The classes {@code\n- * String}, {@code StringBuffer}, and {@code StringBuilder} similarly\n- * provide commonly used operations on character strings.\n+ * <p>The class {@link Math} provides commonly used mathematical\n+ * functions such as {@linkplain Math#sin(double) sine}, {@linkplain\n+ * Math#cos(double) cosine}, and {@linkplain Math#sqrt(double) square\n+ * root}. The classes {@link String}, {@link StringBuffer}, and {@link\n+ * StringBuilder} similarly provide commonly used operations on\n+ * character strings.\n@@ -49,3 +56,3 @@\n- * <p>Classes {@code ClassLoader}, {@code Process}, {@code\n- * ProcessBuilder}, {@code Runtime}, {@code SecurityManager}, and\n- * {@code System} provide \"system operations\" that manage the dynamic\n+ * <p>Classes {@link ClassLoader}, {@link Process}, {@link\n+ * ProcessBuilder}, {@link Runtime}, {@link SecurityManager}, and\n+ * {@link System} provide \"system operations\" that manage the dynamic\n@@ -56,1 +63,1 @@\n- * <p>Class {@code Throwable} encompasses objects that may be thrown\n+ * <p>Class {@link Throwable} encompasses objects that may be thrown\n","filename":"src\/java.base\/share\/classes\/java\/lang\/package-info.java","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -662,1 +662,1 @@\n-                    cb.ldc(integerLabel);\n+                    cb.loadConstant(integerLabel);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -600,0 +600,1 @@\n+\n@@ -601,2 +602,2 @@\n-        int nBits = n&0x1F;\n-        int bitsInHighWord = BigInteger.bitLengthForInt(value[offset]);\n+        int nBits = n & 0x1F;\n+        int leadingZeros = Integer.numberOfLeadingZeros(value[offset]);\n@@ -605,1 +606,1 @@\n-        if (n <= (32-bitsInHighWord)) {\n+        if (n <= leadingZeros) {\n@@ -610,13 +611,9 @@\n-        int newLen = intLen + nInts +1;\n-        if (nBits <= (32-bitsInHighWord))\n-            newLen--;\n-        if (value.length < newLen) {\n-            \/\/ The array must grow\n-            int[] result = new int[newLen];\n-            for (int i=0; i < intLen; i++)\n-                result[i] = value[offset+i];\n-            setValue(result, newLen);\n-        } else if (value.length - offset >= newLen) {\n-            \/\/ Use space on right\n-            for(int i=0; i < newLen - intLen; i++)\n-                value[offset+intLen+i] = 0;\n+        int newLen = intLen + nInts;\n+        if (nBits > leadingZeros)\n+            newLen++;\n+\n+        int[] result;\n+        final int newOffset;\n+        if (value.length < newLen) { \/\/ The array must grow\n+            result = new int[newLen];\n+            newOffset = 0;\n@@ -624,6 +621,2 @@\n-            \/\/ Must use space on left\n-            for (int i=0; i < intLen; i++)\n-                value[i] = value[offset+i];\n-            for (int i=intLen; i < newLen; i++)\n-                value[i] = 0;\n-            offset = 0;\n+            result = value;\n+            newOffset = value.length - offset >= newLen ? offset : 0;\n@@ -631,0 +624,20 @@\n+\n+        int trailingZerosPos = newOffset + intLen;\n+        if (nBits != 0) {\n+            \/\/ Do primitive shift directly for speed\n+            if (nBits <= leadingZeros) {\n+                primitiveLeftShift(nBits, result, newOffset); \/\/ newOffset <= offset\n+            } else {\n+                int lastInt = value[offset + intLen - 1];\n+                primitiveRightShift(32 - nBits, result, newOffset); \/\/ newOffset <= offset\n+                result[trailingZerosPos++] = lastInt << nBits;\n+            }\n+        } else if (result != value || newOffset != offset) {\n+            System.arraycopy(value, offset, result, newOffset, intLen);\n+        }\n+\n+        \/\/ Add trailing zeros\n+        if (result == value)\n+            Arrays.fill(result, trailingZerosPos, newOffset + newLen, 0);\n+\n+        value = result;\n@@ -632,6 +645,1 @@\n-        if (nBits == 0)\n-            return;\n-        if (nBits <= (32-bitsInHighWord))\n-            primitiveLeftShift(nBits);\n-        else\n-            primitiveRightShift(32 -nBits);\n+        offset = newOffset;\n@@ -701,1 +709,14 @@\n-    private final void primitiveRightShift(int n) {\n+    private void primitiveRightShift(int n) {\n+        primitiveRightShift(n, value, offset);\n+    }\n+\n+    \/**\n+     * Right shift this MutableBigInteger n bits, where n is\n+     * less than 32, placing the result in the specified array.\n+     * Assumes that intLen > 0, n > 0 for speed.\n+     * The result can be the value array of this MutableBigInteger,\n+     * but for speed the copy is not performed safely, so, in that case\n+     * the caller has to make sure that\n+     * {@code (resFrom <= offset || resFrom >= offset + intLen)}.\n+     *\/\n+    private void primitiveRightShift(int n, int[] result, int resFrom) {\n@@ -704,4 +725,7 @@\n-        for (int i=offset+intLen-1, c=val[i]; i > offset; i--) {\n-            int b = c;\n-            c = val[i-1];\n-            val[i] = (c << n2) | (b >>> n);\n+\n+        int b = val[offset];\n+        result[resFrom] = b >>> n;\n+        for (int i = 1; i < intLen; i++) {\n+            int c = b;\n+            b = val[offset + i];\n+            result[resFrom + i] = (c << n2) | (b >>> n);\n@@ -709,1 +733,0 @@\n-        val[offset] >>>= n;\n@@ -717,1 +740,14 @@\n-    private final void primitiveLeftShift(int n) {\n+    private void primitiveLeftShift(int n) {\n+        primitiveLeftShift(n, value, offset);\n+    }\n+\n+    \/**\n+     * Left shift this MutableBigInteger n bits, where n is\n+     * less than 32, placing the result in the specified array.\n+     * Assumes that intLen > 0, n > 0 for speed.\n+     * The result can be the value array of this MutableBigInteger,\n+     * but for speed the copy is not performed safely, so, in that case\n+     * the caller has to make sure that\n+     * {@code (resFrom <= offset || resFrom >= offset + intLen)}.\n+     *\/\n+    private void primitiveLeftShift(int n, int[] result, int resFrom) {\n@@ -720,4 +756,6 @@\n-        for (int i=offset, c=val[i], m=i+intLen-1; i < m; i++) {\n-            int b = c;\n-            c = val[i+1];\n-            val[i] = (b << n) | (c >>> n2);\n+        final int m = intLen - 1;\n+        int b = val[offset];\n+        for (int i = 0; i < m; i++) {\n+            int c = val[offset + i + 1];\n+            result[resFrom + i] = (b << n) | (c >>> n2);\n+            b = c;\n@@ -725,1 +763,1 @@\n-        val[offset+intLen-1] <<= n;\n+        result[resFrom + m] = b << n;\n@@ -1514,11 +1552,0 @@\n-    private static void copyAndShift(int[] src, int srcFrom, int srcLen, int[] dst, int dstFrom, int shift) {\n-        int n2 = 32 - shift;\n-        int c=src[srcFrom];\n-        for (int i=0; i < srcLen-1; i++) {\n-            int b = c;\n-            c = src[++srcFrom];\n-            dst[dstFrom+i] = (b << shift) | (c >>> n2);\n-        }\n-        dst[dstFrom+srcLen-1] = c << shift;\n-    }\n-\n@@ -1542,1 +1569,1 @@\n-            copyAndShift(div.value,div.offset,dlen,divisor,0,shift);\n+            div.primitiveLeftShift(shift, divisor, 0);\n@@ -1548,1 +1575,1 @@\n-                copyAndShift(value,offset,intLen,remarr,1,shift);\n+                this.primitiveLeftShift(shift, remarr, 1);\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":80,"deletions":53,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -36,11 +36,23 @@\n- * zero-argument constructor and some number of associated charset\n- * implementation classes.  Charset providers may be installed in an instance\n- * of the Java platform as extensions.  Providers may also be made available by\n- * adding them to the application class path or by some other\n- * platform-specific means.  Charset providers are looked up via the current\n- * thread's {@link java.lang.Thread#getContextClassLoader() context class\n- * loader}.\n- *\n- * <p> A charset provider identifies itself with a provider-configuration file\n- * named {@code java.nio.charset.spi.CharsetProvider} in the resource\n- * directory {@code META-INF\/services}.  The file should contain a list of\n+ * zero-argument constructor and some number of associated {@code Charset}\n+ * implementation classes.  Charset providers are deployed on the application\n+ * module path or the application class path. In order to be looked up, charset\n+ * providers must be visible to the {@link ClassLoader#getSystemClassLoader() system\n+ * class loader}. See {@link java.util.ServiceLoader##developing-service-providers\n+ * Deploying Service Providers} for further detail on deploying a charset\n+ * provider as a module or on the class path.\n+ *\n+ * <p> For a charset provider deployed in a module, the <i>provides<\/i>\n+ * directive must be specified in the module declaration. The provides directive\n+ * specifies both the service and the service provider. In this case, the service\n+ * is {@code java.nio.charset.spi.CharsetProvider}.\n+ *\n+ * <p> As an example, a charset provider deployed as a module might specify the\n+ * following directive:\n+ * <pre>{@code\n+ *     provides java.nio.charset.spi.CharsetProvider with com.example.ExternalCharsetProvider;\n+ * }<\/pre>\n+ *\n+ * <p> For a charset provider deployed on the class path, it identifies itself\n+ * with a provider-configuration file named {@code\n+ * java.nio.charset.spi.CharsetProvider} in the resource directory\n+ * {@code META-INF\/services}.  The file should contain a list of\n","filename":"src\/java.base\/share\/classes\/java\/nio\/charset\/spi\/CharsetProvider.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -127,4 +128,1 @@\n-     * The maximum size of array to allocate.\n-     * Some VMs reserve some header words in an array.\n-     * Attempts to allocate larger arrays may result in\n-     * OutOfMemoryError: Requested array size exceeds VM limit\n+     * The maximum size of array to allocate\n@@ -132,1 +130,1 @@\n-    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n+    private static final int MAX_ARRAY_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"src\/java.base\/share\/classes\/java\/util\/ArrayDeque.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1187,1 +1187,1 @@\n-        final int MAX_INITIAL_CAPACITY = Integer.MAX_VALUE - 8;\n+        final int MAX_INITIAL_CAPACITY = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"src\/java.base\/share\/classes\/java\/util\/BitSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -393,4 +394,1 @@\n-     * The maximum size of array to allocate.\n-     * Some VMs reserve some header words in an array.\n-     * Attempts to allocate larger arrays may result in\n-     * OutOfMemoryError: Requested array size exceeds VM limit\n+     * The maximum size of array to allocate\n@@ -398,1 +396,1 @@\n-    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n+    private static final int MAX_ARRAY_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"src\/java.base\/share\/classes\/java\/util\/Hashtable.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -520,1 +521,1 @@\n-    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n+    static final int MAX_ARRAY_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1505,2 +1505,2 @@\n-        lenHint = (lenHint < Integer.MAX_VALUE - 8 - lenHint) ?\n-                (lenHint << 1) : (Integer.MAX_VALUE - 8);\n+        lenHint = (lenHint < ArraysSupport.SOFT_MAX_ARRAY_LENGTH - lenHint) ?\n+                (lenHint << 1) : ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.util.ArraysSupport;\n+\n@@ -60,1 +62,1 @@\n-    static final long MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n+    static final long MAX_ARRAY_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Nodes.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -1181,0 +1182,2 @@\n+        \/\/ CEN size is limited to the maximum array size in the JDK\n+        private static final int MAX_CEN_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n@@ -1188,1 +1191,1 @@\n-        private byte[] cen;                  \/\/ CEN & ENDHDR\n+        private byte[] cen;                  \/\/ CEN\n@@ -1244,1 +1247,1 @@\n-            if (headerSize > 0xFFFF || pos + headerSize > cen.length - ENDHDR) {\n+            if (headerSize > 0xFFFF || pos + headerSize > cen.length) {\n@@ -1297,1 +1300,1 @@\n-            if (extraEndOffset > cen.length - ENDHDR) {\n+            if (extraEndOffset > cen.length) {\n@@ -1735,2 +1738,2 @@\n-                \/\/ read in the CEN and END\n-                if (end.cenlen + ENDHDR >= Integer.MAX_VALUE) {\n+                \/\/ read in the CEN\n+                if (end.cenlen > MAX_CEN_SIZE) {\n@@ -1739,2 +1742,2 @@\n-                cen = this.cen = new byte[(int)(end.cenlen + ENDHDR)];\n-                if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {\n+                cen = this.cen = new byte[(int)end.cenlen];\n+                if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen) {\n@@ -1769,1 +1772,1 @@\n-            int limit = cen.length - ENDHDR;\n+            int limit = cen.length;\n@@ -1832,1 +1835,1 @@\n-            if (pos + ENDHDR != cen.length) {\n+            if (pos != cen.length) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -851,3 +851,3 @@\n-            super(slot <= 255 && constant < 128 && constant > -127\n-                  ? Opcode.IINC\n-                  : Opcode.IINC_W);\n+            super(BytecodeHelpers.validateAndIsWideIinc(slot, constant)\n+                  ? Opcode.IINC_W\n+                  : Opcode.IINC);\n@@ -870,1 +870,1 @@\n-            writer.writeIncrement(slot, constant);\n+            writer.writeIncrement(op == Opcode.IINC_W, slot, constant);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+            BytecodeHelpers.validateSlot(slot);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.Objects;\n@@ -63,0 +64,8 @@\n+    public static IllegalArgumentException slotOutOfBounds(int slot) {\n+        return new IllegalArgumentException(\"Invalid slot index :\".concat(Integer.toString(slot)));\n+    }\n+\n+    public static IllegalArgumentException slotOutOfBounds(Opcode opcode, int slot) {\n+        return new IllegalArgumentException(\"Invalid slot index %d for %s\".formatted(slot, opcode));\n+    }\n+\n@@ -81,1 +90,7 @@\n-            default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.ALOAD;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.ALOAD_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -91,1 +106,7 @@\n-            default -> (slot < 256) ? Opcode.FLOAD : Opcode.FLOAD_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.FLOAD;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.FLOAD_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -101,1 +122,7 @@\n-            default -> (slot < 256) ? Opcode.DLOAD : Opcode.DLOAD_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.DLOAD;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.DLOAD_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -111,1 +138,7 @@\n-            default -> (slot < 256) ? Opcode.LLOAD : Opcode.LLOAD_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.LLOAD;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.LLOAD_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -121,1 +154,7 @@\n-            default -> (slot < 256) ? Opcode.ILOAD : Opcode.ILOAD_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.ILOAD;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.ILOAD_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -143,1 +182,7 @@\n-            default -> (slot < 256) ? Opcode.ASTORE : Opcode.ASTORE_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.ASTORE;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.ASTORE_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -153,1 +198,7 @@\n-            default -> (slot < 256) ? Opcode.FSTORE : Opcode.FSTORE_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.FSTORE;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.FSTORE_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -163,1 +214,7 @@\n-            default -> (slot < 256) ? Opcode.DSTORE : Opcode.DSTORE_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.DSTORE;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.DSTORE_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -173,1 +230,7 @@\n-            default -> (slot < 256) ? Opcode.LSTORE : Opcode.LSTORE_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.LSTORE;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.LSTORE_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -183,1 +246,7 @@\n-            default -> (slot < 256) ? Opcode.ISTORE : Opcode.ISTORE_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.ISTORE;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.ISTORE_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -308,0 +377,42 @@\n+    public static void validateSlot(Opcode opcode, int slot, boolean load) {\n+        int size = opcode.sizeIfFixed();\n+        if (size == 1 && slot == (load ? intrinsicLoadSlot(opcode) : intrinsicStoreSlot(opcode)) ||\n+                size == 2 && slot == (slot & 0xFF) ||\n+                size == 4 && slot == (slot & 0xFFFF))\n+            return;\n+        throw slotOutOfBounds(opcode, slot);\n+    }\n+\n+    public static void validateSlot(int slot) {\n+        if ((slot & 0xFFFF) != slot)\n+            throw slotOutOfBounds(slot);\n+    }\n+\n+    public static boolean validateAndIsWideIinc(int slot, int val) {\n+        var ret = false;\n+        if ((slot & 0xFF) != slot) {\n+            validateSlot(slot);\n+            ret = true;\n+        }\n+        if ((byte) val != val) {\n+            if ((short) val != val) {\n+                throw new IllegalArgumentException(\"cannot encode as S2: \".concat(String.valueOf(val)));\n+            }\n+            ret = true;\n+        }\n+        return ret;\n+    }\n+\n+    public static void validateRet(Opcode opcode, int slot) {\n+        if (opcode == Opcode.RET && slot == (slot & 0xFF) ||\n+                opcode == Opcode.RET_W && slot == (slot & 0xFFFF))\n+            return;\n+        Objects.requireNonNull(opcode);\n+        throw slotOutOfBounds(opcode, slot);\n+    }\n+\n+    public static void validateMultiArrayDimensions(int value) {\n+        if (value < 1 || value > 0xFF)\n+            throw new IllegalArgumentException(\"Not a valid array dimension: \".concat(String.valueOf(value)));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":121,"deletions":10,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-                    case LOAD -> LoadInstruction.of(o, BytecodeHelpers.intrinsicLoadSlot(o));\n+                    case LOAD -> new AbstractInstruction.UnboundLoadInstruction(o, BytecodeHelpers.intrinsicLoadSlot(o));\n@@ -64,1 +64,1 @@\n-                    case STORE -> StoreInstruction.of(o, BytecodeHelpers.intrinsicStoreSlot(o));\n+                    case STORE -> new AbstractInstruction.UnboundStoreInstruction(o, BytecodeHelpers.intrinsicStoreSlot(o));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -509,6 +509,6 @@\n-    public void writeIncrement(int slot, int val) {\n-        Opcode opcode = (slot < 256 && val < 128 && val > -127)\n-                        ? IINC\n-                        : IINC_W;\n-        writeBytecode(opcode);\n-        if (opcode.isWide()) {\n+    public void writeIncrement(boolean wide, int slot, int val) {\n+        if (wide) {\n+            bytecodesBufWriter.writeU1(RawBytecodeHelper.WIDE);\n+        }\n+        bytecodesBufWriter.writeU1(RawBytecodeHelper.IINC);\n+        if (wide) {\n@@ -1219,1 +1219,1 @@\n-        writeIncrement(slot, val);\n+        writeIncrement(validateAndIsWideIinc(slot, val), slot, val);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-        if (arraySize > (Integer.MAX_VALUE - 8)) { \/\/conservative check\n+        if (arraySize > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) { \/\/conservative check\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1087,0 +1087,3 @@\n+        if (!moduleToReader.isEmpty()) {\n+            moduleToReader.clear();\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BuiltinClassLoader.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -213,7 +213,0 @@\n-\n-        \/**\n-         * Called by the VM, during -Xshare:dump\n-         *\/\n-        private void resetArchivedStates() {\n-            setClassPath(null);\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/ClassLoaders.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.file.Files;\n@@ -142,1 +143,0 @@\n-               getProperty(\"jdk.module.path\") == null &&\n@@ -206,1 +206,2 @@\n-        boolean haveModulePath = (appModulePath != null || upgradeModulePath != null);\n+        boolean haveUpgradeModulePath = (upgradeModulePath != null);\n+        boolean haveModulePath = (appModulePath != null || haveUpgradeModulePath);\n@@ -466,1 +467,4 @@\n-        if (CDS.isDumpingStaticArchive() && !haveModulePath && addModules.isEmpty()) {\n+        if (CDS.isDumpingStaticArchive()\n+                && !haveUpgradeModulePath\n+                && addModules.isEmpty()\n+                && allJrtOrModularJar(cf)) {\n@@ -513,0 +517,23 @@\n+    \/**\n+     * Returns true if all modules in the configuration are in the run-time image or\n+     * modular JAR files.\n+     *\/\n+    private static boolean allJrtOrModularJar(Configuration cf) {\n+        return !cf.modules().stream()\n+                .map(m -> m.reference().location().orElseThrow())\n+                .anyMatch(uri -> !uri.getScheme().equalsIgnoreCase(\"jrt\")\n+                        && !isJarFile(uri));\n+    }\n+\n+    \/**\n+     * Returns true if the given URI locates a jar file on the file system.\n+     *\/\n+    private static boolean isJarFile(URI uri) {\n+        if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            Path path = Path.of(uri);\n+            return path.toString().endsWith(\".jar\") && Files.isRegularFile(path);\n+        } else {\n+            return false;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -94,2 +94,13 @@\n-        Supplier<ModuleReader> supplier = () -> new JarModuleReader(file, uri);\n-        HashSupplier hasher = (a) -> ModuleHashes.computeHash(supplier, a);\n+        String fileString = file.toString();\n+        Supplier<ModuleReader> supplier = new Supplier<>() {\n+            @Override\n+            public ModuleReader get() {\n+                return new JarModuleReader(fileString, uri);\n+            }\n+        };\n+        HashSupplier hasher = new HashSupplier() {\n+            @Override\n+            public byte[] generate(String algorithm) {\n+              return ModuleHashes.computeHash(supplier, algorithm);\n+            }\n+        };\n@@ -225,1 +236,1 @@\n-        static JarFile newJarFile(Path path) {\n+        static JarFile newJarFile(String path) {\n@@ -227,1 +238,1 @@\n-                return new JarFile(new File(path.toString()),\n+                return new JarFile(new File(path),\n@@ -236,1 +247,1 @@\n-        JarModuleReader(Path path, URI uri) {\n+        JarModuleReader(String path, URI uri) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleReferences.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -266,0 +266,14 @@\n+    public interface WrapShuffleIndexesOperation<SH extends VectorShuffle<?>> {\n+        SH apply(SH sh);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <E,\n+     SH extends VectorShuffle<E>>\n+    SH wrapShuffleIndexes(Class<E> eClass, Class<? extends SH> shClass, SH sh, int length,\n+                          WrapShuffleIndexesOperation<SH> defaultImpl) {\n+       assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+       return defaultImpl.apply(sh);\n+    }\n+\n@@ -608,0 +622,17 @@\n+    public interface VectorSelectFromOp<V extends Vector<?>,\n+                                        M extends VectorMask<?>> {\n+        V apply(V v1, V v2, M m);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     M  extends VectorMask<E>,\n+     E>\n+    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+                   int length, V v1, V v2, M m,\n+                   VectorSelectFromOp<V, M> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v1, v2, m);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -90,2 +91,2 @@\n-    \/\/ The maximum size of array to allocate. Some VMs reserve some header words in an array.\n-    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n+    \/\/ The maximum size of array to allocate\n+    private static final int MAX_ARRAY_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureFileVerifier.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-     * issued after October 31, 2024. If enabled, this policy is currently\n+     * issued after November 11, 2024. If enabled, this policy is currently\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/CADistrustPolicy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,2 +91,2 @@\n-    private static final LocalDate OCTOBER_31_2024 =\n-        LocalDate.of(2024, Month.OCTOBER, 31);\n+    private static final LocalDate NOVEMBER_11_2024 =\n+        LocalDate.of(2024, Month.NOVEMBER, 11);\n@@ -114,2 +114,2 @@\n-            \/\/ reject if certificate is issued after October 31, 2024\n-            checkNotBefore(ldNotBefore, OCTOBER_31_2024, anchor);\n+            \/\/ reject if certificate is issued after November 11, 2024\n+            checkNotBefore(ldNotBefore, NOVEMBER_11_2024, anchor);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/EntrustTLSPolicy.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1361,1 +1361,1 @@\n-#   an Entrust root CA and issued after October 31, 2024.\n+#   an Entrust root CA and issued after November 11, 2024.\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,21 @@\n+Owner: CN=SSL.com TLS ECC Root CA 2022, O=SSL Corporation, C=US\n+Issuer: CN=SSL.com TLS ECC Root CA 2022, O=SSL Corporation, C=US\n+Serial number: 1403f5abfb378b17405be243b2a5d1c4\n+Valid from: Thu Aug 25 16:33:48 GMT 2022 until: Sun Aug 19 16:33:47 GMT 2046\n+Signature algorithm name: SHA384withECDSA\n+Subject Public Key Algorithm: 384-bit EC (secp384r1) key\n+Version: 3\n+-----BEGIN CERTIFICATE-----\n+MIICOjCCAcCgAwIBAgIQFAP1q\/s3ixdAW+JDsqXRxDAKBggqhkjOPQQDAzBOMQsw\n+CQYDVQQGEwJVUzEYMBYGA1UECgwPU1NMIENvcnBvcmF0aW9uMSUwIwYDVQQDDBxT\n+U0wuY29tIFRMUyBFQ0MgUm9vdCBDQSAyMDIyMB4XDTIyMDgyNTE2MzM0OFoXDTQ2\n+MDgxOTE2MzM0N1owTjELMAkGA1UEBhMCVVMxGDAWBgNVBAoMD1NTTCBDb3Jwb3Jh\n+dGlvbjElMCMGA1UEAwwcU1NMLmNvbSBUTFMgRUNDIFJvb3QgQ0EgMjAyMjB2MBAG\n+ByqGSM49AgEGBSuBBAAiA2IABEUpNXP6wrgjzhR9qLFNoFs27iosU8NgCTWyJGYm\n+acCzldZdkkAZDsalE3D07xJRKF3nzL35PIXBz5SQySvOkkJYWWf9lCcQZIxPBLFN\n+SeR7T5v15wj4A4j3p8OSSxlUgaNjMGEwDwYDVR0TAQH\/BAUwAwEB\/zAfBgNVHSME\n+GDAWgBSJjy+j6CugFFR781a4Jl9nOAuc0DAdBgNVHQ4EFgQUiY8vo+groBRUe\/NW\n+uCZfZzgLnNAwDgYDVR0PAQH\/BAQDAgGGMAoGCCqGSM49BAMDA2gAMGUCMFXjIlbp\n+15IkWE8elDIPDAI2wv2sdDJO4fscgIijzPvX6yv\/N33w7deedWo1dlJF4AIxAMeN\n+b0Igj762TVntd00pxCAgRWSGOlDGxK0tk\/UYfXLtqc\/ErFc2KAhl3zx5Zn6g6g==\n+-----END CERTIFICATE-----\n","filename":"src\/java.base\/share\/data\/cacerts\/ssltlsrootecc2022","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+Owner: CN=SSL.com TLS RSA Root CA 2022, O=SSL Corporation, C=US\n+Issuer: CN=SSL.com TLS RSA Root CA 2022, O=SSL Corporation, C=US\n+Serial number: 6fbedaad73bd0840e28b4dbed4f75b91\n+Valid from: Thu Aug 25 16:34:22 GMT 2022 until: Sun Aug 19 16:34:21 GMT 2046\n+Signature algorithm name: SHA256withRSA\n+Subject Public Key Algorithm: 4096-bit RSA key\n+Version: 3\n+-----BEGIN CERTIFICATE-----\n+MIIFiTCCA3GgAwIBAgIQb77arXO9CEDii02+1PdbkTANBgkqhkiG9w0BAQsFADBO\n+MQswCQYDVQQGEwJVUzEYMBYGA1UECgwPU1NMIENvcnBvcmF0aW9uMSUwIwYDVQQD\n+DBxTU0wuY29tIFRMUyBSU0EgUm9vdCBDQSAyMDIyMB4XDTIyMDgyNTE2MzQyMloX\n+DTQ2MDgxOTE2MzQyMVowTjELMAkGA1UEBhMCVVMxGDAWBgNVBAoMD1NTTCBDb3Jw\n+b3JhdGlvbjElMCMGA1UEAwwcU1NMLmNvbSBUTFMgUlNBIFJvb3QgQ0EgMjAyMjCC\n+AiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANCkCXJPQIgSYT41I57u9nTP\n+L3tYPc48DRAokC+X94xI2KDYJbFMsBFMF3NQ0CJKY7uB0ylu1bUJPiYYf7ISf5OY\n+t6\/wNr\/y7hienDtSxUcZXXTzZGbVXcdotL8bHAajvI9AI7YexoS9UcQbOcGV0ins\n+S657Lb85\/bRi3pZ7QcacoOAGcvvwB5cJOYF0r\/c0WRFXCsJbwST0MXMwgsadugL3\n+PnxEX4MN8\/HdIGkWCVDi1FW24IBydm5MR7d1VVm0U3TZlMZBrViKMWYPHqIbKUBO\n+L9975hYsLfy\/7PO0+r4Y9ptJ1O4Fbtk085zx7AGL0SDGD6C1vBdOSHtRwvzpXGk3\n+R2azaPgVKPC506QVzFpPulJwoxJF3ca6TvvC0PeoUidtbnm1jPx7jMEWTO6Af77w\n+dr5BUxIzrlo4QqvXDz5BjXYHMtWrifZOZ9mxQnUjbvPNQrL8VfVThxc7wDNY8VLS\n++YCk8OjwO4s4zKTGkH8PnP2L0aPP2oOnaclQNtVcBdIKQXTbYxE3waWglksejBYS\n+d66UNHsef8JmAOSqg+qKkK3ONkRN0VHpvB\/zagX9wHQfJRlAUW7qglFA35u5CCoG\n+AtUjHBPW6dvbxrB6y3snm\/vg1UYk7RBLY0ulBY+6uB0rpvqR4pJSvezrZ5dtmi2f\n+gTIFZzL7SAg\/2SW4BCUvAgMBAAGjYzBhMA8GA1UdEwEB\/wQFMAMBAf8wHwYDVR0j\n+BBgwFoAU+y437uOEeicuzRk1sTN8\/9REQrkwHQYDVR0OBBYEFPsuN+7jhHonLs0Z\n+NbEzfP\/UREK5MA4GA1UdDwEB\/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOCAgEAjYlt\n+hEUY8U+zoO9opMAdrDC8Z2awms22qyIZZtM7QbUQnRC6cm4pJCAcAZli05bg4vsM\n+QtfhWsSWTVTNj8pDU\/0quOr4ZcoBwq1gaAafORpR2eCNJvkLTqVTJXojpBzOCBvf\n+R4iyrT7gJ4eLSYwfqUdYe5byiB0YrrPRpgqU+tvT5TgKa3kSM\/tKWTcWQA673vWJ\n+DPFs0\/dRa1419dvAJuoSc06pkZCmF8NsLzjUo3KUQyxi4U5cMj29TH0ZR6LDSeeW\n+P4+a0zvkEdiLA9z2tmBVGKaBUfPhqBVq6+AL8BQx1rmMRTqoENjwuSfr98t67wVy\n+lrXEj5ZzxOhWc5y8aVFjvO9nHEMaX3cZHxj4HCUp+UmZKbaSPaKDN7EgkaibMOlq\n+bLQjk2UEqxHzDh1TJElTHaE\/nUiSEeJ9DU\/1172iWD54nR4fK\/4huxoTtrEoZP2w\n+AgDHbICivRZQIA9ygV\/MlP+7mea6kMvq+cYMwq7FGc4zoWtcu358NFcXrfA\/rs3q\n+r5nsLFR+jM4uElZI7xc7P0peYNLcdDa8pUNjyw9bowJWCZ4kLOGGgYz+qxcs+sji\n+Mho6\/4UIyYOf8kpIEFR3N+2ivEC+5BB09+Rbu7nzifmPQdjH5FCQNYA+HLhNkNPU\n+98OwoX6EyneSMSy4kLGCenROmxMmtNVQZlR4rmA=\n+-----END CERTIFICATE-----\n","filename":"src\/java.base\/share\/data\/cacerts\/ssltlsrootrsa2022","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -246,7 +246,1 @@\n-    char *emsg;\n-\n-    \/*\n-     * TODO: its safer to use strerror_r but is not available on\n-     * Solaris 8. Until then....\n-     *\/\n-    emsg = strerror(errno);\n+    char *emsg = strerror(errno);\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md_common.c","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @see AbstractAnnotationValueVisitor6##note_for_subclasses\"\n+ * @see AbstractAnnotationValueVisitor6##note_for_subclasses\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitor7.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,5 @@\n+ * @apiNote\n+ * In the reference implementation, handling {@linkplain ErrorType\n+ * error types} generally does not cause an {@code\n+ * IllegalArgumentException} from the methods in this interface.\n+ *\n@@ -201,0 +206,1 @@\n+     *\n@@ -202,1 +208,3 @@\n-     *          unboxing conversion\n+     *         unboxing conversion. Only types for the {@linkplain\n+     *         java.lang##wrapperClasses wrapper classes} have an\n+     *         unboxing conversion.\n@@ -271,1 +279,4 @@\n-     * @throws IllegalArgumentException if bounds are not valid\n+     *\n+     * @throws IllegalArgumentException if bounds are not valid. Invalid bounds\n+     * include all types that are not {@linkplain ReferenceType\n+     * reference types}.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -274,1 +274,0 @@\n-    int rc;\n@@ -278,1 +277,4 @@\n-    rc = pthread_create(&thr, &attr, SplashScreenThread, (void *) splash);\n+    rslt = pthread_create(&thr, &attr, SplashScreenThread, (void *) splash);\n+    if (rslt != 0) {\n+        fprintf(stderr, \"Could not create SplashScreen thread, error number:%d\\n\", rslt);\n+    }\n","filename":"src\/java.desktop\/macosx\/native\/libsplashscreen\/splashscreen_sys.m","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -744,1 +744,4 @@\n-    pthread_create(&thr, &attr, SplashScreenThread, (void *) splash);\n+    rslt = pthread_create(&thr, &attr, SplashScreenThread, (void *) splash);\n+    if (rslt != 0) {\n+        fprintf(stderr, \"Could not create SplashScreen thread, error number:%d\\n\", rslt);\n+    }\n","filename":"src\/java.desktop\/unix\/native\/libsplashscreen\/splashscreen_sys.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -960,0 +960,2 @@\n+                \/\/ Don't lose the interrupt.\n+                Thread.currentThread().interrupt();\n","filename":"src\/java.prefs\/unix\/classes\/java\/util\/prefs\/FileSystemPreferences.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.io.InputStream;\n-import java.io.IOException;\n@@ -34,0 +32,3 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n@@ -36,1 +37,1 @@\n-import java.nio.file.Files;\n+import java.util.Optional;\n@@ -50,1 +51,23 @@\n-    private static final String tmpdir = \"\/tmp\";\n+    private static final Path TMPDIR = Path.of(\"\/tmp\");\n+\n+    private static final Path PROC     = Path.of(\"\/proc\");\n+    private static final Path NS_MNT   = Path.of(\"ns\/mnt\");\n+    private static final Path NS_PID   = Path.of(\"ns\/pid\");\n+    private static final Path SELF     = PROC.resolve(\"self\");\n+    private static final Path STATUS   = Path.of(\"status\");\n+    private static final Path ROOT_TMP = Path.of(\"root\/tmp\");\n+\n+    private static final Optional<Path> SELF_MNT_NS;\n+\n+    static {\n+        Path nsPath = null;\n+\n+        try {\n+            nsPath = Files.readSymbolicLink(SELF.resolve(NS_MNT));\n+        } catch (IOException _) {\n+            \/\/ do nothing\n+        } finally {\n+            SELF_MNT_NS = Optional.ofNullable(nsPath);\n+        }\n+    }\n+\n@@ -52,0 +75,1 @@\n+\n@@ -55,2 +79,1 @@\n-    VirtualMachineImpl(AttachProvider provider, String vmid)\n-        throws AttachNotSupportedException, IOException\n+    VirtualMachineImpl(AttachProvider provider, String vmid) throws AttachNotSupportedException, IOException\n@@ -67,1 +90,1 @@\n-        int ns_pid = getNamespacePid(pid);\n+        final long ns_pid = getNamespacePid(pid);\n@@ -72,1 +95,1 @@\n-        File socket_file = findSocketFile(pid, ns_pid);\n+        final File socket_file = findSocketFile(pid, ns_pid);\n@@ -214,3 +237,2 @@\n-    private File findSocketFile(int pid, int ns_pid) throws IOException {\n-        String root = findTargetProcessTmpDirectory(pid, ns_pid);\n-        return new File(root, \".java_pid\" + ns_pid);\n+    private File findSocketFile(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+        return new File(findTargetProcessTmpDirectory(pid, ns_pid), \".java_pid\" + ns_pid);\n@@ -223,4 +245,4 @@\n-    private File createAttachFile(int pid, int ns_pid) throws IOException {\n-        String fn = \".attach_pid\" + ns_pid;\n-        String path = \"\/proc\/\" + pid + \"\/cwd\/\" + fn;\n-        File f = new File(path);\n+    private File createAttachFile(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+        Path fn   = Path.of(\".attach_pid\" + ns_pid);\n+        Path path = PROC.resolve(Path.of(Long.toString(pid), \"cwd\")).resolve(fn);\n+        File f    = new File(path.toString());\n@@ -230,3 +252,2 @@\n-        } catch (IOException x) {\n-            String root = findTargetProcessTmpDirectory(pid, ns_pid);\n-            f = new File(root, fn);\n+        } catch (IOException _) {\n+            f = new File(findTargetProcessTmpDirectory(pid, ns_pid), fn.toString());\n@@ -238,12 +259,28 @@\n-    private String findTargetProcessTmpDirectory(int pid, int ns_pid) throws IOException {\n-        String root;\n-        if (pid != ns_pid) {\n-            \/\/ A process may not exist in the same mount namespace as the caller, e.g.\n-            \/\/ if we are trying to attach to a JVM process inside a container.\n-            \/\/ Instead, attach relative to the target root filesystem as exposed by\n-            \/\/ procfs regardless of namespaces.\n-            String procRootDirectory = \"\/proc\/\" + pid + \"\/root\";\n-            if (!Files.isReadable(Path.of(procRootDirectory))) {\n-                throw new IOException(\n-                        String.format(\"Unable to access root directory %s \" +\n-                          \"of target process %d\", procRootDirectory, pid));\n+    private String findTargetProcessTmpDirectory(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+        \/\/ We need to handle at least 4 different cases:\n+        \/\/ 1. Caller and target processes share PID namespace and root filesystem (host to host or container to\n+        \/\/    container with both \/tmp mounted between containers).\n+        \/\/ 2. Caller and target processes share PID namespace and root filesystem but the target process has elevated\n+        \/\/    privileges (host to host).\n+        \/\/ 3. Caller and target processes share PID namespace but NOT root filesystem (container to container).\n+        \/\/ 4. Caller and target processes share neither PID namespace nor root filesystem (host to container).\n+\n+        Optional<ProcessHandle> target = ProcessHandle.of(pid);\n+        Optional<ProcessHandle> ph = target;\n+        long nsPid = ns_pid;\n+        Optional<Path> prevPidNS = Optional.empty();\n+\n+        while (ph.isPresent()) {\n+            final var curPid = ph.get().pid();\n+            final var procPidPath = PROC.resolve(Long.toString(curPid));\n+            Optional<Path> targetMountNS = Optional.empty();\n+\n+            try {\n+                \/\/ attempt to read the target's mnt ns id\n+                targetMountNS = Optional.ofNullable(Files.readSymbolicLink(procPidPath.resolve(NS_MNT)));\n+            } catch (IOException _) {\n+                \/\/ if we fail to read the target's mnt ns id then we either don't have access or it no longer exists!\n+                if (!Files.exists(procPidPath)) {\n+                    throw new IOException(String.format(\"unable to attach, %s non-existent! process: %d terminated\", procPidPath, pid));\n+                }\n+                \/\/ the process still exists, but we don't have privileges to read its procfs\n@@ -252,1 +289,41 @@\n-            root = procRootDirectory + \"\/\" + tmpdir;\n+            final var sameMountNS = SELF_MNT_NS.isPresent() && SELF_MNT_NS.equals(targetMountNS);\n+\n+            if (sameMountNS) {\n+                return TMPDIR.toString(); \/\/ we share TMPDIR in common!\n+            } else {\n+                \/\/ we could not read the target's mnt ns\n+                final var procPidRootTmp = procPidPath.resolve(ROOT_TMP);\n+                if (Files.isReadable(procPidRootTmp)) {\n+                    return procPidRootTmp.toString(); \/\/ not in the same mnt ns but tmp is accessible via \/proc\n+                }\n+            }\n+\n+            \/\/ let's attempt to obtain the pid ns, best efforts to avoid crossing pid ns boundaries (as with a container)\n+            Optional<Path> curPidNS = Optional.empty();\n+\n+            try {\n+                \/\/ attempt to read the target's pid ns id\n+                curPidNS = Optional.ofNullable(Files.readSymbolicLink(procPidPath.resolve(NS_PID)));\n+            } catch (IOException _) {\n+                \/\/ if we fail to read the target's pid ns id then we either don't have access or it no longer exists!\n+                if (!Files.exists(procPidPath)) {\n+                    throw new IOException(String.format(\"unable to attach, %s non-existent! process: %d terminated\", procPidPath, pid));\n+                }\n+                \/\/ the process still exists, but we don't have privileges to read its procfs\n+            }\n+\n+            \/\/ recurse \"up\" the process hierarchy if appropriate. PID 1 cannot have a parent in the same namespace\n+            final var havePidNSes = prevPidNS.isPresent() && curPidNS.isPresent();\n+            final var ppid = ph.get().parent();\n+\n+            if (ppid.isPresent() && (havePidNSes && curPidNS.equals(prevPidNS)) || (!havePidNSes && nsPid > 1)) {\n+                ph = ppid;\n+                nsPid = getNamespacePid(ph.get().pid()); \/\/ get the ns pid of the parent\n+                prevPidNS = curPidNS;\n+            } else {\n+                ph = Optional.empty();\n+            }\n+        }\n+\n+        if (target.orElseThrow(AttachNotSupportedException::new).isAlive()) {\n+            return TMPDIR.toString(); \/\/ fallback...\n@@ -254,1 +331,1 @@\n-            root = tmpdir;\n+            throw new IOException(String.format(\"unable to attach, process: %d terminated\", pid));\n@@ -256,1 +333,0 @@\n-        return root;\n@@ -273,1 +349,0 @@\n-\n@@ -276,1 +351,1 @@\n-    private int getNamespacePid(int pid) throws AttachNotSupportedException, IOException {\n+    private long getNamespacePid(long pid) throws AttachNotSupportedException, IOException {\n@@ -279,1 +354,1 @@\n-        String statusFile = \"\/proc\/\" + pid + \"\/status\";\n+        final var statusFile = PROC.resolve(Long.toString(pid)).resolve(STATUS).toString();\n@@ -295,2 +370,1 @@\n-                    int ns_pid = Integer.parseInt(parts[parts.length - 1]);\n-                    return ns_pid;\n+                    return Long.parseLong(parts[parts.length - 1]);\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":112,"deletions":38,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -2355,0 +2355,6 @@\n+        \/**\n+         * A supertype_index value of 65535 specifies that the annotation appears on the superclass\n+         * in an extends clause of a class declaration, see JVMS 4.7.20.1\n+         *\/\n+        public static final int SUPERCLASS_INDEX = 65535;\n+\n@@ -2364,1 +2370,1 @@\n-            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(65535));\n+            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(SUPERCLASS_INDEX));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  \/\/ The type of the contained stubs (i.e., InterpreterCodelet,\n-  \/\/ ICStub). Must be a subclass of type Stub.\n+  \/\/ The type of the contained stubs (i.e., InterpreterCodelet).\n+  \/\/ Must be a subclass of type Stub.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/StubQueue.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-    public final VectorShuffle<E> wrapIndexes() {\n+    public final VectorShuffle<E> wrapIndexesTemplate() {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Byte128Mask) m);  \/\/ specialize\n+                                     Byte128Mask.class, (Byte128Mask) m);  \/\/ specialize\n@@ -863,0 +863,7 @@\n+        @Override\n+        @ForceInline\n+        public Byte128Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte128Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Byte256Mask) m);  \/\/ specialize\n+                                     Byte256Mask.class, (Byte256Mask) m);  \/\/ specialize\n@@ -895,0 +895,7 @@\n+        @Override\n+        @ForceInline\n+        public Byte256Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte256Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Byte512Mask) m);  \/\/ specialize\n+                                     Byte512Mask.class, (Byte512Mask) m);  \/\/ specialize\n@@ -959,0 +959,7 @@\n+        @Override\n+        @ForceInline\n+        public Byte512Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte512Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Byte64Mask) m);  \/\/ specialize\n+                                     Byte64Mask.class, (Byte64Mask) m);  \/\/ specialize\n@@ -847,0 +847,7 @@\n+        @Override\n+        @ForceInline\n+        public Byte64Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte64Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (ByteMaxMask) m);  \/\/ specialize\n+                                     ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialize\n@@ -833,0 +833,7 @@\n+        @Override\n+        @ForceInline\n+        public ByteMaxShuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, ByteMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((ByteMaxShuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2396,1 +2396,1 @@\n-    ByteVector rearrange(VectorShuffle<Byte> m);\n+    ByteVector rearrange(VectorShuffle<Byte> shuffle);\n@@ -2403,1 +2403,2 @@\n-        shuffle.checkIndexes();\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2406,1 +2407,1 @@\n-            this, shuffle, null,\n+            this, ws, null,\n@@ -2431,5 +2432,2 @@\n-        VectorMask<Byte> valid = shuffle.laneIsValid();\n-        if (m.andNot(valid).anyTrue()) {\n-            shuffle.checkIndexes();\n-            throw new AssertionError();\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2438,1 +2436,1 @@\n-                   this, shuffle, m,\n+                   this, ws, m,\n@@ -2441,1 +2439,1 @@\n-                        return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                        return !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n@@ -2554,1 +2552,4 @@\n-        return v.rearrange(this.toShuffle());\n+        return (ByteVector)VectorSupport.selectFromOp(getClass(), null, byte.class,\n+                                                        length(), this, v, null,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle()));\n@@ -2566,3 +2567,9 @@\n-    final ByteVector selectFromTemplate(ByteVector v,\n-                                                  AbstractMask<Byte> m) {\n-        return v.rearrange(this.toShuffle(), m);\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector selectFromTemplate(ByteVector v,\n+                                            Class<M> masktype, M m) {\n+        m.check(masktype, this);\n+        return (ByteVector)VectorSupport.selectFromOp(getClass(), masktype, byte.class,\n+                                                        length(), this, v, m,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle(), _m));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-                                     (Double128Mask) m);  \/\/ specialize\n+                                     Double128Mask.class, (Double128Mask) m);  \/\/ specialize\n@@ -824,0 +824,7 @@\n+        @Override\n+        @ForceInline\n+        public Double128Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Double128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double128Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-                                     (Double256Mask) m);  \/\/ specialize\n+                                     Double256Mask.class, (Double256Mask) m);  \/\/ specialize\n@@ -828,0 +828,7 @@\n+        @Override\n+        @ForceInline\n+        public Double256Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Double256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double256Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-                                     (Double512Mask) m);  \/\/ specialize\n+                                     Double512Mask.class, (Double512Mask) m);  \/\/ specialize\n@@ -836,0 +836,7 @@\n+        @Override\n+        @ForceInline\n+        public Double512Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Double512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double512Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-                                     (Double64Mask) m);  \/\/ specialize\n+                                     Double64Mask.class, (Double64Mask) m);  \/\/ specialize\n@@ -822,0 +822,7 @@\n+        @Override\n+        @ForceInline\n+        public Double64Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Double64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double64Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-                                     (DoubleMaxMask) m);  \/\/ specialize\n+                                     DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialize\n@@ -821,0 +821,7 @@\n+        @Override\n+        @ForceInline\n+        public DoubleMaxShuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, DoubleMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((DoubleMaxShuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2238,1 +2238,1 @@\n-    DoubleVector rearrange(VectorShuffle<Double> m);\n+    DoubleVector rearrange(VectorShuffle<Double> shuffle);\n@@ -2245,1 +2245,2 @@\n-        shuffle.checkIndexes();\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2248,1 +2249,1 @@\n-            this, shuffle, null,\n+            this, ws, null,\n@@ -2273,5 +2274,2 @@\n-        VectorMask<Double> valid = shuffle.laneIsValid();\n-        if (m.andNot(valid).anyTrue()) {\n-            shuffle.checkIndexes();\n-            throw new AssertionError();\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2280,1 +2278,1 @@\n-                   this, shuffle, m,\n+                   this, ws, m,\n@@ -2283,1 +2281,1 @@\n-                        return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                        return !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n@@ -2396,1 +2394,4 @@\n-        return v.rearrange(this.toShuffle());\n+        return (DoubleVector)VectorSupport.selectFromOp(getClass(), null, double.class,\n+                                                        length(), this, v, null,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle()));\n@@ -2408,3 +2409,9 @@\n-    final DoubleVector selectFromTemplate(DoubleVector v,\n-                                                  AbstractMask<Double> m) {\n-        return v.rearrange(this.toShuffle(), m);\n+    final\n+    <M extends VectorMask<Double>>\n+    DoubleVector selectFromTemplate(DoubleVector v,\n+                                            Class<M> masktype, M m) {\n+        m.check(masktype, this);\n+        return (DoubleVector)VectorSupport.selectFromOp(getClass(), masktype, double.class,\n+                                                        length(), this, v, m,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle(), _m));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-                                     (Float128Mask) m);  \/\/ specialize\n+                                     Float128Mask.class, (Float128Mask) m);  \/\/ specialize\n@@ -828,0 +828,7 @@\n+        @Override\n+        @ForceInline\n+        public Float128Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Float128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float128Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-                                     (Float256Mask) m);  \/\/ specialize\n+                                     Float256Mask.class, (Float256Mask) m);  \/\/ specialize\n@@ -836,0 +836,7 @@\n+        @Override\n+        @ForceInline\n+        public Float256Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Float256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float256Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-                                     (Float512Mask) m);  \/\/ specialize\n+                                     Float512Mask.class, (Float512Mask) m);  \/\/ specialize\n@@ -852,0 +852,7 @@\n+        @Override\n+        @ForceInline\n+        public Float512Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Float512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float512Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-                                     (Float64Mask) m);  \/\/ specialize\n+                                     Float64Mask.class, (Float64Mask) m);  \/\/ specialize\n@@ -824,0 +824,7 @@\n+        @Override\n+        @ForceInline\n+        public Float64Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Float64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float64Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-                                     (FloatMaxMask) m);  \/\/ specialize\n+                                     FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialize\n@@ -821,0 +821,7 @@\n+        @Override\n+        @ForceInline\n+        public FloatMaxShuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, FloatMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((FloatMaxShuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2250,1 +2250,1 @@\n-    FloatVector rearrange(VectorShuffle<Float> m);\n+    FloatVector rearrange(VectorShuffle<Float> shuffle);\n@@ -2257,1 +2257,2 @@\n-        shuffle.checkIndexes();\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2260,1 +2261,1 @@\n-            this, shuffle, null,\n+            this, ws, null,\n@@ -2285,5 +2286,2 @@\n-        VectorMask<Float> valid = shuffle.laneIsValid();\n-        if (m.andNot(valid).anyTrue()) {\n-            shuffle.checkIndexes();\n-            throw new AssertionError();\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2292,1 +2290,1 @@\n-                   this, shuffle, m,\n+                   this, ws, m,\n@@ -2295,1 +2293,1 @@\n-                        return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                        return !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n@@ -2408,1 +2406,4 @@\n-        return v.rearrange(this.toShuffle());\n+        return (FloatVector)VectorSupport.selectFromOp(getClass(), null, float.class,\n+                                                        length(), this, v, null,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle()));\n@@ -2420,3 +2421,9 @@\n-    final FloatVector selectFromTemplate(FloatVector v,\n-                                                  AbstractMask<Float> m) {\n-        return v.rearrange(this.toShuffle(), m);\n+    final\n+    <M extends VectorMask<Float>>\n+    FloatVector selectFromTemplate(FloatVector v,\n+                                            Class<M> masktype, M m) {\n+        m.check(masktype, this);\n+        return (FloatVector)VectorSupport.selectFromOp(getClass(), masktype, float.class,\n+                                                        length(), this, v, m,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle(), _m));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Int128Mask) m);  \/\/ specialize\n+                                     Int128Mask.class, (Int128Mask) m);  \/\/ specialize\n@@ -839,0 +839,7 @@\n+        @Override\n+        @ForceInline\n+        public Int128Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Int128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int128Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Int256Mask) m);  \/\/ specialize\n+                                     Int256Mask.class, (Int256Mask) m);  \/\/ specialize\n@@ -847,0 +847,7 @@\n+        @Override\n+        @ForceInline\n+        public Int256Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Int256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int256Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Int512Mask) m);  \/\/ specialize\n+                                     Int512Mask.class, (Int512Mask) m);  \/\/ specialize\n@@ -863,0 +863,7 @@\n+        @Override\n+        @ForceInline\n+        public Int512Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Int512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int512Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Int64Mask) m);  \/\/ specialize\n+                                     Int64Mask.class, (Int64Mask) m);  \/\/ specialize\n@@ -835,0 +835,7 @@\n+        @Override\n+        @ForceInline\n+        public Int64Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Int64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int64Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (IntMaxMask) m);  \/\/ specialize\n+                                     IntMaxMask.class, (IntMaxMask) m);  \/\/ specialize\n@@ -844,0 +844,7 @@\n+        @Override\n+        @ForceInline\n+        public IntMaxShuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, IntMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((IntMaxShuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2381,1 +2381,1 @@\n-    IntVector rearrange(VectorShuffle<Integer> m);\n+    IntVector rearrange(VectorShuffle<Integer> shuffle);\n@@ -2388,1 +2388,2 @@\n-        shuffle.checkIndexes();\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2391,1 +2392,1 @@\n-            this, shuffle, null,\n+            this, ws, null,\n@@ -2416,5 +2417,2 @@\n-        VectorMask<Integer> valid = shuffle.laneIsValid();\n-        if (m.andNot(valid).anyTrue()) {\n-            shuffle.checkIndexes();\n-            throw new AssertionError();\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2423,1 +2421,1 @@\n-                   this, shuffle, m,\n+                   this, ws, m,\n@@ -2426,1 +2424,1 @@\n-                        return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                        return !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n@@ -2539,1 +2537,4 @@\n-        return v.rearrange(this.toShuffle());\n+        return (IntVector)VectorSupport.selectFromOp(getClass(), null, int.class,\n+                                                        length(), this, v, null,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle()));\n@@ -2551,3 +2552,9 @@\n-    final IntVector selectFromTemplate(IntVector v,\n-                                                  AbstractMask<Integer> m) {\n-        return v.rearrange(this.toShuffle(), m);\n+    final\n+    <M extends VectorMask<Integer>>\n+    IntVector selectFromTemplate(IntVector v,\n+                                            Class<M> masktype, M m) {\n+        m.check(masktype, this);\n+        return (IntVector)VectorSupport.selectFromOp(getClass(), masktype, int.class,\n+                                                        length(), this, v, m,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle(), _m));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-                                     (Long128Mask) m);  \/\/ specialize\n+                                     Long128Mask.class, (Long128Mask) m);  \/\/ specialize\n@@ -825,0 +825,7 @@\n+        @Override\n+        @ForceInline\n+        public Long128Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Long128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long128Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-                                     (Long256Mask) m);  \/\/ specialize\n+                                     Long256Mask.class, (Long256Mask) m);  \/\/ specialize\n@@ -829,0 +829,7 @@\n+        @Override\n+        @ForceInline\n+        public Long256Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Long256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long256Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-                                     (Long512Mask) m);  \/\/ specialize\n+                                     Long512Mask.class, (Long512Mask) m);  \/\/ specialize\n@@ -837,0 +837,7 @@\n+        @Override\n+        @ForceInline\n+        public Long512Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Long512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long512Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-                                     (Long64Mask) m);  \/\/ specialize\n+                                     Long64Mask.class, (Long64Mask) m);  \/\/ specialize\n@@ -823,0 +823,7 @@\n+        @Override\n+        @ForceInline\n+        public Long64Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Long64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long64Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-                                     (LongMaxMask) m);  \/\/ specialize\n+                                     LongMaxMask.class, (LongMaxMask) m);  \/\/ specialize\n@@ -823,0 +823,7 @@\n+        @Override\n+        @ForceInline\n+        public LongMaxShuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, LongMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((LongMaxShuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2247,1 +2247,1 @@\n-    LongVector rearrange(VectorShuffle<Long> m);\n+    LongVector rearrange(VectorShuffle<Long> shuffle);\n@@ -2254,1 +2254,2 @@\n-        shuffle.checkIndexes();\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2257,1 +2258,1 @@\n-            this, shuffle, null,\n+            this, ws, null,\n@@ -2282,5 +2283,2 @@\n-        VectorMask<Long> valid = shuffle.laneIsValid();\n-        if (m.andNot(valid).anyTrue()) {\n-            shuffle.checkIndexes();\n-            throw new AssertionError();\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2289,1 +2287,1 @@\n-                   this, shuffle, m,\n+                   this, ws, m,\n@@ -2292,1 +2290,1 @@\n-                        return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                        return !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n@@ -2405,1 +2403,4 @@\n-        return v.rearrange(this.toShuffle());\n+        return (LongVector)VectorSupport.selectFromOp(getClass(), null, long.class,\n+                                                        length(), this, v, null,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle()));\n@@ -2417,3 +2418,9 @@\n-    final LongVector selectFromTemplate(LongVector v,\n-                                                  AbstractMask<Long> m) {\n-        return v.rearrange(this.toShuffle(), m);\n+    final\n+    <M extends VectorMask<Long>>\n+    LongVector selectFromTemplate(LongVector v,\n+                                            Class<M> masktype, M m) {\n+        m.check(masktype, this);\n+        return (LongVector)VectorSupport.selectFromOp(getClass(), masktype, long.class,\n+                                                        length(), this, v, m,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle(), _m));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Short128Mask) m);  \/\/ specialize\n+                                     Short128Mask.class, (Short128Mask) m);  \/\/ specialize\n@@ -847,0 +847,7 @@\n+        @Override\n+        @ForceInline\n+        public Short128Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Short128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short128Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Short256Mask) m);  \/\/ specialize\n+                                     Short256Mask.class, (Short256Mask) m);  \/\/ specialize\n@@ -863,0 +863,7 @@\n+        @Override\n+        @ForceInline\n+        public Short256Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Short256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short256Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Short512Mask) m);  \/\/ specialize\n+                                     Short512Mask.class, (Short512Mask) m);  \/\/ specialize\n@@ -895,0 +895,7 @@\n+        @Override\n+        @ForceInline\n+        public Short512Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Short512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short512Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (Short64Mask) m);  \/\/ specialize\n+                                     Short64Mask.class, (Short64Mask) m);  \/\/ specialize\n@@ -839,0 +839,7 @@\n+        @Override\n+        @ForceInline\n+        public Short64Shuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, Short64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short64Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                                     (ShortMaxMask) m);  \/\/ specialize\n+                                     ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialize\n@@ -833,0 +833,7 @@\n+        @Override\n+        @ForceInline\n+        public ShortMaxShuffle wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, ShortMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((ShortMaxShuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2397,1 +2397,1 @@\n-    ShortVector rearrange(VectorShuffle<Short> m);\n+    ShortVector rearrange(VectorShuffle<Short> shuffle);\n@@ -2404,1 +2404,2 @@\n-        shuffle.checkIndexes();\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2407,1 +2408,1 @@\n-            this, shuffle, null,\n+            this, ws, null,\n@@ -2432,5 +2433,2 @@\n-        VectorMask<Short> valid = shuffle.laneIsValid();\n-        if (m.andNot(valid).anyTrue()) {\n-            shuffle.checkIndexes();\n-            throw new AssertionError();\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2439,1 +2437,1 @@\n-                   this, shuffle, m,\n+                   this, ws, m,\n@@ -2442,1 +2440,1 @@\n-                        return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                        return !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n@@ -2555,1 +2553,4 @@\n-        return v.rearrange(this.toShuffle());\n+        return (ShortVector)VectorSupport.selectFromOp(getClass(), null, short.class,\n+                                                        length(), this, v, null,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle()));\n@@ -2567,3 +2568,9 @@\n-    final ShortVector selectFromTemplate(ShortVector v,\n-                                                  AbstractMask<Short> m) {\n-        return v.rearrange(this.toShuffle(), m);\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector selectFromTemplate(ShortVector v,\n+                                            Class<M> masktype, M m) {\n+        m.check(masktype, this);\n+        return (ShortVector)VectorSupport.selectFromOp(getClass(), masktype, short.class,\n+                                                        length(), this, v, m,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle(), _m));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2617,1 +2617,1 @@\n-     * source index {@code I=s.laneSource(N)} in the shuffle,\n+     * source index {@code I=s.wrapIndex(s.laneSource(N))} in the shuffle,\n@@ -2623,2 +2623,0 @@\n-     * @throws IndexOutOfBoundsException if there are any exceptional\n-     *        source indexes in the shuffle\n@@ -2627,1 +2625,0 @@\n-     * @see VectorShuffle#laneIsValid()\n@@ -2639,1 +2636,1 @@\n-     * source index {@code I=s.laneSource(N)} in the shuffle,\n+     * source index {@code I=s.wrapIndex(s.laneSource(N))} in the shuffle,\n@@ -2646,3 +2643,1 @@\n-     * Vector<E> r = this.rearrange(s.wrapIndexes());\n-     * VectorMask<E> valid = s.laneIsValid();\n-     * if (m.andNot(valid).anyTrue()) throw ...;\n+     * Vector<E> r = this.rearrange(s);\n@@ -2655,2 +2650,0 @@\n-     * @throws IndexOutOfBoundsException if there are any exceptional\n-     *        source indexes in the shuffle where the mask is set\n@@ -2659,1 +2652,0 @@\n-     * @see VectorShuffle#laneIsValid()\n@@ -2750,1 +2742,1 @@\n-     * value {@code I=this.lane(N)} in this vector,\n+     * value {@code I=wrapIndex(this.lane(N))} in this vector,\n@@ -2763,2 +2755,0 @@\n-     * @throws IndexOutOfBoundsException if any invalid\n-     *         source indexes are found in {@code this}\n@@ -2790,3 +2780,0 @@\n-     * @throws IndexOutOfBoundsException if any invalid\n-     *         source indexes are found in {@code this},\n-     *         in a lane which is set in the mask\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2773,1 +2773,1 @@\n-    $abstractvectortype$ rearrange(VectorShuffle<$Boxtype$> m);\n+    $abstractvectortype$ rearrange(VectorShuffle<$Boxtype$> shuffle);\n@@ -2780,1 +2780,2 @@\n-        shuffle.checkIndexes();\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2783,1 +2784,1 @@\n-            this, shuffle, null,\n+            this, ws, null,\n@@ -2808,5 +2809,2 @@\n-        VectorMask<$Boxtype$> valid = shuffle.laneIsValid();\n-        if (m.andNot(valid).anyTrue()) {\n-            shuffle.checkIndexes();\n-            throw new AssertionError();\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n@@ -2815,1 +2813,1 @@\n-                   this, shuffle, m,\n+                   this, ws, m,\n@@ -2818,1 +2816,1 @@\n-                        return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                        return !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n@@ -2931,1 +2929,4 @@\n-        return v.rearrange(this.toShuffle());\n+        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), null, $type$.class,\n+                                                        length(), this, v, null,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle()));\n@@ -2943,3 +2944,9 @@\n-    final $abstractvectortype$ selectFromTemplate($abstractvectortype$ v,\n-                                                  AbstractMask<$Boxtype$> m) {\n-        return v.rearrange(this.toShuffle(), m);\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $abstractvectortype$ selectFromTemplate($abstractvectortype$ v,\n+                                            Class<M> masktype, M m) {\n+        m.check(masktype, this);\n+        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), masktype, $type$.class,\n+                                                        length(), this, v, m,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle(), _m));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -512,1 +512,1 @@\n-                                     ($masktype$) m);  \/\/ specialize\n+                                     $masktype$.class, ($masktype$) m);  \/\/ specialize\n@@ -1121,0 +1121,7 @@\n+        @Override\n+        @ForceInline\n+        public $shuffletype$ wrapIndexes() {\n+            return VectorSupport.wrapShuffleIndexes(ETYPE, $shuffletype$.class, this, VLENGTH,\n+                                                    (s) -> (($shuffletype$)(((AbstractShuffle<$Boxtype$>)(s)).wrapIndexesTemplate())));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -200,0 +200,1 @@\n+    private boolean hasNonexistentEntries = false;\n@@ -738,0 +739,1 @@\n+        Map<String,Set<String>> entriesInSF = new HashMap<>();\n@@ -785,0 +787,1 @@\n+                                entriesInSF.put(alias, sf.getEntries().keySet());\n@@ -884,0 +887,3 @@\n+                        for (var signed : entriesInSF.values()) {\n+                            signed.remove(name);\n+                        }\n@@ -1079,0 +1085,7 @@\n+                        var signed = entriesInSF.get(s);\n+                        if (!signed.isEmpty()) {\n+                            if (verbose != null) {\n+                                System.out.println(rb.getString(\"history.nonexistent.entries\") + signed);\n+                            }\n+                            hasNonexistentEntries = true;\n+                        }\n@@ -1314,0 +1327,3 @@\n+        if (hasNonexistentEntries) {\n+            warnings.add(rb.getString(\"nonexistent.entries.found\"));\n+        }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -167,0 +167,1 @@\n+        {\"history.nonexistent.entries\", \"    Warning: nonexistent signed entries: \"},\n@@ -181,0 +182,1 @@\n+        {\"nonexistent.entries.found\", \"This jar contains signed entries for files that do not exist. See the -verbose output for more details.\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -873,4 +873,6 @@\n-            for (ModuleSymbol msym : modules.allModules()) {\n-                PackageSymbol p = syms.getPackage(msym, pack);\n-                if (p != null && !p.members().isEmpty()) {\n-                    return msym;\n+            if (modules.modulesInitialized()) {\n+                for (ModuleSymbol msym : modules.allModules()) {\n+                    PackageSymbol p = syms.getPackage(msym, pack);\n+                    if (p != null && !p.members().isEmpty()) {\n+                        return msym;\n+                    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ElementsTable.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-                codeBuilder.ldc(index);\n+                codeBuilder.loadConstant(index);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -502,1 +502,1 @@\n-                codeBuilder.ldc(index);\n+                codeBuilder.loadConstant(index);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+compiler\/cha\/TypeProfileFinalMethod.java 8341039 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-applications\/ctw\/modules\/java_base.java 8340683 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    vm.libgraal.enabled \\\n+    vm.libgraal.jit \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -438,0 +438,1 @@\n+ -runtime\/cds\/appcds\/complexURI \\\n@@ -440,0 +441,2 @@\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndFMG.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java \\\n@@ -456,0 +459,1 @@\n+ -runtime\/cds\/appcds\/DumpRuntimeClassesTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -264,6 +264,0 @@\n-            \/\/ a card mark volatile barrier should be generated\n-            \/\/ before the card mark strb\n-            \/\/\n-            \/\/ following the fix for 8225776 the G1 barrier is now\n-            \/\/ scheduled out of line after the membar volatile and\n-            \/\/ and subsequent return\n@@ -274,4 +268,1 @@\n-                \"ret\",\n-                \"membar_volatile\",\n-                \"dmb ish\",\n-                \"strb\"\n+                \"ret\"\n@@ -335,6 +326,0 @@\n-            \/\/ a card mark volatile barrier should be generated\n-            \/\/ before the card mark strb\n-            \/\/\n-            \/\/ following the fix for 8225776 the G1 barrier is now\n-            \/\/ scheduled out of line after the membar acquire and\n-            \/\/ and subsequent return\n@@ -345,4 +330,1 @@\n-                \"ret\",\n-                \"membar_volatile\",\n-                \"dmb ish\",\n-                \"strb\"\n+                \"ret\"\n@@ -421,6 +403,0 @@\n-            \/\/ a card mark volatile barrier should be generated\n-            \/\/ before the card mark strb\n-            \/\/\n-            \/\/ following the fix for 8225776 the G1 barrier is now\n-            \/\/ scheduled out of line after the membar acquire and\n-            \/\/ and subsequent return\n@@ -431,4 +407,1 @@\n-                \"ret\",\n-                \"membar_volatile\",\n-                \"dmb ish\",\n-                \"strb\"\n+                \"ret\"\n@@ -487,6 +460,0 @@\n-            \/\/ a card mark volatile barrier should be generated\n-            \/\/ before the card mark strb\n-            \/\/\n-            \/\/ following the fix for 8225776 the G1 barrier is now\n-            \/\/ scheduled out of line after the membar acquire and\n-            \/\/ and subsequent return\n@@ -497,4 +464,1 @@\n-                \"ret\",\n-                \"membar_volatile\",\n-                \"dmb ish\",\n-                \"strb\"\n+                \"ret\"\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestVolatiles.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1358,3 +1358,6 @@\n-    @IR(counts = { IRNode.ALLOC, \"1\" })\n-    \/\/ The last allocation won't be reduced because it would cause the creation\n-    \/\/ of a nested SafePointScalarMergeNode.\n+    \/\/ Using G1, all allocations are reduced.\n+    @IR(applyIf = {\"UseG1GC\", \"true\"}, failOn = { IRNode.ALLOC })\n+    \/\/ Otherwise, the last allocation won't be reduced because it would cause\n+    \/\/ the creation of a nested SafePointScalarMergeNode. This is caused by the\n+    \/\/ store barrier corresponding to 'C.other = B'.\n+    @IR(applyIf = {\"UseG1GC\", \"false\"}, counts = { IRNode.ALLOC, \"1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -182,1 +182,3 @@\n-                                                              \"-XX:NonNMethodCodeHeapSize=5M\",\n+                                                              \/\/ After fixing a round_down issue with large page sizes (JDK-8334564),\n+                                                              \/\/ 5M is a bit too small for NonNMethodCodeHeap\n+                                                              \"-XX:NonNMethodCodeHeapSize=6M\",\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,639 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.gcbarriers;\n+\n+import compiler.lib.ir_framework.*;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.concurrent.ThreadLocalRandom;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that G1 barriers are generated and optimized as expected.\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.G1\n+ * @run driver compiler.gcbarriers.TestG1BarrierGeneration\n+ *\/\n+\n+public class TestG1BarrierGeneration {\n+    static final String PRE_ONLY = \"pre\";\n+    static final String POST_ONLY = \"post\";\n+    static final String POST_ONLY_NOT_NULL = \"post notnull\";\n+    static final String PRE_AND_POST = \"pre post\";\n+    static final String PRE_AND_POST_NOT_NULL = \"pre post notnull\";\n+\n+    static class Outer {\n+        Object f;\n+    }\n+\n+    static class OuterWithVolatileField {\n+        volatile Object f;\n+    }\n+\n+    static class OuterWithFewFields implements Cloneable {\n+        Object f1;\n+        Object f2;\n+        public Object clone() throws CloneNotSupportedException {\n+            return super.clone();\n+        }\n+    }\n+\n+    static class OuterWithManyFields implements Cloneable {\n+        Object f1;\n+        Object f2;\n+        Object f3;\n+        Object f4;\n+        Object f5;\n+        Object f6;\n+        Object f7;\n+        Object f8;\n+        Object f9;\n+        Object f10;\n+        public Object clone() throws CloneNotSupportedException {\n+            return super.clone();\n+        }\n+    }\n+\n+    static final VarHandle fVarHandle;\n+    static {\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        try {\n+            fVarHandle = l.findVarHandle(Outer.class, \"f\", Object.class);\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework();\n+        Scenario[] scenarios = new Scenario[2*2];\n+        int scenarioIndex = 0;\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+                scenarios[scenarioIndex] =\n+                    new Scenario(scenarioIndex,\n+                                 \"-XX:CompileCommand=inline,java.lang.ref.*::*\",\n+                                 \"-XX:\" + (i == 0 ? \"-\" : \"+\") + \"UseCompressedOops\",\n+                                 \"-XX:\" + (j == 0 ? \"-\" : \"+\") + \"ReduceInitialCardMarks\");\n+                scenarioIndex++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static void testStore(Outer o, Object o1) {\n+        o.f = o1;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, PRE_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_STORE_N_WITH_BARRIER_FLAG, PRE_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static void testStoreNull(Outer o) {\n+        o.f = null;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, PRE_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_STORE_N_WITH_BARRIER_FLAG, PRE_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static void testStoreObfuscatedNull(Outer o, Object o1) {\n+        Object o2 = o1;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                o2 = null;\n+            }\n+        }\n+        \/\/ o2 is null here, but this is only known to C2 after applying some\n+        \/\/ optimizations (loop unrolling, IGVN).\n+        o.f = o2;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, PRE_AND_POST_NOT_NULL, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, PRE_AND_POST_NOT_NULL, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static void testStoreNotNull(Outer o, Object o1) {\n+        if (o1.hashCode() == 42) {\n+            return;\n+        }\n+        o.f = o1;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, PRE_AND_POST, \"2\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, PRE_AND_POST, \"2\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static void testStoreTwice(Outer o, Outer p, Object o1) {\n+        o.f = o1;\n+        p.f = o1;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static void testStoreVolatile(OuterWithVolatileField o, Object o1) {\n+        o.f = o1;\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_P},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_N, IRNode.G1_ENCODE_P_AND_STORE_N},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static Outer testStoreOnNewObject(Object o1) {\n+        Outer o = new Outer();\n+        o.f = o1;\n+        return o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_P, IRNode.STORE_N},\n+        phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+    public static Outer testStoreNullOnNewObject() {\n+        Outer o = new Outer();\n+        o.f = null;\n+        return o;\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, POST_ONLY_NOT_NULL, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, POST_ONLY_NOT_NULL, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_P},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_N, IRNode.G1_ENCODE_P_AND_STORE_N},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static Outer testStoreNotNullOnNewObject(Object o1) {\n+        if (o1.hashCode() == 42) {\n+            return null;\n+        }\n+        Outer o = new Outer();\n+        o.f = o1;\n+        return o;\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, POST_ONLY, \"2\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, POST_ONLY, \"2\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_P},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_N, IRNode.G1_ENCODE_P_AND_STORE_N},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static Outer testStoreOnNewObjectInTwoPaths(Object o1, boolean c) {\n+        Outer o;\n+        if (c) {\n+            o = new Outer();\n+            o.f = o1;\n+        } else {\n+            o = new Outer();\n+            o.f = o1;\n+        }\n+        return o;\n+    }\n+\n+    @Run(test = {\"testStore\",\n+                 \"testStoreNull\",\n+                 \"testStoreObfuscatedNull\",\n+                 \"testStoreNotNull\",\n+                 \"testStoreTwice\",\n+                 \"testStoreVolatile\",\n+                 \"testStoreOnNewObject\",\n+                 \"testStoreNullOnNewObject\",\n+                 \"testStoreNotNullOnNewObject\",\n+                 \"testStoreOnNewObjectInTwoPaths\"})\n+    public void runStoreTests() {\n+        {\n+            Outer o = new Outer();\n+            Object o1 = new Object();\n+            testStore(o, o1);\n+            Asserts.assertEquals(o1, o.f);\n+        }\n+        {\n+            Outer o = new Outer();\n+            testStoreNull(o);\n+            Asserts.assertNull(o.f);\n+        }\n+        {\n+            Outer o = new Outer();\n+            Object o1 = new Object();\n+            testStoreObfuscatedNull(o, o1);\n+            Asserts.assertNull(o.f);\n+        }\n+        {\n+            Outer o = new Outer();\n+            Object o1 = new Object();\n+            testStoreNotNull(o, o1);\n+            Asserts.assertEquals(o1, o.f);\n+        }\n+        {\n+            Outer o = new Outer();\n+            Outer p = new Outer();\n+            Object o1 = new Object();\n+            testStoreTwice(o, p, o1);\n+            Asserts.assertEquals(o1, o.f);\n+            Asserts.assertEquals(o1, p.f);\n+        }\n+        {\n+            OuterWithVolatileField o = new OuterWithVolatileField();\n+            Object o1 = new Object();\n+            testStoreVolatile(o, o1);\n+            Asserts.assertEquals(o1, o.f);\n+        }\n+        {\n+            Object o1 = new Object();\n+            Outer o = testStoreOnNewObject(o1);\n+            Asserts.assertEquals(o1, o.f);\n+        }\n+        {\n+            Outer o = testStoreNullOnNewObject();\n+            Asserts.assertNull(o.f);\n+        }\n+        {\n+            Object o1 = new Object();\n+            Outer o = testStoreNotNullOnNewObject(o1);\n+            Asserts.assertEquals(o1, o.f);\n+        }\n+        {\n+            Object o1 = new Object();\n+            Outer o = testStoreOnNewObjectInTwoPaths(o1, ThreadLocalRandom.current().nextBoolean());\n+            Asserts.assertEquals(o1, o.f);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static void testArrayStore(Object[] a, int index, Object o1) {\n+        a[index] = o1;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, PRE_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_STORE_N_WITH_BARRIER_FLAG, PRE_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static void testArrayStoreNull(Object[] a, int index) {\n+        a[index] = null;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, PRE_AND_POST_NOT_NULL, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, PRE_AND_POST_NOT_NULL, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static void testArrayStoreNotNull(Object[] a, int index, Object o1) {\n+        if (o1.hashCode() == 42) {\n+            return;\n+        }\n+        a[index] = o1;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, PRE_AND_POST, \"2\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, PRE_AND_POST, \"2\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static void testArrayStoreTwice(Object[] a, Object[] b, int index, Object o1) {\n+        a[index] = o1;\n+        b[index] = o1;\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_P},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_N, IRNode.G1_ENCODE_P_AND_STORE_N},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static Object[] testStoreOnNewArray(Object o1) {\n+        Object[] a = new Object[10];\n+        \/\/ The index needs to be concrete for C2 to detect that it is safe to\n+        \/\/ remove the pre-barrier.\n+        a[4] = o1;\n+        return a;\n+    }\n+\n+    @Run(test = {\"testArrayStore\",\n+                 \"testArrayStoreNull\",\n+                 \"testArrayStoreNotNull\",\n+                 \"testArrayStoreTwice\",\n+                 \"testStoreOnNewArray\"})\n+    public void runArrayStoreTests() {\n+        {\n+            Object[] a = new Object[10];\n+            Object o1 = new Object();\n+            testArrayStore(a, 4, o1);\n+            Asserts.assertEquals(o1, a[4]);\n+        }\n+        {\n+            Object[] a = new Object[10];\n+            testArrayStoreNull(a, 4);\n+            Asserts.assertNull(a[4]);\n+        }\n+        {\n+            Object[] a = new Object[10];\n+            Object o1 = new Object();\n+            testArrayStoreNotNull(a, 4, o1);\n+            Asserts.assertEquals(o1, a[4]);\n+        }\n+        {\n+            Object[] a = new Object[10];\n+            Object[] b = new Object[10];\n+            Object o1 = new Object();\n+            testArrayStoreTwice(a, b, 4, o1);\n+            Asserts.assertEquals(o1, a[4]);\n+            Asserts.assertEquals(o1, b[4]);\n+        }\n+        {\n+            Object o1 = new Object();\n+            Object[] a = testStoreOnNewArray(o1);\n+            Asserts.assertEquals(o1, a[4]);\n+        }\n+    }\n+\n+    @Test\n+    public static Object[] testCloneArrayOfObjects(Object[] a) {\n+        Object[] a1 = null;\n+        try {\n+            a1 = a.clone();\n+        } catch (Exception e) {}\n+        return a1;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_P, IRNode.G1_STORE_N, IRNode.G1_ENCODE_P_AND_STORE_N},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"ReduceInitialCardMarks\", \"false\", \"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, POST_ONLY, \"2\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"ReduceInitialCardMarks\", \"false\", \"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_STORE_N_WITH_BARRIER_FLAG, POST_ONLY, \"2\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static OuterWithFewFields testCloneObjectWithFewFields(OuterWithFewFields o) {\n+        Object o1 = null;\n+        try {\n+            o1 = o.clone();\n+        } catch (Exception e) {}\n+        return (OuterWithFewFields)o1;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"ReduceInitialCardMarks\", \"true\"},\n+        counts = {IRNode.CALL_OF, \"jlong_disjoint_arraycopy\", \"1\"})\n+    @IR(applyIf = {\"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.CALL_OF, \"G1BarrierSetRuntime::clone\", \"1\"})\n+    public static OuterWithManyFields testCloneObjectWithManyFields(OuterWithManyFields o) {\n+        Object o1 = null;\n+        try {\n+            o1 = o.clone();\n+        } catch (Exception e) {}\n+        return (OuterWithManyFields)o1;\n+    }\n+\n+    @Run(test = {\"testCloneArrayOfObjects\",\n+                 \"testCloneObjectWithFewFields\",\n+                 \"testCloneObjectWithManyFields\"})\n+    public void runCloneTests() {\n+        {\n+            Object o1 = new Object();\n+            Object[] a = new Object[4];\n+            for (int i = 0; i < 4; i++) {\n+                a[i] = o1;\n+            }\n+            Object[] a1 = testCloneArrayOfObjects(a);\n+            for (int i = 0; i < 4; i++) {\n+                Asserts.assertEquals(o1, a1[i]);\n+            }\n+        }\n+        {\n+            Object a = new Object();\n+            Object b = new Object();\n+            OuterWithFewFields o = new OuterWithFewFields();\n+            o.f1 = a;\n+            o.f2 = b;\n+            OuterWithFewFields o1 = testCloneObjectWithFewFields(o);\n+            Asserts.assertEquals(a, o1.f1);\n+            Asserts.assertEquals(b, o1.f2);\n+        }\n+        {\n+            Object a = new Object();\n+            Object b = new Object();\n+            Object c = new Object();\n+            Object d = new Object();\n+            Object e = new Object();\n+            Object f = new Object();\n+            Object g = new Object();\n+            Object h = new Object();\n+            Object i = new Object();\n+            Object j = new Object();\n+            OuterWithManyFields o = new OuterWithManyFields();\n+            o.f1 = a;\n+            o.f2 = b;\n+            o.f3 = c;\n+            o.f4 = d;\n+            o.f5 = e;\n+            o.f6 = f;\n+            o.f7 = g;\n+            o.f8 = h;\n+            o.f9 = i;\n+            o.f10 = j;\n+            OuterWithManyFields o1 = testCloneObjectWithManyFields(o);\n+            Asserts.assertEquals(a, o1.f1);\n+            Asserts.assertEquals(b, o1.f2);\n+            Asserts.assertEquals(c, o1.f3);\n+            Asserts.assertEquals(d, o1.f4);\n+            Asserts.assertEquals(e, o1.f5);\n+            Asserts.assertEquals(f, o1.f6);\n+            Asserts.assertEquals(g, o1.f7);\n+            Asserts.assertEquals(h, o1.f8);\n+            Asserts.assertEquals(i, o1.f9);\n+            Asserts.assertEquals(j, o1.f10);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_COMPARE_AND_EXCHANGE_P_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_COMPARE_AND_EXCHANGE_N_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    static Object testCompareAndExchange(Outer o, Object oldVal, Object newVal) {\n+        return fVarHandle.compareAndExchange(o, oldVal, newVal);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_COMPARE_AND_SWAP_N_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    static boolean testCompareAndSwap(Outer o, Object oldVal, Object newVal) {\n+        return fVarHandle.compareAndSet(o, oldVal, newVal);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_GET_AND_SET_P_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_GET_AND_SET_N_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    static Object testGetAndSet(Outer o, Object newVal) {\n+        return fVarHandle.getAndSet(o, newVal);\n+    }\n+\n+    @Run(test = {\"testCompareAndExchange\",\n+                 \"testCompareAndSwap\",\n+                 \"testGetAndSet\"})\n+    public void runAtomicTests() {\n+        {\n+            Outer o = new Outer();\n+            Object oldVal = new Object();\n+            o.f = oldVal;\n+            Object newVal = new Object();\n+            Object oldVal2 = testCompareAndExchange(o, oldVal, newVal);\n+            Asserts.assertEquals(oldVal, oldVal2);\n+            Asserts.assertEquals(o.f, newVal);\n+        }\n+        {\n+            Outer o = new Outer();\n+            Object oldVal = new Object();\n+            o.f = oldVal;\n+            Object newVal = new Object();\n+            boolean b = testCompareAndSwap(o, oldVal, newVal);\n+            Asserts.assertTrue(b);\n+            Asserts.assertEquals(o.f, newVal);\n+        }\n+        {\n+            Outer o = new Outer();\n+            Object oldVal = new Object();\n+            o.f = oldVal;\n+            Object newVal = new Object();\n+            Object oldVal2 = testGetAndSet(o, newVal);\n+            Asserts.assertEquals(oldVal, oldVal2);\n+            Asserts.assertEquals(o.f, newVal);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_LOAD_P_WITH_BARRIER_FLAG, PRE_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_LOAD_N_WITH_BARRIER_FLAG, PRE_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    static Object testLoadSoftReference(SoftReference<Object> ref) {\n+        return ref.get();\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_LOAD_P_WITH_BARRIER_FLAG, PRE_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_LOAD_N_WITH_BARRIER_FLAG, PRE_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    static Object testLoadWeakReference(WeakReference<Object> ref) {\n+        return ref.get();\n+    }\n+\n+    @Run(test = {\"testLoadSoftReference\",\n+                 \"testLoadWeakReference\"})\n+    public void runReferenceTests() {\n+        {\n+            Object o1 = new Object();\n+            SoftReference<Object> sref = new SoftReference<Object>(o1);\n+            Object o2 = testLoadSoftReference(sref);\n+            Asserts.assertTrue(o2 == o1 || o2 == null);\n+        }\n+        {\n+            Object o1 = new Object();\n+            WeakReference<Object> wref = new WeakReference<Object>(o1);\n+            Object o2 = testLoadWeakReference(wref);\n+            Asserts.assertTrue(o2 == o1 || o2 == null);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestG1BarrierGeneration.java","additions":639,"deletions":0,"binary":false,"changes":639,"status":"added"},{"patch":"@@ -361,0 +361,5 @@\n+    public static final String CALL_OF = COMPOSITE_PREFIX + \"CALL_OF\" + POSTFIX;\n+    static {\n+        callOfNodes(CALL_OF, \"Call.*\");\n+    }\n+\n@@ -584,0 +589,86 @@\n+    public static final String G1_COMPARE_AND_EXCHANGE_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_COMPARE_AND_EXCHANGE_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1CompareAndExchangeN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_COMPARE_AND_EXCHANGE_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_COMPARE_AND_EXCHANGE_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_COMPARE_AND_EXCHANGE_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1CompareAndExchangeP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_COMPARE_AND_EXCHANGE_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_COMPARE_AND_SWAP_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_COMPARE_AND_SWAP_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1CompareAndSwapN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_COMPARE_AND_SWAP_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1CompareAndSwapP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_ENCODE_P_AND_STORE_N = PREFIX + \"G1_ENCODE_P_AND_STORE_N\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(G1_ENCODE_P_AND_STORE_N, \"g1EncodePAndStoreN\");\n+    }\n+\n+    public static final String G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1EncodePAndStoreN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_GET_AND_SET_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_GET_AND_SET_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1GetAndSetN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_GET_AND_SET_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_GET_AND_SET_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_GET_AND_SET_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1GetAndSetP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_GET_AND_SET_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_LOAD_N = PREFIX + \"G1_LOAD_N\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(G1_LOAD_N, \"g1LoadN\");\n+    }\n+\n+    public static final String G1_LOAD_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_LOAD_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1LoadN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_LOAD_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_LOAD_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_LOAD_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1LoadP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_LOAD_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_STORE_N = PREFIX + \"G1_STORE_N\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(G1_STORE_N, \"g1StoreN\");\n+    }\n+\n+    public static final String G1_STORE_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_STORE_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1StoreN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_STORE_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_STORE_P = PREFIX + \"G1_STORE_P\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(G1_STORE_P, \"g1StoreP\");\n+    }\n+\n+    public static final String G1_STORE_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_STORE_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1StoreP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_STORE_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n@@ -855,0 +946,5 @@\n+    public static final String MACH_TEMP = PREFIX + \"MACH_TEMP\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(MACH_TEMP, \"MachTemp\");\n+    }\n+\n@@ -1151,0 +1247,6 @@\n+    public static final String OOPMAP_WITH = COMPOSITE_PREFIX + \"OOPMAP_WITH\" + POSTFIX;\n+    static {\n+        String regex = \"(#\\\\s*OopMap\\\\s*\\\\{.*\" + IS_REPLACED + \".*\\\\})\";\n+        optoOnly(OOPMAP_WITH, regex);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8320308\n+ * @summary Unsafe::getShortUnaligned with base null hidden behind CheckCastPP nodes\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=quiet -XX:TypeProfileLevel=222\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *      -XX:CompileCommand=compileonly,compiler.parsing.TestUnsafeArrayAccessWithNullBase::test*\n+ *      -XX:-TieredCompilation compiler.parsing.TestUnsafeArrayAccessWithNullBase\n+ * @run main compiler.parsing.TestUnsafeArrayAccessWithNullBase\n+ *\/\n+\n+package compiler.parsing;\n+\n+import java.lang.reflect.*;\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestUnsafeArrayAccessWithNullBase {\n+\n+    \/*\n+    Trigger bug when handling Unsafe.getShortUnaligned with null checks and inlined methods.\n+    The bug appears when the method is incrementally inlined and optimized based on the argument profile information.\n+\n+    Warmup Phase: By warming up with non-null values, the argument profile for the helper methods records non-null types.\n+        - insert CheckCastPP: speculative=byte[int:>=0] for return of getSmall\/getLarge\n+        - insert CheckCastPP: speculative=byte[int:>=0] for argument `Object array` in helperSmall\/helperLarge\n+    Trigger Phase: Calling test causes LibraryCallKit::inline_unsafe_access(..) for Unsafe::getShortUnaligned to fail:\n+        Reason: UNSAFE.getShortUnaligned(array, offset) is called with array=null,\n+        but ConP null is now hidden by two CheckCastPP with speculative=byte[int:>=0] in the graph\n+    *\/\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    private static final Object byteArray = new byte[1_050_000];\n+\n+    public static Object getLarge(boolean useNull) {\n+        return useNull ? null : byteArray;\n+    }\n+\n+    public static Object getSmall(boolean useNull) {\n+        return useNull ? null : new byte[10];\n+    }\n+\n+    \/\/ use a helper to delay inlining of UNSAFE.getShortUnaligned\n+    public static int helperLarge(Object array, boolean run) {\n+        \/\/ offset >= os::vm_page_size(): LibraryCallKit::classify_unsafe_addr returns Type::AnyPtr\n+        return run ? UNSAFE.getShortUnaligned(array, 1_049_000) : 0; \/\/ after warmup CheckCastPP: speculative=byte[int:>=0]\n+    }\n+\n+    public static int accessLargeArray(boolean useNull, boolean run) {\n+        Object array = getLarge(useNull); \/\/ after warmup CheckCastPP: speculative=byte[int:>=0]\n+        \/\/ getLarge() ensures null is only visible after helperLarge was (incrementally) inlined\n+        return helperLarge(array, run);\n+    }\n+\n+    \/\/ use a helper to delay inlining of UNSAFE.getShortUnaligned\n+    \/\/ warmup adds argument profile information for array: CheckCastPP with type non null\n+    public static int helperSmall(Object array, boolean run) {\n+        \/\/ 0 <= offset < os::vm_page_size():  LibraryCallKit::classify_unsafe_addr returns Type::OopPtr\n+        return run ? UNSAFE.getShortUnaligned(array, 1) : 0; \/\/ after warmup CheckCastPP: speculative=byte[int:>=0]\n+    }\n+\n+    public static int accessSmallArray(boolean useNull, boolean run) {\n+        Object array = getSmall(useNull); \/\/ after warmup CheckCastPP: speculative=byte[int:>=0]\n+        return helperSmall(array, run);\n+    }\n+\n+    public static int test1(boolean run) {\n+        return accessLargeArray(true, run);\n+    }\n+\n+    public static int test2(boolean run) {\n+        return accessSmallArray(true, run);\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup to collect speculative types\n+        for (int i = 0; i < 10_000; i++) {\n+            accessLargeArray(false, true);\n+            accessSmallArray(false, true);\n+        }\n+\n+        \/\/ Trigger Compilation\n+        for (int i = 0; i < 10_000; ++i) {\n+            test1(false);\n+            test2(false);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/parsing\/TestUnsafeArrayAccessWithNullBase.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.runtime.safepoints;\n+\n+import compiler.lib.ir_framework.*;\n+import java.lang.ref.SoftReference;\n+\n+\/**\n+ * @test\n+ * @summary Test that undefined values generated by MachTemp nodes (in this\n+ *          case, derived from G1 barriers) are not included in OopMaps.\n+ *          Extracted from java.lang.invoke.LambdaFormEditor::getInCache.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.G1 & vm.bits == 64 & vm.opt.final.UseCompressedOops == true\n+ * @run driver compiler.runtime.safepoints.TestMachTempsAcrossSafepoints\n+ *\/\n+\n+public class TestMachTempsAcrossSafepoints {\n+\n+    static class RefWithKey extends SoftReference<Object> {\n+        final int key;\n+\n+        public RefWithKey(int key) {\n+            super(new Object());\n+            this.key = key;\n+        }\n+\n+        @DontInline\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof RefWithKey that && this.key == that.key;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String inlineCmd = \"-XX:CompileCommand=inline,java.lang.ref.SoftReference::get\";\n+        TestFramework.runWithFlags(inlineCmd, \"-XX:+StressGCM\", \"-XX:+StressLCM\", \"-XX:StressSeed=1\");\n+        TestFramework.runWithFlags(inlineCmd, \"-XX:+StressGCM\", \"-XX:+StressLCM\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.G1_LOAD_N, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.MACH_TEMP, \">= 1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.STATIC_CALL_OF_METHOD, \"equals\", \"2\"})\n+    @IR(failOn = {IRNode.OOPMAP_WITH, \"NarrowOop\"})\n+    static private Object test(RefWithKey key, RefWithKey[] refs) {\n+        RefWithKey k = null;\n+        \/\/ This loop causes the register allocator to not \"rematerialize\" all\n+        \/\/ MachTemp nodes generated for the reference g1LoadN instruction below.\n+        for (int i = 0; i < refs.length; i++) {\n+            RefWithKey k0 = refs[0];\n+            if (k0.equals(key)) {\n+                k = k0;\n+            }\n+        }\n+        if (k != null && !key.equals(k)) {\n+            return null;\n+        }\n+        \/\/ The MachTemp node implementing the dst TEMP operand in the g1LoadN\n+        \/\/ instruction corresponding to k.get() can be scheduled across the\n+        \/\/ above call to RefWithKey::equals(), due to an unfortunate interaction\n+        \/\/ of inaccurate basic block frequency estimation (emulated in this test\n+        \/\/ by randomizing the GCM and LCM heuristics) and call-catch cleanup.\n+        \/\/ Since narrow pointer MachTemp nodes are typed as narrow OOPs, this\n+        \/\/ causes the oopmap builder to include the MachTemp node definition in\n+        \/\/ the RefWithKey::equals() return oopmap.\n+        return (k != null) ? k.get() : null;\n+    }\n+\n+    @Run(test = \"test\")\n+    @Warmup(0)\n+    public void run() {\n+        RefWithKey ref = new RefWithKey(42);\n+        test(ref, new RefWithKey[]{ref});\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/safepoints\/TestMachTempsAcrossSafepoints.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -41,0 +41,3 @@\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n@@ -44,0 +47,2 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n@@ -45,0 +50,1 @@\n+import java.util.Optional;\n@@ -47,0 +53,1 @@\n+import java.util.regex.Pattern;\n@@ -63,0 +70,25 @@\n+    private static final String UID = \"uid\";\n+    private static final String GID = \"gid\";\n+\n+    private static final Pattern ID_PATTERN = Pattern.compile(\"uid=(?<\" + UID + \">\\\\d+)\\\\([^\\\\)]+\\\\)\\\\s+gid=(?<\" + GID + \">\\\\d+).*\");\n+\n+    private static final Optional<String> USER = ProcessHandle.current().info().user().map(\n+            user -> {\n+                try (var br = new BufferedReader(new InputStreamReader(new ProcessBuilder(\"id\", user).start().getInputStream()))) {\n+                    for (final var line : br.lines().toList()) {\n+                        final var m = ID_PATTERN.matcher(line);\n+\n+                        if (m.matches()) {\n+                            return \"--user=\" + m.group(UID) + \":\" + m.group(GID);\n+                        }\n+                    }\n+                } catch (IOException e) {\n+                    \/\/ do nothing...\n+                }\n+\n+                return null;\n+            }\n+    );\n+\n+    private static final String NET_BIND_SERVICE = \"--cap-add=NET_BIND_SERVICE\";\n+\n@@ -71,16 +103,19 @@\n-            \/\/ Start the loop process in the \"main\" container, then run test cases\n-            \/\/ using a sidecar container.\n-            MainContainer mainContainer = new MainContainer();\n-            mainContainer.start();\n-            mainContainer.waitForMainMethodStart(TIME_TO_WAIT_FOR_MAIN_METHOD_START);\n-\n-            long mainProcPid = testCase01();\n-\n-            \/\/ Excluding the test case below until JDK-8228850 is fixed\n-            \/\/ JDK-8228850: jhsdb jinfo fails with ClassCastException:\n-            \/\/ s.j.h.oops.TypeArray cannot be cast to s.j.h.oops.Instance\n-            \/\/ mainContainer.assertIsAlive();\n-            \/\/ testCase02(mainProcPid);\n-\n-            mainContainer.assertIsAlive();\n-            testCase03(mainProcPid);\n+            for (final boolean elevated : USER.isPresent() ? new Boolean[] { false, true } : new Boolean[] { false }) {\n+                \/\/ Start the loop process in the \"main\" container, then run test cases\n+                \/\/ using a sidecar container.\n+                MainContainer mainContainer = new MainContainer();\n+                mainContainer.start(elevated);\n+                mainContainer.waitForMainMethodStart(TIME_TO_WAIT_FOR_MAIN_METHOD_START);\n+\n+                for (AttachStrategy attachStrategy : EnumSet.allOf(AttachStrategy.class)) {\n+                    long mainProcPid = testCase01(attachStrategy, elevated);\n+\n+                    \/\/ Excluding the test case below until JDK-8228850 is fixed\n+                    \/\/ JDK-8228850: jhsdb jinfo fails with ClassCastException:\n+                    \/\/ s.j.h.oops.TypeArray cannot be cast to s.j.h.oops.Instance\n+                    \/\/ mainContainer.assertIsAlive();\n+                    \/\/ testCase02(mainProcPid, attachStrategy, elevated);\n+\n+                    mainContainer.assertIsAlive();\n+                    testCase03(mainProcPid, attachStrategy, elevated);\n+                }\n@@ -88,1 +123,2 @@\n-            mainContainer.waitForAndCheck(TIME_TO_RUN_MAIN_PROCESS * 1000);\n+                mainContainer.waitForAndCheck(TIME_TO_RUN_MAIN_PROCESS * 1000);\n+            }\n@@ -96,2 +132,2 @@\n-    private static long testCase01() throws Exception {\n-        OutputAnalyzer out = runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"-l\")\n+    private static long testCase01(AttachStrategy attachStrategy, boolean elevated) throws Exception {\n+        OutputAnalyzer out = runSideCar(MAIN_CONTAINER_NAME, attachStrategy, elevated, \"\/jdk\/bin\/jcmd\", \"-l\")\n@@ -102,1 +138,1 @@\n-            throw new RuntimeException(\"Could not find specified process\");\n+            throw new RuntimeException(attachStrategy + \": Could not find specified process\");\n@@ -109,2 +145,2 @@\n-    private static void testCase02(long pid) throws Exception {\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jhsdb\", \"jinfo\", \"--pid\", \"\" + pid)\n+    private static void testCase02(long pid, AttachStrategy attachStrategy, boolean elevated) throws Exception {\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, elevated, \"\/jdk\/bin\/jhsdb\", \"jinfo\", \"--pid\", \"\" + pid)\n@@ -118,2 +154,2 @@\n-    private static void testCase03(long pid) throws Exception {\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"help\")\n+    private static void testCase03(long pid, AttachStrategy attachStrategy, boolean elevated) throws Exception {\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, elevated, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"help\")\n@@ -122,1 +158,1 @@\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"JFR.start\")\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, elevated, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"JFR.start\")\n@@ -130,6 +166,8 @@\n-    \/\/ buffers in \/tmp directory (hsperfdata_<user>). Thus, in sidecar\n-    \/\/ we mount \/tmp via --volumes-from from the main container.\n-    private static OutputAnalyzer runSideCar(String mainContainerName, String whatToRun,\n-                                             String... args) throws Exception {\n-        List<String> cmd = new ArrayList<>();\n-        String[] command = new String[] {\n+    \/\/ buffers in \/tmp directory (hsperfdata_<user>). Thus, in the sidecar\n+    \/\/ we have two options:\n+    \/\/ 1. mount \/tmp from the main container using --volumes-from.\n+    \/\/ 2. access \/tmp from the main container via \/proc\/<pid>\/root\/tmp.\n+    private static OutputAnalyzer runSideCar(String mainContainerName, AttachStrategy attachStrategy, boolean elevated,  String whatToRun, String... args) throws Exception {\n+        System.out.println(\"Attach strategy \" + attachStrategy);\n+\n+        List<String> initialCommands = List.of(\n@@ -139,3 +177,6 @@\n-            \"--pid=container:\" + mainContainerName,\n-            \"--volumes-from\", mainContainerName,\n-            IMAGE_NAME, whatToRun\n+            \"--pid=container:\" + mainContainerName\n+        );\n+\n+        List<String> attachStrategyCommands = switch (attachStrategy) {\n+            case TMP_MOUNTED_INTO_SIDECAR -> List.of(\"--volumes-from\", mainContainerName);\n+            case ACCESS_TMP_VIA_PROC_ROOT -> List.of();\n@@ -144,1 +185,11 @@\n-        cmd.addAll(Arrays.asList(command));\n+        List<String> elevatedOpts = elevated && USER.isPresent() ? List.of(NET_BIND_SERVICE, USER.get()) : Collections.emptyList();\n+\n+        List<String> imageAndCommand = List.of(\n+            IMAGE_NAME, whatToRun\n+        );\n+\n+        List<String> cmd = new ArrayList<>();\n+        cmd.addAll(initialCommands);\n+        cmd.addAll(elevatedOpts);\n+        cmd.addAll(attachStrategyCommands);\n+        cmd.addAll(imageAndCommand);\n@@ -191,1 +242,1 @@\n-        public Process start() throws Exception {\n+        public Process start(final boolean elevated) throws Exception {\n@@ -194,0 +245,6 @@\n+\n+            if (elevated && USER.isPresent()) {\n+                opts.addDockerOpts(USER.get());\n+                opts.addDockerOpts(NET_BIND_SERVICE);\n+            }\n+\n@@ -244,1 +301,1 @@\n-                    System.out.println(\"IllegalThreadStateException occured when calling exitValue()\");\n+                    System.out.println(\"IllegalThreadStateException occurred when calling exitValue()\");\n@@ -256,0 +313,4 @@\n+    private enum AttachStrategy {\n+        TMP_MOUNTED_INTO_SIDECAR,\n+        ACCESS_TMP_VIA_PROC_ROOT\n+    }\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmdWithSideCar.java","additions":98,"deletions":37,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/*\n+ * @test TestAllocateHeapAtWithHugeTLBFS\n+ * @requires vm.gc.ZGenerational & os.family == \"linux\"\n+ * @summary Test ZGC with -XX:AllocateHeapAt and -XX:+UseLargePages\n+ * @library \/test\/lib\n+ * @run driver gc.z.TestAllocateHeapAtWithHugeTLBFS true\n+ * @run driver gc.z.TestAllocateHeapAtWithHugeTLBFS false\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.Path;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.Scanner;\n+\n+public class TestAllocateHeapAtWithHugeTLBFS {\n+    static String find_hugetlbfs_mountpoint() {\n+        Pattern pat = Pattern.compile(\"\\\\d+ \\\\d+ \\\\d+:\\\\d+ \\\\S+ (\\\\S+) [^-]*- hugetlbfs (.+)\");\n+        try (Scanner scanner = new Scanner(new File(\"\/proc\/self\/mountinfo\"))) {\n+            while (scanner.hasNextLine()) {\n+                final Matcher mat = pat.matcher(scanner.nextLine());\n+                if (mat.matches() && mat.group(2).contains(\"pagesize=2M\")) {\n+                    final Path path = Paths.get(mat.group(1));\n+                    if (Files.isReadable(path) &&\n+                        Files.isWritable(path) &&\n+                        Files.isExecutable(path)) {\n+                        \/\/ Found a usable mount point.\n+                        return path.toString();\n+                    }\n+                }\n+            }\n+        } catch (FileNotFoundException e) {\n+            System.out.println(\"Could not open \/proc\/self\/mountinfo\");\n+        }\n+        return null;\n+    }\n+    public static void main(String[] args) throws Exception {\n+        final boolean exists = Boolean.parseBoolean(args[0]);\n+        final String directory = exists ? find_hugetlbfs_mountpoint()\n+                                        : \"non-existing-directory\";\n+        if (directory == null) {\n+            throw new SkippedException(\"No valid hugetlbfs mount point found\");\n+        }\n+        final String heapBackingFile = \"Heap Backing File: \" + directory;\n+        final String failedToCreateFile = \"Failed to create file \" + directory;\n+\n+        ProcessTools.executeTestJava(\n+            \"-XX:+UseZGC\",\n+            \"-XX:+ZGenerational\",\n+            \"-Xlog:gc*\",\n+            \"-Xms32M\",\n+            \"-Xmx32M\",\n+            \"-XX:+UseLargePages\",\n+            \"-XX:AllocateHeapAt=\" + directory,\n+            \"-version\")\n+                .shouldContain(exists ? heapBackingFile : failedToCreateFile)\n+                .shouldNotContain(exists ? failedToCreateFile : heapBackingFile)\n+                .shouldHaveExitValue(exists ? 0 : 1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestAllocateHeapAtWithHugeTLBFS.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -150,1 +150,2 @@\n-                unsafe.copySwapMemory(null, mapAddr + pageSize, new byte[4000], 16, 2000, 2);\n+                int destOffset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+                unsafe.copySwapMemory(null, mapAddr + pageSize, new byte[4000], destOffset, 2000, 2);\n","filename":"test\/hotspot\/jtreg\/runtime\/Unsafe\/InternalErrorTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Classes used by CDS at runtime should be in the archived\n+ * @bug 8324259\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/Hello.java\n+ * @run driver DumpRuntimeClassesTest\n+ *\/\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+\n+public class DumpRuntimeClassesTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ build The app\n+        String appClass = \"Hello\";\n+        String classList = \"hello.classlist\";\n+        String archiveName = \"hello.jsa\";\n+        JarBuilder.build(\"hello\", appClass);\n+        String appJar = TestCommon.getTestJar(\"hello.jar\");\n+\n+        \/\/ Dump class list\n+        CDSTestUtils.dumpClassList(classList, \"-cp\", appJar, appClass);\n+\n+        \/\/ Dump archive\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-cp\", appJar, \"-XX:SharedClassListFile=\" + classList)\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchive(opts);\n+\n+        \/\/ Run with archive and ensure all the classes used were in the archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", appJar, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(appClass);\n+        CDSTestUtils.runWithArchive(runOpts)\n+            .shouldNotContain(\"source: jrt:\/java.base\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/DumpRuntimeClassesTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/* Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verifies that CDS works with jar located in directories\n+ *          with names that need escaping\n+ * @bug 8339460\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile mypackage\/Main.java mypackage\/Another.java\n+ * @run main\/othervm ComplexURITest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Platform;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class ComplexURITest {\n+    final static String moduleName = \"mymodule\";\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"test.noclasspath\", \"true\");\n+        String jarFile = JarBuilder.build(moduleName, \"mypackage\/Main\", \"mypackage\/Another\");\n+\n+        Path subDir = Path.of(\".\", \"dir with space\");\n+        Files.createDirectory(subDir);\n+        Path newJarFilePath = subDir.resolve(moduleName + \".jar\");\n+        Files.move(Path.of(jarFile), newJarFilePath);\n+        jarFile = newJarFilePath.toString();\n+\n+        final String listFileName = \"test-classlist.txt\";\n+        final String staticArchiveName = \"test-static.jsa\";\n+        final String dynamicArchiveName = \"test-dynamic.jsa\";\n+\n+        \/\/ Verify static archive creation and use\n+        File fileList = new File(listFileName);\n+        delete(fileList.toPath());\n+        File staticArchive = new File(staticArchiveName);\n+        delete(staticArchive.toPath());\n+\n+        createClassList(jarFile, listFileName);\n+        if (!fileList.exists()) {\n+            throw new RuntimeException(\"No class list created at \" + fileList);\n+        }\n+\n+        createArchive(jarFile, listFileName, staticArchiveName);\n+        if (!staticArchive.exists()) {\n+            throw new RuntimeException(\"No shared classes archive created at \" + staticArchive);\n+        }\n+\n+        useArchive(jarFile, staticArchiveName);\n+\n+        \/\/ Verify dynamic archive creation and use\n+        File dynamicArchive = new File(dynamicArchiveName);\n+        delete(dynamicArchive.toPath());\n+\n+        createDynamicArchive(jarFile, dynamicArchiveName);\n+        if (!dynamicArchive.exists()) {\n+            throw new RuntimeException(\"No dynamic archive created at \" + dynamicArchive);\n+        }\n+\n+        testDynamicArchive(jarFile, dynamicArchiveName);\n+    }\n+\n+    private static void delete(Path path) throws Exception {\n+        if (Files.exists(path)) {\n+            if (Platform.isWindows()) {\n+                Files.setAttribute(path, \"dos:readonly\", false);\n+            }\n+            Files.delete(path);\n+        }\n+    }\n+\n+    private static void createClassList(String jarFile, String list) throws Exception {\n+        String[] launchArgs  = {\n+                \"-XX:DumpLoadedClassList=\" + list,\n+                \"--module-path\",\n+                jarFile,\n+                \"--module\",\n+                moduleName + \"\/mypackage.Main\"};\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"create-list\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    private static void createArchive(String jarFile, String list, String archive) throws Exception {\n+        String[] launchArgs  = {\n+                \"-Xshare:dump\",\n+                \"-XX:SharedClassListFile=\" + list,\n+                \"-XX:SharedArchiveFile=\" + archive,\n+                \"--module-path\",\n+                jarFile,\n+                \"--module\",\n+                moduleName + \"\/mypackage.Main\"};\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dump-archive\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    private static void useArchive(String jarFile, String archive) throws Exception {\n+        String[] launchArgs  = {\n+                \"-Xshare:on\",\n+                \"-XX:SharedArchiveFile=\" + archive,\n+                \"--module-path\",\n+                jarFile,\n+                \"--module\",\n+                moduleName + \"\/mypackage.Main\"};\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"use-archive\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    private static void createDynamicArchive(String jarFile, String archive) throws Exception {\n+        String[] launchArgs  = {\n+                \"-XX:ArchiveClassesAtExit=\" + archive,\n+                \"--module-path\",\n+                jarFile,\n+                \"--module\",\n+                moduleName + \"\/mypackage.Main\"};\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dynamic-archive\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testDynamicArchive(String jarFile, String archive) throws Exception {\n+        String[] launchArgs  = {\n+                \"-XX:SharedArchiveFile=\" + archive,\n+                \"-XX:+PrintSharedArchiveAndExit\",\n+                \"--module-path\",\n+                jarFile,\n+                \"--module\",\n+                moduleName + \"\/mypackage.Main\"};\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dynamic-archive\");\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(\"archive is valid\");\n+        output.shouldContain(\": mypackage.Main app_loader\");\n+        output.shouldContain(\": mypackage.Another unregistered_loader\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/complexURI\/ComplexURITest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/* Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package mypackage;\n+\n+public class Another {\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/complexURI\/mypackage\/Another.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/* Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package mypackage;\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+\n+public class Main {\n+    public static void main(String[] args) throws Exception {\n+        URL url1 = Main.class.getProtectionDomain().getCodeSource().getLocation();\n+        System.out.println(\"Will load Another from \" + url1);\n+        ClassLoader cl = URLClassLoader.newInstance(new URL[] { url1 }, null);\n+        var anotherClass = cl.loadClass(\"mypackage.Another\");\n+        System.out.println(\"Class \" + anotherClass + \" loaded successfully\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/complexURI\/mypackage\/Main.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -216,2 +216,4 @@\n-            .assertAbnormalExit(output -> {\n-                output.shouldMatch(\"Error: non-empty directory.*com.simple\");\n+            \/\/ After JDK-8328313, non-empty module path directory won't be included\n+            \/\/ in the shared paths table.\n+            .assertNormalExit(output -> {\n+                output.shouldNotMatch(\"Error: non-empty directory.*com.simple\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/MainModuleOnly.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -197,2 +197,4 @@\n-        output.shouldHaveExitValue(1)\n-              .shouldMatch(\"Error: non-empty directory.*com.simple\");\n+        \/\/ After JDK-8328313, non-empty module path directory won't be included\n+        \/\/ in the shared paths table.\n+        output.shouldHaveExitValue(0)\n+              .shouldNotMatch(\"Error: non-empty directory.*com.simple\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/MainModuleOnly.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,385 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8328313\n+ * @requires vm.cds & !vm.graal.enabled & vm.cds.write.archived.java.heap\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @run driver ModulePathAndFMG\n+ * @summary test module path changes for full module graph handling.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ModulePathAndFMG {\n+    private static final String JAVA_HOME = System.getProperty(\"java.home\");\n+\n+    private static final Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n+\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+\n+    private static final Path SRC_DIR = Paths.get(TEST_SRC, \"src\");\n+    private static final Path MODS_DIR = Paths.get(\"mody\");\n+    private static final Path JMOD_DIR = Paths.get(\"jmod_dir\");\n+\n+    \/\/ the module name of the test module\n+    private static final String MAIN_MODULE = \"com.bars\";\n+    private static final String TEST_MODULE = \"com.foos\";\n+    private static final String DUP_MODULE = \"com.foos3\";\n+\n+    \/\/ the module main class\n+    private static final String MAIN_CLASS = \"com.bars.Main\";\n+    private static final String TEST_CLASS = \"com.foos.Test\";\n+\n+    private static String PATH_LIBS = \"modylibs\";\n+    private static String DUP_LIBS = \"duplibs\";\n+    private static Path libsDir = null;\n+    private static Path dupDir = null;\n+    private static Path jmodDir = null;\n+    private static Path mainJar = null;\n+    private static Path testJar = null;\n+    private static Path dupJar = null;\n+    private static Path badJar = null;\n+\n+    private static String CLASS_FOUND_MESSAGE = \"com.foos.Test found\";\n+    private static String CLASS_NOT_FOUND_MESSAGE = \"java.lang.ClassNotFoundException: com.foos.Test\";\n+    private static String FIND_EXCEPTION_MESSAGE = \"java.lang.module.FindException: Module com.foos not found, required by com.bars\";\n+    private static String MODULE_NOT_RECOGNIZED = \"Module format not recognized:.*modylibs.*com.bars.JAR\";\n+    private static String OPTIMIZE_ENABLED = \"] optimized module handling: enabled\";\n+    private static String OPTIMIZE_DISABLED = \"] optimized module handling: disabled\";\n+    private static String FMG_ENABLED = \"] full module graph: enabled\";\n+    private static String FMG_DISABLED = \"] full module graph: disabled\";\n+    private static String MAIN_FROM_JAR = \"class,load.*com.bars.Main.*[.]jar\";\n+    private static String MAIN_FROM_CDS = \"class,load.*com.bars.Main.*shared objects file\";\n+    private static String MAIN_FROM_MODULE = \"class,load.*com.bars.Main.*mody\/com.bars\";\n+    private static String TEST_FROM_JAR = \"class,load.*com.foos.Test.*[.]jar\";\n+    private static String TEST_FROM_CDS = \"class,load.*com.foos.Test.*shared objects file\";\n+    private static String MAP_FAILED  = \"Unable to use shared archive\";\n+    private static String PATH_SEPARATOR = File.pathSeparator;\n+    private static String appClasses[] = {MAIN_CLASS, TEST_CLASS};\n+    private static String prefix[] = {\"-Djava.class.path=\", \"-Xlog:cds,class+load,class+path=info\"};\n+\n+    public static void buildTestModule() throws Exception {\n+\n+        \/\/ javac -d mods\/$TESTMODULE src\/$TESTMODULE\/**\n+        JarBuilder.compileModule(SRC_DIR.resolve(TEST_MODULE),\n+                                 MODS_DIR.resolve(TEST_MODULE),\n+                                 null);\n+\n+        \/\/ javac -d mods\/$TESTMODULE --module-path MOD_DIR src\/$TESTMODULE\/**\n+        JarBuilder.compileModule(SRC_DIR.resolve(MAIN_MODULE),\n+                                 MODS_DIR.resolve(MAIN_MODULE),\n+                                 MODS_DIR.toString());\n+\n+        libsDir = Files.createTempDirectory(USER_DIR, PATH_LIBS);\n+        mainJar = libsDir.resolve(MAIN_MODULE + \".jar\");\n+        testJar = libsDir.resolve(TEST_MODULE + \".jar\");\n+\n+        \/\/ modylibs contains both modules com.foos.jar, com.bars.jar\n+        \/\/ build com.foos.jar\n+        String classes = MODS_DIR.resolve(TEST_MODULE).toString();\n+        JarBuilder.createModularJar(testJar.toString(), classes, TEST_CLASS);\n+\n+        \/\/ build com.bars.jar\n+        classes = MODS_DIR.resolve(MAIN_MODULE).toString();\n+        JarBuilder.createModularJar(mainJar.toString(), classes, MAIN_CLASS);\n+\n+        dupDir = Files.createTempDirectory(USER_DIR, DUP_LIBS);\n+        dupJar = dupDir.resolve(DUP_MODULE + \".jar\");\n+        Files.copy(testJar, dupJar, StandardCopyOption.REPLACE_EXISTING);\n+\n+        badJar = libsDir.resolve(MAIN_MODULE + \".JAR\");\n+        Files.copy(mainJar, badJar, StandardCopyOption.REPLACE_EXISTING);\n+    }\n+\n+    public static void buildJmod() throws Exception {\n+        Path jmod = Paths.get(JAVA_HOME, \"bin\", \"jmod\");\n+        jmodDir = Files.createDirectory(Paths.get(USER_DIR.toString() + File.separator + JMOD_DIR.toString()));\n+        OutputAnalyzer output = ProcessTools.executeProcess(jmod.toString(),\n+                       \"create\",\n+                       \"--class-path\", Paths.get(USER_DIR.toString(), MODS_DIR.toString(), TEST_MODULE).toString(),\n+                       \"--module-version\", \"1.0\",\n+                       \"--main-class\", TEST_CLASS,\n+                       jmodDir.toString() + File.separator + TEST_MODULE + \".jmod\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        runWithModulePath();\n+        runWithExplodedModule();\n+        runWithJmodAndBadJar();\n+    }\n+\n+    private static void tty(String... args) {\n+        for (String s : args) {\n+            System.out.print(s + \" \");\n+        }\n+        System.out.print(\"\\n\");\n+    }\n+\n+    public static void runWithModulePath() throws Exception {\n+        \/\/ compile the modules and create the modular jar files\n+        buildTestModule();\n+        \/\/ create an archive with the classes in the modules built in the\n+        \/\/ previous step\n+        OutputAnalyzer output = TestCommon.createArchive(\n+                                        null, appClasses,\n+                                        \"--module-path\",\n+                                        libsDir.toString(),\n+                                        \"-m\", MAIN_MODULE);\n+        TestCommon.checkDump(output);\n+\n+        tty(\"1. run with CDS on, with module path same as dump time\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 libsDir.toString(), \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+\n+        tty(\"2. run with CDS on, with jar on path\");\n+        TestCommon.run(\"-Xlog:cds\",\n+                       \"-Xlog:class+load\",\n+                       \"-cp\", mainJar.toString() + PATH_SEPARATOR + testJar.toString(),\n+                       MAIN_CLASS)\n+            .assertNormalExit(out -> {\n+                out.shouldContain(CLASS_FOUND_MESSAGE)\n+                   .shouldMatch(MAIN_FROM_JAR)\n+                   .shouldMatch(TEST_FROM_JAR)\n+                   .shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED);\n+            });\n+\n+        tty(\"3. run with CDS on, with --module-path, with jar should fail\");\n+        TestCommon.run(\"-Xlog:cds\",\n+                       \"-Xlog:class+load\",\n+                       \"-p\", libsDir.toString(),\n+                       \"-cp\", mainJar.toString(),\n+                       MAIN_CLASS)\n+            .assertNormalExit(out -> {\n+                out.shouldContain(CLASS_NOT_FOUND_MESSAGE)\n+                   .shouldMatch(MAIN_FROM_JAR)\n+                   .shouldNotContain(FMG_ENABLED)\n+                   .shouldNotContain(OPTIMIZE_ENABLED);\n+            });\n+\n+        final String modularJarPath = mainJar.toString() + PATH_SEPARATOR + testJar.toString();\n+\n+        tty(\"4. run with CDS on, with modular jars specified --module-path, should pass\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 modularJarPath,     \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldMatch(MAIN_FROM_CDS);       \/\/ archived Main class is for module only\n+            });\n+\n+        final String extraModulePath = libsDir.toString() + PATH_SEPARATOR + dupDir.toString();\n+        \/\/ create an archive with an extra module which is not referenced\n+        output = TestCommon.createArchive(\n+                                        null, appClasses,\n+                                        \"--module-path\",\n+                                        extraModulePath,\n+                                        \"-m\", MAIN_MODULE);\n+        TestCommon.checkDump(output);\n+\n+        tty(\"5. run with CDS on, without the extra module specified in dump time, should pass\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 libsDir.toString(), \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+        tty(\"6. run with CDS on, with the extra module specified in dump time\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 extraModulePath,    \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+\n+        final String extraJarPath = modularJarPath + PATH_SEPARATOR + dupJar.toString();\n+\n+        \/\/ create an archive by specifying modular jars in the --module-path with an extra module which is not referenced\n+        output = TestCommon.createArchive(\n+                                        null, appClasses,\n+                                        \"--module-path\",\n+                                        extraJarPath,\n+                                        \"-m\", MAIN_MODULE);\n+        TestCommon.checkDump(output);\n+        tty(\"7. run with CDS on, without the extra module specified in dump time, should pass\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 modularJarPath,     \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+\n+        tty(\"8. run with CDS on, with the extra module specified in dump time\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 extraJarPath,       \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+        tty(\"9. same as test case 8 but with paths instead of modular jars in the --module-path\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 extraModulePath,    \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+    }\n+\n+    public static void runWithExplodedModule() throws Exception {\n+        \/\/ create an archive with an exploded module in the module path.\n+        OutputAnalyzer output = TestCommon.createArchive(\n+                                        null, appClasses,\n+                                        \"--module-path\",\n+                                        MODS_DIR.toString(),\n+                                        \"-m\", MAIN_MODULE + \"\/\" + MAIN_CLASS);\n+        TestCommon.checkDump(output);\n+\n+        tty(\"10. run with CDS on, with exploded module in the module path\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 MODS_DIR.toString(), \/\/ --module-path\n+                                 MAIN_MODULE + \"\/\" + MAIN_CLASS)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldContain(FMG_DISABLED)\n+                   .shouldMatch(MAIN_FROM_MODULE) \/\/ Main class loaded from the exploded module\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+    }\n+\n+    public static void runWithJmodAndBadJar() throws Exception {\n+        buildJmod();\n+\n+        final String modularJarPath = mainJar.toString() + PATH_SEPARATOR + testJar.toString();\n+        \/\/ create an archive with --module-path com.bars.jar:com.foos.jar\n+        OutputAnalyzer output = TestCommon.createArchive(\n+                                    null, appClasses,\n+                                    \"--module-path\",\n+                                    modularJarPath,\n+                                    \"-m\", MAIN_MODULE);\n+        TestCommon.checkDump(output);\n+\n+        String runModulePath = mainJar.toString() + PATH_SEPARATOR +\n+            jmodDir.toString() + TEST_MODULE + \".jmod\";\n+        tty(\"11. run with CDS on, with module path com.bars.jar:com.foos.jmod\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 runModulePath, \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertAbnormalExit(out -> {\n+                out.shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED)\n+                   .shouldContain(FIND_EXCEPTION_MESSAGE);\n+            });\n+\n+        runModulePath += PATH_SEPARATOR + testJar.toString();\n+        tty(\"12. run with CDS on, with module path com.bars.jar:com.foos.jmod:com.foos.jar\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 runModulePath, \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldMatch(TEST_FROM_CDS)\n+                   .shouldMatch(MAIN_FROM_CDS)\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+\n+        runModulePath = badJar.toString() + PATH_SEPARATOR + testJar.toString();\n+        tty(\"13. run with CDS on, with module path com.bars.JAR:com.foos.jar\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 runModulePath, \/\/ --module-path\n+                                 TEST_MODULE)        \/\/ -m\n+            .assertAbnormalExit(out -> {\n+                out.shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED)\n+                   .shouldMatch(MODULE_NOT_RECOGNIZED);\n+            });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndFMG.java","additions":385,"deletions":0,"binary":false,"changes":385,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.cds & !vm.graal.enabled\n+ * @requires vm.cds & !vm.graal.enabled & vm.cds.write.archived.java.heap\n@@ -67,2 +67,2 @@\n-    private static String OPTIMIZE_ENABLED = \"optimized module handling: enabled\";\n-    private static String OPTIMIZE_DISABLED = \"optimized module handling: disabled\";\n+    private static String OPTIMIZE_ENABLED = \"] optimized module handling: enabled\";\n+    private static String OPTIMIZE_DISABLED = \"] optimized module handling: disabled\";\n@@ -157,1 +157,1 @@\n-        String prefix[] = {\"-Djava.class.path=\", \"-Xlog:cds\", \"-Xlog:class+load\"};\n+        String prefix[] = {\"-Djava.class.path=\", \"-Xlog:cds,class+load,class+path=info\"};\n@@ -163,2 +163,2 @@\n-                out.shouldNotContain(OPTIMIZE_ENABLED)\n-                   .shouldContain(OPTIMIZE_DISABLED)\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n@@ -177,2 +177,2 @@\n-                   .shouldContain(OPTIMIZE_DISABLED)\n-                   .shouldNotContain(OPTIMIZE_ENABLED);\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(OPTIMIZE_DISABLED);\n@@ -234,1 +234,0 @@\n-                   .shouldContain(OPTIMIZE_DISABLED)           \/\/ mapping info\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -307,1 +307,4 @@\n-                \"-XX:StressSeed=\" + rng.nextInt(Integer.MAX_VALUE)));\n+                \"-XX:StressSeed=\" + rng.nextInt(Integer.MAX_VALUE),\n+                \/\/ Do not fail on huge methods where StressGCM makes register\n+                \/\/ allocation allocate lots of memory\n+                \"-XX:CompileCommand=memlimit,*.*,0\"));\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/CtwRunner.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-        log = new Log(System.out, verbose);\n+        log = new Log(System.out);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/escape\/LockElision\/MatMul\/MatMul.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-        \/\/log.enableVerbose(true);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/LaunchingConnector\/launchnosuspend\/launchnosuspend001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-        log.enableVerbose(true);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateThroughHeap\/filter_tagged\/HeapFilter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-        log.enableVerbose(true);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isCollectionUsageThresholdExceeded\/isexceeded001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-        log.enableVerbose(true); \/\/ show log output\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-        Log log = new Log(System.out, true);\n+        Log log = new Log(System.out);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.Enumeration;\n@@ -39,1 +38,0 @@\n-import nsk.share.test.LazyFormatString;\n@@ -42,6 +40,1 @@\n- * This class helps to print test-execution trace messages\n- * and filter them when execution mode is not verbose.\n- * <p>\n- * Verbose mode if defined by providing <i>-verbose<\/i> command line\n- * option, handled by <code>ArgumentParser<\/code>. Use <code>verbose()<\/code>\n- * method to determine which mode is used.\n+ * This class helps to print test-execution trace messages.\n@@ -63,1 +56,0 @@\n- * @see #verbose()\n@@ -75,12 +67,0 @@\n-    \/**\n-     * Is log-mode verbose?\n-     * Always enabled.\n-     *\/\n-    private final boolean verbose = true;\n-\n-    \/**\n-     * Should log messages prefixed with timestamps?\n-     * Always enabled.\n-     *\/\n-    private final boolean timestamp = true;\n-\n@@ -191,10 +171,0 @@\n-     * either for verbose or for non-verbose mode accordingly to\n-     * the given <code>verbose<\/code> key.\n-     *\/\n-    public Log(PrintStream stream, boolean verbose) {\n-        this(stream);\n-    }\n-\n-    \/**\n-     * Incarnate new Log for the given <code>stream<\/code>; and\n-     * either for verbose or for non-verbose mode accordingly to\n@@ -204,1 +174,1 @@\n-        this(stream, argsParser.verbose());\n+        this(stream);\n@@ -210,16 +180,0 @@\n-    \/**\n-     * Return <i>true<\/i> if log mode is verbose.\n-     *\/\n-    public boolean verbose() {\n-        return verbose;\n-    }\n-\n-    \/**\n-     * Enable or disable verbose mode for printing messages.\n-     *\/\n-    public void enableVerbose(boolean enable) {\n-        if (!enable) {\n-            throw new RuntimeException(\"The non-verbose logging is not supported.\");\n-        }\n-    }\n-\n@@ -269,3 +223,0 @@\n-        if (!verbose()) {\n-            keepLog(composeLine(message));\n-        }\n@@ -285,3 +236,0 @@\n-        if (!verbose()) {\n-            doPrint(message);\n-        }\n@@ -317,4 +265,1 @@\n-     * Print <code>message<\/code> to the assigned output stream,\n-     * if log mode is verbose. The <code>message<\/code> will be lost,\n-     * if execution mode is non-verbose, and there is no error messages\n-     * printed.\n+     * Print <code>message<\/code> to the assigned output stream.\n@@ -323,5 +268,1 @@\n-        if (verbose()) {\n-            doPrint(message.toString());\n-        } else {\n-            keepLog(composeLine(message.toString()));\n-        }\n+        doPrint(message.toString());\n@@ -336,9 +277,0 @@\n-        if (!verbose()) {\n-            PrintStream stream = findOutStream();\n-            stream.println(\"#>  \");\n-            stream.println(\"#>  WARNING: switching log to verbose mode,\");\n-            stream.println(\"#>      because error is complained\");\n-            stream.println(\"#>  \");\n-            stream.flush();\n-            enableVerbose(true);\n-        }\n@@ -409,4 +341,1 @@\n-     * Redirect log to the given <code>stream<\/code>, and switch\n-     * log mode to verbose.\n-     * Prints errors summary to current stream, cancel current stream\n-     * and switches to new stream. Turns on verbose mode for new stream.\n+     * Redirect log to the given <code>stream<\/code>.\n@@ -433,14 +362,0 @@\n-    \/**\n-     * Print all messages from log buffer which were hidden because\n-     * of non-verbose mode,\n-     *\/\n-    private synchronized void flushLogBuffer() {\n-        if (!logBuffer.isEmpty()) {\n-            PrintStream stream = findOutStream();\n-            for (int i = 0; i < logBuffer.size(); i++) {\n-                stream.println(logBuffer.elementAt(i));\n-            }\n-            stream.flush();\n-        }\n-    }\n-\n@@ -471,12 +386,9 @@\n-        if (timestamp) {\n-            long time = System.currentTimeMillis();\n-            long ms = time % 1000;\n-            time \/= 1000;\n-            long secs = time % 60;\n-            time \/= 60;\n-            long mins = time % 60;\n-            time \/= 60;\n-            long hours = time % 24;\n-            return \"[\" + hours + \":\" + mins + \":\" + secs + \".\" + ms + \"] \" + message;\n-        }\n-        return message;\n+        long time = System.currentTimeMillis();\n+        long ms = time % 1000;\n+        time \/= 1000;\n+        long secs = time % 60;\n+        time \/= 60;\n+        long mins = time % 60;\n+        time \/= 60;\n+        long hours = time % 24;\n+        return \"[\" + hours + \":\" + mins + \":\" + secs + \".\" + ms + \"] \" + message;\n@@ -516,7 +428,0 @@\n-    \/**\n-     * Keep the given log <code>message<\/code> into <code>logBuffer<\/code>.\n-     *\/\n-    private synchronized void keepLog(String message) {\n-        logBuffer.addElement(message);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/Log.java","additions":14,"deletions":109,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-        log = new Log(System.out, true);\n+        log = new Log(System.out);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/aod\/AODTestRunner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-        log = new Log(System.out, true);\n+        log = new Log(System.out);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/aod\/AbstractJarAgent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    protected Log log = new Log(System.out, true);\n+    protected Log log = new Log(System.out);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/aod\/DummyTargetApplication.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-            log = new Log(System.out, true);\n+            log = new Log(System.out);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/aod\/TargetApplicationWaitingAgents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,0 @@\n-                int referenceSize = getReferenceSize();\n@@ -155,4 +154,2 @@\n-                return (int) Math.min(\n-                                (memory - arrayExtraSize) \/ (objectSize + referenceSize),\n-                                Integer.MAX_VALUE\n-                                );\n+                return (int) Math.min((memory - arrayExtraSize) \/ objectSize,\n+                        Integer.MAX_VALUE);\n@@ -169,1 +166,1 @@\n-                return getObjectExtraSize() + length * (objectSize + getReferenceSize());\n+                return getArrayExtraSize() + length * objectSize;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/Memory.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-                new Log(System.out, true));\n+                new Log(System.out));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/JVMTITest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-        log = new Log(System.out, verbose);\n+        log = new Log(System.out);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/coverage\/parentheses\/Parentheses.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+java\/awt\/Frame\/InitialIconifiedTest.java 8203920 macosx-all,linux-all\n+java\/awt\/Frame\/ShapeNotSetSometimes\/ShapeNotSetSometimes.java 8341370 macosx-all\n@@ -800,0 +802,1 @@\n+java\/awt\/List\/HandlingKeyEventIfMousePressedTest.java 6848358 macosx-all,windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main AbsPathsInImage\n+ * @run main\/othervm -Xmx900m AbsPathsInImage\n","filename":"test\/jdk\/build\/AbsPathsInImage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,0 @@\n- *\n- *\n@@ -18,2 +16,5 @@\n-    \/* to read configuration file in META-INF\/services, and write\/delete .attach_pid<pid> *\/\n-    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write,delete\";\n+    \/* \n+     * To read configuration file in META-INF\/services, write\/delete .attach_pid<pid>, \n+     * and read symbolic link of \/proc\/self\/ns\/mnt.\n+     *\/\n+    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write,delete,readlink\";\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/java.policy.allow","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4530087\n+ * @summary Test if double-clicking causes ActionEvent on underlying button\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual BadActionEventTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+public class BadActionEventTest implements ActionListener {\n+    private static Button showBtn;\n+    private static Button listBtn;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+            1) Click on 'Show File Dialog' to bring up the FileDialog window.\n+            (If necessary, change to a directory with files (not just directories) in it.)\n+            2) Move the FileDialog so that one of the file names (again, a file, NOT a directory) in the list is\n+            directly over the 'ActionListener' button.\n+            3) Double-click on the file name over the button. The FileDialog will disappear.\n+            4) If the 'ActionListener' button receives an ActionEvent, the test fails and a\n+            message to that effect will be printed.\n+            Otherwise, the test passes.\n+            \"\"\";\n+\n+        PassFailJFrame.builder()\n+            .title(\"Test Instructions\")\n+            .instructions(INSTRUCTIONS)\n+            .columns(45)\n+            .testUI(BadActionEventTest::createUI)\n+            .logArea(2)\n+            .build()\n+            .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame frame = new Frame(\"BadActionEventTest\");\n+        frame.setLayout(new GridLayout(1, 2));\n+        frame.setSize(400, 200);\n+        showBtn = new Button(\"Show File Dialog\");\n+        listBtn = new Button(\"ActionListener\");\n+        showBtn.setSize(200, 200);\n+        listBtn.setSize(200, 200);\n+        showBtn.addActionListener(new BadActionEventTest());\n+        listBtn.addActionListener(new BadActionEventTest());\n+        frame.add(showBtn);\n+        frame.add(listBtn);\n+        return frame;\n+    }\n+\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+        if (e.getSource() == showBtn) {\n+            FileDialog fd = new FileDialog(new Frame());\n+            fd.setVisible(true);\n+        } else if (e.getSource() == listBtn) {\n+            listBtn.setBackground(Color.red);\n+            listBtn.setLabel(\"TEST FAILS!\");\n+            PassFailJFrame.log(\"*TEST FAILS!* ActionListener got ActionEvent! *TEST FAILS!*\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Button\/BadActionEventTest\/BadActionEventTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4130788\n+ * @summary Choice components move unexpectedly when in lightweight containers\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ChoiceInLWTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.Container;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ChoiceInLWTest extends Frame implements Runnable {\n+    private final Choice choices;\n+    static final String INSTRUCTIONS = \"\"\"\n+            After test starts wait for two seconds and open a choice.\n+            If choice's popup obscures the label above it press Fail.\n+            Otherwise press Pass.\n+            \"\"\";\n+\n+    public ChoiceInLWTest() {\n+        setLayout(new BorderLayout());\n+        Container lwCont = new Container();\n+        lwCont.setLayout(new FlowLayout());\n+        choices = new Choice();\n+        choices.add(\"This is just a token item to get a nice width.\");\n+        lwCont.add(choices);\n+        add(\"Center\", lwCont);\n+        Label label = new Label(\"You should see an unobscured Choice below.\");\n+        label.setAlignment(Label.CENTER);\n+        add(\"North\", label);\n+        addChoiceItem();\n+        addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowOpened(WindowEvent e) {\n+                super.windowOpened(e);\n+                new Thread(ChoiceInLWTest.this).start();\n+            }\n+        });\n+        pack();\n+    }\n+\n+    private void addChoiceItem() {\n+        choices.add(\"Adding an item used to move the Choice!\");\n+    }\n+\n+    public void run() {\n+        try {\n+            Thread.sleep(1000);\n+        } catch (InterruptedException ignore) {\n+        }\n+        addChoiceItem();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Choice in LW Container Test\")\n+                .testUI(ChoiceInLWTest::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .build()\n+                .awaitAndCheck();\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceInLWTest\/ChoiceInLWTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6367251\n+ * @summary 2 items are highlighted when pressing, dragging the mouse inside the choice, XToolkit\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultiItemSelected_DragOut\n+ *\/\n+\n+import java.awt.Choice;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class MultiItemSelected_DragOut extends Frame {\n+    static final String INSTRUCTIONS = \"\"\"\n+            1) Open Choice.\n+            2) Start drag from first item to second or third one.\n+            3) Without releasing left mouse button\n+               press and release right mouse button.\n+            4) Release left mouse button.\n+            5) Open choice again.\n+            6) If there is only one selection cursor\n+               in the dropdown list press Pass otherwise press Fail.\n+            \"\"\";\n+\n+    public MultiItemSelected_DragOut() {\n+        Choice choice = new Choice();\n+\n+        for (int i = 1; i < 10; i++) {\n+            choice.add(\"item \" + i);\n+        }\n+        add(choice);\n+        choice.addItemListener(ie -> System.out.println(ie));\n+\n+        setLayout(new FlowLayout());\n+        setSize(200, 200);\n+        validate();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"MultiItemSelected Drag Out Test\")\n+                .testUI(MultiItemSelected_DragOut::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/MultiItemSelected\/MultiItemSelected_DragOut.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6367251\n+ * @summary 2 items are highlighted when dragging inside and press ESC or ENTER\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultiItemSelected_KeySelect\n+ *\/\n+\n+import java.awt.Choice;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class MultiItemSelected_KeySelect extends Frame {\n+    static final String INSTRUCTIONS = \"\"\"\n+            1) Open Choice.\n+            2) Start drag from first item to another one.\n+            3) Without releasing the mouse button press ESC key.\n+            4) Open choice again.\n+            5) Verify that there is only one\n+               selection cursor in the dropdown list.\n+            6) Repeat steps 2-5 once again but  this time\n+               press ENTER key instead of ESC.\n+            7) If in both scenarios there is only one selection cursor\n+               press Pass otherwise press Fail.\n+            \"\"\";\n+\n+    public MultiItemSelected_KeySelect() {\n+        Choice choice = new Choice();\n+\n+        for (int i = 1; i < 10; i++) {\n+            choice.add(\"item \" + i);\n+        }\n+        add(choice);\n+        choice.addItemListener(ie -> System.out.println(ie));\n+        setLayout(new FlowLayout());\n+        setSize(200, 200);\n+        validate();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"MultiItemSelected Key Select Test\")\n+                .testUI(MultiItemSelected_KeySelect::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/MultiItemSelected\/MultiItemSelected_KeySelect.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6367251\n+ * @summary 2 items are highlighted when dragging outside and press UP or DOWN\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultiItemSelected_UpDown\n+ *\/\n+\n+import java.awt.Choice;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class MultiItemSelected_UpDown extends Frame {\n+    static final String INSTRUCTIONS = \"\"\"\n+            1) Open Choice.\n+            2) Start drag from first item to another one.\n+            3) Without interrupting drag\n+               move mouse cursor outside the choice popup.\n+            4) Press UP, DOWN key several times to position\n+               selection cursor to a different item.\n+            5) Release mouse button.\n+            6) If popup is closed upon mouse button release open Choice again.\n+            7) Verify that there is only one\n+               selection cursor in the dropdown list.\n+            8) If true then press Pass, otherwise press Fail.\n+            \"\"\";\n+\n+    public MultiItemSelected_UpDown() {\n+        Choice choice = new Choice();\n+\n+        for (int i = 1; i < 20; i++) {\n+            choice.add(\" item \" + i);\n+        }\n+        add(choice);\n+        choice.addItemListener(ie -> System.out.println(ie));\n+        setLayout(new FlowLayout());\n+        setSize(200, 200);\n+        validate();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"MultiItemSelected Up\/Down Test\")\n+                .testUI(MultiItemSelected_UpDown::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/MultiItemSelected\/MultiItemSelected_UpDown.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6292186\n+ * @summary Choice is not refreshed properly when the last item gets removed\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual RepaintAfterRemoveLastItemTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Choice;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class RepaintAfterRemoveLastItemTest extends Frame implements ActionListener {\n+    Choice ch = new Choice();\n+\n+    static final String INSTRUCTIONS = \"\"\"\n+            Press on the 'remove' button after that if the choice does not display\n+            'only item' press Pass. If 'only item' is still displayed press Fail.\n+            \"\"\";\n+\n+    public RepaintAfterRemoveLastItemTest() {\n+        ch.add(\"only item\");\n+        add(ch);\n+\n+        Button b = new Button(\"remove\");\n+        add(b);\n+        b.addActionListener(this);\n+        setLayout(new FlowLayout());\n+        setSize(200, 200);\n+        validate();\n+    }\n+\n+    public void actionPerformed(ActionEvent ae) {\n+        if (ch.getItemCount() != 0) {\n+            ch.remove(0);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Repaint After Remove Test\")\n+                .testUI(RepaintAfterRemoveLastItemTest::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/RepaintAfterRemoveLastItemTest\/RepaintAfterRemoveLastItemTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4148334\n+ * @summary tests that background color is initially set correctly.\n+ * @requires os.family == \"windows\"\n+ * @key headful\n+ * @run main InitialBackgroundSettingTest\n+ *\/\n+import java.awt.Button;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.List;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.Scrollbar;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class InitialBackgroundSettingTest {\n+    Frame frame;\n+    TextField tf;\n+    TextArea ta;\n+    Choice choice;\n+    List list;\n+    Scrollbar bar;\n+    Button button;\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        InitialBackgroundSettingTest test= new InitialBackgroundSettingTest();\n+        try {\n+            EventQueue.invokeAndWait(test::setupGUI);\n+            EventQueue.invokeAndWait(test::test);\n+        } finally {\n+            EventQueue.invokeAndWait(test::dispose);\n+        }\n+    }\n+\n+    public void setupGUI () {\n+        frame = new Frame(\"InitialBackgroundSettingTest frame\");\n+        tf = new TextField(\"I am the TextField\");\n+        ta = new TextArea(\"I am the TextArea\");\n+        choice = new Choice();\n+        list = new List();\n+        bar = new Scrollbar(Scrollbar.HORIZONTAL);\n+        button = new Button(\"I am the button\");\n+        frame.setBackground(Color.red);\n+        frame.setLayout(new GridLayout(7, 1));\n+        frame.add(button);\n+        frame.add(bar);\n+        frame.add(choice);\n+        frame.add(list);\n+        frame.add(tf);\n+        frame.add(ta);\n+        frame.setVisible(true);\n+        frame.setBounds (400, 0, 300, 300);\n+    }\n+\n+    public void test() {\n+        boolean passed = true;\n+        System.out.println(\"Button background color is:\" +\n+                button.getBackground());\n+        if (Color.red.equals(button.getBackground())) {\n+            System.err.println(\"Button background is red\");\n+            passed = false;\n+        }\n+        System.out.println(\"Scrollbar background color is:\" +\n+                bar.getBackground());\n+        if (Color.red.equals(bar.getBackground())) {\n+            System.err.println(\"ScrollBar background is red\");\n+            passed = false;\n+        }\n+        System.out.println(\"Choice background color is:\" +\n+                choice.getBackground());\n+        if (Color.red.equals(choice.getBackground())) {\n+            System.err.println(\"Choice background is red\");\n+            passed = false;\n+        }\n+        System.out.println(\"List background color is:\" +\n+                list.getBackground());\n+        if (Color.red.equals(list.getBackground())) {\n+            System.err.println(\"List background is red\");\n+            passed = false;\n+        }\n+        System.out.println(\"TextField background color is:\" +\n+                tf.getBackground());\n+        if (Color.red.equals(tf.getBackground())) {\n+            System.err.println(\"TextField background is red\");\n+            passed = false;\n+        }\n+        System.out.println(\"TextArea background color is:\" +\n+                ta.getBackground());\n+        if (Color.red.equals(ta.getBackground())) {\n+            System.err.println(\"TextArea background is red\");\n+            passed = false;\n+        }\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"One or more component inherited\" +\n+                    \" background from a Frame\");\n+        }\n+    }\n+\n+    public void dispose() {\n+        frame.dispose();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/BackgroundColorTest\/InitialBackgroundSettingTest.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Scrollbar;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+import java.awt.event.InputEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import jdk.test.lib.Platform;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8333403\n+ * @summary Test performs various operations to check components events are triggered properly.\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main ComponentEventTest\n+ *\/\n+public class ComponentEventTest {\n+\n+    private static final int DELAY = 500;\n+\n+    private static Frame frame;\n+    private static Robot robot;\n+\n+    private static Component[] components;\n+\n+    private static volatile Point centerPoint;\n+\n+    private static volatile boolean componentHidden;\n+    private static volatile boolean componentShown;\n+    private static volatile boolean componentMoved;\n+    private static volatile boolean componentResized;\n+\n+    private static final ComponentListener componentListener =\n+        new ComponentListener() {\n+\n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                System.out.println(\"ComponentShown: \" + e.getSource());\n+                componentShown = true;\n+            }\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                System.out.println(\"ComponentResized: \" + e.getSource());\n+                componentResized = true;\n+            }\n+\n+            @Override\n+            public void componentMoved(ComponentEvent e) {\n+                System.out.println(\"ComponentMoved: \" + e.getSource());\n+                componentMoved = true;\n+            }\n+\n+            @Override\n+            public void componentHidden(ComponentEvent e) {\n+                System.out.println(\"ComponentHidden: \" + e.getSource());\n+                componentHidden = true;\n+            }\n+        };\n+\n+    private static void initializeGUI() {\n+        frame = new Frame(\"Component Event Test\");\n+        frame.setLayout(new FlowLayout());\n+\n+        Panel panel = new Panel();\n+        Button button = new Button(\"Button\");\n+        Label label = new Label(\"Label\");\n+        List list = new List();\n+        list.add(\"One\");\n+        list.add(\"Two\");\n+        list.add(\"Three\");\n+        Choice choice = new Choice();\n+        choice.add(\"Red\");\n+        choice.add(\"Orange\");\n+        choice.add(\"Yellow\");\n+        Checkbox checkbox = new Checkbox(\"Checkbox\");\n+        Scrollbar scrollbar = new Scrollbar(Scrollbar.HORIZONTAL, 0, 1, 0, 255);\n+        TextField textfield = new TextField(15);\n+        TextArea textarea = new TextArea(5, 15);\n+\n+        components = new Component[] { panel, button, label, list, choice,\n+            checkbox, scrollbar, textfield, textarea, frame };\n+\n+        for (int i = 0; i < components.length - 1; i++) {\n+            components[i].addComponentListener(componentListener);\n+            frame.add(components[i]);\n+        }\n+        frame.addComponentListener(componentListener);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+\n+            EventQueue.invokeAndWait(ComponentEventTest::initializeGUI);\n+            robot.waitForIdle();\n+            robot.delay(DELAY);\n+\n+            doTest();\n+\n+            System.out.println(\"Test PASSED\");\n+        } finally {\n+            EventQueue.invokeAndWait(ComponentEventTest::disposeFrame);\n+        }\n+    }\n+\n+    private static void doTest()\n+        throws InvocationTargetException, InterruptedException {\n+        \/\/ Click the frame to ensure it gains focus\n+        clickFrame();\n+\n+        robot.delay(DELAY);\n+\n+        for (int i = 0; i < components.length; i++) {\n+            for (boolean state : new boolean[] { true, false }) {\n+                doTest(components[i], state);\n+            }\n+        }\n+\n+        robot.delay(DELAY);\n+\n+        System.out.println(\"Iconify frame\");\n+        resetValues();\n+        testIconifyFrame();\n+\n+        System.out.println(\"Deiconify frame\");\n+        resetValues();\n+        testDeiconifyFrame();\n+    }\n+\n+    private static void clickFrame()\n+        throws InvocationTargetException, InterruptedException {\n+        EventQueue.invokeAndWait(() -> {\n+            Point location = frame.getLocationOnScreen();\n+            Dimension size = frame.getSize();\n+            centerPoint = new Point(location.x + size.width \/ 2,\n+                location.y + size.height \/ 2);\n+        });\n+\n+        robot.mouseMove(centerPoint.x, centerPoint.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+    }\n+\n+    private static void testIconifyFrame()\n+        throws InvocationTargetException, InterruptedException {\n+        EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.ICONIFIED));\n+\n+        robot.waitForIdle();\n+        robot.delay(DELAY);\n+        if (componentShown || componentHidden || componentMoved\n+            || componentResized) {\n+            throw new RuntimeException(\n+                \"ComponentEvent triggered when frame is iconified\");\n+        }\n+    }\n+\n+    private static void testDeiconifyFrame()\n+        throws InvocationTargetException, InterruptedException {\n+        EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.NORMAL));\n+\n+        robot.waitForIdle();\n+        robot.delay(DELAY);\n+\n+        \/*\n+         * Because of the different behavior between MS Windows and other OS, we\n+         * receive native events WM_SIZE and WM_MOVE on Windows when the frame\n+         * state changes from iconified to normal. AWT sends these events to\n+         * components when it receives the events from the native system. See\n+         * JDK-6754618 for more information.\n+         *\/\n+\n+        if (componentShown || componentHidden) {\n+            throw new RuntimeException(\n+                \"FAIL: componentShown or componentHidden triggered \"\n+                    + \"when frame set to normal\");\n+        }\n+\n+        if (Platform.isWindows() && (!componentMoved || !componentResized)) {\n+            throw new RuntimeException(\n+                \"FAIL: componentMoved or componentResized wasn't triggered \"\n+                    + \"when frame set to normal\");\n+        }\n+        if (!Platform.isWindows() && (componentMoved || componentResized)) {\n+            throw new RuntimeException(\n+                \"FAIL: componentMoved or componentResized triggered \"\n+                    + \"when frame set to normal\");\n+        }\n+    }\n+\n+    private static void doTest(final Component currentComponent, boolean enable)\n+        throws InvocationTargetException, InterruptedException {\n+\n+        System.out.println(\"Component \" + currentComponent);\n+        System.out.println(\"  enabled \" + enable);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setEnabled(enable);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(false);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentHidden) {\n+            throw new RuntimeException(\"FAIL: ComponentHidden not triggered for\"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(false);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (componentHidden) {\n+            throw new RuntimeException(\"FAIL: ComponentHidden triggered when \"\n+                + \"setVisible(false) called for a hidden \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(true);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentShown) {\n+            throw new RuntimeException(\"FAIL: ComponentShown not triggered for \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(true);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (componentShown) {\n+            throw new RuntimeException(\"FAIL: ComponentShown triggered when \"\n+                + \"setVisible(true) called for a shown \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setLocation(currentComponent.getLocation().x + 1,\n+                currentComponent.getLocation().y);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentMoved) {\n+            throw new RuntimeException(\"FAIL: ComponentMoved not triggered for \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setSize(currentComponent.getSize().width + 1,\n+                currentComponent.getSize().height);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentResized) {\n+            throw new RuntimeException(\"FAIL: ComponentResized not triggered \"\n+                + \"when size increases for \" + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setSize(currentComponent.getSize().width - 1,\n+                currentComponent.getSize().height);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentResized) {\n+            throw new RuntimeException(\"FAIL: ComponentResized not triggered \"\n+                + \"when size decreases for \" + currentComponent.getClass());\n+        }\n+\n+        System.out.println(\"\\n\");\n+    }\n+\n+    private static void revalidateFrame() {\n+        frame.invalidate();\n+        frame.validate();\n+    }\n+\n+    private static void resetValues() {\n+        componentShown = false;\n+        componentHidden = false;\n+        componentMoved = false;\n+        componentResized = false;\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/ComponentEventTest.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"},{"patch":"@@ -0,0 +1,769 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family != \"linux\")\n+ * @bug 4119609 4149812 4136116 4171960 4170095 4294016 4343272\n+ * @summary  This test verifies that java.awt objects are being garbage\n+ * collected correctly. That is, it ensures that unneeded\n+ * references (such as JNI global refs or refs in static arrays)\n+ * do not remain after the object is disposed.\n+ * @run main\/othervm ComponentLeakTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.CardLayout;\n+import java.awt.Checkbox;\n+import java.awt.CheckboxGroup;\n+import java.awt.CheckboxMenuItem;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.FileDialog;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.GridLayout;\n+import java.awt.Label;\n+import java.awt.LayoutManager;\n+import java.awt.List;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.MenuShortcut;\n+import java.awt.Panel;\n+import java.awt.PopupMenu;\n+import java.awt.ScrollPane;\n+import java.awt.Scrollbar;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.Window;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.util.Map;\n+import java.util.HashMap;\n+\n+public class ComponentLeakTest {\n+\n+    public static void main(String[] args) {\n+        final int iter = 5;\n+\n+        for(int count = 0; count < iter; count++) {\n+            MainFrame f = new MainFrame();\n+            MainWindow w = new MainWindow(f);\n+            MainDialog d = new MainDialog(f);\n+            TestFileDialog fd = new TestFileDialog(f, \"TestFileDialog\");\n+            fd.addNotify(); \/\/ fd.show() hangs\n+\n+            fd.dispose();\n+            d.dispose();\n+            w.dispose();\n+            f.dispose();\n+        }\n+\n+        \/\/ Test layout managers\n+        Frame border = new Frame();\n+        border.setLayout(new BorderLayout());\n+        Frame card = new Frame();\n+        card.setLayout(new CardLayout());\n+        Frame flow = new Frame();\n+        flow.setLayout(new FlowLayout());\n+        Frame gridBag = new Frame();\n+        gridBag.setLayout(new GridBagLayout());\n+        Frame grid = new Frame();\n+        grid.setLayout(new GridLayout(1, 2));\n+\n+        for (int count = 0; count < iter; count++) {\n+            border.add(new BorderTestButton(\"BorderTest\"),\n+                    BorderLayout.WEST);\n+            border.add(new BorderTestButton(\"BorderTest\"),\n+                    BorderLayout.EAST);\n+            card.add(new CardTestButton(\"CardTest\"), \"card0\");\n+            card.add(new CardTestButton(\"CardTest\"), \"card1\");\n+            flow.add(new FlowTestButton());\n+            flow.add(new FlowTestButton());\n+            gridBag.add(new GridBagTestButton(), new GridBagConstraints());\n+            gridBag.add(new GridBagTestButton(), new GridBagConstraints());\n+            grid.add(new GridTestButton());\n+            grid.add(new GridTestButton());\n+\n+            border.removeAll();\n+            card.removeAll();\n+            flow.removeAll();\n+            gridBag.removeAll();\n+            grid.removeAll();\n+        }\n+\n+        gc(5);\n+        try {\n+            Thread.sleep(1000);\n+        } catch (InterruptedException ie) {\n+        }\n+\n+        freeReferences();\n+        reportLeaks();\n+        System.err.println(\"Test passed.\");\n+    }\n+\n+    public static void initWindow(Window w) {\n+        w.setSize(600, 400);\n+        w.setLayout(new FlowLayout());\n+\n+        \/\/ peered components\n+        w.add(new TestButton(\"Button\"));\n+        w.add(new TestCanvas());\n+        w.add(new TestCheckbox(\"Checkbox\", true));\n+        TestChoice choice = new TestChoice();\n+        choice.add(\"Choice 1\");\n+        choice.add(\"Choice Two\");\n+        w.add(choice);\n+        w.add(new TestLabel(\"Label\"));\n+        TestList list = new TestList();\n+        list.add(\"List 1\");\n+        list.add(\"List Two\");\n+        w.add(list);\n+        w.add(new TestScrollbar(Scrollbar.VERTICAL));\n+        w.add(new TestScrollbar(Scrollbar.HORIZONTAL));\n+        TestScrollPane scrollpane = new TestScrollPane();\n+        scrollpane.add(new TestButton(\"Button in a scrollpane\"));\n+        w.add(scrollpane);\n+        w.add(new TestTextArea(\"TextArea\", 3, 30));\n+        w.add(new TestTextField(\"TextField\"));\n+\n+        \/\/ nested components\n+        TestPanel panel1 = new TestPanel();\n+        panel1.setLayout(new FlowLayout());\n+        panel1.setBackground(Color.red);\n+        w.add(panel1);\n+\n+        panel1.add(new TestButton(\"level 2\"));\n+\n+        Panel panel2 = new Panel();\n+        panel2.setLayout(new FlowLayout());\n+        panel2.setBackground(Color.green);\n+        panel1.add(panel2);\n+\n+        panel2.add(new TestButton(\"level 3\"));\n+\n+        w.add(new TestLightweight(\"Lightweight\"));\n+    }\n+\n+    private static ReferenceQueue queue = new ReferenceQueue();\n+    private static Map<Reference, String> refs = new HashMap<Reference, String>();\n+\n+    public static void register(Object obj) {\n+        PhantomReference ref = new PhantomReference(obj, queue);\n+        refs.put(ref, obj.getClass().getName());\n+    }\n+\n+    private static void gc() {\n+        System.gc();\n+        try {\n+            Thread.sleep(100);\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(\"Test was interrupted\");\n+        }\n+    }\n+\n+    private static void gc(int num) {\n+        for (; num > 0; num--) {\n+            gc();\n+        }\n+    }\n+\n+    public static void freeReferences() {\n+        System.err.println(\"Total references: \" + refs.size());\n+        boolean wasFreed = false;\n+        do {\n+            Object[] arr = new Object[2000];\n+            gc(5);\n+            Reference ref = null;\n+            wasFreed = false;\n+            while ((ref = queue.poll()) != null) {\n+                refs.remove(ref);\n+                wasFreed = true;\n+                gc();\n+            }\n+        } while (wasFreed);\n+    }\n+\n+    public static void reportLeaks() {\n+        for (Reference ref : refs.keySet()) {\n+            System.err.println(\"Leaked \" + refs.get(ref));\n+        }\n+\n+        if (refs.size() > 0) {\n+            throw new RuntimeException(\"Some references remained: \" + refs.size());\n+        }\n+    }\n+}\n+\n+class TestFrame extends Frame {\n+    public TestFrame() {\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestFrame(String title) {\n+        super(title);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestWindow extends Window {\n+    public TestWindow(Frame owner) {\n+        super(owner);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestWindow(Window owner) {\n+        super(owner);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestDialogL extends Dialog {\n+    public TestDialogL(Frame owner) {\n+        super(owner);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestDialogL(Frame owner, boolean modal) {\n+        super(owner, modal);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestDialogL(Frame owner, String title) {\n+        super(owner, title);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestDialogL(Frame owner, String title, boolean modal) {\n+        super(owner, title, modal);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestDialogL(Dialog owner) {\n+        super(owner);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestDialogL(Dialog owner, String title) {\n+        super(owner, title);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestDialogL(Dialog owner, String title, boolean modal) {\n+        super(owner, title, modal);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestFileDialog extends FileDialog {\n+    public TestFileDialog(Frame parent) {\n+        super(parent);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestFileDialog(Frame parent, String title) {\n+        super(parent, title);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestFileDialog(Frame parent, String title, int mode) {\n+        super(parent, title, mode);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestButton extends Button {\n+    public TestButton() {\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestButton(String title) {\n+        super(title);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestCanvas extends Canvas {\n+    int width = 100;\n+    int height = 100;\n+\n+    public TestCanvas() {\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestCanvas(GraphicsConfiguration config) {\n+        super(config);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public void paint(Graphics g) {\n+        g.setColor(Color.blue);\n+        g.fillRoundRect(10, 10, 50, 50, 15, 30);\n+        g.setColor(Color.red);\n+        g.fillOval(70, 70, 25, 25);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(width, height);\n+    }\n+}\n+\n+class TestCheckbox extends Checkbox {\n+    public TestCheckbox() {\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestCheckbox(String label) {\n+        super(label);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestCheckbox(String label, boolean state) {\n+        super(label, state);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestCheckbox(String label, boolean state, CheckboxGroup group) {\n+        super(label, state, group);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestCheckbox(String label, CheckboxGroup group, boolean state) {\n+        super(label, group, state);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestChoice extends Choice {\n+    public TestChoice() {\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestLabel extends Label {\n+    public TestLabel() {\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestLabel(String text) {\n+        super(text);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestLabel(String text, int align) {\n+        super(text, align);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestList extends List {\n+    public TestList() {\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestList(int rows) {\n+        super(rows);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestList(int rows, boolean multipleMode) {\n+        super(rows, multipleMode);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestScrollbar extends Scrollbar {\n+    public TestScrollbar() {\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestScrollbar(int orientation) {\n+        super(orientation);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestScrollbar(int orient, int val, int visible, int min, int max) {\n+        super(orient, val, visible, min, max);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestScrollPane extends ScrollPane {\n+    public TestScrollPane() {\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestScrollPane(int policy) {\n+        super(policy);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestTextField extends TextField {\n+    public TestTextField() {\n+        ComponentLeakTest.register(this);\n+        requestFocus();\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestTextField(String text) {\n+        super(text);\n+        ComponentLeakTest.register(this);\n+        requestFocus();\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestTextField(int columns) {\n+        super(columns);\n+        ComponentLeakTest.register(this);\n+        requestFocus();\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestTextField(String text, int columns) {\n+        super(text, columns);\n+        ComponentLeakTest.register(this);\n+        requestFocus();\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestTextArea extends TextArea {\n+    public TestTextArea() {\n+        ComponentLeakTest.register(this);\n+        requestFocus();\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestTextArea(String text) {\n+        super(text);\n+        ComponentLeakTest.register(this);\n+        requestFocus();\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestTextArea(int rows, int columns) {\n+        super(rows, columns);\n+        ComponentLeakTest.register(this);\n+        requestFocus();\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestTextArea(String text, int rows, int columns) {\n+        super(text, rows, columns);\n+        ComponentLeakTest.register(this);\n+        requestFocus();\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestTextArea(String text, int rows, int columns, int bars) {\n+        super(text, rows, columns, bars);\n+        ComponentLeakTest.register(this);\n+        requestFocus();\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+\n+class TestPanel extends Panel {\n+    public TestPanel() {\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+\n+    public TestPanel(LayoutManager layout) {\n+        super(layout);\n+        ComponentLeakTest.register(this);\n+        setDropTarget(new TestDropTarget(this));\n+    }\n+}\n+class TestMenu extends Menu {\n+    public TestMenu() {\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public TestMenu(String label) {\n+        super(label);\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public TestMenu(String label, boolean tearOff) {\n+        super(label, tearOff);\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class TestMenuItem extends MenuItem {\n+    public TestMenuItem() {\n+        ComponentLeakTest.register(this);\n+    }\n+    public TestMenuItem(String label) {\n+        super(label);\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public TestMenuItem(String label, MenuShortcut s) {\n+        super(label, s);\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class TestMenuBar extends MenuBar {\n+    public TestMenuBar() {\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class TestPopupMenu extends PopupMenu {\n+    public TestPopupMenu() {\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public TestPopupMenu(String label) {\n+        super(label);\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class TestCheckboxMenuItem extends CheckboxMenuItem {\n+    public TestCheckboxMenuItem() {\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public TestCheckboxMenuItem(String label) {\n+        super(label);\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public TestCheckboxMenuItem(String label, boolean state) {\n+        super(label, state);\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class BorderTestButton extends Button {\n+    public BorderTestButton() {\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public BorderTestButton(String title) {\n+        super(title);\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class CardTestButton extends Button {\n+    public CardTestButton() {\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public CardTestButton(String title) {\n+        super(title);\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class FlowTestButton extends Button {\n+    public FlowTestButton() {\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public FlowTestButton(String title) {\n+        super(title);\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class GridBagTestButton extends Button {\n+    public GridBagTestButton() {\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public GridBagTestButton(String title) {\n+        super(title);\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class GridTestButton extends Button {\n+    public GridTestButton() {\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public GridTestButton(String title) {\n+        super(title);\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class TestLightweight extends Component {\n+    String label;\n+    int width = 100;\n+    int height = 30;\n+\n+    public TestLightweight(String label) {\n+        this.label = label;\n+        ComponentLeakTest.register(this);\n+    }\n+\n+    public void paint(Graphics g) {\n+        Dimension d = getSize();\n+        g.setColor(Color.orange);\n+        g.fillRect(0, 0, d.width, d.height);\n+        g.setColor(Color.black);\n+        int x = 5;\n+        int y = (d.height - 5);\n+        g.drawString(label, x, y);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(width,height);\n+    }\n+}\n+\n+class TestDropTarget extends DropTarget {\n+    public TestDropTarget(Component comp) {\n+        super(comp, new DropTargetListener() {\n+            public void dragEnter(DropTargetDragEvent dtde) {}\n+            public void dragOver(DropTargetDragEvent dtde) {}\n+            public void dropActionChanged(DropTargetDragEvent dtde) {}\n+            public void dragExit(DropTargetEvent dte) {}\n+            public void drop(DropTargetDropEvent dtde) {}\n+        });\n+        ComponentLeakTest.register(this);\n+    }\n+}\n+\n+class MainWindow extends TestWindow {\n+    public MainWindow(Frame f) {\n+        super(f);\n+        ComponentLeakTest.initWindow(this);\n+        setVisible(true);\n+\n+        TestPopupMenu popup = new TestPopupMenu(\"hi\");\n+        add(popup);\n+        popup.show(this, 5, 5);\n+    }\n+}\n+\n+class MainDialog extends TestDialogL {\n+    public MainDialog(Frame f) {\n+        super(f, \"MainDialog\", false);\n+        ComponentLeakTest.initWindow(this);\n+        setVisible(true);\n+\n+        TestPopupMenu popup = new TestPopupMenu(\"hi\");\n+        add(popup);\n+        popup.show(this, 5, 5);\n+    }\n+}\n+\n+class MainFrame extends TestFrame {\n+    public MainFrame(){\n+        super(\"Component Leak Test MainFrame\");\n+\n+        ComponentLeakTest.initWindow(this);\n+\n+        TestMenu menu = new TestMenu(\"Print\");\n+        TestMenu menu2 = new TestMenu(\"File\");\n+        TestMenu menu3 = new TestMenu(\"Edit\");\n+        TestMenu menu4 = new TestMenu(\"ReallyReallyReallyReallyReallyReallyReallyReally\" +\n+                \"ReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyLong\");\n+        menu2.setFont(new Font(\"SansSerif\", Font.BOLD, 20));\n+        menu2.setEnabled(false);\n+        menu3.setFont(new Font(\"Monospaced\", Font.ITALIC, 18));\n+        menu3.setEnabled(false);\n+        menu4.setEnabled(false);\n+        TestMenuItem itemPrinter  = new TestMenuItem(\"foobar\");\n+        TestMenuItem itemScreen  = new TestMenuItem(\"baz\");\n+        TestCheckboxMenuItem itemCheck = new TestCheckboxMenuItem(\"yep\");\n+        menu.add(itemPrinter);\n+        menu.add(itemScreen);\n+        menu.add(itemCheck);\n+        TestMenuBar menuBar = new TestMenuBar();\n+        menuBar.add( menu );\n+        menuBar.add( menu2 );\n+        menuBar.add( menu3 );\n+        menuBar.add( menu4 );\n+        setMenuBar(menuBar);\n+\n+        setVisible(true);\n+\n+        TestPopupMenu popup = new TestPopupMenu(\"hi\");\n+        add(popup);\n+        popup.show(this, 5, 5);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/ComponentLeakTest\/ComponentLeakTest.java","additions":769,"deletions":0,"binary":false,"changes":769,"status":"added"},{"patch":"@@ -0,0 +1,354 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4146452\n+ * @summary Tests serialization of peered and lightweight Components.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ComponentSerializationTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Checkbox;\n+import java.awt.CheckboxMenuItem;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FileDialog;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Label;\n+import java.awt.List;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.Panel;\n+import java.awt.ScrollPane;\n+import java.awt.Scrollbar;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.Window;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import javax.swing.JPanel;\n+\n+public class ComponentSerializationTest extends JPanel {\n+    private MainFrame mf;\n+    private MainWindow mw;\n+    private MainDialog md;\n+    private MainFileDialog mfd;\n+    private static final String INSTRUCTIONS = \"\"\"\n+        A Frame, a Window, and a Dialog should appear. From the Frame's\n+        \"Serialize\" menu, select \"Serialize!\". Another Frame, Window, and\n+        Dialog should appear exactly on top of the existing ones. The state\n+        and functionality of the two sets of Windows should be identical. If\n+        any errors or exceptions appear in the log area, or if the second set of\n+        Windows is different from the first, the test fails. Otherwise, the\n+        test passes.\n+    \"\"\";\n+\n+    private static final ArrayList<Window> toDispose = new ArrayList<>();\n+\n+    public ComponentSerializationTest() {\n+        mf = new MainFrame();\n+        toDispose.add(mf);\n+        mw = new MainWindow(mf);\n+        toDispose.add(mw);\n+        md = new MainDialog(mf);\n+        toDispose.add(md);\n+        mfd = new MainFileDialog(mf);\n+        toDispose.add(mfd);\n+    }\n+\n+    public static void main(String[] argc) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Component Serialization Test\")\n+                .splitUI(ComponentSerializationTest::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+        for (Window w : toDispose) {\n+            if (w != null) {\n+                EventQueue.invokeAndWait(w::dispose);\n+            }\n+        }\n+    }\n+\n+    private void initWindow(Window w) {\n+        w.setSize(600, 400);\n+        w.setLayout(new FlowLayout());\n+\n+        \/\/ peered components\n+        w.add(new Button(\"Button\"));\n+        w.add(new TestCanvas());\n+        w.add(new Checkbox(\"Checkbox\", true));\n+        Choice choice = new Choice();\n+        choice.add(\"Choice 1\");\n+        choice.add(\"Choice Two\");\n+        w.add(choice);\n+        w.add(new Label(\"Label\"));\n+        List list = new List();\n+        list.add(\"List 1\");\n+        list.add(\"List Two\");\n+        w.add(list);\n+        w.add(new Scrollbar(Scrollbar.VERTICAL));\n+        w.add(new Scrollbar(Scrollbar.HORIZONTAL));\n+        ScrollPane scrollpane = new ScrollPane();\n+        scrollpane.add(new Button(\"Button in a scrollpane\"));\n+        w.add(scrollpane);\n+        w.add(new TextArea(\"TextArea\", 3, 30));\n+        w.add(new TextField(\"TextField\"));\n+\n+        \/\/ nested components\n+        Panel panel1 = new Panel();\n+        panel1.setLayout(new FlowLayout());\n+        panel1.setBackground(Color.red);\n+        w.add(panel1);\n+\n+        panel1.add(new Button(\"level 2\"));\n+\n+        Panel panel2 = new Panel();\n+        panel2.setLayout(new FlowLayout());\n+        panel2.setBackground(Color.green);\n+        panel1.add(panel2);\n+\n+        panel2.add(new Button(\"level 3\"));\n+\n+        \/\/ lightweight components\n+        w.add(new LWButton(\"LWbutton\") );\n+\n+        \/\/ overlapping components\n+        w.add(new ZOrderPanel());\n+    }\n+\n+    class MainWindow extends Window {\n+        public MainWindow(Frame f) {\n+            super(f);\n+            initWindow(this);\n+            setLocation(650, 0);\n+            setVisible(true);\n+        }\n+    }\n+\n+    class MainDialog extends Dialog {\n+        public MainDialog(Frame f) {\n+            super(f, \"MainDialog\", false);\n+            initWindow(this);\n+            setLocation(0, 450);\n+            setVisible(true);\n+        }\n+    }\n+\n+    class MainFileDialog extends FileDialog {\n+        public MainFileDialog(Frame f) {\n+            super(f, \"MainFileDialog\", FileDialog.SAVE);\n+            setLocation(650, 450);\n+            addNotify();\n+        }\n+    }\n+\n+    class MainFrame extends Frame {\n+        public MainFrame() {\n+            super(\"ComponentSerializationTest\");\n+            initWindow(this);\n+\n+            Menu menu = new Menu(\"Serialize\");\n+            Menu menu2 = new Menu(\"File\");\n+            Menu menu3 = new Menu(\"Edit\");\n+            Menu menu4 = new Menu(\"ReallyReallyReallyReallyReallyReallyReallyReally\" +\n+                    \"ReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyLong\");\n+            menu2.setFont(new Font(\"SansSerif\", Font.BOLD, 20));\n+            menu2.setEnabled(false);\n+            menu3.setFont(new Font(\"Monospaced\", Font.ITALIC, 18));\n+            menu3.setEnabled(false);\n+            menu4.setEnabled(false);\n+            MenuItem itemSerialize  = new MenuItem(\"Serialize!\");\n+            CheckboxMenuItem itemCheck  = new CheckboxMenuItem(\"Check me\");\n+            menu.add(itemSerialize);\n+            menu.add(itemCheck);\n+            MenuBar menuBar = new MenuBar();\n+            menuBar.add(menu);\n+            menuBar.add(menu2);\n+            menuBar.add(menu3);\n+            menuBar.add(menu4);\n+            setMenuBar(menuBar);\n+\n+            itemSerialize.addActionListener(new ActionSerialize());\n+\n+            setLocation(0, 0);\n+            setVisible(true);\n+        }\n+    }\n+\n+    class ActionSerialize implements ActionListener {\n+        public void actionPerformed(ActionEvent ev) {\n+            Frame f2 = null;\n+            Window w2 = null;\n+            Dialog d2 = null;\n+            FileDialog fd2 = null;\n+\n+            try {\n+                FileOutputStream fos = new FileOutputStream(\"tmp\");\n+                ObjectOutputStream oos = new ObjectOutputStream(fos);\n+                oos.writeObject(mf);\n+                oos.writeObject(mw);\n+                oos.writeObject(md);\n+                oos.writeObject(mfd);\n+                oos.flush();\n+\n+                FileInputStream fis = new FileInputStream(\"tmp\");\n+                ObjectInputStream ois = new ObjectInputStream(fis);\n+                f2 = (Frame)ois.readObject();\n+                w2 = (Window)ois.readObject();\n+                d2 = (Dialog)ois.readObject();\n+                fd2= (FileDialog)ois.readObject();\n+            } catch (Exception e) {\n+                PassFailJFrame.log(e.getMessage());\n+            }\n+\n+            if (f2 == null || w2 == null || d2 == null || fd2 == null) {\n+                PassFailJFrame.log(\"ERROR: one of the components was not deserialized.\");\n+                PassFailJFrame.log(\"frame = \" + f2);\n+                PassFailJFrame.log(\"window = \" + w2);\n+                PassFailJFrame.log(\"dialog = \" + d2);\n+                PassFailJFrame.log(\"file dalog = \" + fd2);\n+            }\n+\n+            if (f2 != null) {\n+                toDispose.add(f2);\n+                f2.setVisible(true);\n+            }\n+            if (w2 != null) {\n+                toDispose.add(w2);\n+                w2.setVisible(true);\n+            }\n+            if (d2 != null) {\n+                toDispose.add(d2);\n+                d2.setVisible(true);\n+            }\n+            if (fd2 != null) {\n+                toDispose.add(fd2);\n+                fd2.addNotify();\n+            }\n+        }\n+    }\n+\n+    class LWButton extends Component {\n+        String label;\n+        int width = 100;\n+        int height = 30;\n+\n+        public LWButton(String label) {\n+            super();\n+            this.label = label;\n+        }\n+\n+        public void paint(Graphics g) {\n+            Dimension d = getSize();\n+            g.setColor(Color.orange);\n+            g.fillRect(0, 0, d.width, d.height);\n+            g.setColor(Color.black);\n+            int x = 5;\n+            int y = (d.height - 5);\n+            g.drawString(label, x, y);\n+        }\n+\n+        public Dimension getPreferredSize()     {\n+            return new Dimension(width, height);\n+        }\n+    }\n+\n+    class TestCanvas extends Canvas {\n+        int width = 100;\n+        int height = 100;\n+\n+        public void paint(Graphics g) {\n+            g.setColor(Color.blue);\n+            g.fillRoundRect(10, 10, 50, 50, 15, 30);\n+            g.setColor(Color.red);\n+            g.fillOval(70, 70, 25, 25);\n+        }\n+        public Dimension getPreferredSize() {\n+            return new Dimension(width, height);\n+        }\n+    }\n+\n+    class ZOrderPanel extends Panel {\n+        public ZOrderPanel() {\n+            setLayout(null);\n+\n+            Component first, second, third, fourth;\n+\n+            show();\n+            first = makeBox(\"Second\", Color.blue, -1);\n+            second = makeBox(\"First\", Color.yellow, 0);\n+            fourth = makeBox(\"Fourth\", Color.red, 2);\n+            third = makeBox(\"Third\", Color.green, 3);\n+            remove(third);\n+            add(third, 2);\n+            validate();\n+            add(new LWButton(\"LWButton\"), 0);\n+        }\n+\n+        public Dimension preferredSize() {\n+            return new Dimension(260, 80);\n+        }\n+\n+        public void layout() {\n+            int i, n;\n+            Insets ins = insets();\n+            n = countComponents();\n+            for (i = n - 1; i >= 0; i--) {\n+                Component p = getComponent(i);\n+                p.reshape(ins.left + 40 * i, ins.top + 5 * i, 60, 60);\n+            }\n+        }\n+\n+        public Component makeBox(String s, Color c, int index) {\n+            Label l = new Label(s);\n+            l.setBackground(c);\n+            l.setAlignment(Label.RIGHT);\n+            add(l, index);\n+            validate();\n+            return l;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/ComponentSerializationTest\/ComponentSerializationTest.java","additions":354,"deletions":0,"binary":false,"changes":354,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6347994\n+ * @summary REG: Scrollbar, Choice, Checkbox flickers and grays out when scrolling, XToolkit\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FlickeringOnScroll\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.MenuItem;\n+import java.awt.Panel;\n+import java.awt.PopupMenu;\n+import java.awt.Scrollbar;\n+import java.awt.TextArea;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class FlickeringOnScroll extends Frame {\n+\n+    static final String INSTRUCTIONS = \"\"\"\n+            There are five components in the frame:\n+            Scrollbars(vertical and horizontal), a Choice,\n+            a Checkbox and a TextArea\n+            1) Drag the thumbs of each Scrollbar.\n+            2) Do the same with Choice's scrollbar.\n+            3) Focus on Checkbox and press left mouse button or SPACE repeatedly.\n+            4) Right click inside TextArea and navigate through all menu items\n+               in PopupMenu using the arrow keys.\n+            If you notice some component or its scrollbar flickers on\n+            key\/mouse press or drag, press Fail. Otherwise press Pass.\n+            \"\"\";\n+\n+    public FlickeringOnScroll() {\n+        Choice ch = new Choice();\n+        ch.add(\"Praveen\");\n+        ch.add(\"Mohan\");\n+        ch.add(\"Rakesh\");\n+        ch.add(\"Menon\");\n+        ch.add(\"Girish\");\n+        ch.add(\"Ramachandran\");\n+        ch.add(\"Elancheran\");\n+        ch.add(\"Subramanian\");\n+        ch.add(\"Raju\");\n+        ch.add(\"Pallath\");\n+        ch.add(\"Mayank\");\n+        ch.add(\"Joshi\");\n+        ch.add(\"Sundar\");\n+        ch.add(\"Srinivas\");\n+        ch.add(\"Mandalika\");\n+        Checkbox chb = new Checkbox (\"Checkbox\", false);\n+        TextArea ta = new TextArea(\"Text Area\");\n+        Panel panel = new Panel();\n+        PopupMenu popup = new PopupMenu(\"Popup\");\n+        MenuItem mi1 = new MenuItem(\"mi1\");\n+        MenuItem mi2 = new MenuItem(\"mi2\");\n+        MenuItem mi3 = new MenuItem(\"mi3\");\n+        MenuItem mi4 = new MenuItem(\"mi4\");\n+\n+        setTitle(\"Flickering Scroll Area Testing Frame\");\n+        setLayout(new FlowLayout());\n+        add(ch);\n+        add(chb);\n+        add(ta);\n+\n+        panel.setLayout(new BorderLayout());\n+        panel.setPreferredSize(new Dimension(200, 200));\n+        add(panel);\n+        panel.add(\"Center\",new java.awt.Label(\"Scrollbar flickering test...\" ,java.awt.Label.CENTER));\n+        panel.add(\"South\",new Scrollbar(Scrollbar.HORIZONTAL, 0, 100, 0, 255));\n+        panel.add(\"East\",new Scrollbar(Scrollbar.VERTICAL, 0, 100, 0, 255));\n+\n+        ta.add(popup);\n+        popup.add (mi1);\n+        popup.add (mi2);\n+        popup.add (mi3);\n+        popup.add (mi4);\n+\n+        ta.addMouseListener(new MouseAdapter() {\n+                public void mousePressed(MouseEvent me) {\n+                    if (me.isPopupTrigger()) {\n+                        if (popup != null) {\n+                            popup.show(me.getComponent(), me.getX(), me.getY());\n+                        }\n+                    }\n+                }\n+                public void mouseReleased(MouseEvent me) {\n+                    if (me.isPopupTrigger()) {\n+                        if (popup != null) {\n+                            popup.show(me.getComponent(), me.getX(), me.getY());\n+                        }\n+                    }\n+                }\n+        });\n+\n+        pack();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Scroll Area Flickering Repaint\")\n+                .testUI(FlickeringOnScroll::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/FlickeringOnScroll\/FlickeringOnScroll.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4079435\n+ * @summary Calling repaint() in focus handlers messes up the window.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FocusRepaintTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class FocusRepaintTest extends Frame implements FocusListener {\n+    static final String INSTRUCTIONS = \"\"\"\n+            Hit the tab key repeatedly in the Test window.\n+            If any of the buttons disappear press Fail, otherwise press Pass.\n+            \"\"\";\n+\n+    public FocusRepaintTest() {\n+        setTitle(\"Test\");\n+        setLayout(new FlowLayout());\n+        setSize(200, 100);\n+        Button b1 = new Button(\"Close\");\n+        Button b2 = new Button(\"Button\");\n+        add(b1);\n+        add(b2);\n+        b1.setSize(50, 30);\n+        b2.setSize(50, 30);\n+        b1.addFocusListener(this);\n+        b2.addFocusListener(this);\n+    }\n+\n+    public void focusGained(FocusEvent e) {\n+        Button b = (Button) e.getSource();\n+        PassFailJFrame.log(\"Focus gained for \" + b.getLabel());\n+        b.repaint();\n+    }\n+\n+    public void focusLost(FocusEvent e) {\n+        Button b = (Button) e.getSource();\n+        PassFailJFrame.log(\"Focus lost for \" + b.getLabel());\n+        b.repaint();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Focus Repaint\")\n+                .testUI(FocusRepaintTest::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/FocusRepaintTest\/FocusRepaintTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4185460\n+ * @summary Container list the indentation is 2x the indent param value\n+ * @key headful\n+ * @run main ListDoubleIndentTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+import java.io.PipedInputStream;\n+import java.io.PrintStream;\n+import java.io.PipedOutputStream;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Vector;\n+\n+public class ListDoubleIndentTest {\n+    public static void main(final String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        EventQueue.invokeAndWait(new ListDoubleIndentTest()::performTest);\n+    }\n+\n+    public void performTest() {\n+        boolean bReturn = false;\n+        int iCompCount = 0;\n+        int iNotEqual = 0;\n+        int iIndentWrong = 0;\n+        System.out.println(\"Test: Check indentation\");\n+        Vector v = new Vector();\n+        String sLine;\n+        String sReturn;\n+        String sExpTrim;\n+        Button b1, b2, b3, b4, b5;\n+        Frame f = null;\n+\n+        try {\n+            f = new Frame(\"ListDoubleIndentTest\");\n+\n+            f.add(b1 = new Button(\"North\"), BorderLayout.NORTH, 0);\n+            f.add(b2 = new Button(\"South\"), BorderLayout.SOUTH, 1);\n+            f.add(b3 = new Button(\"East\"), BorderLayout.EAST, 2);\n+            f.add(b4 = new Button(\"West\"), BorderLayout.WEST, 3);\n+            f.add(b5 = new Button(\"Center\"), BorderLayout.CENTER, -1);\n+\n+            String[] sExpected = {f.toString(), b1.toString(), b2.toString(),\n+                    b3.toString(), b4.toString(), b5.toString()};\n+\n+            iCompCount = f.getComponentCount();\n+            System.out.println(\"Component count: \" + iCompCount);\n+\n+            for (int j = 0; j <= 10; j++) {\n+                PipedInputStream pin = new PipedInputStream();\n+                PrintStream output = new PrintStream(new PipedOutputStream(pin), true);\n+                BufferedReader input = new BufferedReader(new InputStreamReader(pin));\n+\n+                f.list(output, j);\n+\n+                output.flush();\n+                output.close();\n+\n+                while ((sLine = input.readLine()) != null) {\n+                    v.addElement(sLine);\n+                }\n+\n+                for (int i = 0; i < v.size(); i++) {\n+                    sReturn = (String)v.elementAt(i);\n+                    sExpTrim = sExpected[i].trim();\n+\n+                    if (!(sExpTrim.equals(sReturn.trim()))) {\n+                        System.out.println(\"iNotEqual\");\n+                        ++iNotEqual;\n+                    }\n+\n+                    int iSpace = sReturn.lastIndexOf(' ') + 1;\n+\n+                    if (i == 0) {\n+                        System.out.println(\"Indent set at: \" + j);\n+                        System.out.println(\"Indent return: \" + iSpace);\n+                        if (iSpace != j) {\n+                            System.out.println(\"iIndentWrong1\");\n+                            ++iIndentWrong;\n+                        }\n+                    } else {\n+                        if (iSpace != (j + 1)) {\n+                            System.out.println(iSpace + \"; \" + j);\n+                            ++iIndentWrong;\n+                        }\n+                    }\n+                    System.out.println(sReturn);\n+                }\n+                v.removeAllElements();\n+                v.trimToSize();\n+            }\n+\n+            if (iNotEqual == 0 && iIndentWrong == 0) {\n+                bReturn = true;\n+            } else {\n+                bReturn = false;\n+            }\n+\n+        } catch(IOException e) {\n+            bReturn = false;\n+            System.out.println (\"Unexpected Exception thrown: \" + e.getMessage());\n+            e.printStackTrace();\n+        } finally {\n+            if (f != null) {\n+                f.dispose();\n+            }\n+        }\n+\n+        if (bReturn) {\n+            System.out.println(\"Test for Container.list Passed\");\n+        } else {\n+            System.out.println(\"Test for Container.list Failed\");\n+            throw new RuntimeException(\"Test FAILED\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/ListDoubleIndentTest\/ListDoubleIndentTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4783989\n+  @summary  get(Preferred|Minimum|Maximum)Size() must not return a reference.\n+  The object copy of Dimension class needed.\n+  @key headful\n+  @run main GetSizesTest\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class GetSizesTest extends Frame {\n+    Button b;\n+\n+    public static void main(final String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        GetSizesTest app = new GetSizesTest();\n+        EventQueue.invokeAndWait(() -> {\n+            try {\n+                app.init();\n+                app.start();\n+            } finally {\n+                app.dispose();\n+            }\n+        });\n+    }\n+\n+    public void init() {\n+        b = new Button(\"button\");\n+        add(b);\n+    }\n+\n+    public void start () {\n+        setSize(200, 200);\n+        setLocationRelativeTo(null);\n+        setVisible(true);\n+        validate();\n+\n+        System.out.println(\"Test set for Container (Frame).\");\n+\n+        Dimension dimPref = getPreferredSize();\n+        dimPref.setSize(101, 101);\n+        if (getPreferredSize().equals(new Dimension(101, 101))) {\n+            throw new RuntimeException(\"Test Failed for: \" + dimPref);\n+        }\n+        System.out.println(\"getPreferredSize() Passed.\");\n+\n+        Dimension dimMin = getMinimumSize();\n+        dimMin.setSize(101, 101);\n+        if (getMinimumSize().equals(new Dimension(101, 101))) {\n+            throw new RuntimeException(\"Test Failed for: \" + dimMin);\n+        }\n+        System.out.println(\"getMinimumSize() Passed.\");\n+\n+        Dimension dimMax = getMaximumSize();\n+        dimMax.setSize(101, 101);\n+        if (getMaximumSize().equals(new Dimension(101, 101))) {\n+            throw new RuntimeException(\"Test Failed for: \" + dimMax);\n+        }\n+        System.out.println(\"getMaximumSize() Passed.\");\n+\n+        System.out.println(\"Test set for Component (Button).\");\n+\n+        dimPref = b.getPreferredSize();\n+        dimPref.setSize(33, 33);\n+        if (b.getPreferredSize().equals(new Dimension(33, 33))) {\n+            throw new RuntimeException(\"Test Failed for: \" + dimPref);\n+        }\n+        System.out.println(\"getPreferredSize() Passed.\");\n+\n+        dimMin = b.getMinimumSize();\n+        dimMin.setSize(33, 33);\n+        if (b.getMinimumSize().equals(new Dimension(33, 33))) {\n+            throw new RuntimeException(\"Test Failed for: \" + dimMin);\n+        }\n+        System.out.println(\"getMinimumSize() Passed.\");\n+\n+        dimMax = b.getMaximumSize();\n+        dimMax.setSize(33, 33);\n+        if (b.getMaximumSize().equals(new Dimension(33, 33))) {\n+            throw new RuntimeException(\"Test Failed for: \" + dimMax);\n+        }\n+        System.out.println(\"getMaximumSize() Passed.\");\n+        System.out.println(\"GetSizesTest Succeeded.\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/MinMaxSizeDefensive\/GetSizesTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4059430\n+ * @summary Test for component z-ordering consistency\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ZOrderTest\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Insets;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n+\n+public class ZOrderTest {\n+    public final static String INSTRUCTIONS = \"\"\"\n+            The ZOrderTest creates two frames.\n+            - Frame 1 has components added to an intermediate panel\n+            - Frame 2 has components added directly to the frame itself\n+            Verify that the components are in the correct z-order. Lower numbered\n+            components should overlap higher numbered ones (e.g. component zero should\n+            appear on top of component one).\n+            Both frames should have the same component ordering, and this ordering should\n+            be the same on all supported operating systems.\n+            \"\"\";\n+\n+    public static void main(String [] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Component ZOrder Test\")\n+                .testUI(ZOrderTest::makeFrames)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static List<Frame> makeFrames() {\n+        Frame frame, frame2;\n+\n+        \/\/ test adding components to panel on a frame\n+        frame = new Frame(\"ZOrderTest(1) for 4059430\");\n+        frame.pack();\n+        frame.show();\n+        Panel panel = new ZOrderPanel();\n+        frame.setBounds(0, 0, 500, 350);\n+        frame.setLayout(new GridLayout());\n+        frame.add(panel);\n+        doTest(panel);\n+\n+        \/\/ test adding components directly to frame\n+        frame2 = new ZOrderTestFrame(\"ZOrderTest(2) for 4059430\");\n+        frame2.pack();\n+        frame2.show();\n+        frame2.setBounds(80, 80, 500, 350);\n+        doTest(frame2);\n+\n+        return List.of(frame, frame2);\n+    }\n+\n+    \/*\n+     * This tests various boundary conditions with z-ordering\n+     *  - inserting at the top of the z-order\n+     *  - inserting at the bottom of the z-order\n+     *  - inserting in the middle of the z-order\n+     *\/\n+    private static void doTest(Container cont) {\n+        Component compZero, compOne, compTwo, compThree, compFour;\n+\n+        compZero = makeBox(cont, \"Comp One\", Color.blue, -1);\n+        \/\/ insert on top\n+        compOne = makeBox(cont, \"Comp Zero\", Color.yellow, 0);\n+        \/\/ put at the back\n+        compThree = makeBox(cont, \"Comp Three\", Color.red, 2);\n+        \/\/ insert in last position\n+        compTwo = makeBox(cont, \"Comp Two\", Color.green, 3);\n+        \/\/ swap compTwo and compThree to correct positions\n+        cont.remove(compTwo);\n+        cont.add(compTwo, 2);\n+        \/\/ one more test of adding to the end\n+        compFour = makeBox(cont, \"Comp Four\", Color.magenta, -1);\n+        \/\/ re-validate so components cascade into proper place\n+        cont.validate();\n+    }\n+\n+    private static Component makeBox(Container cont, String s, Color c, int index) {\n+        Label l = new Label(s);\n+        l.setBackground(c);\n+        l.setAlignment(Label.RIGHT);\n+        if (index == -1) {\n+            cont.add(l); \/\/ semantically equivalent to -1, but why not test this too\n+        } else {\n+            cont.add(l, index);\n+        }\n+        cont.validate();\n+        return l;\n+    }\n+\n+    \/**\n+     * Cascades components across the container so\n+     * that they overlap, demonstrating their z-ordering\n+     *\/\n+    static void doCascadeLayout(Container cont) {\n+        int i, n;\n+        Insets ins = cont.insets();\n+        n = cont.countComponents();\n+        for (i = n - 1; i >= 0; i--) {\n+            Component comp = cont.getComponent(i);\n+            comp.reshape(ins.left + 75 * i, ins.top + 30 * i, 100, 100);\n+        }\n+    }\n+}\n+\n+class ZOrderPanel extends Panel {\n+    public void layout() {\n+        ZOrderTest.doCascadeLayout(this);\n+    }\n+}\n+\n+class ZOrderTestFrame extends Frame\n+{\n+    public ZOrderTestFrame(String title) {\n+        super(title);\n+    }\n+\n+    public void layout() {\n+        ZOrderTest.doCascadeLayout(this);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/ZOrderTest\/ZOrderTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Toolkit;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+\n+\/*\n+ * @test\n+ * @bug 4808569\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary add desktop property for the Windows XP or later font smoothing settings\n+ * @run main\/manual FontSmoothing\n+ *\/\n+\n+public class FontSmoothing {\n+\n+    private static final String PROP_NAME = \"win.text.fontSmoothingType\";\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                This test should be run on Windows XP or later.\n+\n+                On Windows 11:\n+                1. Open Run dialog by typing 'run' in search bar.\n+                2. Type 'cttune' and press Ok.\n+                3. Uncheck the \"Turn On ClearType\" checkbox and follow next instructions on screen.\n+                4. Repeat Step 1-2.\n+                5. Check the \"Turn On ClearType\" checkbox and follow next instructions on screen.\n+                6. Take a look at the output window to determine if the test passed or failed.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"FontSmoothing Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testTimeOut(5)\n+                .testUI(FontSmoothing::createUI)\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame f = new Frame(\"FontSmoothing Test\");\n+        f.setSize(50, 50);\n+\n+        Object value = Toolkit.getDefaultToolkit().getDesktopProperty(PROP_NAME);\n+        PassFailJFrame.log(\"toolkit.getDesktopProperty: \" + PROP_NAME + \" = \" + value + \"\\n\");\n+\n+        Toolkit.getDefaultToolkit().addPropertyChangeListener(PROP_NAME, new PropertyChangeListener() {\n+            public void propertyChange(PropertyChangeEvent e) {\n+                PassFailJFrame.log(\"PropertyChangeEvent: \" + e.getPropertyName() +\n+                        \"\\n   old value=\" + e.getOldValue() +\n+                        \"\\n   new value=\" + e.getNewValue());\n+\n+                Integer value = (Integer) Toolkit.getDefaultToolkit().getDesktopProperty(PROP_NAME);\n+                PassFailJFrame.log(\"toolkit.getDesktopProperty:\" + PROP_NAME + \"=\" + value);\n+\n+                if (value.equals((Integer) e.getNewValue())) {\n+                    PassFailJFrame.log(\"test PASSED\");\n+                } else {\n+                    PassFailJFrame.log(\"test FAILED\");\n+                }\n+            }\n+        });\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/DesktopProperties\/FontSmoothing.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.Toolkit;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+\n+\/*\n+ * @test\n+ * @bug 4368193\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"windows\")\n+ * @summary Toolkit's getDesktopProperty returns stale values on Microsoft Windows\n+ * @run main\/manual ThreeDBackgroundColor\n+ *\/\n+\n+public class ThreeDBackgroundColor {\n+\n+    private static final String PROP_NAME = \"win.3d.backgroundColor\";\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                On Windows 10:\n+                1. Open Windows Settings, in the search bar type\n+                   'high contrast', in the list of suggestions choose option\n+                   'Turn high contrast on or off'\n+                2. In the High contrast control panel click on the on\/off switch\n+                   to initialize High contrast mode\n+                3. Wait for the High contrast mode to finish initialization\n+                4. Click on the same switch again to turn off High contrast mode\n+\n+                On Windows 11:\n+                1. Open Windows settings, in the search bar type\n+                   'Contrast Theme'.\n+                2. Select any value from 'Contrast themes' dropdown menu and press 'Apply'.\n+                3. Wait for the High contrast mode to finish initialization\n+                4. Select 'None' from 'Contrast themes' dropdown menu to revert the changes.\n+\n+                Take a look at the output window to determine if the test passed or failed.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"ThreeDBackgroundColor Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testTimeOut(5)\n+                .testUI(ThreeDBackgroundColor::createUI)\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame f = new Frame(\"ThreeDBackgroundColor Test\");\n+        f.setSize(50, 50);\n+\n+        Object value = Toolkit.getDefaultToolkit().getDesktopProperty(PROP_NAME);\n+        PassFailJFrame.log(\"toolkit.getDesktopProperty:\" + PROP_NAME + \"=\" + value);\n+\n+        Toolkit.getDefaultToolkit().addPropertyChangeListener(PROP_NAME, new PropertyChangeListener() {\n+            public void propertyChange(PropertyChangeEvent e) {\n+                PassFailJFrame.log(\"PropertyChangeEvent: \" + e.getPropertyName() +\n+                        \"\\n   old value=\" + e.getOldValue() +\n+                        \"\\n   new value=\" + e.getNewValue());\n+\n+                Color value = (Color) Toolkit.getDefaultToolkit().getDesktopProperty(PROP_NAME);\n+                PassFailJFrame.log(\"toolkit.getDesktopProperty:\" + PROP_NAME + \"=\" + value);\n+                if (value.equals((Color) e.getNewValue())) {\n+                    PassFailJFrame.log(\"test PASSED\");\n+                } else {\n+                    PassFailJFrame.log(\"test FAILED\");\n+                }\n+            }\n+        });\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/DesktopProperties\/ThreeDBackgroundColor.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 6259434\n+ * @summary PIT: Choice in FileDialog is not responding to keyboard interactions, XToolkit\n+ * @requires (os.family == \"linux\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual KeyboardInteractionTest\n+ *\/\n+\n+public class KeyboardInteractionTest {\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"sun.awt.disableGtkFileDialogs\", \"true\");\n+        String INSTRUCTIONS = \"\"\"\n+                1) Click on 'Show File Dialog' button to bring up the FileDialog window.\n+                   A file dialog will come up.\n+                2) You will see a text field 'Enter full path or filename'.\n+                   Right next to it, you will see a button.\n+                   Transfer the focus on this button using 'TAB'.\n+                   Make sure that the popup choice is not shown.\n+                3) Press 'ESC'. If file dialog isn't disposed, then the test failed.\n+                4) Again, click on 'Show File Dialog' to bring up the file dialog.\n+                   A file dialog will come up.\n+                5) You will see a text field 'Enter full path or filename'.\n+                   Right next to it, you will see a button.\n+                   Click on this button. The popup choice will appear.\n+                6) Look at the popup choice. Change the current item in the popup\n+                   choice by the arrow keys.\n+                   If the text in the 'Enter full path or filename' text field isn't\n+                   changed, then the test failed.\n+                7) The test passed.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"KeyboardInteractionTest Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .testUI(KeyboardInteractionTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        Frame f = new Frame(\"KeyboardInteractionTest Test\");\n+        Button b = new Button(\"Show File Dialog\");\n+        FileDialog fd = new FileDialog(f);\n+        b.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                fd.setVisible(true);\n+            }\n+        });\n+        f.add(b);\n+        f.setSize(300, 200);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/FileDialog\/KeyboardInteractionTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 6240084\n+ * @summary Test that disposing unfurled list by the pressing ESC\n+ *          in FileDialog is working properly on XToolkit\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PathChoiceDisposeTest\n+ *\/\n+\n+public class PathChoiceDisposeTest {\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"sun.awt.disableGtkFileDialogs\", \"true\");\n+        String INSTRUCTIONS = \"\"\"\n+                1) Click on 'Show File Dialog' button to bring up the FileDialog window.\n+                2) Open the directory selection choice by clicking button next to\n+                   'Enter Path or Folder Name'. A drop-down will appear.\n+                3) Press 'ESC'.\n+                4) If you see that the dialog gets disposed and the popup\n+                   still remains on the screen, the test failed, otherwise passed.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"PathChoiceDisposeTest Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .testUI(PathChoiceDisposeTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        Frame f = new Frame(\"PathChoiceDisposeTest Test\");\n+        Button b = new Button(\"Show File Dialog\");\n+        FileDialog fd = new FileDialog(f);\n+        b.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                fd.setVisible(true);\n+            }\n+        });\n+        f.add(b);\n+        f.setSize(300, 200);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/FileDialog\/PathChoiceDisposeTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 6240074\n+ * @summary Test that file drop-down field in FileDialog is working properly on XToolkit\n+ * @requires (os.family == \"linux\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PathChoiceWorkArrowsTest\n+ *\/\n+\n+public class PathChoiceWorkArrowsTest {\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"sun.awt.disableGtkFileDialogs\", \"true\");\n+        String INSTRUCTIONS = \"\"\"\n+                This is only XAWT test.\n+\n+                1) Click on 'Show File Dialog' to bring up the FileDialog window.\n+                   A file dialog would come up.\n+                2) Click on the button next to 'Enter folder name' field.\n+                   A drop-down will appear. After this, there are 2 scenarios.\n+                3) Press the down arrow one by one. You will see a '\/' being\n+                   appended as soon as the current entry is removed.\n+                   Keep pressing till the last entry is reached. Now the drop-down\n+                   will stop responding to arrow keys. If yes, the test failed.\n+                4) Press the up arrow. The cursor will directly go to the last\n+                   entry ('\/') and navigation will stop there. You will see 2\n+                   entries being selected at the same time.\n+                   If yes, the test failed.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"PathChoiceWorkArrowsTest Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .testUI(PathChoiceWorkArrowsTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        Frame f = new Frame(\"PathChoiceWorkArrowsTest Test\");\n+        Button b = new Button(\"Show File Dialog\");\n+        FileDialog fd = new FileDialog(f);\n+        b.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                fd.setSize(200, 200);\n+                fd.setLocation(200, 200);\n+                fd.setVisible(true);\n+            }\n+        });\n+        f.add(b);\n+        f.setSize(300, 200);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/FileDialog\/PathChoiceWorkArrowsTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 6260650\n+ * @summary FileDialog.getDirectory() does not return null when file dialog is cancelled\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual SavedDirInitTest\n+ *\/\n+\n+public class SavedDirInitTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Click on 'Show File Dialog' button to bring up the FileDialog window.\n+                1) A file dialog will come up.\n+                2) Press 'Cancel' button to cancel the file dialog.\n+                3) The result (passed or failed) will be shown in the message window below.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"SavedDirInitTest Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .testUI(SavedDirInitTest::createUI)\n+                .logArea(2)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        Frame f = new Frame(\"SavedDirInitTest Test\");\n+        Button b = new Button(\"Show File Dialog\");\n+        FileDialog fd = new FileDialog(f);\n+        b.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                fd.setVisible(true);\n+                if (fd.getDirectory() == null && fd.getFile() == null) {\n+                    PassFailJFrame.log(\"TEST PASSED\");\n+                } else {\n+                    PassFailJFrame.log(\"TEST FAILED. dir = \" + fd.getDirectory()\n+                            + \" , file = \" + fd.getFile());\n+                }\n+            }\n+        });\n+        f.add(b);\n+        f.setSize(300, 200);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/FileDialog\/SavedDirInitTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Window;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4240766 8259023\n+ * @summary Frame Icon is wrong - should be Coffee Cup or Duke image icon\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DefaultFrameIconTest\n+*\/\n+\n+public class DefaultFrameIconTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            You should see a dialog and a frame.\n+            If both have Coffee Cup or Duke image icon in the upper left corner,\n+            the test passes, otherwise it fails.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"DefaultFrameIconTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(DefaultFrameIconTest::createAndShowUI)\n+                .positionTestUIRightRow()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static List<Window> createAndShowUI() {\n+        Frame testFrame = new Frame(\"Frame DefaultFrameIconTest\");\n+        Dialog testDialog = new Dialog(testFrame, \"Dialog DefaultFrameIconTest\");\n+\n+        testDialog.setSize(250, 100);\n+\n+        testFrame.setSize(250, 100);\n+        return List.of(testFrame, testDialog);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/DefaultFrameIconTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * DeiconifyClipTest.java\n+ *\n+ * summary:\n+ *\n+ * What happens is that we call AwtWindow::UpdateInsets when\n+ * processing WM_NCCALCSIZE delivered on programmatic deiconification.\n+ * At this point IsIconic returns false (so UpdateInsets proceeds),\n+ * but the rect sizes still seems to be those weird of the iconic\n+ * state.  Based on them we compute insets with top = left = 0 (and\n+ * bottom and right that are completely bogus) and pass them to\n+ * PaintUpdateRgn which results in incorrect clip origin.  Immediately\n+ * after that we do UpdateInsets again during WM_SIZE processing and\n+ * get real values.\n+ *\/\n+\n+import javax.swing.BoxLayout;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+\n+\/*\n+ * @test\n+ * @bug 4792958\n+ * @summary Incorrect clip region after programmatic restore\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DeiconifyClipTest\n+*\/\n+\n+public class DeiconifyClipTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            This test creates a frame that is automatically iconified\/deiconified\n+            in a cycle.\n+\n+            The test FAILS if after deiconfication the frame has a greyed-out area\n+            in the lower-right corner.\n+            If the frame contents is drawn completely - the test PASSES.\n+\n+            Press PASS or FAIL button accordingly.\n+            \"\"\";\n+\n+    static TestFrame testFrame;\n+    static volatile boolean shouldContinue = true;\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .title(\"DeiconifyClipTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(DeiconifyClipTest::createAndShowUI)\n+                .build();\n+        try {\n+            runThread();\n+        } finally {\n+            passFailJFrame.awaitAndCheck();\n+            shouldContinue = false;\n+        }\n+    }\n+\n+    private static void runThread() {\n+        new Thread(() -> {\n+            for (int i = 0; i < 1000 && shouldContinue; ++i) {\n+                try {\n+                    Thread.sleep(3000);\n+                    SwingUtilities.invokeAndWait(() -> {\n+                        if ((testFrame.getExtendedState() & Frame.ICONIFIED)\n+                                != 0) {\n+                            testFrame.setExtendedState(Frame.NORMAL);\n+                        } else {\n+                            testFrame.setState(Frame.ICONIFIED);\n+                        }\n+                    });\n+                } catch (Exception ignored) {\n+                }\n+            }\n+        }).start();\n+    }\n+\n+    static Frame createAndShowUI() {\n+        testFrame = new TestFrame();\n+        testFrame.getContentPane().setLayout(new BoxLayout(testFrame.getContentPane(),\n+                                                   BoxLayout.Y_AXIS));\n+        testFrame.getContentPane().setBackground(Color.yellow);\n+        testFrame.setSize(300, 300);\n+        return testFrame;\n+    }\n+\n+    static class TestFrame extends JFrame {\n+        public TestFrame() {\n+            super(\"DeiconifyClipTest\");\n+        }\n+\n+        \/\/ make it more visible if the clip is wrong.\n+        public void paint(Graphics g) {\n+            Insets b = getInsets();\n+            Dimension d = getSize();\n+\n+            int x = b.left;\n+            int y = b.top;\n+            int w = d.width - x - b.right;\n+            int h = d.height - y - b.bottom;\n+\n+            g.setColor(Color.white);\n+            g.fillRect(0, 0, d.width, d.height);\n+\n+            g.setColor(Color.green);\n+            g.drawRect(x, y, w-1, h-1);\n+            g.drawLine(x, y, x+w, y+h);\n+            g.drawLine(x, y+h, x+w, y);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/DeiconifyClipTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Window;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 5062118\n+ * @key headful\n+ * @summary Disabling of a parent should not disable Window.\n+ * @run main DisabledParentOfToplevel\n+ *\/\n+\n+public class DisabledParentOfToplevel {\n+    private static Button okBtn;\n+    private static Window ww;\n+    private static Frame parentFrame;\n+    private static volatile Point p;\n+    private static volatile Dimension d;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                createAndShowUI();\n+            });\n+            robot.delay(1000);\n+            EventQueue.invokeAndWait(() -> {\n+                p = okBtn.getLocationOnScreen();\n+                d = okBtn.getSize();\n+            });\n+            robot.mouseMove(p.x + d.width \/ 2, p.x + d.height \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(500);\n+            if (ww.isVisible()) {\n+                throw new RuntimeException(\"Window is visible but should be hidden: failure.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (parentFrame != null) {\n+                    parentFrame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        parentFrame = new Frame(\"parentFrame\");\n+        parentFrame.setSize(100, 100);\n+        parentFrame.setEnabled(false);\n+        ww = new Window(parentFrame);\n+        ww.setLayout(new BorderLayout());\n+        okBtn = new Button(\"Click to Close Me\");\n+        ww.add(okBtn);\n+        ww.setSize(250, 250);\n+        ww.setLocation(110, 110);\n+        okBtn.addMouseListener(new MouseAdapter() {\n+            public void mousePressed(MouseEvent me) {\n+                System.out.println(\"Pressed: close\");\n+                ww.setVisible(false);\n+            }\n+        });\n+        parentFrame.setVisible(true);\n+        ww.setVisible(true);\n+        okBtn.requestFocus();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/DisabledParentOfToplevel.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4127271\n+ * @summary Tests that disposing of a Frame with MenuBar removes all traces\n+ *          of the Frame from the screen.\n+ *\/\n+\n+public class DisposeTest {\n+    private static Frame backgroundFrame;\n+    private static Frame testedFrame;\n+\n+    private static final Rectangle backgroundFrameBounds =\n+            new Rectangle(100, 100, 200, 200);\n+    private static final Rectangle testedFrameBounds =\n+            new Rectangle(150, 150, 100, 100);\n+\n+    private static Robot robot;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        try {\n+            EventQueue.invokeAndWait(DisposeTest::initAndShowGui);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+            EventQueue.invokeAndWait(testedFrame::dispose);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+            test();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                backgroundFrame.dispose();\n+                testedFrame.dispose();\n+            });\n+        }\n+    }\n+\n+    private static void test() {\n+        BufferedImage bi = robot.createScreenCapture(backgroundFrameBounds);\n+        int redPix = Color.RED.getRGB();\n+\n+        for (int x = 0; x < bi.getWidth(); x++) {\n+            for (int y = 0; y < bi.getHeight(); y++) {\n+                if (bi.getRGB(x, y) != redPix) {\n+                    try {\n+                        ImageIO.write(bi, \"png\",\n+                                new File(\"failure.png\"));\n+                    } catch (IOException ignored) {}\n+                    throw new RuntimeException(\"Test failed\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void initAndShowGui() {\n+        backgroundFrame = new Frame(\"DisposeTest background\");\n+        backgroundFrame.setUndecorated(true);\n+        backgroundFrame.setBackground(Color.RED);\n+        backgroundFrame.setBounds(backgroundFrameBounds);\n+        backgroundFrame.setVisible(true);\n+\n+        testedFrame = new UglyFrame();\n+    }\n+\n+    static class UglyFrame extends Frame {\n+        public UglyFrame() {\n+            super(\"DisposeTest\");\n+            MenuBar mb = new MenuBar();\n+            Menu m = new Menu(\"menu\");\n+            mb.add(m);\n+            setMenuBar(mb);\n+            setBounds(testedFrameBounds);\n+            setVisible(true);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Frame\/DisposeTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.ScrollPane;\n+import java.awt.Window;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4084766\n+ * @summary Test for bug(s): 4084766\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FrameMenuPackTest\n+ *\/\n+\n+public class FrameMenuPackTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Check that both frames that appear are properly packed with\n+            the scrollpane visible.\n+            \"\"\";\n+\n+    public static void main(String[] argv) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"FrameMenuPackTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(FrameMenuPackTest::createAndShowUI)\n+                .positionTestUIRightRow()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static List<Window> createAndShowUI() {\n+        \/\/ Frame without menu, packs correctly\n+        PackedFrame f1 = new PackedFrame(false);\n+        f1.pack();\n+\n+        \/\/ Frame with menu, doesn't pack right\n+        PackedFrame f2 = new PackedFrame(true);\n+        f2.pack();\n+\n+        return List.of(f1, f2);\n+    }\n+\n+    private static class PackedFrame extends Frame {\n+        public PackedFrame(boolean withMenu) {\n+            super(\"PackedFrame\");\n+\n+            MenuBar menubar;\n+            Menu fileMenu;\n+            MenuItem foo;\n+            ScrollPane sp;\n+\n+            sp = new ScrollPane();\n+            sp.add(new Label(\"Label in ScrollPane\"));\n+            System.out.println(sp.getMinimumSize());\n+\n+            this.setLayout(new BorderLayout());\n+            this.add(sp, \"Center\");\n+            this.add(new Label(\"Label in Frame\"), \"South\");\n+\n+            if (withMenu) {\n+                menubar = new MenuBar();\n+                fileMenu = new Menu(\"File\");\n+                foo = new MenuItem(\"foo\");\n+                fileMenu.add(foo);\n+                menubar.add(fileMenu);\n+                this.setMenuBar(menubar);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameMenuPackTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+\n+\/*\n+ * @test\n+ * @bug 4023385\n+ * @summary resizing a frame causes too many repaints\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FramePaintTest\n+*\/\n+\n+public class FramePaintTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            You should see a Frame titled \"Repaint Test\", filled with colored blocks.\n+\n+            Resize the frame several times, both inward as well as outward.\n+\n+            The blocks should move to fill the window without any flashes or\n+            glitches which ensures that repaint is not done excessively\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"FramePaintTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(ResizeLW::new)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    static class ResizeLW extends Frame {\n+\n+        public ResizeLW() {\n+            super(\"Repaint Test\");\n+            setBackground(Color.red);\n+            setLayout(new FlowLayout());\n+            setSize(300, 300);\n+\n+            for (int i = 0; i < 10; i++) {\n+                add(new ColorComp(Color.blue));\n+                add(new ColorComp(Color.green));\n+            }\n+        }\n+\n+        private static class ColorComp extends Component {\n+            public ColorComp(Color c) {\n+                super();\n+                setBackground(c);\n+            }\n+\n+            public void paint(Graphics g) {\n+                g.setColor(getBackground());\n+                g.fillRect(0, 0, getWidth(), getHeight());\n+            }\n+\n+            public Dimension getPreferredSize() {\n+                return new Dimension(50, 50);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FramePaintTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Window;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 4097207\n+ * @summary setSize() on a Frame does not resize its content\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FrameResizeTest_3\n+*\/\n+\n+public class FrameResizeTest_3 {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            1. You would see a frame titled 'TestFrame' with 2 buttons\n+               named 'setSize(500,500)' and 'setSize(400,400)'\n+            2. Click any button and you would see the frame resized\n+            3. If the buttons get resized along with the frame\n+               (ie., to fit the frame), press Pass else press Fail.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"FrameResizeTest_3 Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .logArea(6)\n+                .testUI(FrameResizeTest_3::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Window createTestUI() {\n+        Frame frame = new Frame(\"TestFrame\");\n+        frame.setLayout(new GridLayout(2, 1));\n+\n+        Button butSize500 = new Button(\"setSize(500,500)\");\n+        Button butSize400 = new Button(\"setSize(400,400)\");\n+\n+        ActionListener actionListener = e -> {\n+            if (e.getSource() instanceof Button) {\n+                if (e.getSource() == butSize500) {\n+                    frame.setSize(500, 500);\n+                    PassFailJFrame.log(\"New bounds: \" + frame.getBounds());\n+                } else if (e.getSource() == butSize400) {\n+                    frame.setSize(400, 400);\n+                    PassFailJFrame.log(\"New bounds: \" + frame.getBounds());\n+                }\n+            }\n+        };\n+        butSize500.addActionListener(actionListener);\n+        butSize400.addActionListener(actionListener);\n+        frame.add(butSize500);\n+        frame.add(butSize400);\n+\n+        frame.setSize(270, 200);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameResizeTest\/FrameResizeTest_3.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* Note that although this test makes use of Swing classes, like JFrame and *\/\n+\/* JButton, it is really an AWT test, because it tests mechanism of sending *\/\n+\/* paint events. *\/\n+\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import java.awt.BorderLayout;\n+\n+\/*\n+ * @test\n+ * @bug 4174831\n+ * @summary Tests that frame do not flicker on diagonal resize\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FrameResizeTest_4\n+ *\/\n+\n+public class FrameResizeTest_4 {\n+    private static final String INSTRUCTIONS = \"\"\"\n+          Try enlarging the frame diagonally.\n+          If buttons inside frame excessively repaint themselves and flicker\n+          while you enlarge frame, the test fails.\n+          Otherwise, it passes.\n+          \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"FrameResizeTest_4 Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(FrameResizeTest_4::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static JFrame createTestUI() {\n+        JFrame f = new JFrame(\"FrameResizeTest_4 Flickering Frame\");\n+\n+        JPanel panel = new JPanel(new BorderLayout());\n+        panel.add(new JButton(\"West\"), BorderLayout.WEST);\n+        panel.add(new JButton(\"East\"), BorderLayout.EAST);\n+        panel.add(new JButton(\"North\"), BorderLayout.NORTH);\n+        panel.add(new JButton(\"South\"), BorderLayout.SOUTH);\n+        panel.add(new JButton(\"Center\"), BorderLayout.CENTER);\n+        f.setContentPane(panel);\n+\n+        f.pack();\n+        f.setBounds(100, 50, 300, 200);\n+\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameResizeTest\/FrameResizeTest_4.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+\n+\/*\n+ * @test\n+ * @summary Test to make sure non-resizable Frames can be resized with the\n+ *          setSize() method.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FrameResizeTest_5\n+*\/\n+\n+public class FrameResizeTest_5  {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            This tests the programmatic resizability of non-resizable Frames.\n+            Even when a Frame is set to be non-resizable, it should still be\n+            programmatically resizable using the setSize() method.\n+\n+            Initially the Frame will be resizable.  Try using the \"Smaller\"\n+            and \"Larger\" buttons to verify that the Frame resizes correctly.\n+            Then, click the \"Toggle\" button to make the Frame non-resizable.\n+            Again, verify that clicking the \"Larger\" and \"Smaller\" buttons\n+            causes the Frame to get larger and smaller.  If the Frame does\n+            not change size, or does not re-layout correctly, the test fails.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"FrameResizeTest_5 Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .logArea(6)\n+                .testUI(TestFrame::new)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static class TestFrame extends Frame {\n+        Button bLarger, bSmaller, bCheck, bToggle;\n+\n+        public TestFrame() {\n+            super(\"Frame Resize Test\");\n+            setSize(200, 200);\n+            bLarger = new Button(\"Larger\");\n+            bLarger.addActionListener(e -> {\n+                setSize(400, 400);\n+                validate();\n+            });\n+            bSmaller = new Button(\"Smaller\");\n+            bSmaller.addActionListener(e -> {\n+                setSize(200, 100);\n+                validate();\n+            });\n+            bCheck = new Button(\"Resizable?\");\n+            bCheck.addActionListener(e -> {\n+                if (isResizable()) {\n+                    PassFailJFrame.log(\"Frame is resizable\");\n+                    setResizable(true);\n+                } else {\n+                    PassFailJFrame.log(\"Frame is not resizable\");\n+                    setResizable(false);\n+                }\n+            });\n+            bToggle = new Button(\"Toggle\");\n+            bToggle.addActionListener(e -> {\n+                if (isResizable()) {\n+                    PassFailJFrame.log(\"Frame is now not resizable\");\n+                    setResizable(false);\n+                } else {\n+                    PassFailJFrame.log(\"Frame is now resizable\");\n+                    setResizable(true);\n+                }\n+            });\n+            setLayout(new GridLayout(4, 1));\n+            add(bSmaller);\n+            add(bLarger);\n+            add(bCheck);\n+            add(bToggle);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameResizeTest\/FrameResizeTest_5.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Cursor;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.event.ActionListener;\n+import java.lang.Exception;\n+import java.lang.InterruptedException;\n+import java.lang.Object;\n+import java.lang.String;\n+import java.lang.Thread;\n+\n+\/*\n+ * @test\n+ * @bug 4097226\n+ * @summary Frame.setCursor() sometimes doesn't update the cursor until user moves the mouse\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FrameSetCursorTest\n+ *\/\n+\n+public class FrameSetCursorTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            1. Keep the instruction dialog and TestFrame side by side so that\n+               you can read the instructions while doing the test\n+            2. Click on the 'Start Busy' button on the frame titled 'TestFrame'\n+               and DO NOT MOVE THE MOUSE ANYWHERE till you complete the steps below\n+            3. The cursor on the TestFrame changes to busy cursor\n+            4. If you don't see the busy cursor press 'Fail' after\n+               the `done sleeping` message\n+            5. If the busy cursor is seen, after 5 seconds the message\n+               'done sleeping' is displayed in the message window\n+            6. Check for the cursor type after the display of 'done sleeping'\n+            7. If the cursor on the TestFrame has changed back to default cursor\n+               (without you touching or moving the mouse), then press 'Pass'\n+               else if the frame still shows the busy cursor press 'Fail'\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"FrameSetCursorTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(FrameSetCursorTest::createAndShowUI)\n+                .logArea(5)\n+                .build()\n+                .awaitAndCheck();\n+\n+    }\n+\n+    static Frame createAndShowUI() {\n+        Frame frame = new Frame(\"TestFrame\");\n+        Panel panel = new Panel();\n+        Button busyButton = new Button(\"Start Busy\");\n+\n+        ActionListener actionListener = event -> {\n+            Object source = event.getSource();\n+            if (source == busyButton) {\n+                frame.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n+                try {\n+                    Thread.sleep(5000);\n+                } catch (InterruptedException ignored) {}\n+                PassFailJFrame.log(\"done sleeping\");\n+                frame.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\n+            }\n+        };\n+\n+        busyButton.addActionListener(actionListener);\n+        panel.setLayout(new BorderLayout());\n+        panel.add(\"North\", busyButton);\n+\n+        frame.add(panel);\n+        frame.pack();\n+        frame.setSize(200, 200);\n+        return frame;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameSetCursorTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.ImageIO;\n+\n+\/*\n+ * @test\n+ * @bug 4328588\n+ * @key headful\n+ * @summary Non-default visual on top-level Frame should work\n+ * @run main FrameVisualTest\n+ *\/\n+\n+public class FrameVisualTest {\n+    private static GraphicsConfiguration[] gcs;\n+    private static volatile Frame[] frames;\n+    private static volatile int index;\n+\n+    private static Frame f;\n+    private static Robot robot;\n+    private static volatile Point p;\n+    private static volatile Dimension d;\n+    private static final int TOLERANCE = 5;\n+\n+    public static void main(String[] args) throws Exception {\n+        gcs = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getConfigurations();\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                createAndShowUI();\n+            });\n+            robot.delay(1000);\n+            System.out.println(\"frames.length: \"+frames.length);\n+            for (index = 0; index < frames.length; index++) {\n+                EventQueue.invokeAndWait(() -> {\n+                    p = frames[index].getLocation();\n+                    d = frames[index].getSize();\n+                });\n+                Rectangle rect = new Rectangle(p, d);\n+                BufferedImage img = robot.createScreenCapture(rect);\n+                if (chkImgBackgroundColor(img)) {\n+                    try {\n+                        ImageIO.write(img, \"png\", new File(\"Frame_\" + index + \".png\"));\n+                    } catch (IOException ignored) {}\n+                    throw new RuntimeException(\"Frame visual test failed with non-white background color\");\n+                }\n+            }\n+        } finally {\n+            for (index = 0; index < frames.length; index++) {\n+                EventQueue.invokeAndWait(() -> {\n+                    if (frames[index] != null) {\n+                        frames[index].dispose();\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frames = new Frame[gcs.length];\n+        for (int i = 0; i < frames.length; i++) {\n+            frames[i] = new Frame(\"Frame w\/ gc \" + i, gcs[i]);\n+            frames[i].setSize(100, 100);\n+            frames[i].setUndecorated(true);\n+            frames[i].setBackground(Color.WHITE);\n+            frames[i].setVisible(true);\n+        }\n+    }\n+\n+    private static boolean chkImgBackgroundColor(BufferedImage img) {\n+\n+        \/\/ scan for mid-line and if it is non-white color then return true.\n+        for (int x = 1; x < img.getWidth() - 1; ++x) {\n+            Color c = new Color(img.getRGB(x, img.getHeight() \/ 2));\n+            if ((c.getRed() - Color.WHITE.getRed()) > TOLERANCE &&\n+                    (c.getGreen() - Color.WHITE.getGreen()) > TOLERANCE &&\n+                    (c.getBlue() - Color.WHITE.getBlue()) > TOLERANCE) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameVisualTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.TextField;\n+\n+\/*\n+ * @test\n+ * @bug 4113040\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Checks that IMStatusBar does not affect Frame layout\n+ * @run main\/manual\/othervm -Duser.language=ja -Duser.country=JP IMStatusBar\n+ *\/\n+\n+public class IMStatusBar {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                If the window appears the right size, but then resizes so that the\n+                status field overlaps the bottom label, press Fail; otherwise press Pass.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"IMStatusBar Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(IMStatusBar::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame f = new Frame();\n+        Panel centerPanel = new Panel();\n+        f.setSize(200, 200);\n+        f.setLayout(new BorderLayout());\n+        f.add(new Label(\"Top\"), BorderLayout.NORTH);\n+        f.add(centerPanel, BorderLayout.CENTER);\n+        f.add(new Label(\"Bottom\"), BorderLayout.SOUTH);\n+        centerPanel.setLayout(new BorderLayout());\n+        centerPanel.add(new TextField(\"Middle\"), BorderLayout.CENTER);\n+        centerPanel.validate();\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/IMStatusBar.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4851435\n+ * @summary Frame is not shown initially iconified after pack\n+ *\/\n+\n+public class InitialIconifiedTest {\n+\n+    private static Frame backgroundFrame;\n+    private static Frame testedFrame;\n+\n+    private static final Rectangle backgroundFrameBounds =\n+            new Rectangle(100, 100, 200, 200);\n+    private static final Rectangle testedFrameBounds =\n+            new Rectangle(150, 150, 100, 100);\n+\n+    private static Robot robot;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+\n+        try {\n+            EventQueue.invokeAndWait(InitialIconifiedTest::initAndShowGui);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+            test();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                backgroundFrame.dispose();\n+                testedFrame.dispose();\n+            });\n+        }\n+    }\n+\n+    private static void initAndShowGui() {\n+        backgroundFrame = new Frame(\"DisposeTest background\");\n+        backgroundFrame.setUndecorated(true);\n+        backgroundFrame.setBackground(Color.RED);\n+        backgroundFrame.setBounds(backgroundFrameBounds);\n+        backgroundFrame.setVisible(true);\n+\n+        testedFrame = new Frame(\"Should have started ICONIC\");\n+        testedFrame.setExtendedState(Frame.ICONIFIED);\n+        testedFrame.setBounds(testedFrameBounds);\n+        testedFrame.setVisible(true);\n+    }\n+\n+    private static void test() {\n+        BufferedImage bi = robot.createScreenCapture(backgroundFrameBounds);\n+        int redPix = Color.RED.getRGB();\n+\n+        for (int x = 0; x < bi.getWidth(); x++) {\n+            for (int y = 0; y < bi.getHeight(); y++) {\n+                if (bi.getRGB(x, y) != redPix) {\n+                    try {\n+                        ImageIO.write(bi, \"png\",\n+                                new File(\"failure.png\"));\n+                    } catch (IOException ignored) {}\n+                    throw new RuntimeException(\"Test failed\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/InitialIconifiedTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 4091426\n+ * @key headful\n+ * @summary Test inset correction when setVisible(true) BEFORE setSize(), setLocation()\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual InsetCorrectionTest\n+ *\/\n+\n+public class InsetCorrectionTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            There is a frame of size 300x300 at location (100,100).\n+            It has a menubar with one menu, 'File', but the frame\n+            is otherwise empty.  In particular, there should be no\n+            part of the frame that is not shown in the background color.\n+            Upon test completion, click Pass or Fail appropriately.\n+            \"\"\";\n+\n+    private static InsetCorrection testFrame;\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> testFrame = new InsetCorrection());\n+\n+        try {\n+            PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                    .title(\"InsetCorrectionTest Instructions\")\n+                    .instructions(INSTRUCTIONS)\n+                    .columns(45)\n+                    .logArea(3)\n+                    .build();\n+            EventQueue.invokeAndWait(() ->\n+                    PassFailJFrame.log(\"frame location: \" + testFrame.getBounds()));\n+            passFailJFrame.awaitAndCheck();\n+        } finally {\n+            EventQueue.invokeAndWait(testFrame::dispose);\n+        }\n+    }\n+\n+    static class InsetCorrection extends Frame\n+            implements ActionListener {\n+        MenuBar mb;\n+        Menu file;\n+        MenuItem cause_bug_b;\n+\n+        public InsetCorrection() {\n+            super(\"InsetCorrection\");\n+            mb = new MenuBar();\n+            file = new Menu(\"File\");\n+            mb.add(file);\n+            cause_bug_b = new MenuItem(\"cause bug\");\n+            file.add(cause_bug_b);\n+            setMenuBar(mb);\n+            cause_bug_b.addActionListener(this);\n+\n+            \/\/ Making the frame visible before setSize and setLocation()\n+            \/\/ are being called causes sometimes strange behaviour with\n+            \/\/ JDK1.1.5G. The frame is then sometimes to large and the\n+            \/\/ excess areas are drawn in black. This only happens\n+            \/\/ sometimes.\n+            setVisible(true);\n+            setSize(300, 300);\n+            setLocation(100, 100);\n+        }\n+\n+        public void actionPerformed(ActionEvent e) {\n+            setVisible(false);\n+            setVisible(true);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/InsetCorrectionTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.CheckboxMenuItem;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.TextField;\n+import java.awt.Window;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4133279\n+ * @summary  Clicking in menu in inactive frame crashes application\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MenuCrash\n+ *\/\n+public class MenuCrash {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Two frames will appear, alternate between frames by clicking on the\n+            menubar of the currently deactivated frame and verify no crash occurs.\n+\n+            Try mousing around the menus and choosing various items to see the menu\n+            item name reflected in the text field. Note that CheckBoxMenuItems do\n+            not fire action events so the check menu item (Item 03) will not change\n+            the field.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"MenuCrash Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(MenuCrash::createAndShowUI)\n+                .positionTestUIRightRow()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+\n+    private static List<Window> createAndShowUI() {\n+        Frame frame1 = new MenuFrame(\"Frame 1 MenuCrash\");\n+        Frame frame2 = new MenuFrame(\"Frame 2 MenuCrash\");\n+\n+        frame1.setSize(300, 200);\n+        frame2.setSize(300, 200);\n+\n+        frame1.validate();\n+        frame2.validate();\n+\n+        return List.of(frame1, frame2);\n+    }\n+\n+    static class MenuFrame extends Frame {\n+        private final TextField  field;\n+\n+        MenuFrame(String name) {\n+            super(name);\n+            setLayout(new FlowLayout());\n+\n+            Button removeMenus = new Button(\"Remove Menus\");\n+            removeMenus.addActionListener(ev -> remove(getMenuBar()));\n+\n+            Button addMenus = new Button(\"Add Menus\");\n+            addMenus.addActionListener(ev -> setupMenus());\n+\n+            add(removeMenus);\n+            add(addMenus);\n+            field = new TextField(20);\n+            add(field);\n+\n+            addWindowListener(\n+                    new WindowAdapter() {\n+                        public void windowActivated(WindowEvent e) {\n+                            setupMenus();\n+                        }\n+                    }\n+            );\n+\n+            addComponentListener(\n+                    new ComponentAdapter() {\n+                        public void componentResized(ComponentEvent e) {\n+                            System.out.println(MenuFrame.this);\n+                        }\n+                    }\n+            );\n+\n+            pack();\n+        }\n+\n+        private void addMenuListeners() {\n+            MenuBar menuBar = getMenuBar();\n+\n+            for (int nMenu = 0; nMenu < menuBar.getMenuCount(); nMenu++) {\n+                Menu menu = menuBar.getMenu(nMenu);\n+                for (int nMenuItem = 0; nMenuItem < menu.getItemCount(); nMenuItem++) {\n+                    MenuItem item = menu.getItem(nMenuItem);\n+                    item.addActionListener(ev -> field.setText(ev.getActionCommand()));\n+                }\n+            }\n+        }\n+\n+        private void setupMenus() {\n+            MenuItem miSetLabel = new MenuItem(\"Item 01\");\n+            MenuItem miSetEnabled = new MenuItem(\"Item 02\");\n+            CheckboxMenuItem miSetState = new CheckboxMenuItem(\"Item 03\");\n+            MenuItem miAdded = new MenuItem(\"Item 04 Added\");\n+\n+            MenuBar menuBar = new MenuBar();\n+            Menu menu1 = new Menu(\"Menu 01\");\n+            menu1.add(miSetLabel);\n+            menu1.add(miSetEnabled);\n+            menu1.add(miSetState);\n+            menuBar.add(menu1);\n+            setMenuBar(menuBar);\n+\n+            \/\/ now that the peers are created, screw\n+            \/\/ around with the menu items\n+            miSetLabel.setLabel(\"Menu 01 - SetLabel\");\n+            miSetEnabled.setEnabled(false);\n+            miSetState.setState(true);\n+            menu1.add(miAdded);\n+            menu1.remove(miAdded);\n+            menu1.addSeparator();\n+            menu1.add(miAdded);\n+\n+            Menu menu2 = new Menu(\"Menu 02\");\n+            menuBar.add(menu2);\n+            menuBar.remove(menu2);\n+            menuBar.add(menu2);\n+            menu2.add(new MenuItem(\"Foo\"));\n+            menu1.setLabel(\"Menu Number 1\");\n+            menu2.setLabel(\"Menu Number 2\");\n+\n+            addMenuListeners();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/MenuCrash.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,485 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.FontMetrics;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Image;\n+import java.awt.Label;\n+import java.awt.LayoutManager;\n+import java.awt.Panel;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.TextField;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+import java.awt.image.ColorModel;\n+import java.awt.image.MemoryImageSource;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.swing.JFrame;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 4312921\n+ * @key multimon\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame\n+ * @summary Tests that no garbage is painted on primary screen with DGA\n+ * @run main\/manual MultiScreenTest\n+ *\/\n+\n+public class MultiScreenTest {\n+    static GraphicsEnvironment ge;\n+    static GraphicsDevice[] gs;\n+\n+    public static void main(String[] args) throws Exception {\n+        ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        gs = ge.getScreenDevices();\n+        if (gs.length < 2) {\n+            throw new SkippedException(\"You have only one monitor in your system - test passed\");\n+        }\n+        MultiScreenTest obj = new MultiScreenTest();\n+        String INSTRUCTIONS =\n+                \"This test is to be run only on multiscreen machine. \" +\n+                \"You have \" + gs.length + \" monitors in your system.\\n\" +\n+                \"Actively drag the DitherTest frames on the secondary screen and \" +\n+                \"if you see garbage appearing on your primary screen \" +\n+                \"test failed otherwise it passed.\";;\n+\n+        PassFailJFrame.builder()\n+                .title(\"MultiScreenTest Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(obj::init)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public List<JFrame> init() {\n+        List<JFrame> list = new ArrayList<>();\n+        for (int j = 0; j < gs.length; j++) {\n+            GraphicsConfiguration[] gc = gs[j].getConfigurations();\n+            if (gc.length > 0) {\n+                for (int i = 0; i < gc.length \/ 2; i++) {\n+                    JFrame f = new JFrame(gc[i]); \/\/test JFrame( gc )\n+                    GCCanvas c = new GCCanvas(gc[i]);\/\/test canvas( gc )\n+                    Rectangle gcBounds = gc[i].getBounds(); \/\/test getBounds()\n+                    int xoffs = gcBounds.x;\n+                    int yoffs = gcBounds.y;\n+\n+                    f.getContentPane().add(c);\n+                    f.setTitle(\"Screen# \" + Integer.toString(j) + \", GC#\" + Integer.toString(i));\n+                    f.setSize(300, 200);\n+                    f.setLocation(400 + xoffs, (i * 150) + yoffs);\/\/test displaying in right location\n+                    list.add(f);\n+\n+                    Frame ditherfs = new Frame(\"DitherTest GC#\" + Integer.toString(i), gc[i]);\n+                    ditherfs.setLayout(new BorderLayout()); \/\/showDitherTest\n+                    DitherTest ditherTest = new DitherTest(gc[i]);\n+                    ditherfs.add(\"Center\", ditherTest);\n+                    ditherfs.setBounds(300, 200, 300, 200);\n+                    ditherfs.setLocation(750 + xoffs, (i * 50) + yoffs);\n+                    ditherfs.pack();\n+                    ditherfs.show();\n+                    ditherTest.start();\n+                }\n+            }\n+        }\n+        return list;\n+    }\n+}\n+\n+class GCCanvas extends Canvas {\n+\n+    GraphicsConfiguration gc;\n+    Rectangle bounds;\n+    Graphics g = this.getGraphics();\n+    Dimension size = getSize();\n+\n+    public GCCanvas(GraphicsConfiguration gc) {\n+        super(gc);\n+        this.gc = gc;\n+        bounds = gc.getBounds();\n+    }\n+\n+    public void paint( Graphics _g ) {\n+\n+        Graphics2D g = (Graphics2D) _g;\n+\n+        g.drawRect(0, 0, size.width-1, size.height-1);\n+        g.setColor(Color.lightGray);\n+        g.draw3DRect(1, 1, size.width-3, size.height-3, true);\n+\n+        g.setColor(Color.red);\n+        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+\n+        g.drawString(\"HELLO!\", 110, 10);\n+\n+        g.setColor(Color.blue);\n+        g.drawString(\"ScreenSize=\"+Integer.toString(bounds.width)+\"X\"+\n+                     Integer.toString(bounds.height), 10, 20);\n+        g.setColor(Color.green);\n+        g.drawString(gc.toString(), 10, 30);\n+        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n+\n+        g.setColor(Color.orange);\n+        g.fillRect(40, 20, 50, 50);\n+\n+        g.setColor(Color.red);\n+        g.drawRect(100, 20, 30, 30);\n+\n+        g.setColor(Color.gray);\n+        g.drawLine(220, 20, 280, 40);\n+\n+        g.setColor(Color.cyan);\n+        g.fillArc(150, 30, 30, 30, 0, 200);\n+    }\n+\n+    public Dimension getPreferredSize(){\n+         return new Dimension(300, 200);\n+    }\n+}\n+\n+class DitherCanvas extends Canvas {\n+    Image img;\n+    static String calcString = \"Calculating...\";\n+\n+    GraphicsConfiguration mGC;\n+\n+    public DitherCanvas(GraphicsConfiguration gc) {\n+        super(gc);\n+        mGC = gc;\n+    }\n+\n+    public GraphicsConfiguration getGraphicsConfig() {\n+        return mGC;\n+    }\n+\n+    public void paint(Graphics g) {\n+        int w = getSize().width;\n+        int h = getSize().height;\n+        if (img == null) {\n+            super.paint(g);\n+            g.setColor(Color.black);\n+            FontMetrics fm = g.getFontMetrics();\n+            int x = (w - fm.stringWidth(calcString)) \/ 2;\n+            int y = h \/ 2;\n+            g.drawString(calcString, x, y);\n+        } else {\n+            g.drawImage(img, 0, 0, w, h, this);\n+        }\n+    }\n+\n+    public void update(Graphics g) {\n+        paint(g);\n+    }\n+\n+    public Dimension getMinimumSize() {\n+        return new Dimension(20, 20);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(200, 200);\n+    }\n+\n+    public Image getImage() {\n+        return img;\n+    }\n+\n+    public void setImage(Image img) {\n+        this.img = img;\n+        paint(getGraphics());\n+    }\n+}\n+\n+class DitherTest extends Panel implements Runnable {\n+    final static int NOOP = 0;\n+    final static int RED = 1;\n+    final static int GREEN = 2;\n+    final static int BLUE = 3;\n+    final static int ALPHA = 4;\n+    final static int SATURATION = 5;\n+\n+    Thread runner;\n+\n+    DitherControls XControls;\n+    DitherControls YControls;\n+    DitherCanvas canvas;\n+\n+    public DitherTest(GraphicsConfiguration gc) {\n+        String xspec, yspec;\n+        int xvals[] = new int[2];\n+        int yvals[] = new int[2];\n+\n+        xspec = \"red\";\n+        yspec = \"blue\";\n+        int xmethod = colormethod(xspec, xvals);\n+        int ymethod = colormethod(yspec, yvals);\n+\n+        setLayout(new BorderLayout());\n+        XControls = new DitherControls(this, xvals[0], xvals[1],\n+                xmethod, false);\n+        YControls = new DitherControls(this, yvals[0], yvals[1],\n+                ymethod, true);\n+        YControls.addRenderButton();\n+        add(\"North\", XControls);\n+        add(\"South\", YControls);\n+        add(\"Center\", canvas = new DitherCanvas(gc));\n+    }\n+\n+    public void start() {\n+        runner = new Thread(this);\n+        runner.start();\n+    }\n+\n+    int colormethod(String s, int vals[]) {\n+        int method = NOOP;\n+\n+        if (s == null) {\n+            s = \"\";\n+        }\n+\n+        String lower = s.toLowerCase();\n+        int len = 0;\n+        if (lower.startsWith(\"red\")) {\n+            method = RED;\n+            lower = lower.substring(3);\n+        } else if (lower.startsWith(\"green\")) {\n+            method = GREEN;\n+            lower = lower.substring(5);\n+        } else if (lower.startsWith(\"blue\")) {\n+            method = BLUE;\n+            lower = lower.substring(4);\n+        } else if (lower.startsWith(\"alpha\")) {\n+            method = ALPHA;\n+            lower = lower.substring(4);\n+        } else if (lower.startsWith(\"saturation\")) {\n+            method = SATURATION;\n+            lower = lower.substring(10);\n+        }\n+\n+        if (method == NOOP) {\n+            vals[0] = 0;\n+            vals[1] = 0;\n+            return method;\n+        }\n+\n+        int begval = 0;\n+        int endval = 255;\n+\n+        try {\n+            int dash = lower.indexOf('-');\n+            if (dash < 0) {\n+                begval = endval = Integer.parseInt(lower);\n+            } else {\n+                begval = Integer.parseInt(lower.substring(0, dash));\n+                endval = Integer.parseInt(lower.substring(dash + 1));\n+            }\n+        } catch (Exception e) {\n+        }\n+\n+        if (begval < 0) {\n+            begval = 0;\n+        }\n+        if (endval < 0) {\n+            endval = 0;\n+        }\n+        if (begval > 255) {\n+            begval = 255;\n+        }\n+        if (endval > 255) {\n+            endval = 255;\n+        }\n+\n+        vals[0] = begval;\n+        vals[1] = endval;\n+\n+        return method;\n+    }\n+\n+    void applymethod(int c[], int method, int step, int total, int vals[]) {\n+        if (method == NOOP)\n+            return;\n+        int val = ((total < 2)\n+                ? vals[0]\n+                : vals[0] + ((vals[1] - vals[0]) * step \/ (total - 1)));\n+        switch (method) {\n+            case RED:\n+                c[0] = val;\n+                break;\n+            case GREEN:\n+                c[1] = val;\n+                break;\n+            case BLUE:\n+                c[2] = val;\n+                break;\n+            case ALPHA:\n+                c[3] = val;\n+                break;\n+            case SATURATION:\n+                int max = Math.max(Math.max(c[0], c[1]), c[2]);\n+                int min = max * (255 - val) \/ 255;\n+                if (c[0] == 0) {\n+                    c[0] = min;\n+                }\n+                if (c[1] == 0) {\n+                    c[1] = min;\n+                }\n+                if (c[2] == 0) {\n+                    c[2] = min;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void run() {\n+        canvas.setImage(null);  \/\/ Wipe previous image\n+        Image img = calculateImage();\n+        synchronized (this) {\n+            if (img != null && runner == Thread.currentThread()) {\n+                canvas.setImage(img);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Calculates and returns the image.  Halts the calculation and returns\n+     * null if stopped during the calculation.\n+     *\/\n+    Image calculateImage() {\n+        Thread me = Thread.currentThread();\n+\n+        int width = canvas.getSize().width;\n+        int height = canvas.getSize().height;\n+        int xvals[] = new int[2];\n+        int yvals[] = new int[2];\n+        int xmethod = XControls.getParams(xvals);\n+        int ymethod = YControls.getParams(yvals);\n+        int pixels[] = new int[width * height];\n+        int c[] = new int[4];\n+        int index = 0;\n+\n+        for (int j = 0; j < height; j++) {\n+            for (int i = 0; i < width; i++) {\n+                c[0] = c[1] = c[2] = 0;\n+                c[3] = 255;\n+                if (xmethod < ymethod) {\n+                    applymethod(c, xmethod, i, width, xvals);\n+                    applymethod(c, ymethod, j, height, yvals);\n+                } else {\n+                    applymethod(c, ymethod, j, height, yvals);\n+                    applymethod(c, xmethod, i, width, xvals);\n+                }\n+                pixels[index++] = ((c[3] << 24) |\n+                        (c[0] << 16) |\n+                        (c[1] << 8) |\n+                        (c[2] << 0));\n+\n+            }\n+            \/\/ Poll once per row to see if we've been told to stop.\n+            if (runner != me) {\n+                return null;\n+            }\n+        }\n+\n+        return createImage(new MemoryImageSource(width, height,\n+                ColorModel.getRGBdefault(), pixels, 0, width));\n+    }\n+\n+    public String getInfo() {\n+        return \"An interactive demonstration of dithering.\";\n+    }\n+\n+    public String[][] getParameterInfo() {\n+        String[][] info = {\n+                {\"xaxis\", \"{RED, GREEN, BLUE, PINK, ORANGE, MAGENTA, CYAN, WHITE, YELLOW, GRAY, DARKGRAY}\",\n+                 \"The color of the Y axis.  Default is RED.\"},\n+                {\"yaxis\", \"{RED, GREEN, BLUE, PINK, ORANGE, MAGENTA, CYAN, WHITE, YELLOW, GRAY, DARKGRAY}\",\n+                 \"The color of the X axis.  Default is BLUE.\"}\n+        };\n+        return info;\n+    }\n+}\n+\n+class DitherControls extends Panel implements ActionListener {\n+    TextField start;\n+    TextField end;\n+    Button button;\n+    Choice choice;\n+    DitherTest dt;\n+\n+    static LayoutManager dcLayout = new FlowLayout(FlowLayout.CENTER, 10, 5);\n+\n+    public DitherControls(DitherTest app, int s, int e, int type,\n+                          boolean vertical) {\n+        dt = app;\n+        setLayout(dcLayout);\n+        add(new Label(vertical ? \"Vertical\" : \"Horizontal\"));\n+        add(choice = new Choice());\n+        choice.addItem(\"Noop\");\n+        choice.addItem(\"Red\");\n+        choice.addItem(\"Green\");\n+        choice.addItem(\"Blue\");\n+        choice.addItem(\"Alpha\");\n+        choice.addItem(\"Saturation\");\n+        choice.select(type);\n+        add(start = new TextField(Integer.toString(s), 4));\n+        add(end = new TextField(Integer.toString(e), 4));\n+    }\n+\n+    public void addRenderButton() {\n+        add(button = new Button(\"New Image\"));\n+        button.addActionListener(this);\n+    }\n+\n+    public int getParams(int vals[]) {\n+        vals[0] = Integer.parseInt(start.getText());\n+        vals[1] = Integer.parseInt(end.getText());\n+        return choice.getSelectedIndex();\n+    }\n+\n+    public void actionPerformed(ActionEvent e) {\n+        if (e.getSource() == button) {\n+            dt.start();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/MultiScreenTest.java","additions":485,"deletions":0,"binary":false,"changes":485,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4234245\n+ * @summary the actionEvent is not invoked when hit enter on list.\n+ * @key headful\n+ * @run main ActionEventWhenHitEnterTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.IllegalComponentStateException;\n+import java.awt.List;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.event.KeyEvent;\n+\n+public class ActionEventWhenHitEnterTest\n+        implements ActionListener, ItemListener {\n+\n+    volatile boolean passed1;\n+    volatile boolean passed2;\n+    volatile Point pt;\n+    List list;\n+    Frame frame;\n+\n+    public static void main(final String[] args) throws Exception {\n+        ActionEventWhenHitEnterTest app = new ActionEventWhenHitEnterTest();\n+        app.doTest();\n+    }\n+\n+    public ActionEventWhenHitEnterTest() {\n+        list = new List(7);\n+        for (int i = 0; i < 10; i++) {\n+            list.add(\"Item \" + i);\n+        }\n+        list.addItemListener(this);\n+        list.addActionListener(this);\n+    }\n+\n+    public void actionPerformed(ActionEvent ae) {\n+        passed1 = true;\n+        System.out.println(\"--> Action event invoked: \" + ae.getSource());\n+    }\n+\n+    public void itemStateChanged(ItemEvent ie) {\n+        passed2 = true;\n+        System.out.println(\"--> Item state changed:\" + ie.getSource());\n+    }\n+\n+    public void doTest() throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            frame = new Frame(\"ActionEventWhenHitEnterTest\");\n+            frame.add(list);\n+            frame.setSize(200, 200);\n+            frame.setLocationRelativeTo(null);\n+            frame.setVisible(true);\n+        });\n+\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                pt = list.getLocationOnScreen();\n+            });\n+\n+            if (pt.x != 0 || pt.y != 0) {\n+                robot.mouseMove(pt.x + list.getWidth() \/ 2,\n+                                pt.y + list.getHeight() \/ 2);\n+                robot.waitForIdle();\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.waitForIdle();\n+\n+                robot.keyPress(KeyEvent.VK_ENTER);\n+                robot.keyRelease(KeyEvent.VK_ENTER);\n+            }\n+\n+            robot.waitForIdle();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+\n+        if (!passed1 || !passed2) {\n+            throw new RuntimeException(\"ActionEventWhenHitEnterTest FAILED\");\n+        }\n+        System.out.println(\"Test PASSED\");\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/List\/ActionEventWhenHitEnterTest.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6354810\n+ * @summary Items in the list are not grayed out when disabled, XToolkit\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DisabledListIsGreyTest\n+*\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+\n+public class DisabledListIsGreyTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            1) After the test started you will see two lists.\n+            2) One of them is enabled, and the second is disabled.\n+            3) Check that the items of the disabled list are grayed.\n+            4) If so, the test passed. Otherwise, failed.\"\"\";\n+\n+\n+    public static void main(String[] args) throws Exception {\n+         PassFailJFrame.builder()\n+                .title(\"DisabledListIsGreyTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(DisabledListIsGreyTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame frame = new Frame(\"DisabledListIsGreyTest Frame\");\n+        frame.setLayout(new FlowLayout());\n+\n+        List list1 = new List(3);\n+        List list2 = new List(3);\n+        for (int i = 0; i < 5; i++) {\n+            list1.addItem(\"Item \" + i);\n+            list2.addItem(\"Item \" + i);\n+        }\n+        frame.add(list1);\n+\n+        list2.setEnabled(false);\n+        frame.add(list2);\n+        frame.pack();\n+        return frame;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/List\/DisabledListIsGreyTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6293432\n+ * @summary Key events ('SPACE', 'UP', 'DOWN') aren't blocked\n+ *          if mouse is kept in 'PRESSED' state for List\n+ * @key headful\n+ * @run main HandlingKeyEventIfMousePressedTest\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionAdapter;\n+\n+public class HandlingKeyEventIfMousePressedTest {\n+\n+    static Frame frame;\n+    static List list;\n+    static volatile Point loc;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            EventQueue.invokeAndWait(() -> {\n+                loc = list.getLocationOnScreen();\n+            });\n+            robot.mouseMove(loc.x + 10, loc.y + 10);\n+            robot.waitForIdle();\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            \/\/ key pressing when the mouse is kept in the 'pressed' state\n+            robot.keyPress(KeyEvent.VK_DOWN);\n+            robot.keyRelease(KeyEvent.VK_DOWN);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+\n+            int selectedIndex = list.getSelectedIndex();\n+            if (selectedIndex != 0) {\n+                throw new RuntimeException(\"Test failed: list.getCurrentItem = \" + selectedIndex);\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new Frame(\"HandlingKeyEventIfMousePressedTest\");\n+        list = new List(10, false);\n+\n+        list.add(\"111\");\n+        list.add(\"222\");\n+        list.add(\"333\");\n+        list.add(\"444\");\n+        frame.add(list);\n+\n+        addListeners();\n+\n+        frame.setLayout(new FlowLayout());\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    \/\/ added in order to have more information in failed case\n+    private static void addListeners() {\n+\n+        list.addMouseMotionListener(\n+            new MouseMotionAdapter() {\n+                @Override\n+                public void mouseDragged(MouseEvent me) {\n+                    System.out.println(me);\n+                }\n+\n+                @Override\n+                public void mouseMoved(MouseEvent me) {\n+                    System.out.println(me);\n+                }\n+            });\n+\n+        list.addMouseListener(\n+            new MouseAdapter(){\n+                public void mousePressed(MouseEvent me) {\n+                    System.out.println(me);\n+                }\n+                public void mouseClicked(MouseEvent me) {\n+                    System.out.println(me);\n+                }\n+                public void mouseEntered(MouseEvent me) {\n+                    System.out.println(me);\n+                }\n+                public void mouseExited(MouseEvent me) {\n+                    System.out.println(me);\n+                }\n+                public void mouseReleased(MouseEvent me) {\n+                    System.out.println(me);\n+                }\n+            });\n+\n+        list.addActionListener(\n+            new ActionListener() {\n+                public void actionPerformed(ActionEvent ae) {\n+                    System.out.println(ae);\n+                }\n+            });\n+\n+        list.addItemListener(\n+            new ItemListener() {\n+                public void itemStateChanged(ItemEvent ie) {\n+                    System.out.println(ie);\n+                }\n+            });\n+\n+        list.addFocusListener(\n+            new FocusAdapter() {\n+                public void focusGained(FocusEvent fe) {\n+                    System.out.println(fe);\n+                }\n+                public void focusLost(FocusEvent fe) {\n+                    System.out.println(fe);\n+                }\n+            });\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/HandlingKeyEventIfMousePressedTest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6355467\n+ * @summary Horizontal scroll bar thumb of a List does not stay at the end\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"linux\")\n+ * @run main\/manual HorizScrollWorkTest\n+*\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+\n+public class HorizScrollWorkTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            This is a linux only test.\n+            Drag and drop the horizontal scroll bar thumb at the right end.\n+            If the thumb does not stay at the right end, then the test failed. Otherwise passed.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"HorizScrollWorkTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int)INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(HorizScrollWorkTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame frame = new Frame(\"HorizScrollWorkTest Frame\");\n+        List list = new List(4);\n+\n+        frame.setLayout (new FlowLayout());\n+\n+        list.add(\"veryyyyyyyyyyyyyyyyyyyyyyyyyy longgggggggggggggggggggggg stringggggggggggggggggggggg\");\n+\n+        frame.add(list);\n+        frame.pack();\n+\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/HorizScrollWorkTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4895367\n+ * @summary List scrolling w\/ down arrow keys obscures horizontal scrollbar\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"linux\")\n+ * @run main\/manual HorizScrollbarEraseTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.TextArea;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+public class HorizScrollbarEraseTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            This is a Unix-only test.\n+            Do the four mini-tests below.\n+            If the horizontal scrollbar is ever erased by a rectangle\n+            of the background color, the test FAILS.\n+            If the horizontal scrollbars remain painted, test passes.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"HorizScrollbarEraseTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(HorizScrollbarEraseTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame frame = new Frame(\"HorizScrollbarEraseTest\");\n+        Panel borderPanel = new Panel();\n+        borderPanel.setLayout(new BorderLayout());\n+        Button focusedButton = new Button(\"Focus starts here\");\n+        borderPanel.add(focusedButton, BorderLayout.NORTH);\n+\n+        Panel gridPanel = new Panel();\n+        gridPanel.setLayout(new GridLayout(0, 4));\n+        borderPanel.add(gridPanel, BorderLayout.CENTER);\n+\n+        InstructionList il1 = new InstructionList(\"Tab to Item 2, then \\n\" +\n+                                                   \"press the down\" +\n+                                                    \"arrow key to scroll down\");\n+        il1.list.select(2);\n+        il1.list.makeVisible(0);\n+        gridPanel.add(il1);\n+\n+        InstructionList il2 = new InstructionList(\"Tab to the next List,\\n\" +\n+                                                  \"then press the down\\n\" +\n+                                                  \"arrow key to select\\n\" +\n+                                                  \"the last item.\");\n+        il2.list.select(3);\n+        il2.list.makeVisible(0);\n+        gridPanel.add(il2);\n+\n+        InstructionList il3 = new InstructionList(\"Click the button to\\n\" +\n+                                                  \"programmatically\\n\" +\n+                                                  \"select item 3 (not showing)\");\n+        Button selectBtn = new Button(\"Click Me\");\n+        final List selectList = il3.list;\n+        selectBtn.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                selectList.select(3);\n+            }\n+        });\n+        il3.add(selectBtn, BorderLayout.CENTER);\n+        gridPanel.add(il3);\n+\n+        InstructionList il4 = new InstructionList(\"Click the button to\\nprogrammatically\\ndeselect item 3\\n(not showing)\");\n+        Button deselectBtn = new Button(\"Click Me\");\n+        final List deselectList = il4.list;\n+        deselectBtn.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                deselectList.deselect(3);\n+            }\n+        });\n+        il4.add(deselectBtn, BorderLayout.CENTER);\n+        il4.list.select(3);\n+        il4.list.makeVisible(0);\n+        gridPanel.add(il4);\n+\n+        frame.add(borderPanel);\n+        frame.pack();\n+        return frame;\n+\n+    }\n+}\n+\n+class InstructionList extends Panel {\n+    TextArea ta;\n+    public List list;\n+\n+    public InstructionList(String instructions) {\n+        super();\n+        setLayout(new BorderLayout());\n+        ta = new TextArea(instructions, 6, 25, TextArea.SCROLLBARS_NONE);\n+        ta.setFocusable(false);\n+        list = new List();\n+        for (int i = 0; i < 5; i++) {\n+            list.add(\"Item \" + i + \", a long, long, long, long item\");\n+        }\n+        add(ta, BorderLayout.NORTH);\n+        add(list, BorderLayout.SOUTH);\n+     }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/HorizScrollbarEraseTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4089604\n+ * @summary Enter key doesn't fire List actionPerformed as specified\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ListActionEventTest\n+*\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+\n+public class ListActionEventTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            A frame will be shown.\n+            1. Click any item in the list (say item 1) in the frame\n+            2. A message 'ItemSelected' is displayed on the message window.\n+            3. Press the return key on the selected item.\n+            4. If the text 'ActionPerformed' is displayed on the message window,\n+               then press PASS else press FAIL.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ListActionEventTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(ListActionEventTest::createTestUI)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame frame = new Frame(\"ListActionEventTest frame\");\n+\n+        Panel pnl1 = new Panel();\n+        frame.add(pnl1);\n+        pnl1.setLayout(new BorderLayout());\n+\n+        List list = new List();\n+        for (int i = 0; i < 5; i++) {\n+            list.addItem(\"Item \" + i);\n+        }\n+        pnl1.add(list);\n+\n+        list.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent ev) {\n+                PassFailJFrame.log(\"ActionPerformed\");\n+            }\n+        });\n+\n+        list.addItemListener(new ItemListener() {\n+            @Override\n+            public void itemStateChanged(ItemEvent ev) {\n+                PassFailJFrame.log(\"ItemSelected\");\n+            }\n+        });\n+        frame.pack();\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/ListActionEventTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4117288\n+ * @summary JDKversion1.2beta3-J List's add() method is much slower.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ListAddPerfTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+public class ListAddPerfTest {\n+\n+    static Button button;\n+    static List list;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+         It is used to check the performance of List add operation.\n+\n+         Instructions:\n+             Click on the Remove All button.\n+             The list should be cleared.\n+             The button is now named \"Add Items\".\n+             Click on the \"Add Items\" button.\n+             800 items should be added to the list.\n+             Notice not only how fast or slow this is, but also how\n+             'smooth' it goes as well i.e. without any flashing.\n+\n+             Press pass if the list performance is acceptable.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ListAddPerfTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int)INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(ListAddPerfTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame frame = new Frame(\"ListAddPerfTest\");\n+        frame.setLayout(new BorderLayout());\n+\n+        button = new Button(\"Remove All\");\n+        button.addActionListener((ActionEvent e) -> {\n+            if (list.getItemCount() > 0) {\n+                list.removeAll();\n+                list.invalidate();\n+                button.setLabel(\"Add Items\");\n+            } else {\n+                for (int i = 0; i < 800; i ++) {\n+                    list.add(\"My number is \" + i);\n+                }\n+                button.setLabel(\"Remove All\");\n+            }\n+        });\n+\n+        list = new List(15);\n+        for (int i = 0; i < 800; i ++) {\n+            list.add(\"My number is \" + i);\n+        }\n+\n+        frame.add(\"North\", button);\n+        frame.add(\"South\", list);\n+\n+        frame.pack();\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/ListAddPerfTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4085379\n+ * @summary List component not properly \"resized\" with GridBagLayout\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ListFrameResizeTest\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.Insets;\n+import java.awt.List;\n+\n+public class ListFrameResizeTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        This test is for windows only.\n+\n+        1. A Frame will appear with a List\n+           (the List occupies the whole Frame)\n+        2. Minimize the Frame, the Frame is now in the Task Bar (ie.,iconified)\n+        3. Right click (right mouse button) the icon in the task bar\n+           and click on the 'maximize' menuitem to maximize the Frame\n+        4. If you notice the List has not been resized\n+           (ie.,if it partly occupies the Frame), then press FAIL else press PASS\".\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ListFrameResizeTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(ListFrameResizeTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        wintest client = new wintest(\"ListFrameResizeTest Frame\");\n+        client.resize(500, 300);\n+        client.setBackground(Color.blue);\n+        return client;\n+    }\n+\n+}\n+\n+class wintest extends Frame {\n+    private List msg;\n+\n+    public wintest(String title) {\n+        super(title);\n+        msg = new List();\n+        for (int i = 0; i < 100; i++) {\n+            msg.add(\"\" + i);\n+        }\n+\n+        GridBagLayout gridbag = new GridBagLayout();\n+        GridBagConstraints constraints = new GridBagConstraints();\n+\n+        setLayout(gridbag);\n+\n+        constraints.fill = GridBagConstraints.BOTH;\n+\n+        constraints.anchor = GridBagConstraints.CENTER;\n+        constraints.insets = new Insets(10, 10, 10, 10);\n+        constraints.ipadx = 0;\n+        constraints.ipady = 0;\n+        constraints.weightx = 1;\n+        constraints.weighty = 1;\n+        constraints.gridx = 0;\n+        constraints.gridy = 0;\n+        constraints.gridwidth = GridBagConstraints.REMAINDER;\n+        constraints.gridheight = GridBagConstraints.REMAINDER;\n+        gridbag.setConstraints(msg, constraints);\n+        add(msg);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/ListFrameResizeTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6240151\n+ * @summary XToolkit: Dragging the List scrollbar initiates DnD\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MouseDraggedOriginatedByScrollBarTest\n+*\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.event.MouseMotionAdapter;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+public class MouseDraggedOriginatedByScrollBarTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            1) Click and drag the scrollbar of the list.\n+            2) Keep dragging till the mouse pointer goes out the scrollbar.\n+            3) The test failed if you see messages about events. The test passed if you don't.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"MouseDraggedOriginatedByScrollBarTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(MouseDraggedOriginatedByScrollBarTest::createTestUI)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame frame = new Frame();\n+        List list = new List(4, false);\n+\n+        list.add(\"000\");\n+        list.add(\"111\");\n+        list.add(\"222\");\n+        list.add(\"333\");\n+        list.add(\"444\");\n+        list.add(\"555\");\n+        list.add(\"666\");\n+        list.add(\"777\");\n+        list.add(\"888\");\n+        list.add(\"999\");\n+\n+        frame.add(list);\n+\n+        list.addMouseMotionListener(\n+            new MouseMotionAdapter(){\n+                @Override\n+                public void mouseDragged(MouseEvent me){\n+                    PassFailJFrame.log(me.toString());\n+                }\n+            });\n+\n+        list.addMouseListener(\n+            new MouseAdapter() {\n+                public void mousePressed(MouseEvent me) {\n+                    PassFailJFrame.log(me.toString());\n+                }\n+\n+                public void mouseReleased(MouseEvent me) {\n+                    PassFailJFrame.log(me.toString());\n+                }\n+\n+                public void mouseClicked(MouseEvent me){\n+                    PassFailJFrame.log(me.toString());\n+                }\n+            });\n+\n+        frame.setLayout(new FlowLayout());\n+        frame.pack();\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/MouseDraggedOriginatedByScrollBarTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4201967\n+ * @summary tests that a multiselection list doesn't causes crash when FileDialog is invoked\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultiSelectionListCrashTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FileDialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+public class MultiSelectionListCrashTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+         Press \"Invoke dialog\" button to invoke a FileDialog.\n+         When it appears close it by pressing cancel button.\n+         If all remaining frames are enabled and\n+         page fault didn't occur the test passed. Otherwise the test failed.\n+\n+         Try to invoke a FileDialog several times to verify that the bug doesn't exist.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"MultiSelectionListCrashTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(MultiSelectionListCrashTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+\n+        Frame frame = new Frame(\"MultiSelectionListCrashTest frame\");\n+        Button button = new Button(\"Invoke dialog\");\n+        button.addActionListener(new FileDialogInvoker(frame));\n+        List list = new List(4, true);\n+        list.add(\"Item1\");\n+        list.add(\"Item2\");\n+        frame.setLayout(new FlowLayout());\n+        frame.add(button);\n+        frame.add(list);\n+        frame.setSize(200, 200);\n+        return frame;\n+    }\n+}\n+\n+class FileDialogInvoker implements ActionListener {\n+     FileDialog fileDialog;\n+\n+     public FileDialogInvoker(Frame frame) {\n+         fileDialog = new FileDialog(frame);\n+     }\n+\n+     public void actionPerformed(ActionEvent e) {\n+         fileDialog.setVisible(true);\n+     }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/List\/MultiSelectionListCrashTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4102881\n+ * @summary Ensure multiple selection Lists have horizontal scrollbars when necessary\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultiSelectionListHorizScrollbar\n+*\/\n+\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.List;\n+\n+public class MultiSelectionListHorizScrollbar {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+         Resize the frame so that the lists are not wide enough\n+         to fully display the lines of text they contain.\n+         Once the lists are in this state, press pass\n+         if both lists display an horizontal scrollbar. Otherwise press fail.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"MultiSelectionListHorizScrollbar Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(MultiSelectionListHorizScrollbar::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame frame = new Frame(\"MultiSelectionListHorizScrollbar Frame\");\n+        List singleList = new List(3);\n+        List multiList = new List(3, true);\n+\n+        frame.setLayout(new GridLayout(1, 2));\n+        frame.add(singleList);\n+        frame.add(multiList);\n+\n+        singleList.addItem(\"This is the 1st item in the list! Does it scroll horizontally??\");\n+        singleList.addItem(\"This is the 2nd item in the list! Does it scroll horizontally??\");\n+        singleList.addItem(\"This is the 4th item in the list! Does it scroll horizontally??\");\n+        singleList.addItem(\"This is the 5th item in the list! Does it scroll horizontally??\");\n+        singleList.addItem(\"This is the 6th item in the list! Does it scroll horizontally??\");\n+\n+        multiList.addItem(\"This is the 1st item in the list! Does it scroll horizontally??\");\n+        multiList.addItem(\"This is the 2nd item in the list! Does it scroll horizontally??\");\n+        multiList.addItem(\"This is the 4th item in the list! Does it scroll horizontally??\");\n+        multiList.addItem(\"This is the 5th item in the list! Does it scroll horizontally??\");\n+        multiList.addItem(\"This is the 6th item in the list! Does it scroll horizontally??\");\n+\n+        frame.pack();\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/MultiSelectionListHorizScrollbar.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6308295\n+ * @summary XAWTduplicate list item is displayed\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual RepaintAfterResize\n+*\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+\n+public class RepaintAfterResize {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            1) A Frame appears with a list\n+            2) Resize somehow the frame using mouse\n+            3) Move down the vertical scrollbar of the list\n+            4) If you see that two selected items are displayed then the test failed.\n+               Otherwise, the test passed.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"RepaintAfterResize Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(RepaintAfterResize::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame frame = new Frame(\"RepaintAfterResize Frame\");\n+        List list = new List(4, false);\n+\n+        frame.setLayout (new FlowLayout ());\n+        list.setBounds(100, 100, 100, 100);\n+        for (int i = 0 ; i < 7 ; i++) {\n+            list.add(\" \" + i);\n+        }\n+        frame.add(list);\n+        list.select(3);\n+\n+        frame.setSize(100, 100);\n+        return frame;\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/RepaintAfterResize.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4024943\n+ * @summary  Test for position of List scrollbar when it is added\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ScrollbarPositionTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+public class ScrollbarPositionTest {\n+    static int item = 0;\n+    static List list;\n+    static Button addButton, delButton;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        Click on the \"Add List Item\" button many times\n+        until the vertical scrollbar appears.\n+        Verify that the displayed vertical scrollbar does not take the space\n+        that was occupied by buttons before the scrollbar is shown.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ScrollbarPositionTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(ScrollbarPositionTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Panel pan;\n+\n+        Frame frame = new Frame(\"ScrollbarPositionTest Frame\");\n+        frame.setLayout(new GridLayout(1, 2));\n+        list = new List();\n+        frame.add(list);\n+        frame.add(pan = new Panel());\n+        pan.setLayout(new GridLayout(4, 1));\n+\n+        MyListener listener = new MyListener();\n+        addButton = new Button(\"Add List Item\");\n+        addButton.addActionListener(listener);\n+        pan.add(addButton);\n+\n+        delButton = new Button(\"Delete List Item\");\n+        delButton.addActionListener(listener);\n+        pan.add(delButton);\n+\n+        frame.pack();\n+        return frame;\n+    }\n+\n+    static class MyListener implements ActionListener {\n+        public void actionPerformed(ActionEvent evt) {\n+            if (evt.getSource() == addButton) {\n+                String s = \"item\";\n+                for (int i = 0; i <= item; i++) {\n+                    s = s +\" \"+Integer.toString(i);\n+                }\n+                item++;\n+                list.addItem(s);\n+            } else if (evt.getSource() == delButton) {\n+                int i;\n+                if ((i = list.countItems()) > 0) {\n+                    list.delItem(i - 1);\n+                    --item;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/ScrollbarPositionTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6336384\n+ * @summary ScrollBar does not show up correctly\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ScrollbarPresenceTest\n+*\/\n+\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.List;\n+\n+public class ScrollbarPresenceTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        You will see a list,\n+        If a vertical scrollbar appears on the list and the list is big enough\n+        to show all items then the test failed else the test passed.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ScrollbarPresenceTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(ScrollbarPresenceTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame frame = new Frame(\"ScrollbarPresenceTest Frame\");\n+        List list = new List();\n+\n+        for (int i = 0; i < 6; i++) {\n+            list.addItem(\"Row \" + i);\n+        }\n+\n+        list.setFont(new Font(\"MonoSpaced\", Font.PLAIN, 12));\n+        list.setBounds(30, 30, 128, 104);\n+        frame.add(list);\n+\n+        frame.pack();\n+        return frame;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/List\/ScrollbarPresenceTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4676536\n+ * @summary REGRESSION: makeVisible() method of List Component does not perform\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual SelectedItemVisibilityTest\n+ *\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.List;\n+\n+public class SelectedItemVisibilityTest {\n+\n+    static List list1, list2;\n+    static int visibleItem = 4;\n+    static int selectedItems[] = {6, 7, 8};\n+    static String selectedItemsStr = \"\";\n+\n+    static {\n+        for (int i = 0 ; i < selectedItems.length ; i++) {\n+            selectedItemsStr += \"\"+selectedItems[i]+\" \";\n+        }\n+    }\n+\n+    private static final String INSTRUCTIONS =\n+            \"You should see two lists.\\n\" +\n+            \"\\n\" +\n+            \"list1: \\n\" +\n+            \"\\t1. the first visible item should be \" + visibleItem +\n+            \"\\n\\t2. the selected item should be \" + selectedItems[0] +\n+            \"\\n\" +\n+            \"list2:\\n\" +\n+            \"\\t1. the first visible item should be \" + visibleItem +\n+            \"\\n\\t2. the selected items should be \" + selectedItemsStr +\n+            \"\\n\" +\n+            \"\\nIf it is so the test passed else failed.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"SelectedItemVisibilityTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(SelectedItemVisibilityTest::createTestUI)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+\n+        Frame frame = new Frame(\"SelectedItemVisibilityTest Frame\");\n+        frame.setLayout(new FlowLayout());\n+\n+        \/\/ list1\n+        list1 = new List(4);\n+        for (int i = 0; i < 20; i++) {\n+            list1.add(\"\"+i);\n+        }\n+        list1.makeVisible(visibleItem);\n+        list1.select(selectedItems[0]);\n+        frame.add(new Label(\"list1:\"));\n+        frame.add(list1);\n+\n+        \/\/ list2\n+        list2 = new List(4);\n+        list2.setMultipleMode(true);\n+        for (int i = 0; i < 20; i++) {\n+            list2.add(\"\"+i);\n+        }\n+        list2.makeVisible(visibleItem);\n+        for (int i = 0 ; i < selectedItems.length ; i++) {\n+            list2.select(selectedItems[i]);\n+        }\n+        frame.add(new Label(\"list2:\"));\n+        frame.add(list2);\n+        frame.setSize(200, 200);\n+\n+        \/\/ common output\n+        String s;\n+        int sel[];\n+\n+        PassFailJFrame.log(\"list1: \");\n+        PassFailJFrame.log(\"\\tgetVisibleIndex=\"+list1.getVisibleIndex());\n+        sel = list1.getSelectedIndexes();\n+        s = \"\\tgetSelectedIndexes=\";\n+        for (int i = 0 ; i < sel.length ; i++) {\n+            s += \"\" + sel[i] + \" \";\n+        }\n+        PassFailJFrame.log(s);\n+\n+        PassFailJFrame.log(\"list2: \");\n+        PassFailJFrame.log(\"\\tgetVisibleIndex=\"+list2.getVisibleIndex());\n+        sel = list2.getSelectedIndexes();\n+        s = \"\\tgetSelectedIndexes=\";\n+        for (int i = 0 ; i < sel.length ; i++) {\n+            s += \"\" + sel[i] + \" \";\n+        }\n+        PassFailJFrame.log(s);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/SelectedItemVisibilityTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6246467\n+ * @summary Tests that list works correctly if user specified foreground colors on XToolkit\/Motif\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual SetForegroundTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.ScrollPane;\n+\n+public class SetForegroundTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        To make sure, that for each component\n+        (Button, Checkbox, Label, List, TextArea, TextField, Choice)\n+        in the frame,\n+        the title exist and the color of the title is red.\n+        If not, the test failed.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"SetForegroundTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(SetForegroundTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame frame = new Frame();\n+        ScrollPane sp = new ScrollPane() {\n+            public Dimension getPreferredSize() {\n+                return new Dimension(180, 180);\n+            }\n+        };\n+        Panel p = new Panel();\n+        Component childs[] = new Component[] {new Button(\"button\"),\n+                                              new Checkbox(\"checkbox\"),\n+                                              new Label(\"label\"),\n+                                              new List(3, false),\n+                                              new TextArea(\"text area\"),\n+                                              new TextField(\"text field\"),\n+                                              new Choice()};\n+\n+        p.setLayout (new FlowLayout ());\n+\n+        sp.add(p);\n+\n+        sp.validate();\n+\n+        frame.add(sp);\n+        for (int i = 0; i < childs.length; i++){\n+            childs[i].setForeground(Color.red);\n+        }\n+\n+        for (int i = 0; i < childs.length; i++) {\n+            p.add(childs[i]);\n+            if (childs[i] instanceof List) {\n+                ((List)childs[i]).add(\"list1\");\n+                ((List)childs[i]).add(\"list2\");\n+            } else if (childs[i] instanceof Choice) {\n+                ((Choice)childs[i]).add(\"choice1\");\n+                ((Choice)childs[i]).add(\"choice2\");\n+            }\n+        }\n+        frame.pack();\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/SetForegroundTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4009555\n+ * @summary Unit test for a new method in Container class: getMousePosition(boolean)\n+ *          while Container resized.\n+ *\/\n+\n+public class ContainerResizeMousePositionTest {\n+    private static Frame frame;\n+    private static Button button;\n+    private static Robot robot;\n+    private static volatile Point frameLocation;\n+    private static volatile Point newLoc;\n+    private static boolean testSucceeded = false;\n+\n+    private static final CountDownLatch eventCaught = new CountDownLatch(1);\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            EventQueue.invokeAndWait(() -> createAndShowUI());\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            testUI();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new Frame(\"Testing getMousePosition() after resize\");\n+        button = new Button(\"Button\");\n+        frame.setLayout(new BorderLayout());\n+        frame.add(button);\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void testUI() throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            frameLocation = frame.getLocationOnScreen();\n+            newLoc = new Point(frame.getWidth() + 10, frame.getHeight() + 10);\n+        });\n+\n+        robot.mouseMove(frameLocation.x + newLoc.x, frameLocation.y + newLoc.y);\n+        EventQueue.invokeAndWait(() -> {\n+            button.addComponentListener(new ResizeAdapter());\n+            frame.setSize(frame.getWidth() * 2, frame.getHeight() * 2);\n+            frame.validate();\n+        });\n+        robot.waitForIdle();\n+        robot.delay(500);\n+\n+        if (!eventCaught.await(2, TimeUnit.SECONDS)) {\n+            throw new RuntimeException(\"componentResized Event isn't\"\n+                                       + \" received within a timeout\");\n+        }\n+\n+        if (!testSucceeded) {\n+            throw new RuntimeException(\"Container.getMousePosition(boolean)\"\n+                                       + \" returned incorrect result while Container resized\");\n+        }\n+    }\n+\n+    static class ResizeAdapter extends ComponentAdapter {\n+        int testStageCounter = 0;\n+        @Override\n+        public void componentResized(ComponentEvent e) {\n+            Point pTrue = frame.getMousePosition(true);\n+            if (frame.getMousePosition(false) == null) {\n+                testStageCounter++;\n+                System.out.println(\"\"\"\n+                                    TEST STAGE 1 PASSED:\n+                                    Container.getMousePosition(false)\n+                                    returned NULL over Child Component\n+                                    during resize.\n+                                    \"\"\");\n+            }\n+            if (pTrue != null) {\n+                testStageCounter++;\n+                System.out.println(\"\"\"\n+                                    TEST STAGE 2 PASSED:\n+                                    Container.getMousePosition(true)\n+                                    returned NON-NULL over Child Component\n+                                    during resize.\n+                                    \"\"\");\n+            }\n+            if (pTrue != null && pTrue.x == newLoc.x && pTrue.y == newLoc.y) {\n+                testStageCounter++;\n+                System.out.println(\"\"\"\n+                                    TEST STAGE 3 PASSED:\n+                                    Container.getMousePosition(true)\n+                                    returned correct result over Child Component\n+                                    during resize.\n+                                    \"\"\");\n+            }\n+            testSucceeded = testStageCounter == 3;\n+            eventCaught.countDown();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/MouseInfo\/ContainerResizeMousePositionTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.MenuItem;\n+import java.awt.PopupMenu;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 6267162\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Popup Menu gets hidden below the screen when opened near the periphery\n+ *          of the screen, XToolkit Test if popup menu window is adjusted on screen\n+ *          when trying to show outside\n+ * @run main\/manual PeripheryOfScreen\n+ *\/\n+\n+public class PeripheryOfScreen {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Click on the button to show popup menu in the center of\n+                frame. Move frame beyond the edge of screen and click on\n+                button to show the popup menu and see if popup menu is\n+                adjusted to the edge.\n+\n+                Press Pass if popup menu behaves as per instruction, otherwise\n+                press Fail.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"PeripheryOfScreen Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .testUI(PeripheryOfScreen::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI () {\n+        Frame f = new Frame(\"PeripheryOfScreen Test frame\");\n+        Button b = new Button(\"Click to show popup menu\");\n+        PopupMenu pm = new PopupMenu(\"Test menu\");\n+        MenuItem i = new MenuItem(\"Click me\");\n+        pm.add(i);\n+        b.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                pm.show(f, 100, 100);\n+            }\n+        });\n+        f.add(b);\n+        f.add(pm);\n+        f.setSize(300, 200);\n+        f.toFront();\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/PeripheryOfScreen.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Component;\n+import java.awt.Frame;\n+import java.awt.Font;\n+import java.awt.MenuItem;\n+import java.awt.PopupMenu;\n+\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4169155\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Popup menus get a leading separator on Motif system\n+ * @run main\/manual PopupLeadingSeparatorTest\n+ *\/\n+\n+public class PopupLeadingSeparatorTest {\n+    public static void main(String[] args) throws Exception {\n+        PopupLeadingSeparatorTest obj = new PopupLeadingSeparatorTest();\n+        String INSTRUCTIONS = \"\"\"\n+                Press mouse button on the frame. Popup menu without leading\n+                separator should appear.\n+                If a PopupMenu behaves same, press Pass, else press Fail.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"PopupLeadingSeparatorTest Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .testUI(obj::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private Frame createUI() {\n+        Frame f = new Frame(\"PopupLeadingSeparatorTest Test\");\n+        PopupMenu popupMenu = new PopupMenu(\"Popup Menu Title\");\n+        popupMenu.add(new MenuItem(\"Item1\"));\n+        PopupMenu cascadeMenu = new PopupMenu(\"Multifont menu\");\n+        cascadeMenu.add(new MenuItem(\"Item1\"));\n+        MenuItem item2 = new MenuItem(\"Item2\");\n+        item2.setFont(new Font(\"Serif\", Font.BOLD, 36));\n+        cascadeMenu.add(item2);\n+\n+        popupMenu.add(cascadeMenu);\n+        f.add(popupMenu);\n+        f.setSize(300, 150);\n+        f.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mousePressed(MouseEvent evt) {\n+                popupMenu.show((Component) evt.getSource(), evt.getX(), evt.getY());\n+            }\n+        });\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/PopupLeadingSeparatorTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.MenuItem;\n+import java.awt.PopupMenu;\n+\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4168006 4196790\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Popup menu test fails on x86\/Solaris 2.6 combination.\n+ * @run main\/manual PopupMenuShowTest\n+ *\/\n+\n+public class PopupMenuShowTest {\n+    public static void main(String[] args) throws Exception {\n+        PopupMenuShowTest obj = new PopupMenuShowTest();\n+        String INSTRUCTIONS = \"\"\"\n+                Press the right mouse button in the PopupTest window.\n+                If a PopupMenu appears, press Pass, else press Fail.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"PopupMenuShowTest Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .testUI(obj::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private Frame createUI() {\n+        Frame f = new Frame(\"PopupMenuShowTest Test\");\n+        f.setLayout(new FlowLayout());\n+        f.add(new Label(\"Press right mouse button inside this frame.\"));\n+        f.add(new Label(\"A pop-up menu should appear.\"));\n+        PopupMenu popupMenu = new PopupMenu(\"Popup Menu Title\");\n+        MenuItem mi = new MenuItem(\"Menu Item\");\n+        popupMenu.add(mi);\n+        f.add(popupMenu);\n+        f.setSize(400, 350);\n+        f.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseClicked(MouseEvent e) {\n+                popupMenu.show(e.getComponent(), e.getX(), e.getY());\n+            }\n+        });\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/PopupMenuShowTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.PopupMenu;\n+\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4038140\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test for functionality of PopupMenuWithMenuBar\n+ * @run main\/manual PopupMenuWithMenuBar\n+ *\/\n+\n+public class PopupMenuWithMenuBar {\n+    public static void main(String[] args) throws Exception {\n+        PopupMenuWithMenuBar obj = new PopupMenuWithMenuBar();\n+        String INSTRUCTIONS = \"\"\"\n+                There was a bug that prevented the popup menu from appearing properly\n+                (if even at all) for a frame window when there is also a menu bar.\n+\n+                Right click inside the frame window to display the popup window. If\n+                the popup menu appears normally, then the test is successful and the\n+                bug has been fixed.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"PopupMenuWithMenuBar Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .testUI(obj::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private Frame createUI() {\n+        Frame f = new Frame(\"PopupMenuWithMenuBar Test\");\n+        f.setBounds(10, 10, 300, 250);\n+        MenuBar menuBar = new MenuBar();\n+        Menu fileMenu = createFileMenu();\n+        menuBar.add(fileMenu);\n+        f.setMenuBar(menuBar);\n+        PopupMenu popupMenu = createPopupMenu();\n+        f.add(popupMenu);\n+        f.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseClicked(MouseEvent e) {\n+                popupMenu.show(f, e.getX(), e.getY());\n+            }\n+        });\n+        return f;\n+    }\n+\n+    private Menu createFileMenu() {\n+        String[] menu1Labels = new String[]\n+                {\"Save As\", \"Save As\", \"Quit\"};\n+        MenuItem menuItem;\n+        Menu returnMenu = new Menu(\"File\");\n+        for (int menu1Index = 0; menu1Index < menu1Labels.length; menu1Index++) {\n+            menuItem = new MenuItem(menu1Labels[menu1Index]);\n+            returnMenu.add(menuItem);\n+        }\n+        return returnMenu;\n+    }\n+\n+    private PopupMenu createPopupMenu() {\n+        String[] popupLabels = new String[]\n+                {\"Popup 1\", \"Popup 2\", \"Quit\"};\n+        MenuItem menuItem;\n+        PopupMenu returnMenu = new PopupMenu(\"Popups\");\n+        for (int popupIndex = 0; popupIndex < popupLabels.length; popupIndex++) {\n+            menuItem = new MenuItem(popupLabels[popupIndex]);\n+            returnMenu.add(menuItem);\n+        }\n+        return returnMenu;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/PopupMenuWithMenuBar.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Frame;\n+import java.awt.MenuItem;\n+import java.awt.PopupMenu;\n+\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4181790\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Tests a popup menu on a button.\n+ * @run main\/manual PopupOnButton\n+ *\/\n+\n+public class PopupOnButton {\n+   public static void main(String[] args) throws Exception {\n+       PopupOnButton obj = new PopupOnButton();\n+       String INSTRUCTIONS = \"\"\"\n+                Right-click on the button.\n+                Popup Menu should appear and behave fine.\n+                If a PopupMenu appears, press Pass, else press Fail.\n+                \"\"\";\n+\n+       PassFailJFrame.builder()\n+               .title(\"PopupOnButton Instruction\")\n+               .instructions(INSTRUCTIONS)\n+               .columns(40)\n+               .testUI(obj::createUI)\n+               .build()\n+               .awaitAndCheck();\n+   }\n+\n+    private Frame createUI() {\n+        Frame f = new Frame(\"PopupOnButton Test\");\n+        Button b = new Button(\"button with popup menu\");\n+        PopupMenu m = new PopupMenu(\"popup\");\n+        m.add(new MenuItem(\"item1\"));\n+        m.add(new MenuItem(\"item2\"));\n+        m.add(new MenuItem(\"item3\"));\n+        b.add(m);\n+        b.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mousePressed(MouseEvent e) {\n+                if (e.isPopupTrigger()) {\n+                    m.show((Component) e.getSource(), e.getX(), e.getY());\n+                }\n+            }\n+\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                if (e.isPopupTrigger()) {\n+                    m.show((Component) e.getSource(), e.getX(), e.getY());\n+                }\n+            }\n+        });\n+\n+        f.add(b);\n+        f.setSize(200, 150);\n+        return f;\n+    }\n+ }\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/PopupOnButton.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,446 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.JobAttributes;\n+import java.awt.Label;\n+import java.awt.List;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.PageAttributes;\n+import java.awt.Panel;\n+import java.awt.PrintJob;\n+import java.awt.Scrollbar;\n+import java.awt.ScrollPane;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.JobAttributes.DialogType;\n+import java.awt.PageAttributes.OriginType;\n+\n+import java.util.Enumeration;\n+import java.util.Properties;\n+\n+\/*\n+ * @test\n+ * @bug 4247583\n+ * @key printer\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Tests that the old Properties API still works\n+ * @run main\/manual PrintCompatibilityTest\n+ *\/\n+\n+public class PrintCompatibilityTest {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        String INSTRUCTIONS = \"\"\"\n+                A frame window will appear.\n+                Choose 'Print to Printer...' from the 'Print' menu. Make sure that you print\n+                to a printer, not a file. Examine the output and verify that the frame and all\n+                the components in it get printed properly.\n+\n+                Known problems:\n+                    * The text in the second row of the menubar is not indented correctly.\n+\n+                You can also use the 'Print to Screen...' command for a quick manual check that\n+                printing works, but this is only for debugging purposes.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"PrintComponentTest Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(60)\n+                .testTimeOut(10)\n+                .testUI(new MainFrame())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class MainFrame extends Frame {\n+    private LWContainer lwc;\n+\n+    public MainFrame() {\n+        super(\"PrintCompatibilityTest\");\n+\n+        setSize(800, 400);\n+        setLayout(new FlowLayout());\n+\n+        \/\/ peered components\n+        Button button = new Button(\"Button\");\n+        button.setFont(new Font(\"Dialog\", Font.PLAIN, 12));\n+        add(button);\n+        add(new TestCanvas());\n+        Checkbox cbox = new Checkbox(\"Checkbox\", true);\n+        cbox.setFont(new Font(\"DialogInput\", Font.PLAIN, 12));\n+        add(cbox);\n+        Choice choice = new Choice();\n+        choice.add(\"Choice 1\");\n+        choice.add(\"Choice Two\");\n+        choice.setFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n+        add(choice);\n+        Label label = new Label(\"Label\");\n+        label.setFont(new Font(\"Serif\", Font.PLAIN, 12));\n+        add(label);\n+        List list = new List();\n+        list.add(\"List 1\");\n+        list.add(\"List Two\");\n+        list.setFont(new Font(\"SansSerif\", Font.PLAIN, 12));\n+        add(list);\n+        add(new Scrollbar(Scrollbar.VERTICAL) );\n+        add(new Scrollbar(Scrollbar.HORIZONTAL) );\n+        ScrollPane scrollpane = new ScrollPane();\n+        Button spButton = new Button(\"Button in a scrollpane\");\n+        spButton.setFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n+        scrollpane.add(spButton);\n+        add(scrollpane);\n+        TextArea textarea = new TextArea(\"TextArea\", 3, 30);\n+        textarea.setFont(new Font(\"Dialog\", Font.ITALIC, 10));\n+        add(textarea);\n+        TextField textfield = new TextField(\"TextField\");\n+        textfield.setFont(new Font(\"DialogInput\", Font.ITALIC, 10));\n+        add(textfield);\n+\n+        \/\/ nested components\n+        Panel panel1 = new Panel();\n+        panel1.setLayout(new FlowLayout());\n+        panel1.setBackground(Color.red);\n+        this.add(panel1);\n+\n+        Button p1Button = new Button(\"level 2\");\n+        p1Button.setFont(new Font(\"Monospaced\", Font.ITALIC, 10));\n+        panel1.add(p1Button);\n+\n+        Panel panel2 = new Panel();\n+        panel2.setLayout(new FlowLayout());\n+        panel2.setBackground(Color.green);\n+        panel1.add(panel2);\n+\n+        Button p2Button = new Button(\"level 3\");\n+        p2Button.setFont(new Font(\"Serif\", Font.ITALIC, 10));\n+        panel2.add(p2Button);\n+\n+\n+        \/\/ lightweight components\n+        LWButton lwbutton = new LWButton(\"LWbutton\");\n+        lwbutton.setFont(new Font(\"SansSerif\", Font.ITALIC, 10));\n+        add(lwbutton);\n+\n+        lwc = new LWContainer(\"LWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainer\");\n+        lwc.setFont(new Font(\"Monospaced\", Font.ITALIC, 10));\n+        add(lwc);\n+        Button lwcButton1 = new Button(\"HW Button 1\");\n+        Button lwcButton2 = new Button(\"HW Button 2\");\n+        LWButton lwcButton3 = new LWButton(\"LW Button\");\n+        lwcButton1.setFont(new Font(\"Dialog\", Font.BOLD, 14));\n+        lwcButton2.setFont(new Font(\"DialogInput\", Font.BOLD, 14));\n+        lwcButton3.setFont(new Font(\"Monospaced\", Font.BOLD, 14));\n+        lwc.add(lwcButton1);\n+        lwc.add(lwcButton2);\n+        lwc.add(lwcButton3);\n+\n+        \/\/ overlapping components\n+        add(new ZOrderPanel());\n+\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+        Menu menu = new Menu(\"Print\");\n+        Menu menu2 = new Menu(\"File\");\n+        Menu menu3 = new Menu(\"Edit\");\n+        Menu menu4 = new Menu(\"ReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyLong\");\n+        menu2.setFont(new Font(\"SansSerif\", Font.BOLD, 20));\n+        menu2.setEnabled(false);\n+        menu3.setFont(new Font(\"Monospaced\", Font.ITALIC, 18));\n+        menu3.setEnabled(false);\n+        menu4.setEnabled(false);\n+        MenuItem itemPrinter = new MenuItem(\"Print to Printer...\");\n+        MenuItem itemScreen = new MenuItem(\"Print to Screen...\");\n+        menu.add(itemPrinter);\n+        menu.add(itemScreen);\n+        MenuBar menuBar = new MenuBar();\n+        menuBar.add( menu );\n+        menuBar.add( menu2 );\n+        menuBar.add( menu3 );\n+        menuBar.add( menu4 );\n+        setMenuBar(menuBar);\n+\n+        itemPrinter.addActionListener( new ActionPrint() );\n+        itemScreen.addActionListener( new ActionPrintToScreen() );\n+        setVisible(true);\n+    }\n+\n+    static void printProps(Properties props)\n+    {\n+        Enumeration propNames = props.propertyNames();\n+        while (propNames.hasMoreElements()) {\n+            String propName = (String)propNames.nextElement();\n+            PassFailJFrame.log( propName + \" = \" + props.getProperty(propName));\n+        }\n+    }\n+\n+    class ActionPrint implements ActionListener {\n+        private final int ITERATIONS = 1;\n+        private Properties props = new Properties();\n+\n+        public void actionPerformed(ActionEvent ev) {\n+            PassFailJFrame.log(\"About to show print dialog...\");\n+            printProps(props);\n+            PrintJob pj = getToolkit().getPrintJob(\n+                MainFrame.this, \"Print test!\", props);\n+            if (pj == null) {\n+                return;\n+            }\n+            Dimension d = pj.getPageDimension();\n+            PassFailJFrame.log(\"About to print...\");\n+            PassFailJFrame.log(\"Dimensions: \" + d);\n+            printProps(props);\n+\n+            \/\/ For xor mode set, there is a printing issue with number of copies to be print.\n+            \/\/ So, ITERATIONS are changed to 1 from 3.\n+            \/\/ So, for now the XOR related code is commented out.\n+\n+            \/\/boolean xor = false;\n+\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                Graphics g = pj.getGraphics();\n+                g.setColor(Color.red);\n+                \/\/if (xor) {\n+                \/\/    g.setXORMode(Color.blue);\n+                \/\/}\n+                g.translate(13, 13);\n+                printAll(g);\n+                g.dispose();\n+                \/\/xor = (xor) ? false : true;\n+            }\n+\n+            \/\/ For xor mode set, LWC components don't get printed.\n+            \/\/ So, for now the code is commented out and separate bug\n+            \/\/ (JDK-8340495) is filed to handle it.\n+\n+            \/\/ one more page so that we can test printing a lightweight\n+            \/\/ at the top of the hierarchy (BugId 4212564)\n+            \/\/Graphics g = pj.getGraphics();\n+            \/\/g.setColor(Color.red);\n+            \/\/g.translate(13, 13);\n+            \/\/lwc.printAll(g);\n+            \/\/g.dispose();\n+            \/\/ end 4212564\n+\n+            pj.end();\n+        }\n+    }\n+\n+    class ActionPrintToScreen implements ActionListener {\n+        public void actionPerformed(ActionEvent ev) {\n+            PrintFrame printFrame = new PrintFrame(MainFrame.this);\n+            printFrame.show();\n+            Graphics g = printFrame.getGraphics();\n+            g.setColor(Color.red);\n+            printAll(g);\n+            g.dispose();\n+        }\n+    }\n+\n+    \/\/ Frame window that displays results of printing\n+    \/\/ main window to a screen Graphics-- useful for\n+    \/\/ quick testing of printing\n+    class PrintFrame extends Frame\n+    {\n+        private Component printComponent;\n+        public PrintFrame( Component c )\n+        {\n+            super(\"Print to Screen\");\n+            printComponent = c ;\n+            addWindowListener( new WindowAdapter() {\n+                                        public void windowClosing(WindowEvent ev) {\n+                                            setVisible(false);\n+                                            dispose();\n+                                        }\n+                                    }\n+                                );\n+            setSize(printComponent.getSize());\n+            setResizable(false);\n+        }\n+\n+        public void paint( Graphics g ) {\n+            printComponent.printAll(g);\n+        }\n+    }\n+\n+    class LWButton extends Component {\n+        String label;\n+        int width = 100;\n+        int height = 30;\n+\n+        public LWButton(String label) {\n+            super();\n+            this.label = label;\n+        }\n+\n+        public void paint(Graphics g) {\n+            Dimension d = getSize();\n+            g.setColor(Color.orange);\n+            g.setFont(getFont());\n+            g.fillRect(0, 0, d.width, d.height);\n+            g.setColor(Color.black);\n+            int x = 5;\n+            int y = (d.height - 5);\n+            g.drawString(label, x, y);\n+        }\n+\n+        public Dimension getPreferredSize()\n+        {\n+            return new Dimension(width, height);\n+        }\n+    }\n+\n+    class LWContainer extends Container {\n+        String label;\n+        int width = 300;\n+        int height = 100;\n+\n+        public LWContainer(String label) {\n+            super();\n+            this.label = label;\n+            setLayout(new FlowLayout());\n+        }\n+\n+        public void paint(Graphics g) {\n+            super.paint(g);\n+            Dimension d = getSize();\n+            g.setColor(Color.green);\n+            g.setFont(getFont());\n+            g.drawLine(0, 0, d.width - 1, 0);\n+            g.drawLine(d.width - 1, 0, d.width - 1, d.height - 1);\n+            g.drawLine(d.width - 1, d.height - 1, 0, d.height - 1);\n+            g.drawLine(0, d.height - 1, 0, 0);\n+            g.setColor(Color.black);\n+            int x = 5;\n+            int y = (d.height - 5);\n+            g.drawString(label, x, y);\n+        }\n+\n+        public Dimension getPreferredSize()\n+        {\n+            return new Dimension(width, height);\n+        }\n+    }\n+\n+    class TestCanvas extends Canvas {\n+        int width = 100;\n+        int height = 100;\n+\n+        public void paint(Graphics g) {\n+            g.setColor(Color.blue);\n+            g.fillRoundRect(10, 10, 50, 50, 15, 30);\n+            g.setColor(Color.red);\n+            g.fillOval(70, 70, 25, 25);\n+        }\n+        public Dimension getPreferredSize() {\n+            return new Dimension(width, height);\n+        }\n+    }\n+\n+    class ZOrderPanel extends Panel\n+    {\n+        ZOrderPanel()\n+        {\n+            setLayout(null);\n+\n+            Component first, second, third, fourth;\n+\n+            setVisible(true);\n+            \/\/ add first component\n+            first = makeBox(\"Second\", Color.blue,\n+                            new Font(\"Serif\", Font.BOLD, 14),\n+                            -1);\n+            \/\/ insert on top\n+            second = makeBox(\"First\", Color.yellow,\n+                             new Font(\"SansSerif\", Font.BOLD, 14),\n+                             0);\n+            \/\/ put at the back\n+            fourth = makeBox(\"Fourth\", Color.red,\n+                             new Font(\"Monospaced\", Font.BOLD, 14),\n+                             2);\n+            \/\/ insert in last position\n+            third = makeBox(\"Third\", Color.green,\n+                            new Font(\"Dialog\", Font.PLAIN, 12),\n+                            3);\n+            \/\/ swap third and fourth to correct positions\n+            remove(third);\n+            add(third, 2);\n+            \/\/ re-validate so third and fourth peers change position\n+            validate();\n+            \/\/ now make things really interesting with a lightweight\n+            \/\/ component at the top of the z-order, that should print\n+            \/\/ _below_ the native guys to match the screen...\n+            add(new LWButton(\"LWButton\"), 0);\n+        }\n+\n+        public Dimension preferredSize()\n+        {\n+            return new Dimension(260, 80);\n+        }\n+\n+        public void layout()\n+        {\n+            int i, n;\n+            Insets ins = getInsets();\n+            n = getComponentCount();\n+            for (i = n-1; i >= 0; i--) {\n+                Component p = getComponent(i);\n+                p.setBounds(ins.left + 40 * i, ins.top + 5 * i, 60, 60);\n+            }\n+        }\n+\n+        public Component makeBox(String s, Color c, Font f, int index)\n+        {\n+            Label l = new Label(s);\n+            l.setBackground(c);\n+            l.setAlignment(Label.RIGHT);\n+            l.setFont(f);\n+            add(l, index);\n+            validate();\n+            return l;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PrintJob\/PrintCompatibilityTest.java","additions":446,"deletions":0,"binary":false,"changes":446,"status":"added"},{"patch":"@@ -0,0 +1,486 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.JobAttributes;\n+import java.awt.Label;\n+import java.awt.List;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.PageAttributes;\n+import java.awt.Panel;\n+import java.awt.PrintJob;\n+import java.awt.Scrollbar;\n+import java.awt.ScrollPane;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.JobAttributes.DialogType;\n+import java.awt.PageAttributes.OriginType;\n+\n+\n+\/*\n+ * @test\n+ * @bug 4111262 4035285 4038900 4046147 4049680 4084038 4100004 4105875\n+ * @bug 4117502 4037486 4068433 4128031 4151161 4151707 4155884 4212564\n+ * @bug 4025626 4029565 4034365 4036068 4040622 4061890 4067405 4086256\n+ * @bug 4113827 4116722 4121984 4145350 4146510 4172659 4179886 4218471\n+ * @bug 4219657 4227128 4242308 4245917 4265746\n+ * @key printer\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test printing of lightweight (and heavyweight) components\n+ * @run main\/manual PrintComponentTest\n+ *\/\n+\n+public class PrintComponentTest {\n+    public static void main(String[] args) throws Exception {\n+\n+        String INSTRUCTIONS = \"\"\"\n+                A frame window will appear.\n+                Choose 'Print to Printer...' from the 'Print' menu. Examine the output\n+                and verify that the frame and all the components in it get printed properly.\n+\n+                Print using both 'Portrait' and 'Landscape' orientation.\n+                Verify that the paper dimensions printed to standard error\n+                are exactly inverted.\n+                (That is, if the output for 'Portrait' is\n+                \"Dimensions: java.awt.Dimension[width=612,height=792]\" then the output\n+                for 'Landscape' should be \"Dimensions: java.awt.Dimension[width=792, height=612].)\n+\n+                Now, attempt to print a second time. When the print dialog box appears,\n+                however, cancel the print request.\n+                Verify that _no_ output is sent to standard error.\n+\n+                You should attempt to print with both the native and common print dialogs,\n+                as well as with no dialog.\n+                Note that on Linux the native and common print dialogs are identical.\n+\n+                On Windows, the common print dialog communicates with the printer to\n+                determine supported paper sizes and duplex capability.\n+                Verify that these constraints are properly enforced in the common dialog\n+                for the target printer.\n+\n+                Known problems:\n+                    * The text in the second row of the menubar is not indented\n+                      correctly.\n+\n+                You can also use the 'Print to Screen...' command for a quick manual\n+                check that printing works, but this is only for debugging purposes.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"PrintComponentTest Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(60)\n+                .testTimeOut(10)\n+                .testUI(new MainFrame())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class MainFrame extends Frame {\n+    private LWContainer lwc;\n+\n+    public MainFrame() {\n+        super(\"PrintComponentTest\");\n+\n+        setSize(800, 400);\n+        setLayout(new FlowLayout());\n+\n+        \/\/ peered components\n+        Button button = new Button(\"Button\");\n+        button.setFont(new Font(\"Dialog\", Font.PLAIN, 12));\n+        add(button);\n+        add(new TestCanvas());\n+        Checkbox cbox = new Checkbox(\"Checkbox\", true);\n+        cbox.setFont(new Font(\"DialogInput\", Font.PLAIN, 12));\n+        add(cbox);\n+        Choice choice = new Choice();\n+        choice.add(\"Choice 1\");\n+        choice.add(\"Choice Two\");\n+        choice.setFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n+        add(choice);\n+        Label label = new Label(\"Label\");\n+        label.setFont(new Font(\"Serif\", Font.PLAIN, 12));\n+        add(label);\n+        List list = new List();\n+        list.add(\"List 1\");\n+        list.add(\"List Two\");\n+        list.setFont(new Font(\"SansSerif\", Font.PLAIN, 12));\n+        add(list);\n+        add(new Scrollbar(Scrollbar.VERTICAL) );\n+        add(new Scrollbar(Scrollbar.HORIZONTAL) );\n+        ScrollPane scrollpane = new ScrollPane();\n+        Button spButton = new Button(\"Button in a scrollpane\");\n+        spButton.setFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n+        scrollpane.add(spButton);\n+        add(scrollpane);\n+        TextArea textarea = new TextArea(\"TextArea\", 3, 30);\n+        textarea.setFont(new Font(\"Dialog\", Font.ITALIC, 10));\n+        add(textarea);\n+        TextField textfield = new TextField(\"TextField\");\n+        textfield.setFont(new Font(\"DialogInput\", Font.ITALIC, 10));\n+        add(textfield);\n+\n+        \/\/ nested components\n+        Panel panel1 = new Panel();\n+        panel1.setLayout(new FlowLayout());\n+        panel1.setBackground(Color.red);\n+        this.add(panel1);\n+\n+        Button p1Button = new Button(\"level 2\");\n+        p1Button.setFont(new Font(\"Monospaced\", Font.ITALIC, 10));\n+        panel1.add(p1Button);\n+\n+        Panel panel2 = new Panel();\n+        panel2.setLayout(new FlowLayout());\n+        panel2.setBackground(Color.green);\n+        panel1.add(panel2);\n+\n+        Button p2Button = new Button(\"level 3\");\n+        p2Button.setFont(new Font(\"Serif\", Font.ITALIC, 10));\n+        panel2.add(p2Button);\n+\n+\n+        \/\/ lightweight components\n+        LWButton lwbutton = new LWButton(\"LWbutton\");\n+        lwbutton.setFont(new Font(\"SansSerif\", Font.ITALIC, 10));\n+        add(lwbutton);\n+\n+        lwc = new LWContainer(\"LWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainerLWContainer\");\n+        lwc.setFont(new Font(\"Monospaced\", Font.ITALIC, 10));\n+        add(lwc);\n+        Button lwcButton1 = new Button(\"HW Button 1\");\n+        Button lwcButton2 = new Button(\"HW Button 2\");\n+        LWButton lwcButton3 = new LWButton(\"LW Button\");\n+        lwcButton1.setFont(new Font(\"Dialog\", Font.BOLD, 14));\n+        lwcButton2.setFont(new Font(\"DialogInput\", Font.BOLD, 14));\n+        lwcButton3.setFont(new Font(\"Monospaced\", Font.BOLD, 14));\n+        lwc.add(lwcButton1);\n+        lwc.add(lwcButton2);\n+        lwc.add(lwcButton3);\n+\n+        \/\/ overlapping components\n+        add(new ZOrderPanel());\n+\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+        Menu menu = new Menu(\"Print\");\n+        Menu menu2 = new Menu(\"File\");\n+        Menu menu3 = new Menu(\"Edit\");\n+        Menu menu4 = new Menu(\"ReallyReallyReallyReallyReallyReallyReallyReally\" +\n+                \"ReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReally\" +\n+                \"ReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyLong\");\n+        menu2.setFont(new Font(\"SansSerif\", Font.BOLD, 20));\n+        menu2.setEnabled(false);\n+        menu3.setFont(new Font(\"Monospaced\", Font.ITALIC, 18));\n+        menu3.setEnabled(false);\n+        menu4.setEnabled(false);\n+        MenuItem itemJFC =\n+                new MenuItem(\"Print to Printer with Cross-Platform Dialog...\");\n+        itemJFC.setActionCommand(\"common\");\n+        MenuItem itemNative =\n+                new MenuItem(\"Print to Printer with Native Dialog...\");\n+        itemNative.setActionCommand(\"native\");\n+        MenuItem itemBackground =\n+                new MenuItem(\"Print to Printer in Background\");\n+        itemBackground.setActionCommand(\"none\");\n+        MenuItem itemScreen = new MenuItem(\"Print to Screen...\");\n+        menu.add(itemJFC);\n+        menu.add(itemNative);\n+        menu.add(itemBackground);\n+        menu.add(itemScreen);\n+        MenuBar menuBar = new MenuBar();\n+        menuBar.add( menu );\n+        menuBar.add( menu2 );\n+        menuBar.add( menu3 );\n+        menuBar.add( menu4 );\n+        setMenuBar(menuBar);\n+\n+        ActionPrint actionPrint = new ActionPrint();\n+\n+        itemJFC.addActionListener( actionPrint );\n+        itemNative.addActionListener( actionPrint );\n+        itemBackground.addActionListener( actionPrint );\n+        itemScreen.addActionListener( new ActionPrintToScreen() );\n+    }\n+\n+    class ActionPrint implements ActionListener {\n+        private final int ITERATIONS = 1;\n+        private PageAttributes pageAttributes = new PageAttributes();\n+        private JobAttributes jobAttributes = new JobAttributes();\n+\n+        public void actionPerformed(ActionEvent ev) {\n+            DialogType dialog;\n+            if (ev.getActionCommand().equals(\"common\")) {\n+                dialog = DialogType.COMMON;\n+            } else if (ev.getActionCommand().equals(\"native\")) {\n+                dialog = DialogType.NATIVE;\n+            } else {\n+                dialog = DialogType.NONE;\n+            }\n+            jobAttributes.setDialog(dialog);\n+            pageAttributes.setOrigin(OriginType.PRINTABLE);\n+            System.err.println(jobAttributes);\n+            System.err.println(pageAttributes);\n+\n+            PassFailJFrame.log(\"About to show print dialog...\");\n+\n+            PrintJob pj = getToolkit().getPrintJob(\n+                    MainFrame.this, \"Print test!\", jobAttributes, pageAttributes);\n+            if (pj == null) {\n+                return;\n+            }\n+            Dimension d = pj.getPageDimension();\n+            PassFailJFrame.log(\"About to print...\");\n+            PassFailJFrame.log(\"Dimensions: \" + d);\n+            System.err.println(jobAttributes);\n+            System.err.println(pageAttributes);\n+\n+            \/\/ For xor mode set, there is a printing issue with number of copies to be print.\n+            \/\/ So, ITERATIONS are changed to 1 from 3.\n+            \/\/ So, for now the XOR related code is commented out.\n+\n+            \/\/boolean xor = false;\n+\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                Graphics g = pj.getGraphics();\n+                g.setColor(Color.red);\n+                \/\/if (xor) {\n+                \/\/    g.setXORMode(Color.blue);\n+                \/\/}\n+                printAll(g);\n+                g.dispose();\n+                \/\/xor = (xor) ? false : true;\n+            }\n+\n+            \/\/ For xor mode set, LWC components don't get printed.\n+            \/\/ So, for now the code is commented out and separate bug\n+            \/\/ (JDK-8340495) is filed to handle it.\n+\n+            \/\/ one more page so that we can test printing a lightweight\n+            \/\/ at the top of the hierarchy (BugId 4212564)\n+            \/\/Graphics g = pj.getGraphics();\n+            \/\/g.setColor(Color.red);\n+            \/\/lwc.printAll(g);\n+            \/\/g.dispose();\n+            \/\/ end 4212564\n+\n+            pj.end();\n+        }\n+    }\n+\n+    class ActionPrintToScreen implements ActionListener {\n+        public void actionPerformed(ActionEvent ev) {\n+            PrintFrame printFrame = new PrintFrame(MainFrame.this);\n+            printFrame.show();\n+            Graphics g = printFrame.getGraphics();\n+            g.setColor(Color.red);\n+            printAll(g);\n+            g.dispose();\n+        }\n+    }\n+\n+    \/\/ Frame window that displays results of printing\n+    \/\/ main window to a screen Graphics-- useful for\n+    \/\/ quick testing of printing\n+    class PrintFrame extends Frame\n+    {\n+        private Component printComponent;\n+        public PrintFrame( Component c )\n+        {\n+            super(\"Print to Screen\");\n+            printComponent = c ;\n+            addWindowListener( new WindowAdapter() {\n+                                   public void windowClosing(WindowEvent ev) {\n+                                       setVisible(false);\n+                                       dispose();\n+                                   }\n+                               }\n+            );\n+            setSize(printComponent.getSize());\n+            setResizable(false);\n+        }\n+\n+        public void paint( Graphics g ) {\n+            printComponent.printAll(g);\n+        }\n+    }\n+\n+    class LWButton extends Component {\n+        String label;\n+        int width = 100;\n+        int height = 30;\n+\n+        public LWButton(String label) {\n+            super();\n+            this.label = label;\n+        }\n+\n+        public void paint(Graphics g) {\n+            Dimension d = getSize();\n+            g.setColor(Color.orange);\n+            g.setFont(getFont());\n+            g.fillRect(0, 0, d.width, d.height);\n+            g.setColor(Color.black);\n+            int x = 5;\n+            int y = (d.height - 5);\n+            g.drawString(label, x, y);\n+        }\n+\n+        public Dimension getPreferredSize()\n+        {\n+            return new Dimension(width, height);\n+        }\n+    }\n+\n+    class LWContainer extends Container {\n+        String label;\n+        int width = 300;\n+        int height = 100;\n+\n+        public LWContainer(String label) {\n+            super();\n+            this.label = label;\n+            setLayout(new FlowLayout());\n+        }\n+\n+        public void paint(Graphics g) {\n+            super.paint(g);\n+            Dimension d = getSize();\n+            g.setColor(Color.green);\n+            g.setFont(getFont());\n+            g.drawLine(0, 0, d.width - 1, 0);\n+            g.drawLine(d.width - 1, 0, d.width - 1, d.height - 1);\n+            g.drawLine(d.width - 1, d.height - 1, 0, d.height - 1);\n+            g.drawLine(0, d.height - 1, 0, 0);\n+            g.setColor(Color.black);\n+            int x = 5;\n+            int y = (d.height - 5);\n+            g.drawString(label, x, y);\n+        }\n+\n+        public Dimension getPreferredSize()\n+        {\n+            return new Dimension(width, height);\n+        }\n+    }\n+\n+    class TestCanvas extends Canvas {\n+        int width = 100;\n+        int height = 100;\n+\n+        public void paint(Graphics g) {\n+            g.setColor(Color.blue);\n+            g.fillRoundRect(10, 10, 50, 50, 15, 30);\n+            g.setColor(Color.red);\n+            g.fillOval(70, 70, 25, 25);\n+        }\n+        public Dimension getPreferredSize() {\n+            return new Dimension(width, height);\n+        }\n+    }\n+\n+    class ZOrderPanel extends Panel\n+    {\n+        ZOrderPanel()\n+        {\n+            setLayout(null);\n+\n+            Component first, second, third, fourth;\n+\n+            setVisible(true);\n+            \/\/ add first component\n+            first = makeBox(\"Second\", Color.blue,\n+                    new Font(\"Serif\", Font.BOLD, 14),\n+                    -1);\n+            \/\/ insert on top\n+            second = makeBox(\"First\", Color.yellow,\n+                    new Font(\"SansSerif\", Font.BOLD, 14),\n+                    0);\n+            \/\/ put at the back\n+            fourth = makeBox(\"Fourth\", Color.red,\n+                    new Font(\"Monospaced\", Font.BOLD, 14),\n+                    2);\n+            \/\/ insert in last position\n+            third = makeBox(\"Third\", Color.green,\n+                    new Font(\"Dialog\", Font.PLAIN, 12),\n+                    3);\n+            \/\/ swap third and fourth to correct positions\n+            remove(third);\n+            add(third, 2);\n+            \/\/ re-validate so third and fourth peers change position\n+            validate();\n+            \/\/ now make things really interesting with a lightweight\n+            \/\/ component at the top of the z-order, that should print\n+            \/\/ _below_ the native guys to match the screen...\n+            add(new LWButton(\"LWButton\"), 0);\n+        }\n+\n+        public Dimension preferredSize()\n+        {\n+            return new Dimension(260, 80);\n+        }\n+\n+        public void layout()\n+        {\n+            int i, n;\n+            Insets ins = getInsets();\n+            n = getComponentCount();\n+            for (i = n-1; i >= 0; i--) {\n+                Component p = getComponent(i);\n+                p.setBounds(ins.left + 40 * i, ins.top + 5 * i, 60, 60);\n+            }\n+        }\n+\n+        public Component makeBox(String s, Color c, Font f, int index)\n+        {\n+            Label l = new Label(s);\n+            l.setBackground(c);\n+            l.setAlignment(Label.RIGHT);\n+            l.setFont(f);\n+            add(l, index);\n+            validate();\n+            return l;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PrintJob\/PrintComponentTest.java","additions":486,"deletions":0,"binary":false,"changes":486,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.PrintJob;\n+import java.awt.Toolkit;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 4257962\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary tests that scaled images are printed at resolution greater than 72dpi\n+ * @run main\/manual ScaledImagePrintingTest\n+ *\/\n+\n+public class ScaledImagePrintingTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Press 'Print' button from the test UI.\n+\n+                The test will bring up a print dialog. Select a printer and proceed.\n+                Verify that the output is a series of a horizontal lines in a\n+                rectangular box in the center of the page.\n+\n+                If output is as mentioned above, press Pass else Fail.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"ScaledImagePrintingTest Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testTimeOut(5)\n+                .testUI(ScaledImagePrintingTest::createUI)\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame frame = new Frame(\"ResolutionTest\");\n+        Button b = new Button(\"Print\");\n+        b.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                PrintJob pj = frame.getToolkit().getPrintJob(frame, \"ResolutionTest\", null);\n+                PassFailJFrame.log(\"Printing code started.\");\n+                if (pj != null) {\n+                    Graphics g = pj.getGraphics();\n+                    g.setColor(Color.black);\n+                    int w = 200;\n+                    int h = 200;\n+                    Image image = frame.createImage(w, h);\n+                    Graphics imageGraphics = image.getGraphics();\n+                    Dimension d = pj.getPageDimension();\n+                    imageGraphics.setColor(Color.black);\n+                    for (int i = 0; i < h; i += 20) {\n+                        imageGraphics.drawLine(0, i, w, i);\n+                    }\n+                    g.translate(d.width \/ 2, d.height \/ 2);\n+                    g.drawImage(image, -w \/ 8, -h \/ 8, w \/ 4, h \/ 4, frame);\n+                    g.setColor(Color.black);\n+                    g.drawRect(-w \/ 4, -h \/ 4, w \/ 2, h \/ 2);\n+                    imageGraphics.dispose();\n+                    g.dispose();\n+                    pj.end();\n+                }\n+                PassFailJFrame.log(\"Printing code finished.\");\n+            }\n+        });\n+        frame.add(b);\n+        frame.setSize(50, 50);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PrintJob\/ScaledImagePrintingTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4189244\n+ * @summary Swing Popup menu is not being refreshed (cleared) under a Dialog\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"windows\")\n+ * @run main\/manual bug4189244\n+*\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JMenuItem;\n+import javax.swing.JOptionPane;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+\n+public class bug4189244 {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+         This is Windows only test!\n+\n+         Click right button on frame to show popup menu.\n+         (menu should be placed inside frame otherwise bug is not reproducible)\n+         click on any menu item (dialog will be shown).\n+         close dialog.\n+         if you see part of popupmenu, under dialog, before it is closed,\n+         then test failed, else passed.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+         PassFailJFrame.builder()\n+                .title(\"bug4189244 Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int)INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(bug4189244::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+\n+    private static JFrame createTestUI() {\n+        RefreshBug panel = new RefreshBug();\n+        JFrame frame = new JFrame(\"Popup refresh bug\");\n+\n+        frame.add(panel, BorderLayout.CENTER);\n+        panel.init();\n+        frame.setSize(400, 400);\n+        return frame;\n+    }\n+}\n+\n+class RefreshBug extends JPanel implements ActionListener {\n+    JPopupMenu _jPopupMenu = new JPopupMenu();\n+\n+    public void init() {\n+        JMenuItem menuItem;\n+        JButton jb = new JButton(\"Bring the popup here and select an item\");\n+\n+        this.add(jb, BorderLayout.CENTER);\n+\n+        for(int i = 1; i < 10; i++) {\n+            menuItem = new JMenuItem(\"Item \" + i);\n+            menuItem.addActionListener(this);\n+            _jPopupMenu.add(menuItem);\n+        }\n+\n+        MouseListener ml = new MouseAdapter() {\n+            public void mouseReleased(MouseEvent e) {\n+                if (e.isPopupTrigger()) {\n+                        _jPopupMenu.show(e.getComponent(),\n+                                         e.getX(), e.getY());\n+                }\n+            }\n+        };\n+        this.addMouseListener(ml);\n+\n+        jb.addMouseListener(ml);\n+\n+    }\n+\n+    \/\/ An action is requested by the user\n+    public void actionPerformed(java.awt.event.ActionEvent e) {\n+        JOptionPane.showMessageDialog(this,\n+                                      \"Check if there is some popup left under me\\n\"+\n+                                      \"if not, retry and let the popup appear where i am\",\n+                                      \"WARNING\",\n+                                      JOptionPane.WARNING_MESSAGE);\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Window\/bug4189244.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/XAWTDifference\/XAWTColors.jpg","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Component;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.Label;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.Panel;\n+import java.awt.PopupMenu;\n+import java.awt.ScrollPane;\n+import java.awt.Scrollbar;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.Window;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.swing.ImageIcon;\n+import javax.swing.JLabel;\n+\n+\/*\n+ * @test\n+ * @bug 5092883 6513478 7154025\n+ * @requires (os.family == \"linux\")\n+ * @summary REGRESSION: SystemColor class gives back wrong values under Linux\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual XAWTDifference\n+ *\/\n+\n+public class XAWTDifference {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+                You would see a frame with title \"XAWTDifference Test Frame\".\n+\n+                Test Frame (1)\n+\n+                a) It has three columns in it. The 1st one with ordinary components.\n+                   The 2nd one with disabled components.\n+                   The 3rd one with uneditable components (only text components\n+                   are there). Verify that the difference between different states\n+                   is visible.\n+\n+                Standard Frame (2)\n+\n+                b) You would also see a frame named StandardFrame (2)\n+                   with a lot of components in it. Actually this is just a jpg-image\n+                   in a frame. Verify that every component in the frame (1) looks\n+                   similar to the same component in (2).\n+\n+                   They might differ in colors and be darker or brighter but\n+                   the whole picture should be the same.\n+\n+                c) Also check the color of the MenuBar Items in the MenuBar and\n+                   the PopupMenu assigned to TextArea.\n+                   As you can't compare the colors of menu items with the picture\n+                   so just look if the are adequate enough.\n+                \"\"\";\n+    private static final int HGAP = 20;\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                      .title(\"Test Instructions\")\n+                      .instructions(INSTRUCTIONS)\n+                      .columns(40)\n+                      .testUI(XAWTDifference::createAndShowUI)\n+                      .positionTestUI(XAWTDifference::positionMultiTestUI)\n+                      .build()\n+                      .awaitAndCheck();\n+    }\n+\n+    private static Panel addComponentsIntoPanel(boolean enabled, boolean editable) {\n+        TextField tf = new TextField(\"TextField\");\n+        TextArea ta = new TextArea(\"TextArea\", 10, 10);\n+\n+        Choice levelChooser = new Choice();\n+        levelChooser.add(\"Item #1\");\n+        levelChooser.add(\"Item #2\");\n+\n+        Button b = new Button(\"BUTTON\");\n+        Label label = new Label(\"LABEL\");\n+        java.awt.List list = new java.awt.List(4, false);\n+        list.add(\"one\");\n+        list.add(\"two\");\n+        list.add(\"three\");\n+\n+        Checkbox chb = new Checkbox();\n+        Scrollbar sb = new Scrollbar(Scrollbar.HORIZONTAL);\n+        ScrollPane sp = new ScrollPane(ScrollPane.SCROLLBARS_ALWAYS);\n+        sp.add(new TextArea(\"this is a textarea in scrollpane\"));\n+        sp.setSize(200, 200);\n+        Canvas canvas = new Canvas();\n+        canvas.setSize(100, 100);\n+\n+        \/\/add popup menu to Button\n+        final PopupMenu pm = new PopupMenu();\n+        MenuItem i1 = new MenuItem(\"Item1\");\n+        MenuItem i2 = new MenuItem(\"Item2\");\n+        MenuItem i3 = new MenuItem(\"Item3\");\n+        i3.setEnabled(false);\n+        pm.add(i1);\n+        pm.add(i2);\n+        pm.add(i3);\n+        canvas.add(pm);\n+\n+        ta.add(pm);\n+        ta.addMouseListener(new MouseAdapter() {\n+                public void mousePressed(MouseEvent me) {\n+                    if (me.isPopupTrigger()) {\n+                        pm.show(me.getComponent(), me.getX(), me.getY());\n+                    }\n+                }\n+            });\n+\n+        ArrayList<Component> componentList = new ArrayList<>();\n+\n+        componentList.add(tf);\n+        componentList.add(ta);\n+        if (editable){\n+            componentList.add(levelChooser);\n+            componentList.add(b);\n+            componentList.add(label);\n+            componentList.add(list);\n+            componentList.add(chb);\n+            componentList.add(sb);\n+            componentList.add(sp);\n+            componentList.add(canvas);\n+        } else {\n+            tf.setEditable(false);\n+            ta.setEditable(false);\n+        }\n+\n+        Panel panel = new Panel();\n+        panel.setLayout(new GridLayout(0, 1));\n+        for (Component c : componentList) {\n+            if (!enabled) {\n+                c.setEnabled(false);\n+            }\n+            panel.add(c);\n+        }\n+        return panel;\n+    }\n+\n+    private static List<Window> createAndShowUI() {\n+        Frame testFrame = new Frame(\"XAWTDifference Test Frame\");\n+        StandardFrame standardFrame = new StandardFrame(\"StandardFrame\");\n+        standardFrame.pack();\n+\n+        testFrame.setLayout(new GridLayout(1, 3));\n+        testFrame.add(addComponentsIntoPanel(true, true));\n+        testFrame.add(addComponentsIntoPanel(false, true));\n+        testFrame.add(addComponentsIntoPanel(true, false));\n+\n+        MenuItem mi1 = new MenuItem(\"Item1\");\n+        MenuItem mi2 = new MenuItem(\"Item2\");\n+        MenuItem mi3 = new MenuItem(\"Disabled Item3\");\n+        mi3.setEnabled(false);\n+\n+        MenuBar mb = new MenuBar();\n+        Menu enabledMenu = new Menu(\"Enabled Menu\");\n+        Menu disabledMenu = new Menu(\"Disabled Menu\");\n+        disabledMenu.setEnabled(false);\n+        mb.add(enabledMenu);\n+        mb.add(disabledMenu);\n+        enabledMenu.add(mi1);\n+        enabledMenu.add(mi2);\n+        enabledMenu.add(mi3);\n+\n+        testFrame.setMenuBar(mb);\n+        testFrame.setSize(standardFrame.getWidth(), standardFrame.getHeight());\n+        return List.of(testFrame, standardFrame);\n+    }\n+\n+    private static void positionMultiTestUI(List<? extends Window> windows,\n+                                            PassFailJFrame.InstructionUI instructionUI) {\n+        int x = instructionUI.getLocation().x + instructionUI.getSize().width + HGAP;\n+        for (Window w : windows) {\n+            w.setLocation(x, instructionUI.getLocation().y);\n+            x += w.getWidth() + HGAP;\n+        }\n+    }\n+\n+    private static class StandardFrame extends Frame {\n+        public StandardFrame(String name) {\n+            super(name);\n+            String testPath = System.getProperty(\"test.src\", \".\");\n+            Panel panel = new Panel();\n+            panel.add(new JLabel(new ImageIcon(testPath + File.separator + \"XAWTColors.jpg\")));\n+            add(panel);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/XAWTDifference\/XAWTDifference.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4178123\n+ * @summary Verifies that the Arc2D.contains(point) methods work correctly.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual Arc2DHitTest\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.Arc2D;\n+\n+public class Arc2DHitTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+            This test displays an arc figure and lets the user click on it.\n+            The arc will initially be drawn in red and only when the user clicks\n+            within the arc in the window it will be redrawn into green otherwise\n+            it should stay red.\n+\n+            For convenience, the point being tested is drawn in black.  Note\n+            that rounding in the arc rendering routines may cause points near\n+            the boundary of the arc to render incorrectly.  Allow for a pixel\n+            or two of leeway near the boundary.\n+            \"\"\";\n+\n+        PassFailJFrame.builder()\n+            .title(\"Test Instructions\")\n+            .instructions(INSTRUCTIONS)\n+            .columns(40)\n+            .testUI(initialize())\n+            .build()\n+            .awaitAndCheck();\n+    }\n+    private static Frame initialize() {\n+        Frame f = new Frame(\"Arc2DHitTest\");\n+        ArcHitPanel panel = new ArcHitPanel();\n+        f.add(panel);\n+        f.setSize(300, 250);\n+        return f;\n+    }\n+}\n+\n+class ArcHitPanel extends Panel {\n+    private Arc2D arc;\n+    private Point hit;\n+    public ArcHitPanel() {\n+        arc = new Arc2D.Float(10, 10, 100, 100, 0, 120, Arc2D.PIE);\n+        this.addMouseListener(new MouseAdapter() {\n+            public void mouseClicked(MouseEvent e) {\n+                hit = e.getPoint();\n+                repaint();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void paint(Graphics g) {\n+        Graphics2D g2 = (Graphics2D) g;\n+        g2.setColor(Color.white);\n+        g2.fill(g2.getClipBounds());\n+        g2.setColor((hit != null && arc.contains(hit))\n+            ? Color.green : Color.red);\n+        g2.fill(arc);\n+        if (hit != null) {\n+            g2.setColor(Color.black);\n+            g2.fillRect(hit.x, hit.y, 1, 1);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/geom\/Arc2D\/Arc2DHitTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4197746\n+ * @summary Verifies that the getBounds2D method of Arc2D returns the\n+ *          correct result.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual BoundsBug\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.RenderingHints;\n+import java.awt.Shape;\n+import java.awt.geom.Arc2D;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.GeneralPath;\n+import java.awt.geom.Point2D;\n+import java.awt.geom.Rectangle2D;\n+\n+public class BoundsBug {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+            This test displays three figures and draws the outline of their\n+            bounding boxes. The bounding boxes should correctly encompass\n+            the 3 figures.\n+\n+            This test also paints two highlight rectangles at the ends of the\n+            angular extents of the arc. The two highlights should correctly\n+            appear at the outer circumference of the arc where the radii lines\n+            from its center intersect that circumference.\n+            \"\"\";\n+\n+        PassFailJFrame.builder()\n+            .title(\"Test Instructions\")\n+            .instructions(INSTRUCTIONS)\n+            .columns(40)\n+            .testUI(initialize())\n+            .build()\n+            .awaitAndCheck();\n+    }\n+    private static Frame initialize() {\n+        Frame f = new Frame(\"BoundsBug\");\n+        ArcPanel panel = new ArcPanel();\n+        f.add(panel);\n+        f.setSize(300, 250);\n+        return f;\n+    }\n+}\n+\n+class ArcPanel extends Panel {\n+    protected void drawPoint(Graphics2D g2, Point2D p) {\n+        g2.setColor(Color.green);\n+        g2.fill(new Rectangle2D.Double(p.getX() - 5, p.getY() - 5, 10, 10));\n+    }\n+\n+    protected void drawShapeAndBounds(Graphics2D g2, Shape s) {\n+        g2.setColor(Color.orange);\n+        g2.fill(s);\n+        g2.setColor(Color.black);\n+        g2.draw(s);\n+\n+        Rectangle2D r = s.getBounds2D();\n+        g2.setColor(Color.gray);\n+        g2.draw(r);\n+    }\n+\n+    @Override\n+    public void paint(Graphics g) {\n+        Graphics2D g2 = (Graphics2D)g;\n+        g2.setColor(Color.white);\n+        g2.fill(g.getClipBounds());\n+        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+            RenderingHints.VALUE_ANTIALIAS_ON);\n+\n+        \/\/ Create some interesting shapes.\n+        Ellipse2D ellipse = new Ellipse2D.Float(20, 40, 60, 80);\n+        Arc2D arc = new Arc2D.Float(60, 40, 100, 120,\n+            -30, -40, Arc2D.PIE);\n+        GeneralPath path = new GeneralPath(GeneralPath.WIND_EVEN_ODD);\n+        path.moveTo(0, 0);\n+        path.lineTo(75, -25);\n+        path.lineTo(25, 75);\n+        path.lineTo(0, 25);\n+        path.lineTo(100, 50);\n+        path.lineTo(50, 0);\n+        path.lineTo(25, 50);\n+        path.closePath();\n+        \/\/ Now draw them and their bounds rectangles.\n+        drawShapeAndBounds(g2, ellipse);\n+        drawShapeAndBounds(g2, arc);\n+        drawPoint(g2, arc.getStartPoint());\n+        drawPoint(g2, arc.getEndPoint());\n+        g2.translate(180, 65);\n+        drawShapeAndBounds(g2, path);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/geom\/Arc2D\/BoundsBug.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4183373\n+ * @summary Verifies that the translated Area objects display correctly\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual Translate\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.CardLayout;\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Panel;\n+import java.awt.Rectangle;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Area;\n+import java.awt.geom.Rectangle2D;\n+\n+public class Translate {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+            This test displays two sets of rectangular figures. The two sets\n+            should be displayed one on top of the other and should be lined\n+            up vertically with each other. If the two sets of figures are\n+            not directly above and below each other then the test fails\n+            \"\"\";\n+\n+        PassFailJFrame.builder()\n+            .title(\"Test Instructions\")\n+            .instructions(INSTRUCTIONS)\n+            .columns(35)\n+            .testUI(initialize())\n+            .build()\n+            .awaitAndCheck();\n+    }\n+    private static Frame initialize() {\n+        Frame f = new Frame(\"Translate\");\n+        TranslatePanel panel = new TranslatePanel();\n+        f.add(panel);\n+        f.setSize(300, 250);\n+        return f;\n+    }\n+}\n+\n+class TranslatePanel extends Panel {\n+    private static Image bufferedImage;\n+    private static Area a1, a2, a3;\n+\n+    public TranslatePanel() {\n+        a1 = new Area(new Rectangle2D.Double(20.0, 20.0, 60.0, 60.0));\n+\n+        a2 = new Area((Area) a1.clone());\n+        a2.subtract(new Area(new Rectangle2D.Double(30.0, 30.0, 40.0, 40.0)));\n+\n+        a3 = new Area((Area) a2.clone());\n+        a3.add(new Area(new Rectangle2D.Double(40.0, 40.0, 20.0, 20.0)));\n+\n+        AffineTransform at2 = new AffineTransform();\n+        at2.translate(100.0, 0.0);\n+        a2.transform(at2);\n+\n+        AffineTransform at3 = new AffineTransform();\n+        at3.translate(200.0, 0.0);\n+        a3.transform(at3);\n+    }\n+    private void paintRects(Graphics2D g2) {\n+        Rectangle clip = g2.getClipBounds();\n+        g2.setColor(Color.white);\n+        g2.fillRect(clip.x, clip.y, clip.width, clip.height);\n+        g2.setPaint(Color.red);\n+        g2.fill(a1);\n+        g2.setPaint(Color.yellow);\n+        g2.fill(a2);\n+        g2.setPaint(Color.blue);\n+        g2.fill(a3);\n+    }\n+\n+    @Override\n+    public void paint(Graphics g) {\n+        if (bufferedImage == null) {\n+            bufferedImage = createImage(300, 100);\n+            Graphics big = bufferedImage.getGraphics();\n+            \/\/ Notice that if you remove the translate() call, it works fine.\n+            big.translate(-1, -1);\n+            big.setClip(1, 1, 300, 100);\n+            paintRects((Graphics2D)big);\n+            big.translate(1, 1);\n+        }\n+        paintRects((Graphics2D)g);\n+        g.drawImage(bufferedImage, 1, 100, this);\n+        g.setColor(Color.black);\n+        g.drawString(\"From offscreen image (with translate):\", 10, 95);\n+        g.drawString(\" (should line up with rectangles above)\", 10, 110);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/geom\/Area\/Translate.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -82,2 +82,57 @@\n- * Provides a framework for manual tests to display test instructions and\n- * Pass\/Fail buttons.\n+ * A framework for manual tests to display test instructions and\n+ * <i>Pass<\/i> \/ <i>Fail<\/i> buttons. The framework automatically\n+ * creates a frame to display the instructions, provides buttons\n+ * to select the test result, and handles test timeout.\n+ *\n+ * <p id=\"timeOutTimer\">\n+ * The instruction UI frame displays a timer at the top which indicates\n+ * how much time is left. The timer can be paused using the <i>Pause<\/i>\n+ * button to the right of the time; the title of the button changes to\n+ * <i>Resume<\/i>. To resume the timer, use the <i>Resume<\/i> button.\n+ *\n+ * <p id=\"instructionText\">\n+ * In the center, the instruction UI frame displays instructions for the\n+ * tester. The instructions can be either plain text or HTML. If the\n+ * text of the instructions starts with {@code \"<html>\"}, the\n+ * instructions are displayed as HTML, as supported by Swing, which\n+ * provides richer formatting options.\n+ * <p>\n+ * The instructions are displayed in a text component with word-wrapping\n+ * so that there's no horizontal scroll bar. If the text doesn't fit, a\n+ * vertical scroll bar is shown. Use {@code rows} and {@code columns}\n+ * parameters to change the size of this text component.\n+ * If possible, choose the number of rows and columns so that\n+ * the instructions fit and no scroll bars are shown.\n+ *\n+ * <p id=\"passFailButtons\">\n+ * At the bottom, the instruction UI frame displays the\n+ * <i>Pass<\/i> and <i>Fail<\/i> buttons. The tester clicks either <i>Pass<\/i>\n+ * or <i>Fail<\/i> button to finish the test. When the tester clicks the\n+ * <i>Fail<\/i> button, the framework displays a dialog box prompting for\n+ * a reason why the test fails. The tester enters the reason and clicks\n+ * <i>OK<\/i> to close the dialog and fail the test,\n+ * or simply closes the dialog to fail the test without providing any reason.\n+ *\n+ * <p id=\"screenCapture\">\n+ * If you enable the screenshot feature, a <i>Screenshot<\/i> button is\n+ * added  to the right of the <i>Fail<\/i> button. The tester can choose either\n+ * <i>Capture Full Screen<\/i> (default) or <i>Capture Frames<\/i> and click the\n+ * <i>Screenshot<\/i> button to take a screenshot.\n+ * If there are multiple screens, screenshots of each screen are created.\n+ * If the tester selects the <i>Capture Frames<\/i> mode, screenshots of all\n+ * the windows or frames registered in the {@code PassFailJFrame} framework\n+ * are created.\n+ *\n+ * <p id=\"logArea\">\n+ * If you enable a log area, the instruction UI frame adds a text component\n+ * to display log messages below the buttons.\n+ * Use {@link #log(String) log}, {@link #logSet(String) logSet}\n+ * and {@link #logClear() logClear} static methods of {@code PassFailJFrame}\n+ * to add or clear messages from the log area.\n+ *\n+ * <p id=\"awaitTestResult\">\n+ * After you create an instance of {@code PassFailJFrame}, call the\n+ * {@link #awaitAndCheck() awaitAndCheck} method to stop the current thread\n+ * (usually the main thread) and wait until the tester clicks\n+ * either <i>Pass<\/i> or <i>Fail<\/i> button,\n+ * or until the test times out.\n@@ -85,3 +140,6 @@\n- * Instructions for the user can be either plain text or HTML as supported\n- * by Swing. If the instructions start with {@code <html>}, the\n- * instructions are displayed as HTML.\n+ * The call to the {@code awaitAndCheck} method is usually the last\n+ * statement in the {@code main} method of your test.\n+ * If the test fails, an exception is thrown to signal the failure to jtreg.\n+ * The test fails if the tester clicks the <i>Fail<\/i> button,\n+ * if the timeout occurs,\n+ * or if any window or frame is closed.\n@@ -89,0 +147,4 @@\n+ * Before returning from {@code awaitAndCheck}, the framework disposes of\n+ * all the windows and frames.\n+ *\n+ * <h2 id=\"sampleManualTest\">Sample Manual Test<\/h2>\n@@ -90,1 +152,1 @@\n- * <pre>{@code\n+ * {@snippet id='sampleManualTestCode' lang='java':\n@@ -98,1 +160,1 @@\n- *                       .testUI(() -> createTestUI())\n+ *                       .testUI(SampleManualTest::createTestUI)\n@@ -109,1 +171,1 @@\n- * }<\/pre>\n+ * }\n@@ -111,2 +173,4 @@\n- * The above example uses the {@link Builder Builder} to set the parameters of\n- * the instruction frame. It is the recommended way.\n+ * The above example uses the {@link Builder Builder} class to set\n+ * the parameters of the instruction frame.\n+ * It is <em>the recommended way<\/em>.\n+ *\n@@ -114,3 +178,15 @@\n- * The framework will create instruction UI, it will call\n- * the provided {@code createTestUI} on the Event Dispatch Thread (EDT),\n- * and it will automatically position the test UI and make it visible.\n+ * The framework will create an instruction UI frame, it will call\n+ * the provided {@code createTestUI} on the Event Dispatch Thread (<dfn>EDT<\/dfn>),\n+ * and it will automatically position the test UI frame and make it visible.\n+ *\n+ * <p id=\"jtregTagsForTest\">\n+ * Add the following jtreg tags before the test class declaration\n+ * {@snippet :\n+ * \/*\n+ *  * @test\n+ *  * @summary Sample manual test\n+ *  * @library \/java\/awt\/regtesthelpers\n+ *  * @build PassFailJFrame\n+ *  * @run main\/manual SampleManualTest\n+ * }\n+ * and the closing comment tag <code>*&#47;<\/code>.\n@@ -118,0 +194,28 @@\n+ * The {@code @library} tag points to the location of the\n+ * {@code PassFailJFrame} class in the source code;\n+ * the {@code @build} tag makes jtreg compile the {@code PassFailJFrame} class,\n+ * and finally the {@code @run} tag specifies it is a manual\n+ * test and the class to run.\n+ *\n+ * <h2 id=\"usingBuilder\">Using {@code Builder}<\/h2>\n+ * Use methods of the {@link Builder Builder} class to set or change\n+ * parameters of {@code PassFailJFrame} and its instruction UI:\n+ * <ul>\n+ *     <li>{@link Builder#title(String) title} sets\n+ *         the title of the instruction UI\n+ *         (the default is {@value #TITLE});<\/li>\n+ *     <li>{@link Builder#testTimeOut(long) testTimeOut} sets\n+ *         the timeout of the test\n+ *         (the default is {@value #TEST_TIMEOUT});<\/li>\n+ *     <li>{@link Builder#rows(int) rows} and\n+ *         {@link Builder#columns(int) columns} control the size\n+ *         the text component which displays the instructions\n+ *         (the default number of rows is the number of lines in the text\n+ *         of the instructions,\n+ *         the default number of columns is {@value #COLUMNS});<\/li>\n+ *     <li>{@link Builder#logArea() logArea} adds a log area;<\/li>\n+ *     <li>{@link Builder#screenCapture() screenCapture}\n+ *         enables screenshots.<\/li>\n+ * <\/ul>\n+ *\n+ * <h3 id=\"builderTestUI\">Using {@code testUI} and {@code splitUI}<\/h3>\n@@ -122,4 +226,7 @@\n- * For simple test UI, use {@code Builder.splitUI}, or explicitly\n- * {@code Builder.splitUIRight} or {@code Builder.splitUIBottom} with\n- * a {@code PanelCreator}. The framework will call the provided\n- * {@code createUIPanel} to create the component with test UI and\n+ * For simple test UI, use {@link Builder#splitUI(PanelCreator) splitUI},\n+ * or explicitly\n+ * {@link Builder#splitUIRight(PanelCreator) splitUIRight} or\n+ * {@link Builder#splitUIBottom(PanelCreator) splitUIBottom} with\n+ * a {@link PanelCreator PanelCreator}.\n+ * The framework will call the provided\n+ * {@code createUIPanel} method to create the component with test UI and\n@@ -129,0 +236,3 @@\n+ * Note: <em>support for multiple windows is incomplete<\/em>.\n+ *\n+ * <h2 id=\"obsoleteSampleTest\">Obsolete Sample Test<\/h2>\n@@ -133,2 +243,2 @@\n- * <pre>{@code\n- * public class SampleOldManualTest {\n+ * {@snippet id='obsoleteSampleTestCode' lang='java':\n+ * public class ObsoleteManualTest {\n@@ -141,1 +251,1 @@\n- *         SwingUtilities.invokeAndWait(() -> createTestUI());\n+ *         SwingUtilities.invokeAndWait(ObsoleteManualTest::createTestUI);\n@@ -154,1 +264,1 @@\n- * }<\/pre>\n+ * }\n@@ -156,9 +266,21 @@\n- * Use methods of the {@code Builder} class or constructors of the\n- * {@code PassFailJFrame} class to control other parameters:\n- * <ul>\n- *     <li>the title of the instruction UI,<\/li>\n- *     <li>the timeout of the test,<\/li>\n- *     <li>the size of the instruction UI via rows and columns, and<\/li>\n- *     <li>to add a log area,<\/li>\n- *     <li>to enable screenshots.<\/li>\n- * <\/ul>\n+ * This sample uses {@link #PassFailJFrame(String) a constructor} of\n+ * {@code PassFailJFrame} to create its instance,\n+ * there are several overloads provided which allow changing other parameters.\n+ * <p>\n+ * When you use the constructors, you have to explicitly create\n+ * your test UI window on EDT. After you create the window,\n+ * you need to register it with the framework using\n+ * {@link #addTestWindow(Window) addTestWindow}\n+ * to ensure the window is disposed of when the test completes.\n+ * Before showing the window, you have to call\n+ * {@link #positionTestWindow(Window, Position) positionTestWindow}\n+ * to position the test window near the instruction UI frame provided\n+ * by the framework. And finally you have to explicitly show the test UI\n+ * window by calling {@code setVisible(true)}.\n+ * <p>\n+ * To avoid the complexity, use the {@link Builder Builder} class\n+ * which provides a streamlined way to configure and create an\n+ * instance of {@code PassFailJFrame}.\n+ * <p>\n+ * Consider updating tests which use {@code PassFailJFrame} constructors to\n+ * use the builder pattern.\n@@ -173,0 +295,5 @@\n+    \/**\n+     * A gap between windows.\n+     *\/\n+    public static final int WINDOW_GAP = 8;\n+\n@@ -216,2 +343,20 @@\n-    public PassFailJFrame(String instructions) throws InterruptedException,\n-            InvocationTargetException {\n+    \/**\n+     * Constructs a frame which displays test instructions and\n+     * the <i>Pass<\/i> \/ <i>Fail<\/i> buttons with the given instructions, and\n+     * the default timeout of {@value #TEST_TIMEOUT} minutes,\n+     * the default title of {@value #TITLE} and\n+     * the default values of {@value #ROWS} and {@value #COLUMNS}\n+     * for rows and columns.\n+     * <p>\n+     * See {@link #PassFailJFrame(String,String,long,int,int,boolean)} for\n+     * more details.\n+     *\n+     * @param instructions the instructions for the tester\n+     *\n+     * @throws InterruptedException if the current thread is interrupted\n+     *              while waiting for EDT to finish creating UI components\n+     * @throws InvocationTargetException if an exception is thrown while\n+     *              creating UI components on EDT\n+     *\/\n+    public PassFailJFrame(String instructions)\n+            throws InterruptedException, InvocationTargetException {\n@@ -221,2 +366,21 @@\n-    public PassFailJFrame(String instructions, long testTimeOut) throws\n-            InterruptedException, InvocationTargetException {\n+    \/**\n+     * Constructs a frame which displays test instructions and\n+     * the <i>Pass<\/i> \/ <i>Fail<\/i> buttons\n+     * with the given instructions and timeout as well as\n+     * the default title of {@value #TITLE}\n+     * and the default values of {@value #ROWS} and {@value #COLUMNS}\n+     * for rows and columns.\n+     * <p>\n+     * See {@link #PassFailJFrame(String,String,long,int,int,boolean)} for\n+     * more details.\n+     *\n+     * @param instructions the instructions for the tester\n+     * @param testTimeOut  the test timeout in minutes\n+     *\n+     * @throws InterruptedException if the current thread is interrupted\n+     *              while waiting for EDT to finish creating UI components\n+     * @throws InvocationTargetException if an exception is thrown while\n+     *              creating UI components on EDT\n+     *\/\n+    public PassFailJFrame(String instructions, long testTimeOut)\n+            throws InterruptedException, InvocationTargetException {\n@@ -226,0 +390,20 @@\n+    \/**\n+     * Constructs a frame which displays test instructions and\n+     * the <i>Pass<\/i> \/ <i>Fail<\/i> buttons\n+     * with the given title, instructions and timeout as well as\n+     * the default values of {@value #ROWS} and {@value #COLUMNS}\n+     * for rows and columns.\n+     * The screenshot feature is not enabled, if you use this constructor.\n+     * <p>\n+     * See {@link #PassFailJFrame(String,String,long,int,int,boolean)} for\n+     * more details.\n+     *\n+     * @param title        the title of the instruction frame\n+     * @param instructions the instructions for the tester\n+     * @param testTimeOut  the test timeout in minutes\n+     *\n+     * @throws InterruptedException if the current thread is interrupted\n+     *              while waiting for EDT to finish creating UI components\n+     * @throws InvocationTargetException if an exception is thrown while\n+     *              creating UI components on EDT\n+     *\/\n@@ -227,2 +411,2 @@\n-                          long testTimeOut) throws InterruptedException,\n-            InvocationTargetException {\n+                          long testTimeOut)\n+            throws InterruptedException, InvocationTargetException {\n@@ -233,6 +417,7 @@\n-     * Constructs a JFrame with a given title & serves as test instructional\n-     * frame where the user follows the specified test instruction in order\n-     * to test the test case & mark the test pass or fail. If the expected\n-     * result is seen then the user click on the 'Pass' button else click\n-     * on the 'Fail' button and the reason for the failure should be\n-     * specified in the JDialog JTextArea.\n+     * Constructs a frame which displays test instructions and\n+     * the <i>Pass<\/i> \/ <i>Fail<\/i> buttons\n+     * with the given title, instructions, timeout, number of rows and columns.\n+     * The screenshot feature is not enabled, if you use this constructor.\n+     * <p>\n+     * See {@link #PassFailJFrame(String,String,long,int,int,boolean)} for\n+     * more details.\n@@ -240,11 +425,10 @@\n-     * @param title        title of the Frame.\n-     * @param instructions the instruction for the tester on how to test\n-     *                     and what is expected (pass) and what is not\n-     *                     expected (fail).\n-     * @param testTimeOut  test timeout where time is specified in minutes.\n-     * @param rows         number of visible rows of the JTextArea where the\n-     *                     instruction is show.\n-     * @param columns      Number of columns of the instructional\n-     *                     JTextArea\n-     * @throws InterruptedException      exception thrown when thread is\n-     *                                   interrupted\n+     * @param title        the title of the instruction frame\n+     * @param instructions the instructions for the tester\n+     * @param testTimeOut  the test timeout in minutes\n+     * @param rows         the number of rows for the text component\n+     *                     which displays test instructions\n+     * @param columns      the number of columns for the text component\n+     *                     which displays test instructions\n+     *\n+     * @throws InterruptedException if the current thread is interrupted\n+     *              while waiting for EDT to finish creating UI components\n@@ -252,2 +436,1 @@\n-     *                                   creating the test instruction frame on\n-     *                                   EDT\n+     *              creating UI components on EDT\n@@ -255,3 +438,4 @@\n-    public PassFailJFrame(String title, String instructions, long testTimeOut,\n-                          int rows, int columns) throws InterruptedException,\n-            InvocationTargetException {\n+    public PassFailJFrame(String title, String instructions,\n+                          long testTimeOut,\n+                          int rows, int columns)\n+            throws InterruptedException, InvocationTargetException {\n@@ -262,6 +446,16 @@\n-     * Constructs a JFrame with a given title & serves as test instructional\n-     * frame where the user follows the specified test instruction in order\n-     * to test the test case & mark the test pass or fail. If the expected\n-     * result is seen then the user click on the 'Pass' button else click\n-     * on the 'Fail' button and the reason for the failure should be\n-     * specified in the JDialog JTextArea.\n+     * Constructs a frame which displays test instructions and\n+     * the <i>Pass<\/i> \/ <i>Fail<\/i> buttons\n+     * as well as supporting UI components with the given title, instructions,\n+     * timeout, number of rows and columns,\n+     * and screen capture functionality.\n+     * All the UI components are created on the EDT, so it is safe to call\n+     * the constructor on the main thread.\n+     * <p>\n+     * After you create a test UI window, register the window using\n+     * {@link #addTestWindow(Window) addTestWindow} for disposal, and\n+     * position it close to the instruction frame using\n+     * {@link #positionTestWindow(Window, Position) positionTestWindow}.\n+     * As the last step, make your test UI window visible.\n+     * <p>\n+     * Call the {@link #awaitAndCheck() awaitAndCheck} method on the instance\n+     * of {@code PassFailJFrame} when you set up the testing environment.\n@@ -269,4 +463,18 @@\n-     * The test instruction frame also provides a way for the tester to take\n-     * a screenshot (full screen or individual frame) if this feature\n-     * is enabled by passing {@code true} as {@code  enableScreenCapture}\n-     * parameter.\n+     * If the tester clicks the <i>Fail<\/i> button, a dialog prompting for\n+     * a description of the problem is displayed, and then an exception\n+     * is thrown which fails the test.\n+     * If the tester clicks the <i>Pass<\/i> button, the test completes\n+     * successfully.\n+     * If the timeout occurs or the instruction frame is closed,\n+     * the test fails.\n+     * <p>\n+     * The {@code rows} and {@code columns} parameters control\n+     * the size of a text component which displays the instructions.\n+     * The preferred size of the instructions is calculated by\n+     * creating {@code new JTextArea(rows, columns)}.\n+     * <p>\n+     * If you enable screenshots by setting the {@code screenCapture}\n+     * parameter to {@code true}, a <i>Screenshot<\/i> button is added.\n+     * Clicking the <i>Screenshot<\/i> button takes screenshots of\n+     * all the monitors or all the windows registered with\n+     * {@code PassFailJFrame}.\n@@ -274,14 +482,12 @@\n-     * @param title        title of the Frame.\n-     * @param instructions the instruction for the tester on how to test\n-     *                     and what is expected (pass) and what is not\n-     *                     expected (fail).\n-     * @param testTimeOut  test timeout where time is specified in minutes.\n-     * @param rows         number of visible rows of the JTextArea where the\n-     *                     instruction is show.\n-     * @param columns      Number of columns of the instructional\n-     *                     JTextArea\n-     * @param enableScreenCapture if set to true, 'Capture Screen' button & its\n-     *                            associated UIs are added to test instruction\n-     *                            frame\n-     * @throws InterruptedException      exception thrown when thread is\n-     *                                   interrupted\n+     * @param title        the title of the instruction frame\n+     * @param instructions the instructions for the tester\n+     * @param testTimeOut  the test timeout in minutes\n+     * @param rows         the number of rows for the text component\n+     *                     which displays test instructions\n+     * @param columns      the number of columns for the text component\n+     *                     which displays test instructions\n+     * @param screenCapture if set to {@code true}, enables screen capture\n+     *                      functionality\n+     *\n+     * @throws InterruptedException if the current thread is interrupted\n+     *              while waiting for EDT to finish creating UI components\n@@ -289,2 +495,4 @@\n-     *                                   creating the test instruction frame on\n-     *                                   EDT\n+     *              creating UI components on EDT\n+     *\n+     * @see JTextArea#JTextArea(int,int) JTextArea(int rows, int columns)\n+     * @see Builder Builder\n@@ -292,1 +500,2 @@\n-    public PassFailJFrame(String title, String instructions, long testTimeOut,\n+    public PassFailJFrame(String title, String instructions,\n+                          long testTimeOut,\n@@ -294,1 +503,1 @@\n-                          boolean enableScreenCapture)\n+                          boolean screenCapture)\n@@ -299,1 +508,1 @@\n-                                   enableScreenCapture));\n+                                   screenCapture));\n@@ -457,1 +666,5 @@\n-        main.add(new JScrollPane(text), BorderLayout.CENTER);\n+        JPanel textPanel = new JPanel(new BorderLayout());\n+        textPanel.setBorder(createEmptyBorder(4, 0, 0, 0));\n+        textPanel.add(new JScrollPane(text), BorderLayout.CENTER);\n+\n+        main.add(textPanel, BorderLayout.CENTER);\n@@ -590,1 +803,1 @@\n-        void positionTestWindows(List<? extends Window> testWindows,\n+        void positionTestWindows(List<Window> testWindows,\n@@ -738,1 +951,1 @@\n-        JButton capture = new JButton(\"ScreenShot\");\n+        JButton capture = new JButton(\"Screenshot\");\n@@ -750,1 +963,1 @@\n-        WINDOWS(\"Capture Individual Frame\");\n+        WINDOWS(\"Capture Frames\");\n@@ -928,1 +1141,1 @@\n-                int newX = ((screenSize.width \/ 2) - frame.getWidth());\n+                int newX = (((screenSize.width + WINDOW_GAP) \/ 2) - frame.getWidth());\n@@ -934,1 +1147,1 @@\n-                int newY = ((screenSize.height \/ 2) - frame.getHeight());\n+                int newY = (((screenSize.height + WINDOW_GAP) \/ 2) - frame.getHeight());\n@@ -982,1 +1195,1 @@\n-                    testWindow.setLocation((frame.getX() + frame.getWidth() + 5),\n+                    testWindow.setLocation((frame.getX() + frame.getWidth() + WINDOW_GAP),\n@@ -988,1 +1201,1 @@\n-                                           (frame.getY() + frame.getHeight() + 5));\n+                                           (frame.getY() + frame.getHeight() + WINDOW_GAP));\n@@ -1291,0 +1504,1 @@\n+\n@@ -1314,0 +1528,71 @@\n+        \/**\n+         * Positions the test UI windows in a row to the right of\n+         * the instruction frame. The top of the windows is aligned to\n+         * that of the instruction frame.\n+         *\n+         * @return this builder\n+         *\/\n+        public Builder positionTestUIRightRow() {\n+            return position(Position.HORIZONTAL)\n+                   .positionTestUI(WindowLayouts::rightOneRow);\n+        }\n+\n+        \/**\n+         * Positions the test UI windows in a column to the right of\n+         * the instruction frame. The top of the first window is aligned to\n+         * that of the instruction frame.\n+         *\n+         * @return this builder\n+         *\/\n+        public Builder positionTestUIRightColumn() {\n+            return position(Position.HORIZONTAL)\n+                   .positionTestUI(WindowLayouts::rightOneColumn);\n+        }\n+\n+        \/**\n+         * Positions the test UI windows in a column to the right of\n+         * the instruction frame centering the stack of the windows.\n+         *\n+         * @return this builder\n+         *\/\n+        public Builder positionTestUIRightColumnCentered() {\n+            return position(Position.HORIZONTAL)\n+                   .positionTestUI(WindowLayouts::rightOneColumnCentered);\n+        }\n+\n+        \/**\n+         * Positions the test UI windows in a row to the bottom of\n+         * the instruction frame. The left of the first window is aligned to\n+         * that of the instruction frame.\n+         *\n+         * @return this builder\n+         *\/\n+        public Builder positionTestUIBottomRow() {\n+            return position(Position.VERTICAL)\n+                   .positionTestUI(WindowLayouts::bottomOneRow);\n+        }\n+\n+        \/**\n+         * Positions the test UI windows in a row to the bottom of\n+         * the instruction frame centering the row of the windows.\n+         *\n+         * @return this builder\n+         *\/\n+        public Builder positionTestUIBottomRowCentered() {\n+            return position(Position.VERTICAL)\n+                   .positionTestUI(WindowLayouts::bottomOneRowCentered);\n+        }\n+\n+        \/**\n+         * Positions the test UI windows in a column to the bottom of\n+         * the instruction frame. The left of the first window is aligned to\n+         * that of the instruction frame.\n+         *\n+         * @return this builder\n+         *\/\n+        public Builder positionTestUIBottomColumn() {\n+            return position(Position.VERTICAL)\n+                   .positionTestUI(WindowLayouts::bottomOneColumn);\n+        }\n+\n+\n@@ -1416,0 +1701,1 @@\n+\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/PassFailJFrame.java","additions":381,"deletions":95,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Window;\n+import java.util.List;\n+\n+import static java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment;\n+import static java.awt.Toolkit.getDefaultToolkit;\n+\n+\/**\n+ * A utility class which provides standard window layouts for multi-window\n+ * manual tests using the {@link PassFailJFrame} framework.\n+ * The layout methods {@code right-} and {@code bottom-} implement the\n+ * {@link PassFailJFrame.PositionWindows PositionWindows} interface and\n+ * can be used directly or via builder methods.\n+ * <p>\n+ * There are several helper methods, such as\n+ * {@link #getScreenCenter() getScreenCenter}, which could help you\n+ * implement customized windows layouts.\n+ *\/\n+public final class WindowLayouts {\n+\n+    \/** Private constructor to prevent instantiating the utility class. *\/\n+    private WindowLayouts() {\n+    }\n+\n+    \/** A gap between windows. (Local copy makes expressions shorter.) *\/\n+    private static final int WINDOW_GAP = PassFailJFrame.WINDOW_GAP;\n+\n+    \/**\n+     * Lays out the window list in one row to the right of\n+     * the instruction frame. The top of the windows is aligned to\n+     * that of the instruction frame.\n+     *\n+     * @param windows the list of windows to lay out\n+     * @param instructionUI information about the instruction frame\n+     *\/\n+    public static void rightOneRow(final List<Window> windows,\n+                                   final PassFailJFrame.InstructionUI instructionUI) {\n+        layoutRow(instructionUI.getLocation().x\n+                  + instructionUI.getSize().width\n+                  + WINDOW_GAP,\n+                  instructionUI.getLocation().y,\n+                  windows);\n+    }\n+\n+    \/**\n+     * Lays out the window list in one column to the right of\n+     * the instruction frame. The top of the first window is aligned to\n+     * that of the instruction frame.\n+     *\n+     * @param windows the list of windows to lay out\n+     * @param instructionUI information about the instruction frame\n+     *\/\n+    public static void rightOneColumn(final List<Window> windows,\n+                                      final PassFailJFrame.InstructionUI instructionUI) {\n+        layoutColumn(instructionUI.getLocation().x\n+                     + instructionUI.getSize().width\n+                     + WINDOW_GAP,\n+                     instructionUI.getLocation().y,\n+                     windows);\n+    }\n+\n+    \/**\n+     * Lays out the window list in one column to the right of\n+     * the instruction frame centering the stack of the windows.\n+     *\n+     * @param windows the list of windows to lay out\n+     * @param instructionUI information about the instruction frame\n+     *\/\n+    public static void rightOneColumnCentered(final List<Window> windows,\n+                                              final PassFailJFrame.InstructionUI instructionUI) {\n+        layoutColumn(instructionUI.getLocation().x\n+                     + instructionUI.getSize().width\n+                     + WINDOW_GAP,\n+                     getScreenCenter().y\n+                     - getWindowListHeight(windows) \/ 2,\n+                     windows);\n+    }\n+\n+\n+    \/**\n+     * Lays out the window list in one row to the bottom of\n+     * the instruction frame. The left of the first window is aligned to\n+     * that of the instruction frame.\n+     *\n+     * @param windows the list of windows to lay out\n+     * @param instructionUI information about the instruction frame\n+     *\/\n+    public static void bottomOneRow(final List<Window> windows,\n+                                    final PassFailJFrame.InstructionUI instructionUI) {\n+        layoutRow(instructionUI.getLocation().x,\n+                  instructionUI.getLocation().y\n+                  + instructionUI.getSize().height\n+                  + WINDOW_GAP,\n+                  windows);\n+    }\n+\n+    \/**\n+     * Lays out the window list in one row to the bottom of\n+     * the instruction frame centering the row of the windows.\n+     *\n+     * @param windows the list of windows to lay out\n+     * @param instructionUI information about the instruction frame\n+     *\/\n+    public static void bottomOneRowCentered(final List<Window> windows,\n+                                            final PassFailJFrame.InstructionUI instructionUI) {\n+        layoutRow(getScreenCenter().x\n+                  - getWindowListWidth(windows) \/ 2,\n+                  instructionUI.getLocation().y\n+                  + instructionUI.getSize().height\n+                  + WINDOW_GAP,\n+                  windows);\n+    }\n+\n+    \/**\n+     * Lays out the window list in one column to the bottom of\n+     * the instruction frame. The left of the first window is aligned to\n+     * that of the instruction frame.\n+     *\n+     * @param windows the list of windows to lay out\n+     * @param instructionUI information about the instruction frame\n+     *\/\n+    public static void bottomOneColumn(final List<Window> windows,\n+                                       final PassFailJFrame.InstructionUI instructionUI) {\n+        layoutColumn(instructionUI.getLocation().x,\n+                     instructionUI.getLocation().y\n+                     + instructionUI.getSize().height\n+                     + WINDOW_GAP,\n+                     windows);\n+    }\n+\n+\n+    \/**\n+     * Lays out the window list in one row starting at\n+     * ({@code x0}, {@code y}).\n+     *\n+     * @param x0 the starting <var>x<\/var> coordinate of the windows\n+     * @param y the <var>y<\/var> coordinate of the windows\n+     * @param windows the list of windows to lay out\n+     *\/\n+    public static void layoutRow(final int x0,\n+                                 final int y,\n+                                 final List<Window> windows) {\n+        int x = x0;\n+        for (Window w : windows) {\n+            w.setLocation(x, y);\n+            x += w.getWidth() + WINDOW_GAP;\n+        }\n+    }\n+\n+    \/**\n+     * Lays out the window list in one column starting at\n+     * ({@code x}, {@code y0}).\n+     *\n+     * @param x the <var>x<\/var> coordinate of the windows\n+     * @param y0 the starting <var>y<\/var> coordinate of the windows\n+     * @param windows the list of windows to lay out\n+     *\/\n+    public static void layoutColumn(final int x,\n+                                    final int y0,\n+                                    final List<Window> windows) {\n+        int y = y0;\n+        for (Window w : windows) {\n+            w.setLocation(x, y);\n+            y += w.getHeight() + WINDOW_GAP;\n+        }\n+    }\n+\n+\n+    \/**\n+     * {@return the center point of the main screen}\n+     *\/\n+    public static Point getScreenCenter() {\n+        GraphicsConfiguration gc = getLocalGraphicsEnvironment()\n+                                   .getDefaultScreenDevice()\n+                                   .getDefaultConfiguration();\n+        Dimension size = gc.getBounds()\n+                           .getSize();\n+        Insets insets = getDefaultToolkit()\n+                        .getScreenInsets(gc);\n+\n+        return new Point((size.width - insets.left - insets.right) \/ 2,\n+                         (size.height - insets.top - insets.bottom) \/ 2);\n+    }\n+\n+    \/**\n+     * {@return width of the windows in the list, taking into account\n+     * the gap between windows}\n+     *\n+     * @param windows the list of windows to get the width of\n+     *\/\n+    public static int getWindowListWidth(final List<Window> windows) {\n+        return windows.stream()\n+                      .mapToInt(Component::getWidth)\n+                      .sum()\n+               + WINDOW_GAP * (windows.size() - 1);\n+    }\n+\n+    \/**\n+     * {@return height of the windows in the list, taking into account\n+     * the gap between windows}\n+     *\n+     * @param windows the list of windows to get the height of\n+     *\/\n+    public static int getWindowListHeight(final List<Window> windows) {\n+        return windows.stream()\n+                      .mapToInt(Component::getHeight)\n+                      .sum()\n+               + WINDOW_GAP * (windows.size() - 1);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/WindowLayouts.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import jdk.internal.util.ArraysSupport;\n+\n@@ -29,0 +31,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -46,1 +49,1 @@\n-            String str = \"Z\".repeat(Integer.MAX_VALUE - 8);\n+            String str = \"Z\".repeat(ArraysSupport.SOFT_MAX_ARRAY_LENGTH);\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/HugeCapacity.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import jdk.internal.util.ArraysSupport;\n+\n@@ -29,0 +31,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -78,1 +81,1 @@\n-            String str = \"Z\".repeat(Integer.MAX_VALUE - 8);\n+            String str = \"Z\".repeat(ArraysSupport.SOFT_MAX_ARRAY_LENGTH);\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/HugeCapacity.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run junit\/othervm\/timeout=2500 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies -esa -DBigArityTest.ITERATION_COUNT=1 test.java.lang.invoke.BigArityTest\n+ * @run junit\/othervm\/timeout=2500 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies -XX:CompileCommand=memlimit,*.*,0 -esa -DBigArityTest.ITERATION_COUNT=1 test.java.lang.invoke.BigArityTest\n","filename":"test\/jdk\/java\/lang\/invoke\/BigArityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+import java.math.BigInteger;\n+import java.math.MutableBigIntegerBox;\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static java.math.MutableBigIntegerBox.*;\n+\n+\/**\n+ * @test\n+ * @bug 8336274\n+ * @summary Tests for correctness of MutableBigInteger.leftShift(int)\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build java.base\/java.math.MutableBigIntegerBox\n+ * @key randomness\n+ * @run junit MutableBigIntegerShiftTests\n+ *\/\n+public class MutableBigIntegerShiftTests {\n+\n+    private static final int ORDER_SMALL = 60;\n+    private static final int ORDER_MEDIUM = 100;\n+\n+    private static final Random random = RandomFactory.getRandom();\n+\n+    private static int[] orders() {\n+        return new int[] { ORDER_SMALL, ORDER_MEDIUM };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"orders\")\n+    public void shift(int order) {\n+        for (int i = 0; i < 100; i++) {\n+            test(fetchNumber(order), random.nextInt(200));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pathTargetedCases\")\n+    public void test(MutableBigIntegerBox x, int n) {\n+        leftShiftAssertions(x, n);\n+    }\n+\n+    private static Arguments[] pathTargetedCases() {\n+        return new Arguments[] {\n+                \/\/ intLen == 0\n+                Arguments.of(MutableBigIntegerBox.ZERO,\n+                        random.nextInt(33)),\n+                \/\/ intLen != 0 && n <= leadingZeros\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L, 1L << 16) }),\n+                        random.nextInt(1, 17)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length < newLen && nBits == 0\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L, 1L << 32) }),\n+                        32),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length < newLen && nBits != 0\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L, 1L << 16) }),\n+                        32 + random.nextInt(1, 17)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length >= newLen && nBits == 0\n+                \/\/ && newOffset != offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { random.nextInt(), (int) random.nextLong(1L, 1L << 32) }, 1, 1),\n+                        32),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length >= newLen && nBits == 0\n+                \/\/ && newOffset == offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L, 1L << 32), random.nextInt() }, 0, 1),\n+                        32),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length >= newLen && nBits != 0\n+                \/\/ && newOffset != offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { random.nextInt(), (int) random.nextLong(1L, 1L << 16) }, 1, 1),\n+                        32 + random.nextInt(1, 17)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length >= newLen && nBits != 0\n+                \/\/ && newOffset == offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L, 1L << 16), random.nextInt() }, 0, 1),\n+                        32 + random.nextInt(1, 17)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits > leadingZeros && value.length < newLen\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L << 15, 1L << 32) }),\n+                        random.nextInt(17, 32)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits > leadingZeros && value.length >= newLen && newOffset != offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { random.nextInt(), (int) random.nextLong(1L << 15, 1L << 32) }, 1, 1),\n+                        random.nextInt(17, 32)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits > leadingZeros && value.length >= newLen && newOffset == offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L << 15, 1L << 32), random.nextInt() }, 0, 1),\n+                        random.nextInt(17, 32)),\n+        };\n+    }\n+\n+    private static void leftShiftAssertions(MutableBigIntegerBox x, int n) {\n+        MutableBigIntegerBox xShifted = x.shiftLeft(n);\n+        assertEquals(x.multiply(new MutableBigIntegerBox(BigInteger.TWO.pow(n))), xShifted);\n+        assertEquals(x, xShifted.shiftRight(n));\n+    }\n+\n+    \/*\n+     * Get a random or boundary-case number. This is designed to provide\n+     * a lot of numbers that will find failure points, such as max sized\n+     * numbers, empty MutableBigIntegers, etc.\n+     *\n+     * If order is less than 2, order is changed to 2.\n+     *\/\n+    private static MutableBigIntegerBox fetchNumber(int order) {\n+        int numType = random.nextInt(8);\n+        MutableBigIntegerBox result = null;\n+        if (order < 2) order = 2;\n+\n+        int[] val;\n+        switch (numType) {\n+            case 0: \/\/ Empty\n+                result = MutableBigIntegerBox.ZERO;\n+                break;\n+\n+            case 1: \/\/ One\n+                result = MutableBigIntegerBox.ONE;\n+                break;\n+\n+            case 2: \/\/ All bits set in number\n+                int numInts = (order + 31) >> 5;\n+                int[] fullBits = new int[numInts];\n+                Arrays.fill(fullBits, -1);\n+\n+                fullBits[0] &= -1 >>> -order;\n+                result = new MutableBigIntegerBox(fullBits);\n+                break;\n+\n+            case 3: \/\/ One bit in number\n+                result = MutableBigIntegerBox.ONE.shiftLeft(random.nextInt(order));\n+                break;\n+\n+            case 4: \/\/ Random bit density\n+                val = new int[(order + 31) >> 5];\n+                int iterations = random.nextInt(order);\n+                for (int i = 0; i < iterations; i++) {\n+                    int bitIdx = random.nextInt(order);\n+                    val[bitIdx >> 5] |= 1 << bitIdx;\n+                }\n+                result = new MutableBigIntegerBox(val);\n+                break;\n+            case 5: \/\/ Runs of consecutive ones and zeros\n+                result = ZERO;\n+                int remaining = order;\n+                int bit = random.nextInt(2);\n+                while (remaining > 0) {\n+                    int runLength = Math.min(remaining, random.nextInt(order));\n+                    result = result.shiftLeft(runLength);\n+                    if (bit > 0)\n+                        result = result.add(ONE.shiftLeft(runLength).subtract(ONE));\n+                    remaining -= runLength;\n+                    bit = 1 - bit;\n+                }\n+                break;\n+            case 6: \/\/ random bits with trailing space\n+                int len = random.nextInt((order + 31) >> 5) + 1;\n+                int offset = random.nextInt(len);\n+                val = new int[len << 1];\n+                for (int i = 0; i < val.length; i++)\n+                    val[i] = random.nextInt();\n+                result = new MutableBigIntegerBox(val, offset, len);\n+                break;\n+            default: \/\/ random bits\n+                result = new MutableBigIntegerBox(new BigInteger(order, random));\n+        }\n+\n+        return result;\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/MutableBigIntegerShiftTests.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.math;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * A class for tests.\n+ *\/\n+public class MutableBigIntegerBox {\n+\n+    \/**\n+     * Constant zero\n+     *\/\n+    public static final MutableBigIntegerBox ZERO = new MutableBigIntegerBox(new MutableBigInteger());\n+\n+    \/**\n+     * Constant one\n+     *\/\n+    public static final MutableBigIntegerBox ONE = new MutableBigIntegerBox(MutableBigInteger.ONE);\n+\n+    \/**\n+     * Constant two\n+     *\/\n+    public static final MutableBigIntegerBox TWO = new MutableBigIntegerBox(new MutableBigInteger(2));\n+\n+    private MutableBigInteger val;\n+\n+    MutableBigIntegerBox(MutableBigInteger val) {\n+        this.val = val;\n+    }\n+\n+    \/**\n+     * Construct MutableBigIntegerBox from magnitude, starting from\n+     * offset and with a length of intLen ints.\n+     * The value is normalized.\n+     * @param mag the magnitude\n+     * @param offset the offset where the value starts\n+     * @param intLen the length of the value, in int words.\n+     *\/\n+    public MutableBigIntegerBox(int[] mag, int offset, int intLen) {\n+        this(new MutableBigInteger(mag));\n+        val.offset = offset;\n+        val.intLen = intLen;\n+        val.normalize();\n+    }\n+\n+    \/**\n+     * Construct MutableBigIntegerBox from magnitude.\n+     * The value is normalized.\n+     * @param mag the magnitude\n+     *\/\n+    public MutableBigIntegerBox(int[] mag) {\n+        this(mag, 0, mag.length);\n+    }\n+\n+    \/**\n+     * Construct MutableBigIntegerBox from BigInteger val\n+     * @param val the value\n+     *\/\n+    public MutableBigIntegerBox(BigInteger val) {\n+        this(val.mag);\n+    }\n+\n+    \/**\n+     * Returns the bit length of this MutableBigInteger value\n+     * @return the bit length of this MutableBigInteger value\n+     *\/\n+    public long bitLength() {\n+        return val.bitLength();\n+    }\n+\n+    \/**\n+     * Return {@code this << n}\n+     * @return {@code this << n}\n+     * @param n the shift\n+     *\/\n+    public MutableBigIntegerBox shiftLeft(int n) {\n+        MutableBigIntegerBox res = new MutableBigIntegerBox(val.value.clone(), val.offset, val.intLen);\n+        res.val.safeLeftShift(n);\n+        return res;\n+    }\n+\n+    \/**\n+     * Return {@code this >> n}\n+     * @return {@code this >> n}\n+     * @param n the shift\n+     *\/\n+    public MutableBigIntegerBox shiftRight(int n) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.safeRightShift(n);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this + addend\n+     * @return this + addend\n+     * @param addend the addend\n+     *\/\n+    public MutableBigIntegerBox add(MutableBigIntegerBox addend) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.add(addend.val);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this - subtraend\n+     * @return this - subtraend\n+     * @param subtraend the subtraend\n+     *\/\n+    public MutableBigIntegerBox subtract(MutableBigIntegerBox subtraend) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.subtract(subtraend.val);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this * multiplier\n+     * @return this * multiplier\n+     * @param multiplier the multiplier\n+     *\/\n+    public MutableBigIntegerBox multiply(MutableBigIntegerBox multiplier) {\n+        MutableBigInteger res = new MutableBigInteger();\n+        if (!(val.isZero() || multiplier.val.isZero()))\n+            val.multiply(multiplier.val, res);\n+\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Compare the magnitude of two MutableBigIntegers. Returns -1, 0 or 1\n+     * as this is numerically less than, equal to, or greater than {@code b}.\n+     * @return -1, 0 or 1 as this is numerically less than, equal to, or\n+     * greater than {@code b}.\n+     * @param b the value to compare\n+     *\/\n+    public int compare(MutableBigIntegerBox b) {\n+        return val.compare(b.val);\n+    }\n+\n+    \/**\n+     * Compares this MutableBigIntegerBox with the specified Object for equality.\n+     *\n+     * @param  x Object to which this MutableBigIntegerBox is to be compared.\n+     * @return {@code true} if and only if the specified Object is a\n+     *         MutableBigIntegerBox whose value is numerically equal to this MutableBigIntegerBox.\n+     *\/\n+    @Override\n+    public boolean equals(Object x) {\n+        return (x instanceof MutableBigIntegerBox xInt)\n+                && Arrays.equals(val.value, val.offset, val.offset + val.intLen,\n+                        xInt.val.value, xInt.val.offset, xInt.val.offset + xInt.val.intLen);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return val.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/java.base\/java\/math\/MutableBigIntegerBox.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -40,0 +41,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -47,2 +49,2 @@\n-            \/\/ SOFT_MAX_ARRAY_LENGTH: copied from ArraysSupport. No overflow; no OOME.\n-            Arguments.of(Integer.MAX_VALUE - 8),\n+            \/\/ No overflow; no OOME.\n+            Arguments.of(ArraysSupport.SOFT_MAX_ARRAY_LENGTH),\n","filename":"test\/jdk\/java\/nio\/charset\/CharsetDecoder\/XcodeOverflow.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340404\n+ * @summary Check that a CharsetProvider SPI can be deployed as a module\n+ * @build provider\/*\n+ * @run main\/othervm CharsetProviderAsModuleTest\n+ *\/\n+\n+import java.nio.charset.Charset;\n+\n+public class CharsetProviderAsModuleTest {\n+\n+    \/\/ Basic test ensures that our BAZ charset is loaded via the BazProvider\n+    public static void main(String[] args) {\n+        var cs = Charset.availableCharsets();\n+        Charset bazCs;\n+        \/\/ check provider is providing BAZ via charsets()\n+        if (!cs.containsKey(\"BAZ\")) {\n+            throw new RuntimeException(\"SPI BazProvider did not provide BAZ Charset\");\n+        } else {\n+            bazCs = cs.get(\"BAZ\");\n+            \/\/ check provider is in a named module\n+            if (!bazCs.getClass().getModule().isNamed()) {\n+                throw new RuntimeException(\"BazProvider is not a named module\");\n+            }\n+            var aliases = bazCs.aliases();\n+            \/\/ check BAZ cs aliases were loaded correctly\n+            if (!aliases.contains(\"BAZ-1\") || !aliases.contains(\"BAZ-2\")) {\n+                throw new RuntimeException(\"BAZ Charset did not provide correct aliases\");\n+            }\n+            \/\/ check provider implements charsetForName()\n+            if (!bazCs.equals(Charset.forName(\"BAZ\"))) {\n+                throw new RuntimeException(\"SPI BazProvider provides bad charsetForName()\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/charset\/spi\/CharsetProviderAsModuleTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module provider {\n+    provides java.nio.charset.spi.CharsetProvider with spi.BazProvider;\n+}\n","filename":"test\/jdk\/java\/nio\/charset\/spi\/provider\/module-info.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package spi;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.spi.CharsetProvider;\n+import java.util.Collections;\n+import java.util.Iterator;\n+\n+\/\/ Provides some simple BAZ related attributes to our provider\n+public class BazProvider extends CharsetProvider {\n+\n+    @Override\n+    public Iterator charsets() {\n+        return Collections.singleton(new BazCharset()).iterator();\n+    }\n+\n+    @Override\n+    public Charset charsetForName(String charsetName) {\n+        if (charsetName.equals(\"BAZ\")) {\n+            return new BazCharset();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public static class BazCharset extends Charset {\n+\n+        public BazCharset() {\n+            super(\"BAZ\", new String[] { \"BAZ-1\", \"BAZ-2\" });\n+        }\n+\n+        \/\/ Overrides to satisfy Charset\n+        @Override\n+        public boolean contains(Charset cs) {\n+            return false;\n+        }\n+\n+        @Override\n+        public CharsetDecoder newDecoder() {\n+            return null;\n+        }\n+\n+        @Override\n+        public CharsetEncoder newEncoder() {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/charset\/spi\/provider\/spi\/BazProvider.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -40,0 +41,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -48,1 +50,1 @@\n-    private static final int LARGE_MEM_SIZE = Integer.MAX_VALUE - 8;\n+    private static final int LARGE_MEM_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"test\/jdk\/java\/util\/Base64\/TestEncodingDecodingLength.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -89,1 +90,1 @@\n-        final int maxArraySize = Integer.MAX_VALUE - 8;\n+        final int maxArraySize = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ArrayDeque8Test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @modules java.management\n+ * @modules java.management java.base\/jdk.internal.util\n@@ -50,1 +50,1 @@\n- * @modules java.management\n+ * @modules java.management java.base\/jdk.internal.util\n@@ -59,1 +59,1 @@\n- * @modules java.management\n+ * @modules java.management java.base\/jdk.internal.util\n@@ -81,1 +81,1 @@\n- * @modules java.management\n+ * @modules java.management java.base\/jdk.internal.util\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/JSR166TestCase.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -30,0 +31,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -52,1 +54,1 @@\n-    static final int MAX_CEN_SIZE = Integer.MAX_VALUE - ZipFile.ENDHDR - 1;\n+    static final int MAX_CEN_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CenSizeTooLarge.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -30,0 +31,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -71,1 +73,1 @@\n-    private static int MAX_CEN_SIZE = Integer.MAX_VALUE - ENDHDR - 1;\n+    private static int MAX_CEN_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/EndOfCenValidation.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -9,0 +9,1 @@\n+maxOutputSize = 2500000\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341277\n+ * @summary Testing ClassFile instruction argument validation.\n+ * @run junit InstructionValidationTest\n+ *\/\n+\n+import java.lang.classfile.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.instruction.*;\n+import java.util.List;\n+import java.util.function.ObjIntConsumer;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.function.Executable;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static java.lang.classfile.Opcode.*;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class InstructionValidationTest {\n+\n+    @Test\n+    void testArgumentConstant() {\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MAX_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MAX_VALUE));\n+\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int) Short.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int) Short.MAX_VALUE + 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int) Byte.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int) Byte.MAX_VALUE + 1));\n+    }\n+\n+    \/**\n+     * Tests the bad slot argument IAE for load, store, increment, and ret.\n+     *\/\n+    @Test\n+    void testSlots() {\n+        record Result(boolean shouldFail, int slot) {\n+        }\n+\n+        List<Integer> badSlots = List.of(-1, 72694, -42, 0x10000, Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        List<Integer> u2OnlySlots = List.of(0x100, 1000, 0xFFFF);\n+        List<Integer> u1Slots = List.of(0, 2, 15, 0xFF);\n+\n+        List<Integer> badU1Slots = Stream.concat(badSlots.stream(), u2OnlySlots.stream()).toList();\n+        List<Integer> u2Slots = Stream.concat(u1Slots.stream(), u2OnlySlots.stream()).toList();\n+        List<Result> u2Cases = Stream.concat(\n+                badSlots.stream().map(i -> new Result(true, i)),\n+                u2Slots.stream().map(i -> new Result(false, i))\n+        ).toList();\n+        List<Result> u1Cases = Stream.concat(\n+                badU1Slots.stream().map(i -> new Result(true, i)),\n+                u1Slots.stream().map(i -> new Result(false, i))\n+        ).toList();\n+        List<Integer> nonIntrinsicValues = Stream.of(badSlots, u2Slots, u1Slots).<Integer>mapMulti(List::forEach)\n+                .filter(i -> i < 0 || i > 3).toList();\n+\n+        Label[] capture = new Label[1];\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            capture[0] = cob.startLabel();\n+            cob.return_();\n+        }));\n+        Label dummyLabel = capture[0];\n+\n+        List<ObjIntConsumer<CodeBuilder>> cbFactories = List.of(\n+                CodeBuilder::aload,\n+                CodeBuilder::iload,\n+                CodeBuilder::lload,\n+                CodeBuilder::dload,\n+                CodeBuilder::fload,\n+                CodeBuilder::astore,\n+                CodeBuilder::istore,\n+                CodeBuilder::lstore,\n+                CodeBuilder::dstore,\n+                CodeBuilder::fstore\n+        );\n+\n+        for (var r : u2Cases) {\n+            var fails = r.shouldFail;\n+            var i = r.slot;\n+            for (var fac : cbFactories) {\n+                \/\/check(fails, () -> execute(cob -> fac.accept(cob, i)));\n+            }\n+            for (TypeKind tk : TypeKind.values()) {\n+                if (tk == TypeKind.VOID)\n+                    continue;\n+                \/\/check(fails, () -> execute(cob -> cob.loadLocal(tk, i)));\n+                \/\/check(fails, () -> execute(cob -> cob.storeLocal(tk, i)));\n+                check(fails, () -> LoadInstruction.of(tk, i));\n+                check(fails, () -> StoreInstruction.of(tk, i));\n+            }\n+            \/\/check(fails, () -> execute(cob -> cob.iinc(i, 1)));\n+            check(fails, () -> IncrementInstruction.of(i, 1));\n+            check(fails, () -> DiscontinuedInstruction.RetInstruction.of(i));\n+            check(fails, () -> DiscontinuedInstruction.RetInstruction.of(RET_W, i));\n+            check(fails, () -> LocalVariable.of(i, \"test\", CD_Object, dummyLabel, dummyLabel));\n+            check(fails, () -> LocalVariableType.of(i, \"test\", Signature.of(CD_Object), dummyLabel, dummyLabel));\n+        }\n+\n+        for (var r : u1Cases) {\n+            var fails = r.shouldFail;\n+            var i = r.slot;\n+            for (var u1Op : List.of(ALOAD, ILOAD, LLOAD, FLOAD, DLOAD))\n+                check(fails, () -> LoadInstruction.of(u1Op, i));\n+            for (var u1Op : List.of(ASTORE, ISTORE, LSTORE, FSTORE, DSTORE))\n+                check(fails, () -> StoreInstruction.of(u1Op, i));\n+            check(fails, () -> DiscontinuedInstruction.RetInstruction.of(RET, i));\n+        }\n+\n+        for (var i : nonIntrinsicValues) {\n+            for (var intrinsicOp : List.of(ALOAD_0, ILOAD_0, LLOAD_0, FLOAD_0, DLOAD_0, ALOAD_1, ILOAD_1, LLOAD_1, FLOAD_1, DLOAD_1,\n+                    ALOAD_2, ILOAD_2, LLOAD_2, FLOAD_2, DLOAD_2, ALOAD_3, ILOAD_3, LLOAD_3, FLOAD_3, DLOAD_3)) {\n+                assertThrows(IllegalArgumentException.class, () -> LoadInstruction.of(intrinsicOp, i));\n+            }\n+            for (var intrinsicOp : List.of(ASTORE_0, ISTORE_0, LSTORE_0, FSTORE_0, DSTORE_0, ASTORE_1, ISTORE_1, LSTORE_1, FSTORE_1, DSTORE_1,\n+                    ASTORE_2, ISTORE_2, LSTORE_2, FSTORE_2, DSTORE_2, ASTORE_3, ISTORE_3, LSTORE_3, FSTORE_3, DSTORE_3)) {\n+                assertThrows(IllegalArgumentException.class, () -> StoreInstruction.of(intrinsicOp, i));\n+            }\n+        }\n+    }\n+\n+    static void check(boolean fails, Executable exec) {\n+        if (fails) {\n+            assertThrows(IllegalArgumentException.class, exec);\n+        } else {\n+            assertDoesNotThrow(exec);\n+        }\n+    }\n+\n+    @Test\n+    void testIincConstant() {\n+        IncrementInstruction.of(0, 2);\n+        IncrementInstruction.of(0, Short.MAX_VALUE);\n+        IncrementInstruction.of(0, Short.MIN_VALUE);\n+        assertThrows(IllegalArgumentException.class, () -> IncrementInstruction.of(0, Short.MAX_VALUE + 1));\n+        assertThrows(IllegalArgumentException.class, () -> IncrementInstruction.of(0, Short.MIN_VALUE - 1));\n+    }\n+\n+    @Test\n+    void testNewMultiArrayDimension() {\n+        ClassEntry ce = ConstantPoolBuilder.of().classEntry(CD_Class);\n+        NewMultiArrayInstruction.of(ce, 1);\n+        NewMultiArrayInstruction.of(ce, 13);\n+        NewMultiArrayInstruction.of(ce, 0xFF);\n+        assertThrows(IllegalArgumentException.class, () -> NewMultiArrayInstruction.of(ce, 0));\n+        assertThrows(IllegalArgumentException.class, () -> NewMultiArrayInstruction.of(ce, 0x100));\n+        assertThrows(IllegalArgumentException.class, () -> NewMultiArrayInstruction.of(ce, -1));\n+        assertThrows(IllegalArgumentException.class, () -> NewMultiArrayInstruction.of(ce, Integer.MIN_VALUE));\n+        assertThrows(IllegalArgumentException.class, () -> NewMultiArrayInstruction.of(ce, Integer.MAX_VALUE));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/InstructionValidationTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Testing ClassFile constant instruction argument validation.\n- * @run junit OpcodesValidationTest\n- *\/\n-import java.lang.classfile.instruction.ConstantInstruction;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-import static java.lang.classfile.Opcode.*;\n-\n-class OpcodesValidationTest {\n-\n-    @Test\n-    void testArgumentConstant() {\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, 0));\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MIN_VALUE));\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MAX_VALUE));\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, 0));\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MIN_VALUE));\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MAX_VALUE));\n-\n-        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MIN_VALUE - 1));\n-        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MAX_VALUE + 1));\n-        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MIN_VALUE - 1));\n-        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MAX_VALUE + 1));\n-    }\n-}\n","filename":"test\/jdk\/jdk\/classfile\/OpcodesValidationTest.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-                             \"G1 Compaction Pause\", \"System.gc()\"};\n+                             \"G1 Compaction Pause\", \"CodeCache GC Threshold\", \"System.gc()\"};\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestGCCauseWithG1ConcurrentMark.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-                             \"G1 Compaction Pause\", \"System.gc()\"};\n+                             \"G1 Compaction Pause\", \"CodeCache GC Threshold\", \"System.gc()\"};\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestGCCauseWithG1FullCollection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,2 @@\n-        String[] gcCauses = {\"Allocation Failure\", \"System.gc()\", \"GCLocker Initiated GC\"};\n+        String[] gcCauses = {\"Allocation Failure\", \"System.gc()\", \"GCLocker Initiated GC\",\n+                             \"CodeCache GC Threshold\"};\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestGCCauseWithParallelOld.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,2 @@\n-        String[] gcCauses = {\"Allocation Failure\", \"System.gc()\", \"GCLocker Initiated GC\"};\n+        String[] gcCauses = {\"Allocation Failure\", \"System.gc()\", \"GCLocker Initiated GC\",\n+                             \"CodeCache GC Threshold\"};\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestGCCauseWithSerial.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -538,0 +538,22 @@\n+\/*\n+ * @test id=ssltlsrootecc2022\n+ * @bug 8341057\n+ * @summary Interoperability tests with SSL TLS 2022 root CAs\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop ssltlsrootecc2022 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop ssltlsrootecc2022 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop ssltlsrootecc2022 CRL\n+ *\/\n+\n+\/*\n+ * @test id=ssltlsrootrsa2022\n+ * @bug 8341057\n+ * @summary Interoperability tests with SSL TLS 2022 root CAs\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop ssltlsrootrsa2022 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop ssltlsrootrsa2022 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop ssltlsrootrsa2022 CRL\n+ *\/\n+\n@@ -716,0 +738,7 @@\n+            case \"ssltlsrootecc2022\" ->\n+                    new CATestURLs(\"https:\/\/test-root-2022-ecc.ssl.com\",\n+                            \"https:\/\/revoked-root-2022-ecc.ssl.com\");\n+            case \"ssltlsrootrsa2022\" ->\n+                    new CATestURLs(\"https:\/\/test-root-2022-rsa.ssl.com\",\n+                            \"https:\/\/revoked-root-2022-rsa.ssl.com\");\n+\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4286726\n+ * @summary Java2D raster printing: large text may overflow glyph cache.\n+ *          Draw a large glyphvector, the 'A' glyph should appear and not get flushed.\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.Point2D;\n+import java.awt.image.BufferedImage;\n+import java.util.HashMap;\n+\n+\/**\n+ * Draw a very large glyphvector on a surface.\n+ * If the cache was flushed the first glyph is not rendered.\n+ * Note: the implementation no longer uses glyphs for rendering large text,\n+ * but in principle the test is still useful.\n+ *\/\n+public class CacheFlushTest {\n+\n+    static final int WIDTH = 400, HEIGHT = 600;\n+    static final int FONTSIZE = 250;\n+    static final String TEST = \"ABCDEFGHIJKLMNOP\";\n+    static final HashMap<RenderingHints.Key, Object> HINTS = new HashMap<>();\n+\n+    static {\n+      HINTS.put(RenderingHints.KEY_ANTIALIASING,\n+                RenderingHints.VALUE_ANTIALIAS_ON);\n+      HINTS.put(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+      HINTS.put(RenderingHints.KEY_FRACTIONALMETRICS,\n+                RenderingHints.VALUE_FRACTIONALMETRICS_ON);\n+    }\n+\n+    public static void main(String args[]) {\n+        BufferedImage bi = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);\n+\n+        Graphics2D g2d = bi.createGraphics();\n+        g2d.addRenderingHints(HINTS);\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, WIDTH, HEIGHT);\n+        g2d.setColor(Color.black);\n+\n+        FontRenderContext frc = g2d.getFontRenderContext();\n+        Font font = new Font(Font.DIALOG, Font.PLAIN, 250);\n+        GlyphVector gv = font.createGlyphVector(frc, TEST);\n+\n+        \/* Set the positions of all but the first glyph to be offset vertically but\n+         * FONTSIZE pixels. So if the first glyph \"A\" is not flushed we can tell this\n+         * by checking for non-white pixels in the range for the default y offset of 0\n+         * from the specified y location.\n+         *\/\n+        Point2D.Float pt = new Point2D.Float(20f, FONTSIZE);\n+        for (int i = 1; i < gv.getNumGlyphs(); ++i) {\n+            gv.setGlyphPosition(i, pt);\n+            pt.x += 25f;\n+            pt.y = FONTSIZE;\n+        }\n+        g2d.drawGlyphVector(gv, 20, FONTSIZE);\n+        \/* Now expect to find at least one black pixel in the rect (0,0) -> (WIDTH, FONTSIZE) *\/\n+        boolean found = false;\n+        int blackPixel = Color.black.getRGB();\n+        for (int y = 0; y < FONTSIZE; y++) {\n+            for (int x = 0; x < WIDTH; x++) {\n+                if (bi.getRGB(x, y) == blackPixel) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (found == true) {\n+                break;\n+            }\n+        }\n+        if (!found) {\n+            throw new RuntimeException(\"NO BLACK PIXELS\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/font\/CacheFlushTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4198081\n+ * @key headful\n+ * @summary Arabic characters should appear instead of boxes and be correctly shaped.\n+ *          Hebrew characters should appear instead of boxes.\n+ *          Test is made headful so there's no excuse for test systems not having the fonts.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridLayout;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.Rectangle2D;\n+\n+public class TestArabicHebrew extends Panel {\n+\n+    static volatile Frame frame;\n+    static volatile Font font = new Font(Font.DIALOG, Font.PLAIN, 36);\n+\n+    static void createUI() {\n+        frame = new Frame(\"Test Arabic\/Hebrew\");\n+        frame.setLayout(new BorderLayout());\n+        TestArabicHebrew panel = new TestArabicHebrew();\n+        frame.add(panel, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        EventQueue.invokeAndWait(TestArabicHebrew::createUI);\n+        try {\n+             checkStrings();\n+        } finally {\n+           if (frame != null && args.length == 0) {\n+               EventQueue.invokeAndWait(frame::dispose);\n+           }\n+        }\n+    }\n+\n+    static void checkString(String script, String str) {\n+        int index = font.canDisplayUpTo(str);\n+        if (index != -1) {\n+            throw new RuntimeException(\"Cannot display char \" +  index + \" for \" + script);\n+        }\n+    }\n+\n+    static void checkStrings() {\n+        checkString(\"Arabic\", arabic);\n+        checkString(\"Hebrew\", hebrew);\n+        checkString(\"Latin-1 Supplement\", latin1sup);\n+    }\n+\n+    \/\/ Table of arabic unicode characters - minimal support level\n+    \/\/ Includes arabic chars from basic block up to 0652 and\n+    \/\/ corresponding shaped characters from the arabic\n+    \/\/ extended-B block from fe80 to fefc (does include lam-alef\n+    \/\/ ligatures).\n+    \/\/ Does not include arabic-indic digits nor \"arabic extended\"\n+    \/\/ range.\n+\n+    static final String arabic =\n+    \"\\u060c\\u061b\\u061f\\u0621\\u0622\\u0623\\u0624\\u0625\\u0626\\u0627\"\n+    + \"\\u0628\\u0629\\u062a\\u062b\\u062c\\u062d\\u062e\\u062f\\u0630\\u0631\"\n+    + \"\\u0632\\u0633\\u0634\\u0635\\u0636\\u0637\\u0638\\u0639\\u063a\\u0640\"\n+    + \"\\u0641\\u0642\\u0643\\u0644\\u0645\\u0646\\u0647\\u0648\\u0649\\u064a\"\n+    + \"\\u064b\\u064c\\u064d\\u064e\\u064f\\u0650\\u0651\\u0652\\ufe80\\ufe81\"\n+    + \"\\ufe82\\ufe83\\ufe84\\ufe85\\ufe86\\ufe87\\ufe88\\ufe89\\ufe8a\\ufe8b\"\n+    + \"\\ufe8c\\ufe8d\\ufe8e\\ufe8f\\ufe90\\ufe91\\ufe92\\ufe93\\ufe94\\ufe95\"\n+    + \"\\ufe96\\ufe97\\ufe98\\ufe99\\ufe9a\\ufe9b\\ufe9c\\ufe9d\\ufe9e\\ufe9f\"\n+    + \"\\ufea0\\ufea1\\ufea2\\ufea3\\ufea4\\ufea5\\ufea6\\ufea7\\ufea8\\ufea9\"\n+    + \"\\ufeaa\\ufeab\\ufeac\\ufead\\ufeae\\ufeaf\\ufeb0\\ufeb1\\ufeb2\\ufeb3\"\n+    + \"\\ufeb4\\ufeb5\\ufeb6\\ufeb7\\ufeb8\\ufeb9\\ufeba\\ufebb\\ufebc\\ufebd\"\n+    + \"\\ufebe\\ufebf\\ufec0\\ufec1\\ufec2\\ufec3\\ufec4\\ufec5\\ufec6\\ufec7\"\n+    + \"\\ufec8\\ufec9\\ufeca\\ufecb\\ufecc\\ufecd\\ufece\\ufecf\\ufed0\\ufed1\"\n+    + \"\\ufed2\\ufed3\\ufed4\\ufed5\\ufed6\\ufed7\\ufed8\\ufed9\\ufeda\\ufedb\"\n+    + \"\\ufedc\\ufedd\\ufede\\ufedf\\ufee0\\ufee1\\ufee2\\ufee3\\ufee4\\ufee5\"\n+    + \"\\ufee6\\ufee7\\ufee8\\ufee9\\ufeea\\ufeeb\\ufeec\\ufeed\\ufeee\\ufeef\"\n+    + \"\\ufef0\\ufef1\\ufef2\\ufef3\\ufef4\\ufef5\\ufef6\\ufef7\\ufef8\\ufef9\"\n+    + \"\\ufefa\\ufefb\\ufefc\";\n+\n+    \/\/ hebrew table includes all characters in hebrew block\n+\n+    static final String hebrew =\n+    \"\\u0591\\u0592\\u0593\\u0594\\u0595\\u0596\\u0597\\u0598\\u0599\\u059a\"\n+    + \"\\u059b\\u059c\\u059d\\u059e\\u059f\\u05a0\\u05a1\\u05a3\\u05a4\\u05a5\"\n+    + \"\\u05a6\\u05a7\\u05a8\\u05a9\\u05aa\\u05ab\\u05ac\\u05ad\\u05ae\\u05af\"\n+    + \"\\u05b0\\u05b1\\u05b2\\u05b3\\u05b4\\u05b5\\u05b6\\u05b7\\u05b8\\u05b9\"\n+    + \"\\u05bb\\u05bc\\u05bd\\u05be\\u05bf\\u05c0\\u05c1\\u05c2\\u05c3\\u05c4\"\n+    + \"\\u05d0\\u05d1\\u05d2\\u05d3\\u05d4\\u05d5\\u05d6\\u05d7\\u05d8\\u05d9\"\n+    + \"\\u05da\\u05db\\u05dc\\u05dd\\u05de\\u05df\\u05e0\\u05e1\\u05e2\\u05e3\"\n+    + \"\\u05e4\\u05e5\\u05e6\\u05e7\\u05e8\\u05e9\\u05ea\\u05f0\\u05f1\\u05f2\"\n+    + \"\\u05f3\\u05f4\";\n+\n+    \/\/ latin 1 supplement table includes all non-control characters\n+    \/\/ in this range.  Included because of comment in code that claims\n+    \/\/ some problems displaying this range with some SJIS fonts.\n+\n+    static final String latin1sup =\n+    \"\\u00a0\\u00a1\\u00a2\\u00a3\\u00a4\\u00a5\\u00a6\\u00a7\"\n+    + \"\\u00a8\\u00a9\\u00aa\\u00ab\\u00ac\\u00ad\\u00ae\\u00af\\u00b0\\u00b1\"\n+    + \"\\u00b2\\u00b3\\u00b4\\u00b5\\u00b6\\u00b7\\u00b8\\u00b9\\u00ba\\u00bb\"\n+    + \"\\u00bc\\u00bd\\u00be\\u00bf\\u00c0\\u00c1\\u00c2\\u00c3\\u00c4\\u00c5\"\n+    + \"\\u00c6\\u00c7\\u00c8\\u00c9\\u00ca\\u00cb\\u00cc\\u00cd\\u00ce\\u00cf\"\n+    + \"\\u00d0\\u00d1\\u00d2\\u00d3\\u00d4\\u00d5\\u00d6\\u00d7\\u00d8\\u00d9\"\n+    + \"\\u00da\\u00db\\u00dc\\u00dd\\u00de\\u00df\\u00e0\\u00e1\\u00e2\\u00e3\"\n+    + \"\\u00e4\\u00e5\\u00e6\\u00e7\\u00e8\\u00e9\\u00ea\\u00eb\\u00ec\\u00ed\"\n+    + \"\\u00ee\\u00ef\\u00f0\\u00f1\\u00f2\\u00f3\\u00f4\\u00f5\\u00f6\\u00f7\"\n+    + \"\\u00f8\\u00f9\\u00fa\\u00fb\\u00fc\\u00fd\\u00fe\\u00ff\";\n+\n+    public TestArabicHebrew() {\n+        setLayout(new GridLayout(3, 1));\n+\n+        FontRenderContext frc = new FontRenderContext(null, false, false);\n+        add(new SubGlyphPanel(\"Arabic\", arabic, font, frc));\n+        add(new SubGlyphPanel(\"Hebrew\", hebrew, font, frc));\n+        add(new SubGlyphPanel(\"Latin-1 Supplement\", latin1sup, font, frc));\n+    }\n+\n+  static class SubGlyphPanel extends Panel {\n+      String title;\n+      Dimension extent;\n+      GlyphVector[] vectors;\n+\n+      static final int kGlyphsPerLine = 20;\n+\n+      SubGlyphPanel(String title, String chars, Font font, FontRenderContext frc) {\n+\n+          this.title = title;\n+          setBackground(Color.white);\n+\n+          double width = 0;\n+          double height = 0;\n+\n+          int max = chars.length();\n+          vectors = new GlyphVector[(max + kGlyphsPerLine - 1) \/ kGlyphsPerLine];\n+          for (int i = 0; i < vectors.length; i++) {\n+              int start = i * 20;\n+              int limit = Math.min(max, (i + 1) * kGlyphsPerLine);\n+              String substr = \"\";\n+              for (int j = start; j < limit; ++j) {\n+                  substr = substr.concat(chars.charAt(j) + \" \");\n+              }\n+              GlyphVector gv = font.createGlyphVector(frc, substr);\n+              vectors[i] = gv;\n+              Rectangle2D bounds = gv.getLogicalBounds();\n+\n+              width = Math.max(width, bounds.getWidth());\n+              height += bounds.getHeight();\n+          }\n+\n+          extent = new Dimension((int)(width + 1), (int)(height + 1 + 30)); \/\/ room for title\n+\n+          setSize(getPreferredSize());\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(extent);\n+    }\n+\n+    public Dimension getMinimumSize() {\n+        return getPreferredSize();\n+    }\n+\n+    public Dimension getMaximumSize() {\n+        return getPreferredSize();\n+    }\n+\n+    public void paint(Graphics g) {\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        g.drawString(title, 10, 20);\n+\n+        float x = 10;\n+        float y = 30;\n+        for (int i = 0; i < vectors.length; ++i) {\n+            GlyphVector gv = vectors[i];\n+            Rectangle2D bounds = gv.getLogicalBounds();\n+            g2d.drawGlyphVector(gv, x, (float)(y - bounds.getY()));\n+            y += bounds.getHeight();\n+        }\n+    }\n+  }\n+}\n","filename":"test\/jdk\/sun\/awt\/font\/TestArabicHebrew.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4269775\n+ * @summary Check that different text rendering APIs agree\n+ *\/\n+\n+\/**\n+ * Draw into an image rendering the same text string nine different\n+ * ways: as a TextLayout, a simple String, and a GlyphVector, each\n+ * with three different x scale factors. The expectation is that each\n+ * set of three strings would appear the same although offset in y to\n+ * avoid overlap. The bug was that the y positions of the individual characters\n+ * of the TextLayout and GlyphVector were wrong, so the strings appeared\n+ * to be rendered at different angles.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.font.TextLayout;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.util.HashMap;\n+\n+public class TestDevTransform {\n+\n+    static HashMap<RenderingHints.Key, Object> hints = new HashMap<>();\n+\n+    static {\n+      hints.put(RenderingHints.KEY_ANTIALIASING,\n+                RenderingHints.VALUE_ANTIALIAS_ON);\n+      hints.put(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+      hints.put(RenderingHints.KEY_FRACTIONALMETRICS,\n+                RenderingHints.VALUE_FRACTIONALMETRICS_ON);\n+    }\n+\n+    static String test = \"This is only a test\";\n+    static double angle = Math.PI \/ 6.0;  \/\/ Rotate 30 degrees\n+    static final int W = 400, H = 400;\n+\n+    static void draw(Graphics2D g2d, TextLayout layout,\n+                      float x, float y, float scalex) {\n+        AffineTransform saveTransform = g2d.getTransform();\n+        g2d.translate(x, y);\n+        g2d.rotate(angle);\n+        g2d.scale(scalex, 1f);\n+        layout.draw(g2d, 0f, 0f);\n+        g2d.setTransform(saveTransform);\n+      }\n+\n+    static void draw(Graphics2D g2d, String string,\n+                      float x, float y, float scalex) {\n+      AffineTransform saveTransform = g2d.getTransform();\n+      g2d.translate(x, y);\n+      g2d.rotate(angle);\n+      g2d.scale(scalex, 1f);\n+      g2d.drawString(string, 0f, 0f);\n+      g2d.setTransform(saveTransform);\n+    }\n+\n+    static void draw(Graphics2D g2d, GlyphVector gv,\n+                      float x, float y, float scalex) {\n+        AffineTransform saveTransform = g2d.getTransform();\n+        g2d.translate(x, y);\n+        g2d.rotate(angle);\n+        g2d.scale(scalex, 1f);\n+        g2d.drawGlyphVector(gv, 0f, 0f);\n+        g2d.setTransform(saveTransform);\n+      }\n+\n+    static void init(Graphics2D g2d) {\n+         g2d.setColor(Color.white);\n+         g2d.fillRect(0, 0, W, H);\n+         g2d.setColor(Color.black);\n+         g2d.scale(1.481f, 1.481);   \/\/ Convert to 108 dpi\n+         g2d.addRenderingHints(hints);\n+         Font font = new Font(Font.DIALOG, Font.PLAIN, 12);\n+         g2d.setFont(font);\n+    }\n+\n+    static void compare(BufferedImage bi1, BufferedImage bi2) {\n+        for (int x = 0; x < bi1.getWidth(); x++) {\n+            for (int y = 0; y < bi1.getHeight(); y++) {\n+                if (bi1.getRGB(x, y) != bi2.getRGB(x, y)) {\n+                    throw new RuntimeException(\"Different rendering\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+\n+      BufferedImage tl_Image = new BufferedImage(W, H, BufferedImage.TYPE_INT_RGB);\n+      {\n+          Graphics2D tl_g2d = tl_Image.createGraphics();\n+          init(tl_g2d);\n+          FontRenderContext frc = tl_g2d.getFontRenderContext();\n+          \/\/ Specify font from graphics to be sure it is the same as the other cases.\n+          TextLayout tl = new TextLayout(test, tl_g2d.getFont(), frc);\n+          draw(tl_g2d, tl, 10f, 12f, 3.0f);\n+          draw(tl_g2d, tl, 10f, 24f, 1.0f);\n+          draw(tl_g2d, tl, 10f, 36f, 0.33f);\n+      }\n+\n+      BufferedImage st_Image = new BufferedImage(400, 400, BufferedImage.TYPE_INT_RGB);\n+      {\n+          Graphics2D st_g2d = st_Image.createGraphics();\n+          init(st_g2d);\n+          draw(st_g2d, test, 10f, 12f, 3.0f);\n+          draw(st_g2d, test, 10f, 24f, 1.0f);\n+          draw(st_g2d, test, 10f, 36f, .33f);\n+      }\n+\n+      BufferedImage gv_Image = new BufferedImage(400, 400, BufferedImage.TYPE_INT_RGB);\n+      {\n+          Graphics2D gv_g2d = gv_Image.createGraphics();\n+          init(gv_g2d);\n+          FontRenderContext frc = gv_g2d.getFontRenderContext();\n+          GlyphVector gv = gv_g2d.getFont().createGlyphVector(frc, test);\n+          draw(gv_g2d, gv, 10f, 12f, 3.0f);\n+          draw(gv_g2d, gv, 10f, 24f, 1.0f);\n+          draw(gv_g2d, gv, 10f, 36f, .33f);\n+      }\n+\n+      compare(tl_Image, st_Image);\n+      compare(gv_Image, st_Image);\n+  }\n+}\n","filename":"test\/jdk\/sun\/awt\/font\/TestDevTransform.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4277201\n+ * @summary verifies that invoking a fill on a brand new Graphics object\n+ *          does not stroke the shape in addition to filling it\n+ * @key headful\n+ *\/\n+\n+\/*\n+ * This test case tests for a problem with initializing GDI graphics\n+ * contexts (HDCs) where a pen is left installed in the graphics object\n+ * even though the AWT believes that there is no Pen installed.  The\n+ * result is that when you try to fill a shape, GDI will both fill and\n+ * stroke it.\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+\n+public class TestPen extends Panel {\n+\n+    static volatile TestPen pen;\n+    static volatile Frame frame;\n+\n+    public TestPen() {\n+        setForeground(Color.black);\n+        setBackground(Color.white);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(200, 200);\n+    }\n+\n+    public void paint(Graphics g) {\n+        g.setColor(Color.green);\n+        g.fillOval(50, 50, 100, 100);\n+    }\n+\n+   static void createUI() {\n+        frame = new Frame();\n+        pen = new TestPen();\n+        frame.add(pen);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String argv[]) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(TestPen::createUI);\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+            robot.delay(2000);\n+            Point p = pen.getLocationOnScreen();\n+            Dimension d = pen.getSize();\n+            Rectangle r = new Rectangle(p.x + 1, p.y + 1, d.width - 2, d.height - 2);\n+            BufferedImage bi = robot.createScreenCapture(r);\n+            int blackPixel = Color.black.getRGB();\n+            for (int y = 0; y < bi.getHeight(); y++ ) {\n+                for (int x = 0; x < bi.getWidth(); x++ ) {\n+                    if (bi.getRGB(x, y) == blackPixel) {\n+                        throw new RuntimeException(\"Black pixel !\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/windows\/TestPen.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -22,1 +22,0 @@\n- *\n@@ -25,1 +24,1 @@\n-\/**\n+\/*\n@@ -32,1 +31,1 @@\n- *      8321408 8316138\n+ *      8321408 8316138 8341057\n@@ -51,1 +50,1 @@\n-    private static final int COUNT = 110;\n+    private static final int COUNT = 112;\n@@ -56,1 +55,1 @@\n-            = \"BD:80:65:81:68:E5:6C:51:64:ED:B9:08:53:9F:BB:2F:D9:6C:5D:D4:06:D4:16:59:39:10:8E:F8:24:81:8B:78\";\n+            = \"21:68:E7:16:5B:94:23:D2:60:5C:BB:F2:AF:C1:66:5C:EC:36:BC:20:FF:5C:54:AF:91:D1:2C:38:AE:55:D3:27\";\n@@ -285,0 +284,4 @@\n+            put(\"ssltlsrootecc2022 [jdk]\",\n+                    \"C3:2F:FD:9F:46:F9:36:D1:6C:36:73:99:09:59:43:4B:9A:D6:0A:AF:BB:9E:7C:F3:36:54:F1:44:CC:1B:A1:43\");\n+            put(\"ssltlsrootrsa2022 [jdk]\",\n+                    \"8F:AF:7D:2E:2C:B4:70:9B:B8:E0:B3:36:66:BF:75:A5:DD:45:B5:DE:48:0F:8E:A8:D4:BF:E6:BE:BC:17:F2:ED\");\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,249 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.math.BigInteger;\n-import java.security.*;\n-import java.security.cert.*;\n-import java.time.*;\n-import java.util.*;\n-import javax.net.ssl.*;\n-import sun.security.validator.Validator;\n-import sun.security.validator.ValidatorException;\n-\n-import jdk.test.lib.security.SecurityUtils;\n-\n-\/**\n- * @test\n- * @bug 8337664\n- * @summary Check that TLS Server certificates chaining back to distrusted\n- *          Entrust roots are invalid\n- * @library \/test\/lib\n- * @modules java.base\/sun.security.validator\n- * @run main\/othervm Distrust after policyOn invalid\n- * @run main\/othervm Distrust after policyOff valid\n- * @run main\/othervm Distrust before policyOn valid\n- * @run main\/othervm Distrust before policyOff valid\n- *\/\n-\n-public class Distrust {\n-\n-    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n-    private static CertificateFactory cf;\n-\n-    \/\/ Each of the roots have a test certificate chain stored in a file\n-    \/\/ named \"<root>-chain.pem\".\n-    private static String[] rootsToTest = new String[] {\n-        \"entrustevca\", \"entrustrootcaec1\", \"entrustrootcag2\", \"entrustrootcag4\",\n-        \"entrust2048ca\", \"affirmtrustcommercialca\", \"affirmtrustnetworkingca\",\n-        \"affirmtrustpremiumca\", \"affirmtrustpremiumeccca\" };\n-\n-    \/\/ A date that is after the restrictions take effect\n-    private static final Date NOVEMBER_1_2024 =\n-        Date.from(LocalDate.of(2024, 11, 1)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .toInstant());\n-\n-    \/\/ A date that is a second before the restrictions take effect\n-    private static final Date BEFORE_NOVEMBER_1_2024 =\n-        Date.from(LocalDate.of(2024, 11, 1)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .minusSeconds(1)\n-                           .toInstant());\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        boolean before = args[0].equals(\"before\");\n-        boolean policyOn = args[1].equals(\"policyOn\");\n-        boolean isValid = args[2].equals(\"valid\");\n-\n-        if (!policyOn) {\n-            \/\/ disable policy (default is on)\n-            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n-        }\n-\n-        Date notBefore = before ? BEFORE_NOVEMBER_1_2024 : NOVEMBER_1_2024;\n-\n-        X509TrustManager pkixTM = getTMF(\"PKIX\", null);\n-        X509TrustManager sunX509TM = getTMF(\"SunX509\", null);\n-        for (String test : rootsToTest) {\n-            System.err.println(\"Testing \" + test);\n-            X509Certificate[] chain = loadCertificateChain(test);\n-\n-            testTM(sunX509TM, chain, notBefore, isValid);\n-            testTM(pkixTM, chain, notBefore, isValid);\n-        }\n-    }\n-\n-    private static X509TrustManager getTMF(String type,\n-            PKIXBuilderParameters params) throws Exception {\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n-        if (params == null) {\n-            tmf.init((KeyStore)null);\n-        } else {\n-            tmf.init(new CertPathTrustManagerParameters(params));\n-        }\n-        TrustManager[] tms = tmf.getTrustManagers();\n-        for (TrustManager tm : tms) {\n-            X509TrustManager xtm = (X509TrustManager)tm;\n-            return xtm;\n-        }\n-        throw new Exception(\"No TrustManager for \" + type);\n-    }\n-\n-    private static PKIXBuilderParameters getParams() throws Exception {\n-        PKIXBuilderParameters pbp =\n-            new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n-                                      new X509CertSelector());\n-        pbp.setRevocationEnabled(false);\n-        return pbp;\n-    }\n-\n-    private static void testTM(X509TrustManager xtm, X509Certificate[] chain,\n-                               Date notBefore, boolean valid) throws Exception {\n-        \/\/ Check if TLS Server certificate (the first element of the chain)\n-        \/\/ is issued after the specified notBefore date (should be rejected\n-        \/\/ unless distrust property is false). To do this, we need to\n-        \/\/ fake the notBefore date since none of the test certs are issued\n-        \/\/ after then.\n-        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n-\n-        try {\n-            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n-            if (!valid) {\n-                throw new Exception(\"chain should be invalid\");\n-            }\n-        } catch (CertificateException ce) {\n-            \/\/ expired TLS certificates should not be treated as failure\n-            if (expired(ce)) {\n-                System.err.println(\"Test is N\/A, chain is expired\");\n-                return;\n-            }\n-            if (valid) {\n-                throw new Exception(\"Unexpected exception, chain \" +\n-                                    \"should be valid\", ce);\n-            }\n-            if (ce instanceof ValidatorException) {\n-                ValidatorException ve = (ValidatorException)ce;\n-                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n-                    ce.printStackTrace(System.err);\n-                    throw new Exception(\"Unexpected exception: \" + ce);\n-                }\n-            } else {\n-                throw new Exception(\"Unexpected exception: \" + ce);\n-            }\n-        }\n-    }\n-\n-    \/\/ check if a cause of exception is an expired cert\n-    private static boolean expired(CertificateException ce) {\n-        if (ce instanceof CertificateExpiredException) {\n-            return true;\n-        }\n-        Throwable t = ce.getCause();\n-        while (t != null) {\n-            if (t instanceof CertificateExpiredException) {\n-                return true;\n-            }\n-            t = t.getCause();\n-        }\n-        return false;\n-    }\n-\n-    private static X509Certificate[] loadCertificateChain(String name)\n-            throws Exception {\n-        try (InputStream in = new FileInputStream(TEST_SRC + File.separator +\n-                                                  name + \"-chain.pem\")) {\n-            Collection<X509Certificate> certs =\n-                (Collection<X509Certificate>)cf.generateCertificates(in);\n-            return certs.toArray(new X509Certificate[0]);\n-        }\n-    }\n-\n-    private static class DistrustedTLSServerCert extends X509Certificate {\n-        private final X509Certificate cert;\n-        private final Date notBefore;\n-        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n-            this.cert = cert;\n-            this.notBefore = notBefore;\n-        }\n-        public Set<String> getCriticalExtensionOIDs() {\n-           return cert.getCriticalExtensionOIDs();\n-        }\n-        public byte[] getExtensionValue(String oid) {\n-            return cert.getExtensionValue(oid);\n-        }\n-        public Set<String> getNonCriticalExtensionOIDs() {\n-            return cert.getNonCriticalExtensionOIDs();\n-        }\n-        public boolean hasUnsupportedCriticalExtension() {\n-            return cert.hasUnsupportedCriticalExtension();\n-        }\n-        public void checkValidity() throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public void checkValidity(Date date) throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public int getVersion() { return cert.getVersion(); }\n-        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n-        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n-        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n-        public Date getNotBefore() { return notBefore; }\n-        public Date getNotAfter() { return cert.getNotAfter(); }\n-        public byte[] getTBSCertificate() throws CertificateEncodingException {\n-            return cert.getTBSCertificate();\n-        }\n-        public byte[] getSignature() { return cert.getSignature(); }\n-        public String getSigAlgName() { return cert.getSigAlgName(); }\n-        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n-        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n-        public boolean[] getIssuerUniqueID() {\n-            return cert.getIssuerUniqueID();\n-        }\n-        public boolean[] getSubjectUniqueID() {\n-            return cert.getSubjectUniqueID();\n-        }\n-        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n-        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n-        public byte[] getEncoded() throws CertificateEncodingException {\n-            return cert.getEncoded();\n-        }\n-        public void verify(PublicKey key) throws CertificateException,\n-            InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key);\n-        }\n-        public void verify(PublicKey key, String sigProvider) throws\n-            CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key, sigProvider);\n-        }\n-        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n-        public String toString() { return cert.toString(); }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/Distrust.java","additions":0,"deletions":249,"binary":false,"changes":249,"status":"deleted"},{"patch":"@@ -1,292 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.math.BigInteger;\n-import java.security.*;\n-import java.security.cert.*;\n-import java.time.*;\n-import java.util.*;\n-import javax.net.ssl.*;\n-import sun.security.validator.Validator;\n-import sun.security.validator.ValidatorException;\n-\n-import jdk.test.lib.security.SecurityUtils;\n-\n-\/**\n- * @test\n- * @bug 8207258 8216280\n- * @summary Check that TLS Server certificates chaining back to distrusted\n- *          Symantec roots are invalid\n- * @library \/test\/lib\n- * @modules java.base\/sun.security.validator\n- * @run main\/othervm Distrust after policyOn invalid\n- * @run main\/othervm Distrust after policyOff valid\n- * @run main\/othervm Distrust before policyOn valid\n- * @run main\/othervm Distrust before policyOff valid\n- *\/\n-\n-public class Distrust {\n-\n-    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n-    private static CertificateFactory cf;\n-\n-    \/\/ Each of the roots have a test certificate chain stored in a file\n-    \/\/ named \"<root>-chain.pem\".\n-    private static String[] rootsToTest = new String[] {\n-        \"geotrustprimarycag2\", \"geotrustprimarycag3\",\n-        \"geotrustuniversalca\", \"thawteprimaryrootca\", \"thawteprimaryrootcag2\",\n-        \"thawteprimaryrootcag3\", \"verisignclass3g3ca\", \"verisignclass3g4ca\",\n-        \"verisignclass3g5ca\", \"verisignuniversalrootca\" };\n-\n-    \/\/ Each of the subCAs with a delayed distrust date have a test certificate\n-    \/\/ chain stored in a file named \"<subCA>-chain.pem\".\n-    private static String[] subCAsToTest = new String[]{\"appleistca8g1\"};\n-\n-    \/\/ A date that is after the restrictions take affect\n-    private static final Date APRIL_17_2019 =\n-        Date.from(LocalDate.of(2019, 4, 17)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .toInstant());\n-\n-    \/\/ A date that is a second before the restrictions take affect\n-    private static final Date BEFORE_APRIL_17_2019 =\n-        Date.from(LocalDate.of(2019, 4, 17)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .minusSeconds(1)\n-                           .toInstant());\n-\n-    \/\/ A date that is after the subCA restrictions take affect\n-    private static final Date JANUARY_1_2020 =\n-        Date.from(LocalDate.of(2020, 1, 1)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .toInstant());\n-\n-    \/\/ A date that is a second before the subCA restrictions take affect\n-    private static final Date BEFORE_JANUARY_1_2020 =\n-        Date.from(LocalDate.of(2020, 1, 1)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .minusSeconds(1)\n-                           .toInstant());\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        boolean before = args[0].equals(\"before\");\n-        boolean policyOn = args[1].equals(\"policyOn\");\n-        boolean isValid = args[2].equals(\"valid\");\n-\n-        if (!policyOn) {\n-            \/\/ disable policy (default is on)\n-            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n-        }\n-\n-        Date notBefore = before ? BEFORE_APRIL_17_2019 : APRIL_17_2019;\n-\n-        X509TrustManager pkixTM = getTMF(\"PKIX\", null);\n-        X509TrustManager sunX509TM = getTMF(\"SunX509\", null);\n-        for (String test : rootsToTest) {\n-            System.err.println(\"Testing \" + test);\n-            X509Certificate[] chain = loadCertificateChain(test);\n-\n-            testTM(sunX509TM, chain, notBefore, isValid);\n-            testTM(pkixTM, chain, notBefore, isValid);\n-        }\n-\n-        \/\/ test chain if params are passed to TrustManager\n-        System.err.println(\"Testing verisignuniversalrootca with params\");\n-        testTM(getTMF(\"PKIX\", getParams()),\n-               loadCertificateChain(\"verisignuniversalrootca\"),\n-               notBefore, isValid);\n-\n-        \/\/ test code-signing chain (should be valid as restrictions don't apply)\n-        System.err.println(\"Testing verisignclass3g5ca code-signing chain\");\n-        Validator v = Validator.getInstance(Validator.TYPE_PKIX,\n-                                            Validator.VAR_CODE_SIGNING,\n-                                            getParams());\n-        \/\/ set validation date so this will still pass when cert expires\n-        v.setValidationDate(new Date(1544197375493l));\n-        v.validate(loadCertificateChain(\"verisignclass3g5ca-codesigning\"));\n-\n-        \/\/ test chains issued through subCAs\n-        notBefore = before ? BEFORE_JANUARY_1_2020 : JANUARY_1_2020;\n-        for (String test : subCAsToTest) {\n-            System.err.println(\"Testing \" + test);\n-            X509Certificate[] chain = loadCertificateChain(test);\n-\n-            testTM(sunX509TM, chain, notBefore, isValid);\n-            testTM(pkixTM, chain, notBefore, isValid);\n-        }\n-    }\n-\n-    private static X509TrustManager getTMF(String type,\n-            PKIXBuilderParameters params) throws Exception {\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n-        if (params == null) {\n-            tmf.init((KeyStore)null);\n-        } else {\n-            tmf.init(new CertPathTrustManagerParameters(params));\n-        }\n-        TrustManager[] tms = tmf.getTrustManagers();\n-        for (TrustManager tm : tms) {\n-            X509TrustManager xtm = (X509TrustManager)tm;\n-            return xtm;\n-        }\n-        throw new Exception(\"No TrustManager for \" + type);\n-    }\n-\n-    private static PKIXBuilderParameters getParams() throws Exception {\n-        PKIXBuilderParameters pbp =\n-            new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n-                                      new X509CertSelector());\n-        pbp.setRevocationEnabled(false);\n-        return pbp;\n-    }\n-\n-    private static void testTM(X509TrustManager xtm, X509Certificate[] chain,\n-                               Date notBefore, boolean valid) throws Exception {\n-        \/\/ Check if TLS Server certificate (the first element of the chain)\n-        \/\/ is issued after the specified notBefore date (should be rejected\n-        \/\/ unless distrust property is false). To do this, we need to\n-        \/\/ fake the notBefore date since none of the test certs are issued\n-        \/\/ after then.\n-        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n-\n-        try {\n-            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n-            if (!valid) {\n-                throw new Exception(\"chain should be invalid\");\n-            }\n-        } catch (CertificateException ce) {\n-            \/\/ expired TLS certificates should not be treated as failure\n-            if (expired(ce)) {\n-                System.err.println(\"Test is N\/A, chain is expired\");\n-                return;\n-            }\n-            if (valid) {\n-                throw new Exception(\"Unexpected exception, chain \" +\n-                                    \"should be valid\", ce);\n-            }\n-            if (ce instanceof ValidatorException) {\n-                ValidatorException ve = (ValidatorException)ce;\n-                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n-                    ce.printStackTrace(System.err);\n-                    throw new Exception(\"Unexpected exception: \" + ce);\n-                }\n-            } else {\n-                throw new Exception(\"Unexpected exception: \" + ce);\n-            }\n-        }\n-    }\n-\n-    \/\/ check if a cause of exception is an expired cert\n-    private static boolean expired(CertificateException ce) {\n-        if (ce instanceof CertificateExpiredException) {\n-            return true;\n-        }\n-        Throwable t = ce.getCause();\n-        while (t != null) {\n-            if (t instanceof CertificateExpiredException) {\n-                return true;\n-            }\n-            t = t.getCause();\n-        }\n-        return false;\n-    }\n-\n-    private static X509Certificate[] loadCertificateChain(String name)\n-            throws Exception {\n-        try (InputStream in = new FileInputStream(TEST_SRC + File.separator +\n-                                                  name + \"-chain.pem\")) {\n-            Collection<X509Certificate> certs =\n-                (Collection<X509Certificate>)cf.generateCertificates(in);\n-            return certs.toArray(new X509Certificate[0]);\n-        }\n-    }\n-\n-    private static class DistrustedTLSServerCert extends X509Certificate {\n-        private final X509Certificate cert;\n-        private final Date notBefore;\n-        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n-            this.cert = cert;\n-            this.notBefore = notBefore;\n-        }\n-        public Set<String> getCriticalExtensionOIDs() {\n-           return cert.getCriticalExtensionOIDs();\n-        }\n-        public byte[] getExtensionValue(String oid) {\n-            return cert.getExtensionValue(oid);\n-        }\n-        public Set<String> getNonCriticalExtensionOIDs() {\n-            return cert.getNonCriticalExtensionOIDs();\n-        }\n-        public boolean hasUnsupportedCriticalExtension() {\n-            return cert.hasUnsupportedCriticalExtension();\n-        }\n-        public void checkValidity() throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public void checkValidity(Date date) throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public int getVersion() { return cert.getVersion(); }\n-        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n-        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n-        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n-        public Date getNotBefore() { return notBefore; }\n-        public Date getNotAfter() { return cert.getNotAfter(); }\n-        public byte[] getTBSCertificate() throws CertificateEncodingException {\n-            return cert.getTBSCertificate();\n-        }\n-        public byte[] getSignature() { return cert.getSignature(); }\n-        public String getSigAlgName() { return cert.getSigAlgName(); }\n-        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n-        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n-        public boolean[] getIssuerUniqueID() {\n-            return cert.getIssuerUniqueID();\n-        }\n-        public boolean[] getSubjectUniqueID() {\n-            return cert.getSubjectUniqueID();\n-        }\n-        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n-        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n-        public byte[] getEncoded() throws CertificateEncodingException {\n-            return cert.getEncoded();\n-        }\n-        public void verify(PublicKey key) throws CertificateException,\n-            InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key);\n-        }\n-        public void verify(PublicKey key, String sigProvider) throws\n-            CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key, sigProvider);\n-        }\n-        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n-        public String toString() { return cert.toString(); }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/Distrust.java","additions":0,"deletions":292,"binary":false,"changes":292,"status":"deleted"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.cert.*;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import javax.net.ssl.*;\n+import sun.security.validator.Validator;\n+import sun.security.validator.ValidatorException;\n+\n+import jdk.test.lib.security.SecurityUtils;\n+\n+\/**\n+ * Helper class that provides methods to facilitate testing of distrusted roots.\n+ *\/\n+public final class Distrust {\n+\n+    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n+    private static CertificateFactory cf;\n+\n+    private final boolean before;\n+    private final boolean policyOn;\n+    private final boolean isValid;\n+\n+    public Distrust(String[] args) {\n+        before = args[0].equals(\"before\");\n+        policyOn = args[1].equals(\"policyOn\");\n+        isValid = args[2].equals(\"valid\");\n+\n+        if (!policyOn) {\n+            \/\/ disable policy (default is on)\n+            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n+        }\n+    }\n+\n+    public Date getNotBefore(ZonedDateTime distrustDate) {\n+        ZonedDateTime notBefore = before ? distrustDate.minusSeconds(1) : distrustDate;\n+        return Date.from(notBefore.toInstant());\n+    }\n+\n+    public void testCodeSigningChain(String certPath, String name, Date validationDate)\n+            throws Exception {\n+        System.err.println(\"Testing \" + name + \" code-signing chain\");\n+        Validator v = Validator.getInstance(Validator.TYPE_PKIX,\n+                Validator.VAR_CODE_SIGNING,\n+                getParams());\n+        \/\/ set validation date so this will still pass when cert expires\n+        v.setValidationDate(validationDate);\n+        v.validate(loadCertificateChain(certPath, name));\n+    }\n+\n+    public void testCertificateChain(String certPath, Date notBefore, X509TrustManager[] tms,\n+                                     String... tests) throws Exception {\n+        for (String test : tests) {\n+            System.err.println(\"Testing \" + test);\n+            X509Certificate[] chain = loadCertificateChain(certPath, test);\n+\n+            for (X509TrustManager tm : tms) {\n+                testTM(tm, chain, notBefore, isValid);\n+            }\n+        }\n+    }\n+\n+    public X509TrustManager getTMF(String type, PKIXBuilderParameters params) throws Exception {\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n+        if (params == null) {\n+            tmf.init((KeyStore) null);\n+        } else {\n+            tmf.init(new CertPathTrustManagerParameters(params));\n+        }\n+        TrustManager[] tms = tmf.getTrustManagers();\n+        for (TrustManager tm : tms) {\n+            return (X509TrustManager) tm;\n+        }\n+        throw new RuntimeException(\"No TrustManager for \" + type);\n+    }\n+\n+    public PKIXBuilderParameters getParams() throws Exception {\n+        PKIXBuilderParameters pbp =\n+                new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n+                        new X509CertSelector());\n+        pbp.setRevocationEnabled(false);\n+        return pbp;\n+    }\n+\n+    public void testTM(X509TrustManager xtm, X509Certificate[] chain,\n+                              Date notBefore, boolean valid) {\n+        \/\/ Check if TLS Server certificate (the first element of the chain)\n+        \/\/ is issued after the specified notBefore date (should be rejected\n+        \/\/ unless distrust property is false). To do this, we need to\n+        \/\/ fake the notBefore date since none of the test certs are issued\n+        \/\/ after then.\n+        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n+\n+        \/\/ Wrap the intermediate and root CA certs in NonExpiringTLSServerCert\n+        \/\/ so it will never throw a CertificateExpiredException\n+        for (int i = 1; i < chain.length; i++) {\n+            chain[i] = new NonExpiringTLSServerCert(chain[i]);\n+        }\n+\n+        try {\n+            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n+            if (!valid) {\n+                throw new RuntimeException(\"chain should be invalid\");\n+            }\n+        } catch (CertificateException ce) {\n+            if (valid) {\n+                throw new RuntimeException(\"Unexpected exception, chain \" +\n+                        \"should be valid\", ce);\n+            }\n+            if (ce instanceof ValidatorException) {\n+                ValidatorException ve = (ValidatorException) ce;\n+                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n+                    ce.printStackTrace(System.err);\n+                    throw new RuntimeException(\"Unexpected exception: \" + ce);\n+                }\n+            } else {\n+                throw new RuntimeException(ce);\n+            }\n+        }\n+    }\n+\n+    private X509Certificate[] loadCertificateChain(String certPath, String name)\n+            throws Exception {\n+        if (cf == null) {\n+            cf = CertificateFactory.getInstance(\"X.509\");\n+        }\n+        try (InputStream in = new FileInputStream(TEST_SRC + File.separator + certPath +\n+                File.separator + name + \"-chain.pem\")) {\n+            Collection<X509Certificate> certs =\n+                    (Collection<X509Certificate>) cf.generateCertificates(in);\n+            return certs.toArray(new X509Certificate[0]);\n+        }\n+    }\n+\n+    private static class NonExpiringTLSServerCert extends X509Certificate {\n+        private final X509Certificate cert;\n+        NonExpiringTLSServerCert(X509Certificate cert) {\n+            this.cert = cert;\n+        }\n+        public Set<String> getCriticalExtensionOIDs() {\n+            return cert.getCriticalExtensionOIDs();\n+        }\n+        public byte[] getExtensionValue(String oid) {\n+            return cert.getExtensionValue(oid);\n+        }\n+        public Set<String> getNonCriticalExtensionOIDs() {\n+            return cert.getNonCriticalExtensionOIDs();\n+        }\n+        public boolean hasUnsupportedCriticalExtension() {\n+            return cert.hasUnsupportedCriticalExtension();\n+        }\n+        public void checkValidity() {\n+            \/\/ always pass\n+        }\n+        public void checkValidity(Date date) {\n+            \/\/ always pass\n+        }\n+        public int getVersion() { return cert.getVersion(); }\n+        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n+        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n+        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n+        public Date getNotBefore() { return cert.getNotBefore(); }\n+        public Date getNotAfter() { return cert.getNotAfter(); }\n+        public byte[] getTBSCertificate() throws CertificateEncodingException {\n+            return cert.getTBSCertificate();\n+        }\n+        public byte[] getSignature() { return cert.getSignature(); }\n+        public String getSigAlgName() { return cert.getSigAlgName(); }\n+        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n+        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n+        public boolean[] getIssuerUniqueID() {\n+            return cert.getIssuerUniqueID();\n+        }\n+        public boolean[] getSubjectUniqueID() {\n+            return cert.getSubjectUniqueID();\n+        }\n+        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n+        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n+        public byte[] getEncoded() throws CertificateEncodingException {\n+            return cert.getEncoded();\n+        }\n+        public void verify(PublicKey key) throws CertificateException,\n+                InvalidKeyException, NoSuchAlgorithmException,\n+                NoSuchProviderException, SignatureException {\n+            cert.verify(key);\n+        }\n+        public void verify(PublicKey key, String sigProvider) throws\n+                CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n+                NoSuchProviderException, SignatureException {\n+            cert.verify(key, sigProvider);\n+        }\n+        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n+        public String toString() { return cert.toString(); }\n+    }\n+\n+    private static class DistrustedTLSServerCert extends NonExpiringTLSServerCert {\n+        private final Date notBefore;\n+        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n+            super(cert);\n+            this.notBefore = notBefore;\n+        }\n+        public Date getNotBefore() { return notBefore; }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Distrust.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.time.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+\/**\n+ * @test\n+ * @bug 8337664 8341059\n+ * @summary Check that TLS Server certificates chaining back to distrusted\n+ *          Entrust roots are invalid\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.validator\n+ * @run main\/othervm Entrust after policyOn invalid\n+ * @run main\/othervm Entrust after policyOff valid\n+ * @run main\/othervm Entrust before policyOn valid\n+ * @run main\/othervm Entrust before policyOff valid\n+ *\/\n+\n+public class Entrust {\n+\n+    private static final String certPath = \"chains\" + File.separator + \"entrust\";\n+\n+    \/\/ Each of the roots have a test certificate chain stored in a file\n+    \/\/ named \"<root>-chain.pem\".\n+    private static String[] rootsToTest = new String[]{\n+            \"entrustevca\", \"entrustrootcaec1\", \"entrustrootcag2\", \"entrustrootcag4\",\n+            \"entrust2048ca\", \"affirmtrustcommercialca\", \"affirmtrustnetworkingca\",\n+            \"affirmtrustpremiumca\", \"affirmtrustpremiumeccca\"};\n+\n+    \/\/ Date when the restrictions take effect\n+    private static final ZonedDateTime DISTRUST_DATE =\n+            LocalDate.of(2024, 11, 12).atStartOfDay(ZoneOffset.UTC);\n+\n+    public static void main(String[] args) throws Exception {\n+        Distrust distrust = new Distrust(args);\n+\n+        X509TrustManager[] tms = new X509TrustManager[]{\n+                distrust.getTMF(\"PKIX\", null),\n+                distrust.getTMF(\"SunX509\", null)\n+        };\n+\n+        Date notBefore = distrust.getNotBefore(DISTRUST_DATE);\n+        distrust.testCertificateChain(certPath, notBefore, tms, rootsToTest);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Entrust.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ssl.X509TrustManager;\n+import java.io.File;\n+import java.time.*;\n+import java.util.*;\n+\n+\n+\/**\n+ * @test\n+ * @bug 8207258 8216280\n+ * @summary Check that TLS Server certificates chaining back to distrusted\n+ *          Symantec roots are invalid\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.validator\n+ * @run main\/othervm Symantec after policyOn invalid\n+ * @run main\/othervm Symantec after policyOff valid\n+ * @run main\/othervm Symantec before policyOn valid\n+ * @run main\/othervm Symantec before policyOff valid\n+ *\/\n+\n+public class Symantec {\n+\n+    private static final String certPath = \"chains\" + File.separator + \"symantec\";\n+\n+    \/\/ Each of the roots have a test certificate chain stored in a file\n+    \/\/ named \"<root>-chain.pem\".\n+    private static final String[] rootsToTest = new String[]{\n+            \"geotrustprimarycag2\", \"geotrustprimarycag3\", \"geotrustuniversalca\",\n+            \"thawteprimaryrootca\", \"thawteprimaryrootcag2\", \"thawteprimaryrootcag3\",\n+            \"verisignclass3g3ca\", \"verisignclass3g4ca\", \"verisignclass3g5ca\",\n+            \"verisignuniversalrootca\"\n+    };\n+\n+    \/\/ Each of the subCAs with a delayed distrust date have a test certificate\n+    \/\/ chain stored in a file named \"<subCA>-chain.pem\".\n+    private static String[] subCAsToTest = new String[]{\"appleistca8g1\"};\n+\n+    \/\/ Date when the restrictions take effect\n+    private static final ZonedDateTime ROOTS_DISTRUST_DATE =\n+            LocalDate.of(2019, 4, 17).atStartOfDay(ZoneOffset.UTC);\n+\n+    \/\/ Date when the subCA restrictions take effect\n+    private static final ZonedDateTime SUBCA_DISTRUST_DATE =\n+            LocalDate.of(2020, 1, 1).atStartOfDay(ZoneOffset.UTC);\n+\n+    public static void main(String[] args) throws Exception {\n+        Distrust distrust = new Distrust(args);\n+        X509TrustManager[] tms = new X509TrustManager[]{\n+                distrust.getTMF(\"PKIX\", null),\n+                distrust.getTMF(\"SunX509\", null)\n+        };\n+\n+        \/\/ test chains issued through roots\n+        Date notBefore = distrust.getNotBefore(ROOTS_DISTRUST_DATE);\n+        distrust.testCertificateChain(certPath, notBefore, tms, rootsToTest);\n+\n+        \/\/ test chain if params are passed to TrustManager\n+        System.err.println(\"Testing verisignuniversalrootca with params\");\n+        X509TrustManager[] tmsParams = new X509TrustManager[]{\n+                distrust.getTMF(\"PKIX\", distrust.getParams())\n+        };\n+        distrust.testCertificateChain(certPath, notBefore, tmsParams,\n+                \"verisignuniversalrootca\");\n+\n+        \/\/ test code-signing chain (should be valid as restrictions don't apply)\n+        Date validationDate = new Date(1544197375493L);\n+        distrust.testCodeSigningChain(certPath, \"verisignclass3g5ca-codesigning\", validationDate);\n+\n+        \/\/ test chains issued through subCAs\n+        notBefore = distrust.getNotBefore(SUBCA_DISTRUST_DATE);\n+        distrust.testCertificateChain(certPath, notBefore, tms, subCAsToTest);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Symantec.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustcommercialca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustcommercialca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustnetworkingca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustnetworkingca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustpremiumca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustpremiumca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustpremiumeccca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustpremiumeccca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrust2048ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrust2048ca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustevca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustevca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustrootcaec1-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcaec1-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustrootcag2-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcag2-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustrootcag4-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcag4-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/appleistca8g1-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/appleistca8g1-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/geotrustprimarycag2-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/geotrustprimarycag2-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/geotrustprimarycag3-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/geotrustprimarycag3-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/geotrustuniversalca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/geotrustuniversalca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/thawteprimaryrootca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/thawteprimaryrootca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/thawteprimaryrootcag2-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/thawteprimaryrootcag2-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/thawteprimaryrootcag3-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/thawteprimaryrootcag3-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g3ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g3ca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g4ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g4ca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g5ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g5ca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g5ca-codesigning-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g5ca-codesigning-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignuniversalrootca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignuniversalrootca-chain.pem","status":"renamed"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8309841\n+ * @summary Jarsigner should print a warning if an entry is removed\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.util.JarUtils;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+public class RemovedFiles {\n+\n+    private static final String NONEXISTENT_ENTRIES_FOUND\n+            = \"This jar contains signed entries for files that do not exist. See the -verbose output for more details.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        JarUtils.createJarFile(\n+                Path.of(\"a.jar\"),\n+                Path.of(\".\"),\n+                Files.writeString(Path.of(\"a\"), \"a\"),\n+                Files.writeString(Path.of(\"b\"), \"b\"));\n+        SecurityTools.keytool(\"-genkeypair -storepass changeit -keystore ks -alias x -dname CN=x -keyalg ed25519\");\n+        SecurityTools.jarsigner(\"-storepass changeit -keystore ks a.jar x\");\n+\n+        \/\/ All is fine at the beginning.\n+        SecurityTools.jarsigner(\"-verify a.jar\")\n+                .shouldNotContain(NONEXISTENT_ENTRIES_FOUND);\n+\n+        \/\/ Remove an entry after signing. There will be a warning.\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"a\");\n+        SecurityTools.jarsigner(\"-verify a.jar\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND);\n+        SecurityTools.jarsigner(\"-verify -verbose a.jar\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND)\n+                .shouldContain(\"Warning: nonexistent signed entries: [a]\");\n+\n+        \/\/ Remove one more entry.\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"b\");\n+        SecurityTools.jarsigner(\"-verify a.jar\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND);\n+        SecurityTools.jarsigner(\"-verify -verbose a.jar\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND)\n+                .shouldContain(\"Warning: nonexistent signed entries: [a, b]\");\n+\n+        \/\/ Re-sign will not clear the warning.\n+        SecurityTools.jarsigner(\"-storepass changeit -keystore ks a.jar x\");\n+        SecurityTools.jarsigner(\"-verify a.jar\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND);\n+\n+        \/\/ Unfortunately, if there is a non-file entry in manifest, there will be\n+        \/\/ a false alarm. See https:\/\/bugs.openjdk.org\/browse\/JDK-8334261.\n+        var man = new Manifest();\n+        man.getMainAttributes().putValue(\"Manifest-Version\", \"1.0\");\n+        man.getEntries().computeIfAbsent(\"Hello\", _ -> new Attributes())\n+                .putValue(\"Foo\", \"Bar\");\n+        JarUtils.createJarFile(Path.of(\"b.jar\"),\n+                man,\n+                Path.of(\".\"),\n+                Path.of(\"a\"));\n+        SecurityTools.jarsigner(\"-storepass changeit -keystore ks b.jar x\");\n+        SecurityTools.jarsigner(\"-verbose -verify b.jar\")\n+                .shouldContain(\"Warning: nonexistent signed entries: [Hello]\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND);\n+\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/RemovedFiles.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -131,2 +131,1 @@\n-        \/\/ vm.libgraal.enabled is true if libgraal is used as JIT\n-        map.put(\"vm.libgraal.enabled\", this::isLibgraalEnabled);\n+        map.put(\"vm.libgraal.jit\", this::isLibgraalJIT);\n@@ -563,2 +562,2 @@\n-    protected String isLibgraalEnabled() {\n-        return \"\" + Compiler.isLibgraalEnabled();\n+    protected String isLibgraalJIT() {\n+        return \"\" + Compiler.isLibgraalJIT();\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325090\n+ * @summary javadoc fails when -subpackages option is used with non-modular -source\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.api\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @library \/tools\/lib\n+ * @build toolbox.TestRunner toolbox.ToolBox\n+ * @run main SubpackageNoModules\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import toolbox.*;\n+import toolbox.Task.Expect;\n+\n+public class SubpackageNoModules extends TestRunner {\n+\n+    final ToolBox tb = new ToolBox();\n+\n+    public SubpackageNoModules() {\n+        super(System.err);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        SubpackageNoModules t = new SubpackageNoModules();\n+        t.runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testSubpackageNoModules(Path base) throws Exception {\n+        Files.createDirectories(base);\n+        tb.writeFile(base.resolve(\"pkg\/A.java\"), \"package pkg;\\npublic class A {}\\n\");\n+\n+        Path outDir = base.resolve(\"out\");\n+        Files.createDirectory(outDir);\n+        \/\/ Combine -subpackages option with -source release that doesn't support modules\n+        new JavadocTask(tb)\n+                .outdir(outDir)\n+                .sourcepath(base)\n+                .options(\"-source\", \"8\",\n+                         \"-subpackages\", \"pkg\")\n+                .run(Expect.SUCCESS);\n+        \/\/ Check for presence of generated docs\n+        if (!Files.isRegularFile(outDir.resolve(\"pkg\/A.html\"))) {\n+            error(\"File not found: \" + outDir.resolve(\"pkg\/A.html\"));\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/subpackageNoModules\/SubpackageNoModules.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -44,0 +44,2 @@\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n@@ -96,0 +98,1 @@\n+                      new NameToAnnotationEntry(\"java.lang.annotation.Retention\", Target.class),\n@@ -102,1 +105,2 @@\n-                      new NameToAnnotationEntry(\"BasicAnnoTests.TCs\",  BasicAnnoTests.TCs.class));\n+                      new NameToAnnotationEntry(\"BasicAnnoTests.TCs\",  BasicAnnoTests.TCs.class),\n+                      new NameToAnnotationEntry(\"BasicAnnoTests.TD\",  BasicAnnoTests.TD.class));\n@@ -523,0 +527,6 @@\n+    @Target(ElementType.TYPE_USE)\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface TD {\n+        int value();\n+    }\n+\n@@ -660,0 +670,4 @@\n+    @Test(posn=0, annoType=TA.class, expect=\"1\")\n+    @Test(posn=0, annoType=TD.class, expect=\"2\")\n+    public @TA(1) @TD(2) int f10;\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/type\/BasicAnnoTests.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340721\n+ * @summary Test invalid inputs to javax.lang.model.util.Types methods\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ * @build JavacTestingAbstractProcessor TestInvalidInputs\n+ * @compile -processor TestInvalidInputs -proc:only TestInvalidInputs.java\n+ *\/\n+\n+import java.util.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.type.*;\n+import javax.lang.model.util.*;\n+\n+\/**\n+ * Test if exceptions are thrown for invalid arguments as expected.\n+ *\/\n+public class TestInvalidInputs extends JavacTestingAbstractProcessor {\n+\n+    \/\/ Reference types are ArrayType, DeclaredType, ErrorType, NullType, and TypeVariable\n+\n+    private TypeMirror       objectType; \/\/ Notable DeclaredType\n+    private TypeMirror       stringType; \/\/ Another notable DeclaredType\n+    private ArrayType        arrayType;\n+    \/\/ private ErrorType        errorType; \/\/ skip for now\n+    private ExecutableType   executableType;\n+    private IntersectionType intersectionType;\n+\n+    private NoType           noTypeVoid;\n+    private NoType           noTypeNone;\n+    private NoType           noTypePackage;\n+    private NoType           noTypeModule;\n+\n+    private NullType         nullType;\n+    private PrimitiveType    primitiveType;\n+    private UnionType        unionType;\n+    private WildcardType     wildcardType;\n+\n+    \/**\n+     * Check expected behavior on classes and packages.\n+     *\/\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            initializeTypes();\n+            testUnboxedType();\n+            testGetWildcardType();\n+        }\n+        return true;\n+    }\n+\n+    void initializeTypes() {\n+        objectType = elements.getTypeElement(\"java.lang.Object\").asType();\n+        stringType = elements.getTypeElement(\"java.lang.String\").asType();\n+\n+        arrayType = types.getArrayType(objectType); \/\/ Object[]\n+        executableType = extractExecutableType();\n+        intersectionType = extractIntersectionType();\n+\n+        noTypeVoid = types.getNoType(TypeKind.VOID);\n+        noTypeNone = types.getNoType(TypeKind.NONE);\n+        noTypePackage = (NoType)(elements.getPackageElement(\"java.lang\").asType());\n+        noTypeModule  = (NoType)(elements.getModuleElement(\"java.base\").asType());\n+\n+        nullType = types.getNullType();\n+        primitiveType = types.getPrimitiveType(TypeKind.DOUBLE);\n+        \/\/ unionType; \/\/ more work here\n+        wildcardType = types.getWildcardType(objectType, null);\n+\n+        return;\n+    }\n+\n+    ExecutableType extractExecutableType() {\n+        var typeElement = elements.getTypeElement(\"TestInvalidInputs.InvalidInputsHost\");\n+        for (var method : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {\n+            if (\"foo7\".equals(method.getSimpleName().toString())) {\n+                return (ExecutableType)method.asType();\n+            }\n+        }\n+        throw new RuntimeException(\"Expected method not found\");\n+    }\n+\n+    IntersectionType extractIntersectionType() {\n+        var typeElement = elements.getTypeElement(\"TestInvalidInputs.InvalidInputsHost\");\n+        for (var method : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {\n+            if (\"foo9\".equals(method.getSimpleName().toString())) {\n+                return (IntersectionType) ((TypeVariable)method.getReturnType()).getUpperBound();\n+            }\n+        }\n+        throw new RuntimeException(\"Expected method not found\");\n+    }\n+\n+    \/*\n+     * Class to host inputs for testing.\n+     *\/\n+    class InvalidInputsHost {\n+        \/\/ Use a method to get an ExecutableType\n+        public static String foo7(int arg) {return null;}\n+\n+        \/\/ Type variable with intersection type\n+        public static <S extends Number &  Runnable>  S foo9() {return null;}\n+    }\n+\n+    \/**\n+     * @throws IllegalArgumentException if the given type has no\n+     *         unboxing conversion, including for types that are not\n+     *         {@linkplain ReferenceType reference types}\n+     *\/\n+    void testUnboxedType() {\n+        \/\/ Only DeclaredType's for wrapper classes should have unboxing conversions defined.\n+\n+        \/\/ Reference types are ArrayType, DeclaredType, ErrorType, NullType, TypeVariable\n+        \/\/ non-reference: ExecutableType, IntersectionType, NoType, PrimitiveType, UnionType, WildcardType\n+        var invalidInputs = List.of(objectType, stringType, arrayType,\n+                                    executableType, intersectionType,\n+                                    noTypeVoid, noTypeNone, noTypePackage, noTypeModule, nullType,\n+                                    primitiveType, \/*unionType, *\/ wildcardType);\n+\n+        for (TypeMirror tm : invalidInputs) {\n+            try {\n+                PrimitiveType pt = types.unboxedType(tm);\n+                throw new RuntimeException(\"Should not reach \" + tm);\n+            } catch(IllegalArgumentException iae) {\n+                ; \/\/ Expected\n+            }\n+        }\n+        return;\n+    }\n+\n+    \/**\n+     * @throws IllegalArgumentException if bounds are not valid,\n+     * including for types that are not {@linkplain ReferenceType\n+     * reference types}\n+     *\/\n+    void testGetWildcardType() {\n+        \/\/ Reference types are ArrayType, DeclaredType, ErrorType, NullType, TypeVariable\n+        \/\/ non-reference: ExecutableType, IntersectionType, NoType, PrimitiveType, UnionType, WildcardType\n+        var invalidInputs = List.of(executableType, intersectionType,\n+                                    noTypeVoid, noTypeNone, noTypePackage, noTypeModule, nullType,\n+                                    primitiveType, \/*unionType, *\/ wildcardType);\n+\n+        for (TypeMirror tm : invalidInputs) {\n+            try {\n+                WildcardType wc1 = types.getWildcardType(tm,   null);\n+                throw new RuntimeException(\"Should not reach \" + tm);\n+            } catch(IllegalArgumentException iae) {\n+                ; \/\/ Expected\n+            }\n+\n+            try {\n+                WildcardType wc2 = types.getWildcardType(null, tm);\n+                throw new RuntimeException(\"Should not reach \" + tm);\n+            } catch(IllegalArgumentException iae) {\n+                ; \/\/ Expected\n+            }\n+        }\n+        return;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/types\/TestInvalidInputs.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8309841\n+ * @summary Unit Test for a common Test API in jdk.test.lib.util.JarUtils\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.util.JarUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.stream.Collectors;\n+\n+public class JarUtilsTest {\n+    public static void main(String[] args) throws Exception {\n+        Files.createDirectory(Path.of(\"bx\"));\n+        JarUtils.createJarFile(Path.of(\"a.jar\"),\n+                Path.of(\".\"),\n+                Files.writeString(Path.of(\"a\"), \"\"),\n+                Files.writeString(Path.of(\"b1\"), \"\"),\n+                Files.writeString(Path.of(\"b2\"), \"\"),\n+                Files.writeString(Path.of(\"bx\/x\"), \"\"),\n+                Files.writeString(Path.of(\"c\"), \"\"),\n+                Files.writeString(Path.of(\"e1\"), \"\"),\n+                Files.writeString(Path.of(\"e2\"), \"\"));\n+        checkContent(\"a\", \"b1\", \"b2\", \"bx\/x\", \"c\", \"e1\", \"e2\");\n+\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"a\");\n+        checkContent(\"b1\", \"b2\", \"bx\/x\", \"c\", \"e1\", \"e2\");\n+\n+        \/\/ Note: b* covers everything starting with b, even bx\/x\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"b*\");\n+        checkContent(\"c\", \"e1\", \"e2\");\n+\n+        \/\/ d* does not match\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"d*\");\n+        checkContent(\"c\", \"e1\", \"e2\");\n+\n+        \/\/ multiple patterns\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"d*\", \"e*\");\n+        checkContent(\"c\");\n+    }\n+\n+    static void checkContent(String... expected) throws IOException {\n+        try (var jf = new JarFile(\"a.jar\")) {\n+            Asserts.assertEquals(Set.of(expected),\n+                    jf.stream().map(JarEntry::getName).collect(Collectors.toSet()));\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/util\/JarUtilsTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -323,0 +323,51 @@\n+    \/**\n+     * Remove entries from a ZIP file.\n+     *\n+     * Each entry can be a name or a name ending with \"*\".\n+     *\n+     * @return number of removed entries\n+     * @throws IOException if there is any I\/O error\n+     *\/\n+    public static int deleteEntries(Path jarfile, String... patterns)\n+            throws IOException {\n+        Path tmpfile = Files.createTempFile(\"jar\", \"jar\");\n+        int count = 0;\n+\n+        try (OutputStream out = Files.newOutputStream(tmpfile);\n+             JarOutputStream jos = new JarOutputStream(out)) {\n+            try (JarFile jf = new JarFile(jarfile.toString())) {\n+                Enumeration<JarEntry> jentries = jf.entries();\n+                top: while (jentries.hasMoreElements()) {\n+                    JarEntry jentry = jentries.nextElement();\n+                    String name = jentry.getName();\n+                    for (String pattern : patterns) {\n+                        if (pattern.endsWith(\"*\")) {\n+                            if (name.startsWith(pattern.substring(\n+                                    0, pattern.length() - 1))) {\n+                                \/\/ Go directly to next entry. This\n+                                \/\/ one is not written into `jos` and\n+                                \/\/ therefore removed.\n+                                count++;\n+                                continue top;\n+                            }\n+                        } else {\n+                            if (name.equals(pattern)) {\n+                                \/\/ Same as above\n+                                count++;\n+                                continue top;\n+                            }\n+                        }\n+                    }\n+                    \/\/ No pattern matched, file retained\n+                    jos.putNextEntry(copyEntry(jentry));\n+                    jf.getInputStream(jentry).transferTo(jos);\n+                }\n+            }\n+        }\n+\n+        \/\/ replace the original JAR file\n+        Files.move(tmpfile, jarfile, StandardCopyOption.REPLACE_EXISTING);\n+\n+        return count;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/JarUtils.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-     * libraal is enabled if isGraalEnabled is true and:\n+     * libraal JIT is enabled if isGraalEnabled is true and:\n@@ -99,1 +99,1 @@\n-    public static boolean isLibgraalEnabled() {\n+    public static boolean isLibgraalJIT() {\n","filename":"test\/lib\/jdk\/test\/whitebox\/code\/Compiler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    @Param({\"128\"})\n+    @Param({\"128\", \"192\", \"256\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMBench.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    @Param({\"1024\", \"1500\", \"4096\", \"16384\"})\n+    @Param({\"128\", \"256\", \"512\", \"1024\", \"1500\", \"4096\", \"16384\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/BenchBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,2 +312,3 @@\n-     * With two threads lockObject1 will be contended so should be\n-     * inflated.\n+     * With three threads lockObject1 will be contended so should be\n+     * inflated. Three threads is also needed to ensure a high level\n+     * of code coverage in the locking code.\n@@ -315,1 +316,1 @@\n-    @Threads(2)\n+    @Threads(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}