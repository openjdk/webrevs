{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-include NativeCompilation.gmk\n","filename":"make\/CompileDemos.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -139,0 +139,4 @@\n+################################################################################\n+## Build libhsdis\n+################################################################################\n+\n@@ -143,1 +147,3 @@\n-    EXTRA_HEADER_DIRS := $(TOPDIR)\/src\/utils\/hsdis, \\\n+    EXTRA_HEADER_DIRS := \\\n+          java.base:include \\\n+          $(TOPDIR)\/src\/utils\/hsdis, \\\n","filename":"make\/Hsdis.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-include NativeCompilation.gmk\n+include JdkNativeCompilation.gmk\n@@ -50,0 +50,2 @@\n+BITS := $(OPENJDK_TARGET_CPU_BITS)\n+\n@@ -56,2 +58,0 @@\n-BITS := $(OPENJDK_TARGET_CPU_BITS)\n-\n@@ -79,0 +79,4 @@\n+################################################################################\n+## Build data_generator\n+################################################################################\n+\n@@ -80,3 +84,2 @@\n-$(eval $(call SetupNativeCompilation, BUILD_DATA_GENERATOR, \\\n-    PROGRAM := data_generator, \\\n-    OUTPUT_DIR := $(X11WRAPPERS_OUTPUT)\/bin, \\\n+$(eval $(call SetupJdkExecutable, BUILD_DATA_GENERATOR, \\\n+    NAME := data_generator, \\\n@@ -84,2 +87,1 @@\n-    CFLAGS := $(X_CFLAGS) $(DATA_GENERATOR_INCLUDES) $(CFLAGS_JDKEXE), \\\n-    LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+    CFLAGS := $(X_CFLAGS) $(DATA_GENERATOR_INCLUDES), \\\n@@ -87,0 +89,1 @@\n+    OUTPUT_DIR := $(X11WRAPPERS_OUTPUT)\/bin, \\\n@@ -95,0 +98,1 @@\n+    SUPPORT_DIR := $(X11WRAPPERS_OUTPUT)\/run-wrapper, \\\n","filename":"make\/UpdateX11Wrappers.gmk","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -580,2 +580,2 @@\n-    TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:preprocessor -Zc:strictStrings -Zc:inline -permissive- -utf-8 -MP\"\n-    TOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:preprocessor -Zc:strictStrings -Zc:inline -utf-8 -Zc:wchar_t-\"\n+    TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:preprocessor -Zc:inline -permissive- -utf-8 -MP\"\n+    TOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:preprocessor -Zc:inline -permissive- -utf-8 -Zc:wchar_t-\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,6 +38,0 @@\n-FindSrcDirsForLib += \\\n-  $(call uniq, $(wildcard \\\n-      $(TOPDIR)\/src\/$(strip $1)\/$(OPENJDK_TARGET_OS)\/native\/lib$(strip $2) \\\n-      $(TOPDIR)\/src\/$(strip $1)\/$(OPENJDK_TARGET_OS_TYPE)\/native\/lib$(strip $2) \\\n-      $(TOPDIR)\/src\/$(strip $1)\/share\/native\/lib$(strip $2)))\n-\n@@ -107,2 +101,3 @@\n-# Setup make rules for creating a native shared library with suitable defaults\n-# for the OpenJDK project.\n+# Setup make rules for creating a native binary with suitable defaults\n+# for the OpenJDK project. This macro is mostly considered to be an internal\n+# support version. Please use SetupJdkLibrary or SetupJdkExecutable instead.\n@@ -114,1 +109,3 @@\n-# SetupNativeCompilation, except for\n+# SetupNativeCompilation. This macro also adds the following additional\n+# arguments:\n+#\n@@ -125,2 +122,29 @@\n-SetupJdkLibrary = $(NamedParamsMacroTemplate)\n-define SetupJdkLibraryBody\n+#   JDK_LIBS -- libraries generated by the JDK build system to link against\n+#   JDK_LIBS_<os> or JDK_LIBS_<osType> -- additional JDK_LIBS for the given OS\n+#     or OS type only\n+#   DEFAULT_LIBCXX -- if false, do not add LIBCXX to LIBS for C++ compilations\n+#   DEFAULT_CFLAGS -- if false, do not add default CFLAGS and CXXFLAGS\n+#   DEFAULT_LDFLAGS -- if false, do not add default LDFLAGS\n+#   CFLAGS_FILTER_OUT -- flags to filter out from default CFLAGS\n+#   CXXFLAGS_FILTER_OUT -- flags to filter out from default CXXFLAGS\n+#   LDFLAGS_FILTER_OUT -- flags to filter out from default LDFLAGS\n+#   LD_SET_ORIGIN -- if false, do not add SET_*_ORIGIN flags to LDFLAGS\n+#   APPEND_LDFLAGS -- a quirk to have additional LDFLAGS that will be set after\n+#     the origin flags\n+#   DEFAULT_VERSIONINFO_RESOURCE -- if false, do not set the default\n+#     VERSIONINFO_RESOURCE\n+#\n+SetupJdkNativeCompilation = $(NamedParamsMacroTemplate)\n+define SetupJdkNativeCompilationBody\n+  ifeq ($$($1_TYPE), EXECUTABLE)\n+    $1_NATIVE_DIR_PREFIX :=\n+    $1_MODULES_PATH := modules_cmds\n+    $1_RC_EXT := exe\n+    $1_RC_FTYPE := 0x1L\n+  else\n+    $1_NATIVE_DIR_PREFIX := lib\n+    $1_MODULES_PATH := modules_libs\n+    $1_RC_EXT := dll\n+    $1_RC_FTYPE := 0x2L\n+  endif\n+\n@@ -129,1 +153,5 @@\n-      $1_OUTPUT_DIR := $$(call FindLibDirForModule, $$(MODULE))\n+      ifeq ($$($1_TYPE), STATIC_LIBRARY)\n+        $1_OUTPUT_DIR := $$(SUPPORT_OUTPUTDIR)\/native\/$$(MODULE)\n+      else\n+        $1_OUTPUT_DIR := $$(SUPPORT_OUTPUTDIR)\/$$($1_MODULES_PATH)\/$$(strip $$(MODULE))\n+      endif\n@@ -137,1 +165,1 @@\n-      $1_OBJECT_DIR := $$(SUPPORT_OUTPUTDIR)\/native\/$$(MODULE)\/lib$$($1_NAME)\n+      $1_OBJECT_DIR := $$(SUPPORT_OUTPUTDIR)\/native\/$$(MODULE)\/$$($1_NATIVE_DIR_PREFIX)$$($1_NAME)\n@@ -143,2 +171,4 @@\n-  ifeq ($$($1_LINK_TYPE), C++)\n-    $1_LIBS += $(LIBCXX)\n+  ifneq ($$($1_DEFAULT_LIBCXX), false)\n+    ifeq ($$($1_LINK_TYPE), C++)\n+      $1_LIBS += $(LIBCXX)\n+    endif\n@@ -149,1 +179,1 @@\n-      $1_SRC := $$(call FindSrcDirsForLib, $$(MODULE), $$($1_NAME))\n+      $1_SRC := $$(call FindSrcDirsForComponent, $$(MODULE), $$($1_NATIVE_DIR_PREFIX)$$($1_NAME))\n@@ -151,1 +181,3 @@\n-      $$(error Must specify SRC in a MODULE free context)\n+      ifeq ($$($1_EXTRA_FILES), )\n+        $$(error Must specify SRC or EXTRA_FILES in a MODULE free context)\n+      endif\n@@ -167,2 +199,4 @@\n-  ifeq ($$($1_VERSIONINFO_RESOURCE), )\n-    $1_VERSIONINFO_RESOURCE := $$(GLOBAL_VERSION_INFO_RESOURCE)\n+  ifneq ($$($1_DEFAULT_VERSIONINFO_RESOURCE), false)\n+    ifeq ($$($1_VERSIONINFO_RESOURCE), )\n+      $1_VERSIONINFO_RESOURCE := $$(GLOBAL_VERSION_INFO_RESOURCE)\n+    endif\n@@ -174,1 +208,0 @@\n-\n@@ -176,2 +209,2 @@\n-      -D\"JDK_FILEDESC=$$(strip $$($1_RC_FILEDESC))\" \\\n-      -D\"JDK_FNAME=$$($1_NAME).dll\" \\\n+      -D\"JDK_FILEDESC=$$($1_RC_FILEDESC)\" \\\n+      -D\"JDK_FNAME=$$($1_NAME).$$($1_RC_EXT)\" \\\n@@ -179,1 +212,1 @@\n-      -D\"JDK_FTYPE=0x2L\" \\\n+      -D\"JDK_FTYPE=$$($1_RC_FTYPE)\" \\\n@@ -188,1 +221,3 @@\n-  $1_SRC_HEADER_FLAGS += $$(addprefix -I, $$(call GetJavaHeaderDir, $$(MODULE)))\n+  ifneq ($$(MODULE), )\n+    $1_SRC_HEADER_FLAGS += $$(addprefix -I, $$(call GetJavaHeaderDir, $$(MODULE)))\n+  endif\n@@ -202,2 +237,3 @@\n-    # Set the default flags first to be able to override\n-    $1_CFLAGS := $$(filter-out $$($1_CFLAGS_FILTER_OUT), $$(CFLAGS_JDKLIB)) $$($1_CFLAGS)\n+    ifeq ($$($1_TYPE), EXECUTABLE)\n+      # Set the default flags first to be able to override\n+      $1_CFLAGS := $$(filter-out $$($1_CFLAGS_FILTER_OUT), $$(CFLAGS_JDKEXE)) $$($1_CFLAGS)\n@@ -205,2 +241,9 @@\n-    # Set the default flags first to be able to override\n-    $1_CXXFLAGS := $$(filter-out $$($1_CXXFLAGS_FILTER_OUT), $$(CXXFLAGS_JDKLIB)) $$($1_CXXFLAGS)\n+      # Set the default flags first to be able to override\n+      $1_CXXFLAGS := $$(filter-out $$($1_CXXFLAGS_FILTER_OUT), $$(CXXFLAGS_JDKEXE)) $$($1_CXXFLAGS)\n+    else\n+      # Set the default flags first to be able to override\n+      $1_CFLAGS := $$(filter-out $$($1_CFLAGS_FILTER_OUT), $$(CFLAGS_JDKLIB)) $$($1_CFLAGS)\n+\n+      # Set the default flags first to be able to override\n+      $1_CXXFLAGS := $$(filter-out $$($1_CXXFLAGS_FILTER_OUT), $$(CXXFLAGS_JDKLIB)) $$($1_CXXFLAGS)\n+    endif\n@@ -220,2 +263,7 @@\n-    # Set the default flags first to be able to override\n-    $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKLIB)) $$($1_LDFLAGS)\n+    ifeq ($$($1_TYPE), EXECUTABLE)\n+      # Set the default flags first to be able to override\n+      $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKEXE)) $$($1_LDFLAGS)\n+    else\n+      # Set the default flags first to be able to override\n+      $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKLIB)) $$($1_LDFLAGS)\n+    endif\n@@ -225,1 +273,5 @@\n-    $1_LDFLAGS += $$(call SET_SHARED_LIBRARY_ORIGIN)\n+    ifeq ($$($1_TYPE), EXECUTABLE)\n+      $1_LDFLAGS += $$(call SET_EXECUTABLE_ORIGIN)\n+    else\n+      $1_LDFLAGS += $$(call SET_SHARED_LIBRARY_ORIGIN)\n+    endif\n@@ -233,1 +285,1 @@\n-  $$(eval $$(call SetupNativeCompilation, $1, ))\n+  $$(eval $$(call SetupNativeCompilation, $1))\n@@ -236,2 +288,3 @@\n-# Setup make rules for creating a native executable with suitable defaults for\n-# the OpenJDK project.\n+# Setup make rules for creating a native library with suitable defaults\n+# for the OpenJDK project. The default is to create a shared library,\n+# but by passing TYPE := STATIC_LIBARY, a static library can be created.\n@@ -243,82 +296,6 @@\n-# SetupNativeCompilation, except for\n-#   EXTRA_RCFLAGS -- additional RCFLAGS to append.\n-SetupJdkExecutable = $(NamedParamsMacroTemplate)\n-define SetupJdkExecutableBody\n-  $1_TYPE := EXECUTABLE\n-\n-  ifeq ($$($1_OUTPUT_DIR), )\n-    ifneq ($$(MODULE), )\n-      $1_OUTPUT_DIR := $$(call FindExecutableDirForModule, $$(MODULE))\n-    else\n-      $$(error Must specify OUTPUT_DIR in a MODULE free context)\n-    endif\n-  endif\n-\n-  ifeq ($$($1_OBJECT_DIR), )\n-    ifneq ($$(MODULE), )\n-      $1_OBJECT_DIR := $$(SUPPORT_OUTPUTDIR)\/native\/$$(MODULE)\/$$($1_NAME)\n-    else\n-      $$(error Must specify OBJECT_DIR in a MODULE free context)\n-    endif\n-  endif\n-\n-  ifeq ($$($1_LINK_TYPE), C++)\n-    $1_LIBS += $(LIBCXX)\n-  endif\n-\n-  ifeq ($$($1_SRC), )\n-    ifneq ($$(MODULE), )\n-      $1_SRC := $$(call FindSrcDirsForComponent, $$(MODULE), $$($1_NAME))\n-    else\n-      $$(error Must specify SRC in a MODULE free context)\n-    endif\n-  else\n-    $1_SRC := $$(foreach dir, $$($1_SRC), $$(call ProcessDir, $$(dir)))\n-  endif\n-  ifneq ($$($1_EXTRA_SRC), )\n-    $1_SRC += $$(foreach dir, $$($1_EXTRA_SRC), $$(call ProcessDir, $$(dir)))\n-  endif\n-\n-  ifeq ($$($1_VERSIONINFO_RESOURCE), )\n-    $1_VERSIONINFO_RESOURCE := $$(GLOBAL_VERSION_INFO_RESOURCE)\n-  endif\n-\n-  $1_RCFLAGS := $(JDK_RCFLAGS) \\\n-      -D\"JDK_FILEDESC=$(JDK_RC_NAME) binary\" \\\n-      -D\"JDK_FNAME=$$($1_NAME).exe\" \\\n-      -D\"JDK_INTERNAL_NAME=$$($1_NAME)\" \\\n-      -D\"JDK_FTYPE=0x1L\" \\\n-      -I$(TOPDIR)\/src\/java.base\/windows\/native\/common \\\n-      $$($1_EXTRA_RCFLAGS)\n-\n-  ifneq ($$($1_HEADERS_FROM_SRC), false)\n-    $1_SRC_HEADER_FLAGS := $$(addprefix -I, $$(wildcard $$($1_SRC)))\n-  endif\n-\n-  $1_JDK_LIBS += $$($1_JDK_LIBS_$$(OPENJDK_TARGET_OS))\n-  $1_JDK_LIBS += $$($1_JDK_LIBS_$$(OPENJDK_TARGET_OS_TYPE))\n-  # Prepend JDK libs before external libs\n-  $1_LIBS := $$($1_JDK_LIBS) $$($1_LIBS)\n-\n-  ifneq ($$($1_EXTRA_HEADER_DIRS), )\n-    $1_PROCESSED_EXTRA_HEADER_DIRS := $$(foreach dir, $$($1_EXTRA_HEADER_DIRS), \\\n-        $$(call ProcessDir, $$(dir)))\n-    $1_EXTRA_HEADER_FLAGS := $$(addprefix -I, $$($1_PROCESSED_EXTRA_HEADER_DIRS))\n-  endif\n-\n-  ifneq ($$($1_DEFAULT_CFLAGS), false)\n-    # Set the default flags first to be able to override\n-    $1_CFLAGS := $$(filter-out $$($1_CFLAGS_FILTER_OUT), $$(CFLAGS_JDKEXE)) $$($1_CFLAGS)\n-\n-    # Set the default flags first to be able to override\n-    $1_CXXFLAGS := $$(filter-out $$($1_CXXFLAGS_FILTER_OUT), $$(CXXFLAGS_JDKEXE)) $$($1_CXXFLAGS)\n-  endif\n-\n-  ifneq ($$($1_CFLAGS), )\n-    $1_CFLAGS += $$($1_SRC_HEADER_FLAGS) $$($1_EXTRA_HEADER_FLAGS)\n-  endif\n-  ifneq ($$($1_CXXFLAGS), )\n-    $1_CXXFLAGS += $$($1_SRC_HEADER_FLAGS) $$($1_EXTRA_HEADER_FLAGS)\n-  endif\n-  ifeq ($$($1_CFLAGS)$$($1_CXXFLAGS), )\n-    $1_CFLAGS += $$($1_SRC_HEADER_FLAGS) $$($1_EXTRA_HEADER_FLAGS)\n+# SetupJdkNativeCompilation. Please see that macro for details.\n+SetupJdkLibrary = $(NamedParamsMacroTemplate)\n+define SetupJdkLibraryBody\n+  # If type is unspecified, default to LIBRARY\n+  ifeq ($$($1_TYPE), )\n+    $1_TYPE := LIBRARY\n@@ -327,4 +304,4 @@\n-  ifneq ($$($1_DEFAULT_LDFLAGS), false)\n-    # Set the default flags first to be able to override\n-    $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKEXE)) $$($1_LDFLAGS)\n-  endif\n+  # Since we reuse the rule name ($1), all our arguments will pass through.\n+  # We lose in transparency, but gain in brevity in this call...\n+  $$(eval $$(call SetupJdkNativeCompilation, $1))\n+endef\n@@ -332,3 +309,11 @@\n-  ifneq ($$($1_LD_SET_ORIGIN), false)\n-    $1_LDFLAGS += $$(call SET_EXECUTABLE_ORIGIN)\n-  endif\n+# Setup make rules for creating a native executable with suitable defaults\n+# for the OpenJDK project.\n+#\n+# Parameter 1 is the name of the rule. This name is used as variable prefix,\n+# and the targets generated are listed in a variable by that name.\n+#\n+# Remaining parameters are named arguments. These are all passed on to\n+# SetupJdkNativeCompilation. Please see that macro for details.\n+SetupJdkExecutable = $(NamedParamsMacroTemplate)\n+define SetupJdkExecutableBody\n+  $1_TYPE := EXECUTABLE\n@@ -338,1 +323,1 @@\n-  $$(eval $$(call SetupNativeCompilation, $1))\n+  $$(eval $$(call SetupJdkNativeCompilation, $1))\n","filename":"make\/common\/JdkNativeCompilation.gmk","additions":109,"deletions":124,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -76,2 +76,0 @@\n-#   ARFLAGS the archiver flags to be used on unix platforms\n-#   LIBFLAGS the flags for the lib tool used on windows\n","filename":"make\/common\/NativeCompilation.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-include NativeCompilation.gmk\n+include JdkNativeCompilation.gmk\n@@ -59,3 +59,0 @@\n-  # Always include common test functionality\n-  TEST_CFLAGS := -I$(TOPDIR)\/test\/lib\/native\n-\n@@ -67,3 +64,0 @@\n-    $1_BASE_CFLAGS := $(CFLAGS_JDKLIB) $$(TEST_CFLAGS)\n-    $1_BASE_CXXFLAGS := $(CXXFLAGS_JDKLIB) $$(TEST_CFLAGS)\n-    $1_LDFLAGS := $(LDFLAGS_JDKLIB) $$(call SET_SHARED_LIBRARY_ORIGIN)\n@@ -75,3 +69,0 @@\n-    $1_BASE_CFLAGS := $(CFLAGS_JDKEXE) $$(TEST_CFLAGS)\n-    $1_BASE_CXXFLAGS := $(CXXFLAGS_JDKEXE) $$(TEST_CFLAGS)\n-    $1_LDFLAGS := $(LDFLAGS_JDKEXE) $(LDFLAGS_TESTEXE)\n@@ -80,0 +71,2 @@\n+    $1_LD_SET_ORIGIN := false\n+    $1_LDFLAGS := $(LDFLAGS_TESTEXE)\n@@ -102,0 +95,3 @@\n+  # Always include common test functionality\n+  TEST_CFLAGS := -I$(TOPDIR)\/test\/lib\/native\n+\n@@ -106,1 +102,1 @@\n-    $$(eval $$(call SetupNativeCompilation, BUILD_TEST_$$(name), \\\n+    $$(eval $$(call SetupJdkNativeCompilation, BUILD_TEST_$$(name), \\\n@@ -113,2 +109,3 @@\n-        CFLAGS := $$($1_BASE_CFLAGS) $$($1_CFLAGS) $$($1_CFLAGS_$$(name)), \\\n-        CXXFLAGS := $$($1_BASE_CXXFLAGS) $$($1_CFLAGS) $$($1_CFLAGS_$$(name)), \\\n+        CFLAGS := $$(TEST_CFLAGS) $$($1_CFLAGS) $$($1_CFLAGS_$$(name)), \\\n+        CXXFLAGS := $$(TEST_CFLAGS) $$($1_CFLAGS) $$($1_CFLAGS_$$(name)), \\\n+        LD_SET_ORIGIN := $$($1_LD_SET_ORIGIN), \\\n@@ -119,0 +116,1 @@\n+        DEFAULT_LIBCXX := false, \\\n@@ -120,0 +118,1 @@\n+        DEFAULT_VERSIONINFO_RESOURCE := false, \\\n@@ -132,1 +131,1 @@\n-  # SetupNativeCompilation.\n+  # SetupJdkNativeCompilation.\n","filename":"make\/common\/TestFilesCompilation.gmk","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -137,0 +137,4 @@\n+  ##############################################################################\n+  ## Build launcher \"$1\"\n+  ##############################################################################\n+\n@@ -154,3 +158,1 @@\n-      JDK_LIBS_linux := -ljli, \\\n-      JDK_LIBS_macosx := -ljli, \\\n-      JDK_LIBS_aix := -ljli_static, \\\n+      JDK_LIBS_unix := -ljli, \\\n@@ -180,1 +182,1 @@\n-    $$(BUILD_LAUNCHER_$1): $(call FindStaticLib, java.base, jli_static)\n+    $$(BUILD_LAUNCHER_$1): $(call FindStaticLib, java.base, jli)\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  $1_VARDEPS := $$($1_AR) $$(ARFLAGS) $$($1_ARFLAGS) $$($1_LIBS) \\\n+  $1_VARDEPS := $$($1_AR) $$(ARFLAGS) $$($1_LIBS) \\\n@@ -119,1 +119,1 @@\n-\t    $$($1_AR) $$(ARFLAGS) $$($1_ARFLAGS) -r -cs $$($1_TARGET) \\\n+\t    $$($1_AR) $$(ARFLAGS) -r -cs $$($1_TARGET) \\\n","filename":"make\/common\/native\/Link.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  $1_VARDEPS := $$($1_LIB) $$(LIBFLAGS) $$($1_LIBFLAGS) $$($1_LIBS) \\\n+  $1_VARDEPS := $$($1_LIB) $$(LIBFLAGS) $$($1_LIBS) \\\n@@ -53,1 +53,1 @@\n-\t    $$($1_LIB) -nologo $$(LIBFLAGS) $$($1_LIBFLAGS) -out:$$($1_TARGET) \\\n+\t    $$($1_LIB) -nologo $$(LIBFLAGS) -out:$$($1_TARGET) \\\n","filename":"make\/common\/native\/LinkMicrosoft.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_SHA256=a30c454a9bef8f46d5f1bf3122830014a8fbe7ac03b5f8729bc3add4b92a1d0a\n+LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22\/830ec9fcccef480bb3e73fb7ecafe059\/36\/GPL\/openjdk-22_linux-x64_bin.tar.gz\n+LINUX_X64_BOOT_JDK_SHA256=4d65cc6ed28711768fd72c2043a7925f7c83f5f51bb64970bd9d52f7791fc6ac\n@@ -36,2 +36,2 @@\n-MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_SHA256=af32e84c11009f72f783fdcdc9917efc277893988f097e198e2576875d1e88c1\n+MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22\/830ec9fcccef480bb3e73fb7ecafe059\/36\/GPL\/openjdk-22_macos-x64_bin.tar.gz\n+MACOS_X64_BOOT_JDK_SHA256=ae31fe10916429e3fe284266095067a5ce9fecbdc03ff1a079d20459f731ca36\n@@ -40,2 +40,2 @@\n-MACOS_AARCH64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_macos-aarch64_bin.tar.gz\n-MACOS_AARCH64_BOOT_JDK_SHA256=f12e1e0a2dffc847951598f597c8ee60fb0913932f24b2b09c62cfd2f0f4dfb9\n+MACOS_AARCH64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22\/830ec9fcccef480bb3e73fb7ecafe059\/36\/GPL\/openjdk-22_macos-aarch64_bin.tar.gz\n+MACOS_AARCH64_BOOT_JDK_SHA256=d10f82429d01047968c52c7975c326388cb5d212791e14c1de21c987463a4b53\n@@ -44,2 +44,2 @@\n-WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_SHA256=5434faaf029e66e7ce6e75770ca384de476750984a7d2881ef7686894c4b4944\n+WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22\/830ec9fcccef480bb3e73fb7ecafe059\/36\/GPL\/openjdk-22_windows-x64_bin.zip\n+WINDOWS_X64_BOOT_JDK_SHA256=8f5138fecb53c08c20abd4fa6812f9400051f3852582a2142ffda0dff73a5824\n","filename":"make\/conf\/github-actions.conf","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -393,2 +393,2 @@\n-    common.boot_jdk_version = \"21\";\n-    common.boot_jdk_build_number = \"35\";\n+    common.boot_jdk_version = \"22\";\n+    common.boot_jdk_build_number = \"36\";\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"21 22 23\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"22 23\"\n","filename":"make\/conf\/version-numbers.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-include NativeCompilation.gmk\n+include JdkNativeCompilation.gmk\n","filename":"make\/hotspot\/gensrc\/GenerateSources.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,5 @@\n-  $(eval $(call SetupNativeCompilation, BUILD_ADLC, \\\n+  ##############################################################################\n+  ## Build adlc\n+  ##############################################################################\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_ADLC, \\\n@@ -73,1 +77,0 @@\n-      TYPE := EXECUTABLE, \\\n@@ -78,0 +81,1 @@\n+      DEFAULT_CFLAGS := false, \\\n@@ -79,0 +83,1 @@\n+      DEFAULT_LDFLAGS := false, \\\n@@ -81,0 +86,1 @@\n+      DEFAULT_VERSIONINFO_RESOURCE := false, \\\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,1 +47,2 @@\n-\n+## Build libgtest\n+################################################################################\n@@ -78,1 +79,2 @@\n-# Additional disabled warnings are due to code in the test source.\n+## Build libjvm (for gtest)\n+################################################################################\n@@ -80,0 +82,1 @@\n+# Additional disabled warnings are due to code in the test source.\n@@ -131,0 +134,2 @@\n+################################################################################\n+## Build gtestLauncher\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-# parameter to SetupNativeCompilation allows an empty value to override the\n+# parameter to SetupJdkLibrary allows an empty value to override the\n@@ -162,1 +162,2 @@\n-# Now set up the actual compilation of the main hotspot native library\n+## Build libjvm\n+################################################################################\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,1 +217,0 @@\n-      genMarkSweep.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-    # This will get implicitly picked up by SetupNativeCompilation below.\n+    # This will get implicitly picked up by SetupJdkLibrary below.\n","filename":"make\/hotspot\/lib\/JvmOverrideFiles.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    private static SupplementDataParseHandler handlerSuppl;\n+    private static SupplementalDataParseHandler handlerSuppl;\n@@ -474,1 +474,1 @@\n-        handlerSuppl = new SupplementDataParseHandler();\n+        handlerSuppl = new SupplementalDataParseHandler();\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,203 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package build.tools.cldrconverter;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-import java.util.stream.Collectors;\n-import org.xml.sax.Attributes;\n-import org.xml.sax.InputSource;\n-import org.xml.sax.SAXException;\n-\n-\/**\n- * Handles parsing of files in Locale Data Markup Language for SupplementData.xml\n- * and produces a map that uses the keys and values of JRE locale data.\n- *\/\n-\n-class SupplementDataParseHandler extends AbstractLDMLHandler<Object> {\n-    \/\/UNM49 region and composition code used in supplementalData.xml\n-    private static final String WORLD = \"001\";\n-\n-    private static final String JAVA_FIRSTDAY = \"firstDayOfWeek\";\n-    private static final String JAVA_MINDAY = \"minimalDaysInFirstWeek\";\n-\n-    \/\/ The weekData is now in supplementalData.xml,\n-    \/\/ which is not a locale specific file.\n-    \/\/ Map for JRE is created locale specific way.\n-    \/\/ When parsing the locale neutral file (supplementalData.xml),\n-    \/\/ we need to rely on the country code because\n-    \/\/ the weekData is listed using country code.\n-    \/\/\n-    \/\/ weekData are generated per each country\n-    private final Map<String, Object> firstDayMap;\n-    private final Map<String, Object> minDaysMap;\n-\n-    \/\/ Parent locales. These information will only be\n-    \/\/ generated towards the base meta info, with the format of\n-    \/\/\n-    \/\/ parentLocale.<parent_locale_id>=<child_locale_id>(\" \"<child_locale_id>)+\n-    private final Map<String, String> parentLocalesMap;\n-\n-    \/\/ Input Skeleton map for \"preferred\" and \"allowed\"\n-    \/\/ Map<\"preferred\"\/\"allowed\", Map<\"skeleton\", SortedSet<\"regions\">>>\n-    private final Map<String, Map<String, SortedSet<String>>> inputSkeletonMap;\n-\n-    \/\/ \"component\" specific to this parent locale chain\n-    private String currentParentLocaleComponent;\n-\n-    SupplementDataParseHandler() {\n-        firstDayMap = new HashMap<>();\n-        minDaysMap = new HashMap<>();\n-        parentLocalesMap = new HashMap<>();\n-        inputSkeletonMap = new HashMap<>();\n-    }\n-\n-    \/**\n-     * It returns Map that contains the firstDay and minDays information for\n-     * the country. The Map is created in JRE format after obtaining the data\n-     * from two Maps, firstDayMap and minDaysMap.\n-     *\n-     * It returns null when there is no firstDay and minDays for the country\n-     * although this should not happen because supplementalData.xml includes\n-     * default value for the world (\"001\") for firstDay and minDays.\n-     *\n-     * This method also returns Maps for \"preferred\" and \"allowed\" skeletons,\n-     * which are grouped by regions. E.g, \"h:XX YY ZZ;\" which means 'h' pattern\n-     * is \"preferred\"\/\"allowed\" in \"XX\", \"YY\", and \"ZZ\" regions.\n-     *\/\n-    Map<String, Object> getData(String id) {\n-        Map<String, Object> values = new HashMap<>();\n-        if (\"root\".equals(id)) {\n-            parentLocalesMap.forEach((k, v) -> values.put(CLDRConverter.PARENT_LOCALE_PREFIX + k, v));\n-            firstDayMap.forEach((k, v) -> values.put(CLDRConverter.CALENDAR_FIRSTDAY_PREFIX + v, k));\n-            minDaysMap.forEach((k, v) -> values.put(CLDRConverter.CALENDAR_MINDAYS_PREFIX + v, k));\n-            inputSkeletonMap.get(\"preferred\").forEach((k, v) ->\n-                    values.merge(Bundle.DATEFORMATITEM_INPUT_REGIONS_PREFIX + \"preferred\",\n-                            k + \":\" + v.stream().collect(Collectors.joining(\" \")) + \";\",\n-                            (old, newVal) -> old + (String)newVal));\n-            inputSkeletonMap.get(\"allowed\").forEach((k, v) ->\n-                    values.merge(Bundle.DATEFORMATITEM_INPUT_REGIONS_PREFIX + \"allowed\",\n-                            k + \":\" + v.stream().collect(Collectors.joining(\" \")) + \";\",\n-                            (old, newVal) -> old + (String)newVal));\n-        }\n-        return values.isEmpty() ? null : values;\n-    }\n-\n-    @Override\n-    public InputSource resolveEntity(String publicID, String systemID) throws IOException, SAXException {\n-        \/\/ avoid HTTP traffic to unicode.org\n-        if (systemID.startsWith(CLDRConverter.SPPL_LDML_DTD_SYSTEM_ID)) {\n-            return new InputSource((new File(CLDRConverter.LOCAL_SPPL_LDML_DTD)).toURI().toString());\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * JRE requires all the data to be organized by the locale while CLDR 1.4 list\n-     * Calendar related data (weekData)in SupplementalData.xml.\n-     * startElement stores JRE required data into two Maps,\n-     * firstDayMap and minDaysMap.\n-     *\/\n-    @Override\n-    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n-        \/\/ elements we need to actively ignore\n-        switch (qName) {\n-        case \"firstDay\":\n-            if (!isIgnored(attributes)) {\n-                String fd;\n-\n-                switch (attributes.getValue(\"day\")) {\n-                    case \"sun\":\n-                        fd = \"1\";\n-                        break;\n-                    default:\n-                    case \"mon\":\n-                        fd = \"2\";\n-                        break;\n-                    case \"tue\":\n-                        fd = \"3\";\n-                        break;\n-                    case \"wed\":\n-                        fd = \"4\";\n-                        break;\n-                    case \"thu\":\n-                        fd = \"5\";\n-                        break;\n-                    case \"fri\":\n-                        fd = \"6\";\n-                        break;\n-                    case \"sat\":\n-                        fd = \"7\";\n-                        break;\n-                }\n-                firstDayMap.put(attributes.getValue(\"territories\"), fd);\n-            }\n-            break;\n-        case \"minDays\":\n-            if (!isIgnored(attributes)) {\n-                minDaysMap.put(attributes.getValue(\"territories\"), attributes.getValue(\"count\"));\n-            }\n-            break;\n-        case \"parentLocales\":\n-            currentParentLocaleComponent = attributes.getValue(\"component\");\n-            pushContainer(qName, attributes);\n-            break;\n-        case \"parentLocale\":\n-            if (!isIgnored(attributes)) {\n-                \/\/ Ignore component for now, otherwise \"zh-Hant\" falling back to \"zh\" would happen\n-                \/\/ https:\/\/github.com\/unicode-org\/cldr\/pull\/2664\n-                if (currentParentLocaleComponent == null) {\n-                    parentLocalesMap.put(\n-                        attributes.getValue(\"parent\").replaceAll(\"_\", \"-\"),\n-                        attributes.getValue(\"locales\").replaceAll(\"_\", \"-\"));\n-                }\n-            }\n-            break;\n-        case \"hours\":\n-            if (!isIgnored(attributes)) {\n-                var preferred = attributes.getValue(\"preferred\");\n-                var allowed = attributes.getValue(\"allowed\").replaceFirst(\" .*\", \"\").replaceFirst(\"b\", \"B\"); \/\/ take only the first one, \"b\" -> \"B\"\n-                var regions = Arrays.stream(attributes.getValue(\"regions\").split(\" \"))\n-                        .map(r -> r.replaceAll(\"_\", \"-\"))\n-                        .collect(Collectors.toSet());\n-                var pmap = inputSkeletonMap.computeIfAbsent(\"preferred\", k -> new HashMap<>());\n-                var amap = inputSkeletonMap.computeIfAbsent(\"allowed\", k -> new HashMap<>());\n-                pmap.computeIfAbsent(preferred, k -> new TreeSet<>()).addAll(regions);\n-                amap.computeIfAbsent(allowed, k -> new TreeSet<>()).addAll(regions);\n-            }\n-            break;\n-        default:\n-            \/\/ treat anything else as a container\n-            pushContainer(qName, attributes);\n-            break;\n-        }\n-    }\n-}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/SupplementDataParseHandler.java","additions":0,"deletions":203,"binary":false,"changes":203,"status":"deleted"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package build.tools.cldrconverter;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+\n+\/**\n+ * Handles parsing of files in Locale Data Markup Language for supplementalData.xml\n+ * and produces a map that uses the keys and values of JRE locale data.\n+ *\/\n+\n+class SupplementalDataParseHandler extends AbstractLDMLHandler<Object> {\n+    \/\/UNM49 region and composition code used in supplementalData.xml\n+    private static final String WORLD = \"001\";\n+\n+    private static final String JAVA_FIRSTDAY = \"firstDayOfWeek\";\n+    private static final String JAVA_MINDAY = \"minimalDaysInFirstWeek\";\n+\n+    \/\/ The weekData is now in supplementalData.xml,\n+    \/\/ which is not a locale specific file.\n+    \/\/ Map for JRE is created locale specific way.\n+    \/\/ When parsing the locale neutral file (supplementalData.xml),\n+    \/\/ we need to rely on the country code because\n+    \/\/ the weekData is listed using country code.\n+    \/\/\n+    \/\/ weekData are generated per each country\n+    private final Map<String, Object> firstDayMap;\n+    private final Map<String, Object> minDaysMap;\n+\n+    \/\/ Parent locales. These information will only be\n+    \/\/ generated towards the base meta info, with the format of\n+    \/\/\n+    \/\/ parentLocale.<parent_locale_id>=<child_locale_id>(\" \"<child_locale_id>)+\n+    private final Map<String, String> parentLocalesMap;\n+\n+    \/\/ Input Skeleton map for \"preferred\" and \"allowed\"\n+    \/\/ Map<\"preferred\"\/\"allowed\", Map<\"skeleton\", SortedSet<\"regions\">>>\n+    private final Map<String, Map<String, SortedSet<String>>> inputSkeletonMap;\n+\n+    \/\/ \"component\" specific to this parent locale chain\n+    private String currentParentLocaleComponent;\n+\n+    SupplementalDataParseHandler() {\n+        firstDayMap = new HashMap<>();\n+        minDaysMap = new HashMap<>();\n+        parentLocalesMap = new HashMap<>();\n+        inputSkeletonMap = new HashMap<>();\n+    }\n+\n+    \/**\n+     * It returns Map that contains the firstDay and minDays information for\n+     * the country. The Map is created in JRE format after obtaining the data\n+     * from two Maps, firstDayMap and minDaysMap.\n+     *\n+     * It returns null when there is no firstDay and minDays for the country\n+     * although this should not happen because supplementalData.xml includes\n+     * default value for the world (\"001\") for firstDay and minDays.\n+     *\n+     * This method also returns Maps for \"preferred\" and \"allowed\" skeletons,\n+     * which are grouped by regions. E.g, \"h:XX YY ZZ;\" which means 'h' pattern\n+     * is \"preferred\"\/\"allowed\" in \"XX\", \"YY\", and \"ZZ\" regions.\n+     *\/\n+    Map<String, Object> getData(String id) {\n+        Map<String, Object> values = new HashMap<>();\n+        if (\"root\".equals(id)) {\n+            parentLocalesMap.forEach((k, v) -> values.put(CLDRConverter.PARENT_LOCALE_PREFIX + k, v));\n+            firstDayMap.forEach((k, v) -> values.put(CLDRConverter.CALENDAR_FIRSTDAY_PREFIX + v, k));\n+            minDaysMap.forEach((k, v) -> values.put(CLDRConverter.CALENDAR_MINDAYS_PREFIX + v, k));\n+            inputSkeletonMap.get(\"preferred\").forEach((k, v) ->\n+                    values.merge(Bundle.DATEFORMATITEM_INPUT_REGIONS_PREFIX + \"preferred\",\n+                            k + \":\" + v.stream().collect(Collectors.joining(\" \")) + \";\",\n+                            (old, newVal) -> old + (String)newVal));\n+            inputSkeletonMap.get(\"allowed\").forEach((k, v) ->\n+                    values.merge(Bundle.DATEFORMATITEM_INPUT_REGIONS_PREFIX + \"allowed\",\n+                            k + \":\" + v.stream().collect(Collectors.joining(\" \")) + \";\",\n+                            (old, newVal) -> old + (String)newVal));\n+        }\n+        return values.isEmpty() ? null : values;\n+    }\n+\n+    @Override\n+    public InputSource resolveEntity(String publicID, String systemID) throws IOException, SAXException {\n+        \/\/ avoid HTTP traffic to unicode.org\n+        if (systemID.startsWith(CLDRConverter.SPPL_LDML_DTD_SYSTEM_ID)) {\n+            return new InputSource((new File(CLDRConverter.LOCAL_SPPL_LDML_DTD)).toURI().toString());\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * JRE requires all the data to be organized by the locale while CLDR 1.4 list\n+     * Calendar related data (weekData)in SupplementalData.xml.\n+     * startElement stores JRE required data into two Maps,\n+     * firstDayMap and minDaysMap.\n+     *\/\n+    @Override\n+    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n+        \/\/ elements we need to actively ignore\n+        switch (qName) {\n+        case \"firstDay\":\n+            if (!isIgnored(attributes)) {\n+                String fd = switch (attributes.getValue(\"day\")) {\n+                    case \"sun\" -> \"1\";\n+                    case \"tue\" -> \"3\";\n+                    case \"wed\" -> \"4\";\n+                    case \"thu\" -> \"5\";\n+                    case \"fri\" -> \"6\";\n+                    case \"sat\" -> \"7\";\n+                    default -> \"2\"; \/\/ Mon\n+                };\n+                firstDayMap.put(attributes.getValue(\"territories\"), fd);\n+            }\n+            break;\n+        case \"minDays\":\n+            if (!isIgnored(attributes)) {\n+                minDaysMap.put(attributes.getValue(\"territories\"), attributes.getValue(\"count\"));\n+            }\n+            break;\n+        case \"parentLocales\":\n+            currentParentLocaleComponent = attributes.getValue(\"component\");\n+            pushContainer(qName, attributes);\n+            break;\n+        case \"parentLocale\":\n+            if (!isIgnored(attributes)) {\n+                \/\/ Ignore component for now, otherwise \"zh-Hant\" falling back to \"zh\" would happen\n+                \/\/ https:\/\/github.com\/unicode-org\/cldr\/pull\/2664\n+                if (currentParentLocaleComponent == null) {\n+                    parentLocalesMap.put(\n+                        attributes.getValue(\"parent\").replaceAll(\"_\", \"-\"),\n+                        attributes.getValue(\"locales\").replaceAll(\"_\", \"-\"));\n+                }\n+            }\n+            break;\n+        case \"hours\":\n+            if (!isIgnored(attributes)) {\n+                var preferred = attributes.getValue(\"preferred\");\n+                var allowed = attributes.getValue(\"allowed\").replaceFirst(\" .*\", \"\").replaceFirst(\"b\", \"B\"); \/\/ take only the first one, \"b\" -> \"B\"\n+                var regions = Arrays.stream(attributes.getValue(\"regions\").split(\" \"))\n+                        .map(r -> r.replaceAll(\"_\", \"-\"))\n+                        .collect(Collectors.toSet());\n+                var pmap = inputSkeletonMap.computeIfAbsent(\"preferred\", k -> new HashMap<>());\n+                var amap = inputSkeletonMap.computeIfAbsent(\"allowed\", k -> new HashMap<>());\n+                pmap.computeIfAbsent(preferred, k -> new TreeSet<>()).addAll(regions);\n+                amap.computeIfAbsent(allowed, k -> new TreeSet<>()).addAll(regions);\n+            }\n+            break;\n+        default:\n+            \/\/ treat anything else as a container\n+            pushContainer(qName, attributes);\n+            break;\n+        }\n+    }\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/SupplementalDataParseHandler.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * SupplementalMetadata.xml\n+ * supplementalMetadata.xml\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/SupplementalMetadataParseHandler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,8 +46,2 @@\n-    public int dispatchCompilation(String[] args) {\n-        Log log = Log.get();\n-        try {\n-            return pool.submit(() -> Server.runCompiler(log, args)).get();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Error during compile\", e);\n-        }\n+    public void execute(Runnable runnable) {\n+        this.pool.execute(runnable);\n","filename":"make\/langtools\/tools\/javacserver\/server\/CompilerThreadPool.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -171,4 +171,2 @@\n-                 \/\/ Handle each incoming request in a separate thread. This is just for socket communication,\n-                 \/\/ the actual compilation will be done by the threadpool.\n-                Thread requestHandler = new Thread(() -> handleRequest(socket));\n-                requestHandler.start();\n+                 \/\/ Handle each incoming request in a threapool thread\n+                compilerThreadPool.execute(() -> handleRequest(socket));\n@@ -209,3 +207,3 @@\n-                \/\/ Perform compilation. This will call runCompiler() on a\n-                \/\/ thread in the thread pool\n-                int exitCode = compilerThreadPool.dispatchCompilation(args);\n+                \/\/ Perform compilation\n+                int exitCode = runCompiler(args);\n+\n@@ -223,0 +221,1 @@\n+            ex.printStackTrace();\n@@ -229,3 +228,1 @@\n-    public static int runCompiler(Log log, String[] args) {\n-        Log.setLogForCurrentThread(log);\n-\n+    public static int runCompiler(String[] args) {\n","filename":"make\/langtools\/tools\/javacserver\/server\/Server.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -102,15 +102,15 @@\n-    $(eval $(call SetupJdkLibrary, BUILD_LIBOSXSECURITY, \\\n-        NAME := osxsecurity, \\\n-        OPTIMIZATION := LOW, \\\n-        DISABLED_WARNINGS_clang_KeystoreImpl.m := deprecated-declarations, \\\n-        LDFLAGS := -L$(SUPPORT_OUTPUTDIR)\/modules_libs\/java.base,\\\n-        JDK_LIBS := $(JDKLIB_LIBS), \\\n-        LIBS_macosx := -lobjc \\\n-            -framework CoreServices \\\n-            -framework Foundation \\\n-            -framework Security, \\\n-    ))\n-\n-    $(BUILD_LIBOSXSECURITY): $(BUILD_LIBJAVA)\n-\n-    TARGETS += $(BUILD_LIBOSXSECURITY)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBOSXSECURITY, \\\n+      NAME := osxsecurity, \\\n+      OPTIMIZATION := LOW, \\\n+      DISABLED_WARNINGS_clang_KeystoreImpl.m := deprecated-declarations, \\\n+      LDFLAGS := -L$(SUPPORT_OUTPUTDIR)\/modules_libs\/java.base,\\\n+      JDK_LIBS := $(JDKLIB_LIBS), \\\n+      LIBS_macosx := -lobjc \\\n+          -framework CoreServices \\\n+          -framework Foundation \\\n+          -framework Security, \\\n+  ))\n+\n+  $(BUILD_LIBOSXSECURITY): $(BUILD_LIBJAVA)\n+\n+  TARGETS += $(BUILD_LIBOSXSECURITY)\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -166,0 +166,5 @@\n+ifeq ($(call isTargetOs, aix), true)\n+  # AIX requires a static libjli because the compiler doesn't support '-rpath'\n+  BUILD_LIBJLI_TYPE := STATIC_LIBRARY\n+endif\n+\n@@ -168,0 +173,1 @@\n+    TYPE := $(BUILD_LIBJLI_TYPE), \\\n@@ -176,1 +182,0 @@\n-    LIBS_aix := $(LIBDL),\\\n@@ -186,23 +191,0 @@\n-\n-LIBJLI_SRC_DIRS := $(call FindSrcDirsForComponent, java.base, libjli)\n-\n-ifeq ($(call isTargetOs, aix), true)\n-  # AIX also requires a static libjli because the compiler doesn't support\n-  # '-rpath'\n-  $(eval $(call SetupNativeCompilation, BUILD_LIBJLI_STATIC, \\\n-      NAME := jli_static, \\\n-      TYPE := STATIC_LIBRARY, \\\n-      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE), \\\n-      SRC := $(LIBJLI_SRC_DIRS), \\\n-      EXCLUDE_FILES := $(LIBJLI_EXCLUDE_FILES), \\\n-      EXTRA_FILES := $(LIBJLI_EXTRA_FILES), \\\n-      OPTIMIZATION := HIGH, \\\n-      CFLAGS := $(STATIC_LIBRARY_FLAGS) $(CFLAGS_JDKLIB) $(LIBJLI_CFLAGS) \\\n-          $(LIBZ_CFLAGS) $(addprefix -I, $(LIBJLI_SRC_DIRS)), \\\n-      DISABLED_WARNINGS_clang_aix := format-nonliteral \\\n-          deprecated-non-prototype, \\\n-      ARFLAGS := $(ARFLAGS), \\\n-      OBJECT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjli_static))\n-\n-  TARGETS += $(BUILD_LIBJLI_STATIC)\n-endif\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -44,3 +44,1 @@\n-    JDK_LIBS_linux := -ljli, \\\n-    JDK_LIBS_macosx := -ljli, \\\n-    JDK_LIBS_aix := -ljli_static, \\\n+    JDK_LIBS_unix := -ljli, \\\n@@ -60,1 +58,1 @@\n-  $(BUILD_LIBINSTRUMENT): $(call FindStaticLib, java.base, jli_static)\n+  $(BUILD_LIBINSTRUMENT): $(call FindStaticLib, java.base, jli)\n","filename":"make\/modules\/java.instrument\/Lib.gmk","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+################################################################################\n+## Build libmanagement\n","filename":"make\/modules\/java.management\/Lib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+################################################################################\n+## Build libmanagement_ext\n@@ -46,1 +48,1 @@\n-    CFLAGS := $(CFLAGS_JDKLIB) $(LIBMANAGEMENT_EXT_CFLAGS), \\\n+    CFLAGS := $(LIBMANAGEMENT_EXT_CFLAGS), \\\n","filename":"make\/modules\/jdk.management\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-################################################################################\n-## Build libsctp\n-################################################################################\n-\n@@ -33,0 +29,4 @@\n+  ##############################################################################\n+  ## Build libsctp\n+  ##############################################################################\n+\n","filename":"make\/modules\/jdk.sctp\/Lib.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-include NativeCompilation.gmk\n","filename":"make\/test\/BuildFailureHandler.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -143,3 +143,0 @@\n-BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS $(JVMTI_COMMON_INCLUDES)\n-BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS $(JVMTI_COMMON_INCLUDES)\n-\n@@ -1530,0 +1527,4 @@\n+# These apply to all tests\n+BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS $(JVMTI_COMMON_INCLUDES)\n+BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS $(JVMTI_COMMON_INCLUDES)\n+\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -97,0 +97,3 @@\n+  ifeq ($(call isTargetOs, aix), true)\n+    BUILD_JDK_JTREG_EXECUTABLES_LDFLAGS_exeJliLaunchTest := -L$(SUPPORT_OUTPUTDIR)\/native\/java.base\n+  endif\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/food\/apple.jpeg","binary":true,"status":"deleted"},{"patch":"@@ -60,2 +60,2 @@\n-  static constexpr int num_immediates = sizeof(immediates) \/ sizeof(immediates[0]);\n-  const int start_index = aslr ? os::next_random((int)os::javaTimeNanos()) : 0;\n+  static constexpr unsigned num_immediates = sizeof(immediates) \/ sizeof(immediates[0]);\n+  const unsigned start_index = aslr ? os::next_random((int)os::javaTimeNanos()) : 0;\n@@ -67,2 +67,2 @@\n-    const int alt_index = (ntry & 1) ? 0 : num_immediates \/ 2;\n-    const int index = (start_index + ntry + alt_index) % num_immediates;\n+    const unsigned alt_index = (ntry & 1) ? 0 : num_immediates \/ 2;\n+    const unsigned index = (start_index + ntry + alt_index) % num_immediates;\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n+  assert(cb->as_nmethod()->method()->is_continuation_enter_intrinsic(), \"\");\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationEntry_aarch64.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-    CompiledMethod* nm = sender_blob->as_compiled_method_or_null();\n+    nmethod* nm = sender_blob->as_nmethod_or_null();\n@@ -237,1 +237,1 @@\n-      assert(!sender_blob->is_compiled(), \"should count return address at least\");\n+      assert(!sender_blob->is_nmethod(), \"should count return address at least\");\n@@ -246,1 +246,1 @@\n-    if (!sender_blob->is_compiled()) {\n+    if (!sender_blob->is_nmethod()) {\n@@ -300,1 +300,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -429,1 +429,1 @@\n-void frame::verify_deopt_original_pc(CompiledMethod* nm, intptr_t* unextended_sp) {\n+void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n@@ -452,2 +452,2 @@\n-    CompiledMethod* sender_cm = _cb->as_compiled_method_or_null();\n-    if (sender_cm != nullptr) {\n+    nmethod* sender_nm = _cb->as_nmethod_or_null();\n+    if (sender_nm != nullptr) {\n@@ -455,3 +455,3 @@\n-      if (sender_cm->is_deopt_entry(_pc) ||\n-          sender_cm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_cm, _unextended_sp);\n+      if (sender_nm->is_deopt_entry(_pc) ||\n+          sender_nm->is_deopt_mh_entry(_pc)) {\n+        verify_deopt_original_pc(sender_nm, _unextended_sp);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-  static void verify_deopt_original_pc(   CompiledMethod* nm, intptr_t* unextended_sp);\n+  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -78,1 +78,1 @@\n-    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb == nullptr || _cb->as_nmethod()->insts_contains_inclusive(_pc),\n@@ -181,1 +181,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -243,2 +243,2 @@\n-  assert(cb()->is_compiled(), \"\");\n-  return (cb()->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  assert(cb()->is_nmethod(), \"\");\n+  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n@@ -420,1 +420,1 @@\n-    if (!_cb->is_compiled()) { \/\/ compiled frames do not use callee-saved registers\n+    if (!_cb->is_nmethod()) { \/\/ compiled frames do not use callee-saved registers\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-                   notproduct,                                          \\\n@@ -89,2 +88,0 @@\n-  product(bool, UseNeon, false,                                         \\\n-          \"Use Neon for CRC32 computation\")                             \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -870,1 +870,1 @@\n-          !CodeCache::find_blob(target)->is_compiled(),\n+          !CodeCache::find_blob(target)->is_nmethod(),\n@@ -1202,1 +1202,1 @@\n-  \/\/ %%% Could store the aligned, prescaled offset in the klassoop.\n+  \/\/ Could store the aligned, prescaled offset in the klass.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"code\/compiledMethod.hpp\"\n+#include \"code\/nmethod.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  int argsize = is_compiled() ? (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n+  int argsize = is_compiled() ? (_cb->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n@@ -182,1 +182,1 @@\n-      assert(!sender_blob->is_compiled(), \"should count return address at least\");\n+      assert(!sender_blob->is_nmethod(), \"should count return address at least\");\n@@ -191,1 +191,1 @@\n-    if (!sender_blob->is_compiled()) {\n+    if (!sender_blob->is_nmethod()) {\n@@ -232,1 +232,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -335,1 +335,1 @@\n-void frame::verify_deopt_original_pc(CompiledMethod* nm, intptr_t* unextended_sp, bool is_method_handle_return) {\n+void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp, bool is_method_handle_return) {\n@@ -360,2 +360,2 @@\n-  CompiledMethod* sender_cm = (_cb == nullptr) ? nullptr : _cb->as_compiled_method_or_null();\n-  if (sender_cm != nullptr) {\n+  nmethod* sender_nm = (_cb == nullptr) ? nullptr : _cb->as_nmethod_or_null();\n+  if (sender_nm != nullptr) {\n@@ -365,2 +365,2 @@\n-    if (sender_cm->is_deopt_mh_entry(_pc)) {\n-      DEBUG_ONLY(verify_deopt_mh_original_pc(sender_cm, _fp));\n+    if (sender_nm->is_deopt_mh_entry(_pc)) {\n+      DEBUG_ONLY(verify_deopt_mh_original_pc(sender_nm, _fp));\n@@ -369,2 +369,2 @@\n-    else if (sender_cm->is_deopt_entry(_pc)) {\n-      DEBUG_ONLY(verify_deopt_original_pc(sender_cm, _unextended_sp));\n+    else if (sender_nm->is_deopt_entry(_pc)) {\n+      DEBUG_ONLY(verify_deopt_original_pc(sender_nm, _unextended_sp));\n@@ -372,1 +372,1 @@\n-    else if (sender_cm->is_method_handle_return(_pc)) {\n+    else if (sender_nm->is_method_handle_return(_pc)) {\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,2 +96,2 @@\n-  static void verify_deopt_original_pc(   CompiledMethod* nm, intptr_t* unextended_sp, bool is_method_handle_return = false);\n-  static void verify_deopt_mh_original_pc(CompiledMethod* nm, intptr_t* unextended_sp) {\n+  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp, bool is_method_handle_return = false);\n+  static void verify_deopt_mh_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -64,1 +64,1 @@\n-    assert(_cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb->as_nmethod()->insts_contains_inclusive(_pc),\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,0 @@\n-                   notproduct,  \\\n","filename":"src\/hotspot\/cpu\/arm\/globals_arm.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n+  assert(cb->as_nmethod()->method()->is_continuation_enter_intrinsic(), \"\");\n","filename":"src\/hotspot\/cpu\/ppc\/continuationEntry_ppc.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n@@ -283,1 +283,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -291,1 +291,1 @@\n-  assert(!is_compiled_frame() || !_cb->as_compiled_method()->is_deopt_entry(_pc), \"must be\");\n+  assert(!is_compiled_frame() || !_cb->as_nmethod()->is_deopt_entry(_pc), \"must be\");\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -68,1 +68,1 @@\n-    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb == nullptr || _cb->as_nmethod()->insts_contains_inclusive(_pc),\n@@ -332,1 +332,1 @@\n-    if (!_cb->is_compiled()) { \/\/ compiled frames do not use callee-saved registers\n+    if (!_cb->is_nmethod()) { \/\/ compiled frames do not use callee-saved registers\n@@ -371,2 +371,2 @@\n-  assert(cb()->is_compiled(), \"\");\n-  return (cb()->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  assert(cb()->is_nmethod(), \"\");\n+  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,0 @@\n-                   notproduct,                                              \\\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1882,1 +1882,1 @@\n-  \/\/ %%% We should store the aligned, prescaled offset in the klassoop.\n+  \/\/ We should store the aligned, prescaled offset in the klass.\n@@ -2013,1 +2013,1 @@\n-  \/\/ The loaded value is the offset from KlassOopDesc.\n+  \/\/ The loaded value is the offset from Klass.\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -463,1 +463,1 @@\n-  if (cb == nullptr || !cb->is_compiled()) return false;\n+  if (cb == nullptr || !cb->is_nmethod()) return false;\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  int argsize = (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  int argsize = (_cb->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkFrameStream_ppc.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n+  assert(cb->as_nmethod()->method()->is_continuation_enter_intrinsic(), \"\");\n","filename":"src\/hotspot\/cpu\/riscv\/continuationEntry_riscv.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-    CompiledMethod* nm = sender_blob->as_compiled_method_or_null();\n+    nmethod* nm = sender_blob->as_nmethod_or_null();\n@@ -225,1 +225,1 @@\n-      assert(!sender_blob->is_compiled(), \"should count return address at least\");\n+      assert(!sender_blob->is_nmethod(), \"should count return address at least\");\n@@ -233,1 +233,1 @@\n-    if (!sender_blob->is_compiled()) {\n+    if (!sender_blob->is_nmethod()) {\n@@ -276,1 +276,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -402,1 +402,1 @@\n-void frame::verify_deopt_original_pc(CompiledMethod* nm, intptr_t* unextended_sp) {\n+void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n@@ -426,2 +426,2 @@\n-    CompiledMethod* sender_cm = _cb->as_compiled_method_or_null();\n-    if (sender_cm != nullptr) {\n+    nmethod* sender_nm = _cb->as_nmethod_or_null();\n+    if (sender_nm != nullptr) {\n@@ -429,3 +429,3 @@\n-      if (sender_cm->is_deopt_entry(_pc) ||\n-          sender_cm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_cm, _unextended_sp);\n+      if (sender_nm->is_deopt_entry(_pc) ||\n+          sender_nm->is_deopt_mh_entry(_pc)) {\n+        verify_deopt_original_pc(sender_nm, _unextended_sp);\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,1 +189,1 @@\n-  static void verify_deopt_original_pc(CompiledMethod* nm, intptr_t* unextended_sp);\n+  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -76,1 +76,1 @@\n-    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb == nullptr || _cb->as_nmethod()->insts_contains_inclusive(_pc),\n@@ -173,1 +173,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -234,2 +234,2 @@\n-  assert(cb()->is_compiled(), \"\");\n-  return (cb()->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  assert(cb()->is_nmethod(), \"\");\n+  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n@@ -416,1 +416,1 @@\n-    if (!_cb->is_compiled()) { \/\/ compiled frames do not use callee-saved registers\n+    if (!_cb->is_nmethod()) { \/\/ compiled frames do not use callee-saved registers\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,0 @@\n-                   notproduct,                                                   \\\n@@ -102,1 +101,0 @@\n-  product(bool, UseRVC, false, \"Use RVC instructions\")                           \\\n@@ -104,0 +102,2 @@\n+  product(bool, UseRVA23U64, false, EXPERIMENTAL, \"Use RVA23U64 profile\")        \\\n+  product(bool, UseRVC, false, \"Use RVC instructions\")                           \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2505,1 +2505,1 @@\n-  \/\/ %%% Could store the aligned, prescaled offset in the klassoop.\n+  \/\/ Could store the aligned, prescaled offset in the klass.\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  int argsize = is_compiled() ? (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n+  int argsize = is_compiled() ? (_cb->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,12 @@\n+void VM_Version::useRVA20U64Profile() {\n+  RV_USE_RVA20U64;\n+}\n+\n+void VM_Version::useRVA22U64Profile() {\n+  RV_USE_RVA22U64;\n+}\n+\n+void VM_Version::useRVA23U64Profile() {\n+  RV_USE_RVA23U64;\n+}\n+\n@@ -64,1 +76,0 @@\n-  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/profiles.adoc#rva20-profiles\n@@ -66,3 +77,1 @@\n-    if (FLAG_IS_DEFAULT(UseRVC)) {\n-      FLAG_SET_DEFAULT(UseRVC, true);\n-    }\n+    useRVA20U64Profile();\n@@ -70,1 +79,0 @@\n-  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/profiles.adoc#rva22-profiles\n@@ -72,30 +80,4 @@\n-    if (FLAG_IS_DEFAULT(UseRVC)) {\n-      FLAG_SET_DEFAULT(UseRVC, true);\n-    }\n-    if (FLAG_IS_DEFAULT(UseZba)) {\n-      FLAG_SET_DEFAULT(UseZba, true);\n-    }\n-    if (FLAG_IS_DEFAULT(UseZbb)) {\n-      FLAG_SET_DEFAULT(UseZbb, true);\n-    }\n-    if (FLAG_IS_DEFAULT(UseZbs)) {\n-      FLAG_SET_DEFAULT(UseZbs, true);\n-    }\n-    if (FLAG_IS_DEFAULT(UseZfh)) {\n-      FLAG_SET_DEFAULT(UseZfh, true);\n-    }\n-    if (FLAG_IS_DEFAULT(UseZic64b)) {\n-      FLAG_SET_DEFAULT(UseZic64b, true);\n-    }\n-    if (FLAG_IS_DEFAULT(UseZicbom)) {\n-      FLAG_SET_DEFAULT(UseZicbom, true);\n-    }\n-    if (FLAG_IS_DEFAULT(UseZicbop)) {\n-      FLAG_SET_DEFAULT(UseZicbop, true);\n-    }\n-    if (FLAG_IS_DEFAULT(UseZicboz)) {\n-      FLAG_SET_DEFAULT(UseZicboz, true);\n-    }\n-    if (FLAG_IS_DEFAULT(UseZihintpause)) {\n-      FLAG_SET_DEFAULT(UseZihintpause, true);\n-    }\n+    useRVA22U64Profile();\n+  }\n+  if (UseRVA23U64) {\n+    useRVA23U64Profile();\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":17,"deletions":35,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+    void disable_feature() {\n+      _enabled = false;\n+      _value = -1;\n+    }\n@@ -72,10 +76,15 @@\n-  #define UPDATE_DEFAULT(flag)        \\\n-  void update_flag() {                \\\n-      assert(enabled(), \"Must be.\");  \\\n-      if (FLAG_IS_DEFAULT(flag)) {    \\\n-        FLAG_SET_DEFAULT(flag, true); \\\n-      }                               \\\n-  }                                   \\\n-\n-  #define NO_UPDATE_DEFAULT           \\\n-  void update_flag() {}               \\\n+  #define UPDATE_DEFAULT(flag)             \\\n+  void update_flag() {                     \\\n+      assert(enabled(), \"Must be.\");       \\\n+      if (FLAG_IS_DEFAULT(flag)) {         \\\n+        FLAG_SET_DEFAULT(flag, true);      \\\n+      } else {                             \\\n+        \/* Sync CPU features with flags *\/ \\\n+        if (!flag) {                       \\\n+          disable_feature();               \\\n+        }                                  \\\n+      }                                    \\\n+  }                                        \\\n+\n+  #define NO_UPDATE_DEFAULT                \\\n+  void update_flag() {}                    \\\n@@ -156,0 +165,1 @@\n+  decl(ext_Zvkn        , \"Zvkn\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZvkn))        \\\n@@ -173,0 +183,46 @@\n+  \/\/ enable extensions based on profile, current supported profiles:\n+  \/\/  RVA20U64\n+  \/\/  RVA22U64\n+  \/\/  RVA23U64\n+  \/\/ NOTE: we only enable the mandatory extensions, not optional extension.\n+  #define RV_ENABLE_EXTENSION(UseExtension)     \\\n+    if (FLAG_IS_DEFAULT(UseExtension)) {        \\\n+      FLAG_SET_DEFAULT(UseExtension, true);     \\\n+    }                                           \\\n+\n+  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/profiles.adoc#rva20-profiles\n+  #define RV_USE_RVA20U64                            \\\n+    RV_ENABLE_EXTENSION(UseRVC)                      \\\n+\n+  static void useRVA20U64Profile();\n+\n+  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/profiles.adoc#rva22-profiles\n+  #define RV_USE_RVA22U64                            \\\n+    RV_ENABLE_EXTENSION(UseRVC)                      \\\n+    RV_ENABLE_EXTENSION(UseZba)                      \\\n+    RV_ENABLE_EXTENSION(UseZbb)                      \\\n+    RV_ENABLE_EXTENSION(UseZbs)                      \\\n+    RV_ENABLE_EXTENSION(UseZic64b)                   \\\n+    RV_ENABLE_EXTENSION(UseZicbom)                   \\\n+    RV_ENABLE_EXTENSION(UseZicbop)                   \\\n+    RV_ENABLE_EXTENSION(UseZicboz)                   \\\n+    RV_ENABLE_EXTENSION(UseZihintpause)              \\\n+\n+  static void useRVA22U64Profile();\n+\n+  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/rva23-profile.adoc#rva23u64-profile\n+  #define RV_USE_RVA23U64                           \\\n+    RV_ENABLE_EXTENSION(UseRVC)                     \\\n+    RV_ENABLE_EXTENSION(UseRVV)                     \\\n+    RV_ENABLE_EXTENSION(UseZba)                     \\\n+    RV_ENABLE_EXTENSION(UseZbb)                     \\\n+    RV_ENABLE_EXTENSION(UseZbs)                     \\\n+    RV_ENABLE_EXTENSION(UseZcb)                     \\\n+    RV_ENABLE_EXTENSION(UseZic64b)                  \\\n+    RV_ENABLE_EXTENSION(UseZicbom)                  \\\n+    RV_ENABLE_EXTENSION(UseZicbop)                  \\\n+    RV_ENABLE_EXTENSION(UseZicboz)                  \\\n+    RV_ENABLE_EXTENSION(UseZihintpause)             \\\n+\n+  static void useRVA23U64Profile();\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":66,"deletions":10,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,1 @@\n-        case 4: __ mem2reg_opt(as_Register(to_reg), from_addr, false);break;\n+        case 4: __ mem2reg_signed_opt(as_Register(to_reg), from_addr);break;\n","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -278,1 +278,1 @@\n-  assert(!is_compiled_frame() || !_cb->as_compiled_method()->is_deopt_entry(_pc), \"must be\");\n+  assert(!is_compiled_frame() || !_cb->as_nmethod()->is_deopt_entry(_pc), \"must be\");\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -63,1 +63,1 @@\n-    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb == nullptr || _cb->as_nmethod()->insts_contains_inclusive(_pc),\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,0 @@\n-                   notproduct,                                                \\\n","filename":"src\/hotspot\/cpu\/s390\/globals_s390.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -3199,0 +3199,4 @@\n+  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n+\n+  assert_different_registers(temp1, temp2, oop, box);\n+\n@@ -3202,1 +3206,1 @@\n-  z_lg(displacedHeader, 0, oop);\n+  z_lg(displacedHeader, hdr_offset, oop);\n@@ -3205,2 +3209,2 @@\n-    load_klass(Z_R1_scratch, oop);\n-    z_l(Z_R1_scratch, Address(Z_R1_scratch, Klass::access_flags_offset()));\n+    load_klass(temp, oop);\n+    z_l(temp, Address(temp, Klass::access_flags_offset()));\n@@ -3208,1 +3212,1 @@\n-    z_nilh(Z_R1_scratch, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_nilh(temp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n@@ -3215,3 +3219,2 @@\n-  z_lgr(temp, displacedHeader);\n-  z_nill(temp, markWord::monitor_value);\n-  z_brne(object_has_monitor);\n+  z_tmll(displacedHeader, markWord::monitor_value);\n+  z_brnaz(object_has_monitor);\n@@ -3221,0 +3224,1 @@\n+    \/\/ From loading the markWord, we know that oop != nullptr\n@@ -3232,6 +3236,3 @@\n-    \/\/ Memory Fence (in cmpxchgd)\n-    \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n-\n-    \/\/ If the compare-and-swap succeeded, then we found an unlocked object and we\n-    \/\/ have now locked it.\n-    z_csg(displacedHeader, box, 0, oop);\n+    \/\/ Compare object markWord with mark and if equal, exchange box with object markWork.\n+    \/\/ If the compare-and-swap succeeds, then we found an unlocked object and have now locked it.\n+    z_csg(displacedHeader, box, hdr_offset, oop);\n@@ -3241,2 +3242,4 @@\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n+    \/\/ We did not see an unlocked object\n+    \/\/ currentHeader contains what is currently stored in the oop's markWord.\n+    \/\/ We might have a recursive case. Verify by checking if the owner is self.\n+    \/\/ To do so, compare the value in the markWord (currentHeader) with the stack pointer.\n@@ -3247,2 +3250,4 @@\n-    \/\/   z_brne(done);\n-    \/\/   z_release();\n+\n+    \/\/ result zero: owner is self -> recursive lock. Indicate that by storing 0 in the box.\n+    \/\/ result not-zero: attempt failed. We don't hold the lock -> go for slow case.\n+\n@@ -3258,0 +3263,2 @@\n+  bind(object_has_monitor);\n+\n@@ -3260,1 +3267,0 @@\n-  bind(object_has_monitor);\n@@ -3263,1 +3269,1 @@\n-  \/\/\n+\n@@ -3265,1 +3271,0 @@\n-  z_lghi(zero, 0);\n@@ -3267,0 +3272,2 @@\n+  \/\/ Otherwise, register zero is filled with the current owner.\n+  z_lghi(zero, 0);\n@@ -3272,8 +3279,12 @@\n-#ifdef ASSERT\n-  z_brne(done);\n-  \/\/ We've acquired the monitor, check some invariants.\n-  \/\/ Invariant 1: _recursions should be 0.\n-  asm_assert_mem8_is_zero(OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions), monitor_tagged,\n-                          \"monitor->_recursions should be 0\", -1);\n-  z_ltgr(zero, zero); \/\/ Set CR=EQ.\n-#endif\n+\n+  z_bre(done); \/\/ acquired the lock for the first time.\n+\n+  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n+  \/\/ Check if we are already the owner (recursive lock)\n+  z_cgr(Z_thread, zero); \/\/ owner is stored in zero by \"z_csg\" above\n+  z_brne(done); \/\/ not a recursive lock\n+\n+  \/\/ Current thread already owns the lock. Just increment recursion count.\n+  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+  z_cgr(zero, zero); \/\/ set the CC to EQUAL\n+  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n@@ -3292,1 +3303,0 @@\n-  Register monitor = temp2;\n@@ -3296,1 +3306,3 @@\n-  Label done, object_has_monitor;\n+  assert_different_registers(temp1, temp2, oop, box);\n+\n+  Label done, object_has_monitor, not_recursive;\n@@ -3311,5 +3323,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    z_lgr(temp, currentHeader);\n-  }\n-  z_nill(currentHeader, markWord::monitor_value);\n-  z_brne(object_has_monitor);\n+\n+  z_tmll(currentHeader, markWord::monitor_value);\n+  z_brnaz(object_has_monitor);\n@@ -3322,1 +3332,1 @@\n-    \/\/ Check if it is still a light weight lock, this is true if we see\n+    \/\/ Check if it is still a lightweight lock, this is true if we see\n@@ -3326,1 +3336,1 @@\n-    z_csg(currentHeader, displacedHeader, 0, oop);\n+    z_csg(currentHeader, displacedHeader, hdr_offset, oop);\n@@ -3331,4 +3341,1 @@\n-    \/\/ don't load currentHead again from stack-top after monitor check, as it is possible\n-    \/\/ some other thread modified it.\n-    \/\/ currentHeader is altered, but it's contents are copied in temp as well\n-    lightweight_unlock(oop, temp, currentHeader, done);\n+    lightweight_unlock(oop, currentHeader, displacedHeader, done);\n@@ -3343,4 +3350,2 @@\n-  z_lg(currentHeader, hdr_offset, oop);    \/\/ CurrentHeader is tagged with monitor_value set.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_brne(done);\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+\n+  z_cg(Z_thread, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n@@ -3348,0 +3353,13 @@\n+\n+  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n+  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+\n+  \/\/ Recursive inflated unlock\n+  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n+  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n+  z_bru(done);\n+\n+  bind(not_recursive);\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":64,"deletions":46,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -543,1 +543,1 @@\n-void NativeMovConstReg::set_pcrel_addr(intptr_t newTarget, CompiledMethod *passed_nm \/* = nullptr *\/) {\n+void NativeMovConstReg::set_pcrel_addr(intptr_t newTarget, nmethod *passed_nm \/* = nullptr *\/) {\n@@ -568,1 +568,1 @@\n-void NativeMovConstReg::set_pcrel_data(intptr_t newData, CompiledMethod *passed_nm \/* = nullptr *\/) {\n+void NativeMovConstReg::set_pcrel_data(intptr_t newData, nmethod *passed_nm \/* = nullptr *\/) {\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -489,2 +489,2 @@\n-  void set_pcrel_addr(intptr_t addr, CompiledMethod *nm = nullptr);\n-  void set_pcrel_data(intptr_t data, CompiledMethod *nm = nullptr);\n+  void set_pcrel_addr(intptr_t addr, nmethod *nm = nullptr);\n+  void set_pcrel_data(intptr_t data, nmethod *nm = nullptr);\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2034,1 +2034,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, src, src, VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n@@ -2093,1 +2093,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, src, src, VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1025,2 +1025,3 @@\n-  jccb(Assembler::zero, zf_correct);\n-  stop(\"Fast Lock ZF != 1\");\n+  Label zf_bad_zero;\n+  jcc(Assembler::zero, zf_correct);\n+  jmp(zf_bad_zero);\n@@ -1032,1 +1033,1 @@\n-  jccb(Assembler::notZero, zf_correct);\n+  jcc(Assembler::notZero, zf_correct);\n@@ -1034,0 +1035,2 @@\n+  bind(zf_bad_zero);\n+  stop(\"Fast Lock ZF != 1\");\n@@ -1164,1 +1167,1 @@\n-  jccb(Assembler::zero, zf_correct);\n+  jcc(Assembler::zero, zf_correct);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n+  assert(cb->as_nmethod()->method()->is_continuation_enter_intrinsic(), \"\");\n","filename":"src\/hotspot\/cpu\/x86\/continuationEntry_x86.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n@@ -216,1 +216,1 @@\n-    CompiledMethod* nm = sender_blob->as_compiled_method_or_null();\n+    nmethod* nm = sender_blob->as_nmethod_or_null();\n@@ -228,1 +228,1 @@\n-      assert(!sender_blob->is_compiled(), \"should count return address at least\");\n+      assert(!sender_blob->is_nmethod(), \"should count return address at least\");\n@@ -237,1 +237,1 @@\n-    if (!sender_blob->is_compiled()) {\n+    if (!sender_blob->is_nmethod()) {\n@@ -286,1 +286,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -294,1 +294,1 @@\n-  assert(!is_compiled_frame() || !_cb->as_compiled_method()->is_deopt_entry(_pc), \"must be\");\n+  assert(!is_compiled_frame() || !_cb->as_nmethod()->is_deopt_entry(_pc), \"must be\");\n@@ -418,1 +418,1 @@\n-void frame::verify_deopt_original_pc(CompiledMethod* nm, intptr_t* unextended_sp) {\n+void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n@@ -441,2 +441,2 @@\n-    CompiledMethod* sender_cm = _cb->as_compiled_method_or_null();\n-    if (sender_cm != nullptr) {\n+    nmethod* sender_nm = _cb->as_nmethod_or_null();\n+    if (sender_nm != nullptr) {\n@@ -444,3 +444,3 @@\n-      if (sender_cm->is_deopt_entry(_pc) ||\n-          sender_cm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_cm, _unextended_sp);\n+      if (sender_nm->is_deopt_entry(_pc) ||\n+          sender_nm->is_deopt_mh_entry(_pc)) {\n+        verify_deopt_original_pc(sender_nm, _unextended_sp);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-  static void verify_deopt_original_pc(CompiledMethod* nm, intptr_t* unextended_sp);\n+  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -73,1 +73,1 @@\n-    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb == nullptr || _cb->as_nmethod()->insts_contains_inclusive(_pc),\n@@ -167,1 +167,1 @@\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  address original_pc = get_deopt_original_pc();\n@@ -229,2 +229,2 @@\n-  assert(cb()->is_compiled(), \"\");\n-  return (cb()->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  assert(cb()->is_nmethod(), \"\");\n+  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n@@ -400,1 +400,1 @@\n-    if (!_cb->is_compiled()) { \/\/ compiled frames do not use callee-saved registers\n+    if (!_cb->is_nmethod()) { \/\/ compiled frames do not use callee-saved registers\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -272,2 +272,0 @@\n-  \/\/ Generated code assumes that buffer index is pointer sized.\n-  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n@@ -324,0 +322,3 @@\n+  \/\/ The code below assumes that buffer index is pointer sized.\n+  STATIC_ASSERT(in_bytes(G1DirtyCardQueue::byte_width_of_index()) == sizeof(intptr_t));\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,0 @@\n-                   notproduct,                                              \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4342,1 +4342,1 @@\n-  \/\/ %%% Could store the aligned, prescaled offset in the klassoop.\n+  \/\/ Could store the aligned, prescaled offset in the klass.\n@@ -5782,1 +5782,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512vlbw(), \"\");\n+  assert(UseAVX > 2 && VM_Version::supports_avx512vl(), \"\");\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  int argsize = is_compiled() ? (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n+  int argsize = is_compiled() ? (_cb->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n","filename":"src\/hotspot\/cpu\/x86\/stackChunkFrameStream_x86.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2954,0 +2954,2 @@\n+    if (sef_cpuid7_ecx.bits.gfni != 0)\n+        result |= CPU_GFNI;\n@@ -2979,2 +2981,0 @@\n-      if (sef_cpuid7_ecx.bits.gfni != 0)\n-        result |= CPU_GFNI;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1753,1 +1753,0 @@\n-    case Op_ClearArray:\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -11473,2 +11473,2 @@\n-\/\/ fast clearing of an array\n-\/\/ Small ClearArray non-AVX512.\n+\/\/ Fast clearing of an array\n+\/\/ Small non-constant length ClearArray for non-AVX512 targets.\n@@ -11534,1 +11534,1 @@\n-\/\/ Small ClearArray AVX512 non-constant length.\n+\/\/ Small non-constant length ClearArray for AVX512 targets.\n@@ -11595,1 +11595,1 @@\n-\/\/ Large ClearArray non-AVX512.\n+\/\/ Large non-constant length ClearArray for non-AVX512 targets.\n@@ -11645,1 +11645,1 @@\n-\/\/ Large ClearArray AVX512.\n+\/\/ Large non-constant length ClearArray for AVX512 targets.\n@@ -11695,1 +11695,1 @@\n-\/\/ Small ClearArray AVX512 constant length.\n+\/\/ Small constant length ClearArray for AVX512 targets.\n@@ -11698,2 +11698,1 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() &&\n-               ((UseAVX > 2) && VM_Version::supports_avx512vlbw()));\n+  predicate(!((ClearArrayNode*)n)->is_large() && (MaxVectorSize >= 32) && VM_Version::supports_avx512vl());\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -5665,1 +5665,1 @@\n-instruct bytes_reversebit_int_gfni(rRegI dst, rRegI src, regF xtmp1, regF xtmp2, rRegL rtmp, rFlagsReg cr) %{\n+instruct bytes_reversebit_int_gfni(rRegI dst, rRegI src, vlRegF xtmp1, vlRegF xtmp2, rRegL rtmp, rFlagsReg cr) %{\n@@ -5687,1 +5687,1 @@\n-instruct bytes_reversebit_long_gfni(rRegL dst, rRegL src, regD xtmp1, regD xtmp2, rRegL rtmp, rFlagsReg cr) %{\n+instruct bytes_reversebit_long_gfni(rRegL dst, rRegL src, vlRegD xtmp1, vlRegD xtmp2, rRegL rtmp, rFlagsReg cr) %{\n@@ -9962,0 +9962,1 @@\n+  predicate(UseAVX == 0);\n@@ -9984,0 +9985,1 @@\n+  predicate(UseAVX == 0);\n@@ -10060,1 +10062,1 @@\n-instruct convI2F_reg_reg(regF dst, rRegI src)\n+instruct convI2F_reg_reg(vlRegF dst, rRegI src)\n@@ -10067,0 +10069,3 @@\n+    if (UseAVX > 0) {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n@@ -10074,0 +10079,1 @@\n+  predicate(UseAVX == 0);\n@@ -10083,1 +10089,1 @@\n-instruct convI2D_reg_reg(regD dst, rRegI src)\n+instruct convI2D_reg_reg(vlRegD dst, rRegI src)\n@@ -10090,0 +10096,3 @@\n+    if (UseAVX > 0) {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n@@ -10097,0 +10106,1 @@\n+  predicate(UseAVX == 0);\n@@ -10134,1 +10144,1 @@\n-instruct convL2F_reg_reg(regF dst, rRegL src)\n+instruct convL2F_reg_reg(vlRegF dst, rRegL src)\n@@ -10140,0 +10150,3 @@\n+    if (UseAVX > 0) {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n@@ -10147,0 +10160,1 @@\n+  predicate(UseAVX == 0);\n@@ -10156,1 +10170,1 @@\n-instruct convL2D_reg_reg(regD dst, rRegL src)\n+instruct convL2D_reg_reg(vlRegD dst, rRegL src)\n@@ -10162,0 +10176,3 @@\n+    if (UseAVX > 0) {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n@@ -10169,0 +10186,1 @@\n+  predicate(UseAVX == 0);\n@@ -10395,1 +10413,1 @@\n-\/\/ Small ClearArray non-AVX512.\n+\/\/ Small non-constant lenght ClearArray for non-AVX512 targets.\n@@ -10455,1 +10473,1 @@\n-\/\/ Small ClearArray AVX512 non-constant length.\n+\/\/ Small non-constant length ClearArray for AVX512 targets.\n@@ -10516,1 +10534,1 @@\n-\/\/ Large ClearArray non-AVX512.\n+\/\/ Large non-constant length ClearArray for non-AVX512 targets.\n@@ -10567,1 +10585,1 @@\n-\/\/ Large ClearArray AVX512.\n+\/\/ Large non-constant length ClearArray for AVX512 targets.\n@@ -10618,1 +10636,1 @@\n-\/\/ Small ClearArray AVX512 constant length.\n+\/\/ Small constant length ClearArray for AVX512 targets.\n@@ -10621,2 +10639,1 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() &&\n-              ((UseAVX > 2) && VM_Version::supports_avx512vlbw()));\n+  predicate(!((ClearArrayNode*)n)->is_large() && (MaxVectorSize >= 32) && VM_Version::supports_avx512vl());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,0 @@\n-                   notproduct,                                              \\\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-                         notproduct,                                                \\\n","filename":"src\/hotspot\/os\/aix\/globals_aix.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/log.hpp\"\n@@ -79,1 +80,1 @@\n-    trcVerbose(\"Cannot load %s (error: %s)\", libperfstat, ebuf);\n+    log_warning(os)(\"Cannot load %s (error: %s)\", libperfstat, ebuf);\n@@ -216,1 +217,1 @@\n-      trcVerbose(\"perfstat_cpu_total() failed (errno=%d)\", errno);\n+      log_warning(os)(\"perfstat_cpu_total() failed (errno=%d)\", errno);\n@@ -251,1 +252,1 @@\n-      trcVerbose(\"perfstat_partition_total() failed (errno=%d)\", errno);\n+      log_warning(os)(\"perfstat_partition_total() failed (errno=%d)\", errno);\n@@ -317,1 +318,1 @@\n-    trcVerbose(\"perfstat_wpar_total() failed (errno=%d)\", errno);\n+    log_warning(os)(\"perfstat_wpar_total() failed (errno=%d)\", errno);\n","filename":"src\/hotspot\/os\/aix\/libperfstat_aix.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -38,0 +38,1 @@\n+#include \"logging\/log.hpp\"\n@@ -197,1 +198,1 @@\n-        trcVerbose(\"loadquery failed (%d)\", errno);\n+        log_warning(os)(\"loadquery failed (%d)\", errno);\n@@ -214,1 +215,1 @@\n-      trcVerbose(\"OOM.\");\n+      log_warning(os)(\"OOM.\");\n@@ -227,1 +228,1 @@\n-      trcVerbose(\"OOM.\");\n+      log_warning(os)(\"OOM.\");\n@@ -249,1 +250,1 @@\n-        trcVerbose(\"OOM.\");\n+        log_warning(os)(\"OOM.\");\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-    trcVerbose(\"vmgetinfo(VM_PAGE_INFO) failed (errno: %d)\", errno);\n+    log_warning(pagesize)(\"vmgetinfo(VM_PAGE_INFO) failed (errno: %d)\", errno);\n@@ -445,2 +445,1 @@\n-      trcVerbose(\"vmgetinfo(VMINFO_GETPSIZES) failed (errno: %d)\", errno);\n-      trcVerbose(\"disabling multipage support.\");\n+      log_warning(pagesize)(\"vmgetinfo(VMINFO_GETPSIZES) failed (errno: %d), disabling multipage support.\", errno);\n@@ -452,1 +451,1 @@\n-    trcVerbose(\"vmgetinfo(.., VMINFO_GETPSIZES, ...) returns %d supported page sizes: \", num_psizes);\n+    log_info(pagesize)(\"vmgetinfo(.., VMINFO_GETPSIZES, ...) returns %d supported page sizes: \", num_psizes);\n@@ -474,1 +473,1 @@\n-        trcVerbose(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n+        log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n@@ -482,1 +481,1 @@\n-          trcVerbose(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+          log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n@@ -612,1 +611,1 @@\n-    trcVerbose(\"perfstat_memory_total() failed (errno=%d)\", errno);\n+    log_warning(os)(\"perfstat_memory_total() failed (errno=%d)\", errno);\n@@ -1604,1 +1603,1 @@\n-    trcVerbose(\"my_disclaim64(\" PTR_FORMAT \", \" UINTX_FORMAT \") failed.\\n\", p2i(addr), size);\n+    log_warning(os)(\"my_disclaim64(\" PTR_FORMAT \", \" UINTX_FORMAT \") failed.\\n\", p2i(addr), size);\n@@ -1794,1 +1793,1 @@\n-  trcVerbose(\"commit_memory [\" PTR_FORMAT \" - \" PTR_FORMAT \"].\", p2i(addr), p2i(addr + size - 1));\n+  log_info(os)(\"commit_memory [\" PTR_FORMAT \" - \" PTR_FORMAT \"].\", p2i(addr), p2i(addr + size - 1));\n@@ -2174,1 +2173,1 @@\n-    trcVerbose(\"Could not change priority for thread %d to %d (error %d, %s)\",\n+    log_warning(os)(\"Could not change priority for thread %d to %d (error %d, %s)\",\n@@ -2667,1 +2666,1 @@\n-    trcVerbose(\"uname failed (%d)\", errno);\n+    log_warning(os)(\"uname failed (%d)\", errno);\n@@ -2670,1 +2669,1 @@\n-    trcVerbose(\"uname says: sysname \\\"%s\\\" version \\\"%s\\\" release \\\"%s\\\" \"\n+    log_info(os)(\"uname says: sysname \\\"%s\\\" version \\\"%s\\\" release \\\"%s\\\" \"\n@@ -2686,1 +2685,1 @@\n-        trcVerbose(\"AIX releases older than AIX 7.1 are not supported.\");\n+        log_warning(os)(\"AIX releases older than AIX 7.1 are not supported.\");\n@@ -2695,1 +2694,1 @@\n-    trcVerbose(\"We run on %s %s\", name_str, ver_str);\n+    log_info(os)(\"We run on %s %s\", name_str, ver_str);\n@@ -2720,1 +2719,1 @@\n-    trcVerbose(\"*** Unsupported mode! Please remove EXTSHM from your environment! ***\");\n+    log_warning(os)(\"*** Unsupported mode! Please remove EXTSHM from your environment! ***\");\n@@ -2744,1 +2743,1 @@\n-    trcVerbose(\"Unsupported setting: XPG_SUS_ENV=ON\");\n+    log_warning(os)(\"Unsupported setting: XPG_SUS_ENV=ON\");\n@@ -2763,1 +2762,1 @@\n-    trcVerbose(\"libperfstat initialization failed.\");\n+    log_warning(os)(\"libperfstat initialization failed.\");\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-                         notproduct,                                    \\\n","filename":"src\/hotspot\/os\/bsd\/globals_bsd.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-                         notproduct,                                    \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -380,10 +380,3 @@\n-\n-  char* walker = buffer.release;\n-  long* set_v = major;\n-  while (*minor == -1 && walker != nullptr) {\n-    if (isdigit(walker[0])) {\n-      *set_v = strtol(walker, &walker, 10);\n-      set_v = minor;\n-    } else {\n-      ++walker;\n-    }\n+  int nr_matched = sscanf(buffer.release, \"%ld.%ld\", major, minor);\n+  if (nr_matched != 2) {\n+    log_warning(os)(\"Parsing kernel version failed, expected 2 version numbers, only matched %d\", nr_matched);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -624,3 +624,8 @@\n-  uname(&name);\n-  jio_snprintf(buf, buflen, \"%s\", name.nodename);\n-  return true;\n+  int retcode = uname(&name);\n+  if (retcode != -1) {\n+    jio_snprintf(buf, buflen, \"%s\", name.nodename);\n+    return true;\n+  }\n+  const char* errmsg = os::strerror(errno);\n+  log_warning(os)(\"Failed to get host name, error message: %s\", errmsg);\n+  return false;\n@@ -725,1 +730,10 @@\n-  return dlsym(handle, name);\n+  ::dlerror(); \/\/ Clear any previous error\n+  void* ret = ::dlsym(handle, name);\n+  if (ret == nullptr) {\n+    const char* tmp = ::dlerror();\n+    \/\/ It is possible that we found a NULL symbol, hence no error.\n+    if (tmp != nullptr) {\n+      log_debug(os)(\"Symbol %s not found in dll: %s\", name, tmp);\n+    }\n+  }\n+  return ret;\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"code\/compiledMethod.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -616,1 +616,1 @@\n-      if (cb != nullptr && cb->is_compiled()) {\n+      if (cb != nullptr && cb->is_nmethod()) {\n@@ -618,5 +618,5 @@\n-        CompiledMethod* cm = cb->as_compiled_method();\n-        assert(cm->insts_contains_inclusive(pc), \"\");\n-        address deopt = cm->is_method_handle_return(pc) ?\n-          cm->deopt_mh_handler_begin() :\n-          cm->deopt_handler_begin();\n+        nmethod* nm = cb->as_nmethod();\n+        assert(nm->insts_contains_inclusive(pc), \"\");\n+        address deopt = nm->is_method_handle_return(pc) ?\n+          nm->deopt_mh_handler_begin() :\n+          nm->deopt_handler_begin();\n@@ -626,1 +626,1 @@\n-        cm->set_original_pc(&fr, pc);\n+        nm->set_original_pc(&fr, pc);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-                         notproduct,                                      \\\n","filename":"src\/hotspot\/os\/windows\/globals_windows.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1283,1 +1283,9 @@\n-  return (void*)::GetProcAddress((HMODULE)lib, name);\n+  ::SetLastError(0); \/\/ Clear old pending errors\n+  void* ret = ::GetProcAddress((HMODULE)lib, name);\n+  if (ret == nullptr) {\n+    char buf[512];\n+    if (os::lasterror(buf, sizeof(buf)) > 0) {\n+      log_debug(os)(\"Symbol %s not found in dll: %s\", name, buf);\n+    }\n+  }\n+  return ret;\n@@ -2784,1 +2792,1 @@\n-      CompiledMethod* nm = nullptr;\n+      nmethod* nm = nullptr;\n@@ -2787,1 +2795,1 @@\n-        nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+        nm = (cb != nullptr) ? cb->as_nmethod_or_null() : nullptr;\n@@ -2836,2 +2844,2 @@\n-        if (cb != nullptr && cb->is_compiled()) {\n-          CompiledMethod* cm = cb->as_compiled_method();\n+        if (cb != nullptr && cb->is_nmethod()) {\n+          nmethod* nm = cb->as_nmethod();\n@@ -2839,5 +2847,5 @@\n-          address deopt = cm->is_method_handle_return(pc) ?\n-            cm->deopt_mh_handler_begin() :\n-            cm->deopt_handler_begin();\n-          assert(cm->insts_contains_inclusive(pc), \"\");\n-          cm->set_original_pc(&fr, pc);\n+          address deopt = nm->is_method_handle_return(pc) ?\n+            nm->deopt_mh_handler_begin() :\n+            nm->deopt_handler_begin();\n+          assert(nm->insts_contains_inclusive(pc), \"\");\n+          nm->set_original_pc(&fr, pc);\n@@ -4260,1 +4268,1 @@\n-  os::infinite_sleep();\n+  ::abort();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  os::infinite_sleep();\n+  ::abort();\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-               cb->is_compiled()) {\n+               cb->is_nmethod()) {\n@@ -252,1 +252,1 @@\n-               cb->is_compiled()) {\n+               cb->is_nmethod()) {\n@@ -342,1 +342,1 @@\n-        CompiledMethod* nm = cb ? cb->as_compiled_method_or_null() : nullptr;\n+        nmethod* nm = cb ? cb->as_nmethod_or_null() : nullptr;\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,1 +259,1 @@\n-        CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+        nmethod* nm = (cb != nullptr) ? cb->as_nmethod_or_null() : nullptr;\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -443,1 +443,1 @@\n-        CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+        nmethod* nm = (cb != nullptr) ? cb->as_nmethod_or_null() : nullptr;\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,1 +242,1 @@\n-        CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+        nmethod* nm = (cb != nullptr) ? cb->as_nmethod_or_null() : nullptr;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -326,1 +326,1 @@\n-        CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+        nmethod* nm = (cb != nullptr) ? cb->as_nmethod_or_null() : nullptr;\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,1 @@\n-               cb->is_compiled()) {\n+               cb->is_nmethod()) {\n@@ -278,1 +278,1 @@\n-               cb->is_compiled()) {\n+               cb->is_nmethod()) {\n@@ -357,1 +357,1 @@\n-        CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+        nmethod* nm = (cb != nullptr) ? cb->as_nmethod_or_null() : nullptr;\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,1 +232,1 @@\n-        CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+        nmethod* nm = (cb != nullptr) ? cb->as_nmethod_or_null() : nullptr;\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,0 +118,9 @@\n+      \/\/ Change flag default\n+      _feature_list[i]->update_flag();\n+\n+      \/\/ Feature will be disabled by update_flag() if flag\n+      \/\/ is set to false by the user on the command line.\n+      if (!_feature_list[i]->enabled()) {\n+        continue;\n+      }\n+\n@@ -142,2 +151,0 @@\n-      \/\/ Change flag default\n-      _feature_list[i]->update_flag();\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,1 @@\n-        CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+        nmethod* nm = (cb != nullptr) ? cb->as_nmethod_or_null() : nullptr;\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-        CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+        nmethod* nm = (cb != nullptr) ? cb->as_nmethod_or_null() : nullptr;\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,5 @@\n-\/\/    _insts._start ->              +----------------+\n+\/\/    _consts._start ->             +----------------+\n+\/\/                                  |                |\n+\/\/                                  |   Constants    |\n+\/\/                                  |                |\n+\/\/    _insts._start ->              |----------------|\n@@ -77,4 +81,0 @@\n-\/\/    _consts._start ->             |----------------|\n-\/\/                                  |                |\n-\/\/                                  |   Constants    |\n-\/\/                                  |                |\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1326,3 +1326,3 @@\n-  Klass* univ_klass_obj = Universe::byteArrayKlassObj();\n-  assert(univ_klass_obj->modifier_flags() == (JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC), \"Sanity\");\n-  LIR_Opr prim_klass = LIR_OprFact::metadataConst(univ_klass_obj);\n+  Klass* univ_klass = Universe::byteArrayKlass();\n+  assert(univ_klass->modifier_flags() == (JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC), \"Sanity\");\n+  LIR_Opr prim_klass = LIR_OprFact::metadataConst(univ_klass);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-                 notproduct,                                                \\\n@@ -43,1 +42,1 @@\n-  notproduct(bool, PrintC1Statistics, false,                                \\\n+  develop(bool, PrintC1Statistics, false,                                   \\\n@@ -46,1 +45,1 @@\n-  notproduct(bool, PrintInitialBlockList, false,                            \\\n+  develop(bool, PrintInitialBlockList, false,                               \\\n@@ -49,1 +48,1 @@\n-  notproduct(bool, PrintCFG, false,                                         \\\n+  develop(bool, PrintCFG, false,                                            \\\n@@ -52,1 +51,1 @@\n-  notproduct(bool, PrintCFG0, false,                                        \\\n+  develop(bool, PrintCFG0, false,                                           \\\n@@ -55,1 +54,1 @@\n-  notproduct(bool, PrintCFG1, false,                                        \\\n+  develop(bool, PrintCFG1, false,                                           \\\n@@ -58,1 +57,1 @@\n-  notproduct(bool, PrintCFG2, false,                                        \\\n+  develop(bool, PrintCFG2, false,                                           \\\n@@ -61,1 +60,1 @@\n-  notproduct(bool, PrintIRDuringConstruction, false,                        \\\n+  develop(bool, PrintIRDuringConstruction, false,                           \\\n@@ -64,1 +63,1 @@\n-  notproduct(bool, PrintPhiFunctions, false,                                \\\n+  develop(bool, PrintPhiFunctions, false,                                   \\\n@@ -67,1 +66,1 @@\n-  notproduct(bool, PrintIR, false,                                          \\\n+  develop(bool, PrintIR, false,                                             \\\n@@ -70,1 +69,1 @@\n-  notproduct(bool, PrintIR0, false,                                         \\\n+  develop(bool, PrintIR0, false,                                            \\\n@@ -73,1 +72,1 @@\n-  notproduct(bool, PrintIR1, false,                                         \\\n+  develop(bool, PrintIR1, false,                                            \\\n@@ -76,1 +75,1 @@\n-  notproduct(bool, PrintIR2, false,                                         \\\n+  develop(bool, PrintIR2, false,                                            \\\n@@ -79,1 +78,1 @@\n-  notproduct(bool, PrintSimpleStubs, false,                                 \\\n+  develop(bool, PrintSimpleStubs, false,                                    \\\n@@ -191,1 +190,1 @@\n-  notproduct(bool, PrintIRWithLIR, false,                                   \\\n+  develop(bool, PrintIRWithLIR, false,                                      \\\n@@ -194,1 +193,1 @@\n-  notproduct(bool, PrintLIRWithAssembly, false,                             \\\n+  develop(bool, PrintLIRWithAssembly, false,                                \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-\n@@ -65,1 +64,1 @@\n-GrowableArrayCHeap<int, mtClassShared>* ArchiveHeapWriter::_source_objs_order;\n+GrowableArrayCHeap<ArchiveHeapWriter::HeapObjOrder, mtClassShared>* ArchiveHeapWriter::_source_objs_order;\n@@ -82,1 +81,1 @@\n-    _buffer_offset_to_source_obj_table = new BufferOffsetToSourceObjectTable();\n+    _buffer_offset_to_source_obj_table = new BufferOffsetToSourceObjectTable(\/*size (prime)*\/36137, \/*max size*\/1 * M);\n@@ -89,1 +88,0 @@\n-    _source_objs_order = new GrowableArrayCHeap<int, mtClassShared>(10000);\n@@ -97,1 +95,0 @@\n-  _source_objs_order->append(_source_objs->length());\n@@ -191,1 +188,1 @@\n-  Klass* k = Universe::objectArrayKlassObj(); \/\/ already relocated to point to archived klass\n+  Klass* k = Universe::objectArrayKlass(); \/\/ already relocated to point to archived klass\n@@ -234,2 +231,2 @@\n-  bool has_o_ptr = HeapShared::has_oop_pointers(o);\n-  bool has_n_ptr = HeapShared::has_native_pointers(o);\n+  bool has_oop_ptr, has_native_ptr;\n+  HeapShared::get_pointer_info(o, has_oop_ptr, has_native_ptr);\n@@ -237,2 +234,2 @@\n-  if (!has_o_ptr) {\n-    if (!has_n_ptr) {\n+  if (!has_oop_ptr) {\n+    if (!has_native_ptr) {\n@@ -244,1 +241,1 @@\n-    if (has_n_ptr) {\n+    if (has_native_ptr) {\n@@ -257,6 +254,3 @@\n-int ArchiveHeapWriter::compare_objs_by_oop_fields(int* a, int* b) {\n-  oop oa = _source_objs->at(*a);\n-  oop ob = _source_objs->at(*b);\n-\n-  int rank_a = oop_sorting_rank(oa);\n-  int rank_b = oop_sorting_rank(ob);\n+int ArchiveHeapWriter::compare_objs_by_oop_fields(HeapObjOrder* a, HeapObjOrder* b) {\n+  int rank_a = a->_rank;\n+  int rank_b = b->_rank;\n@@ -268,1 +262,1 @@\n-    return *a - *b;\n+    return a->_index - b->_index;\n@@ -273,0 +267,11 @@\n+  log_info(cds)(\"sorting heap objects\");\n+  int len = _source_objs->length();\n+  _source_objs_order = new GrowableArrayCHeap<HeapObjOrder, mtClassShared>(len);\n+\n+  for (int i = 0; i < len; i++) {\n+    oop o = _source_objs->at(i);\n+    int rank = oop_sorting_rank(o);\n+    HeapObjOrder os = {i, rank};\n+    _source_objs_order->append(os);\n+  }\n+  log_info(cds)(\"computed ranks\");\n@@ -274,0 +279,1 @@\n+  log_info(cds)(\"sorting heap objects done\");\n@@ -279,1 +285,1 @@\n-    int src_obj_index = _source_objs_order->at(i);\n+    int src_obj_index = _source_objs_order->at(i)._index;\n@@ -286,1 +292,2 @@\n-    _buffer_offset_to_source_obj_table->put(buffer_offset, src_obj);\n+    _buffer_offset_to_source_obj_table->put_when_absent(buffer_offset, src_obj);\n+    _buffer_offset_to_source_obj_table->maybe_grow();\n@@ -318,1 +325,1 @@\n-  Klass* oak = Universe::objectArrayKlassObj(); \/\/ already relocated to point to archived klass\n+  Klass* oak = Universe::objectArrayKlass(); \/\/ already relocated to point to archived klass\n@@ -583,1 +590,1 @@\n-    int src_obj_index = _source_objs_order->at(i);\n+    int src_obj_index = _source_objs_order->at(i)._index;\n@@ -597,1 +604,1 @@\n-  update_header_for_requested_obj(requested_roots, nullptr, Universe::objectArrayKlassObj());\n+  update_header_for_requested_obj(requested_roots, nullptr, Universe::objectArrayKlass());\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -143,1 +143,0 @@\n-  static GrowableArrayCHeap<int, mtClassShared>* _source_objs_order;\n@@ -145,2 +144,14 @@\n-  typedef ResourceHashtable<size_t, oop,\n-      36137, \/\/ prime number\n+  \/\/ We sort _source_objs_order to minimize the number of bits in ptrmap and oopmap.\n+  \/\/ See comments near the body of ArchiveHeapWriter::compare_objs_by_oop_fields().\n+  \/\/ The objects will be written in the order of:\n+  \/\/_source_objs->at(_source_objs_order->at(0)._index)\n+  \/\/ source_objs->at(_source_objs_order->at(1)._index)\n+  \/\/ source_objs->at(_source_objs_order->at(2)._index)\n+  \/\/ ...\n+  struct HeapObjOrder {\n+    int _index;    \/\/ The location of this object in _source_objs\n+    int _rank;     \/\/ A lower rank means the object will be written at a lower location.\n+  };\n+  static GrowableArrayCHeap<HeapObjOrder, mtClassShared>* _source_objs_order;\n+\n+  typedef ResizeableResourceHashtable<size_t, oop,\n@@ -215,1 +226,1 @@\n-  static int compare_objs_by_oop_fields(int* a, int* b);\n+  static int compare_objs_by_oop_fields(HeapObjOrder* a, HeapObjOrder* b);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-    check_unsupported_dumping_properties();\n+    check_unsupported_dumping_module_options();\n@@ -238,1 +238,1 @@\n-void CDSConfig::check_system_property(const char* key, const char* value) {\n+void CDSConfig::check_internal_module_property(const char* key, const char* value) {\n@@ -243,6 +243,16 @@\n-  if (strcmp(key, \"jdk.module.showModuleResolution\") == 0 ||\n-      strcmp(key, \"jdk.module.validation\") == 0 ||\n-      strcmp(key, \"java.system.class.loader\") == 0) {\n-    stop_dumping_full_module_graph();\n-    stop_using_full_module_graph();\n-    log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n+}\n+\n+void CDSConfig::check_incompatible_property(const char* key, const char* value) {\n+  static const char* incompatible_properties[] = {\n+    \"java.system.class.loader\",\n+    \"jdk.module.showModuleResolution\",\n+    \"jdk.module.validation\"\n+  };\n+\n+  for (const char* property : incompatible_properties) {\n+    if (strcmp(key, property) == 0) {\n+      stop_dumping_full_module_graph();\n+      stop_using_full_module_graph();\n+      log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n+      break;\n+    }\n@@ -250,0 +260,1 @@\n+\n@@ -252,15 +263,19 @@\n-static const char* unsupported_properties[] = {\n-  \"jdk.module.limitmods\",\n-  \"jdk.module.upgrade.path\",\n-  \"jdk.module.patch.0\"\n-};\n-static const char* unsupported_options[] = {\n-  \"--limit-modules\",\n-  \"--upgrade-module-path\",\n-  \"--patch-module\"\n-};\n-\n-void CDSConfig::check_unsupported_dumping_properties() {\n-  assert(is_dumping_archive(), \"this function is only used with CDS dump time\");\n-  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n-  \/\/ If a vm option is found in the unsupported_options array, vm will exit with an error message.\n+\/\/ Returns any JVM command-line option, such as \"--patch-module\", that's not supported by CDS.\n+static const char* find_any_unsupported_module_option() {\n+  \/\/ Note that arguments.cpp has translated the command-line options into properties. If we find an\n+  \/\/ unsupported property, translate it back to its command-line option for better error reporting.\n+\n+  \/\/ The following properties are checked by Arguments::is_internal_module_property() and cannot be\n+  \/\/ directly specified in the command-line.\n+  static const char* unsupported_module_properties[] = {\n+    \"jdk.module.limitmods\",\n+    \"jdk.module.upgrade.path\",\n+    \"jdk.module.patch.0\"\n+  };\n+  static const char* unsupported_module_options[] = {\n+    \"--limit-modules\",\n+    \"--upgrade-module-path\",\n+    \"--patch-module\"\n+  };\n+\n+  assert(ARRAY_SIZE(unsupported_module_properties) == ARRAY_SIZE(unsupported_module_options), \"must be\");\n@@ -269,4 +284,3 @@\n-    for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n-      if (strcmp(sp->key(), unsupported_properties[i]) == 0) {\n-        vm_exit_during_initialization(\n-          \"Cannot use the following option when dumping the shared archive\", unsupported_options[i]);\n+    for (uint i = 0; i < ARRAY_SIZE(unsupported_module_properties); i++) {\n+      if (strcmp(sp->key(), unsupported_module_properties[i]) == 0) {\n+        return unsupported_module_options[i];\n@@ -278,0 +292,9 @@\n+  return nullptr; \/\/ not found\n+}\n+\n+void CDSConfig::check_unsupported_dumping_module_options() {\n+  assert(is_dumping_archive(), \"this function is only used with CDS dump time\");\n+  const char* option = find_any_unsupported_module_option();\n+  if (option != nullptr) {\n+    vm_exit_during_initialization(\"Cannot use the following option when dumping the shared archive\", option);\n+  }\n@@ -284,1 +307,1 @@\n-bool CDSConfig::check_unsupported_cds_runtime_properties() {\n+bool CDSConfig::has_unsupported_runtime_module_options() {\n@@ -286,1 +309,0 @@\n-  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n@@ -294,8 +316,6 @@\n-  for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n-    if (Arguments::get_property(unsupported_properties[i]) != nullptr) {\n-      if (RequireSharedSpaces) {\n-        warning(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n-      } else {\n-        log_info(cds)(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n-      }\n-      return true;\n+  const char* option = find_any_unsupported_module_option();\n+  if (option != nullptr) {\n+    if (RequireSharedSpaces) {\n+      warning(\"CDS is disabled when the %s option is specified.\", option);\n+    } else {\n+      log_info(cds)(\"CDS is disabled when the %s option is specified.\", option);\n@@ -303,0 +323,1 @@\n+    return true;\n@@ -307,1 +328,1 @@\n-bool CDSConfig::check_vm_args_consistency(bool patch_mod_javabase,  bool mode_flag_cmd_line) {\n+bool CDSConfig::check_vm_args_consistency(bool patch_mod_javabase, bool mode_flag_cmd_line) {\n@@ -355,1 +376,1 @@\n-  if (UseSharedSpaces && check_unsupported_cds_runtime_properties()) {\n+  if (UseSharedSpaces && has_unsupported_runtime_module_options()) {\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":60,"deletions":39,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  static bool check_unsupported_cds_runtime_properties();\n@@ -61,3 +60,5 @@\n-  static void check_system_property(const char* key, const char* value) NOT_CDS_RETURN;\n-  static void check_unsupported_dumping_properties() NOT_CDS_RETURN;\n-  static bool check_vm_args_consistency(bool patch_mod_javabase,  bool mode_flag_cmd_line) NOT_CDS_RETURN_(true);\n+  static void check_internal_module_property(const char* key, const char* value) NOT_CDS_RETURN;\n+  static void check_incompatible_property(const char* key, const char* value) NOT_CDS_RETURN;\n+  static void check_unsupported_dumping_module_options() NOT_CDS_RETURN;\n+  static bool has_unsupported_runtime_module_options() NOT_CDS_RETURN_(false);\n+  static bool check_vm_args_consistency(bool patch_mod_javabase, bool mode_flag_cmd_line) NOT_CDS_RETURN_(true);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-                  notproduct,                                               \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-      Klass* k = Universe::typeArrayKlassObj((BasicType)i);  \/\/ this give you \"[I\", etc\n+      Klass* k = Universe::typeArrayKlass((BasicType)i);  \/\/ this give you \"[I\", etc\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2230,2 +2230,2 @@\n-    \/\/ Populate the archive regions' G1BlockOffsetTableParts. That ensures\n-    \/\/ fast G1BlockOffsetTablePart::block_start operations for any given address\n+    \/\/ Populate the archive regions' G1BlockOffsetTables. That ensures\n+    \/\/ fast G1BlockOffsetTable::block_start operations for any given address\n@@ -2234,1 +2234,1 @@\n-    G1CollectedHeap::heap()->populate_archive_regions_bot_part(_mapped_heap_memregion);\n+    G1CollectedHeap::heap()->populate_archive_regions_bot(_mapped_heap_memregion);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -288,1 +288,2 @@\n-    archived_object_cache()->put(obj, info);\n+    archived_object_cache()->put_when_absent(obj, info);\n+    archived_object_cache()->maybe_grow();\n@@ -433,0 +434,6 @@\n+int HeapShared::archive_exception_instance(oop exception) {\n+  bool success = archive_reachable_objects_from(1, _default_subgraph_info, exception);\n+  assert(success, \"sanity\");\n+  return append_root(exception);\n+}\n+\n@@ -440,1 +447,1 @@\n-bool HeapShared::has_oop_pointers(oop src_obj) {\n+void HeapShared::get_pointer_info(oop src_obj, bool& has_oop_pointers, bool& has_native_pointers) {\n@@ -443,7 +450,2 @@\n-  return info->has_oop_pointers();\n-}\n-\n-bool HeapShared::has_native_pointers(oop src_obj) {\n-  CachedOopInfo* info = archived_object_cache()->get(src_obj);\n-  assert(info != nullptr, \"must be\");\n-  return info->has_native_pointers();\n+  has_oop_pointers = info->has_oop_pointers();\n+  has_native_pointers = info->has_native_pointers();\n@@ -592,0 +594,1 @@\n+  Universe::archive_exception_instances();\n@@ -687,1 +690,1 @@\n-    if (buffered_k == Universe::objectArrayKlassObj()) {\n+    if (buffered_k == Universe::objectArrayKlass()) {\n@@ -1390,5 +1393,9 @@\n-    guarantee(subgraph_k->name()->equals(\"java\/lang\/Class\") ||\n-              subgraph_k->name()->equals(\"java\/lang\/String\") ||\n-              subgraph_k->name()->equals(\"[Ljava\/lang\/Object;\") ||\n-              subgraph_k->name()->equals(\"[C\") ||\n-              subgraph_k->name()->equals(\"[B\"),\n+    Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n+    guarantee(name == vmSymbols::java_lang_Class() ||\n+              name == vmSymbols::java_lang_String() ||\n+              name == vmSymbols::java_lang_ArithmeticException() ||\n+              name == vmSymbols::java_lang_NullPointerException() ||\n+              name == vmSymbols::java_lang_VirtualMachineError() ||\n+              name == vmSymbols::object_array_signature() ||\n+              name == vmSymbols::byte_array_signature() ||\n+              name == vmSymbols::char_array_signature(),\n@@ -1416,1 +1423,2 @@\n-  _seen_objects_table->put(obj, true);\n+  _seen_objects_table->put_when_absent(obj, true);\n+  _seen_objects_table->maybe_grow();\n@@ -1622,1 +1630,1 @@\n-    _dumped_interned_strings = new (mtClass)DumpedInternedStrings();\n+    _dumped_interned_strings = new (mtClass)DumpedInternedStrings(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE);\n@@ -1688,0 +1696,3 @@\n+  if (created) {\n+    _dumped_interned_strings->maybe_grow();\n+  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -218,2 +218,3 @@\n-  typedef ResourceHashtable<oop, CachedOopInfo,\n-      36137, \/\/ prime number\n+  static const int INITIAL_TABLE_SIZE = 15889; \/\/ prime number\n+  static const int MAX_TABLE_SIZE     = 1000000;\n+  typedef ResizeableResourceHashtable<oop, CachedOopInfo,\n@@ -280,2 +281,1 @@\n-  typedef ResourceHashtable<oop, bool,\n-      15889, \/\/ prime number\n+  typedef ResizeableResourceHashtable<oop, bool,\n@@ -303,1 +303,1 @@\n-    _seen_objects_table = new (mtClass)SeenObjectsTable();\n+    _seen_objects_table = new (mtClass)SeenObjectsTable(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE);\n@@ -358,1 +358,1 @@\n-      new (mtClass)ArchivedObjectCache();\n+      new (mtClass)ArchivedObjectCache(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE);\n@@ -368,0 +368,1 @@\n+  static int archive_exception_instance(oop exception);\n@@ -382,3 +383,2 @@\n-  static bool has_oop_pointers(oop obj);\n-  static bool has_native_pointers(oop obj);\n-  static void set_has_native_pointers(oop obj);\n+  static void get_pointer_info(oop src_obj, bool& has_oop_pointers, bool& has_native_pointers);\n+  static void set_has_native_pointers(oop src_obj);\n@@ -438,2 +438,1 @@\n-  public ResourceHashtable<oop, bool,\n-                           15889, \/\/ prime number\n+  public ResizeableResourceHashtable<oop, bool,\n@@ -443,1 +442,8 @@\n-{};\n+{\n+public:\n+  DumpedInternedStrings(unsigned size, unsigned max_size) :\n+    ResizeableResourceHashtable<oop, bool,\n+                                AnyObj::C_HEAP,\n+                                mtClassShared,\n+                                HeapShared::string_oop_hash>(size, max_size) {}\n+};\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-  CDSConfig::check_unsupported_dumping_properties();\n+  CDSConfig::check_unsupported_dumping_module_options();\n@@ -1469,2 +1469,1 @@\n-\n-  CDS_JAVA_HEAP_ONLY(Universe::update_archived_basic_type_mirrors());\n+  Universe::load_archived_object_instances();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1145,1 +1145,1 @@\n-        CompiledMethod* old = method->code();\n+        nmethod* old = method->code();\n@@ -1163,1 +1163,1 @@\n-        MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+        MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n@@ -1175,1 +1175,1 @@\n-        MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+        MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1132,1 +1132,1 @@\n-      CompiledMethod* code = get_Method()->code();\n+      nmethod* code = get_Method()->code();\n@@ -1148,1 +1148,1 @@\n-    CompiledMethod* code = get_Method()->code();\n+    nmethod* code = get_Method()->code();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,8 +183,8 @@\n-  get_metadata(Universe::boolArrayKlassObj());\n-  get_metadata(Universe::charArrayKlassObj());\n-  get_metadata(Universe::floatArrayKlassObj());\n-  get_metadata(Universe::doubleArrayKlassObj());\n-  get_metadata(Universe::byteArrayKlassObj());\n-  get_metadata(Universe::shortArrayKlassObj());\n-  get_metadata(Universe::intArrayKlassObj());\n-  get_metadata(Universe::longArrayKlassObj());\n+  get_metadata(Universe::boolArrayKlass());\n+  get_metadata(Universe::charArrayKlass());\n+  get_metadata(Universe::floatArrayKlass());\n+  get_metadata(Universe::doubleArrayKlass());\n+  get_metadata(Universe::byteArrayKlass());\n+  get_metadata(Universe::shortArrayKlass());\n+  get_metadata(Universe::intArrayKlass());\n+  get_metadata(Universe::longArrayKlass());\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -807,1 +807,1 @@\n-    CompiledMethod* nm = (entry_bci != InvocationEntryBci) ? method->lookup_osr_nmethod_for(entry_bci, comp_level, true) : method->code();\n+    nmethod* nm = (entry_bci != InvocationEntryBci) ? method->lookup_osr_nmethod_for(entry_bci, comp_level, true) : method->code();\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  Klass* k = Universe::typeArrayKlassObj(t);\n+  Klass* k = Universe::typeArrayKlass(t);\n","filename":"src\/hotspot\/share\/ci\/ciTypeArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,32 @@\n+void BytecodeConstantPool::init() {\n+  for (int i = 1; i < _orig->length(); i++) {\n+    BytecodeCPEntry entry;\n+    switch(_orig->tag_at(i).value()) {\n+    case JVM_CONSTANT_Class:\n+    case JVM_CONSTANT_UnresolvedClass:\n+      entry = BytecodeCPEntry::klass(_orig->klass_slot_at(i).name_index());\n+      break;\n+    case JVM_CONSTANT_Utf8:\n+      entry = BytecodeCPEntry::utf8(_orig->symbol_at(i));\n+      break;\n+    case JVM_CONSTANT_NameAndType:\n+      entry = BytecodeCPEntry::name_and_type(_orig->name_ref_index_at(i), _orig->signature_ref_index_at(i));\n+      break;\n+    case JVM_CONSTANT_Methodref:\n+      entry = BytecodeCPEntry::methodref(_orig->uncached_klass_ref_index_at(i), _orig->uncached_name_and_type_ref_index_at(i));\n+      break;\n+    case JVM_CONSTANT_String:\n+      entry = BytecodeCPEntry::string(_orig->unresolved_string_at(i));\n+      break;\n+    }\n+    if (entry._tag != BytecodeCPEntry::tag::ERROR_TAG) {\n+      bool created = false;\n+      _index_map.put_if_absent(entry, i, &created);\n+      if (created) {\n+        _orig_cp_added += 1;\n+        _added_entries.append(entry);\n+      }\n+    }\n+  }\n+}\n+\n@@ -39,1 +71,1 @@\n-  int new_size = _orig->length() + _entries.length();\n+  int new_size = _orig->length() + _added_entries.length() - _orig_cp_added;\n@@ -44,1 +76,1 @@\n-  u2 index = checked_cast<u2>(_entries.length());\n+  u2 index = checked_cast<u2>(new_size);\n@@ -46,1 +78,1 @@\n-  u2* probe = _indices.put_if_absent(bcpe, index, &created);\n+  u2* probe = _index_map.put_if_absent(bcpe, index, &created);\n@@ -48,1 +80,1 @@\n-    _entries.append(bcpe);\n+    _added_entries.append(bcpe);\n@@ -52,1 +84,1 @@\n-  return checked_cast<u2>(index + _orig->length());\n+  return index;\n@@ -56,1 +88,1 @@\n-  if (_entries.length() == 0) {\n+  if (_added_entries.length() == 0) {\n@@ -60,1 +92,1 @@\n-  int new_size = _orig->length() + _entries.length();\n+  int new_size = _orig->length() + _added_entries.length() - _orig_cp_added;\n@@ -72,3 +104,7 @@\n-  for (int i = 0; i < _entries.length(); ++i) {\n-    BytecodeCPEntry entry = _entries.at(i);\n-    int idx = i + _orig->length();\n+  for (int i = _orig_cp_added; i < _added_entries.length(); ++i) {\n+    \/\/ Add new entries that we added to the temporary constant pool, to the\n+    \/\/ newly creatd constant pool.\n+    BytecodeCPEntry entry = _added_entries.at(i);\n+    \/\/ Get the constant pool index saved in the hashtable for this new entry.\n+    u2* value = _index_map.get(entry);\n+    int idx = *value;\n@@ -86,1 +122,1 @@\n-            idx, cp->symbol_at(entry._u.string));\n+            idx, entry._u.utf8);\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.cpp","additions":48,"deletions":12,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,0 @@\n-    u2 string;\n@@ -96,1 +95,1 @@\n-  static BytecodeCPEntry string(u2 index) {\n+  static BytecodeCPEntry string(Symbol* symbol) {\n@@ -98,1 +97,1 @@\n-    bcpe._u.string = index;\n+    bcpe._u.utf8 = symbol;\n@@ -117,0 +116,2 @@\n+    \/\/ The hash is the \"union trick\" value of the information saved for the tag,\n+    \/\/ so can be compared for equality.\n@@ -125,1 +126,1 @@\n-class BytecodeConstantPool : ResourceObj {\n+class BytecodeConstantPool : public ResourceObj {\n@@ -132,2 +133,3 @@\n-  GrowableArray<BytecodeCPEntry> _entries;\n-  IndexHash _indices;\n+  GrowableArray<BytecodeCPEntry> _added_entries;\n+  IndexHash _index_map;\n+  int _orig_cp_added;\n@@ -137,0 +139,1 @@\n+  void init();\n@@ -139,1 +142,3 @@\n-  BytecodeConstantPool(ConstantPool* orig) : _orig(orig) {}\n+  BytecodeConstantPool(ConstantPool* orig) : _orig(orig), _orig_cp_added(0) {\n+    init();\n+  }\n@@ -141,1 +146,1 @@\n-  BytecodeCPEntry const& at(u2 index) const { return _entries.at(index); }\n+  BytecodeCPEntry const& at(u2 index) const { return _added_entries.at(index); }\n@@ -157,2 +162,3 @@\n-    u2 utf8_entry = utf8(str, CHECK_0);\n-    return find_or_add(BytecodeCPEntry::string(utf8_entry), THREAD);\n+    \/\/ Create the utf8_entry in the hashtable but use Symbol for matching.\n+    (void)utf8(str, CHECK_0);\n+    return find_or_add(BytecodeCPEntry::string(str), THREAD);\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.hpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1122,12 +1122,2 @@\n-    \/\/ At CDS dump time, the --patch-module entries are ignored. That means a\n-    \/\/ class is still loaded from the runtime image even if it might\n-    \/\/ appear in the _patch_mod_entries. The runtime shared class visibility\n-    \/\/ check will determine if a shared class is visible based on the runtime\n-    \/\/ environment, including the runtime --patch-module setting.\n-    \/\/\n-    \/\/ Dynamic dumping requires UseSharedSpaces to be enabled. Since --patch-module\n-    \/\/ is not supported with UseSharedSpaces, we can never come here during dynamic dumping.\n-    assert(!CDSConfig::is_dumping_dynamic_archive(), \"sanity\");\n-    if (!CDSConfig::is_dumping_static_archive()) {\n-      stream = search_module_entries(THREAD, _patch_mod_entries, pkg_entry, file_name);\n-    }\n+    assert(!CDSConfig::is_dumping_archive(), \"CDS doesn't support --patch-module during dumping\");\n+    stream = search_module_entries(THREAD, _patch_mod_entries, pkg_entry, file_name);\n@@ -1144,0 +1134,1 @@\n+      assert(!CDSConfig::is_dumping_archive(), \"CDS dumping doesn't support exploded build\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -942,1 +942,0 @@\n-  BytecodeConstantPool bpool(klass->constants());\n@@ -945,0 +944,2 @@\n+  BytecodeConstantPool* bpool = nullptr;\n+\n@@ -977,1 +978,5 @@\n-        int max_stack = BytecodeAssembler::assemble_method_error(&bpool, buffer,\n+        \/\/ Lazily allocate bytecode constant pool also.\n+        if (bpool == nullptr) {\n+          bpool = new BytecodeConstantPool(klass->constants());\n+        }\n+        int max_stack = BytecodeAssembler::assemble_method_error(bpool, buffer,\n@@ -981,1 +986,1 @@\n-        Method* m = new_method(&bpool, buffer, slot->name(), slot->signature(),\n+        Method* m = new_method(bpool, buffer, slot->name(), slot->signature(),\n@@ -998,1 +1003,1 @@\n-    switchover_constant_pool(&bpool, klass, &overpasses, CHECK);\n+    switchover_constant_pool(bpool, klass, &overpasses, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1262,1 +1262,1 @@\n-    Klass* aklass = Universe::typeArrayKlassObj(type);\n+    Klass* aklass = Universe::typeArrayKlass(type);\n@@ -2420,1 +2420,1 @@\n-      CompiledMethod* nm = method->code();\n+      nmethod* nm = method->code();\n@@ -2546,1 +2546,1 @@\n-  CompiledMethod* nm = nullptr;\n+  nmethod* nm = nullptr;\n@@ -2590,1 +2590,1 @@\n-        if (cb == nullptr || !cb->is_compiled()) {\n+        if (cb == nullptr || !cb->is_nmethod()) {\n@@ -2593,1 +2593,1 @@\n-        nm = cb->as_compiled_method();\n+        nm = cb->as_nmethod();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -370,2 +370,2 @@\n-    k = Universe::typeArrayKlassObj(t);\n-    k = TypeArrayKlass::cast(k)->array_klass(ndims, CHECK_NULL);\n+    k = Universe::typeArrayKlass(t);\n+    k = k->array_klass(ndims, CHECK_NULL);\n@@ -785,1 +785,1 @@\n-      k = Universe::typeArrayKlassObj(t);\n+      k = Universe::typeArrayKlass(t);\n@@ -1730,1 +1730,1 @@\n-      klass = Universe::typeArrayKlassObj(t);\n+      klass = Universe::typeArrayKlass(t);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -767,1 +767,1 @@\n-  template(decodeAndThrowThrowable_signature,          \"(IJZ)V\")                                                  \\\n+  template(decodeAndThrowThrowable_signature,          \"(IJZZ)V\")                                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-bool DefaultICProtectionBehaviour::lock(CompiledMethod* method) {\n+bool DefaultICProtectionBehaviour::lock(nmethod* method) {\n@@ -40,1 +40,1 @@\n-void DefaultICProtectionBehaviour::unlock(CompiledMethod* method) {\n+void DefaultICProtectionBehaviour::unlock(nmethod* method) {\n@@ -44,1 +44,1 @@\n-bool DefaultICProtectionBehaviour::is_safe(CompiledMethod* method) {\n+bool DefaultICProtectionBehaviour::is_safe(nmethod* method) {\n","filename":"src\/hotspot\/share\/code\/codeBehaviours.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-class CompiledMethod;\n+class nmethod;\n@@ -36,3 +36,3 @@\n-  virtual bool lock(CompiledMethod* method) = 0;\n-  virtual void unlock(CompiledMethod* method) = 0;\n-  virtual bool is_safe(CompiledMethod* method) = 0;\n+  virtual bool lock(nmethod* method) = 0;\n+  virtual void unlock(nmethod* method) = 0;\n+  virtual bool is_safe(nmethod* method) = 0;\n@@ -45,3 +45,3 @@\n-  virtual bool lock(CompiledMethod* method);\n-  virtual void unlock(CompiledMethod* method);\n-  virtual bool is_safe(CompiledMethod* method);\n+  virtual bool lock(nmethod* method);\n+  virtual void unlock(nmethod* method);\n+  virtual bool is_safe(nmethod* method);\n","filename":"src\/hotspot\/share\/code\/codeBehaviours.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -57,3 +57,0 @@\n-const char* CodeBlob::compiler_name() const {\n-  return compilertype2name(_type);\n-}\n@@ -67,1 +64,0 @@\n-\n@@ -80,7 +76,17 @@\n-CodeBlob::CodeBlob(const char* name, CompilerType type, const CodeBlobLayout& layout, int frame_complete_offset, int frame_size, ImmutableOopMapSet* oop_maps, bool caller_must_gc_arguments, bool compiled) :\n-  _code_begin(layout.code_begin()),\n-  _code_end(layout.code_end()),\n-  _content_begin(layout.content_begin()),\n-  _data_end(layout.data_end()),\n-  _relocation_begin(layout.relocation_begin()),\n-  _relocation_end(layout.relocation_end()),\n+#ifdef ASSERT\n+void CodeBlob::verify_parameters() {\n+  assert(is_aligned(_size,            oopSize), \"unaligned size\");\n+  assert(is_aligned(_header_size,     oopSize), \"unaligned size\");\n+  assert(is_aligned(_relocation_size, oopSize), \"unaligned size\");\n+  assert(_data_offset <= size(), \"codeBlob is too small\");\n+  assert(code_end() == content_end(), \"must be the same - see code_end()\");\n+#ifdef COMPILER1\n+  \/\/ probably wrong for tiered\n+  assert(frame_size() >= -1, \"must use frame size or -1 for runtime stubs\");\n+#endif \/\/ COMPILER1\n+}\n+#endif\n+\n+CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size, int relocation_size,\n+                   int content_offset, int code_offset, int frame_complete_offset, int data_offset,\n+                   int frame_size, ImmutableOopMapSet* oop_maps, bool caller_must_gc_arguments) :\n@@ -89,2 +95,5 @@\n-  _size(layout.size()),\n-  _header_size(layout.header_size()),\n+  _size(size),\n+  _header_size(header_size),\n+  _relocation_size(relocation_size),\n+  _content_offset(content_offset),\n+  _code_offset(code_offset),\n@@ -92,1 +101,1 @@\n-  _data_offset(layout.data_offset()),\n+  _data_offset(data_offset),\n@@ -94,3 +103,3 @@\n-  _caller_must_gc_arguments(caller_must_gc_arguments),\n-  _is_compiled(compiled),\n-  _type(type)\n+  S390_ONLY(_ctable_offset(0) COMMA)\n+  _kind(kind),\n+  _caller_must_gc_arguments(caller_must_gc_arguments)\n@@ -98,9 +107,1 @@\n-  assert(is_aligned(layout.size(),            oopSize), \"unaligned size\");\n-  assert(is_aligned(layout.header_size(),     oopSize), \"unaligned size\");\n-  assert(is_aligned(layout.relocation_size(), oopSize), \"unaligned size\");\n-  assert(layout.code_end() == layout.content_end(), \"must be the same - see code_end()\");\n-#ifdef COMPILER1\n-  \/\/ probably wrong for tiered\n-  assert(_frame_size >= -1, \"must use frame size or -1 for runtime stubs\");\n-#endif \/\/ COMPILER1\n-  S390_ONLY(_ctable_offset = 0;) \/\/ avoid uninitialized fields\n+  DEBUG_ONLY( verify_parameters(); )\n@@ -109,7 +110,3 @@\n-CodeBlob::CodeBlob(const char* name, CompilerType type, const CodeBlobLayout& layout, CodeBuffer* cb \/*UNUSED*\/, int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments, bool compiled) :\n-  _code_begin(layout.code_begin()),\n-  _code_end(layout.code_end()),\n-  _content_begin(layout.content_begin()),\n-  _data_end(layout.data_end()),\n-  _relocation_begin(layout.relocation_begin()),\n-  _relocation_end(layout.relocation_end()),\n+CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, int header_size,\n+                   int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :\n+  _oop_maps(nullptr), \/\/ will be set by set_oop_maps() call\n@@ -117,2 +114,5 @@\n-  _size(layout.size()),\n-  _header_size(layout.header_size()),\n+  _size(size),\n+  _header_size(header_size),\n+  _relocation_size(align_up(cb->total_relocation_size(), oopSize)),\n+  _content_offset(CodeBlob::align_code_offset(_header_size + _relocation_size)),\n+  _code_offset(_content_offset + cb->total_offset_of(cb->insts())),\n@@ -120,1 +120,1 @@\n-  _data_offset(layout.data_offset()),\n+  _data_offset(_content_offset + align_up(cb->total_content_size(), oopSize)),\n@@ -122,3 +122,3 @@\n-  _caller_must_gc_arguments(caller_must_gc_arguments),\n-  _is_compiled(compiled),\n-  _type(type)\n+  S390_ONLY(_ctable_offset(0) COMMA)\n+  _kind(kind),\n+  _caller_must_gc_arguments(caller_must_gc_arguments)\n@@ -126,4 +126,1 @@\n-  assert(is_aligned(_size,        oopSize), \"unaligned size\");\n-  assert(is_aligned(_header_size, oopSize), \"unaligned size\");\n-  assert(_data_offset <= _size, \"codeBlob is too small\");\n-  assert(layout.code_end() == layout.content_end(), \"must be the same - see code_end()\");\n+  DEBUG_ONLY( verify_parameters(); )\n@@ -132,5 +129,0 @@\n-#ifdef COMPILER1\n-  \/\/ probably wrong for tiered\n-  assert(_frame_size >= -1, \"must use frame size or -1 for runtime stubs\");\n-#endif \/\/ COMPILER1\n-  S390_ONLY(_ctable_offset = 0;) \/\/ avoid uninitialized fields\n@@ -139,4 +131,15 @@\n-\n-\/\/ Creates a simple CodeBlob. Sets up the size of the different regions.\n-RuntimeBlob::RuntimeBlob(const char* name, int header_size, int size, int frame_complete, int locs_size)\n-  : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, locs_size, size), frame_complete, 0, nullptr, false \/* caller_must_gc_arguments *\/)\n+\/\/ Simple CodeBlob used for simple BufferBlob.\n+CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size) :\n+  _oop_maps(nullptr),\n+  _name(name),\n+  _size(size),\n+  _header_size(header_size),\n+  _relocation_size(0),\n+  _content_offset(CodeBlob::align_code_offset(header_size)),\n+  _code_offset(_content_offset),\n+  _frame_complete_offset(CodeOffsets::frame_never_safe),\n+  _data_offset(size),\n+  _frame_size(0),\n+  S390_ONLY(_ctable_offset(0) COMMA)\n+  _kind(kind),\n+  _caller_must_gc_arguments(false)\n@@ -144,1 +147,2 @@\n-  assert(is_aligned(locs_size, oopSize), \"unaligned size\");\n+  assert(is_aligned(size,            oopSize), \"unaligned size\");\n+  assert(is_aligned(header_size,     oopSize), \"unaligned size\");\n@@ -147,0 +151,31 @@\n+void CodeBlob::purge(bool free_code_cache_data, bool unregister_nmethod) {\n+  if (_oop_maps != nullptr) {\n+    delete _oop_maps;\n+    _oop_maps = nullptr;\n+  }\n+  NOT_PRODUCT(_asm_remarks.clear());\n+  NOT_PRODUCT(_dbg_strings.clear());\n+}\n+\n+void CodeBlob::set_oop_maps(OopMapSet* p) {\n+  \/\/ Danger Will Robinson! This method allocates a big\n+  \/\/ chunk of memory, its your job to free it.\n+  if (p != nullptr) {\n+    _oop_maps = ImmutableOopMapSet::build_from(p);\n+  } else {\n+    _oop_maps = nullptr;\n+  }\n+}\n+\n+const ImmutableOopMap* CodeBlob::oop_map_for_return_address(address return_address) const {\n+  assert(_oop_maps != nullptr, \"nope\");\n+  return _oop_maps->find_map_at_offset((intptr_t) return_address - (intptr_t) code_begin());\n+}\n+\n+void CodeBlob::print_code_on(outputStream* st) {\n+  ResourceMark m;\n+  Disassembler::decode(this, st);\n+}\n+\n+\/\/-----------------------------------------------------------------------------------------\n+\/\/ Creates a RuntimeBlob from a CodeBuffer and copy code and relocation info.\n@@ -148,2 +183,0 @@\n-\/\/ Creates a RuntimeBlob from a CodeBuffer\n-\/\/ and copy code and relocation info.\n@@ -152,0 +185,1 @@\n+  CodeBlobKind kind,\n@@ -153,1 +187,0 @@\n-  int         header_size,\n@@ -155,0 +188,1 @@\n+  int         header_size,\n@@ -158,2 +192,3 @@\n-  bool        caller_must_gc_arguments\n-) : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, cb), cb, frame_complete, frame_size, oop_maps, caller_must_gc_arguments) {\n+  bool        caller_must_gc_arguments)\n+  : CodeBlob(name, kind, cb, size, header_size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments)\n+{\n@@ -175,19 +210,0 @@\n-void CodeBlob::purge(bool free_code_cache_data, bool unregister_nmethod) {\n-  if (_oop_maps != nullptr) {\n-    delete _oop_maps;\n-    _oop_maps = nullptr;\n-  }\n-  NOT_PRODUCT(_asm_remarks.clear());\n-  NOT_PRODUCT(_dbg_strings.clear());\n-}\n-\n-void CodeBlob::set_oop_maps(OopMapSet* p) {\n-  \/\/ Danger Will Robinson! This method allocates a big\n-  \/\/ chunk of memory, its your job to free it.\n-  if (p != nullptr) {\n-    _oop_maps = ImmutableOopMapSet::build_from(p);\n-  } else {\n-    _oop_maps = nullptr;\n-  }\n-}\n-\n@@ -233,10 +249,0 @@\n-const ImmutableOopMap* CodeBlob::oop_map_for_return_address(address return_address) const {\n-  assert(_oop_maps != nullptr, \"nope\");\n-  return _oop_maps->find_map_at_offset((intptr_t) return_address - (intptr_t) code_begin());\n-}\n-\n-void CodeBlob::print_code_on(outputStream* st) {\n-  ResourceMark m;\n-  Disassembler::decode(this, st);\n-}\n-\n@@ -246,3 +252,2 @@\n-\n-BufferBlob::BufferBlob(const char* name, int size)\n-: RuntimeBlob(name, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, \/*locs_size:*\/ 0)\n+BufferBlob::BufferBlob(const char* name, CodeBlobKind kind, int size)\n+: RuntimeBlob(name, kind, size, sizeof(BufferBlob))\n@@ -262,1 +267,1 @@\n-    blob = new (size) BufferBlob(name, size);\n+    blob = new (size) BufferBlob(name, CodeBlobKind::Buffer, size);\n@@ -271,2 +276,2 @@\n-BufferBlob::BufferBlob(const char* name, int size, CodeBuffer* cb)\n-  : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, nullptr)\n+BufferBlob::BufferBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size)\n+  : RuntimeBlob(name, kind, cb, size, sizeof(BufferBlob), CodeOffsets::frame_never_safe, 0, nullptr)\n@@ -275,0 +280,1 @@\n+\/\/ Used by gtest\n@@ -283,1 +289,1 @@\n-    blob = new (size) BufferBlob(name, size, cb);\n+    blob = new (size) BufferBlob(name, CodeBlobKind::Buffer, cb, size);\n@@ -304,1 +310,1 @@\n-  BufferBlob(\"I2C\/C2I adapters\", size, cb) {\n+  BufferBlob(\"I2C\/C2I adapters\", CodeBlobKind::Adapter, cb, size) {\n@@ -325,0 +331,3 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of VtableBlob\n+\n@@ -336,1 +345,1 @@\n-  BufferBlob(name, size) {\n+  BufferBlob(name, CodeBlobKind::Vtable, size) {\n@@ -407,1 +416,2 @@\n-: RuntimeBlob(name, cb, sizeof(RuntimeStub), size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments)\n+: RuntimeBlob(name, CodeBlobKind::Runtime_Stub, cb, size, sizeof(RuntimeStub),\n+              frame_complete, frame_size, oop_maps, caller_must_gc_arguments)\n@@ -463,1 +473,2 @@\n-: SingletonBlob(\"DeoptimizationBlob\", cb, sizeof(DeoptimizationBlob), size, frame_size, oop_maps)\n+: SingletonBlob(\"DeoptimizationBlob\", CodeBlobKind::Deoptimization, cb,\n+                size, sizeof(DeoptimizationBlob), frame_size, oop_maps)\n@@ -512,1 +523,2 @@\n-: SingletonBlob(\"UncommonTrapBlob\", cb, sizeof(UncommonTrapBlob), size, frame_size, oop_maps)\n+: SingletonBlob(\"UncommonTrapBlob\", CodeBlobKind::Uncommon_Trap, cb,\n+                size, sizeof(UncommonTrapBlob), frame_size, oop_maps)\n@@ -548,1 +560,2 @@\n-: SingletonBlob(\"ExceptionBlob\", cb, sizeof(ExceptionBlob), size, frame_size, oop_maps)\n+: SingletonBlob(\"ExceptionBlob\", CodeBlobKind::Exception, cb,\n+                size, sizeof(ExceptionBlob), frame_size, oop_maps)\n@@ -583,1 +596,2 @@\n-: SingletonBlob(\"SafepointBlob\", cb, sizeof(SafepointBlob), size, frame_size, oop_maps)\n+: SingletonBlob(\"SafepointBlob\", CodeBlobKind::Safepoint, cb,\n+                size, sizeof(SafepointBlob), frame_size, oop_maps)\n@@ -605,0 +619,55 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of UpcallStub\n+\n+UpcallStub::UpcallStub(const char* name, CodeBuffer* cb, int size, jobject receiver, ByteSize frame_data_offset) :\n+  RuntimeBlob(name, CodeBlobKind::Upcall, cb, size, sizeof(UpcallStub),\n+              CodeOffsets::frame_never_safe, 0 \/* no frame size *\/,\n+              \/* oop maps = *\/ nullptr, \/* caller must gc arguments = *\/ false),\n+  _receiver(receiver),\n+  _frame_data_offset(frame_data_offset)\n+{\n+  CodeCache::commit(this);\n+}\n+\n+void* UpcallStub::operator new(size_t s, unsigned size) throw() {\n+  return CodeCache::allocate(size, CodeBlobType::NonNMethod);\n+}\n+\n+UpcallStub* UpcallStub::create(const char* name, CodeBuffer* cb, jobject receiver, ByteSize frame_data_offset) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  UpcallStub* blob = nullptr;\n+  unsigned int size = CodeBlob::allocation_size(cb, sizeof(UpcallStub));\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) UpcallStub(name, cb, size, receiver, frame_data_offset);\n+  }\n+  if (blob == nullptr) {\n+    return nullptr; \/\/ caller must handle this\n+  }\n+\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  trace_new_stub(blob, \"UpcallStub\");\n+\n+  return blob;\n+}\n+\n+void UpcallStub::oops_do(OopClosure* f, const frame& frame) {\n+  frame_data_for_frame(frame)->old_handles->oops_do(f);\n+}\n+\n+JavaFrameAnchor* UpcallStub::jfa_for_frame(const frame& frame) const {\n+  return &frame_data_for_frame(frame)->jfa;\n+}\n+\n+void UpcallStub::free(UpcallStub* blob) {\n+  assert(blob != nullptr, \"caller must check for nullptr\");\n+  JNIHandles::destroy_global(blob->receiver());\n+  RuntimeBlob::free(blob);\n+}\n+\n+void UpcallStub::preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) {\n+  ShouldNotReachHere(); \/\/ caller should never have to gc arguments\n+}\n@@ -681,4 +750,0 @@\n-void RuntimeBlob::verify() {\n-  ShouldNotReachHere();\n-}\n-\n@@ -733,54 +798,0 @@\n-\/\/ Implementation of UpcallStub\n-\n-UpcallStub::UpcallStub(const char* name, CodeBuffer* cb, int size, jobject receiver, ByteSize frame_data_offset) :\n-  RuntimeBlob(name, cb, sizeof(UpcallStub), size, CodeOffsets::frame_never_safe, 0 \/* no frame size *\/,\n-              \/* oop maps = *\/ nullptr, \/* caller must gc arguments = *\/ false),\n-  _receiver(receiver),\n-  _frame_data_offset(frame_data_offset) {\n-  CodeCache::commit(this);\n-}\n-\n-void* UpcallStub::operator new(size_t s, unsigned size) throw() {\n-  return CodeCache::allocate(size, CodeBlobType::NonNMethod);\n-}\n-\n-UpcallStub* UpcallStub::create(const char* name, CodeBuffer* cb, jobject receiver, ByteSize frame_data_offset) {\n-  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n-\n-  UpcallStub* blob = nullptr;\n-  unsigned int size = CodeBlob::allocation_size(cb, sizeof(UpcallStub));\n-  {\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-    blob = new (size) UpcallStub(name, cb, size, receiver, frame_data_offset);\n-  }\n-  if (blob == nullptr) {\n-    return nullptr; \/\/ caller must handle this\n-  }\n-\n-  \/\/ Track memory usage statistic after releasing CodeCache_lock\n-  MemoryService::track_code_cache_memory_usage();\n-\n-  trace_new_stub(blob, \"UpcallStub\");\n-\n-  return blob;\n-}\n-\n-void UpcallStub::oops_do(OopClosure* f, const frame& frame) {\n-  frame_data_for_frame(frame)->old_handles->oops_do(f);\n-}\n-\n-JavaFrameAnchor* UpcallStub::jfa_for_frame(const frame& frame) const {\n-  return &frame_data_for_frame(frame)->jfa;\n-}\n-\n-void UpcallStub::free(UpcallStub* blob) {\n-  assert(blob != nullptr, \"caller must check for nullptr\");\n-  JNIHandles::destroy_global(blob->receiver());\n-  RuntimeBlob::free(blob);\n-}\n-\n-void UpcallStub::preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) {\n-  ShouldNotReachHere(); \/\/ caller should never have to gc arguments\n-}\n-\n-\/\/ Misc.\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":170,"deletions":159,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-\/\/  CompiledMethod       : Compiled Java methods (include method that calls to native code)\n-\/\/   nmethod             : JIT Compiled Java methods\n+\/\/  nmethod              : JIT Compiled Java methods\n@@ -78,0 +77,15 @@\n+enum class CodeBlobKind : u1 {\n+  None,\n+  Nmethod,\n+  Buffer,\n+  Adapter,\n+  Vtable,\n+  MH_Adapter,\n+  Runtime_Stub,\n+  Deoptimization,\n+  Exception,\n+  Safepoint,\n+  Uncommon_Trap,\n+  Upcall,\n+  Number_Of_Kinds\n+};\n@@ -79,1 +93,0 @@\n-class CodeBlobLayout;\n@@ -90,1 +103,0 @@\n-\n@@ -92,8 +104,0 @@\n-  address    _code_begin;\n-  address    _code_end;\n-  address    _content_begin;                     \/\/ address to where content region begins (this includes consts, insts, stubs)\n-                                                 \/\/ address    _content_end - not required, for all CodeBlobs _code_end == _content_end for now\n-  address    _data_end;\n-  address    _relocation_begin;\n-  address    _relocation_end;\n-\n@@ -101,1 +105,0 @@\n-\n@@ -103,1 +106,0 @@\n-  S390_ONLY(int       _ctable_offset;)\n@@ -107,0 +109,3 @@\n+  int        _relocation_size;                   \/\/ size of relocation\n+  int        _content_offset;                    \/\/ offset to where content region begins (this includes consts, insts, stubs)\n+  int        _code_offset;                       \/\/ offset to where instructions region begins (this includes insts, stubs)\n@@ -114,1 +119,3 @@\n-  bool                _caller_must_gc_arguments;\n+  S390_ONLY(int       _ctable_offset;)\n+\n+  CodeBlobKind        _kind;                     \/\/ Kind of this code blob\n@@ -116,2 +123,1 @@\n-  bool                _is_compiled;\n-  const CompilerType  _type;                     \/\/ CompilerType\n+  bool                _caller_must_gc_arguments;\n@@ -124,6 +130,11 @@\n-  CodeBlob(const char* name, CompilerType type, const CodeBlobLayout& layout, int frame_complete_offset,\n-           int frame_size, ImmutableOopMapSet* oop_maps,\n-           bool caller_must_gc_arguments, bool compiled = false);\n-  CodeBlob(const char* name, CompilerType type, const CodeBlobLayout& layout, CodeBuffer* cb, int frame_complete_offset,\n-           int frame_size, OopMapSet* oop_maps,\n-           bool caller_must_gc_arguments, bool compiled = false);\n+  DEBUG_ONLY( void verify_parameters() );\n+\n+  CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size, int relocation_size,\n+           int content_offset, int code_offset, int data_offset, int frame_complete_offset,\n+           int frame_size, ImmutableOopMapSet* oop_maps, bool caller_must_gc_arguments);\n+\n+  CodeBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, int header_size,\n+           int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments);\n+\n+  \/\/ Simple CodeBlob used for simple BufferBlob.\n+  CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size);\n@@ -134,2 +145,0 @@\n-  \/\/ Only used by unit test.\n-  CodeBlob() : _type(compiler_none) {}\n@@ -149,19 +158,11 @@\n-  virtual bool is_buffer_blob() const                 { return false; }\n-  virtual bool is_nmethod() const                     { return false; }\n-  virtual bool is_runtime_stub() const                { return false; }\n-  virtual bool is_deoptimization_stub() const         { return false; }\n-  virtual bool is_uncommon_trap_stub() const          { return false; }\n-  virtual bool is_exception_stub() const              { return false; }\n-  virtual bool is_safepoint_stub() const              { return false; }\n-  virtual bool is_adapter_blob() const                { return false; }\n-  virtual bool is_vtable_blob() const                 { return false; }\n-  virtual bool is_method_handles_adapter_blob() const { return false; }\n-  virtual bool is_upcall_stub() const                 { return false; }\n-  bool is_compiled() const                            { return _is_compiled; }\n-  const bool* is_compiled_addr() const                { return &_is_compiled; }\n-\n-  inline bool is_compiled_by_c1() const    { return _type == compiler_c1; };\n-  inline bool is_compiled_by_c2() const    { return _type == compiler_c2; };\n-  inline bool is_compiled_by_jvmci() const { return _type == compiler_jvmci; };\n-  const char* compiler_name() const;\n-  CompilerType compiler_type() const { return _type; }\n+  bool is_nmethod() const                     { return _kind == CodeBlobKind::Nmethod; }\n+  bool is_buffer_blob() const                 { return _kind == CodeBlobKind::Buffer; }\n+  bool is_runtime_stub() const                { return _kind == CodeBlobKind::Runtime_Stub; }\n+  bool is_deoptimization_stub() const         { return _kind == CodeBlobKind::Deoptimization; }\n+  bool is_uncommon_trap_stub() const          { return _kind == CodeBlobKind::Uncommon_Trap; }\n+  bool is_exception_stub() const              { return _kind == CodeBlobKind::Exception; }\n+  bool is_safepoint_stub() const              { return _kind == CodeBlobKind::Safepoint; }\n+  bool is_adapter_blob() const                { return _kind == CodeBlobKind::Adapter; }\n+  bool is_vtable_blob() const                 { return _kind == CodeBlobKind::Vtable; }\n+  bool is_method_handles_adapter_blob() const { return _kind == CodeBlobKind::MH_Adapter; }\n+  bool is_upcall_stub() const                 { return _kind == CodeBlobKind::Upcall; }\n@@ -170,7 +171,5 @@\n-  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : nullptr; }\n-  nmethod* as_nmethod()                        { assert(is_nmethod(), \"must be nmethod\"); return (nmethod*) this; }\n-  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : nullptr; }\n-  CompiledMethod* as_compiled_method()         { assert(is_compiled(), \"must be compiled\"); return (CompiledMethod*) this; }\n-  CodeBlob* as_codeblob_or_null() const        { return (CodeBlob*) this; }\n-  UpcallStub* as_upcall_stub() const           { assert(is_upcall_stub(), \"must be upcall stub\"); return (UpcallStub*) this; }\n-  RuntimeStub* as_runtime_stub() const         { assert(is_runtime_stub(), \"must be runtime blob\"); return (RuntimeStub*) this; }\n+  nmethod* as_nmethod_or_null()               { return is_nmethod() ? (nmethod*) this : nullptr; }\n+  nmethod* as_nmethod()                       { assert(is_nmethod(), \"must be nmethod\"); return (nmethod*) this; }\n+  CodeBlob* as_codeblob_or_null() const       { return (CodeBlob*) this; }\n+  UpcallStub* as_upcall_stub() const          { assert(is_upcall_stub(), \"must be upcall stub\"); return (UpcallStub*) this; }\n+  RuntimeStub* as_runtime_stub() const        { assert(is_runtime_stub(), \"must be runtime blob\"); return (RuntimeStub*) this; }\n@@ -179,8 +178,16 @@\n-  address header_begin() const        { return (address) this; }\n-  relocInfo* relocation_begin() const { return (relocInfo*) _relocation_begin; };\n-  relocInfo* relocation_end() const   { return (relocInfo*) _relocation_end; }\n-  address content_begin() const       { return _content_begin; }\n-  address content_end() const         { return _code_end; } \/\/ _code_end == _content_end is true for all types of blobs for now, it is also checked in the constructor\n-  address code_begin() const          { return _code_begin;    }\n-  address code_end() const            { return _code_end; }\n-  address data_end() const            { return _data_end;      }\n+  address    header_begin() const             { return (address)    this; }\n+  address    header_end() const               { return ((address)   this) + _header_size; }\n+  relocInfo* relocation_begin() const         { return (relocInfo*) header_end(); }\n+  relocInfo* relocation_end() const           { return (relocInfo*)(header_end()   + _relocation_size); }\n+  address    content_begin() const            { return (address)    header_begin() + _content_offset; }\n+  address    content_end() const              { return (address)    header_begin() + _data_offset; }\n+  address    code_begin() const               { return (address)    header_begin() + _code_offset; }\n+  \/\/ code_end == content_end is true for all types of blobs for now, it is also checked in the constructor\n+  address    code_end() const                 { return (address)    header_begin() + _data_offset; }\n+  address    data_begin() const               { return (address)    header_begin() + _data_offset; }\n+  address    data_end() const                 { return (address)    header_begin() + _size; }\n+\n+  \/\/ Offsets\n+  int content_offset() const                  { return _content_offset; }\n+  int code_offset() const                     { return _code_offset; }\n+  int data_offset() const                     { return _data_offset; }\n@@ -195,5 +202,6 @@\n-  int size() const                               { return _size; }\n-  int header_size() const                        { return _header_size; }\n-  int relocation_size() const                    { return pointer_delta_as_int((address) relocation_end(), (address) relocation_begin()); }\n-  int content_size() const                       { return pointer_delta_as_int(content_end(), content_begin()); }\n-  int code_size() const                          { return pointer_delta_as_int(code_end(), code_begin()); }\n+  int size() const               { return _size; }\n+  int header_size() const        { return _header_size; }\n+  int relocation_size() const    { return pointer_delta_as_int((address) relocation_end(), (address) relocation_begin()); }\n+  int content_size() const       { return pointer_delta_as_int(content_end(), content_begin()); }\n+  int code_size() const          { return pointer_delta_as_int(code_end(), code_begin()); }\n+\n@@ -204,2 +212,0 @@\n-    _code_end = (address)this + used;\n-    _data_end = (address)this + used;\n@@ -216,2 +222,0 @@\n-  virtual bool is_not_entrant() const            { return false; }\n-\n@@ -263,91 +267,2 @@\n-class CodeBlobLayout : public StackObj {\n-private:\n-  int _size;\n-  int _header_size;\n-  int _relocation_size;\n-  int _content_offset;\n-  int _code_offset;\n-  int _data_offset;\n-  address _code_begin;\n-  address _code_end;\n-  address _content_begin;\n-  address _content_end;\n-  address _data_end;\n-  address _relocation_begin;\n-  address _relocation_end;\n-\n-public:\n-  CodeBlobLayout(address code_begin, address code_end, address content_begin, address content_end, address data_end, address relocation_begin, address relocation_end) :\n-    _size(0),\n-    _header_size(0),\n-    _relocation_size(0),\n-    _content_offset(0),\n-    _code_offset(0),\n-    _data_offset(0),\n-    _code_begin(code_begin),\n-    _code_end(code_end),\n-    _content_begin(content_begin),\n-    _content_end(content_end),\n-    _data_end(data_end),\n-    _relocation_begin(relocation_begin),\n-    _relocation_end(relocation_end)\n-  {\n-  }\n-\n-  CodeBlobLayout(const address start, int size, int header_size, int relocation_size, int data_offset) :\n-    _size(size),\n-    _header_size(header_size),\n-    _relocation_size(relocation_size),\n-    _content_offset(CodeBlob::align_code_offset(_header_size + _relocation_size)),\n-    _code_offset(_content_offset),\n-    _data_offset(data_offset)\n-  {\n-    assert(is_aligned(_relocation_size, oopSize), \"unaligned size\");\n-\n-    _code_begin = (address) start + _code_offset;\n-    _code_end = (address) start + _data_offset;\n-\n-    _content_begin = (address) start + _content_offset;\n-    _content_end = (address) start + _data_offset;\n-\n-    _data_end = (address) start + _size;\n-    _relocation_begin = (address) start + _header_size;\n-    _relocation_end = _relocation_begin + _relocation_size;\n-  }\n-\n-  CodeBlobLayout(const address start, int size, int header_size, const CodeBuffer* cb) :\n-    _size(size),\n-    _header_size(header_size),\n-    _relocation_size(align_up(cb->total_relocation_size(), oopSize)),\n-    _content_offset(CodeBlob::align_code_offset(_header_size + _relocation_size)),\n-    _code_offset(_content_offset + cb->total_offset_of(cb->insts())),\n-    _data_offset(_content_offset + align_up(cb->total_content_size(), oopSize))\n-  {\n-    assert(is_aligned(_relocation_size, oopSize), \"unaligned size\");\n-\n-    _code_begin = (address) start + _code_offset;\n-    _code_end = (address) start + _data_offset;\n-\n-    _content_begin = (address) start + _content_offset;\n-    _content_end = (address) start + _data_offset;\n-\n-    _data_end = (address) start + _size;\n-    _relocation_begin = (address) start + _header_size;\n-    _relocation_end = _relocation_begin + _relocation_size;\n-  }\n-\n-  int size() const { return _size; }\n-  int header_size() const { return _header_size; }\n-  int relocation_size() const { return _relocation_size; }\n-  int content_offset() const { return _content_offset; }\n-  int code_offset() const { return _code_offset; }\n-  int data_offset() const { return _data_offset; }\n-  address code_begin() const { return _code_begin; }\n-  address code_end() const { return _code_end; }\n-  address data_end() const { return _data_end; }\n-  address relocation_begin() const { return _relocation_begin; }\n-  address relocation_end() const { return _relocation_end; }\n-  address content_begin() const { return _content_begin; }\n-  address content_end() const { return _content_end; }\n-};\n-\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ RuntimeBlob: used for non-compiled method code (adapters, stubs, blobs)\n@@ -361,3 +276,3 @@\n-  \/\/ frame_complete is the offset from the beginning of the instructions\n-  \/\/ to where the frame setup (from stackwalk viewpoint) is complete.\n-  RuntimeBlob(const char* name, int header_size, int size, int frame_complete, int locs_size);\n+  RuntimeBlob(const char* name, CodeBlobKind kind, int size, int header_size)\n+    : CodeBlob(name, kind, size, header_size)\n+  {}\n@@ -366,0 +281,2 @@\n+  \/\/ frame_complete is the offset from the beginning of the instructions\n+  \/\/ to where the frame setup (from stackwalk viewpoint) is complete.\n@@ -368,0 +285,1 @@\n+    CodeBlobKind kind,\n@@ -369,1 +287,0 @@\n-    int         header_size,\n@@ -371,0 +288,1 @@\n+    int         header_size,\n@@ -379,9 +297,0 @@\n-  void verify();\n-\n-  \/\/ OopMap for frame\n-  virtual void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f)  { ShouldNotReachHere(); }\n-\n-  \/\/ Debugging\n-  virtual void print_on(outputStream* st) const { CodeBlob::print_on(st); }\n-  virtual void print_value_on(outputStream* st) const { CodeBlob::print_value_on(st); }\n-\n@@ -406,2 +315,2 @@\n-  BufferBlob(const char* name, int size);\n-  BufferBlob(const char* name, int size, CodeBuffer* cb);\n+  BufferBlob(const char* name, CodeBlobKind kind, int size);\n+  BufferBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size);\n@@ -418,3 +327,0 @@\n-  \/\/ Typing\n-  virtual bool is_buffer_blob() const            { return true; }\n-\n@@ -422,1 +328,1 @@\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f)  { \/* nothing to do *\/ }\n+  void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) override { \/* nothing to do *\/ }\n@@ -424,3 +330,3 @@\n-  void verify();\n-  void print_on(outputStream* st) const;\n-  void print_value_on(outputStream* st) const;\n+  void verify() override;\n+  void print_on(outputStream* st) const override;\n+  void print_value_on(outputStream* st) const override;\n@@ -440,3 +346,0 @@\n-\n-  \/\/ Typing\n-  virtual bool is_adapter_blob() const { return true; }\n@@ -455,3 +358,0 @@\n-\n-  \/\/ Typing\n-  virtual bool is_vtable_blob() const { return true; }\n@@ -465,1 +365,1 @@\n-  MethodHandlesAdapterBlob(int size): BufferBlob(\"MethodHandles adapters\", size) {}\n+  MethodHandlesAdapterBlob(int size): BufferBlob(\"MethodHandles adapters\", CodeBlobKind::MH_Adapter, size) {}\n@@ -470,3 +370,0 @@\n-\n-  \/\/ Typing\n-  virtual bool is_method_handles_adapter_blob() const { return true; }\n@@ -509,3 +406,0 @@\n-  \/\/ Typing\n-  bool is_runtime_stub() const                   { return true; }\n-\n@@ -515,1 +409,1 @@\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f)  { \/* nothing to do *\/ }\n+  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) override { \/* nothing to do *\/ }\n@@ -517,3 +411,3 @@\n-  void verify();\n-  void print_on(outputStream* st) const;\n-  void print_value_on(outputStream* st) const;\n+  void verify() override;\n+  void print_on(outputStream* st) const override;\n+  void print_value_on(outputStream* st) const override;\n@@ -534,6 +428,7 @@\n-     const char* name,\n-     CodeBuffer* cb,\n-     int         header_size,\n-     int         size,\n-     int         frame_size,\n-     OopMapSet*  oop_maps\n+     const char*  name,\n+     CodeBlobKind kind,\n+     CodeBuffer*  cb,\n+     int          size,\n+     int          header_size,\n+     int          frame_size,\n+     OopMapSet*   oop_maps\n@@ -541,1 +436,1 @@\n-   : RuntimeBlob(name, cb, header_size, size, CodeOffsets::frame_never_safe, frame_size, oop_maps)\n+   : RuntimeBlob(name, kind, cb, size, header_size, CodeOffsets::frame_never_safe, frame_size, oop_maps)\n@@ -547,4 +442,4 @@\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f)  { \/* nothing to do *\/ }\n-  void verify(); \/\/ does nothing\n-  void print_on(outputStream* st) const;\n-  void print_value_on(outputStream* st) const;\n+  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) override { \/* nothing to do *\/ }\n+  void verify() override; \/\/ does nothing\n+  void print_on(outputStream* st) const override;\n+  void print_value_on(outputStream* st) const override;\n@@ -595,6 +490,0 @@\n-  \/\/ Typing\n-  bool is_deoptimization_stub() const { return true; }\n-\n-  \/\/ GC for args\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) { \/* Nothing to do *\/ }\n-\n@@ -602,1 +491,1 @@\n-  void print_value_on(outputStream* st) const;\n+  void print_value_on(outputStream* st) const override;\n@@ -659,6 +548,0 @@\n-\n-  \/\/ GC for args\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f)  { \/* nothing to do *\/ }\n-\n-  \/\/ Typing\n-  bool is_uncommon_trap_stub() const             { return true; }\n@@ -689,6 +572,0 @@\n-\n-  \/\/ GC for args\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f)  { \/* nothing to do *\/ }\n-\n-  \/\/ Typing\n-  bool is_exception_stub() const                 { return true; }\n@@ -720,6 +597,0 @@\n-\n-  \/\/ GC for args\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f)  { \/* nothing to do *\/ }\n-\n-  \/\/ Typing\n-  bool is_safepoint_stub() const                 { return true; }\n@@ -762,3 +633,0 @@\n-  \/\/ Typing\n-  virtual bool is_upcall_stub() const override { return true; }\n-\n@@ -767,2 +635,2 @@\n-  virtual void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) override;\n-  virtual void verify() override;\n+  void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) override;\n+  void verify() override;\n@@ -771,2 +639,2 @@\n-  virtual void print_on(outputStream* st) const override;\n-  virtual void print_value_on(outputStream* st) const override;\n+  void print_on(outputStream* st) const override;\n+  void print_value_on(outputStream* st) const override;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":109,"deletions":241,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,1 +164,0 @@\n-#define FOR_ALL_NMETHOD_HEAPS(heap) for (GrowableArrayIterator<CodeHeap*> heap = _nmethod_heaps->begin(); heap != _nmethod_heaps->end(); ++heap)\n@@ -177,1 +176,0 @@\n-GrowableArray<CodeHeap*>* CodeCache::_compiled_heaps = new(mtCode) GrowableArray<CodeHeap*> (static_cast<int>(CodeBlobType::All), mtCode);\n@@ -181,16 +179,7 @@\n-void CodeCache::check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set) {\n-  size_t total_size = non_nmethod_size + profiled_size + non_profiled_size;\n-  \/\/ Prepare error message\n-  const char* error = \"Invalid code heap sizes\";\n-  err_msg message(\"NonNMethodCodeHeapSize (\" SIZE_FORMAT \"K) + ProfiledCodeHeapSize (\" SIZE_FORMAT \"K)\"\n-                  \" + NonProfiledCodeHeapSize (\" SIZE_FORMAT \"K) = \" SIZE_FORMAT \"K\",\n-          non_nmethod_size\/K, profiled_size\/K, non_profiled_size\/K, total_size\/K);\n-\n-  if (total_size > cache_size) {\n-    \/\/ Some code heap sizes were explicitly set: total_size must be <= cache_size\n-    message.append(\" is greater than ReservedCodeCacheSize (\" SIZE_FORMAT \"K).\", cache_size\/K);\n-    vm_exit_during_initialization(error, message);\n-  } else if (all_set && total_size != cache_size) {\n-    \/\/ All code heap sizes were explicitly set: total_size must equal cache_size\n-    message.append(\" is not equal to ReservedCodeCacheSize (\" SIZE_FORMAT \"K).\", cache_size\/K);\n-    vm_exit_during_initialization(error, message);\n+static void check_min_size(const char* codeheap, size_t size, size_t required_size) {\n+  if (size < required_size) {\n+    log_debug(codecache)(\"Code heap (%s) size \" SIZE_FORMAT \"K below required minimal size \" SIZE_FORMAT \"K\",\n+                         codeheap, size\/K, required_size\/K);\n+    err_msg title(\"Not enough space in %s to run VM\", codeheap);\n+    err_msg message(SIZE_FORMAT \"K < \" SIZE_FORMAT \"K\", size\/K, required_size\/K);\n+    vm_exit_during_initialization(title, message);\n@@ -200,0 +189,11 @@\n+struct CodeHeapInfo {\n+  size_t size;\n+  bool set;\n+  bool enabled;\n+};\n+\n+static void set_size_of_unset_code_heap(CodeHeapInfo* heap, size_t available_size, size_t used_size, size_t min_size) {\n+  assert(!heap->set, \"sanity\");\n+  heap->size = (available_size > (used_size + min_size)) ? (available_size - used_size) : min_size;\n+}\n+\n@@ -201,29 +201,0 @@\n-  bool non_nmethod_set      = FLAG_IS_CMDLINE(NonNMethodCodeHeapSize);\n-  bool profiled_set         = FLAG_IS_CMDLINE(ProfiledCodeHeapSize);\n-  bool non_profiled_set     = FLAG_IS_CMDLINE(NonProfiledCodeHeapSize);\n-  const size_t ps           = page_size(false, 8);\n-  const size_t min_size     = MAX2(os::vm_allocation_granularity(), ps);\n-  const size_t cache_size   = ReservedCodeCacheSize;\n-  size_t non_nmethod_size   = NonNMethodCodeHeapSize;\n-  size_t profiled_size      = ProfiledCodeHeapSize;\n-  size_t non_profiled_size  = NonProfiledCodeHeapSize;\n-  \/\/ Check if total size set via command line flags exceeds the reserved size\n-  check_heap_sizes((non_nmethod_set  ? non_nmethod_size  : min_size),\n-                   (profiled_set     ? profiled_size     : min_size),\n-                   (non_profiled_set ? non_profiled_size : min_size),\n-                   cache_size,\n-                   non_nmethod_set && profiled_set && non_profiled_set);\n-\n-  \/\/ Determine size of compiler buffers\n-  size_t code_buffers_size = 0;\n-#ifdef COMPILER1\n-  \/\/ C1 temporary code buffers (see Compiler::init_buffer_blob())\n-  const int c1_count = CompilationPolicy::c1_count();\n-  code_buffers_size += c1_count * Compiler::code_buffer_size();\n-#endif\n-#ifdef COMPILER2\n-  \/\/ C2 scratch buffers (see Compile::init_scratch_buffer_blob())\n-  const int c2_count = CompilationPolicy::c2_count();\n-  \/\/ Initial size of constant table (this may be increased if a compiled method needs more space)\n-  code_buffers_size += c2_count * C2Compiler::initial_code_buffer_size();\n-#endif\n@@ -231,61 +202,3 @@\n-  \/\/ Increase default non_nmethod_size to account for compiler buffers\n-  if (!non_nmethod_set) {\n-    non_nmethod_size += code_buffers_size;\n-  }\n-  \/\/ Calculate default CodeHeap sizes if not set by user\n-  if (!non_nmethod_set && !profiled_set && !non_profiled_set) {\n-    \/\/ Leave room for the other two parts of the code cache\n-    const size_t max_non_nmethod_size = cache_size - 2 * min_size;\n-    \/\/ Check if we have enough space for the non-nmethod code heap\n-    if (max_non_nmethod_size >= non_nmethod_size) {\n-      \/\/ Use the default value for non_nmethod_size and one half of the\n-      \/\/ remaining size for non-profiled and one half for profiled methods\n-      size_t remaining_size = cache_size - non_nmethod_size;\n-      profiled_size = remaining_size \/ 2;\n-      non_profiled_size = remaining_size - profiled_size;\n-    } else {\n-      \/\/ Use all space for the non-nmethod heap and set other heaps to minimal size\n-      non_nmethod_size = max_non_nmethod_size;\n-      profiled_size = min_size;\n-      non_profiled_size = min_size;\n-    }\n-  } else if (!non_nmethod_set || !profiled_set || !non_profiled_set) {\n-    \/\/ The user explicitly set some code heap sizes. Increase or decrease the (default)\n-    \/\/ sizes of the other code heaps accordingly. First adapt non-profiled and profiled\n-    \/\/ code heap sizes and then only change non-nmethod code heap size if still necessary.\n-    intx diff_size = cache_size - (non_nmethod_size + profiled_size + non_profiled_size);\n-    if (non_profiled_set) {\n-      if (!profiled_set) {\n-        \/\/ Adapt size of profiled code heap\n-        if (diff_size < 0 && ((intx)profiled_size + diff_size) <= 0) {\n-          \/\/ Not enough space available, set to minimum size\n-          diff_size += profiled_size - min_size;\n-          profiled_size = min_size;\n-        } else {\n-          profiled_size += diff_size;\n-          diff_size = 0;\n-        }\n-      }\n-    } else if (profiled_set) {\n-      \/\/ Adapt size of non-profiled code heap\n-      if (diff_size < 0 && ((intx)non_profiled_size + diff_size) <= 0) {\n-        \/\/ Not enough space available, set to minimum size\n-        diff_size += non_profiled_size - min_size;\n-        non_profiled_size = min_size;\n-      } else {\n-        non_profiled_size += diff_size;\n-        diff_size = 0;\n-      }\n-    } else if (non_nmethod_set) {\n-      \/\/ Distribute remaining size between profiled and non-profiled code heaps\n-      diff_size = cache_size - non_nmethod_size;\n-      profiled_size = diff_size \/ 2;\n-      non_profiled_size = diff_size - profiled_size;\n-      diff_size = 0;\n-    }\n-    if (diff_size != 0) {\n-      \/\/ Use non-nmethod code heap for remaining space requirements\n-      assert(!non_nmethod_set && ((intx)non_nmethod_size + diff_size) > 0, \"sanity\");\n-      non_nmethod_size += diff_size;\n-    }\n-  }\n+  CodeHeapInfo non_nmethod = {NonNMethodCodeHeapSize, FLAG_IS_CMDLINE(NonNMethodCodeHeapSize), true};\n+  CodeHeapInfo profiled = {ProfiledCodeHeapSize, FLAG_IS_CMDLINE(ProfiledCodeHeapSize), true};\n+  CodeHeapInfo non_profiled = {NonProfiledCodeHeapSize, FLAG_IS_CMDLINE(NonProfiledCodeHeapSize), true};\n@@ -293,1 +206,7 @@\n-  \/\/ We do not need the profiled CodeHeap, use all space for the non-profiled CodeHeap\n+  const bool cache_size_set   = FLAG_IS_CMDLINE(ReservedCodeCacheSize);\n+  const size_t ps             = page_size(false, 8);\n+  const size_t min_size       = MAX2(os::vm_allocation_granularity(), ps);\n+  const size_t min_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3); \/\/ Make sure we have enough space for VM internal code\n+  size_t cache_size           = align_up(ReservedCodeCacheSize, min_size);\n+\n+  \/\/ Prerequisites\n@@ -295,2 +214,56 @@\n-    non_profiled_size += profiled_size;\n-    profiled_size = 0;\n+    \/\/ For compatibility reasons, disabled tiered compilation overrides\n+    \/\/ segment size even if it is set explicitly.\n+    non_profiled.size += profiled.size;\n+    \/\/ Profiled code heap is not available, forcibly set size to 0\n+    profiled.size = 0;\n+    profiled.set = true;\n+    profiled.enabled = false;\n+  }\n+\n+  assert(heap_available(CodeBlobType::MethodNonProfiled), \"MethodNonProfiled heap is always available for segmented code heap\");\n+\n+  size_t compiler_buffer_size = 0;\n+  COMPILER1_PRESENT(compiler_buffer_size += CompilationPolicy::c1_count() * Compiler::code_buffer_size());\n+  COMPILER2_PRESENT(compiler_buffer_size += CompilationPolicy::c2_count() * C2Compiler::initial_code_buffer_size());\n+\n+  if (!non_nmethod.set) {\n+    non_nmethod.size += compiler_buffer_size;\n+  }\n+\n+  if (!profiled.set && !non_profiled.set) {\n+    non_profiled.size = profiled.size = (cache_size > non_nmethod.size + 2 * min_size) ?\n+                                        (cache_size - non_nmethod.size) \/ 2 : min_size;\n+  }\n+\n+  if (profiled.set && !non_profiled.set) {\n+    set_size_of_unset_code_heap(&non_profiled, cache_size, non_nmethod.size + profiled.size, min_size);\n+  }\n+\n+  if (!profiled.set && non_profiled.set) {\n+    set_size_of_unset_code_heap(&profiled, cache_size, non_nmethod.size + non_profiled.size, min_size);\n+  }\n+\n+  \/\/ Compatibility.\n+  size_t non_nmethod_min_size = min_cache_size + compiler_buffer_size;\n+  if (!non_nmethod.set && profiled.set && non_profiled.set) {\n+    set_size_of_unset_code_heap(&non_nmethod, cache_size, profiled.size + non_profiled.size, non_nmethod_min_size);\n+  }\n+\n+  size_t total = non_nmethod.size + profiled.size + non_profiled.size;\n+  if (total != cache_size && !cache_size_set) {\n+    log_info(codecache)(\"ReservedCodeCache size \" SIZE_FORMAT \"K changed to total segments size NonNMethod \"\n+                        SIZE_FORMAT \"K NonProfiled \" SIZE_FORMAT \"K Profiled \" SIZE_FORMAT \"K = \" SIZE_FORMAT \"K\",\n+                        cache_size\/K, non_nmethod.size\/K, non_profiled.size\/K, profiled.size\/K, total\/K);\n+    \/\/ Adjust ReservedCodeCacheSize as necessary because it was not set explicitly\n+    cache_size = total;\n+  }\n+\n+  log_debug(codecache)(\"Initializing code heaps ReservedCodeCache \" SIZE_FORMAT \"K NonNMethod \" SIZE_FORMAT \"K\"\n+                       \" NonProfiled \" SIZE_FORMAT \"K Profiled \" SIZE_FORMAT \"K\",\n+                       cache_size\/K, non_nmethod.size\/K, non_profiled.size\/K, profiled.size\/K);\n+\n+  \/\/ Validation\n+  \/\/ Check minimal required sizes\n+  check_min_size(\"non-nmethod code heap\", non_nmethod.size, non_nmethod_min_size);\n+  if (profiled.enabled) {\n+    check_min_size(\"profiled code heap\", profiled.size, min_size);\n@@ -298,4 +271,2 @@\n-  \/\/ We do not need the non-profiled CodeHeap, use all space for the non-nmethod CodeHeap\n-  if (!heap_available(CodeBlobType::MethodNonProfiled)) {\n-    non_nmethod_size += non_profiled_size;\n-    non_profiled_size = 0;\n+  if (non_profiled.enabled) { \/\/ non_profiled.enabled is always ON for segmented code heap, leave it checked for clarity\n+    check_min_size(\"non-profiled code heap\", non_profiled.size, min_size);\n@@ -303,6 +274,2 @@\n-  \/\/ Make sure we have enough space for VM internal code\n-  uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);\n-  if (non_nmethod_size < min_code_cache_size) {\n-    vm_exit_during_initialization(err_msg(\n-        \"Not enough space in non-nmethod code heap to run VM: \" SIZE_FORMAT \"K < \" SIZE_FORMAT \"K\",\n-        non_nmethod_size\/K, min_code_cache_size\/K));\n+  if (cache_size_set) {\n+    check_min_size(\"reserved code cache\", cache_size, min_cache_size);\n@@ -311,5 +278,12 @@\n-  \/\/ Verify sizes and update flag values\n-  assert(non_profiled_size + profiled_size + non_nmethod_size == cache_size, \"Invalid code heap sizes\");\n-  FLAG_SET_ERGO(NonNMethodCodeHeapSize, non_nmethod_size);\n-  FLAG_SET_ERGO(ProfiledCodeHeapSize, profiled_size);\n-  FLAG_SET_ERGO(NonProfiledCodeHeapSize, non_profiled_size);\n+  \/\/ ReservedCodeCacheSize was set explicitly, so report an error and abort if it doesn't match the segment sizes\n+  if (total != cache_size && cache_size_set) {\n+    err_msg message(\"NonNMethodCodeHeapSize (\" SIZE_FORMAT \"K)\", non_nmethod.size\/K);\n+    if (profiled.enabled) {\n+      message.append(\" + ProfiledCodeHeapSize (\" SIZE_FORMAT \"K)\", profiled.size\/K);\n+    }\n+    if (non_profiled.enabled) {\n+      message.append(\" + NonProfiledCodeHeapSize (\" SIZE_FORMAT \"K)\", non_profiled.size\/K);\n+    }\n+    message.append(\" = \" SIZE_FORMAT \"K\", total\/K);\n+    message.append((total > cache_size) ? \" is greater than \" : \" is less than \");\n+    message.append(\"ReservedCodeCacheSize (\" SIZE_FORMAT \"K).\", cache_size\/K);\n@@ -317,1 +291,4 @@\n-  \/\/ Print warning if using large pages but not able to use the size given\n+    vm_exit_during_initialization(\"Invalid code heap sizes\", message);\n+  }\n+\n+  \/\/ Compatibility. Print warning if using large pages but not able to use the size given\n@@ -329,11 +306,11 @@\n-  non_nmethod_size = align_up(non_nmethod_size, min_size);\n-  profiled_size    = align_down(profiled_size, min_size);\n-  non_profiled_size = align_down(non_profiled_size, min_size);\n-\n-  \/\/ Reserve one continuous chunk of memory for CodeHeaps and split it into\n-  \/\/ parts for the individual heaps. The memory layout looks like this:\n-  \/\/ ---------- high -----------\n-  \/\/    Non-profiled nmethods\n-  \/\/         Non-nmethods\n-  \/\/      Profiled nmethods\n-  \/\/ ---------- low ------------\n+  non_profiled.size += non_nmethod.size & alignment_mask(min_size);\n+  non_profiled.size += profiled.size & alignment_mask(min_size);\n+  non_nmethod.size = align_down(non_nmethod.size, min_size);\n+  profiled.size = align_down(profiled.size, min_size);\n+  non_profiled.size = align_down(non_profiled.size, min_size);\n+\n+  FLAG_SET_ERGO(NonNMethodCodeHeapSize, non_nmethod.size);\n+  FLAG_SET_ERGO(ProfiledCodeHeapSize, profiled.size);\n+  FLAG_SET_ERGO(NonProfiledCodeHeapSize, non_profiled.size);\n+  FLAG_SET_ERGO(ReservedCodeCacheSize, cache_size);\n+\n@@ -341,4 +318,0 @@\n-  ReservedSpace profiled_space      = rs.first_part(profiled_size);\n-  ReservedSpace rest                = rs.last_part(profiled_size);\n-  ReservedSpace non_method_space    = rest.first_part(non_nmethod_size);\n-  ReservedSpace non_profiled_space  = rest.last_part(non_nmethod_size);\n@@ -349,0 +322,10 @@\n+  size_t offset = 0;\n+  if (profiled.enabled) {\n+    ReservedSpace profiled_space = rs.partition(offset, profiled.size);\n+    offset += profiled.size;\n+    \/\/ Tier 2 and tier 3 (profiled) methods\n+    add_heap(profiled_space, \"CodeHeap 'profiled nmethods'\", CodeBlobType::MethodProfiled);\n+  }\n+\n+  ReservedSpace non_method_space = rs.partition(offset, non_nmethod.size);\n+  offset += non_nmethod.size;\n@@ -351,4 +334,6 @@\n-  \/\/ Tier 2 and tier 3 (profiled) methods\n-  add_heap(profiled_space, \"CodeHeap 'profiled nmethods'\", CodeBlobType::MethodProfiled);\n-  \/\/ Tier 1 and tier 4 (non-profiled) methods and native methods\n-  add_heap(non_profiled_space, \"CodeHeap 'non-profiled nmethods'\", CodeBlobType::MethodNonProfiled);\n+\n+  if (non_profiled.enabled) {\n+    ReservedSpace non_profiled_space  = rs.partition(offset, non_profiled.size);\n+    \/\/ Tier 1 and tier 4 (non-profiled) methods and native methods\n+    add_heap(non_profiled_space, \"CodeHeap 'non-profiled nmethods'\", CodeBlobType::MethodNonProfiled);\n+  }\n@@ -427,3 +412,0 @@\n-  if (code_blob_type_accepts_compiled(type)) {\n-    _compiled_heaps->insert_sorted<code_heap_compare>(heap);\n-  }\n@@ -672,1 +654,1 @@\n-  assert(cb->is_nmethod(), \"did not find an nmethod\");\n+  assert(cb == nullptr || cb->is_nmethod(), \"did not find an nmethod\");\n@@ -687,1 +669,1 @@\n-  NMethodIterator iter(NMethodIterator::all_blobs);\n+  NMethodIterator iter(NMethodIterator::all);\n@@ -693,0 +675,8 @@\n+void CodeCache::nmethods_do(NMethodClosure* cl) {\n+  assert_locked_or_safepoint(CodeCache_lock);\n+  NMethodIterator iter(NMethodIterator::all);\n+  while(iter.next()) {\n+    cl->do_nmethod(iter.method());\n+  }\n+}\n+\n@@ -695,1 +685,1 @@\n-  NMethodIterator iter(NMethodIterator::all_blobs);\n+  NMethodIterator iter(NMethodIterator::all);\n@@ -885,1 +875,1 @@\n-  CompiledMethodIterator iter(CompiledMethodIterator::all_blobs);\n+  NMethodIterator iter(NMethodIterator::all);\n@@ -891,14 +881,0 @@\n-void CodeCache::blobs_do(CodeBlobClosure* f) {\n-  assert_locked_or_safepoint(CodeCache_lock);\n-  FOR_ALL_ALLOCABLE_HEAPS(heap) {\n-    FOR_ALL_BLOBS(cb, *heap) {\n-      f->do_code_blob(cb);\n-#ifdef ASSERT\n-      if (cb->is_nmethod()) {\n-        Universe::heap()->verify_nmethod((nmethod*)cb);\n-      }\n-#endif \/\/ASSERT\n-    }\n-  }\n-}\n-\n@@ -907,1 +883,1 @@\n-  NMethodIterator iter(NMethodIterator::only_not_unloading);\n+  NMethodIterator iter(NMethodIterator::not_unloading);\n@@ -986,1 +962,1 @@\n-  NMethodIterator iter(NMethodIterator::only_not_unloading);\n+  NMethodIterator iter(NMethodIterator::not_unloading);\n@@ -1014,2 +990,2 @@\n-  FOR_ALL_NMETHOD_HEAPS(heap) {\n-    count += (*heap)->nmethod_count();\n+  for (CodeHeap* heap : *_nmethod_heaps) {\n+    count += heap->nmethod_count();\n@@ -1181,1 +1157,1 @@\n-  CompiledMethodIterator iter(CompiledMethodIterator::only_not_unloading);\n+  NMethodIterator iter(NMethodIterator::not_unloading);\n@@ -1190,1 +1166,1 @@\n-  NMethodIterator iter(NMethodIterator::only_not_unloading);\n+  NMethodIterator iter(NMethodIterator::not_unloading);\n@@ -1218,1 +1194,1 @@\n-  NMethodIterator iter(NMethodIterator::only_not_unloading);\n+  NMethodIterator iter(NMethodIterator::not_unloading);\n@@ -1274,6 +1250,0 @@\n-CompiledMethod* CodeCache::find_compiled(void* start) {\n-  CodeBlob *cb = find_blob(start);\n-  assert(cb == nullptr || cb->is_compiled(), \"did not find an compiled_method\");\n-  return (CompiledMethod*)cb;\n-}\n-\n@@ -1283,1 +1253,1 @@\n-static GrowableArray<CompiledMethod*>* old_compiled_method_table = nullptr;\n+static GrowableArray<nmethod*>* old_nmethod_table = nullptr;\n@@ -1285,3 +1255,3 @@\n-static void add_to_old_table(CompiledMethod* c) {\n-  if (old_compiled_method_table == nullptr) {\n-    old_compiled_method_table = new (mtCode) GrowableArray<CompiledMethod*>(100, mtCode);\n+static void add_to_old_table(nmethod* c) {\n+  if (old_nmethod_table == nullptr) {\n+    old_nmethod_table = new (mtCode) GrowableArray<nmethod*>(100, mtCode);\n@@ -1289,1 +1259,1 @@\n-  old_compiled_method_table->push(c);\n+  old_nmethod_table->push(c);\n@@ -1293,3 +1263,3 @@\n-  if (old_compiled_method_table != nullptr) {\n-    delete old_compiled_method_table;\n-    old_compiled_method_table = nullptr;\n+  if (old_nmethod_table != nullptr) {\n+    delete old_nmethod_table;\n+    old_nmethod_table = nullptr;\n@@ -1300,1 +1270,1 @@\n-void CodeCache::unregister_old_nmethod(CompiledMethod* c) {\n+void CodeCache::unregister_old_nmethod(nmethod* c) {\n@@ -1302,2 +1272,2 @@\n-  if (old_compiled_method_table != nullptr) {\n-    int index = old_compiled_method_table->find(c);\n+  if (old_nmethod_table != nullptr) {\n+    int index = old_nmethod_table->find(c);\n@@ -1305,1 +1275,1 @@\n-      old_compiled_method_table->delete_at(index);\n+      old_nmethod_table->delete_at(index);\n@@ -1313,2 +1283,2 @@\n-  if (old_compiled_method_table != nullptr) {\n-    length = old_compiled_method_table->length();\n+  if (old_nmethod_table != nullptr) {\n+    length = old_nmethod_table->length();\n@@ -1319,1 +1289,1 @@\n-      old_compiled_method_table->at(i)->metadata_do(f);\n+      old_nmethod_table->at(i)->metadata_do(f);\n@@ -1332,1 +1302,1 @@\n-  CompiledMethodIterator iter(CompiledMethodIterator::all_blobs);\n+  NMethodIterator iter(NMethodIterator::all);\n@@ -1334,1 +1304,1 @@\n-    CompiledMethod* nm = iter.method();\n+    nmethod* nm = iter.method();\n@@ -1347,1 +1317,1 @@\n-  CompiledMethodIterator iter(CompiledMethodIterator::all_blobs);\n+  NMethodIterator iter(NMethodIterator::all);\n@@ -1349,1 +1319,1 @@\n-    CompiledMethod* nm = iter.method();\n+    nmethod* nm = iter.method();\n@@ -1368,1 +1338,1 @@\n-  CompiledMethodIterator iter(CompiledMethodIterator::only_not_unloading);\n+  NMethodIterator iter(NMethodIterator::not_unloading);\n@@ -1370,1 +1340,1 @@\n-    CompiledMethod* nm = iter.method();\n+    nmethod* nm = iter.method();\n@@ -1386,1 +1356,1 @@\n-  RelaxedCompiledMethodIterator iter(RelaxedCompiledMethodIterator::only_not_unloading);\n+  RelaxedNMethodIterator iter(RelaxedNMethodIterator::not_unloading);\n@@ -1388,1 +1358,1 @@\n-    CompiledMethod* nm = iter.method();\n+    nmethod* nm = iter.method();\n@@ -1427,1 +1397,1 @@\n-  CompiledMethodIterator iter(CompiledMethodIterator::only_not_unloading);\n+  NMethodIterator iter(NMethodIterator::not_unloading);\n@@ -1429,1 +1399,1 @@\n-    CompiledMethod* nm = iter.method();\n+    nmethod* nm = iter.method();\n@@ -1439,1 +1409,1 @@\n-  CompiledMethodIterator iter(CompiledMethodIterator::only_not_unloading);\n+  NMethodIterator iter(NMethodIterator::not_unloading);\n@@ -1441,1 +1411,1 @@\n-    CompiledMethod* nm = iter.method();\n+    nmethod* nm = iter.method();\n@@ -1449,1 +1419,1 @@\n-  RelaxedCompiledMethodIterator iter(RelaxedCompiledMethodIterator::only_not_unloading);\n+  RelaxedNMethodIterator iter(RelaxedNMethodIterator::not_unloading);\n@@ -1451,1 +1421,1 @@\n-    CompiledMethod* nm = iter.method();\n+    nmethod* nm = iter.method();\n@@ -1661,1 +1631,1 @@\n-  NMethodIterator iter(NMethodIterator::all_blobs);\n+  NMethodIterator iter(NMethodIterator::all);\n@@ -1852,1 +1822,1 @@\n-  CompiledMethodIterator iter(CompiledMethodIterator::only_not_unloading);\n+  NMethodIterator iter(NMethodIterator::not_unloading);\n@@ -1854,1 +1824,1 @@\n-    CompiledMethod* cm = iter.method();\n+    nmethod* nm = iter.method();\n@@ -1856,1 +1826,1 @@\n-    char* method_name = cm->method()->name_and_sig_as_C_string();\n+    char* method_name = nm->method()->name_and_sig_as_C_string();\n@@ -1858,1 +1828,1 @@\n-                 cm->compile_id(), cm->comp_level(), cm->get_state(),\n+                 nm->compile_id(), nm->comp_level(), nm->get_state(),\n@@ -1860,1 +1830,1 @@\n-                 (intptr_t)cm->header_begin(), (intptr_t)cm->code_begin(), (intptr_t)cm->code_end());\n+                 (intptr_t)nm->header_begin(), (intptr_t)nm->code_begin(), (intptr_t)nm->code_end());\n@@ -1895,1 +1865,1 @@\n-  AllCodeBlobsIterator iter(AllCodeBlobsIterator::only_not_unloading);\n+  AllCodeBlobsIterator iter(AllCodeBlobsIterator::not_unloading);\n@@ -1900,2 +1870,2 @@\n-      cb->is_compiled() ? cb->as_compiled_method()->method()->external_name()\n-                        : cb->name();\n+      cb->is_nmethod() ? cb->as_nmethod()->method()->external_name()\n+                       : cb->name();\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":189,"deletions":219,"binary":false,"changes":408,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-  template <class T, class Filter, bool is_compiled_method> friend class CodeBlobIterator;\n+  template <class T, class Filter, bool is_relaxed> friend class CodeBlobIterator;\n@@ -93,1 +93,0 @@\n-  static GrowableArray<CodeHeap*>* _compiled_heaps;\n@@ -114,2 +113,1 @@\n-  \/\/ Check the code heap sizes set by the user via command line\n-  static void check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set);\n+\n@@ -147,1 +145,0 @@\n-  static const GrowableArray<CodeHeap*>* compiled_heaps() { return _compiled_heaps; }\n@@ -158,1 +155,0 @@\n-  static void blobs_do(CodeBlobClosure* f);                \/\/ iterates over all CodeBlobs\n@@ -160,0 +156,1 @@\n+  static void nmethods_do(NMethodClosure* cl);             \/\/ iterates over all nmethods\n@@ -168,1 +165,0 @@\n-  static CompiledMethod* find_compiled(void* start);\n@@ -261,8 +257,3 @@\n-  \/\/ Returns the CodeBlobType for the given CompiledMethod\n-  static CodeBlobType get_code_blob_type(CompiledMethod* cm) {\n-    return get_code_heap(cm)->code_blob_type();\n-  }\n-\n-  static bool code_blob_type_accepts_compiled(CodeBlobType code_blob_type) {\n-    bool result = code_blob_type == CodeBlobType::All || code_blob_type <= CodeBlobType::MethodProfiled;\n-    return result;\n+  \/\/ Returns the CodeBlobType for the given nmethod\n+  static CodeBlobType get_code_blob_type(nmethod* nm) {\n+    return get_code_heap(nm)->code_blob_type();\n@@ -318,1 +309,1 @@\n-  static void unregister_old_nmethod(CompiledMethod* c) NOT_JVMTI_RETURN;\n+  static void unregister_old_nmethod(nmethod* c) NOT_JVMTI_RETURN;\n@@ -348,1 +339,1 @@\n-  enum LivenessFilter { all_blobs, only_not_unloading };\n+  enum LivenessFilter { all, not_unloading };\n@@ -354,1 +345,1 @@\n-  bool _only_not_unloading;\n+  bool _not_unloading;    \/\/ Those nmethods that are not unloading\n@@ -371,3 +362,3 @@\n-      if (_only_not_unloading) {\n-        CompiledMethod* cm = _code_blob->as_compiled_method_or_null();\n-        if (cm != nullptr && cm->is_unloading()) {\n+      if (_not_unloading) {\n+        nmethod* nm = _code_blob->as_nmethod_or_null();\n+        if (nm != nullptr && nm->is_unloading()) {\n@@ -384,1 +375,1 @@\n-    : _only_not_unloading(filter == only_not_unloading)\n+    : _not_unloading(filter == not_unloading)\n@@ -445,6 +436,0 @@\n-struct CompiledMethodFilter {\n-  static bool apply(CodeBlob* cb) { return cb->is_compiled(); }\n-  static const GrowableArray<CodeHeap*>* heaps() { return CodeCache::compiled_heaps(); }\n-};\n-\n-\n@@ -461,2 +446,0 @@\n-typedef CodeBlobIterator<CompiledMethod, CompiledMethodFilter, false \/* is_relaxed *\/> CompiledMethodIterator;\n-typedef CodeBlobIterator<CompiledMethod, CompiledMethodFilter, true \/* is_relaxed *\/> RelaxedCompiledMethodIterator;\n@@ -464,0 +447,1 @@\n+typedef CodeBlobIterator<nmethod, NMethodFilter, true  \/* is_relaxed *\/> RelaxedNMethodIterator;\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":15,"deletions":31,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-    \/\/ The nMethod_* values correspond to the CompiledMethod enum values.\n-    \/\/ We can't use the CompiledMethod values 1:1 because we depend on noType == 0.\n+    \/\/ The nMethod_* values correspond to the nmethod enum values.\n+    \/\/ We can't use the nmethod values 1:1 because we depend on noType == 0.\n","filename":"src\/hotspot\/share\/code\/codeHeapState.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-CompiledICLocker::CompiledICLocker(CompiledMethod* method)\n+CompiledICLocker::CompiledICLocker(nmethod* method)\n@@ -59,1 +59,1 @@\n-bool CompiledICLocker::is_safe(CompiledMethod* method) {\n+bool CompiledICLocker::is_safe(nmethod* method) {\n@@ -65,3 +65,3 @@\n-  assert(cb != nullptr && cb->is_compiled(), \"must be compiled\");\n-  CompiledMethod* cm = cb->as_compiled_method();\n-  return CompiledICProtectionBehaviour::current()->is_safe(cm);\n+  assert(cb != nullptr && cb->is_nmethod(), \"must be compiled\");\n+  nmethod* nm = cb->as_nmethod();\n+  return CompiledICProtectionBehaviour::current()->is_safe(nm);\n@@ -170,1 +170,1 @@\n-CompiledIC* CompiledIC_before(CompiledMethod* nm, address return_addr) {\n+CompiledIC* CompiledIC_before(nmethod* nm, address return_addr) {\n@@ -175,1 +175,1 @@\n-CompiledIC* CompiledIC_at(CompiledMethod* nm, address call_site) {\n+CompiledIC* CompiledIC_at(nmethod* nm, address call_site) {\n@@ -183,2 +183,2 @@\n-  CompiledMethod* cm = CodeCache::find_blob(call_reloc->addr())->as_compiled_method();\n-  return CompiledIC_at(cm, call_site);\n+  nmethod* nm = CodeCache::find_blob(call_reloc->addr())->as_nmethod();\n+  return CompiledIC_at(nm, call_site);\n@@ -207,1 +207,1 @@\n-  CompiledMethod* code = method->code();\n+  nmethod* code = method->code();\n@@ -324,1 +324,1 @@\n-  \/\/ in_use is unused but needed to match template function in CompiledMethod\n+  \/\/ in_use is unused but needed to match template function in nmethod\n@@ -346,2 +346,3 @@\n-  CompiledMethod* code = callee_method->code();\n-  CompiledMethod* caller = CodeCache::find_compiled(instruction_address());\n+  nmethod* code = callee_method->code();\n+  nmethod* caller = CodeCache::find_nmethod(instruction_address());\n+  assert(caller != nullptr, \"did not find caller nmethod\");\n@@ -380,2 +381,3 @@\n-  CompiledMethod* cm = CodeCache::find_compiled(instruction_address());\n-  return cm->stub_contains(destination());\n+  nmethod* nm = CodeCache::find_nmethod(instruction_address());\n+  assert(nm != nullptr, \"did not find nmethod\");\n+  return nm->stub_contains(destination());\n@@ -385,1 +387,2 @@\n-  CompiledMethod* caller = CodeCache::find_compiled(instruction_address());\n+  nmethod* caller = CodeCache::find_nmethod(instruction_address());\n+  assert(caller != nullptr, \"did not find caller nmethod\");\n@@ -387,1 +390,1 @@\n-  return !caller->stub_contains(destination()) && dest_cb->is_compiled();\n+  return !caller->stub_contains(destination()) && dest_cb->is_nmethod();\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-class CompiledMethod;\n+class nmethod;\n@@ -45,1 +45,1 @@\n-  CompiledMethod* _method;\n+  nmethod* _method;\n@@ -51,1 +51,1 @@\n-  CompiledICLocker(CompiledMethod* method);\n+  CompiledICLocker(nmethod* method);\n@@ -53,1 +53,1 @@\n-  static bool is_safe(CompiledMethod* method);\n+  static bool is_safe(nmethod* method);\n@@ -101,1 +101,1 @@\n-  CompiledMethod* _method;\n+  nmethod* _method;\n@@ -117,2 +117,2 @@\n-  friend CompiledIC* CompiledIC_before(CompiledMethod* nm, address return_addr);\n-  friend CompiledIC* CompiledIC_at(CompiledMethod* nm, address call_site);\n+  friend CompiledIC* CompiledIC_before(nmethod* nm, address return_addr);\n+  friend CompiledIC* CompiledIC_at(nmethod* nm, address call_site);\n@@ -149,2 +149,2 @@\n-CompiledIC* CompiledIC_before(CompiledMethod* nm, address return_addr);\n-CompiledIC* CompiledIC_at(CompiledMethod* nm, address call_site);\n+CompiledIC* CompiledIC_before(nmethod* nm, address return_addr);\n+CompiledIC* CompiledIC_at(nmethod* nm, address call_site);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,647 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"code\/compiledIC.hpp\"\n-#include \"code\/compiledMethod.inline.hpp\"\n-#include \"code\/exceptionHandlerTable.hpp\"\n-#include \"code\/scopeDesc.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"gc\/shared\/barrierSet.hpp\"\n-#include \"gc\/shared\/barrierSetNMethod.hpp\"\n-#include \"gc\/shared\/gcBehaviours.hpp\"\n-#include \"interpreter\/bytecode.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logTag.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/methodData.hpp\"\n-#include \"oops\/method.inline.hpp\"\n-#include \"oops\/weakHandle.inline.hpp\"\n-#include \"prims\/methodHandles.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/deoptimization.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/jniHandles.inline.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-\n-CompiledMethod::CompiledMethod(Method* method, const char* name, CompilerType type, const CodeBlobLayout& layout,\n-                               int frame_complete_offset, int frame_size, ImmutableOopMapSet* oop_maps,\n-                               bool caller_must_gc_arguments, bool compiled)\n-  : CodeBlob(name, type, layout, frame_complete_offset, frame_size, oop_maps, caller_must_gc_arguments, compiled),\n-    _deoptimization_status(not_marked),\n-    _deoptimization_generation(0),\n-    _method(method),\n-    _gc_data(nullptr)\n-{\n-  init_defaults();\n-}\n-\n-CompiledMethod::CompiledMethod(Method* method, const char* name, CompilerType type, int size,\n-                               int header_size, CodeBuffer* cb, int frame_complete_offset, int frame_size,\n-                               OopMapSet* oop_maps, bool caller_must_gc_arguments, bool compiled)\n-  : CodeBlob(name, type, CodeBlobLayout((address) this, size, header_size, cb), cb,\n-             frame_complete_offset, frame_size, oop_maps, caller_must_gc_arguments, compiled),\n-    _deoptimization_status(not_marked),\n-    _deoptimization_generation(0),\n-    _method(method),\n-    _gc_data(nullptr)\n-{\n-  init_defaults();\n-}\n-\n-void CompiledMethod::init_defaults() {\n-  { \/\/ avoid uninitialized fields, even for short time periods\n-    _scopes_data_begin          = nullptr;\n-    _deopt_handler_begin        = nullptr;\n-    _deopt_mh_handler_begin     = nullptr;\n-    _exception_cache            = nullptr;\n-  }\n-  _has_unsafe_access          = 0;\n-  _has_method_handle_invokes  = 0;\n-  _has_wide_vectors           = 0;\n-  _has_monitors               = 0;\n-}\n-\n-bool CompiledMethod::is_method_handle_return(address return_pc) {\n-  if (!has_method_handle_invokes())  return false;\n-  PcDesc* pd = pc_desc_at(return_pc);\n-  if (pd == nullptr)\n-    return false;\n-  return pd->is_method_handle_invoke();\n-}\n-\n-\/\/ Returns a string version of the method state.\n-const char* CompiledMethod::state() const {\n-  int state = get_state();\n-  switch (state) {\n-  case not_installed:\n-    return \"not installed\";\n-  case in_use:\n-    return \"in use\";\n-  case not_used:\n-    return \"not_used\";\n-  case not_entrant:\n-    return \"not_entrant\";\n-  default:\n-    fatal(\"unexpected method state: %d\", state);\n-    return nullptr;\n-  }\n-}\n-\n-\/\/-----------------------------------------------------------------------------\n-void CompiledMethod::set_deoptimized_done() {\n-  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n-  if (_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n-    Atomic::store(&_deoptimization_status, deoptimize_done);\n-  }\n-}\n-\n-\/\/-----------------------------------------------------------------------------\n-\n-ExceptionCache* CompiledMethod::exception_cache_acquire() const {\n-  return Atomic::load_acquire(&_exception_cache);\n-}\n-\n-void CompiledMethod::add_exception_cache_entry(ExceptionCache* new_entry) {\n-  assert(ExceptionCache_lock->owned_by_self(),\"Must hold the ExceptionCache_lock\");\n-  assert(new_entry != nullptr,\"Must be non null\");\n-  assert(new_entry->next() == nullptr, \"Must be null\");\n-\n-  for (;;) {\n-    ExceptionCache *ec = exception_cache();\n-    if (ec != nullptr) {\n-      Klass* ex_klass = ec->exception_type();\n-      if (!ex_klass->is_loader_alive()) {\n-        \/\/ We must guarantee that entries are not inserted with new next pointer\n-        \/\/ edges to ExceptionCache entries with dead klasses, due to bad interactions\n-        \/\/ with concurrent ExceptionCache cleanup. Therefore, the inserts roll\n-        \/\/ the head pointer forward to the first live ExceptionCache, so that the new\n-        \/\/ next pointers always point at live ExceptionCaches, that are not removed due\n-        \/\/ to concurrent ExceptionCache cleanup.\n-        ExceptionCache* next = ec->next();\n-        if (Atomic::cmpxchg(&_exception_cache, ec, next) == ec) {\n-          CodeCache::release_exception_cache(ec);\n-        }\n-        continue;\n-      }\n-      ec = exception_cache();\n-      if (ec != nullptr) {\n-        new_entry->set_next(ec);\n-      }\n-    }\n-    if (Atomic::cmpxchg(&_exception_cache, ec, new_entry) == ec) {\n-      return;\n-    }\n-  }\n-}\n-\n-void CompiledMethod::clean_exception_cache() {\n-  \/\/ For each nmethod, only a single thread may call this cleanup function\n-  \/\/ at the same time, whether called in STW cleanup or concurrent cleanup.\n-  \/\/ Note that if the GC is processing exception cache cleaning in a concurrent phase,\n-  \/\/ then a single writer may contend with cleaning up the head pointer to the\n-  \/\/ first ExceptionCache node that has a Klass* that is alive. That is fine,\n-  \/\/ as long as there is no concurrent cleanup of next pointers from concurrent writers.\n-  \/\/ And the concurrent writers do not clean up next pointers, only the head.\n-  \/\/ Also note that concurrent readers will walk through Klass* pointers that are not\n-  \/\/ alive. That does not cause ABA problems, because Klass* is deleted after\n-  \/\/ a handshake with all threads, after all stale ExceptionCaches have been\n-  \/\/ unlinked. That is also when the CodeCache::exception_cache_purge_list()\n-  \/\/ is deleted, with all ExceptionCache entries that were cleaned concurrently.\n-  \/\/ That similarly implies that CAS operations on ExceptionCache entries do not\n-  \/\/ suffer from ABA problems as unlinking and deletion is separated by a global\n-  \/\/ handshake operation.\n-  ExceptionCache* prev = nullptr;\n-  ExceptionCache* curr = exception_cache_acquire();\n-\n-  while (curr != nullptr) {\n-    ExceptionCache* next = curr->next();\n-\n-    if (!curr->exception_type()->is_loader_alive()) {\n-      if (prev == nullptr) {\n-        \/\/ Try to clean head; this is contended by concurrent inserts, that\n-        \/\/ both lazily clean the head, and insert entries at the head. If\n-        \/\/ the CAS fails, the operation is restarted.\n-        if (Atomic::cmpxchg(&_exception_cache, curr, next) != curr) {\n-          prev = nullptr;\n-          curr = exception_cache_acquire();\n-          continue;\n-        }\n-      } else {\n-        \/\/ It is impossible to during cleanup connect the next pointer to\n-        \/\/ an ExceptionCache that has not been published before a safepoint\n-        \/\/ prior to the cleanup. Therefore, release is not required.\n-        prev->set_next(next);\n-      }\n-      \/\/ prev stays the same.\n-\n-      CodeCache::release_exception_cache(curr);\n-    } else {\n-      prev = curr;\n-    }\n-\n-    curr = next;\n-  }\n-}\n-\n-\/\/ public method for accessing the exception cache\n-\/\/ These are the public access methods.\n-address CompiledMethod::handler_for_exception_and_pc(Handle exception, address pc) {\n-  \/\/ We never grab a lock to read the exception cache, so we may\n-  \/\/ have false negatives. This is okay, as it can only happen during\n-  \/\/ the first few exception lookups for a given nmethod.\n-  ExceptionCache* ec = exception_cache_acquire();\n-  while (ec != nullptr) {\n-    address ret_val;\n-    if ((ret_val = ec->match(exception,pc)) != nullptr) {\n-      return ret_val;\n-    }\n-    ec = ec->next();\n-  }\n-  return nullptr;\n-}\n-\n-void CompiledMethod::add_handler_for_exception_and_pc(Handle exception, address pc, address handler) {\n-  \/\/ There are potential race conditions during exception cache updates, so we\n-  \/\/ must own the ExceptionCache_lock before doing ANY modifications. Because\n-  \/\/ we don't lock during reads, it is possible to have several threads attempt\n-  \/\/ to update the cache with the same data. We need to check for already inserted\n-  \/\/ copies of the current data before adding it.\n-\n-  MutexLocker ml(ExceptionCache_lock);\n-  ExceptionCache* target_entry = exception_cache_entry_for_exception(exception);\n-\n-  if (target_entry == nullptr || !target_entry->add_address_and_handler(pc,handler)) {\n-    target_entry = new ExceptionCache(exception,pc,handler);\n-    add_exception_cache_entry(target_entry);\n-  }\n-}\n-\n-\/\/ private method for handling exception cache\n-\/\/ These methods are private, and used to manipulate the exception cache\n-\/\/ directly.\n-ExceptionCache* CompiledMethod::exception_cache_entry_for_exception(Handle exception) {\n-  ExceptionCache* ec = exception_cache_acquire();\n-  while (ec != nullptr) {\n-    if (ec->match_exception_with_space(exception)) {\n-      return ec;\n-    }\n-    ec = ec->next();\n-  }\n-  return nullptr;\n-}\n-\n-\/\/-------------end of code for ExceptionCache--------------\n-\n-bool CompiledMethod::is_at_poll_return(address pc) {\n-  RelocIterator iter(this, pc, pc+1);\n-  while (iter.next()) {\n-    if (iter.type() == relocInfo::poll_return_type)\n-      return true;\n-  }\n-  return false;\n-}\n-\n-\n-bool CompiledMethod::is_at_poll_or_poll_return(address pc) {\n-  RelocIterator iter(this, pc, pc+1);\n-  while (iter.next()) {\n-    relocInfo::relocType t = iter.type();\n-    if (t == relocInfo::poll_return_type || t == relocInfo::poll_type)\n-      return true;\n-  }\n-  return false;\n-}\n-\n-void CompiledMethod::verify_oop_relocations() {\n-  \/\/ Ensure sure that the code matches the current oop values\n-  RelocIterator iter(this, nullptr, nullptr);\n-  while (iter.next()) {\n-    if (iter.type() == relocInfo::oop_type) {\n-      oop_Relocation* reloc = iter.oop_reloc();\n-      if (!reloc->oop_is_immediate()) {\n-        reloc->verify_oop_relocation();\n-      }\n-    }\n-  }\n-}\n-\n-\n-ScopeDesc* CompiledMethod::scope_desc_at(address pc) {\n-  PcDesc* pd = pc_desc_at(pc);\n-  guarantee(pd != nullptr, \"scope must be present\");\n-  return new ScopeDesc(this, pd);\n-}\n-\n-ScopeDesc* CompiledMethod::scope_desc_near(address pc) {\n-  PcDesc* pd = pc_desc_near(pc);\n-  guarantee(pd != nullptr, \"scope must be present\");\n-  return new ScopeDesc(this, pd);\n-}\n-\n-address CompiledMethod::oops_reloc_begin() const {\n-  \/\/ If the method is not entrant then a JMP is plastered over the\n-  \/\/ first few bytes.  If an oop in the old code was there, that oop\n-  \/\/ should not get GC'd.  Skip the first few bytes of oops on\n-  \/\/ not-entrant methods.\n-  if (frame_complete_offset() != CodeOffsets::frame_never_safe &&\n-      code_begin() + frame_complete_offset() >\n-      verified_entry_point() + NativeJump::instruction_size)\n-  {\n-    \/\/ If we have a frame_complete_offset after the native jump, then there\n-    \/\/ is no point trying to look for oops before that. This is a requirement\n-    \/\/ for being allowed to scan oops concurrently.\n-    return code_begin() + frame_complete_offset();\n-  }\n-\n-  \/\/ It is not safe to read oops concurrently using entry barriers, if their\n-  \/\/ location depend on whether the nmethod is entrant or not.\n-  \/\/ assert(BarrierSet::barrier_set()->barrier_set_nmethod() == nullptr, \"Not safe oop scan\");\n-\n-  address low_boundary = verified_entry_point();\n-  if (!is_in_use() && is_nmethod()) {\n-    low_boundary += NativeJump::instruction_size;\n-    \/\/ %%% Note:  On SPARC we patch only a 4-byte trap, not a full NativeJump.\n-    \/\/ This means that the low_boundary is going to be a little too high.\n-    \/\/ This shouldn't matter, since oops of non-entrant methods are never used.\n-    \/\/ In fact, why are we bothering to look at oops in a non-entrant method??\n-  }\n-  return low_boundary;\n-}\n-\n-\/\/ Method that knows how to preserve outgoing arguments at call. This method must be\n-\/\/ called with a frame corresponding to a Java invoke\n-void CompiledMethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {\n-  if (method() == nullptr) {\n-    return;\n-  }\n-\n-  \/\/ handle the case of an anchor explicitly set in continuation code that doesn't have a callee\n-  JavaThread* thread = reg_map->thread();\n-  if (thread->has_last_Java_frame() && fr.sp() == thread->last_Java_sp()) {\n-    return;\n-  }\n-\n-  if (!method()->is_native()) {\n-    address pc = fr.pc();\n-    bool has_receiver, has_appendix;\n-    Symbol* signature;\n-\n-    \/\/ The method attached by JIT-compilers should be used, if present.\n-    \/\/ Bytecode can be inaccurate in such case.\n-    Method* callee = attached_method_before_pc(pc);\n-    if (callee != nullptr) {\n-      has_receiver = !(callee->access_flags().is_static());\n-      has_appendix = false;\n-      signature    = callee->signature();\n-    } else {\n-      SimpleScopeDesc ssd(this, pc);\n-\n-      Bytecode_invoke call(methodHandle(Thread::current(), ssd.method()), ssd.bci());\n-      has_receiver = call.has_receiver();\n-      has_appendix = call.has_appendix();\n-      signature    = call.signature();\n-    }\n-\n-    fr.oops_compiled_arguments_do(signature, has_receiver, has_appendix, reg_map, f);\n-  } else if (method()->is_continuation_enter_intrinsic()) {\n-    \/\/ This method only calls Continuation.enter()\n-    Symbol* signature = vmSymbols::continuationEnter_signature();\n-    fr.oops_compiled_arguments_do(signature, false, false, reg_map, f);\n-  }\n-}\n-\n-Method* CompiledMethod::attached_method(address call_instr) {\n-  assert(code_contains(call_instr), \"not part of the nmethod\");\n-  RelocIterator iter(this, call_instr, call_instr + 1);\n-  while (iter.next()) {\n-    if (iter.addr() == call_instr) {\n-      switch(iter.type()) {\n-        case relocInfo::static_call_type:      return iter.static_call_reloc()->method_value();\n-        case relocInfo::opt_virtual_call_type: return iter.opt_virtual_call_reloc()->method_value();\n-        case relocInfo::virtual_call_type:     return iter.virtual_call_reloc()->method_value();\n-        default:                               break;\n-      }\n-    }\n-  }\n-  return nullptr; \/\/ not found\n-}\n-\n-Method* CompiledMethod::attached_method_before_pc(address pc) {\n-  if (NativeCall::is_call_before(pc)) {\n-    NativeCall* ncall = nativeCall_before(pc);\n-    return attached_method(ncall->instruction_address());\n-  }\n-  return nullptr; \/\/ not a call\n-}\n-\n-void CompiledMethod::clear_inline_caches() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"clearing of IC's only allowed at safepoint\");\n-  RelocIterator iter(this);\n-  while (iter.next()) {\n-    iter.reloc()->clear_inline_cache();\n-  }\n-}\n-\n-#ifdef ASSERT\n-\/\/ Check class_loader is alive for this bit of metadata.\n-class CheckClass : public MetadataClosure {\n-  void do_metadata(Metadata* md) {\n-    Klass* klass = nullptr;\n-    if (md->is_klass()) {\n-      klass = ((Klass*)md);\n-    } else if (md->is_method()) {\n-      klass = ((Method*)md)->method_holder();\n-    } else if (md->is_methodData()) {\n-      klass = ((MethodData*)md)->method()->method_holder();\n-    } else {\n-      md->print();\n-      ShouldNotReachHere();\n-    }\n-    assert(klass->is_loader_alive(), \"must be alive\");\n-  }\n-};\n-#endif \/\/ ASSERT\n-\n-\n-static void clean_ic_if_metadata_is_dead(CompiledIC *ic) {\n-  ic->clean_metadata();\n-}\n-\n-\/\/ Clean references to unloaded nmethods at addr from this one, which is not unloaded.\n-template <typename CallsiteT>\n-static void clean_if_nmethod_is_unloaded(CallsiteT* callsite, CompiledMethod* from,\n-                                         bool clean_all) {\n-  CodeBlob* cb = CodeCache::find_blob(callsite->destination());\n-  if (!cb->is_compiled()) {\n-    return;\n-  }\n-  CompiledMethod* cm = cb->as_compiled_method();\n-  if (clean_all || !cm->is_in_use() || cm->is_unloading() || cm->method()->code() != cm) {\n-    callsite->set_to_clean();\n-  }\n-}\n-\n-\/\/ Cleans caches in nmethods that point to either classes that are unloaded\n-\/\/ or nmethods that are unloaded.\n-\/\/\n-\/\/ Can be called either in parallel by G1 currently or after all\n-\/\/ nmethods are unloaded.  Return postponed=true in the parallel case for\n-\/\/ inline caches found that point to nmethods that are not yet visited during\n-\/\/ the do_unloading walk.\n-void CompiledMethod::unload_nmethod_caches(bool unloading_occurred) {\n-  ResourceMark rm;\n-\n-  \/\/ Exception cache only needs to be called if unloading occurred\n-  if (unloading_occurred) {\n-    clean_exception_cache();\n-  }\n-\n-  cleanup_inline_caches_impl(unloading_occurred, false);\n-\n-#ifdef ASSERT\n-  \/\/ Check that the metadata embedded in the nmethod is alive\n-  CheckClass check_class;\n-  metadata_do(&check_class);\n-#endif\n-}\n-\n-void CompiledMethod::run_nmethod_entry_barrier() {\n-  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs_nm != nullptr) {\n-    \/\/ We want to keep an invariant that nmethods found through iterations of a Thread's\n-    \/\/ nmethods found in safepoints have gone through an entry barrier and are not armed.\n-    \/\/ By calling this nmethod entry barrier, it plays along and acts\n-    \/\/ like any other nmethod found on the stack of a thread (fewer surprises).\n-    nmethod* nm = as_nmethod_or_null();\n-    if (nm != nullptr && bs_nm->is_armed(nm)) {\n-      bool alive = bs_nm->nmethod_entry_barrier(nm);\n-      assert(alive, \"should be alive\");\n-    }\n-  }\n-}\n-\n-\/\/ Only called by whitebox test\n-void CompiledMethod::cleanup_inline_caches_whitebox() {\n-  assert_locked_or_safepoint(CodeCache_lock);\n-  CompiledICLocker ic_locker(this);\n-  cleanup_inline_caches_impl(false \/* unloading_occurred *\/, true \/* clean_all *\/);\n-}\n-\n-address* CompiledMethod::orig_pc_addr(const frame* fr) {\n-  return (address*) ((address)fr->unextended_sp() + orig_pc_offset());\n-}\n-\n-\/\/ Called to clean up after class unloading for live nmethods\n-void CompiledMethod::cleanup_inline_caches_impl(bool unloading_occurred, bool clean_all) {\n-  assert(CompiledICLocker::is_safe(this), \"mt unsafe call\");\n-  ResourceMark rm;\n-\n-  \/\/ Find all calls in an nmethod and clear the ones that point to bad nmethods.\n-  RelocIterator iter(this, oops_reloc_begin());\n-  bool is_in_static_stub = false;\n-  while(iter.next()) {\n-\n-    switch (iter.type()) {\n-\n-    case relocInfo::virtual_call_type:\n-      if (unloading_occurred) {\n-        \/\/ If class unloading occurred we first clear ICs where the cached metadata\n-        \/\/ is referring to an unloaded klass or method.\n-        clean_ic_if_metadata_is_dead(CompiledIC_at(&iter));\n-      }\n-\n-      clean_if_nmethod_is_unloaded(CompiledIC_at(&iter), this, clean_all);\n-      break;\n-\n-    case relocInfo::opt_virtual_call_type:\n-    case relocInfo::static_call_type:\n-      clean_if_nmethod_is_unloaded(CompiledDirectCall::at(iter.reloc()), this, clean_all);\n-      break;\n-\n-    case relocInfo::static_stub_type: {\n-      is_in_static_stub = true;\n-      break;\n-    }\n-\n-    case relocInfo::metadata_type: {\n-      \/\/ Only the metadata relocations contained in static\/opt virtual call stubs\n-      \/\/ contains the Method* passed to c2i adapters. It is the only metadata\n-      \/\/ relocation that needs to be walked, as it is the one metadata relocation\n-      \/\/ that violates the invariant that all metadata relocations have an oop\n-      \/\/ in the compiled method (due to deferred resolution and code patching).\n-\n-      \/\/ This causes dead metadata to remain in compiled methods that are not\n-      \/\/ unloading. Unless these slippery metadata relocations of the static\n-      \/\/ stubs are at least cleared, subsequent class redefinition operations\n-      \/\/ will access potentially free memory, and JavaThread execution\n-      \/\/ concurrent to class unloading may call c2i adapters with dead methods.\n-      if (!is_in_static_stub) {\n-        \/\/ The first metadata relocation after a static stub relocation is the\n-        \/\/ metadata relocation of the static stub used to pass the Method* to\n-        \/\/ c2i adapters.\n-        continue;\n-      }\n-      is_in_static_stub = false;\n-      if (is_unloading()) {\n-        \/\/ If the nmethod itself is dying, then it may point at dead metadata.\n-        \/\/ Nobody should follow that metadata; it is strictly unsafe.\n-        continue;\n-      }\n-      metadata_Relocation* r = iter.metadata_reloc();\n-      Metadata* md = r->metadata_value();\n-      if (md != nullptr && md->is_method()) {\n-        Method* method = static_cast<Method*>(md);\n-        if (!method->method_holder()->is_loader_alive()) {\n-          Atomic::store(r->metadata_addr(), (Method*)nullptr);\n-\n-          if (!r->metadata_is_immediate()) {\n-            r->fix_metadata_relocation();\n-          }\n-        }\n-      }\n-      break;\n-    }\n-\n-    default:\n-      break;\n-    }\n-  }\n-}\n-\n-address CompiledMethod::continuation_for_implicit_exception(address pc, bool for_div0_check) {\n-  \/\/ Exception happened outside inline-cache check code => we are inside\n-  \/\/ an active nmethod => use cpc to determine a return address\n-  int exception_offset = int(pc - code_begin());\n-  int cont_offset = ImplicitExceptionTable(this).continuation_offset( exception_offset );\n-#ifdef ASSERT\n-  if (cont_offset == 0) {\n-    Thread* thread = Thread::current();\n-    ResourceMark rm(thread);\n-    CodeBlob* cb = CodeCache::find_blob(pc);\n-    assert(cb != nullptr && cb == this, \"\");\n-\n-    \/\/ Keep tty output consistent. To avoid ttyLocker, we buffer in stream, and print all at once.\n-    stringStream ss;\n-    ss.print_cr(\"implicit exception happened at \" INTPTR_FORMAT, p2i(pc));\n-    print_on(&ss);\n-    method()->print_codes_on(&ss);\n-    print_code_on(&ss);\n-    print_pcs_on(&ss);\n-    tty->print(\"%s\", ss.as_string()); \/\/ print all at once\n-  }\n-#endif\n-  if (cont_offset == 0) {\n-    \/\/ Let the normal error handling report the exception\n-    return nullptr;\n-  }\n-  if (cont_offset == exception_offset) {\n-#if INCLUDE_JVMCI\n-    Deoptimization::DeoptReason deopt_reason = for_div0_check ? Deoptimization::Reason_div0_check : Deoptimization::Reason_null_check;\n-    JavaThread *thread = JavaThread::current();\n-    thread->set_jvmci_implicit_exception_pc(pc);\n-    thread->set_pending_deoptimization(Deoptimization::make_trap_request(deopt_reason,\n-                                                                         Deoptimization::Action_reinterpret));\n-    return (SharedRuntime::deopt_blob()->implicit_exception_uncommon_trap());\n-#else\n-    ShouldNotReachHere();\n-#endif\n-  }\n-  return code_begin() + cont_offset;\n-}\n-\n-class HasEvolDependency : public MetadataClosure {\n-  bool _has_evol_dependency;\n- public:\n-  HasEvolDependency() : _has_evol_dependency(false) {}\n-  void do_metadata(Metadata* md) {\n-    if (md->is_method()) {\n-      Method* method = (Method*)md;\n-      if (method->is_old()) {\n-        _has_evol_dependency = true;\n-      }\n-    }\n-  }\n-  bool has_evol_dependency() const { return _has_evol_dependency; }\n-};\n-\n-bool CompiledMethod::has_evol_metadata() {\n-  \/\/ Check the metadata in relocIter and CompiledIC and also deoptimize\n-  \/\/ any nmethod that has reference to old methods.\n-  HasEvolDependency check_evol;\n-  metadata_do(&check_evol);\n-  if (check_evol.has_evol_dependency() && log_is_enabled(Debug, redefine, class, nmethod)) {\n-    ResourceMark rm;\n-    log_debug(redefine, class, nmethod)\n-            (\"Found evol dependency of nmethod %s.%s(%s) compile_id=%d on in nmethod metadata\",\n-             _method->method_holder()->external_name(),\n-             _method->name()->as_C_string(),\n-             _method->signature()->as_C_string(),\n-             compile_id());\n-  }\n-  return check_evol.has_evol_dependency();\n-}\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":0,"deletions":647,"binary":false,"changes":647,"status":"deleted"},{"patch":"@@ -1,415 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_CODE_COMPILEDMETHOD_HPP\n-#define SHARE_CODE_COMPILEDMETHOD_HPP\n-\n-#include \"code\/codeBlob.hpp\"\n-#include \"code\/pcDesc.hpp\"\n-#include \"oops\/metadata.hpp\"\n-#include \"oops\/method.hpp\"\n-\n-class Dependencies;\n-class ExceptionHandlerTable;\n-class ImplicitExceptionTable;\n-class AbstractCompiler;\n-class xmlStream;\n-class CompiledDirectCall;\n-class NativeCallWrapper;\n-class ScopeDesc;\n-class CompiledIC;\n-class MetadataClosure;\n-\n-\/\/ This class is used internally by nmethods, to cache\n-\/\/ exception\/pc\/handler information.\n-\n-class ExceptionCache : public CHeapObj<mtCode> {\n-  friend class VMStructs;\n- private:\n-  enum { cache_size = 16 };\n-  Klass*   _exception_type;\n-  address  _pc[cache_size];\n-  address  _handler[cache_size];\n-  volatile int _count;\n-  ExceptionCache* volatile _next;\n-  ExceptionCache* _purge_list_next;\n-\n-  inline address pc_at(int index);\n-  void set_pc_at(int index, address a)      { assert(index >= 0 && index < cache_size,\"\"); _pc[index] = a; }\n-\n-  inline address handler_at(int index);\n-  void set_handler_at(int index, address a) { assert(index >= 0 && index < cache_size,\"\"); _handler[index] = a; }\n-\n-  inline int count();\n-  \/\/ increment_count is only called under lock, but there may be concurrent readers.\n-  void increment_count();\n-\n- public:\n-\n-  ExceptionCache(Handle exception, address pc, address handler);\n-\n-  Klass*    exception_type()                { return _exception_type; }\n-  ExceptionCache* next();\n-  void      set_next(ExceptionCache *ec);\n-  ExceptionCache* purge_list_next()                 { return _purge_list_next; }\n-  void      set_purge_list_next(ExceptionCache *ec) { _purge_list_next = ec; }\n-\n-  address match(Handle exception, address pc);\n-  bool    match_exception_with_space(Handle exception) ;\n-  address test_address(address addr);\n-  bool    add_address_and_handler(address addr, address handler) ;\n-};\n-\n-class nmethod;\n-\n-\/\/ cache pc descs found in earlier inquiries\n-class PcDescCache {\n-  friend class VMStructs;\n- private:\n-  enum { cache_size = 4 };\n-  \/\/ The array elements MUST be volatile! Several threads may modify\n-  \/\/ and read from the cache concurrently. find_pc_desc_internal has\n-  \/\/ returned wrong results. C++ compiler (namely xlC12) may duplicate\n-  \/\/ C++ field accesses if the elements are not volatile.\n-  typedef PcDesc* PcDescPtr;\n-  volatile PcDescPtr _pc_descs[cache_size]; \/\/ last cache_size pc_descs found\n- public:\n-  PcDescCache() { debug_only(_pc_descs[0] = nullptr); }\n-  void    reset_to(PcDesc* initial_pc_desc);\n-  PcDesc* find_pc_desc(int pc_offset, bool approximate);\n-  void    add_pc_desc(PcDesc* pc_desc);\n-  PcDesc* last_pc_desc() { return _pc_descs[0]; }\n-};\n-\n-class PcDescSearch {\n-private:\n-  address _code_begin;\n-  PcDesc* _lower;\n-  PcDesc* _upper;\n-public:\n-  PcDescSearch(address code, PcDesc* lower, PcDesc* upper) :\n-    _code_begin(code), _lower(lower), _upper(upper)\n-  {\n-  }\n-\n-  address code_begin() const { return _code_begin; }\n-  PcDesc* scopes_pcs_begin() const { return _lower; }\n-  PcDesc* scopes_pcs_end() const { return _upper; }\n-};\n-\n-class PcDescContainer {\n-private:\n-  PcDescCache _pc_desc_cache;\n-public:\n-  PcDescContainer() {}\n-\n-  PcDesc* find_pc_desc_internal(address pc, bool approximate, const PcDescSearch& search);\n-  void    reset_to(PcDesc* initial_pc_desc) { _pc_desc_cache.reset_to(initial_pc_desc); }\n-\n-  PcDesc* find_pc_desc(address pc, bool approximate, const PcDescSearch& search) {\n-    address base_address = search.code_begin();\n-    PcDesc* desc = _pc_desc_cache.last_pc_desc();\n-    if (desc != nullptr && desc->pc_offset() == pc - base_address) {\n-      return desc;\n-    }\n-    return find_pc_desc_internal(pc, approximate, search);\n-  }\n-};\n-\n-\n-class CompiledMethod : public CodeBlob {\n-  friend class VMStructs;\n-  friend class DeoptimizationScope;\n-  void init_defaults();\n-protected:\n-  enum DeoptimizationStatus : u1 {\n-    not_marked,\n-    deoptimize,\n-    deoptimize_noupdate,\n-    deoptimize_done\n-  };\n-\n-  volatile DeoptimizationStatus _deoptimization_status; \/\/ Used for stack deoptimization\n-  \/\/ Used to track in which deoptimize handshake this method will be deoptimized.\n-  uint64_t                      _deoptimization_generation;\n-\n-  \/\/ set during construction\n-  unsigned int _has_unsafe_access:1;         \/\/ May fault due to unsafe access.\n-  unsigned int _has_method_handle_invokes:1; \/\/ Has this method MethodHandle invokes?\n-  unsigned int _has_wide_vectors:1;          \/\/ Preserve wide vectors at safepoints\n-  unsigned int _has_monitors:1;              \/\/ Fastpath monitor detection for continuations\n-\n-  Method*   _method;\n-  address _scopes_data_begin;\n-  \/\/ All deoptee's will resume execution at this location described by\n-  \/\/ this address.\n-  address _deopt_handler_begin;\n-  \/\/ All deoptee's at a MethodHandle call site will resume execution\n-  \/\/ at this location described by this offset.\n-  address _deopt_mh_handler_begin;\n-\n-  PcDescContainer _pc_desc_container;\n-  ExceptionCache * volatile _exception_cache;\n-\n-  void* _gc_data;\n-\n-  virtual void purge(bool free_code_cache_data, bool unregister_nmethod) = 0;\n-\n-private:\n-  DeoptimizationStatus deoptimization_status() const {\n-    return Atomic::load(&_deoptimization_status);\n-  }\n-\n-protected:\n-  CompiledMethod(Method* method, const char* name, CompilerType type, const CodeBlobLayout& layout, int frame_complete_offset, int frame_size, ImmutableOopMapSet* oop_maps, bool caller_must_gc_arguments, bool compiled);\n-  CompiledMethod(Method* method, const char* name, CompilerType type, int size, int header_size, CodeBuffer* cb, int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments, bool compiled);\n-\n-public:\n-  \/\/ Only used by unit test.\n-  CompiledMethod() {}\n-\n-  template<typename T>\n-  T* gc_data() const                              { return reinterpret_cast<T*>(_gc_data); }\n-  template<typename T>\n-  void set_gc_data(T* gc_data)                    { _gc_data = reinterpret_cast<void*>(gc_data); }\n-\n-  bool  has_unsafe_access() const                 { return _has_unsafe_access; }\n-  void  set_has_unsafe_access(bool z)             { _has_unsafe_access = z; }\n-\n-  bool  has_monitors() const                      { return _has_monitors; }\n-  void  set_has_monitors(bool z)                  { _has_monitors = z; }\n-\n-  bool  has_method_handle_invokes() const         { return _has_method_handle_invokes; }\n-  void  set_has_method_handle_invokes(bool z)     { _has_method_handle_invokes = z; }\n-\n-  bool  has_wide_vectors() const                  { return _has_wide_vectors; }\n-  void  set_has_wide_vectors(bool z)              { _has_wide_vectors = z; }\n-\n-  enum : signed char { not_installed = -1, \/\/ in construction, only the owner doing the construction is\n-                                           \/\/ allowed to advance state\n-                       in_use        = 0,  \/\/ executable nmethod\n-                       not_used      = 1,  \/\/ not entrant, but revivable\n-                       not_entrant   = 2,  \/\/ marked for deoptimization but activations may still exist\n-  };\n-\n-  virtual bool  is_in_use() const = 0;\n-  virtual int   comp_level() const = 0;\n-  virtual int   compile_id() const = 0;\n-\n-  virtual address verified_entry_point() const = 0;\n-  virtual void log_identity(xmlStream* log) const = 0;\n-  virtual void log_state_change() const = 0;\n-  virtual bool make_not_used() = 0;\n-  virtual bool make_not_entrant() = 0;\n-  virtual bool make_entrant() = 0;\n-  virtual address entry_point() const = 0;\n-  virtual bool is_osr_method() const = 0;\n-  virtual int osr_entry_bci() const = 0;\n-  Method* method() const                          { return _method; }\n-  virtual void print_pcs_on(outputStream* st) = 0;\n-  bool is_native_method() const { return _method != nullptr && _method->is_native(); }\n-  bool is_java_method() const { return _method != nullptr && !_method->is_native(); }\n-\n-  \/\/ ScopeDesc retrieval operation\n-  PcDesc* pc_desc_at(address pc)   { return find_pc_desc(pc, false); }\n-  \/\/ pc_desc_near returns the first PcDesc at or after the given pc.\n-  PcDesc* pc_desc_near(address pc) { return find_pc_desc(pc, true); }\n-\n-  \/\/ ScopeDesc for an instruction\n-  ScopeDesc* scope_desc_at(address pc);\n-  ScopeDesc* scope_desc_near(address pc);\n-\n-  bool is_at_poll_return(address pc);\n-  bool is_at_poll_or_poll_return(address pc);\n-\n-  bool  is_marked_for_deoptimization() const { return deoptimization_status() != not_marked; }\n-  bool  has_been_deoptimized() const { return deoptimization_status() == deoptimize_done; }\n-  void  set_deoptimized_done();\n-\n-  virtual void  make_deoptimized() { assert(false, \"not supported\"); };\n-\n-  bool update_recompile_counts() const {\n-    \/\/ Update recompile counts when either the update is explicitly requested (deoptimize)\n-    \/\/ or the nmethod is not marked for deoptimization at all (not_marked).\n-    \/\/ The latter happens during uncommon traps when deoptimized nmethod is made not entrant.\n-    DeoptimizationStatus status = deoptimization_status();\n-    return status != deoptimize_noupdate && status != deoptimize_done;\n-  }\n-\n-  \/\/ tells whether frames described by this nmethod can be deoptimized\n-  \/\/ note: native wrappers cannot be deoptimized.\n-  bool can_be_deoptimized() const { return is_java_method(); }\n-\n-  virtual oop oop_at(int index) const = 0;\n-  virtual Metadata* metadata_at(int index) const = 0;\n-\n-  address scopes_data_begin() const { return _scopes_data_begin; }\n-  virtual address scopes_data_end() const = 0;\n-  int scopes_data_size() const { return int(scopes_data_end() - scopes_data_begin()); }\n-\n-  virtual PcDesc* scopes_pcs_begin() const = 0;\n-  virtual PcDesc* scopes_pcs_end() const = 0;\n-  int scopes_pcs_size() const { return int((intptr_t) scopes_pcs_end() - (intptr_t) scopes_pcs_begin()); }\n-\n-  address insts_begin() const { return code_begin(); }\n-  address insts_end() const { return stub_begin(); }\n-  \/\/ Returns true if a given address is in the 'insts' section. The method\n-  \/\/ insts_contains_inclusive() is end-inclusive.\n-  bool insts_contains(address addr) const { return insts_begin() <= addr && addr < insts_end(); }\n-  bool insts_contains_inclusive(address addr) const { return insts_begin() <= addr && addr <= insts_end(); }\n-\n-  int insts_size() const { return int(insts_end() - insts_begin()); }\n-\n-  virtual address consts_begin() const = 0;\n-  virtual address consts_end() const = 0;\n-  bool consts_contains(address addr) const { return consts_begin() <= addr && addr < consts_end(); }\n-  int consts_size() const { return int(consts_end() - consts_begin()); }\n-\n-  virtual int skipped_instructions_size() const = 0;\n-\n-  virtual address stub_begin() const = 0;\n-  virtual address stub_end() const = 0;\n-  bool stub_contains(address addr) const { return stub_begin() <= addr && addr < stub_end(); }\n-  int stub_size() const { return int(stub_end() - stub_begin()); }\n-\n-  virtual address handler_table_begin() const = 0;\n-  virtual address handler_table_end() const = 0;\n-  bool handler_table_contains(address addr) const { return handler_table_begin() <= addr && addr < handler_table_end(); }\n-  int handler_table_size() const { return int(handler_table_end() - handler_table_begin()); }\n-\n-  virtual address exception_begin() const = 0;\n-\n-  virtual address nul_chk_table_begin() const = 0;\n-  virtual address nul_chk_table_end() const = 0;\n-  bool nul_chk_table_contains(address addr) const { return nul_chk_table_begin() <= addr && addr < nul_chk_table_end(); }\n-  int nul_chk_table_size() const { return int(nul_chk_table_end() - nul_chk_table_begin()); }\n-\n-  virtual oop* oop_addr_at(int index) const = 0;\n-  virtual Metadata** metadata_addr_at(int index) const = 0;\n-\n-protected:\n-  \/\/ Exception cache support\n-  \/\/ Note: _exception_cache may be read and cleaned concurrently.\n-  ExceptionCache* exception_cache() const         { return _exception_cache; }\n-  ExceptionCache* exception_cache_acquire() const;\n-  void set_exception_cache(ExceptionCache *ec)    { _exception_cache = ec; }\n-\n-public:\n-  address handler_for_exception_and_pc(Handle exception, address pc);\n-  void add_handler_for_exception_and_pc(Handle exception, address pc, address handler);\n-  void clean_exception_cache();\n-\n-  void add_exception_cache_entry(ExceptionCache* new_entry);\n-  ExceptionCache* exception_cache_entry_for_exception(Handle exception);\n-\n-  \/\/ MethodHandle\n-  bool is_method_handle_return(address return_pc);\n-  address deopt_mh_handler_begin() const  { return _deopt_mh_handler_begin; }\n-\n-  address deopt_handler_begin() const { return _deopt_handler_begin; }\n-  address* deopt_handler_begin_addr() { return &_deopt_handler_begin; }\n-  \/\/ Deopt\n-  \/\/ Return true is the PC is one would expect if the frame is being deopted.\n-  inline bool is_deopt_pc(address pc);\n-  inline bool is_deopt_mh_entry(address pc);\n-  inline bool is_deopt_entry(address pc);\n-\n-  \/\/ Accessor\/mutator for the original pc of a frame before a frame was deopted.\n-  address get_original_pc(const frame* fr) { return *orig_pc_addr(fr); }\n-  void    set_original_pc(const frame* fr, address pc) { *orig_pc_addr(fr) = pc; }\n-\n-  virtual int orig_pc_offset() = 0;\n-\n-private:\n-  address* orig_pc_addr(const frame* fr);\n-\n-public:\n-  virtual const char* compile_kind() const = 0;\n-  virtual int get_state() const = 0;\n-\n-  const char* state() const;\n-\n-  bool inlinecache_check_contains(address addr) const {\n-    return (addr >= code_begin() && addr < verified_entry_point());\n-  }\n-\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f);\n-\n-  \/\/ implicit exceptions support\n-  address continuation_for_implicit_div0_exception(address pc) { return continuation_for_implicit_exception(pc, true); }\n-  address continuation_for_implicit_null_exception(address pc) { return continuation_for_implicit_exception(pc, false); }\n-\n-  static address get_deopt_original_pc(const frame* fr);\n-\n-  \/\/ Inline cache support for class unloading and nmethod unloading\n- private:\n-  void cleanup_inline_caches_impl(bool unloading_occurred, bool clean_all);\n-\n-  address continuation_for_implicit_exception(address pc, bool for_div0_check);\n-\n- public:\n-  \/\/ Serial version used by whitebox test\n-  void cleanup_inline_caches_whitebox();\n-\n-  virtual void clear_inline_caches();\n-\n-  \/\/ Execute nmethod barrier code, as if entering through nmethod call.\n-  void run_nmethod_entry_barrier();\n-\n-  void verify_oop_relocations();\n-\n-  bool has_evol_metadata();\n-\n-  \/\/ Fast breakpoint support. Tells if this compiled method is\n-  \/\/ dependent on the given method. Returns true if this nmethod\n-  \/\/ corresponds to the given method as well.\n-  virtual bool is_dependent_on_method(Method* dependee) = 0;\n-\n-  virtual address call_instruction_address(address pc) const = 0;\n-\n-  Method* attached_method(address call_pc);\n-  Method* attached_method_before_pc(address pc);\n-\n-  virtual void metadata_do(MetadataClosure* f) = 0;\n-\n-  \/\/ GC support\n- protected:\n-  address oops_reloc_begin() const;\n-\n- public:\n-  \/\/ GC unloading support\n-  \/\/ Cleans unloaded klasses and unloaded nmethods in inline caches\n-\n-  virtual bool is_unloading() = 0;\n-\n-  void unload_nmethod_caches(bool class_unloading_occurred);\n-  virtual void do_unloading(bool unloading_occurred) = 0;\n-\n-private:\n-  PcDesc* find_pc_desc(address pc, bool approximate) {\n-    return _pc_desc_container.find_pc_desc(pc, approximate, PcDescSearch(code_begin(), scopes_pcs_begin(), scopes_pcs_end()));\n-  }\n-};\n-\n-#endif \/\/ SHARE_CODE_COMPILEDMETHOD_HPP\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":0,"deletions":415,"binary":false,"changes":415,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_CODE_COMPILEDMETHOD_INLINE_HPP\n-#define SHARE_CODE_COMPILEDMETHOD_INLINE_HPP\n-\n-#include \"code\/compiledMethod.hpp\"\n-\n-#include \"code\/nativeInst.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/frame.hpp\"\n-\n-inline bool CompiledMethod::is_deopt_pc(address pc) { return is_deopt_entry(pc) || is_deopt_mh_entry(pc); }\n-\n-\/\/ When using JVMCI the address might be off by the size of a call instruction.\n-inline bool CompiledMethod::is_deopt_entry(address pc) {\n-  return pc == deopt_handler_begin()\n-#if INCLUDE_JVMCI\n-    || (is_compiled_by_jvmci() && pc == (deopt_handler_begin() + NativeCall::instruction_size))\n-#endif\n-    ;\n-}\n-\n-inline bool CompiledMethod::is_deopt_mh_entry(address pc) {\n-  return pc == deopt_mh_handler_begin()\n-#if INCLUDE_JVMCI\n-    || (is_compiled_by_jvmci() && pc == (deopt_mh_handler_begin() + NativeCall::instruction_size))\n-#endif\n-    ;\n-}\n-\n-\/\/ -----------------------------------------------------------------------------\n-\/\/ CompiledMethod::get_deopt_original_pc\n-\/\/\n-\/\/ Return the original PC for the given PC if:\n-\/\/ (a) the given PC belongs to a nmethod and\n-\/\/ (b) it is a deopt PC\n-\n-inline address CompiledMethod::get_deopt_original_pc(const frame* fr) {\n-  if (fr->cb() == nullptr)  return nullptr;\n-\n-  CompiledMethod* cm = fr->cb()->as_compiled_method_or_null();\n-  if (cm != nullptr && cm->is_deopt_pc(fr->pc()))\n-    return cm->get_original_pc(fr);\n-\n-  return nullptr;\n-}\n-\n-\n-\/\/ class ExceptionCache methods\n-\n-inline int ExceptionCache::count() { return Atomic::load_acquire(&_count); }\n-\n-address ExceptionCache::pc_at(int index) {\n-  assert(index >= 0 && index < count(),\"\");\n-  return _pc[index];\n-}\n-\n-address ExceptionCache::handler_at(int index) {\n-  assert(index >= 0 && index < count(),\"\");\n-  return _handler[index];\n-}\n-\n-\/\/ increment_count is only called under lock, but there may be concurrent readers.\n-inline void ExceptionCache::increment_count() { Atomic::release_store(&_count, _count + 1); }\n-\n-\n-#endif \/\/ SHARE_CODE_COMPILEDMETHOD_INLINE_HPP\n","filename":"src\/hotspot\/share\/code\/compiledMethod.inline.hpp","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,9 +56,3 @@\n-  nmethod* nm = const_cast<CompiledMethod*>(code())->as_nmethod_or_null();\n-  oop o;\n-  if (nm != nullptr) {\n-    \/\/ Despite these oops being found inside nmethods that are on-stack,\n-    \/\/ they are not kept alive by all GCs (e.g. G1 and Shenandoah).\n-    o = nm->oop_at_phantom(read_int());\n-  } else {\n-    o = code()->oop_at(read_int());\n-  }\n+  \/\/ Despite these oops being found inside nmethods that are on-stack,\n+  \/\/ they are not kept alive by all GCs (e.g. G1 and Shenandoah).\n+  oop o = code()->oop_at_phantom(read_int());\n@@ -253,1 +247,1 @@\n-    _selected = new ObjectValue(id());\n+    _selected = new ObjectValue(id(), nullptr, false);\n@@ -259,2 +253,1 @@\n-    \/\/ No need to rematerialize\n-    return nullptr;\n+    return _selected;\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,2 @@\n+  bool                       _is_scalar_replaced;      \/\/ Whether this ObjectValue describes an object scalar replaced or just\n+                                                       \/\/ an object (possibly null) participating in an allocation merge.\n@@ -141,1 +143,1 @@\n-  ObjectValue(int id, ScopeValue* klass)\n+  ObjectValue(int id, ScopeValue* klass = nullptr, bool is_scalar_replaced = true)\n@@ -147,0 +149,1 @@\n+     , _is_scalar_replaced(is_scalar_replaced)\n@@ -148,1 +151,1 @@\n-    assert(klass->is_constant_oop(), \"should be constant java mirror oop\");\n+    assert(klass == nullptr || klass->is_constant_oop(), \"should be constant java mirror oop\");\n@@ -151,8 +154,0 @@\n-  ObjectValue(int id)\n-     : _id(id)\n-     , _klass(nullptr)\n-     , _field_values()\n-     , _value()\n-     , _visited(false)\n-     , _is_root(true) {}\n-\n@@ -168,0 +163,1 @@\n+  bool                        is_scalar_replaced() const  { return _is_scalar_replaced; }\n@@ -170,1 +166,1 @@\n-  void                        set_id(int id)              { _id = id; }\n+  void                        set_id(int id)                   { _id = id; }\n@@ -172,2 +168,3 @@\n-  void                        set_visited(bool visited)   { _visited = visited; }\n-  void                        set_root(bool root)         { _is_root = root; }\n+  void                        set_visited(bool visited)        { _visited = visited; }\n+  void                        set_is_scalar_replaced(bool scd) { _is_scalar_replaced = scd; }\n+  void                        set_root(bool root)              { _is_root = root; }\n@@ -211,1 +208,1 @@\n-     : ObjectValue(id)\n+     : ObjectValue(id, nullptr, false)\n@@ -218,1 +215,1 @@\n-     : ObjectValue(id)\n+     : ObjectValue(id, nullptr, false)\n@@ -375,2 +372,2 @@\n-  const CompiledMethod* _code;\n-  const CompiledMethod* code() const { return _code; }\n+  const nmethod* _code;\n+  const nmethod* code() const { return _code; }\n@@ -379,1 +376,1 @@\n-  DebugInfoReadStream(const CompiledMethod* code, int offset, GrowableArray<ScopeValue*>* obj_pool = nullptr) :\n+  DebugInfoReadStream(const nmethod* code, int offset, GrowableArray<ScopeValue*>* obj_pool = nullptr) :\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,1 @@\n-         \"must specify a new, larger pc offset\");\n+         \"must specify a new, larger pc offset: %d >= %d\", last_pc()->pc_offset(), pc_offset);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,3 +68,3 @@\n-ExceptionHandlerTable::ExceptionHandlerTable(const CompiledMethod* cm) {\n-  _table  = (HandlerTableEntry*)cm->handler_table_begin();\n-  _length = cm->handler_table_size() \/ sizeof(HandlerTableEntry);\n+ExceptionHandlerTable::ExceptionHandlerTable(const nmethod* nm) {\n+  _table  = (HandlerTableEntry*)nm->handler_table_begin();\n+  _length = nm->handler_table_size() \/ sizeof(HandlerTableEntry);\n@@ -101,3 +101,3 @@\n-void ExceptionHandlerTable::copy_to(CompiledMethod* cm) {\n-  assert(size_in_bytes() == cm->handler_table_size(), \"size of space allocated in compiled method incorrect\");\n-  copy_bytes_to(cm->handler_table_begin());\n+void ExceptionHandlerTable::copy_to(nmethod* nm) {\n+  assert(size_in_bytes() == nm->handler_table_size(), \"size of space allocated in compiled method incorrect\");\n+  copy_bytes_to(nm->handler_table_begin());\n@@ -218,1 +218,1 @@\n-ImplicitExceptionTable::ImplicitExceptionTable(const CompiledMethod* nm) {\n+ImplicitExceptionTable::ImplicitExceptionTable(const nmethod* nm) {\n","filename":"src\/hotspot\/share\/code\/exceptionHandlerTable.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-  ExceptionHandlerTable(const CompiledMethod* nm);\n+  ExceptionHandlerTable(const nmethod* nm);\n@@ -119,1 +119,1 @@\n-  void copy_to(CompiledMethod* nm);\n+  void copy_to(nmethod* nm);\n@@ -153,1 +153,1 @@\n-  ImplicitExceptionTable( const CompiledMethod *nm );\n+  ImplicitExceptionTable(const nmethod *nm);\n","filename":"src\/hotspot\/share\/code\/exceptionHandlerTable.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"code\/compiledMethod.inline.hpp\"\n@@ -32,1 +31,1 @@\n-#include \"code\/nmethod.hpp\"\n+#include \"code\/nmethod.inline.hpp\"\n@@ -47,1 +46,1 @@\n-#include \"interpreter\/bytecode.hpp\"\n+#include \"interpreter\/bytecode.inline.hpp\"\n@@ -101,3 +100,3 @@\n-        (char *) klass_name->bytes(), klass_name->utf8_length(),                   \\\n-        (char *) name->bytes(), name->utf8_length(),                               \\\n-        (char *) signature->bytes(), signature->utf8_length());                    \\\n+        (char *) klass_name->bytes(), klass_name->utf8_length(),          \\\n+        (char *) name->bytes(), name->utf8_length(),                      \\\n+        (char *) signature->bytes(), signature->utf8_length());           \\\n@@ -141,0 +140,3 @@\n+  uint size_gt_32k;\n+  int size_max;\n+\n@@ -159,0 +161,3 @@\n+    int short_pos_max = ((1<<15) - 1);\n+    if (nm->size() > short_pos_max) size_gt_32k++;\n+    if (nm->size() > size_max) size_max = nm->size();\n@@ -163,13 +168,14 @@\n-    if (total_size != 0)          tty->print_cr(\" total in heap  = %u\", total_size);\n-    if (nmethod_count != 0)       tty->print_cr(\" header         = \" SIZE_FORMAT, nmethod_count * sizeof(nmethod));\n-    if (relocation_size != 0)     tty->print_cr(\" relocation     = %u\", relocation_size);\n-    if (consts_size != 0)         tty->print_cr(\" constants      = %u\", consts_size);\n-    if (insts_size != 0)          tty->print_cr(\" main code      = %u\", insts_size);\n-    if (stub_size != 0)           tty->print_cr(\" stub code      = %u\", stub_size);\n-    if (oops_size != 0)           tty->print_cr(\" oops           = %u\", oops_size);\n-    if (metadata_size != 0)       tty->print_cr(\" metadata       = %u\", metadata_size);\n-    if (scopes_data_size != 0)    tty->print_cr(\" scopes data    = %u\", scopes_data_size);\n-    if (scopes_pcs_size != 0)     tty->print_cr(\" scopes pcs     = %u\", scopes_pcs_size);\n-    if (dependencies_size != 0)   tty->print_cr(\" dependencies   = %u\", dependencies_size);\n-    if (handler_table_size != 0)  tty->print_cr(\" handler table  = %u\", handler_table_size);\n-    if (nul_chk_table_size != 0)  tty->print_cr(\" nul chk table  = %u\", nul_chk_table_size);\n+    if (total_size != 0)          tty->print_cr(\" total in heap  = %u (100%%)\", total_size);\n+    uint header_size = (uint)(nmethod_count * sizeof(nmethod));\n+    if (nmethod_count != 0)       tty->print_cr(\" header         = %u (%f%%)\", header_size, (header_size * 100.0f)\/total_size);\n+    if (relocation_size != 0)     tty->print_cr(\" relocation     = %u (%f%%)\", relocation_size, (relocation_size * 100.0f)\/total_size);\n+    if (consts_size != 0)         tty->print_cr(\" constants      = %u (%f%%)\", consts_size, (consts_size * 100.0f)\/total_size);\n+    if (insts_size != 0)          tty->print_cr(\" main code      = %u (%f%%)\", insts_size, (insts_size * 100.0f)\/total_size);\n+    if (stub_size != 0)           tty->print_cr(\" stub code      = %u (%f%%)\", stub_size, (stub_size * 100.0f)\/total_size);\n+    if (oops_size != 0)           tty->print_cr(\" oops           = %u (%f%%)\", oops_size, (oops_size * 100.0f)\/total_size);\n+    if (metadata_size != 0)       tty->print_cr(\" metadata       = %u (%f%%)\", metadata_size, (metadata_size * 100.0f)\/total_size);\n+    if (scopes_data_size != 0)    tty->print_cr(\" scopes data    = %u (%f%%)\", scopes_data_size, (scopes_data_size * 100.0f)\/total_size);\n+    if (scopes_pcs_size != 0)     tty->print_cr(\" scopes pcs     = %u (%f%%)\", scopes_pcs_size, (scopes_pcs_size * 100.0f)\/total_size);\n+    if (dependencies_size != 0)   tty->print_cr(\" dependencies   = %u (%f%%)\", dependencies_size, (dependencies_size * 100.0f)\/total_size);\n+    if (handler_table_size != 0)  tty->print_cr(\" handler table  = %u (%f%%)\", handler_table_size, (handler_table_size * 100.0f)\/total_size);\n+    if (nul_chk_table_size != 0)  tty->print_cr(\" nul chk table  = %u (%f%%)\", nul_chk_table_size, (nul_chk_table_size * 100.0f)\/total_size);\n@@ -177,2 +183,2 @@\n-    if (speculations_size != 0)   tty->print_cr(\" speculations   = %u\", speculations_size);\n-    if (jvmci_data_size != 0)     tty->print_cr(\" JVMCI data     = %u\", jvmci_data_size);\n+    if (speculations_size != 0)   tty->print_cr(\" speculations   = %u (%f%%)\", speculations_size, (speculations_size * 100.0f)\/total_size);\n+    if (jvmci_data_size != 0)     tty->print_cr(\" JVMCI data     = %u (%f%%)\", jvmci_data_size, (jvmci_data_size * 100.0f)\/total_size);\n@@ -180,0 +186,2 @@\n+    if (size_gt_32k != 0)         tty->print_cr(\" size > 32k     = %u\", size_gt_32k);\n+    if (size_max != 0)            tty->print_cr(\" max size       = %d\", size_max);\n@@ -420,0 +428,552 @@\n+bool nmethod::is_method_handle_return(address return_pc) {\n+  if (!has_method_handle_invokes())  return false;\n+  PcDesc* pd = pc_desc_at(return_pc);\n+  if (pd == nullptr)\n+    return false;\n+  return pd->is_method_handle_invoke();\n+}\n+\n+\/\/ Returns a string version of the method state.\n+const char* nmethod::state() const {\n+  int state = get_state();\n+  switch (state) {\n+  case not_installed:\n+    return \"not installed\";\n+  case in_use:\n+    return \"in use\";\n+  case not_entrant:\n+    return \"not_entrant\";\n+  default:\n+    fatal(\"unexpected method state: %d\", state);\n+    return nullptr;\n+  }\n+}\n+\n+void nmethod::set_deoptimized_done() {\n+  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+  if (_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n+    Atomic::store(&_deoptimization_status, deoptimize_done);\n+  }\n+}\n+\n+ExceptionCache* nmethod::exception_cache_acquire() const {\n+  return Atomic::load_acquire(&_exception_cache);\n+}\n+\n+void nmethod::add_exception_cache_entry(ExceptionCache* new_entry) {\n+  assert(ExceptionCache_lock->owned_by_self(),\"Must hold the ExceptionCache_lock\");\n+  assert(new_entry != nullptr,\"Must be non null\");\n+  assert(new_entry->next() == nullptr, \"Must be null\");\n+\n+  for (;;) {\n+    ExceptionCache *ec = exception_cache();\n+    if (ec != nullptr) {\n+      Klass* ex_klass = ec->exception_type();\n+      if (!ex_klass->is_loader_alive()) {\n+        \/\/ We must guarantee that entries are not inserted with new next pointer\n+        \/\/ edges to ExceptionCache entries with dead klasses, due to bad interactions\n+        \/\/ with concurrent ExceptionCache cleanup. Therefore, the inserts roll\n+        \/\/ the head pointer forward to the first live ExceptionCache, so that the new\n+        \/\/ next pointers always point at live ExceptionCaches, that are not removed due\n+        \/\/ to concurrent ExceptionCache cleanup.\n+        ExceptionCache* next = ec->next();\n+        if (Atomic::cmpxchg(&_exception_cache, ec, next) == ec) {\n+          CodeCache::release_exception_cache(ec);\n+        }\n+        continue;\n+      }\n+      ec = exception_cache();\n+      if (ec != nullptr) {\n+        new_entry->set_next(ec);\n+      }\n+    }\n+    if (Atomic::cmpxchg(&_exception_cache, ec, new_entry) == ec) {\n+      return;\n+    }\n+  }\n+}\n+\n+void nmethod::clean_exception_cache() {\n+  \/\/ For each nmethod, only a single thread may call this cleanup function\n+  \/\/ at the same time, whether called in STW cleanup or concurrent cleanup.\n+  \/\/ Note that if the GC is processing exception cache cleaning in a concurrent phase,\n+  \/\/ then a single writer may contend with cleaning up the head pointer to the\n+  \/\/ first ExceptionCache node that has a Klass* that is alive. That is fine,\n+  \/\/ as long as there is no concurrent cleanup of next pointers from concurrent writers.\n+  \/\/ And the concurrent writers do not clean up next pointers, only the head.\n+  \/\/ Also note that concurrent readers will walk through Klass* pointers that are not\n+  \/\/ alive. That does not cause ABA problems, because Klass* is deleted after\n+  \/\/ a handshake with all threads, after all stale ExceptionCaches have been\n+  \/\/ unlinked. That is also when the CodeCache::exception_cache_purge_list()\n+  \/\/ is deleted, with all ExceptionCache entries that were cleaned concurrently.\n+  \/\/ That similarly implies that CAS operations on ExceptionCache entries do not\n+  \/\/ suffer from ABA problems as unlinking and deletion is separated by a global\n+  \/\/ handshake operation.\n+  ExceptionCache* prev = nullptr;\n+  ExceptionCache* curr = exception_cache_acquire();\n+\n+  while (curr != nullptr) {\n+    ExceptionCache* next = curr->next();\n+\n+    if (!curr->exception_type()->is_loader_alive()) {\n+      if (prev == nullptr) {\n+        \/\/ Try to clean head; this is contended by concurrent inserts, that\n+        \/\/ both lazily clean the head, and insert entries at the head. If\n+        \/\/ the CAS fails, the operation is restarted.\n+        if (Atomic::cmpxchg(&_exception_cache, curr, next) != curr) {\n+          prev = nullptr;\n+          curr = exception_cache_acquire();\n+          continue;\n+        }\n+      } else {\n+        \/\/ It is impossible to during cleanup connect the next pointer to\n+        \/\/ an ExceptionCache that has not been published before a safepoint\n+        \/\/ prior to the cleanup. Therefore, release is not required.\n+        prev->set_next(next);\n+      }\n+      \/\/ prev stays the same.\n+\n+      CodeCache::release_exception_cache(curr);\n+    } else {\n+      prev = curr;\n+    }\n+\n+    curr = next;\n+  }\n+}\n+\n+\/\/ public method for accessing the exception cache\n+\/\/ These are the public access methods.\n+address nmethod::handler_for_exception_and_pc(Handle exception, address pc) {\n+  \/\/ We never grab a lock to read the exception cache, so we may\n+  \/\/ have false negatives. This is okay, as it can only happen during\n+  \/\/ the first few exception lookups for a given nmethod.\n+  ExceptionCache* ec = exception_cache_acquire();\n+  while (ec != nullptr) {\n+    address ret_val;\n+    if ((ret_val = ec->match(exception,pc)) != nullptr) {\n+      return ret_val;\n+    }\n+    ec = ec->next();\n+  }\n+  return nullptr;\n+}\n+\n+void nmethod::add_handler_for_exception_and_pc(Handle exception, address pc, address handler) {\n+  \/\/ There are potential race conditions during exception cache updates, so we\n+  \/\/ must own the ExceptionCache_lock before doing ANY modifications. Because\n+  \/\/ we don't lock during reads, it is possible to have several threads attempt\n+  \/\/ to update the cache with the same data. We need to check for already inserted\n+  \/\/ copies of the current data before adding it.\n+\n+  MutexLocker ml(ExceptionCache_lock);\n+  ExceptionCache* target_entry = exception_cache_entry_for_exception(exception);\n+\n+  if (target_entry == nullptr || !target_entry->add_address_and_handler(pc,handler)) {\n+    target_entry = new ExceptionCache(exception,pc,handler);\n+    add_exception_cache_entry(target_entry);\n+  }\n+}\n+\n+\/\/ private method for handling exception cache\n+\/\/ These methods are private, and used to manipulate the exception cache\n+\/\/ directly.\n+ExceptionCache* nmethod::exception_cache_entry_for_exception(Handle exception) {\n+  ExceptionCache* ec = exception_cache_acquire();\n+  while (ec != nullptr) {\n+    if (ec->match_exception_with_space(exception)) {\n+      return ec;\n+    }\n+    ec = ec->next();\n+  }\n+  return nullptr;\n+}\n+\n+bool nmethod::is_at_poll_return(address pc) {\n+  RelocIterator iter(this, pc, pc+1);\n+  while (iter.next()) {\n+    if (iter.type() == relocInfo::poll_return_type)\n+      return true;\n+  }\n+  return false;\n+}\n+\n+\n+bool nmethod::is_at_poll_or_poll_return(address pc) {\n+  RelocIterator iter(this, pc, pc+1);\n+  while (iter.next()) {\n+    relocInfo::relocType t = iter.type();\n+    if (t == relocInfo::poll_return_type || t == relocInfo::poll_type)\n+      return true;\n+  }\n+  return false;\n+}\n+\n+void nmethod::verify_oop_relocations() {\n+  \/\/ Ensure sure that the code matches the current oop values\n+  RelocIterator iter(this, nullptr, nullptr);\n+  while (iter.next()) {\n+    if (iter.type() == relocInfo::oop_type) {\n+      oop_Relocation* reloc = iter.oop_reloc();\n+      if (!reloc->oop_is_immediate()) {\n+        reloc->verify_oop_relocation();\n+      }\n+    }\n+  }\n+}\n+\n+\n+ScopeDesc* nmethod::scope_desc_at(address pc) {\n+  PcDesc* pd = pc_desc_at(pc);\n+  guarantee(pd != nullptr, \"scope must be present\");\n+  return new ScopeDesc(this, pd);\n+}\n+\n+ScopeDesc* nmethod::scope_desc_near(address pc) {\n+  PcDesc* pd = pc_desc_near(pc);\n+  guarantee(pd != nullptr, \"scope must be present\");\n+  return new ScopeDesc(this, pd);\n+}\n+\n+address nmethod::oops_reloc_begin() const {\n+  \/\/ If the method is not entrant then a JMP is plastered over the\n+  \/\/ first few bytes.  If an oop in the old code was there, that oop\n+  \/\/ should not get GC'd.  Skip the first few bytes of oops on\n+  \/\/ not-entrant methods.\n+  if (frame_complete_offset() != CodeOffsets::frame_never_safe &&\n+      code_begin() + frame_complete_offset() >\n+      verified_entry_point() + NativeJump::instruction_size)\n+  {\n+    \/\/ If we have a frame_complete_offset after the native jump, then there\n+    \/\/ is no point trying to look for oops before that. This is a requirement\n+    \/\/ for being allowed to scan oops concurrently.\n+    return code_begin() + frame_complete_offset();\n+  }\n+\n+  \/\/ It is not safe to read oops concurrently using entry barriers, if their\n+  \/\/ location depend on whether the nmethod is entrant or not.\n+  \/\/ assert(BarrierSet::barrier_set()->barrier_set_nmethod() == nullptr, \"Not safe oop scan\");\n+\n+  address low_boundary = verified_entry_point();\n+  if (!is_in_use()) {\n+    low_boundary += NativeJump::instruction_size;\n+    \/\/ %%% Note:  On SPARC we patch only a 4-byte trap, not a full NativeJump.\n+    \/\/ This means that the low_boundary is going to be a little too high.\n+    \/\/ This shouldn't matter, since oops of non-entrant methods are never used.\n+    \/\/ In fact, why are we bothering to look at oops in a non-entrant method??\n+  }\n+  return low_boundary;\n+}\n+\n+\/\/ Method that knows how to preserve outgoing arguments at call. This method must be\n+\/\/ called with a frame corresponding to a Java invoke\n+void nmethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {\n+  if (method() == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ handle the case of an anchor explicitly set in continuation code that doesn't have a callee\n+  JavaThread* thread = reg_map->thread();\n+  if (thread->has_last_Java_frame() && fr.sp() == thread->last_Java_sp()) {\n+    return;\n+  }\n+\n+  if (!method()->is_native()) {\n+    address pc = fr.pc();\n+    bool has_receiver, has_appendix;\n+    Symbol* signature;\n+\n+    \/\/ The method attached by JIT-compilers should be used, if present.\n+    \/\/ Bytecode can be inaccurate in such case.\n+    Method* callee = attached_method_before_pc(pc);\n+    if (callee != nullptr) {\n+      has_receiver = !(callee->access_flags().is_static());\n+      has_appendix = false;\n+      signature    = callee->signature();\n+    } else {\n+      SimpleScopeDesc ssd(this, pc);\n+\n+      Bytecode_invoke call(methodHandle(Thread::current(), ssd.method()), ssd.bci());\n+      has_receiver = call.has_receiver();\n+      has_appendix = call.has_appendix();\n+      signature    = call.signature();\n+    }\n+\n+    fr.oops_compiled_arguments_do(signature, has_receiver, has_appendix, reg_map, f);\n+  } else if (method()->is_continuation_enter_intrinsic()) {\n+    \/\/ This method only calls Continuation.enter()\n+    Symbol* signature = vmSymbols::continuationEnter_signature();\n+    fr.oops_compiled_arguments_do(signature, false, false, reg_map, f);\n+  }\n+}\n+\n+Method* nmethod::attached_method(address call_instr) {\n+  assert(code_contains(call_instr), \"not part of the nmethod\");\n+  RelocIterator iter(this, call_instr, call_instr + 1);\n+  while (iter.next()) {\n+    if (iter.addr() == call_instr) {\n+      switch(iter.type()) {\n+        case relocInfo::static_call_type:      return iter.static_call_reloc()->method_value();\n+        case relocInfo::opt_virtual_call_type: return iter.opt_virtual_call_reloc()->method_value();\n+        case relocInfo::virtual_call_type:     return iter.virtual_call_reloc()->method_value();\n+        default:                               break;\n+      }\n+    }\n+  }\n+  return nullptr; \/\/ not found\n+}\n+\n+Method* nmethod::attached_method_before_pc(address pc) {\n+  if (NativeCall::is_call_before(pc)) {\n+    NativeCall* ncall = nativeCall_before(pc);\n+    return attached_method(ncall->instruction_address());\n+  }\n+  return nullptr; \/\/ not a call\n+}\n+\n+void nmethod::clear_inline_caches() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"clearing of IC's only allowed at safepoint\");\n+  RelocIterator iter(this);\n+  while (iter.next()) {\n+    iter.reloc()->clear_inline_cache();\n+  }\n+}\n+\n+#ifdef ASSERT\n+\/\/ Check class_loader is alive for this bit of metadata.\n+class CheckClass : public MetadataClosure {\n+  void do_metadata(Metadata* md) {\n+    Klass* klass = nullptr;\n+    if (md->is_klass()) {\n+      klass = ((Klass*)md);\n+    } else if (md->is_method()) {\n+      klass = ((Method*)md)->method_holder();\n+    } else if (md->is_methodData()) {\n+      klass = ((MethodData*)md)->method()->method_holder();\n+    } else {\n+      md->print();\n+      ShouldNotReachHere();\n+    }\n+    assert(klass->is_loader_alive(), \"must be alive\");\n+  }\n+};\n+#endif \/\/ ASSERT\n+\n+\n+static void clean_ic_if_metadata_is_dead(CompiledIC *ic) {\n+  ic->clean_metadata();\n+}\n+\n+\/\/ Clean references to unloaded nmethods at addr from this one, which is not unloaded.\n+template <typename CallsiteT>\n+static void clean_if_nmethod_is_unloaded(CallsiteT* callsite, nmethod* from,\n+                                         bool clean_all) {\n+  CodeBlob* cb = CodeCache::find_blob(callsite->destination());\n+  if (!cb->is_nmethod()) {\n+    return;\n+  }\n+  nmethod* nm = cb->as_nmethod();\n+  if (clean_all || !nm->is_in_use() || nm->is_unloading() || nm->method()->code() != nm) {\n+    callsite->set_to_clean();\n+  }\n+}\n+\n+\/\/ Cleans caches in nmethods that point to either classes that are unloaded\n+\/\/ or nmethods that are unloaded.\n+\/\/\n+\/\/ Can be called either in parallel by G1 currently or after all\n+\/\/ nmethods are unloaded.  Return postponed=true in the parallel case for\n+\/\/ inline caches found that point to nmethods that are not yet visited during\n+\/\/ the do_unloading walk.\n+void nmethod::unload_nmethod_caches(bool unloading_occurred) {\n+  ResourceMark rm;\n+\n+  \/\/ Exception cache only needs to be called if unloading occurred\n+  if (unloading_occurred) {\n+    clean_exception_cache();\n+  }\n+\n+  cleanup_inline_caches_impl(unloading_occurred, false);\n+\n+#ifdef ASSERT\n+  \/\/ Check that the metadata embedded in the nmethod is alive\n+  CheckClass check_class;\n+  metadata_do(&check_class);\n+#endif\n+}\n+\n+void nmethod::run_nmethod_entry_barrier() {\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm != nullptr) {\n+    \/\/ We want to keep an invariant that nmethods found through iterations of a Thread's\n+    \/\/ nmethods found in safepoints have gone through an entry barrier and are not armed.\n+    \/\/ By calling this nmethod entry barrier, it plays along and acts\n+    \/\/ like any other nmethod found on the stack of a thread (fewer surprises).\n+    nmethod* nm = this;\n+    if (bs_nm->is_armed(nm)) {\n+      bool alive = bs_nm->nmethod_entry_barrier(nm);\n+      assert(alive, \"should be alive\");\n+    }\n+  }\n+}\n+\n+\/\/ Only called by whitebox test\n+void nmethod::cleanup_inline_caches_whitebox() {\n+  assert_locked_or_safepoint(CodeCache_lock);\n+  CompiledICLocker ic_locker(this);\n+  cleanup_inline_caches_impl(false \/* unloading_occurred *\/, true \/* clean_all *\/);\n+}\n+\n+address* nmethod::orig_pc_addr(const frame* fr) {\n+  return (address*) ((address)fr->unextended_sp() + orig_pc_offset());\n+}\n+\n+\/\/ Called to clean up after class unloading for live nmethods\n+void nmethod::cleanup_inline_caches_impl(bool unloading_occurred, bool clean_all) {\n+  assert(CompiledICLocker::is_safe(this), \"mt unsafe call\");\n+  ResourceMark rm;\n+\n+  \/\/ Find all calls in an nmethod and clear the ones that point to bad nmethods.\n+  RelocIterator iter(this, oops_reloc_begin());\n+  bool is_in_static_stub = false;\n+  while(iter.next()) {\n+\n+    switch (iter.type()) {\n+\n+    case relocInfo::virtual_call_type:\n+      if (unloading_occurred) {\n+        \/\/ If class unloading occurred we first clear ICs where the cached metadata\n+        \/\/ is referring to an unloaded klass or method.\n+        clean_ic_if_metadata_is_dead(CompiledIC_at(&iter));\n+      }\n+\n+      clean_if_nmethod_is_unloaded(CompiledIC_at(&iter), this, clean_all);\n+      break;\n+\n+    case relocInfo::opt_virtual_call_type:\n+    case relocInfo::static_call_type:\n+      clean_if_nmethod_is_unloaded(CompiledDirectCall::at(iter.reloc()), this, clean_all);\n+      break;\n+\n+    case relocInfo::static_stub_type: {\n+      is_in_static_stub = true;\n+      break;\n+    }\n+\n+    case relocInfo::metadata_type: {\n+      \/\/ Only the metadata relocations contained in static\/opt virtual call stubs\n+      \/\/ contains the Method* passed to c2i adapters. It is the only metadata\n+      \/\/ relocation that needs to be walked, as it is the one metadata relocation\n+      \/\/ that violates the invariant that all metadata relocations have an oop\n+      \/\/ in the compiled method (due to deferred resolution and code patching).\n+\n+      \/\/ This causes dead metadata to remain in compiled methods that are not\n+      \/\/ unloading. Unless these slippery metadata relocations of the static\n+      \/\/ stubs are at least cleared, subsequent class redefinition operations\n+      \/\/ will access potentially free memory, and JavaThread execution\n+      \/\/ concurrent to class unloading may call c2i adapters with dead methods.\n+      if (!is_in_static_stub) {\n+        \/\/ The first metadata relocation after a static stub relocation is the\n+        \/\/ metadata relocation of the static stub used to pass the Method* to\n+        \/\/ c2i adapters.\n+        continue;\n+      }\n+      is_in_static_stub = false;\n+      if (is_unloading()) {\n+        \/\/ If the nmethod itself is dying, then it may point at dead metadata.\n+        \/\/ Nobody should follow that metadata; it is strictly unsafe.\n+        continue;\n+      }\n+      metadata_Relocation* r = iter.metadata_reloc();\n+      Metadata* md = r->metadata_value();\n+      if (md != nullptr && md->is_method()) {\n+        Method* method = static_cast<Method*>(md);\n+        if (!method->method_holder()->is_loader_alive()) {\n+          Atomic::store(r->metadata_addr(), (Method*)nullptr);\n+\n+          if (!r->metadata_is_immediate()) {\n+            r->fix_metadata_relocation();\n+          }\n+        }\n+      }\n+      break;\n+    }\n+\n+    default:\n+      break;\n+    }\n+  }\n+}\n+\n+address nmethod::continuation_for_implicit_exception(address pc, bool for_div0_check) {\n+  \/\/ Exception happened outside inline-cache check code => we are inside\n+  \/\/ an active nmethod => use cpc to determine a return address\n+  int exception_offset = int(pc - code_begin());\n+  int cont_offset = ImplicitExceptionTable(this).continuation_offset( exception_offset );\n+#ifdef ASSERT\n+  if (cont_offset == 0) {\n+    Thread* thread = Thread::current();\n+    ResourceMark rm(thread);\n+    CodeBlob* cb = CodeCache::find_blob(pc);\n+    assert(cb != nullptr && cb == this, \"\");\n+\n+    \/\/ Keep tty output consistent. To avoid ttyLocker, we buffer in stream, and print all at once.\n+    stringStream ss;\n+    ss.print_cr(\"implicit exception happened at \" INTPTR_FORMAT, p2i(pc));\n+    print_on(&ss);\n+    method()->print_codes_on(&ss);\n+    print_code_on(&ss);\n+    print_pcs_on(&ss);\n+    tty->print(\"%s\", ss.as_string()); \/\/ print all at once\n+  }\n+#endif\n+  if (cont_offset == 0) {\n+    \/\/ Let the normal error handling report the exception\n+    return nullptr;\n+  }\n+  if (cont_offset == exception_offset) {\n+#if INCLUDE_JVMCI\n+    Deoptimization::DeoptReason deopt_reason = for_div0_check ? Deoptimization::Reason_div0_check : Deoptimization::Reason_null_check;\n+    JavaThread *thread = JavaThread::current();\n+    thread->set_jvmci_implicit_exception_pc(pc);\n+    thread->set_pending_deoptimization(Deoptimization::make_trap_request(deopt_reason,\n+                                                                         Deoptimization::Action_reinterpret));\n+    return (SharedRuntime::deopt_blob()->implicit_exception_uncommon_trap());\n+#else\n+    ShouldNotReachHere();\n+#endif\n+  }\n+  return code_begin() + cont_offset;\n+}\n+\n+class HasEvolDependency : public MetadataClosure {\n+  bool _has_evol_dependency;\n+ public:\n+  HasEvolDependency() : _has_evol_dependency(false) {}\n+  void do_metadata(Metadata* md) {\n+    if (md->is_method()) {\n+      Method* method = (Method*)md;\n+      if (method->is_old()) {\n+        _has_evol_dependency = true;\n+      }\n+    }\n+  }\n+  bool has_evol_dependency() const { return _has_evol_dependency; }\n+};\n+\n+bool nmethod::has_evol_metadata() {\n+  \/\/ Check the metadata in relocIter and CompiledIC and also deoptimize\n+  \/\/ any nmethod that has reference to old methods.\n+  HasEvolDependency check_evol;\n+  metadata_do(&check_evol);\n+  if (check_evol.has_evol_dependency() && log_is_enabled(Debug, redefine, class, nmethod)) {\n+    ResourceMark rm;\n+    log_debug(redefine, class, nmethod)\n+            (\"Found evol dependency of nmethod %s.%s(%s) compile_id=%d on in nmethod metadata\",\n+             _method->method_holder()->external_name(),\n+             _method->name()->as_C_string(),\n+             _method->signature()->as_C_string(),\n+             compile_id());\n+  }\n+  return check_evol.has_evol_dependency();\n+}\n@@ -443,0 +1003,4 @@\n+const char* nmethod::compiler_name() const {\n+  return compilertype2name(_compiler_type);\n+}\n+\n@@ -445,0 +1009,8 @@\n+  \/\/ avoid uninitialized fields, even for short time periods\n+  _exception_cache            = nullptr;\n+\n+  _has_unsafe_access          = 0;\n+  _has_method_handle_invokes  = 0;\n+  _has_wide_vectors           = 0;\n+  _has_monitors               = 0;\n+\n@@ -449,2 +1021,2 @@\n-  _oops_do_mark_link       = nullptr;\n-  _osr_link                = nullptr;\n+  _oops_do_mark_link          = nullptr;\n+  _osr_link                   = nullptr;\n@@ -452,1 +1024,1 @@\n-  _rtm_state               = NoRTM;\n+  _rtm_state                  = NoRTM;\n@@ -642,1 +1214,5 @@\n-  : CompiledMethod(method, \"native nmethod\", type, nmethod_size, sizeof(nmethod), code_buffer, offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false, true),\n+  : CodeBlob(\"native nmethod\", CodeBlobKind::Nmethod, code_buffer, nmethod_size, sizeof(nmethod),\n+             offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),\n+  _deoptimization_generation(0),\n+  _method(method),\n+  _gc_data(nullptr),\n@@ -647,1 +1223,2 @@\n-  _is_unloading_state(0)\n+  _is_unloading_state(0),\n+  _deoptimization_status(not_marked)\n@@ -650,4 +1227,0 @@\n-    int scopes_data_offset   = 0;\n-    int deoptimize_offset    = 0;\n-    int deoptimize_mh_offset = 0;\n-\n@@ -664,0 +1237,2 @@\n+    _deopt_handler_offset    = 0;\n+    _deopt_mh_handler_offset = 0;\n@@ -670,2 +1245,2 @@\n-    scopes_data_offset       = _metadata_offset      + align_up(code_buffer->total_metadata_size(), wordSize);\n-    _scopes_pcs_offset       = scopes_data_offset;\n+    _scopes_data_offset      = _metadata_offset      + align_up(code_buffer->total_metadata_size(), wordSize);\n+    _scopes_pcs_offset       = _scopes_data_offset;\n@@ -684,0 +1259,1 @@\n+    _compiler_type           = type;\n@@ -692,4 +1268,0 @@\n-    _scopes_data_begin = (address) this + scopes_data_offset;\n-    _deopt_handler_begin = (address) this + deoptimize_offset;\n-    _deopt_mh_handler_begin = (address) this + deoptimize_mh_offset;\n-\n@@ -787,1 +1359,5 @@\n-  : CompiledMethod(method, \"nmethod\", type, nmethod_size, sizeof(nmethod), code_buffer, offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false, true),\n+  : CodeBlob(\"nmethod\", CodeBlobKind::Nmethod, code_buffer, nmethod_size, sizeof(nmethod),\n+             offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),\n+  _deoptimization_generation(0),\n+  _method(method),\n+  _gc_data(nullptr),\n@@ -792,1 +1368,2 @@\n-  _is_unloading_state(0)\n+  _is_unloading_state(0),\n+  _deoptimization_status(not_marked)\n@@ -799,3 +1376,0 @@\n-    _deopt_handler_begin = (address) this;\n-    _deopt_mh_handler_begin = (address) this;\n-\n@@ -803,5 +1377,6 @@\n-    _entry_bci               = entry_bci;\n-    _compile_id              = compile_id;\n-    _comp_level              = comp_level;\n-    _orig_pc_offset          = orig_pc_offset;\n-    _gc_epoch                = CodeCache::gc_epoch();\n+    _entry_bci      = entry_bci;\n+    _compile_id     = compile_id;\n+    _compiler_type  = type;\n+    _comp_level     = comp_level;\n+    _orig_pc_offset = orig_pc_offset;\n+    _gc_epoch       = CodeCache::gc_epoch();\n@@ -810,2 +1385,2 @@\n-    _consts_offset           = content_offset()      + code_buffer->total_offset_of(code_buffer->consts());\n-    _stub_offset             = content_offset()      + code_buffer->total_offset_of(code_buffer->stubs());\n+    _consts_offset  = content_offset() + code_buffer->total_offset_of(code_buffer->consts());\n+    _stub_offset    = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n@@ -813,1 +1388,1 @@\n-    _skipped_instructions_size      = code_buffer->total_skipped_instructions_size();\n+    _skipped_instructions_size = code_buffer->total_skipped_instructions_size();\n@@ -819,1 +1394,1 @@\n-        _exception_offset        = code_offset()          + offsets->value(CodeOffsets::Exceptions);\n+        _exception_offset        = code_offset() + offsets->value(CodeOffsets::Exceptions);\n@@ -821,1 +1396,1 @@\n-        _exception_offset = -1;\n+        _exception_offset        = -1;\n@@ -824,1 +1399,1 @@\n-        _deopt_handler_begin       = (address) this + code_offset()          + offsets->value(CodeOffsets::Deopt);\n+        _deopt_handler_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n@@ -826,1 +1401,1 @@\n-        _deopt_handler_begin = nullptr;\n+        _deopt_handler_offset    = -1;\n@@ -829,1 +1404,1 @@\n-        _deopt_mh_handler_begin  = (address) this + code_offset()          + offsets->value(CodeOffsets::DeoptMH);\n+        _deopt_mh_handler_offset = code_offset() + offsets->value(CodeOffsets::DeoptMH);\n@@ -831,1 +1406,1 @@\n-        _deopt_mh_handler_begin = nullptr;\n+        _deopt_mh_handler_offset = -1;\n@@ -840,2 +1415,2 @@\n-      _exception_offset       = _stub_offset          + offsets->value(CodeOffsets::Exceptions);\n-      _deopt_handler_begin    = (address) this + _stub_offset          + offsets->value(CodeOffsets::Deopt);\n+      _exception_offset          = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n+      _deopt_handler_offset      = _stub_offset + offsets->value(CodeOffsets::Deopt);\n@@ -843,1 +1418,1 @@\n-        _deopt_mh_handler_begin  = (address) this + _stub_offset          + offsets->value(CodeOffsets::DeoptMH);\n+        _deopt_mh_handler_offset = _stub_offset + offsets->value(CodeOffsets::DeoptMH);\n@@ -845,1 +1420,1 @@\n-        _deopt_mh_handler_begin  = nullptr;\n+        _deopt_mh_handler_offset = -1;\n@@ -849,1 +1424,1 @@\n-      _unwind_handler_offset = code_offset()         + offsets->value(CodeOffsets::UnwindHandler);\n+      _unwind_handler_offset = code_offset() + offsets->value(CodeOffsets::UnwindHandler);\n@@ -856,1 +1431,1 @@\n-    int scopes_data_offset   = _metadata_offset      + align_up(code_buffer->total_metadata_size(), wordSize);\n+    _scopes_data_offset      = _metadata_offset      + align_up(code_buffer->total_metadata_size(), wordSize);\n@@ -858,1 +1433,1 @@\n-    _scopes_pcs_offset       = scopes_data_offset    + align_up(debug_info->data_size       (), oopSize);\n+    _scopes_pcs_offset       = _scopes_data_offset   + align_up(debug_info->data_size       (), oopSize);\n@@ -874,1 +1449,0 @@\n-    _scopes_data_begin       = (address) this + scopes_data_offset;\n@@ -1297,1 +1871,1 @@\n-  assert_lock_strong(CompiledMethod_lock);\n+  assert_lock_strong(NMethodState_lock);\n@@ -1360,1 +1934,1 @@\n-    ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+    ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -1403,1 +1977,1 @@\n-  } \/\/ leave critical region under CompiledMethod_lock\n+  } \/\/ leave critical region under NMethodState_lock\n@@ -1433,1 +2007,1 @@\n-  \/\/ unlink_from_method will take the CompiledMethod_lock.\n+  \/\/ unlink_from_method will take the NMethodState_lock.\n@@ -1512,1 +2086,1 @@\n-    set_has_flushed_dependencies();\n+    set_has_flushed_dependencies(true);\n@@ -2029,1 +2603,1 @@\n-  assert(has_method_handle_invokes() == (_deopt_mh_handler_begin != nullptr), \"must have deopt mh handler\");\n+  assert(has_method_handle_invokes() == (_deopt_mh_handler_offset != -1), \"must have deopt mh handler\");\n@@ -2246,1 +2820,1 @@\n-    fatal(\"findNMethod did not find this nmethod (\" INTPTR_FORMAT \")\", p2i(this));\n+    fatal(\"find_nmethod did not find this nmethod (\" INTPTR_FORMAT \")\", p2i(this));\n@@ -2329,1 +2903,1 @@\n-  RelocIterator iter((nmethod*)this);\n+  RelocIterator iter(this);\n@@ -2992,2 +3566,2 @@\n-  if (JVMCI_ONLY(_exception_offset >= 0 &&) pos == exception_begin())           label = \"[Exception Handler]\";\n-  if (JVMCI_ONLY(_deopt_handler_begin != nullptr &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n+  if (JVMCI_ONLY(_exception_offset >= 0 &&) pos == exception_begin())          label = \"[Exception Handler]\";\n+  if (JVMCI_ONLY(_deopt_handler_offset != -1 &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":647,"deletions":73,"binary":false,"changes":720,"status":"modified"},{"patch":"@@ -28,2 +28,8 @@\n-#include \"code\/compiledMethod.hpp\"\n-\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/pcDesc.hpp\"\n+#include \"oops\/metadata.hpp\"\n+#include \"oops\/method.hpp\"\n+\n+class AbstractCompiler;\n+class CompiledDirectCall;\n+class CompiledIC;\n@@ -33,0 +39,1 @@\n+class Dependencies;\n@@ -35,0 +42,2 @@\n+class ExceptionHandlerTable;\n+class ImplicitExceptionTable;\n@@ -36,0 +45,2 @@\n+class MetadataClosure;\n+class NativeCallWrapper;\n@@ -37,0 +48,96 @@\n+class ScopeDesc;\n+class xmlStream;\n+\n+\/\/ This class is used internally by nmethods, to cache\n+\/\/ exception\/pc\/handler information.\n+\n+class ExceptionCache : public CHeapObj<mtCode> {\n+  friend class VMStructs;\n+ private:\n+  enum { cache_size = 16 };\n+  Klass*   _exception_type;\n+  address  _pc[cache_size];\n+  address  _handler[cache_size];\n+  volatile int _count;\n+  ExceptionCache* volatile _next;\n+  ExceptionCache* _purge_list_next;\n+\n+  inline address pc_at(int index);\n+  void set_pc_at(int index, address a)      { assert(index >= 0 && index < cache_size,\"\"); _pc[index] = a; }\n+\n+  inline address handler_at(int index);\n+  void set_handler_at(int index, address a) { assert(index >= 0 && index < cache_size,\"\"); _handler[index] = a; }\n+\n+  inline int count();\n+  \/\/ increment_count is only called under lock, but there may be concurrent readers.\n+  void increment_count();\n+\n+ public:\n+\n+  ExceptionCache(Handle exception, address pc, address handler);\n+\n+  Klass*    exception_type()                { return _exception_type; }\n+  ExceptionCache* next();\n+  void      set_next(ExceptionCache *ec);\n+  ExceptionCache* purge_list_next()                 { return _purge_list_next; }\n+  void      set_purge_list_next(ExceptionCache *ec) { _purge_list_next = ec; }\n+\n+  address match(Handle exception, address pc);\n+  bool    match_exception_with_space(Handle exception) ;\n+  address test_address(address addr);\n+  bool    add_address_and_handler(address addr, address handler) ;\n+};\n+\n+\/\/ cache pc descs found in earlier inquiries\n+class PcDescCache {\n+  friend class VMStructs;\n+ private:\n+  enum { cache_size = 4 };\n+  \/\/ The array elements MUST be volatile! Several threads may modify\n+  \/\/ and read from the cache concurrently. find_pc_desc_internal has\n+  \/\/ returned wrong results. C++ compiler (namely xlC12) may duplicate\n+  \/\/ C++ field accesses if the elements are not volatile.\n+  typedef PcDesc* PcDescPtr;\n+  volatile PcDescPtr _pc_descs[cache_size]; \/\/ last cache_size pc_descs found\n+ public:\n+  PcDescCache() { debug_only(_pc_descs[0] = nullptr); }\n+  void    reset_to(PcDesc* initial_pc_desc);\n+  PcDesc* find_pc_desc(int pc_offset, bool approximate);\n+  void    add_pc_desc(PcDesc* pc_desc);\n+  PcDesc* last_pc_desc() { return _pc_descs[0]; }\n+};\n+\n+class PcDescSearch {\n+private:\n+  address _code_begin;\n+  PcDesc* _lower;\n+  PcDesc* _upper;\n+public:\n+  PcDescSearch(address code, PcDesc* lower, PcDesc* upper) :\n+    _code_begin(code), _lower(lower), _upper(upper)\n+  {\n+  }\n+\n+  address code_begin() const { return _code_begin; }\n+  PcDesc* scopes_pcs_begin() const { return _lower; }\n+  PcDesc* scopes_pcs_end() const { return _upper; }\n+};\n+\n+class PcDescContainer {\n+private:\n+  PcDescCache _pc_desc_cache;\n+public:\n+  PcDescContainer() {}\n+\n+  PcDesc* find_pc_desc_internal(address pc, bool approximate, const PcDescSearch& search);\n+  void    reset_to(PcDesc* initial_pc_desc) { _pc_desc_cache.reset_to(initial_pc_desc); }\n+\n+  PcDesc* find_pc_desc(address pc, bool approximate, const PcDescSearch& search) {\n+    address base_address = search.code_begin();\n+    PcDesc* desc = _pc_desc_cache.last_pc_desc();\n+    if (desc != nullptr && desc->pc_offset() == pc - base_address) {\n+      return desc;\n+    }\n+    return find_pc_desc_internal(pc, approximate, search);\n+  }\n+};\n@@ -68,1 +175,1 @@\n-class nmethod : public CompiledMethod {\n+class nmethod : public CodeBlob {\n@@ -73,0 +180,1 @@\n+  friend class DeoptimizationScope;\n@@ -76,0 +184,3 @@\n+  \/\/ Used to track in which deoptimize handshake this method will be deoptimized.\n+  uint64_t  _deoptimization_generation;\n+\n@@ -78,0 +189,2 @@\n+  Method*   _method;\n+\n@@ -81,66 +194,2 @@\n-  \/\/ STW two-phase nmethod root processing helpers.\n-  \/\/\n-  \/\/ When determining liveness of a given nmethod to do code cache unloading,\n-  \/\/ some collectors need to do different things depending on whether the nmethods\n-  \/\/ need to absolutely be kept alive during root processing; \"strong\"ly reachable\n-  \/\/ nmethods are known to be kept alive at root processing, but the liveness of\n-  \/\/ \"weak\"ly reachable ones is to be determined later.\n-  \/\/\n-  \/\/ We want to allow strong and weak processing of nmethods by different threads\n-  \/\/ at the same time without heavy synchronization. Additional constraints are\n-  \/\/ to make sure that every nmethod is processed a minimal amount of time, and\n-  \/\/ nmethods themselves are always iterated at most once at a particular time.\n-  \/\/\n-  \/\/ Note that strong processing work must be a superset of weak processing work\n-  \/\/ for this code to work.\n-  \/\/\n-  \/\/ We store state and claim information in the _oops_do_mark_link member, using\n-  \/\/ the two LSBs for the state and the remaining upper bits for linking together\n-  \/\/ nmethods that were already visited.\n-  \/\/ The last element is self-looped, i.e. points to itself to avoid some special\n-  \/\/ \"end-of-list\" sentinel value.\n-  \/\/\n-  \/\/ _oops_do_mark_link special values:\n-  \/\/\n-  \/\/   _oops_do_mark_link == nullptr: the nmethod has not been visited at all yet, i.e.\n-  \/\/      is Unclaimed.\n-  \/\/\n-  \/\/ For other values, its lowest two bits indicate the following states of the nmethod:\n-  \/\/\n-  \/\/   weak_request (WR): the nmethod has been claimed by a thread for weak processing\n-  \/\/   weak_done (WD): weak processing has been completed for this nmethod.\n-  \/\/   strong_request (SR): the nmethod has been found to need strong processing while\n-  \/\/       being weak processed.\n-  \/\/   strong_done (SD): strong processing has been completed for this nmethod .\n-  \/\/\n-  \/\/ The following shows the _only_ possible progressions of the _oops_do_mark_link\n-  \/\/ pointer.\n-  \/\/\n-  \/\/ Given\n-  \/\/   N as the nmethod\n-  \/\/   X the current next value of _oops_do_mark_link\n-  \/\/\n-  \/\/ Unclaimed (C)-> N|WR (C)-> X|WD: the nmethod has been processed weakly by\n-  \/\/   a single thread.\n-  \/\/ Unclaimed (C)-> N|WR (C)-> X|WD (O)-> X|SD: after weak processing has been\n-  \/\/   completed (as above) another thread found that the nmethod needs strong\n-  \/\/   processing after all.\n-  \/\/ Unclaimed (C)-> N|WR (O)-> N|SR (C)-> X|SD: during weak processing another\n-  \/\/   thread finds that the nmethod needs strong processing, marks it as such and\n-  \/\/   terminates. The original thread completes strong processing.\n-  \/\/ Unclaimed (C)-> N|SD (C)-> X|SD: the nmethod has been processed strongly from\n-  \/\/   the beginning by a single thread.\n-  \/\/\n-  \/\/ \"|\" describes the concatenation of bits in _oops_do_mark_link.\n-  \/\/\n-  \/\/ The diagram also describes the threads responsible for changing the nmethod to\n-  \/\/ the next state by marking the _transition_ with (C) and (O), which mean \"current\"\n-  \/\/ and \"other\" thread respectively.\n-  \/\/\n-  struct oops_do_mark_link; \/\/ Opaque data type.\n-\n-  \/\/ States used for claiming nmethods during root processing.\n-  static const uint claim_weak_request_tag = 0;\n-  static const uint claim_weak_done_tag = 1;\n-  static const uint claim_strong_request_tag = 2;\n-  static const uint claim_strong_done_tag = 3;\n+  PcDescContainer _pc_desc_container;\n+  ExceptionCache* volatile _exception_cache;\n@@ -148,19 +197,1 @@\n-  static oops_do_mark_link* mark_link(nmethod* nm, uint tag) {\n-    assert(tag <= claim_strong_done_tag, \"invalid tag %u\", tag);\n-    assert(is_aligned(nm, 4), \"nmethod pointer must have zero lower two LSB\");\n-    return (oops_do_mark_link*)(((uintptr_t)nm & ~0x3) | tag);\n-  }\n-\n-  static uint extract_state(oops_do_mark_link* link) {\n-    return (uint)((uintptr_t)link & 0x3);\n-  }\n-\n-  static nmethod* extract_nmethod(oops_do_mark_link* link) {\n-    return (nmethod*)((uintptr_t)link & ~0x3);\n-  }\n-\n-  void oops_do_log_change(const char* state);\n-\n-  static bool oops_do_has_weak_request(oops_do_mark_link* next) {\n-    return extract_state(next) == claim_weak_request_tag;\n-  }\n+  void* _gc_data;\n@@ -168,25 +199,2 @@\n-  static bool oops_do_has_any_strong_state(oops_do_mark_link* next) {\n-    return extract_state(next) >= claim_strong_request_tag;\n-  }\n-\n-  \/\/ Attempt Unclaimed -> N|WR transition. Returns true if successful.\n-  bool oops_do_try_claim_weak_request();\n-\n-  \/\/ Attempt Unclaimed -> N|SD transition. Returns the current link.\n-  oops_do_mark_link* oops_do_try_claim_strong_done();\n-  \/\/ Attempt N|WR -> X|WD transition. Returns nullptr if successful, X otherwise.\n-  nmethod* oops_do_try_add_to_list_as_weak_done();\n-\n-  \/\/ Attempt X|WD -> N|SR transition. Returns the current link.\n-  oops_do_mark_link* oops_do_try_add_strong_request(oops_do_mark_link* next);\n-  \/\/ Attempt X|WD -> X|SD transition. Returns true if successful.\n-  bool oops_do_try_claim_weak_done_as_strong_done(oops_do_mark_link* next);\n-\n-  \/\/ Do the N|SD -> X|SD transition.\n-  void oops_do_add_to_list_as_strong_done();\n-\n-  \/\/ Sets this nmethod as strongly claimed (as part of N|SD -> X|SD and N|SR -> X|SD\n-  \/\/ transitions).\n-  void oops_do_set_strong_done(nmethod* old_head);\n-\n-  static nmethod* volatile _oops_do_mark_nmethods;\n+  struct oops_do_mark_link; \/\/ Opaque data type.\n+  static nmethod*    volatile _oops_do_mark_nmethods;\n@@ -201,1 +209,0 @@\n-  bool _is_unlinked;\n@@ -208,0 +215,6 @@\n+  \/\/ All deoptee's will resume execution at this location described by\n+  \/\/ this offset.\n+  int _deopt_handler_offset;\n+  \/\/ All deoptee's at a MethodHandle call site will resume execution\n+  \/\/ at this location described by this offset.\n+  int _deopt_mh_handler_offset;\n@@ -225,2 +238,1 @@\n-\n-  int code_offset() const { return int(code_begin() - header_begin()); }\n+  int _skipped_instructions_size;\n@@ -232,1 +244,5 @@\n-  int _compile_id;                           \/\/ which compilation made this nmethod\n+  int _compile_id;                        \/\/ which compilation made this nmethod\n+\n+  CompilerType _compiler_type;            \/\/ which compiler made this nmethod (u1)\n+\n+  bool _is_unlinked;\n@@ -251,1 +267,1 @@\n-  CompLevel _comp_level;               \/\/ compilation level\n+  CompLevel _comp_level;               \/\/ compilation level (s1)\n@@ -256,3 +272,0 @@\n-  \/\/ protected by CodeCache_lock\n-  bool _has_flushed_dependencies;      \/\/ Used for maintenance of dependencies (CodeCache_lock)\n-\n@@ -262,2 +275,16 @@\n-  \/\/ Protected by CompiledMethod_lock\n-  volatile signed char _state;         \/\/ {not_installed, in_use, not_used, not_entrant}\n+  \/\/ Protected by NMethodState_lock\n+  volatile signed char _state;         \/\/ {not_installed, in_use, not_entrant}\n+\n+  \/\/ set during construction\n+  uint8_t _has_unsafe_access:1,        \/\/ May fault due to unsafe access.\n+          _has_method_handle_invokes:1,\/\/ Has this method MethodHandle invokes?\n+          _has_wide_vectors:1,         \/\/ Preserve wide vectors at safepoints\n+          _has_monitors:1,             \/\/ Fastpath monitor detection for continuations\n+          _has_flushed_dependencies:1; \/\/ Used for maintenance of dependencies (under CodeCache_lock)\n+\n+  enum DeoptimizationStatus : u1 {\n+    not_marked,\n+    deoptimize,\n+    deoptimize_noupdate,\n+    deoptimize_done\n+  };\n@@ -265,1 +292,5 @@\n-  int _skipped_instructions_size;\n+  volatile DeoptimizationStatus _deoptimization_status; \/\/ Used for stack deoptimization\n+\n+  DeoptimizationStatus deoptimization_status() const {\n+    return Atomic::load(&_deoptimization_status);\n+  }\n@@ -305,0 +336,1 @@\n+\n@@ -325,3 +357,85 @@\n-  \/\/ Offsets\n-  int content_offset() const                  { return int(content_begin() - header_begin()); }\n-  int data_offset() const                     { return _data_offset; }\n+  PcDesc* find_pc_desc(address pc, bool approximate) {\n+    return _pc_desc_container.find_pc_desc(pc, approximate, PcDescSearch(code_begin(), scopes_pcs_begin(), scopes_pcs_end()));\n+  }\n+\n+  \/\/ STW two-phase nmethod root processing helpers.\n+  \/\/\n+  \/\/ When determining liveness of a given nmethod to do code cache unloading,\n+  \/\/ some collectors need to do different things depending on whether the nmethods\n+  \/\/ need to absolutely be kept alive during root processing; \"strong\"ly reachable\n+  \/\/ nmethods are known to be kept alive at root processing, but the liveness of\n+  \/\/ \"weak\"ly reachable ones is to be determined later.\n+  \/\/\n+  \/\/ We want to allow strong and weak processing of nmethods by different threads\n+  \/\/ at the same time without heavy synchronization. Additional constraints are\n+  \/\/ to make sure that every nmethod is processed a minimal amount of time, and\n+  \/\/ nmethods themselves are always iterated at most once at a particular time.\n+  \/\/\n+  \/\/ Note that strong processing work must be a superset of weak processing work\n+  \/\/ for this code to work.\n+  \/\/\n+  \/\/ We store state and claim information in the _oops_do_mark_link member, using\n+  \/\/ the two LSBs for the state and the remaining upper bits for linking together\n+  \/\/ nmethods that were already visited.\n+  \/\/ The last element is self-looped, i.e. points to itself to avoid some special\n+  \/\/ \"end-of-list\" sentinel value.\n+  \/\/\n+  \/\/ _oops_do_mark_link special values:\n+  \/\/\n+  \/\/   _oops_do_mark_link == nullptr: the nmethod has not been visited at all yet, i.e.\n+  \/\/      is Unclaimed.\n+  \/\/\n+  \/\/ For other values, its lowest two bits indicate the following states of the nmethod:\n+  \/\/\n+  \/\/   weak_request (WR): the nmethod has been claimed by a thread for weak processing\n+  \/\/   weak_done (WD): weak processing has been completed for this nmethod.\n+  \/\/   strong_request (SR): the nmethod has been found to need strong processing while\n+  \/\/       being weak processed.\n+  \/\/   strong_done (SD): strong processing has been completed for this nmethod .\n+  \/\/\n+  \/\/ The following shows the _only_ possible progressions of the _oops_do_mark_link\n+  \/\/ pointer.\n+  \/\/\n+  \/\/ Given\n+  \/\/   N as the nmethod\n+  \/\/   X the current next value of _oops_do_mark_link\n+  \/\/\n+  \/\/ Unclaimed (C)-> N|WR (C)-> X|WD: the nmethod has been processed weakly by\n+  \/\/   a single thread.\n+  \/\/ Unclaimed (C)-> N|WR (C)-> X|WD (O)-> X|SD: after weak processing has been\n+  \/\/   completed (as above) another thread found that the nmethod needs strong\n+  \/\/   processing after all.\n+  \/\/ Unclaimed (C)-> N|WR (O)-> N|SR (C)-> X|SD: during weak processing another\n+  \/\/   thread finds that the nmethod needs strong processing, marks it as such and\n+  \/\/   terminates. The original thread completes strong processing.\n+  \/\/ Unclaimed (C)-> N|SD (C)-> X|SD: the nmethod has been processed strongly from\n+  \/\/   the beginning by a single thread.\n+  \/\/\n+  \/\/ \"|\" describes the concatenation of bits in _oops_do_mark_link.\n+  \/\/\n+  \/\/ The diagram also describes the threads responsible for changing the nmethod to\n+  \/\/ the next state by marking the _transition_ with (C) and (O), which mean \"current\"\n+  \/\/ and \"other\" thread respectively.\n+  \/\/\n+\n+  \/\/ States used for claiming nmethods during root processing.\n+  static const uint claim_weak_request_tag = 0;\n+  static const uint claim_weak_done_tag = 1;\n+  static const uint claim_strong_request_tag = 2;\n+  static const uint claim_strong_done_tag = 3;\n+\n+  static oops_do_mark_link* mark_link(nmethod* nm, uint tag) {\n+    assert(tag <= claim_strong_done_tag, \"invalid tag %u\", tag);\n+    assert(is_aligned(nm, 4), \"nmethod pointer must have zero lower two LSB\");\n+    return (oops_do_mark_link*)(((uintptr_t)nm & ~0x3) | tag);\n+  }\n+\n+  static uint extract_state(oops_do_mark_link* link) {\n+    return (uint)((uintptr_t)link & 0x3);\n+  }\n+\n+  static nmethod* extract_nmethod(oops_do_mark_link* link) {\n+    return (nmethod*)((uintptr_t)link & ~0x3);\n+  }\n+\n+  void oops_do_log_change(const char* state);\n@@ -329,1 +443,3 @@\n-  address header_end() const                  { return (address)    header_begin() + header_size(); }\n+  static bool oops_do_has_weak_request(oops_do_mark_link* next) {\n+    return extract_state(next) == claim_weak_request_tag;\n+  }\n@@ -331,1 +447,25 @@\n- public:\n+  static bool oops_do_has_any_strong_state(oops_do_mark_link* next) {\n+    return extract_state(next) >= claim_strong_request_tag;\n+  }\n+\n+  \/\/ Attempt Unclaimed -> N|WR transition. Returns true if successful.\n+  bool oops_do_try_claim_weak_request();\n+\n+  \/\/ Attempt Unclaimed -> N|SD transition. Returns the current link.\n+  oops_do_mark_link* oops_do_try_claim_strong_done();\n+  \/\/ Attempt N|WR -> X|WD transition. Returns nullptr if successful, X otherwise.\n+  nmethod* oops_do_try_add_to_list_as_weak_done();\n+\n+  \/\/ Attempt X|WD -> N|SR transition. Returns the current link.\n+  oops_do_mark_link* oops_do_try_add_strong_request(oops_do_mark_link* next);\n+  \/\/ Attempt X|WD -> X|SD transition. Returns true if successful.\n+  bool oops_do_try_claim_weak_done_as_strong_done(oops_do_mark_link* next);\n+\n+  \/\/ Do the N|SD -> X|SD transition.\n+  void oops_do_add_to_list_as_strong_done();\n+\n+  \/\/ Sets this nmethod as strongly claimed (as part of N|SD -> X|SD and N|SR -> X|SD\n+  \/\/ transitions).\n+  void oops_do_set_strong_done(nmethod* old_head);\n+\n+public:\n@@ -354,8 +494,0 @@\n-  \/\/ Only used for unit tests.\n-  nmethod()\n-    : CompiledMethod(),\n-      _native_receiver_sp_offset(in_ByteSize(-1)),\n-      _native_basic_lock_sp_offset(in_ByteSize(-1)),\n-      _is_unloading_state(0) {}\n-\n-\n@@ -373,3 +505,17 @@\n-  \/\/ type info\n-  bool is_nmethod() const                         { return true; }\n-  bool is_osr_method() const                      { return _entry_bci != InvocationEntryBci; }\n+  Method* method       () const { return _method; }\n+  bool is_native_method() const { return _method != nullptr && _method->is_native(); }\n+  bool is_java_method  () const { return _method != nullptr && !_method->is_native(); }\n+  bool is_osr_method   () const { return _entry_bci != InvocationEntryBci; }\n+\n+  \/\/ Compiler task identification.  Note that all OSR methods\n+  \/\/ are numbered in an independent sequence if CICountOSR is true,\n+  \/\/ and native method wrappers are also numbered independently if\n+  \/\/ CICountNative is true.\n+  int compile_id() const { return _compile_id; }\n+  const char* compile_kind() const;\n+\n+  inline bool  is_compiled_by_c1   () const { return _compiler_type == compiler_c1; }\n+  inline bool  is_compiled_by_c2   () const { return _compiler_type == compiler_c2; }\n+  inline bool  is_compiled_by_jvmci() const { return _compiler_type == compiler_jvmci; }\n+  CompilerType compiler_type       () const { return _compiler_type; }\n+  const char*  compiler_name       () const;\n@@ -378,22 +524,25 @@\n-  address consts_begin          () const          { return           header_begin() + _consts_offset        ; }\n-  address consts_end            () const          { return           code_begin()                           ; }\n-  address stub_begin            () const          { return           header_begin() + _stub_offset          ; }\n-  address stub_end              () const          { return           header_begin() + _oops_offset          ; }\n-  address exception_begin       () const          { return           header_begin() + _exception_offset     ; }\n-  address unwind_handler_begin  () const          { return _unwind_handler_offset != -1 ? (header_begin() + _unwind_handler_offset) : nullptr; }\n-  oop*    oops_begin            () const          { return (oop*)   (header_begin() + _oops_offset)         ; }\n-  oop*    oops_end              () const          { return (oop*)   (header_begin() + _metadata_offset)     ; }\n-\n-  Metadata** metadata_begin   () const            { return (Metadata**)  (header_begin() + _metadata_offset)     ; }\n-  Metadata** metadata_end     () const            { return (Metadata**)  _scopes_data_begin; }\n-\n-  address scopes_data_end       () const          { return           header_begin() + _scopes_pcs_offset    ; }\n-  PcDesc* scopes_pcs_begin      () const          { return (PcDesc*)(header_begin() + _scopes_pcs_offset   ); }\n-  PcDesc* scopes_pcs_end        () const          { return (PcDesc*)(header_begin() + _dependencies_offset) ; }\n-  address dependencies_begin    () const          { return           header_begin() + _dependencies_offset  ; }\n-  address dependencies_end      () const          { return           header_begin() + _handler_table_offset ; }\n-  address handler_table_begin   () const          { return           header_begin() + _handler_table_offset ; }\n-  address handler_table_end     () const          { return           header_begin() + _nul_chk_table_offset ; }\n-  address nul_chk_table_begin   () const          { return           header_begin() + _nul_chk_table_offset ; }\n-\n-  int skipped_instructions_size () const          { return           _skipped_instructions_size             ; }\n+  address consts_begin          () const { return           header_begin() + _consts_offset           ; }\n+  address consts_end            () const { return           header_begin() +  code_offset()           ; }\n+  address insts_begin           () const { return           header_begin() +  code_offset()           ; }\n+  address insts_end             () const { return           header_begin() + _stub_offset             ; }\n+  address stub_begin            () const { return           header_begin() + _stub_offset             ; }\n+  address stub_end              () const { return           header_begin() + _oops_offset             ; }\n+  address exception_begin       () const { return           header_begin() + _exception_offset        ; }\n+  address deopt_handler_begin   () const { return           header_begin() + _deopt_handler_offset    ; }\n+  address deopt_mh_handler_begin() const { return           header_begin() + _deopt_mh_handler_offset ; }\n+  address unwind_handler_begin  () const { return _unwind_handler_offset != -1 ? (header_begin() + _unwind_handler_offset) : nullptr; }\n+  oop*    oops_begin            () const { return (oop*)   (header_begin() + _oops_offset)            ; }\n+  oop*    oops_end              () const { return (oop*)   (header_begin() + _metadata_offset)        ; }\n+\n+  Metadata** metadata_begin     () const { return (Metadata**) (header_begin() + _metadata_offset)    ; }\n+  Metadata** metadata_end       () const { return (Metadata**) (header_begin() + _scopes_data_offset) ; }\n+\n+  address scopes_data_begin     () const { return           header_begin() + _scopes_data_offset      ; }\n+  address scopes_data_end       () const { return           header_begin() + _scopes_pcs_offset       ; }\n+  PcDesc* scopes_pcs_begin      () const { return (PcDesc*)(header_begin() + _scopes_pcs_offset)      ; }\n+  PcDesc* scopes_pcs_end        () const { return (PcDesc*)(header_begin() + _dependencies_offset)    ; }\n+  address dependencies_begin    () const { return           header_begin() + _dependencies_offset     ; }\n+  address dependencies_end      () const { return           header_begin() + _handler_table_offset    ; }\n+  address handler_table_begin   () const { return           header_begin() + _handler_table_offset    ; }\n+  address handler_table_end     () const { return           header_begin() + _nul_chk_table_offset    ; }\n+  address nul_chk_table_begin   () const { return           header_begin() + _nul_chk_table_offset    ; }\n@@ -402,5 +551,5 @@\n-  address nul_chk_table_end     () const          { return           header_begin() + _speculations_offset  ; }\n-  address speculations_begin    () const          { return           header_begin() + _speculations_offset  ; }\n-  address speculations_end      () const          { return           header_begin() + _jvmci_data_offset   ; }\n-  address jvmci_data_begin      () const          { return           header_begin() + _jvmci_data_offset    ; }\n-  address jvmci_data_end        () const          { return           header_begin() + _nmethod_end_offset   ; }\n+  address nul_chk_table_end     () const { return           header_begin() + _speculations_offset     ; }\n+  address speculations_begin    () const { return           header_begin() + _speculations_offset     ; }\n+  address speculations_end      () const { return           header_begin() + _jvmci_data_offset       ; }\n+  address jvmci_data_begin      () const { return           header_begin() + _jvmci_data_offset       ; }\n+  address jvmci_data_end        () const { return           header_begin() + _nmethod_end_offset      ; }\n@@ -408,1 +557,1 @@\n-  address nul_chk_table_end     () const          { return           header_begin() + _nmethod_end_offset   ; }\n+  address nul_chk_table_end     () const { return           header_begin() + _nmethod_end_offset      ; }\n@@ -412,3 +561,10 @@\n-  int oops_size         () const                  { return int((address)  oops_end         () - (address)  oops_begin         ()); }\n-  int metadata_size     () const                  { return int((address)  metadata_end     () - (address)  metadata_begin     ()); }\n-  int dependencies_size () const                  { return int(           dependencies_end () -            dependencies_begin ()); }\n+  int consts_size       () const { return int(          consts_end       () -           consts_begin       ()); }\n+  int insts_size        () const { return int(          insts_end        () -           insts_begin        ()); }\n+  int stub_size         () const { return int(          stub_end         () -           stub_begin         ()); }\n+  int oops_size         () const { return int((address) oops_end         () - (address) oops_begin         ()); }\n+  int metadata_size     () const { return int((address) metadata_end     () - (address) metadata_begin     ()); }\n+  int scopes_data_size  () const { return int(          scopes_data_end  () -           scopes_data_begin  ()); }\n+  int scopes_pcs_size   () const { return int((intptr_t)scopes_pcs_end   () - (intptr_t)scopes_pcs_begin   ()); }\n+  int dependencies_size () const { return int(          dependencies_end () -           dependencies_begin ()); }\n+  int handler_table_size() const { return int(          handler_table_end() -           handler_table_begin()); }\n+  int nul_chk_table_size() const { return int(          nul_chk_table_end() -           nul_chk_table_begin()); }\n@@ -416,2 +572,2 @@\n-  int speculations_size () const                  { return int(           speculations_end () -            speculations_begin ()); }\n-  int jvmci_data_size   () const                  { return int(           jvmci_data_end   () -            jvmci_data_begin   ()); }\n+  int speculations_size () const { return int(          speculations_end () -           speculations_begin ()); }\n+  int jvmci_data_size   () const { return int(          jvmci_data_end   () -           jvmci_data_begin   ()); }\n@@ -423,1 +579,2 @@\n-  int total_size        () const;\n+  int skipped_instructions_size () const { return _skipped_instructions_size; }\n+  int total_size() const;\n@@ -426,4 +583,12 @@\n-  bool oops_contains         (oop*    addr) const { return oops_begin         () <= addr && addr < oops_end         (); }\n-  bool metadata_contains     (Metadata** addr) const   { return metadata_begin     () <= addr && addr < metadata_end     (); }\n-  bool scopes_data_contains  (address addr) const { return scopes_data_begin  () <= addr && addr < scopes_data_end  (); }\n-  bool scopes_pcs_contains   (PcDesc* addr) const { return scopes_pcs_begin   () <= addr && addr < scopes_pcs_end   (); }\n+  bool consts_contains         (address addr) const { return consts_begin       () <= addr && addr < consts_end       (); }\n+  \/\/ Returns true if a given address is in the 'insts' section. The method\n+  \/\/ insts_contains_inclusive() is end-inclusive.\n+  bool insts_contains          (address addr) const { return insts_begin        () <= addr && addr < insts_end        (); }\n+  bool insts_contains_inclusive(address addr) const { return insts_begin        () <= addr && addr <= insts_end       (); }\n+  bool stub_contains           (address addr) const { return stub_begin         () <= addr && addr < stub_end         (); }\n+  bool oops_contains           (oop*    addr) const { return oops_begin         () <= addr && addr < oops_end         (); }\n+  bool metadata_contains       (Metadata** addr) const { return metadata_begin  () <= addr && addr < metadata_end     (); }\n+  bool scopes_data_contains    (address addr) const { return scopes_data_begin  () <= addr && addr < scopes_data_end  (); }\n+  bool scopes_pcs_contains     (PcDesc* addr) const { return scopes_pcs_begin   () <= addr && addr < scopes_pcs_end   (); }\n+  bool handler_table_contains  (address addr) const { return handler_table_begin() <= addr && addr < handler_table_end(); }\n+  bool nul_chk_table_contains  (address addr) const { return nul_chk_table_begin() <= addr && addr < nul_chk_table_end(); }\n@@ -432,2 +597,8 @@\n-  address entry_point() const                     { return _entry_point;             } \/\/ normal entry point\n-  address verified_entry_point() const            { return _verified_entry_point;    } \/\/ if klass is correct\n+  address entry_point() const          { return _entry_point;          } \/\/ normal entry point\n+  address verified_entry_point() const { return _verified_entry_point; } \/\/ if klass is correct\n+\n+  enum : signed char { not_installed = -1, \/\/ in construction, only the owner doing the construction is\n+                                           \/\/ allowed to advance state\n+                       in_use        = 0,  \/\/ executable nmethod\n+                       not_entrant   = 1   \/\/ marked for deoptimization but activations may still exist\n+  };\n@@ -436,3 +607,4 @@\n-  bool  is_not_installed() const                  { return _state == not_installed; }\n-  bool  is_in_use() const                         { return _state <= in_use; }\n-  bool  is_not_entrant() const                    { return _state == not_entrant; }\n+  bool is_not_installed() const        { return _state == not_installed; }\n+  bool is_in_use() const               { return _state <= in_use; }\n+  bool is_not_entrant() const          { return _state == not_entrant; }\n+  int  get_state() const               { return _state; }\n@@ -443,2 +615,2 @@\n-  virtual bool is_unloading();\n-  virtual void do_unloading(bool unloading_occurred);\n+  bool is_unloading();\n+  void do_unloading(bool unloading_occurred);\n@@ -446,2 +618,2 @@\n-  bool is_unlinked() const                        { return _is_unlinked; }\n-  void set_is_unlinked()                          { assert(!_is_unlinked, \"already unlinked\"); _is_unlinked = true; }\n+  bool is_unlinked() const             { return _is_unlinked; }\n+  void set_is_unlinked()               { assert(!_is_unlinked, \"already unlinked\"); _is_unlinked = true; }\n@@ -451,2 +623,2 @@\n-  RTMState  rtm_state() const                     { return _rtm_state; }\n-  void set_rtm_state(RTMState state)              { _rtm_state = state; }\n+  RTMState  rtm_state() const          { return _rtm_state; }\n+  void set_rtm_state(RTMState state)   { _rtm_state = state; }\n@@ -465,2 +637,10 @@\n-  int get_state() const {\n-    return _state;\n+  bool  is_marked_for_deoptimization() const { return deoptimization_status() != not_marked; }\n+  bool  has_been_deoptimized() const { return deoptimization_status() == deoptimize_done; }\n+  void  set_deoptimized_done();\n+\n+  bool update_recompile_counts() const {\n+    \/\/ Update recompile counts when either the update is explicitly requested (deoptimize)\n+    \/\/ or the nmethod is not marked for deoptimization at all (not_marked).\n+    \/\/ The latter happens during uncommon traps when deoptimized nmethod is made not entrant.\n+    DeoptimizationStatus status = deoptimization_status();\n+    return status != deoptimize_noupdate && status != deoptimize_done;\n@@ -469,0 +649,4 @@\n+  \/\/ tells whether frames described by this nmethod can be deoptimized\n+  \/\/ note: native wrappers cannot be deoptimized.\n+  bool can_be_deoptimized() const { return is_java_method(); }\n+\n@@ -472,2 +656,20 @@\n-  bool has_flushed_dependencies()                 { return _has_flushed_dependencies; }\n-  void set_has_flushed_dependencies()             {\n+\n+  template<typename T>\n+  T* gc_data() const                              { return reinterpret_cast<T*>(_gc_data); }\n+  template<typename T>\n+  void set_gc_data(T* gc_data)                    { _gc_data = reinterpret_cast<void*>(gc_data); }\n+\n+  bool  has_unsafe_access() const                 { return _has_unsafe_access; }\n+  void  set_has_unsafe_access(bool z)             { _has_unsafe_access = z; }\n+\n+  bool  has_monitors() const                      { return _has_monitors; }\n+  void  set_has_monitors(bool z)                  { _has_monitors = z; }\n+\n+  bool  has_method_handle_invokes() const         { return _has_method_handle_invokes; }\n+  void  set_has_method_handle_invokes(bool z)     { _has_method_handle_invokes = z; }\n+\n+  bool  has_wide_vectors() const                  { return _has_wide_vectors; }\n+  void  set_has_wide_vectors(bool z)              { _has_wide_vectors = z; }\n+\n+  bool  has_flushed_dependencies() const          { return _has_flushed_dependencies; }\n+  void  set_has_flushed_dependencies(bool z)      {\n@@ -475,1 +677,1 @@\n-    _has_flushed_dependencies = 1;\n+    _has_flushed_dependencies = z;\n@@ -480,2 +682,0 @@\n-  void unlink_from_method();\n-\n@@ -494,1 +694,1 @@\n-  Metadata*     metadata_at(int index) const      { return index == 0 ? nullptr: *metadata_addr_at(index); }\n+  Metadata*   metadata_at(int index) const      { return index == 0 ? nullptr: *metadata_addr_at(index); }\n@@ -509,0 +709,3 @@\n+protected:\n+  address oops_reloc_begin() const;\n+\n@@ -513,0 +716,72 @@\n+  bool is_at_poll_return(address pc);\n+  bool is_at_poll_or_poll_return(address pc);\n+\n+protected:\n+  \/\/ Exception cache support\n+  \/\/ Note: _exception_cache may be read and cleaned concurrently.\n+  ExceptionCache* exception_cache() const         { return _exception_cache; }\n+  ExceptionCache* exception_cache_acquire() const;\n+  void set_exception_cache(ExceptionCache *ec)    { _exception_cache = ec; }\n+\n+public:\n+  address handler_for_exception_and_pc(Handle exception, address pc);\n+  void add_handler_for_exception_and_pc(Handle exception, address pc, address handler);\n+  void clean_exception_cache();\n+\n+  void add_exception_cache_entry(ExceptionCache* new_entry);\n+  ExceptionCache* exception_cache_entry_for_exception(Handle exception);\n+\n+\n+  \/\/ MethodHandle\n+  bool is_method_handle_return(address return_pc);\n+  \/\/ Deopt\n+  \/\/ Return true is the PC is one would expect if the frame is being deopted.\n+  inline bool is_deopt_pc(address pc);\n+  inline bool is_deopt_mh_entry(address pc);\n+  inline bool is_deopt_entry(address pc);\n+\n+  \/\/ Accessor\/mutator for the original pc of a frame before a frame was deopted.\n+  address get_original_pc(const frame* fr) { return *orig_pc_addr(fr); }\n+  void    set_original_pc(const frame* fr, address pc) { *orig_pc_addr(fr) = pc; }\n+\n+  const char* state() const;\n+\n+  bool inlinecache_check_contains(address addr) const {\n+    return (addr >= code_begin() && addr < verified_entry_point());\n+  }\n+\n+  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) override;\n+\n+  \/\/ implicit exceptions support\n+  address continuation_for_implicit_div0_exception(address pc) { return continuation_for_implicit_exception(pc, true); }\n+  address continuation_for_implicit_null_exception(address pc) { return continuation_for_implicit_exception(pc, false); }\n+\n+  \/\/ Inline cache support for class unloading and nmethod unloading\n+ private:\n+  void cleanup_inline_caches_impl(bool unloading_occurred, bool clean_all);\n+\n+  address continuation_for_implicit_exception(address pc, bool for_div0_check);\n+\n+ public:\n+  \/\/ Serial version used by whitebox test\n+  void cleanup_inline_caches_whitebox();\n+\n+  void clear_inline_caches();\n+\n+  \/\/ Execute nmethod barrier code, as if entering through nmethod call.\n+  void run_nmethod_entry_barrier();\n+\n+  void verify_oop_relocations();\n+\n+  bool has_evol_metadata();\n+\n+  Method* attached_method(address call_pc);\n+  Method* attached_method_before_pc(address pc);\n+\n+  \/\/ GC unloading support\n+  \/\/ Cleans unloaded klasses and unloaded nmethods in inline caches\n+\n+  void unload_nmethod_caches(bool class_unloading_occurred);\n+\n+  void unlink_from_method();\n+\n@@ -527,1 +802,1 @@\n-  void purge(bool free_code_cache_data, bool unregister_nmethod);\n+  void purge(bool free_code_cache_data, bool unregister_nmethod) override;\n@@ -552,1 +827,0 @@\n- public:\n@@ -594,0 +868,9 @@\n+  \/\/ ScopeDesc retrieval operation\n+  PcDesc* pc_desc_at(address pc)   { return find_pc_desc(pc, false); }\n+  \/\/ pc_desc_near returns the first PcDesc at or after the given pc.\n+  PcDesc* pc_desc_near(address pc) { return find_pc_desc(pc, true); }\n+\n+  \/\/ ScopeDesc for an instruction\n+  ScopeDesc* scope_desc_at(address pc);\n+  ScopeDesc* scope_desc_near(address pc);\n+\n@@ -607,1 +890,1 @@\n-  void verify();\n+  void verify() override;\n@@ -619,2 +902,2 @@\n-  void print()                          const;\n-  void print(outputStream* st)          const;\n+  void print()                 const override;\n+  void print(outputStream* st) const;\n@@ -629,1 +912,1 @@\n-  void print_value_on(outputStream* st) const;\n+  void print_value_on(outputStream* st) const override;\n@@ -649,1 +932,1 @@\n-  virtual void print_on(outputStream* st) const { CodeBlob::print_on(st); }\n+  void print_on(outputStream* st) const override { CodeBlob::print_on(st); }\n@@ -658,1 +941,1 @@\n-  virtual void print_block_comment(outputStream* stream, address block_begin) const {\n+  void print_block_comment(outputStream* stream, address block_begin) const override {\n@@ -673,7 +956,0 @@\n-  \/\/ Compiler task identification.  Note that all OSR methods\n-  \/\/ are numbered in an independent sequence if CICountOSR is true,\n-  \/\/ and native method wrappers are also numbered independently if\n-  \/\/ CICountNative is true.\n-  virtual int compile_id() const { return _compile_id; }\n-  const char* compile_kind() const;\n-\n@@ -687,1 +963,1 @@\n-  virtual bool is_dependent_on_method(Method* dependee);\n+  bool is_dependent_on_method(Method* dependee);\n@@ -702,1 +978,1 @@\n-  virtual void metadata_do(MetadataClosure* f);\n+  void metadata_do(MetadataClosure* f);\n@@ -706,1 +982,1 @@\n-  virtual void  make_deoptimized();\n+  void make_deoptimized();\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":491,"deletions":215,"binary":false,"changes":706,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CODE_NMETHOD_INLINE_HPP\n+#define SHARE_CODE_NMETHOD_INLINE_HPP\n+\n+#include \"code\/nmethod.hpp\"\n+\n+#include \"code\/nativeInst.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+inline bool nmethod::is_deopt_pc(address pc) { return is_deopt_entry(pc) || is_deopt_mh_entry(pc); }\n+\n+\/\/ When using JVMCI the address might be off by the size of a call instruction.\n+inline bool nmethod::is_deopt_entry(address pc) {\n+  return pc == deopt_handler_begin()\n+#if INCLUDE_JVMCI\n+    || (is_compiled_by_jvmci() && pc == (deopt_handler_begin() + NativeCall::instruction_size))\n+#endif\n+    ;\n+}\n+\n+inline bool nmethod::is_deopt_mh_entry(address pc) {\n+  return pc == deopt_mh_handler_begin()\n+#if INCLUDE_JVMCI\n+    || (is_compiled_by_jvmci() && pc == (deopt_mh_handler_begin() + NativeCall::instruction_size))\n+#endif\n+    ;\n+}\n+\n+\/\/ class ExceptionCache methods\n+\n+inline int ExceptionCache::count() { return Atomic::load_acquire(&_count); }\n+\n+address ExceptionCache::pc_at(int index) {\n+  assert(index >= 0 && index < count(),\"\");\n+  return _pc[index];\n+}\n+\n+address ExceptionCache::handler_at(int index) {\n+  assert(index >= 0 && index < count(),\"\");\n+  return _handler[index];\n+}\n+\n+\/\/ increment_count is only called under lock, but there may be concurrent readers.\n+inline void ExceptionCache::increment_count() { Atomic::release_store(&_count, _count + 1); }\n+\n+\n+#endif \/\/ SHARE_CODE_NMETHOD_INLINE_HPP\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-address PcDesc::real_pc(const CompiledMethod* code) const {\n+address PcDesc::real_pc(const nmethod* code) const {\n@@ -43,1 +43,1 @@\n-void PcDesc::print_on(outputStream* st, CompiledMethod* code) {\n+void PcDesc::print_on(outputStream* st, nmethod* code) {\n@@ -60,1 +60,1 @@\n-bool PcDesc::verify(CompiledMethod* code) {\n+bool PcDesc::verify(nmethod* code) {\n","filename":"src\/hotspot\/share\/code\/pcDesc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-class CompiledMethod;\n+class nmethod;\n@@ -105,1 +105,1 @@\n-  address real_pc(const CompiledMethod* code) const;\n+  address real_pc(const nmethod* code) const;\n@@ -107,3 +107,3 @@\n-  void print(CompiledMethod* code) { print_on(tty, code); }\n-  void print_on(outputStream* st, CompiledMethod* code);\n-  bool verify(CompiledMethod* code);\n+  void print(nmethod* code) { print_on(tty, code); }\n+  void print_on(outputStream* st, nmethod* code);\n+  bool verify(nmethod* code);\n","filename":"src\/hotspot\/share\/code\/pcDesc.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-void RelocIterator::initialize(CompiledMethod* nm, address begin, address limit) {\n+void RelocIterator::initialize(nmethod* nm, address begin, address limit) {\n@@ -126,1 +126,1 @@\n-    nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+    nm = (cb != nullptr) ? cb->as_nmethod_or_null() : nullptr;\n@@ -636,3 +636,3 @@\n-  CompiledMethod* cm = code();\n-  if (cm == nullptr) return (Method*)nullptr;\n-  Metadata* m = cm->metadata_at(_method_index);\n+  nmethod* nm = code();\n+  if (nm == nullptr) return (Method*)nullptr;\n+  Metadata* m = nm->metadata_at(_method_index);\n@@ -662,3 +662,3 @@\n-  CompiledMethod* cm = code();\n-  if (cm == nullptr) return (Method*)nullptr;\n-  Metadata* m = cm->metadata_at(_method_index);\n+  nmethod* nm = code();\n+  if (nm == nullptr) return (Method*)nullptr;\n+  Metadata* m = nm->metadata_at(_method_index);\n@@ -692,3 +692,3 @@\n-  CompiledMethod* cm = code();\n-  if (cm == nullptr) return (Method*)nullptr;\n-  Metadata* m = cm->metadata_at(_method_index);\n+  nmethod* nm = code();\n+  if (nm == nullptr) return (Method*)nullptr;\n+  Metadata* m = nm->metadata_at(_method_index);\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-class nmethod;\n@@ -39,1 +38,0 @@\n-class CompiledMethod;\n@@ -42,0 +40,1 @@\n+class nmethod;\n@@ -574,1 +573,1 @@\n-  CompiledMethod* _code;    \/\/ compiled method containing _addr\n+  nmethod*        _code;    \/\/ compiled method containing _addr\n@@ -604,1 +603,1 @@\n-  void initialize(CompiledMethod* nm, address begin, address limit);\n+  void initialize(nmethod* nm, address begin, address limit);\n@@ -610,1 +609,1 @@\n-  RelocIterator(CompiledMethod* nm, address begin = nullptr, address limit = nullptr);\n+  RelocIterator(nmethod* nm, address begin = nullptr, address limit = nullptr);\n@@ -643,1 +642,1 @@\n-  CompiledMethod*     code()  const { return _code; }\n+  nmethod*     code()         const { return _code; }\n@@ -830,1 +829,1 @@\n-  CompiledMethod* code()            const { return binding()->code(); }\n+  nmethod*        code()            const { return binding()->code(); }\n@@ -1466,1 +1465,1 @@\n-inline RelocIterator::RelocIterator(CompiledMethod* nm, address begin, address limit) {\n+inline RelocIterator::RelocIterator(nmethod* nm, address begin, address limit) {\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-ScopeDesc::ScopeDesc(const CompiledMethod* code, PcDesc* pd, bool ignore_objects) {\n+ScopeDesc::ScopeDesc(const nmethod* code, PcDesc* pd, bool ignore_objects) {\n@@ -151,3 +151,3 @@\n-      \/\/ If select() returns nullptr, then the object doesn't need to be\n-      \/\/ rematerialized.\n-      if (sv == nullptr) {\n+      \/\/ 'select(...)' may return an ObjectValue that actually represents a\n+      \/\/ non-scalar replaced object participating in a merge.\n+      if (!sv->is_scalar_replaced()) {\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  SimpleScopeDesc(CompiledMethod* code, address pc) {\n+  SimpleScopeDesc(nmethod* code, address pc) {\n@@ -64,1 +64,1 @@\n-  ScopeDesc(const CompiledMethod* code, PcDesc* pd, bool ignore_objects = false);\n+  ScopeDesc(const nmethod* code, PcDesc* pd, bool ignore_objects = false);\n@@ -123,1 +123,1 @@\n-  const CompiledMethod* _code;\n+  const nmethod* _code;\n","filename":"src\/hotspot\/share\/code\/scopeDesc.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-  CompiledMethod *nm = method->code();\n+  nmethod *nm = method->code();\n@@ -711,1 +711,1 @@\n-                                      int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, TRAPS) {\n+                                      int branch_bci, int bci, CompLevel comp_level, nmethod* nm, TRAPS) {\n@@ -1029,1 +1029,1 @@\n-    if (is_trivial(method)) {\n+    if (is_trivial(method) || method->is_native()) {\n@@ -1140,1 +1140,1 @@\n-                                                      CompLevel level, CompiledMethod* nm, TRAPS) {\n+                                                      CompLevel level, nmethod* nm, TRAPS) {\n@@ -1155,1 +1155,1 @@\n-                                                     int bci, CompLevel level, CompiledMethod* nm, TRAPS) {\n+                                                     int bci, CompLevel level, nmethod* nm, TRAPS) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,1 +238,1 @@\n-                               CompLevel level, CompiledMethod* nm, TRAPS);\n+                                      CompLevel level, nmethod* nm, TRAPS);\n@@ -240,1 +240,1 @@\n-                                int bci, CompLevel level, CompiledMethod* nm, TRAPS);\n+                                      int bci, CompLevel level, nmethod* nm, TRAPS);\n@@ -268,1 +268,1 @@\n-                 int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, TRAPS);\n+                        int branch_bci, int bci, CompLevel comp_level, nmethod* nm, TRAPS);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1379,3 +1379,2 @@\n-    CompiledMethod* method_code = method->code();\n-    if (method_code != nullptr && method_code->is_nmethod()\n-                      && (compile_reason != CompileTask::Reason_DirectivesChanged)) {\n+    nmethod* method_code = method->code();\n+    if (method_code != nullptr && (compile_reason != CompileTask::Reason_DirectivesChanged)) {\n@@ -1383,1 +1382,1 @@\n-        return (nmethod*) method_code;\n+        return method_code;\n@@ -1484,6 +1483,1 @@\n-    CompiledMethod* code = method->code();\n-    if (code == nullptr) {\n-      return (nmethod*) code;\n-    } else {\n-      return code->as_nmethod_or_null();\n-    }\n+    return method->code();\n@@ -1514,1 +1508,1 @@\n-      CompiledMethod* result = method->code();\n+      nmethod* result = method->code();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-                       notproduct,                                          \\\n@@ -98,1 +97,1 @@\n-  notproduct(intx, CICrashAt, -1,                                           \\\n+  develop(intx, CICrashAt, -1,                                              \\\n@@ -102,1 +101,1 @@\n-  notproduct(bool, CIObjectFactoryVerify, false,                            \\\n+  develop(bool, CIObjectFactoryVerify, false,                               \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -501,1 +501,0 @@\n-      \/\/DEBUG_ONLY(nof_callee++;)\n@@ -523,1 +522,0 @@\n-  DEBUG_ONLY(int nof_callee = 0;)\n@@ -525,7 +523,0 @@\n-\n-  \/\/ Check that runtime stubs save all callee-saved registers\n-#ifdef COMPILER2\n-  assert(cb == nullptr || cb->is_compiled_by_c1() || cb->is_compiled_by_jvmci() || !cb->is_runtime_stub() ||\n-         (nof_callee >= SAVED_ON_ENTRY_REG_COUNT || nof_callee >= C_SAVED_ON_ENTRY_REG_COUNT),\n-         \"must save all\");\n-#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-                         notproduct,                                        \\\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilon_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,4 +34,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ G1BlockOffsetTable\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -65,8 +61,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ G1BlockOffsetTablePart\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-G1BlockOffsetTablePart::G1BlockOffsetTablePart(G1BlockOffsetTable* array, HeapRegion* hr) :\n-  _bot(array),\n-  _hr(hr) {}\n-\n@@ -105,1 +93,1 @@\n-void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(uint8_t* start_card, uint8_t* end_card) {\n+void G1BlockOffsetTable::set_remainder_to_point_to_start_incl(uint8_t* start_card, uint8_t* end_card) {\n@@ -107,2 +95,1 @@\n-  assert(start_card > _bot->entry_for_addr(_hr->bottom()), \"Cannot be first card\");\n-  assert(_bot->offset_array(start_card-1) < CardTable::card_size_in_words(),\n+  assert(offset_array(start_card-1) < CardTable::card_size_in_words(),\n@@ -119,1 +106,1 @@\n-      _bot->set_offset_array(start_card_for_region, end_card, offset);\n+      set_offset_array(start_card_for_region, end_card, offset);\n@@ -123,1 +110,1 @@\n-    _bot->set_offset_array(start_card_for_region, reach, offset);\n+    set_offset_array(start_card_for_region, reach, offset);\n@@ -134,1 +121,1 @@\n-void G1BlockOffsetTablePart::check_all_cards(uint8_t* start_card, uint8_t* end_card) const {\n+void G1BlockOffsetTable::check_all_cards(uint8_t* start_card, uint8_t* end_card) const {\n@@ -138,1 +125,1 @@\n-  guarantee(_bot->offset_array(start_card) == CardTable::card_size_in_words(), \"Wrong value in second card\");\n+  guarantee(offset_array(start_card) == CardTable::card_size_in_words(), \"Wrong value in second card\");\n@@ -140,1 +127,1 @@\n-    uint8_t entry = _bot->offset_array(c);\n+    uint8_t entry = offset_array(c);\n@@ -147,1 +134,1 @@\n-                (uint)entry, (uint)_bot->offset_array(c), CardTable::card_size_in_words());\n+                (uint)entry, (uint)offset_array(c), CardTable::card_size_in_words());\n@@ -153,1 +140,1 @@\n-      guarantee(_bot->offset_array(landing_card) <= entry,\n+      guarantee(offset_array(landing_card) <= entry,\n@@ -156,1 +143,1 @@\n-                (uint)_bot->offset_array(landing_card), (uint)entry);\n+                (uint)offset_array(landing_card), (uint)entry);\n@@ -160,1 +147,1 @@\n-      guarantee(_bot->offset_array(landing_card) < CardTable::card_size_in_words(),\n+      guarantee(offset_array(landing_card) < CardTable::card_size_in_words(),\n@@ -163,1 +150,1 @@\n-                (uint)_bot->offset_array(landing_card), (uint)CardTable::card_size_in_words());\n+                (uint)offset_array(landing_card), (uint)CardTable::card_size_in_words());\n@@ -179,2 +166,1 @@\n-void G1BlockOffsetTablePart::update_for_block_work(HeapWord* blk_start,\n-                                                   HeapWord* blk_end) {\n+void G1BlockOffsetTable::update_for_block_work(HeapWord* blk_start, HeapWord* blk_end) {\n@@ -182,1 +168,1 @@\n-  uint8_t* const offset_card =  _bot->entry_for_addr(cur_card_boundary);\n+  uint8_t* const offset_card = entry_for_addr(cur_card_boundary);\n@@ -194,1 +180,1 @@\n-  assert(cur_card_boundary == _bot->addr_for_entry(offset_card),\n+  assert(cur_card_boundary == addr_for_entry(offset_card),\n@@ -198,1 +184,1 @@\n-  _bot->set_offset_array(offset_card, cur_card_boundary, blk_start);\n+  set_offset_array(offset_card, cur_card_boundary, blk_start);\n@@ -203,1 +189,1 @@\n-  uint8_t* end_card = _bot->entry_for_addr(blk_end - 1);\n+  uint8_t* end_card = entry_for_addr(blk_end - 1);\n@@ -213,1 +199,1 @@\n-  HeapWord* new_card_boundary = _bot->addr_for_entry(end_card) + CardTable::card_size_in_words();\n+  HeapWord* new_card_boundary = addr_for_entry(end_card) + CardTable::card_size_in_words();\n@@ -218,4 +204,4 @@\n-  uint8_t* previous_card = _bot->entry_for_addr(blk_start);\n-  HeapWord* boundary = _bot->addr_for_entry(previous_card);\n-  assert((_bot->offset_array(offset_card) == 0 && blk_start == boundary) ||\n-         (_bot->offset_array(offset_card) > 0 && _bot->offset_array(offset_card) < CardTable::card_size_in_words()),\n+  uint8_t* previous_card = entry_for_addr(blk_start);\n+  HeapWord* boundary = addr_for_entry(previous_card);\n+  assert((offset_array(offset_card) == 0 && blk_start == boundary) ||\n+         (offset_array(offset_card) > 0 && offset_array(offset_card) < CardTable::card_size_in_words()),\n@@ -226,1 +212,1 @@\n-         (uint)_bot->offset_array(offset_card),\n+         (uint)offset_array(offset_card),\n@@ -229,3 +215,2 @@\n-    assert(_bot->offset_array(j) > 0 &&\n-           _bot->offset_array(j) <=\n-             (uint8_t) (CardTable::card_size_in_words() + BOTConstants::N_powers - 1),\n+    assert(offset_array(j) > 0 &&\n+           offset_array(j) <= (uint8_t) (CardTable::card_size_in_words() + BOTConstants::N_powers - 1),\n@@ -234,2 +219,2 @@\n-           (uint) _bot->offset_array(j),\n-           (uint) _bot->offset_array(j),\n+           (uint) offset_array(j),\n+           (uint) offset_array(j),\n@@ -241,4 +226,4 @@\n-void G1BlockOffsetTablePart::verify() const {\n-  assert(_hr->bottom() < _hr->top(), \"Only non-empty regions should be verified.\");\n-  uint8_t* start_card = _bot->entry_for_addr(_hr->bottom());\n-  uint8_t* end_card = _bot->entry_for_addr(_hr->top() - 1);\n+void G1BlockOffsetTable::verify(const HeapRegion* hr) const {\n+  assert(hr->bottom() < hr->top(), \"Only non-empty regions should be verified.\");\n+  uint8_t* start_card = entry_for_addr(hr->bottom());\n+  uint8_t* end_card = entry_for_addr(hr->top() - 1);\n@@ -247,1 +232,1 @@\n-    uint8_t entry = _bot->offset_array(current_card);\n+    uint8_t entry = offset_array(current_card);\n@@ -252,1 +237,1 @@\n-      HeapWord* card_address = _bot->addr_for_entry(current_card);\n+      HeapWord* card_address = addr_for_entry(current_card);\n@@ -256,1 +241,1 @@\n-        size_t obj_size = _hr->block_size(obj);\n+        size_t obj_size = hr->block_size(obj);\n@@ -258,1 +243,1 @@\n-        guarantee(obj_end > obj && obj_end <= _hr->top(),\n+        guarantee(obj_end > obj && obj_end <= hr->top(),\n@@ -260,1 +245,1 @@\n-                  p2i(obj), obj_size, p2i(obj_end), p2i(_hr->top()));\n+                  p2i(obj), obj_size, p2i(obj_end), p2i(hr->top()));\n@@ -274,2 +259,2 @@\n-      HeapWord* backskip_address = _bot->addr_for_entry(current_card - backskip);\n-      guarantee(backskip_address >= _hr->bottom(),\n+      HeapWord* backskip_address = addr_for_entry(current_card - backskip);\n+      guarantee(backskip_address >= hr->bottom(),\n@@ -277,1 +262,1 @@\n-                p2i(_hr->bottom()), p2i(backskip_address));\n+                p2i(hr->bottom()), p2i(backskip_address));\n@@ -281,22 +266,0 @@\n-\n-#ifndef PRODUCT\n-void G1BlockOffsetTablePart::print_on(outputStream* out) {\n-  uint8_t* from_card = _bot->entry_for_addr(_hr->bottom());\n-  uint8_t* to_card = _bot->entry_for_addr(_hr->end());\n-  out->print_cr(\">> BOT for area [\" PTR_FORMAT \",\" PTR_FORMAT \") \"\n-                \"cards [\" SIZE_FORMAT \",\" SIZE_FORMAT \")\",\n-                p2i(_hr->bottom()), p2i(_hr->end()), p2i(from_card), p2i(to_card));\n-  for (uint8_t* i = from_card; i < to_card; ++i) {\n-    out->print_cr(\"  entry \" SIZE_FORMAT_W(8) \" | \" PTR_FORMAT \" : %3u\",\n-                  p2i(i), p2i(_bot->addr_for_entry(i)),\n-                  (uint) _bot->offset_array(i));\n-  }\n-}\n-#endif \/\/ !PRODUCT\n-\n-void G1BlockOffsetTablePart::set_for_starts_humongous(HeapWord* obj_top, size_t fill_size) {\n-  update_for_block(_hr->bottom(), obj_top);\n-  if (fill_size > 0) {\n-    update_for_block(obj_top, fill_size);\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":39,"deletions":76,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class G1BlockOffsetTable;\n@@ -43,3 +42,0 @@\n-\/\/\n-\/\/ Each G1BlockOffsetTablePart is owned by a HeapRegion.\n-\n@@ -47,1 +43,0 @@\n-  friend class G1BlockOffsetTablePart;\n@@ -76,0 +71,13 @@\n+  \/\/ Sets the entries corresponding to the cards starting at \"start\" and ending\n+  \/\/ at \"end\" to point back to the card before \"start\"; [start, end]\n+  void set_remainder_to_point_to_start_incl(uint8_t* start, uint8_t* end);\n+\n+  \/\/ Update BOT entries corresponding to the mem range [blk_start, blk_end).\n+  void update_for_block_work(HeapWord* blk_start, HeapWord* blk_end);\n+\n+  void check_all_cards(uint8_t* left_card, uint8_t* right_card) const NOT_DEBUG_RETURN;\n+\n+  static HeapWord* align_up_by_card_size(HeapWord* const addr) {\n+    return align_up(addr, CardTable::card_size());\n+  }\n+\n@@ -99,11 +107,0 @@\n-};\n-\n-class G1BlockOffsetTablePart {\n-  friend class G1BlockOffsetTable;\n-  friend class VMStructs;\n-private:\n-  \/\/ This is the global BlockOffsetTable.\n-  G1BlockOffsetTable* _bot;\n-\n-  \/\/ The region that owns this part of the BOT.\n-  HeapRegion* _hr;\n@@ -111,17 +108,0 @@\n-  \/\/ Sets the entries corresponding to the cards starting at \"start\" and ending\n-  \/\/ at \"end\" to point back to the card before \"start\"; [start, end]\n-  void set_remainder_to_point_to_start_incl(uint8_t* start, uint8_t* end);\n-\n-  \/\/ Update BOT entries corresponding to the mem range [blk_start, blk_end).\n-  void update_for_block_work(HeapWord* blk_start, HeapWord* blk_end);\n-\n-  void check_all_cards(uint8_t* left_card, uint8_t* right_card) const NOT_DEBUG_RETURN;\n-\n-  static HeapWord* align_up_by_card_size(HeapWord* const addr) {\n-    return align_up(addr, CardTable::card_size());\n-  }\n-\n-  void update_for_block(HeapWord* blk_start, size_t size) {\n-    update_for_block(blk_start, blk_start + size);\n-  }\n-public:\n@@ -135,4 +115,1 @@\n-  \/\/  The elements of the array are initialized to zero.\n-  G1BlockOffsetTablePart(G1BlockOffsetTable* array, HeapRegion* hr);\n-\n-  void verify() const;\n+  void verify(const HeapRegion* hr) const;\n@@ -149,4 +126,0 @@\n-\n-  void set_for_starts_humongous(HeapWord* obj_top, size_t fill_size);\n-\n-  void print_on(outputStream* out) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":14,"deletions":41,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-inline HeapWord* G1BlockOffsetTablePart::block_start_reaching_into_card(const void* addr) const {\n-  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n+inline HeapWord* G1BlockOffsetTable::block_start_reaching_into_card(const void* addr) const {\n+  assert(_reserved.contains(addr), \"invalid address\");\n@@ -38,11 +38,2 @@\n-#ifdef ASSERT\n-  if (!_hr->is_continues_humongous()) {\n-    \/\/ For non-ContinuesHumongous regions, the first obj always starts from bottom.\n-    uint8_t offset = _bot->offset_array(_bot->entry_for_addr(_hr->bottom()));\n-    assert(offset == 0, \"Found offset %u instead of 0 for region %u %s\",\n-           offset, _hr->hrm_index(), _hr->get_short_type_str());\n-  }\n-#endif\n-\n-  uint8_t* entry = _bot->entry_for_addr(addr);\n-  uint8_t offset = _bot->offset_array(entry);\n+  uint8_t* entry = entry_for_addr(addr);\n+  uint8_t offset = offset_array(entry);\n@@ -54,1 +45,1 @@\n-    offset = _bot->offset_array(entry);\n+    offset = offset_array(entry);\n@@ -57,1 +48,1 @@\n-  HeapWord* q = _bot->addr_for_entry(entry);\n+  HeapWord* q = addr_for_entry(entry);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"code\/nmethod.hpp\"\n-#include \"gc\/g1\/g1CodeBlobClosure.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n-#include \"gc\/g1\/g1HeapRegion.hpp\"\n-#include \"gc\/g1\/g1HeapRegionRemSet.inline.hpp\"\n-#include \"gc\/shared\/barrierSetNMethod.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/compressedOops.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-\n-template <typename T>\n-void G1CodeBlobClosure::HeapRegionGatheringOopClosure::do_oop_work(T* p) {\n-  _work->do_oop(p);\n-  T oop_or_narrowoop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(oop_or_narrowoop)) {\n-    oop o = CompressedOops::decode_not_null(oop_or_narrowoop);\n-    HeapRegion* hr = _g1h->heap_region_containing(o);\n-    assert(!_g1h->is_in_cset(o) || hr->rem_set()->code_roots_list_contains(_nm), \"if o still in collection set then evacuation failed and nm must already be in the remset\");\n-    hr->add_code_root(_nm);\n-  }\n-}\n-\n-void G1CodeBlobClosure::HeapRegionGatheringOopClosure::do_oop(oop* o) {\n-  do_oop_work(o);\n-}\n-\n-void G1CodeBlobClosure::HeapRegionGatheringOopClosure::do_oop(narrowOop* o) {\n-  do_oop_work(o);\n-}\n-\n-template<typename T>\n-void G1CodeBlobClosure::MarkingOopClosure::do_oop_work(T* p) {\n-  T oop_or_narrowoop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(oop_or_narrowoop)) {\n-    oop o = CompressedOops::decode_not_null(oop_or_narrowoop);\n-    _cm->mark_in_bitmap(_worker_id, o);\n-  }\n-}\n-\n-G1CodeBlobClosure::MarkingOopClosure::MarkingOopClosure(uint worker_id) :\n-  _cm(G1CollectedHeap::heap()->concurrent_mark()), _worker_id(worker_id) { }\n-\n-void G1CodeBlobClosure::MarkingOopClosure::do_oop(oop* o) {\n-  do_oop_work(o);\n-}\n-\n-void G1CodeBlobClosure::MarkingOopClosure::do_oop(narrowOop* o) {\n-  do_oop_work(o);\n-}\n-\n-void G1CodeBlobClosure::do_evacuation_and_fixup(nmethod* nm) {\n-  _oc.set_nm(nm);\n-\n-  \/\/ Evacuate objects pointed to by the nmethod\n-  nm->oops_do(&_oc);\n-\n-  if (_strong) {\n-    \/\/ CodeCache unloading support\n-    nm->mark_as_maybe_on_stack();\n-\n-    BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-    if (bs_nm != nullptr) {\n-      bs_nm->disarm(nm);\n-    }\n-  }\n-\n-  nm->fix_oop_relocations();\n-}\n-\n-void G1CodeBlobClosure::do_marking(nmethod* nm) {\n-  \/\/ Mark through oops in the nmethod\n-  nm->oops_do(&_marking_oc);\n-\n-  \/\/ CodeCache unloading support\n-  nm->mark_as_maybe_on_stack();\n-\n-  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs_nm != nullptr) {\n-    bs_nm->disarm(nm);\n-  }\n-\n-  \/\/ The oops were only marked, no need to update oop relocations.\n-}\n-\n-class G1NmethodProcessor : public nmethod::OopsDoProcessor {\n-  G1CodeBlobClosure* _cl;\n-\n-public:\n-  G1NmethodProcessor(G1CodeBlobClosure* cl) : _cl(cl) { }\n-\n-  void do_regular_processing(nmethod* nm) {\n-    _cl->do_evacuation_and_fixup(nm);\n-  }\n-\n-  void do_remaining_strong_processing(nmethod* nm) {\n-    _cl->do_marking(nm);\n-  }\n-};\n-\n-void G1CodeBlobClosure::do_code_blob(CodeBlob* cb) {\n-  nmethod* nm = cb->as_nmethod_or_null();\n-  if (nm == nullptr) {\n-    return;\n-  }\n-\n-  G1NmethodProcessor cl(this);\n-\n-  if (_strong) {\n-    nm->oops_do_process_strong(&cl);\n-  } else {\n-    nm->oops_do_process_weak(&cl);\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeBlobClosure.cpp","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1CODEBLOBCLOSURE_HPP\n-#define SHARE_GC_G1_G1CODEBLOBCLOSURE_HPP\n-\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"memory\/iterator.hpp\"\n-\n-class G1ConcurrentMark;\n-class nmethod;\n-\n-class G1CodeBlobClosure : public CodeBlobClosure {\n-  \/\/ Gather nmethod remembered set entries.\n-  class HeapRegionGatheringOopClosure : public OopClosure {\n-    G1CollectedHeap* _g1h;\n-    OopClosure* _work;\n-    nmethod* _nm;\n-\n-    template <typename T>\n-    void do_oop_work(T* p);\n-\n-  public:\n-    HeapRegionGatheringOopClosure(OopClosure* oc) : _g1h(G1CollectedHeap::heap()), _work(oc), _nm(nullptr) {}\n-\n-    void do_oop(oop* o);\n-    void do_oop(narrowOop* o);\n-\n-    void set_nm(nmethod* nm) {\n-      _nm = nm;\n-    }\n-  };\n-\n-  \/\/ Mark all oops below TAMS.\n-  class MarkingOopClosure : public OopClosure {\n-    G1ConcurrentMark* _cm;\n-    uint _worker_id;\n-\n-    template <typename T>\n-    void do_oop_work(T* p);\n-\n-  public:\n-    MarkingOopClosure(uint worker_id);\n-\n-    void do_oop(oop* o);\n-    void do_oop(narrowOop* o);\n-  };\n-\n-  HeapRegionGatheringOopClosure _oc;\n-  MarkingOopClosure _marking_oc;\n-\n-  bool _strong;\n-public:\n-  G1CodeBlobClosure(uint worker_id, OopClosure* oc, bool strong) :\n-    _oc(oc), _marking_oc(worker_id), _strong(strong) { }\n-\n-  void do_evacuation_and_fixup(nmethod* nm);\n-  void do_marking(nmethod* nm);\n-\n-  void do_code_blob(CodeBlob* cb);\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1CODEBLOBCLOSURE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeBlobClosure.hpp","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -155,1 +155,1 @@\n-  void iterate_at_safepoint(CodeBlobClosure* blk) {\n+  void iterate_at_safepoint(NMethodClosure* blk) {\n@@ -164,1 +164,1 @@\n-        blk->do_code_blob(*value);\n+        blk->do_nmethod(*value);\n@@ -291,1 +291,1 @@\n-void G1CodeRootSet::nmethods_do(CodeBlobClosure* blk) const {\n+void G1CodeRootSet::nmethods_do(NMethodClosure* blk) const {\n@@ -320,1 +320,1 @@\n-  CodeBlobToOopClosure _blobs;\n+  NMethodToOopClosure _nmethod_cl;\n@@ -323,1 +323,1 @@\n-  CleanCallback(HeapRegion* hr) : _detector(hr), _blobs(&_detector, !CodeBlobToOopClosure::FixRelocations) {}\n+  CleanCallback(HeapRegion* hr) : _detector(hr), _nmethod_cl(&_detector, !NMethodToOopClosure::FixRelocations) {}\n@@ -327,1 +327,1 @@\n-    _blobs.do_code_blob(*value);\n+    _nmethod_cl.do_nmethod(*value);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  void nmethods_do(CodeBlobClosure* blk) const;\n+  void nmethods_do(NMethodClosure* blk) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -535,1 +535,1 @@\n-void G1CollectedHeap::populate_archive_regions_bot_part(MemRegion range) {\n+void G1CollectedHeap::populate_archive_regions_bot(MemRegion range) {\n@@ -2521,1 +2521,1 @@\n-                            false \/* lock_codeblob_free_separately *\/);\n+                            false \/* lock_nmethod_free_separately *\/);\n@@ -2538,1 +2538,1 @@\n-    ctx.free_code_blobs();\n+    ctx.free_nmethods();\n@@ -3019,1 +3019,1 @@\n-class RebuildCodeRootClosure: public CodeBlobClosure {\n+class RebuildCodeRootClosure: public NMethodClosure {\n@@ -3026,5 +3026,3 @@\n-  void do_code_blob(CodeBlob* cb) {\n-    nmethod* nm = cb->as_nmethod_or_null();\n-    if (nm != nullptr) {\n-      _g1h->register_nmethod(nm);\n-    }\n+  void do_nmethod(nmethod* nm) {\n+    assert(nm != nullptr, \"Sanity\");\n+    _g1h->register_nmethod(nm);\n@@ -3035,2 +3033,2 @@\n-  RebuildCodeRootClosure blob_cl(this);\n-  CodeCache::blobs_do(&blob_cl);\n+  RebuildCodeRootClosure nmethod_cl(this);\n+  CodeCache::nmethods_do(&nmethod_cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -720,1 +720,1 @@\n-  \/\/ Populate the G1BlockOffsetTablePart for archived regions with the given\n+  \/\/ Populate the G1BlockOffsetTable for archived regions with the given\n@@ -722,1 +722,1 @@\n-  void populate_archive_regions_bot_part(MemRegion range);\n+  void populate_archive_regions_bot(MemRegion range);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -251,2 +251,2 @@\n-  Klass* k = obj->klass_raw();\n-  return k == Universe::fillerArrayKlassObj() || k == vmClasses::FillerObject_klass();\n+  Klass* k = obj->klass_without_asserts();\n+  return k == Universe::fillerArrayKlass() || k == vmClasses::FillerObject_klass();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  CodeBlobToOopClosure adjust_code(&_adjust, CodeBlobToOopClosure::FixRelocations);\n+  NMethodToOopClosure adjust_code(&_adjust, NMethodToOopClosure::FixRelocations);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  MarkingCodeBlobClosure code_closure(marker->mark_closure(), !CodeBlobToOopClosure::FixRelocations, true \/* keepalive nmethods *\/);\n+  MarkingNMethodClosure code_closure(marker->mark_closure(), !NMethodToOopClosure::FixRelocations, true \/* keepalive nmethods *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  _gc_par_phases[CodeRoots]->create_thread_work_items(\"Scanned Nmethods\", CodeRootsScannedNMethods);\n+  _gc_par_phases[CodeRoots]->create_thread_work_items(\"Scanned Nmethods:\", CodeRootsScannedNMethods);\n@@ -128,1 +128,1 @@\n-  _gc_par_phases[OptCodeRoots]->create_thread_work_items(\"Scanned Nmethods\", CodeRootsScannedNMethods);\n+  _gc_par_phases[OptCodeRoots]->create_thread_work_items(\"Scanned Nmethods:\", CodeRootsScannedNMethods);\n@@ -130,4 +130,4 @@\n-  _gc_par_phases[MergePSS]->create_thread_work_items(\"Copied Bytes\", MergePSSCopiedBytes);\n-  _gc_par_phases[MergePSS]->create_thread_work_items(\"LAB Waste\", MergePSSLABWasteBytes);\n-  _gc_par_phases[MergePSS]->create_thread_work_items(\"LAB Undo Waste\", MergePSSLABUndoWasteBytes);\n-  _gc_par_phases[MergePSS]->create_thread_work_items(\"Evac Fail Extra Cards\", MergePSSEvacFailExtra);\n+  _gc_par_phases[MergePSS]->create_thread_work_items(\"Copied Bytes:\", MergePSSCopiedBytes);\n+  _gc_par_phases[MergePSS]->create_thread_work_items(\"LAB Waste:\", MergePSSLABWasteBytes);\n+  _gc_par_phases[MergePSS]->create_thread_work_items(\"LAB Undo Waste:\", MergePSSLABUndoWasteBytes);\n+  _gc_par_phases[MergePSS]->create_thread_work_items(\"Evac Fail Extra Cards:\", MergePSSEvacFailExtra);\n@@ -144,3 +144,3 @@\n-  _gc_par_phases[EagerlyReclaimHumongousObjects]->create_thread_work_items(\"Humongous Total\", EagerlyReclaimNumTotal);\n-  _gc_par_phases[EagerlyReclaimHumongousObjects]->create_thread_work_items(\"Humongous Candidates\", EagerlyReclaimNumCandidates);\n-  _gc_par_phases[EagerlyReclaimHumongousObjects]->create_thread_work_items(\"Humongous Reclaimed\", EagerlyReclaimNumReclaimed);\n+  _gc_par_phases[EagerlyReclaimHumongousObjects]->create_thread_work_items(\"Humongous Total:\", EagerlyReclaimNumTotal);\n+  _gc_par_phases[EagerlyReclaimHumongousObjects]->create_thread_work_items(\"Humongous Candidates:\", EagerlyReclaimNumCandidates);\n+  _gc_par_phases[EagerlyReclaimHumongousObjects]->create_thread_work_items(\"Humongous Reclaimed:\", EagerlyReclaimNumReclaimed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -119,3 +119,3 @@\n-    { \"Merged Inline\", \"Merged ArrayOfCards\", \"Merged Howl\", \"Merged Full\",\n-      \"Merged Howl Inline\", \"Merged Howl ArrayOfCards\", \"Merged Howl BitMap\", \"Merged Howl Full\",\n-      \"Merged Cards\" };\n+    { \"Merged Inline:\", \"Merged ArrayOfCards:\", \"Merged Howl:\", \"Merged Full:\",\n+      \"Merged Howl Inline:\", \"Merged Howl ArrayOfCards:\", \"Merged Howl BitMap:\", \"Merged Howl Full:\",\n+      \"Merged Cards:\" };\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,1 +191,4 @@\n-  _bot_part.set_for_starts_humongous(obj_top, fill_size);\n+  _bot->update_for_block(bottom(), obj_top);\n+  if (fill_size > 0) {\n+    _bot->update_for_block(obj_top, obj_top + fill_size);\n+  }\n@@ -222,1 +225,1 @@\n-  _bot_part(bot, this),\n+  _bot(bot),\n@@ -289,1 +292,1 @@\n-void HeapRegion::code_roots_do(CodeBlobClosure* blk) const {\n+void HeapRegion::code_roots_do(NMethodClosure* blk) const {\n@@ -331,1 +334,1 @@\n-class VerifyCodeRootCodeBlobClosure: public CodeBlobClosure {\n+class VerifyCodeRootNMethodClosure: public NMethodClosure {\n@@ -335,1 +338,1 @@\n-  VerifyCodeRootCodeBlobClosure(const HeapRegion* hr) :\n+  VerifyCodeRootNMethodClosure(const HeapRegion* hr) :\n@@ -338,15 +341,14 @@\n-  void do_code_blob(CodeBlob* cb) {\n-    nmethod* nm = (cb == nullptr) ? nullptr : cb->as_compiled_method()->as_nmethod_or_null();\n-    if (nm != nullptr) {\n-      \/\/ Verify that the nemthod is live\n-      VerifyCodeRootOopClosure oop_cl(_hr);\n-      nm->oops_do(&oop_cl);\n-      if (!oop_cl.has_oops_in_region()) {\n-        log_error(gc, verify)(\"region [\" PTR_FORMAT \",\" PTR_FORMAT \"] has nmethod \" PTR_FORMAT \" in its code roots with no pointers into region\",\n-                              p2i(_hr->bottom()), p2i(_hr->end()), p2i(nm));\n-        _failures = true;\n-      } else if (oop_cl.failures()) {\n-        log_error(gc, verify)(\"region [\" PTR_FORMAT \",\" PTR_FORMAT \"] has other failures for nmethod \" PTR_FORMAT,\n-                              p2i(_hr->bottom()), p2i(_hr->end()), p2i(nm));\n-        _failures = true;\n-      }\n+  void do_nmethod(nmethod* nm) {\n+    assert(nm != nullptr, \"Sanity\");\n+\n+    \/\/ Verify that the nmethod is live\n+    VerifyCodeRootOopClosure oop_cl(_hr);\n+    nm->oops_do(&oop_cl);\n+    if (!oop_cl.has_oops_in_region()) {\n+      log_error(gc, verify)(\"region [\" PTR_FORMAT \",\" PTR_FORMAT \"] has nmethod \" PTR_FORMAT \" in its code roots with no pointers into region\",\n+          p2i(_hr->bottom()), p2i(_hr->end()), p2i(nm));\n+      _failures = true;\n+    } else if (oop_cl.failures()) {\n+      log_error(gc, verify)(\"region [\" PTR_FORMAT \",\" PTR_FORMAT \"] has other failures for nmethod \" PTR_FORMAT,\n+          p2i(_hr->bottom()), p2i(_hr->end()), p2i(nm));\n+      _failures = true;\n@@ -398,2 +400,2 @@\n-  VerifyCodeRootCodeBlobClosure cb_cl(this);\n-  code_roots_do(&cb_cl);\n+  VerifyCodeRootNMethodClosure nm_cl(this);\n+  code_roots_do(&nm_cl);\n@@ -401,1 +403,1 @@\n-  return cb_cl.failures();\n+  return nm_cl.failures();\n@@ -436,2 +438,6 @@\n-  if (!oopDesc::is_oop(obj)) {\n-    log_error(gc, verify)(PTR_FORMAT \" not an oop\", p2i(obj));\n+  \/\/ Make a few sanity checks of the class before calling the full-fledged\n+  \/\/ is_oop check (which also performs its own klass verification).\n+  Klass* klass = obj->klass_without_asserts();\n+\n+  if (klass == nullptr) {\n+    log_error(gc, verify)(\"Object \" PTR_FORMAT \" has a null klass\", p2i(obj));\n@@ -441,5 +447,1 @@\n-  \/\/ Now examine the Klass a little more closely.\n-  Klass* klass = obj->klass_raw();\n-\n-  bool is_metaspace_object = Metaspace::contains(klass);\n-  if (!is_metaspace_object) {\n+  if (!Metaspace::contains(klass)) {\n@@ -447,1 +449,1 @@\n-                          \"not metadata\", p2i(klass), p2i(obj));\n+                          \"is not in metaspace\", p2i(klass), p2i(obj));\n@@ -449,1 +451,3 @@\n-  } else if (!klass->is_klass()) {\n+  }\n+\n+  if (!klass->is_klass()) {\n@@ -455,0 +459,6 @@\n+  \/\/ Now, perform the more in-depth verification of the object.\n+  if (!oopDesc::is_oop(obj)) {\n+    log_error(gc, verify)(PTR_FORMAT \" not an oop\", p2i(obj));\n+    return false;\n+  }\n+\n@@ -458,0 +468,15 @@\n+class G1VerifyFailureCounter {\n+  size_t _count;\n+\n+public:\n+  G1VerifyFailureCounter() : _count(0) {}\n+\n+  \/\/ Increases the failure counter and return whether this has been the first failure.\n+  bool record_failure() {\n+    _count++;\n+    return _count == 1;\n+  }\n+\n+  size_t count() const { return _count; }\n+};\n+\n@@ -461,3 +486,3 @@\n-  VerifyOption _vo;\n-  oop _containing_obj;\n-  size_t _num_failures;\n+  const VerifyOption _vo;\n+  const oop _containing_obj;\n+  G1VerifyFailureCounter* const _failures;\n@@ -467,2 +492,1 @@\n-    _num_failures++;\n-    return _num_failures == 1;\n+    return _failures->record_failure();\n@@ -482,1 +506,1 @@\n-    G1VerifyLiveAndRemSetClosure* _cl;\n+    G1VerifyFailureCounter* _failures;\n@@ -487,1 +511,1 @@\n-    Checker(G1VerifyLiveAndRemSetClosure* cl, oop containing_obj, T* p, oop obj) :\n+    Checker(G1VerifyFailureCounter* failures, oop containing_obj, T* p, oop obj) :\n@@ -489,1 +513,1 @@\n-      _cl(cl),\n+      _failures(failures),\n@@ -494,0 +518,4 @@\n+    bool record_failure() {\n+      return _failures->record_failure();\n+    }\n+\n@@ -512,1 +540,2 @@\n-    LiveChecker(G1VerifyLiveAndRemSetClosure* cl, oop containing_obj, T* p, oop obj, VerifyOption vo) : Checker<T>(cl, containing_obj, p, obj) {\n+    LiveChecker(G1VerifyFailureCounter* failures, oop containing_obj, T* p, oop obj, VerifyOption vo)\n+      : Checker<T>(failures, containing_obj, p, obj) {\n@@ -528,1 +557,1 @@\n-      if (this->_cl->record_failure()) {\n+      if (this->record_failure()) {\n@@ -554,1 +583,2 @@\n-    RemSetChecker(G1VerifyLiveAndRemSetClosure* cl, oop containing_obj, T* p, oop obj) : Checker<T>(cl, containing_obj, p, obj) {\n+    RemSetChecker(G1VerifyFailureCounter* failures, oop containing_obj, T* p, oop obj)\n+      : Checker<T>(failures, containing_obj, p, obj) {\n@@ -581,1 +611,1 @@\n-      if (this->_cl->record_failure()) {\n+      if (this->record_failure()) {\n@@ -594,4 +624,1 @@\n-    assert(_containing_obj != nullptr, \"must be\");\n-    assert(!G1CollectedHeap::heap()->is_obj_dead_cond(_containing_obj, _vo), \"Precondition\");\n-\n-    if (num_failures() >= G1MaxVerifyFailures) {\n+    if (_failures->count() >= G1MaxVerifyFailures) {\n@@ -607,1 +634,1 @@\n-    LiveChecker<T> live_check(this, _containing_obj, p, obj, _vo);\n+    LiveChecker<T> live_check(_failures, _containing_obj, p, obj, _vo);\n@@ -614,1 +641,1 @@\n-    RemSetChecker<T> remset_check(this, _containing_obj, p, obj);\n+    RemSetChecker<T> remset_check(_failures, _containing_obj, p, obj);\n@@ -621,10 +648,4 @@\n-  G1VerifyLiveAndRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo) :\n-    _vo(vo),\n-    _containing_obj(nullptr),\n-    _num_failures(0) { }\n-\n-  void set_containing_obj(oop const obj) {\n-    _containing_obj = obj;\n-  }\n-\n-  size_t num_failures() const { return _num_failures; }\n+  G1VerifyLiveAndRemSetClosure(oop containing_obj, VerifyOption vo, G1VerifyFailureCounter* failures)\n+    : _vo(vo),\n+      _containing_obj(containing_obj),\n+      _failures(failures) {}\n@@ -639,3 +660,1 @@\n-  G1VerifyLiveAndRemSetClosure cl(g1h, vo);\n-\n-  size_t other_failures = 0;\n+  G1VerifyFailureCounter failures;\n@@ -652,1 +671,1 @@\n-      cl.set_containing_obj(obj);\n+      G1VerifyLiveAndRemSetClosure cl(obj, vo, &failures);\n@@ -655,1 +674,1 @@\n-      other_failures++;\n+      failures.record_failure();\n@@ -658,1 +677,1 @@\n-    if ((cl.num_failures() + other_failures) >= G1MaxVerifyFailures) {\n+    if (failures.count() >= G1MaxVerifyFailures) {\n@@ -668,1 +687,1 @@\n-  return (cl.num_failures() + other_failures) != 0;\n+  return failures.count() != 0;\n@@ -681,1 +700,1 @@\n-    _bot_part.verify();\n+    _bot->verify(this);\n@@ -710,1 +729,1 @@\n-  _bot_part.update_for_block(start, end);\n+  _bot->update_for_block(start, end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":88,"deletions":69,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  G1BlockOffsetTablePart _bot_part;\n+  G1BlockOffsetTable* _bot;\n@@ -434,2 +434,0 @@\n-  inline const char* collection_set_candidate_short_type_str() const;\n-\n@@ -543,1 +541,1 @@\n-  \/\/ Applies blk->do_code_blob() to each of the entries in\n+  \/\/ Applies blk->do_nmethod() to each of the entries in\n@@ -545,1 +543,1 @@\n-  void code_roots_do(CodeBlobClosure* blk) const;\n+  void code_roots_do(NMethodClosure* blk) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    assert(!G1BlockOffsetTablePart::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n+    assert(!G1BlockOffsetTable::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n@@ -108,1 +108,2 @@\n-  HeapWord* first_block = _bot_part.block_start_reaching_into_card(addr);\n+  assert(addr >= bottom() && addr < top(), \"invalid address\");\n+  HeapWord* first_block = _bot->block_start_reaching_into_card(addr);\n@@ -265,1 +266,1 @@\n-  _bot_part.update_for_block(obj_start, obj_end);\n+  _bot->update_for_block(obj_start, obj_end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-void HeapRegionRemSet::code_roots_do(CodeBlobClosure* blk) const {\n+void HeapRegionRemSet::code_roots_do(NMethodClosure* blk) const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  \/\/ A set of code blobs (nmethods) whose code contains pointers into\n+  \/\/ A set of nmethods whose code contains pointers into\n@@ -155,2 +155,2 @@\n-  \/\/ Applies blk->do_code_blob() to each of the entries in _code_roots\n-  void code_roots_do(CodeBlobClosure* blk) const;\n+  \/\/ Applies blk->do_nmethod() to each of the entries in _code_roots\n+  void code_roots_do(NMethodClosure* blk) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-class G1VerifyCodeRootBlobClosure: public CodeBlobClosure {\n+class G1VerifyCodeRootNMethodClosure: public NMethodClosure {\n@@ -142,1 +142,1 @@\n-  G1VerifyCodeRootBlobClosure(G1VerifyCodeRootOopClosure* oop_cl):\n+  G1VerifyCodeRootNMethodClosure(G1VerifyCodeRootOopClosure* oop_cl):\n@@ -145,6 +145,4 @@\n-  void do_code_blob(CodeBlob* cb) {\n-    nmethod* nm = cb->as_nmethod_or_null();\n-    if (nm != nullptr) {\n-      _oop_cl->set_nmethod(nm);\n-      nm->oops_do(_oop_cl);\n-    }\n+  void do_nmethod(nmethod* nm) {\n+    assert(nm != nullptr, \"Sanity\");\n+    _oop_cl->set_nmethod(nm);\n+    nm->oops_do(_oop_cl);\n@@ -343,1 +341,1 @@\n-  G1VerifyCodeRootBlobClosure blobsCl(&codeRootsCl);\n+  G1VerifyCodeRootNMethodClosure blobsCl(&codeRootsCl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"gc\/g1\/g1NMethodClosure.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n+#include \"gc\/g1\/g1HeapRegion.hpp\"\n+#include \"gc\/g1\/g1HeapRegionRemSet.inline.hpp\"\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+template <typename T>\n+void G1NMethodClosure::HeapRegionGatheringOopClosure::do_oop_work(T* p) {\n+  _work->do_oop(p);\n+  T oop_or_narrowoop = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(oop_or_narrowoop)) {\n+    oop o = CompressedOops::decode_not_null(oop_or_narrowoop);\n+    HeapRegion* hr = _g1h->heap_region_containing(o);\n+    assert(!_g1h->is_in_cset(o) || hr->rem_set()->code_roots_list_contains(_nm), \"if o still in collection set then evacuation failed and nm must already be in the remset\");\n+    hr->add_code_root(_nm);\n+  }\n+}\n+\n+void G1NMethodClosure::HeapRegionGatheringOopClosure::do_oop(oop* o) {\n+  do_oop_work(o);\n+}\n+\n+void G1NMethodClosure::HeapRegionGatheringOopClosure::do_oop(narrowOop* o) {\n+  do_oop_work(o);\n+}\n+\n+template<typename T>\n+void G1NMethodClosure::MarkingOopClosure::do_oop_work(T* p) {\n+  T oop_or_narrowoop = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(oop_or_narrowoop)) {\n+    oop o = CompressedOops::decode_not_null(oop_or_narrowoop);\n+    _cm->mark_in_bitmap(_worker_id, o);\n+  }\n+}\n+\n+G1NMethodClosure::MarkingOopClosure::MarkingOopClosure(uint worker_id) :\n+  _cm(G1CollectedHeap::heap()->concurrent_mark()), _worker_id(worker_id) { }\n+\n+void G1NMethodClosure::MarkingOopClosure::do_oop(oop* o) {\n+  do_oop_work(o);\n+}\n+\n+void G1NMethodClosure::MarkingOopClosure::do_oop(narrowOop* o) {\n+  do_oop_work(o);\n+}\n+\n+void G1NMethodClosure::do_evacuation_and_fixup(nmethod* nm) {\n+  _oc.set_nm(nm);\n+\n+  \/\/ Evacuate objects pointed to by the nmethod\n+  nm->oops_do(&_oc);\n+\n+  if (_strong) {\n+    \/\/ CodeCache unloading support\n+    nm->mark_as_maybe_on_stack();\n+\n+    BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+    if (bs_nm != nullptr) {\n+      bs_nm->disarm(nm);\n+    }\n+  }\n+\n+  nm->fix_oop_relocations();\n+}\n+\n+void G1NMethodClosure::do_marking(nmethod* nm) {\n+  \/\/ Mark through oops in the nmethod\n+  nm->oops_do(&_marking_oc);\n+\n+  \/\/ CodeCache unloading support\n+  nm->mark_as_maybe_on_stack();\n+\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm != nullptr) {\n+    bs_nm->disarm(nm);\n+  }\n+\n+  \/\/ The oops were only marked, no need to update oop relocations.\n+}\n+\n+class G1NmethodProcessor : public nmethod::OopsDoProcessor {\n+  G1NMethodClosure* _cl;\n+\n+public:\n+  G1NmethodProcessor(G1NMethodClosure* cl) : _cl(cl) { }\n+\n+  void do_regular_processing(nmethod* nm) {\n+    _cl->do_evacuation_and_fixup(nm);\n+  }\n+\n+  void do_remaining_strong_processing(nmethod* nm) {\n+    _cl->do_marking(nm);\n+  }\n+};\n+\n+void G1NMethodClosure::do_nmethod(nmethod* nm) {\n+  assert(nm != nullptr, \"Sanity\");\n+\n+  G1NmethodProcessor cl(this);\n+\n+  if (_strong) {\n+    nm->oops_do_process_strong(&cl);\n+  } else {\n+    nm->oops_do_process_weak(&cl);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NMethodClosure.cpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1NMETHODCLOSURE_HPP\n+#define SHARE_GC_G1_G1NMETHODCLOSURE_HPP\n+\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"memory\/iterator.hpp\"\n+\n+class G1ConcurrentMark;\n+class nmethod;\n+\n+class G1NMethodClosure : public NMethodClosure {\n+  \/\/ Gather nmethod remembered set entries.\n+  class HeapRegionGatheringOopClosure : public OopClosure {\n+    G1CollectedHeap* _g1h;\n+    OopClosure* _work;\n+    nmethod* _nm;\n+\n+    template <typename T>\n+    void do_oop_work(T* p);\n+\n+  public:\n+    HeapRegionGatheringOopClosure(OopClosure* oc) : _g1h(G1CollectedHeap::heap()), _work(oc), _nm(nullptr) {}\n+\n+    void do_oop(oop* o);\n+    void do_oop(narrowOop* o);\n+\n+    void set_nm(nmethod* nm) {\n+      _nm = nm;\n+    }\n+  };\n+\n+  \/\/ Mark all oops below TAMS.\n+  class MarkingOopClosure : public OopClosure {\n+    G1ConcurrentMark* _cm;\n+    uint _worker_id;\n+\n+    template <typename T>\n+    void do_oop_work(T* p);\n+\n+  public:\n+    MarkingOopClosure(uint worker_id);\n+\n+    void do_oop(oop* o);\n+    void do_oop(narrowOop* o);\n+  };\n+\n+  HeapRegionGatheringOopClosure _oc;\n+  MarkingOopClosure _marking_oc;\n+\n+  bool _strong;\n+public:\n+  G1NMethodClosure(uint worker_id, OopClosure* oc, bool strong) :\n+    _oc(oc), _marking_oc(worker_id), _strong(strong) { }\n+\n+  void do_evacuation_and_fixup(nmethod* nm);\n+  void do_marking(nmethod* nm);\n+\n+  void do_nmethod(nmethod* nm);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1NMETHODCLOSURE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NMethodClosure.hpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1188,1 +1188,1 @@\n-  _survivors_age_table.print_age_table(_tenuring_threshold);\n+  _survivors_age_table.print_age_table();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -737,3 +737,3 @@\n-\/\/ Wrapper around a CodeBlobClosure to count the number of code blobs scanned.\n-class G1ScanAndCountCodeBlobClosure : public CodeBlobClosure {\n-  CodeBlobClosure* _cl;\n+\/\/ Wrapper around a NMethodClosure to count the number of nmethods scanned.\n+class G1ScanAndCountNMethodClosure : public NMethodClosure {\n+  NMethodClosure* _cl;\n@@ -743,1 +743,1 @@\n-  G1ScanAndCountCodeBlobClosure(CodeBlobClosure* cl) : _cl(cl), _count(0) {\n+  G1ScanAndCountNMethodClosure(NMethodClosure* cl) : _cl(cl), _count(0) {\n@@ -746,2 +746,2 @@\n-  void do_code_blob(CodeBlob* cb) override {\n-    _cl->do_code_blob(cb);\n+  void do_nmethod(nmethod* nm) override {\n+    _cl->do_nmethod(nm);\n@@ -823,1 +823,1 @@\n-      G1ScanAndCountCodeBlobClosure cl(_pss->closures()->weak_codeblobs());\n+      G1ScanAndCountNMethodClosure cl(_pss->closures()->weak_nmethods());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-class CodeBlobClosure;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-  CodeBlobClosure* strong_codeblobs()      { return &_closures._codeblobs; }\n-  CodeBlobClosure* weak_codeblobs()        { return &_closures._codeblobs; }\n+  NMethodClosure* strong_nmethods()   { return &_closures._nmethods; }\n+  NMethodClosure* weak_nmethods()     { return &_closures._nmethods; }\n@@ -68,2 +68,2 @@\n-  CodeBlobClosure* strong_codeblobs()      { return &_strong._codeblobs; }\n-  CodeBlobClosure* weak_codeblobs()        { return &_weak._codeblobs; }\n+  NMethodClosure* strong_nmethods()   { return &_strong._nmethods; }\n+  NMethodClosure* weak_nmethods()     { return &_weak._nmethods; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootClosures.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-  \/\/ Applied to code blobs reachable as strong roots.\n-  virtual CodeBlobClosure* strong_codeblobs() = 0;\n+  \/\/ Applied to nmethods reachable as strong roots.\n+  virtual NMethodClosure* strong_nmethods() = 0;\n@@ -49,2 +49,2 @@\n-  \/\/ Applied to code blobs treated as weak roots.\n-  virtual CodeBlobClosure* weak_codeblobs() = 0;\n+  \/\/ Applied to nmethods treated as weak roots.\n+  virtual NMethodClosure* weak_nmethods() = 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootClosures.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1CodeBlobClosure.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"gc\/g1\/g1NMethodClosure.hpp\"\n@@ -83,1 +83,1 @@\n-  CodeBlobClosure* _blobs;\n+  NMethodClosure* _nmethods;\n@@ -85,2 +85,2 @@\n-  StrongRootsClosures(OopClosure* roots, CLDClosure* clds, CodeBlobClosure* blobs) :\n-      _roots(roots), _clds(clds), _blobs(blobs) {}\n+  StrongRootsClosures(OopClosure* roots, CLDClosure* clds, NMethodClosure* nmethods) :\n+      _roots(roots), _clds(clds), _nmethods(nmethods) {}\n@@ -93,1 +93,1 @@\n-  CodeBlobClosure* strong_codeblobs() { return _blobs; }\n+  NMethodClosure* strong_nmethods() { return _nmethods; }\n@@ -98,2 +98,2 @@\n-                                           CodeBlobClosure* blobs) {\n-  StrongRootsClosures closures(oops, clds, blobs);\n+                                           NMethodClosure* nmethods) {\n+  StrongRootsClosures closures(oops, clds, nmethods);\n@@ -126,1 +126,1 @@\n-  \/\/ We don't want to visit code blobs more than once, so we return null for the\n+  \/\/ We don't want to visit nmethods more than once, so we return null for the\n@@ -128,1 +128,1 @@\n-  CodeBlobClosure* strong_codeblobs() { return nullptr; }\n+  NMethodClosure* strong_nmethods() { return nullptr; }\n@@ -133,1 +133,1 @@\n-                                        CodeBlobClosure* blobs) {\n+                                        NMethodClosure* nmethods) {\n@@ -139,1 +139,1 @@\n-  process_code_cache_roots(blobs, nullptr, 0);\n+  process_code_cache_roots(nmethods, nullptr, 0);\n@@ -152,1 +152,1 @@\n-  \/\/ the G1RootClosures::strong_codeblobs() closure on them. The closure\n+  \/\/ the G1RootClosures::strong_nmethods() closure on them. The closure\n@@ -162,1 +162,1 @@\n-  \/\/ G1CodeRootSet). G1 applies the G1RootClosures::weak_codeblobs() closure on\n+  \/\/ G1CodeRootSet). G1 applies the G1RootClosures::weak_nmethods() closure on\n@@ -182,1 +182,1 @@\n-                                       closures->strong_codeblobs());\n+                                       closures->strong_nmethods());\n@@ -203,1 +203,1 @@\n-void G1RootProcessor::process_code_cache_roots(CodeBlobClosure* code_closure,\n+void G1RootProcessor::process_code_cache_roots(NMethodClosure* nmethod_closure,\n@@ -210,1 +210,1 @@\n-    CodeCache::blobs_do(code_closure);\n+    CodeCache::nmethods_do(nmethod_closure);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-class CodeBlobClosure;\n@@ -71,1 +70,1 @@\n-  void process_code_cache_roots(CodeBlobClosure* code_closure,\n+  void process_code_cache_roots(NMethodClosure* nmethods_closure,\n@@ -86,1 +85,1 @@\n-                            CodeBlobClosure* blobs);\n+                            NMethodClosure* nmethods);\n@@ -91,1 +90,1 @@\n-                         CodeBlobClosure* blobs);\n+                         NMethodClosure* nmethods);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"gc\/g1\/g1CodeBlobClosure.hpp\"\n+#include \"gc\/g1\/g1NMethodClosure.hpp\"\n@@ -48,1 +48,1 @@\n-  G1CodeBlobClosure               _codeblobs;\n+  G1NMethodClosure                _nmethods;\n@@ -55,1 +55,1 @@\n-    _codeblobs(pss->worker_id(), &_oops_in_nmethod, should_mark) {}\n+    _nmethods(pss->worker_id(), &_oops_in_nmethod, should_mark) {}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SharedClosures.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-                                       notproduct,                          \\\n@@ -88,1 +87,0 @@\n-                                       notproduct,                          \\\n@@ -100,1 +98,0 @@\n-                    notproduct,                                             \\\n@@ -345,1 +342,0 @@\n-                    notproduct,                                             \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -136,4 +136,0 @@\n-size_t ParallelArguments::heap_max_size_bytes() {\n-  return MaxHeapSize;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  static size_t heap_max_size_bytes();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-                          notproduct,                                       \\\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallel_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -380,18 +380,0 @@\n-class VerifyObjectStartArrayClosure : public ObjectClosure {\n-  ObjectStartArray* _start_array;\n-\n-public:\n-  VerifyObjectStartArrayClosure(ObjectStartArray* start_array) :\n-    _start_array(start_array) { }\n-\n-  virtual void do_object(oop obj) {\n-    HeapWord* test_addr = cast_from_oop<HeapWord*>(obj) + 1;\n-    guarantee(_start_array->object_start(test_addr) == cast_from_oop<HeapWord*>(obj), \"ObjectStartArray cannot find start of object\");\n-  }\n-};\n-\n-void PSOldGen::verify_object_start_array() {\n-  VerifyObjectStartArrayClosure check(&_start_array);\n-  object_iterate(&check);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -152,1 +152,0 @@\n-  void verify_object_start_array();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -916,6 +916,0 @@\n-  \/\/ Verify object start arrays\n-  if (VerifyObjectStartArray &&\n-      VerifyBeforeGC) {\n-    heap->old_gen()->verify_object_start_array();\n-  }\n-\n@@ -1150,0 +1144,1 @@\n+    region_after_dense_prefix->set_partial_obj_addr(obj_beg);\n@@ -1416,1 +1411,1 @@\n-                              false \/* lock_codeblob_free_separately *\/);\n+                              false \/* lock_nmethod_free_separately *\/);\n@@ -1429,1 +1424,1 @@\n-    \/\/ adjust_roots() updates Universe::_intArrayKlassObj which is\n+    \/\/ adjust_roots() updates Universe::_intArrayKlass which is\n@@ -1537,6 +1532,0 @@\n-  \/\/ Re-verify object start arrays\n-  if (VerifyObjectStartArray &&\n-      VerifyAfterGC) {\n-    old_gen->verify_object_start_array();\n-  }\n-\n@@ -1574,1 +1563,1 @@\n-    MarkingCodeBlobClosure mark_and_push_in_blobs(&mark_and_push_closure, !CodeBlobToOopClosure::FixRelocations, true \/* keepalive nmethods *\/);\n+    MarkingNMethodClosure mark_and_push_in_blobs(&mark_and_push_closure, !NMethodToOopClosure::FixRelocations, true \/* keepalive nmethods *\/);\n@@ -1745,1 +1734,1 @@\n-      ctx->free_code_blobs();\n+      ctx->free_nmethods();\n@@ -1811,2 +1800,2 @@\n-      CodeBlobToOopClosure adjust_code(&adjust, CodeBlobToOopClosure::FixRelocations);\n-      CodeCache::blobs_do(&adjust_code);\n+      NMethodToOopClosure adjust_code(&adjust, NMethodToOopClosure::FixRelocations);\n+      CodeCache::nmethods_do(&adjust_code);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-        MarkingCodeBlobClosure code_closure(&roots_to_old_closure, CodeBlobToOopClosure::FixRelocations, false \/* keepalive nmethods *\/);\n+        MarkingNMethodClosure code_closure(&roots_to_old_closure, NMethodToOopClosure::FixRelocations, false \/* keepalive nmethods *\/);\n@@ -271,1 +271,1 @@\n-    MarkingCodeBlobClosure roots_in_blobs(&roots_closure, CodeBlobToOopClosure::FixRelocations, false \/* keepalive nmethods *\/);\n+    MarkingNMethodClosure roots_in_nmethods(&roots_closure, NMethodToOopClosure::FixRelocations, false \/* keepalive nmethods *\/);\n@@ -273,1 +273,1 @@\n-    thread->oops_do(&roots_closure, &roots_in_blobs);\n+    thread->oops_do(&roots_closure, &roots_in_nmethods);\n@@ -422,6 +422,0 @@\n-    \/\/ Verify the object start arrays.\n-    if (VerifyObjectStartArray &&\n-        VerifyBeforeGC) {\n-      old_gen->verify_object_start_array();\n-    }\n-\n@@ -637,6 +631,0 @@\n-    \/\/ Re-verify object start arrays\n-    if (VerifyObjectStartArray &&\n-        VerifyAfterGC) {\n-      old_gen->verify_object_start_array();\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-void CardTableRS::scan_old_to_young_refs(TenuredSpace* sp) {\n+void CardTableRS::scan_old_to_young_refs(TenuredSpace* sp, HeapWord* saved_mark_word) {\n@@ -36,1 +36,1 @@\n-  const MemRegion urasm = sp->used_region_at_save_marks();\n+  const MemRegion urasm = MemRegion(sp->bottom(), saved_mark_word);\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-  void scan_old_to_young_refs(TenuredSpace* sp);\n+  void scan_old_to_young_refs(TenuredSpace* sp, HeapWord* saved_mark_word);\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -647,1 +647,1 @@\n-  age_table()->print_age_table(_tenuring_threshold);\n+  age_table()->print_age_table();\n@@ -705,3 +705,3 @@\n-    MarkingCodeBlobClosure code_cl(&root_cl,\n-                                   CodeBlobToOopClosure::FixRelocations,\n-                                   false \/* keepalive_nmethods *\/);\n+    MarkingNMethodClosure code_cl(&root_cl,\n+                                  NMethodToOopClosure::FixRelocations,\n+                                  false \/* keepalive_nmethods *\/);\n@@ -904,3 +904,1 @@\n-  eden()->set_saved_mark();\n-  to()->set_saved_mark();\n-  from()->set_saved_mark();\n+  set_saved_mark_word();\n@@ -911,3 +909,1 @@\n-  assert(eden()->saved_mark_at_top(), \"Violated spec - alloc in eden\");\n-  assert(from()->saved_mark_at_top(), \"Violated spec - alloc in from\");\n-  return to()->saved_mark_at_top();\n+  return saved_mark_at_top();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -142,0 +142,3 @@\n+  \/\/ Saved mark word, for to-space\n+  HeapWord* _saved_mark_word;\n+\n@@ -171,0 +174,4 @@\n+  HeapWord* saved_mark_word()   const    { return _saved_mark_word; }\n+  void set_saved_mark_word()             { _saved_mark_word = to()->top(); }\n+  bool saved_mark_at_top()               { return _saved_mark_word == _to_space->top(); }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,5 +39,2 @@\n-  \/\/ No allocation in eden and from spaces, so no iteration required.\n-  assert(eden()->saved_mark_at_top(), \"inv\");\n-  assert(from()->saved_mark_at_top(), \"inv\");\n-\n-  to()->oop_since_save_marks_iterate(cl);\n+  Generation::oop_since_save_marks_iterate_impl(cl, to(), _saved_mark_word);\n+  set_saved_mark_word();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,544 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/stringTable.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"compiler\/oopMap.hpp\"\n-#include \"gc\/serial\/cardTableRS.hpp\"\n-#include \"gc\/serial\/defNewGeneration.hpp\"\n-#include \"gc\/serial\/generation.hpp\"\n-#include \"gc\/serial\/genMarkSweep.hpp\"\n-#include \"gc\/serial\/markSweep.inline.hpp\"\n-#include \"gc\/serial\/serialGcRefProcProxyTask.hpp\"\n-#include \"gc\/serial\/serialHeap.hpp\"\n-#include \"gc\/shared\/classUnloadingContext.hpp\"\n-#include \"gc\/shared\/collectedHeap.inline.hpp\"\n-#include \"gc\/shared\/gcHeapSummary.hpp\"\n-#include \"gc\/shared\/gcTimer.hpp\"\n-#include \"gc\/shared\/gcTrace.hpp\"\n-#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSet.hpp\"\n-#include \"gc\/shared\/preservedMarks.inline.hpp\"\n-#include \"gc\/shared\/referencePolicy.hpp\"\n-#include \"gc\/shared\/referenceProcessorPhaseTimes.hpp\"\n-#include \"gc\/shared\/space.inline.hpp\"\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n-#include \"gc\/shared\/weakProcessor.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/instanceRefKlass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"prims\/jvmtiExport.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/prefetch.inline.hpp\"\n-#include \"runtime\/synchronizer.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n-#include \"utilities\/copy.hpp\"\n-#include \"utilities\/events.hpp\"\n-#include \"utilities\/stack.inline.hpp\"\n-#if INCLUDE_JVMCI\n-#include \"jvmci\/jvmci.hpp\"\n-#endif\n-\n-class DeadSpacer : StackObj {\n-  size_t _allowed_deadspace_words;\n-  bool _active;\n-  ContiguousSpace* _space;\n-\n-public:\n-  DeadSpacer(ContiguousSpace* space) : _allowed_deadspace_words(0), _space(space) {\n-    size_t ratio = _space->allowed_dead_ratio();\n-    _active = ratio > 0;\n-\n-    if (_active) {\n-      \/\/ We allow some amount of garbage towards the bottom of the space, so\n-      \/\/ we don't start compacting before there is a significant gain to be made.\n-      \/\/ Occasionally, we want to ensure a full compaction, which is determined\n-      \/\/ by the MarkSweepAlwaysCompactCount parameter.\n-      if ((MarkSweep::total_invocations() % MarkSweepAlwaysCompactCount) != 0) {\n-        _allowed_deadspace_words = (space->capacity() * ratio \/ 100) \/ HeapWordSize;\n-      } else {\n-        _active = false;\n-      }\n-    }\n-  }\n-\n-  bool insert_deadspace(HeapWord* dead_start, HeapWord* dead_end) {\n-    if (!_active) {\n-      return false;\n-    }\n-\n-    size_t dead_length = pointer_delta(dead_end, dead_start);\n-    if (_allowed_deadspace_words >= dead_length) {\n-      _allowed_deadspace_words -= dead_length;\n-      CollectedHeap::fill_with_object(dead_start, dead_length);\n-      oop obj = cast_to_oop(dead_start);\n-      \/\/ obj->set_mark(obj->mark().set_marked());\n-\n-      assert(dead_length == obj->size(), \"bad filler object size\");\n-      log_develop_trace(gc, compaction)(\"Inserting object to dead space: \" PTR_FORMAT \", \" PTR_FORMAT \", \" SIZE_FORMAT \"b\",\n-                                        p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);\n-\n-      return true;\n-    } else {\n-      _active = false;\n-      return false;\n-    }\n-  }\n-};\n-\n-\/\/ Implement the \"compaction\" part of the mark-compact GC algorithm.\n-class Compacter {\n-  \/\/ There are four spaces in total, but only the first three can be used after\n-  \/\/ compact. IOW, old and eden\/from must be enough for all live objs\n-  static constexpr uint max_num_spaces = 4;\n-\n-  struct CompactionSpace {\n-    ContiguousSpace* _space;\n-    \/\/ Will be the new top after compaction is complete.\n-    HeapWord* _compaction_top;\n-    \/\/ The first dead word in this contiguous space. It's an optimization to\n-    \/\/ skip large chunk of live objects at the beginning.\n-    HeapWord* _first_dead;\n-\n-    void init(ContiguousSpace* space) {\n-      _space = space;\n-      _compaction_top = space->bottom();\n-      _first_dead = nullptr;\n-    }\n-  };\n-\n-  CompactionSpace _spaces[max_num_spaces];\n-  \/\/ The num of spaces to be compacted, i.e. containing live objs.\n-  uint _num_spaces;\n-\n-  uint _index;\n-\n-  HeapWord* get_compaction_top(uint index) const {\n-    return _spaces[index]._compaction_top;\n-  }\n-\n-  HeapWord* get_first_dead(uint index) const {\n-    return _spaces[index]._first_dead;\n-  }\n-\n-  ContiguousSpace* get_space(uint index) const {\n-    return _spaces[index]._space;\n-  }\n-\n-  void record_first_dead(uint index, HeapWord* first_dead) {\n-    assert(_spaces[index]._first_dead == nullptr, \"should write only once\");\n-    _spaces[index]._first_dead = first_dead;\n-  }\n-\n-  HeapWord* alloc(size_t words) {\n-    while (true) {\n-      if (words <= pointer_delta(_spaces[_index]._space->end(),\n-                                 _spaces[_index]._compaction_top)) {\n-        HeapWord* result = _spaces[_index]._compaction_top;\n-        _spaces[_index]._compaction_top += words;\n-        if (_index == 0) {\n-          \/\/ old-gen requires BOT update\n-          static_cast<TenuredSpace*>(_spaces[0]._space)->update_for_block(result, result + words);\n-        }\n-        return result;\n-      }\n-\n-      \/\/ out-of-memory in this space\n-      _index++;\n-      assert(_index < max_num_spaces - 1, \"the last space should not be used\");\n-    }\n-  }\n-\n-  static void prefetch_read_scan(void* p) {\n-    if (PrefetchScanIntervalInBytes >= 0) {\n-      Prefetch::read(p, PrefetchScanIntervalInBytes);\n-    }\n-  }\n-\n-  static void prefetch_write_scan(void* p) {\n-    if (PrefetchScanIntervalInBytes >= 0) {\n-      Prefetch::write(p, PrefetchScanIntervalInBytes);\n-    }\n-  }\n-\n-  static void prefetch_write_copy(void* p) {\n-    if (PrefetchCopyIntervalInBytes >= 0) {\n-      Prefetch::write(p, PrefetchCopyIntervalInBytes);\n-    }\n-  }\n-\n-  static void forward_obj(oop obj, HeapWord* new_addr) {\n-    prefetch_write_scan(obj);\n-    if (cast_from_oop<HeapWord*>(obj) != new_addr) {\n-      obj->forward_to(cast_to_oop(new_addr));\n-    } else {\n-      assert(obj->is_gc_marked(), \"inv\");\n-      \/\/ This obj will stay in-place. Fix the markword.\n-      obj->init_mark();\n-    }\n-  }\n-\n-  static HeapWord* find_next_live_addr(HeapWord* start, HeapWord* end) {\n-    for (HeapWord* i_addr = start; i_addr < end; \/* empty *\/) {\n-      prefetch_read_scan(i_addr);\n-      oop obj = cast_to_oop(i_addr);\n-      if (obj->is_gc_marked()) {\n-        return i_addr;\n-      }\n-      i_addr += obj->size();\n-    }\n-    return end;\n-  };\n-\n-  static size_t relocate(HeapWord* addr) {\n-    \/\/ Prefetch source and destination\n-    prefetch_read_scan(addr);\n-\n-    oop obj = cast_to_oop(addr);\n-    oop new_obj = obj->forwardee();\n-    HeapWord* new_addr = cast_from_oop<HeapWord*>(new_obj);\n-    assert(addr != new_addr, \"inv\");\n-    prefetch_write_copy(new_addr);\n-\n-    size_t obj_size = obj->size();\n-    Copy::aligned_conjoint_words(addr, new_addr, obj_size);\n-    new_obj->init_mark();\n-\n-    return obj_size;\n-  }\n-\n-public:\n-  explicit Compacter(SerialHeap* heap) {\n-    \/\/ In this order so that heap is compacted towards old-gen.\n-    _spaces[0].init(heap->old_gen()->space());\n-    _spaces[1].init(heap->young_gen()->eden());\n-    _spaces[2].init(heap->young_gen()->from());\n-\n-    bool is_promotion_failed = (heap->young_gen()->from()->next_compaction_space() != nullptr);\n-    if (is_promotion_failed) {\n-      _spaces[3].init(heap->young_gen()->to());\n-      _num_spaces = 4;\n-    } else {\n-      _num_spaces = 3;\n-    }\n-    _index = 0;\n-  }\n-\n-  void phase2_calculate_new_addr() {\n-    for (uint i = 0; i < _num_spaces; ++i) {\n-      ContiguousSpace* space = get_space(i);\n-      HeapWord* cur_addr = space->bottom();\n-      HeapWord* top = space->top();\n-\n-      bool record_first_dead_done = false;\n-\n-      DeadSpacer dead_spacer(space);\n-\n-      while (cur_addr < top) {\n-        oop obj = cast_to_oop(cur_addr);\n-        size_t obj_size = obj->size();\n-        if (obj->is_gc_marked()) {\n-          HeapWord* new_addr = alloc(obj_size);\n-          forward_obj(obj, new_addr);\n-          cur_addr += obj_size;\n-        } else {\n-          \/\/ Skipping the current known-unmarked obj\n-          HeapWord* next_live_addr = find_next_live_addr(cur_addr + obj_size, top);\n-          if (dead_spacer.insert_deadspace(cur_addr, next_live_addr)) {\n-            \/\/ Register space for the filler obj\n-            alloc(pointer_delta(next_live_addr, cur_addr));\n-          } else {\n-            if (!record_first_dead_done) {\n-              record_first_dead(i, cur_addr);\n-              record_first_dead_done = true;\n-            }\n-            *(HeapWord**)cur_addr = next_live_addr;\n-          }\n-          cur_addr = next_live_addr;\n-        }\n-      }\n-\n-      if (!record_first_dead_done) {\n-        record_first_dead(i, top);\n-      }\n-    }\n-  }\n-\n-  void phase3_adjust_pointers() {\n-    for (uint i = 0; i < _num_spaces; ++i) {\n-      ContiguousSpace* space = get_space(i);\n-      HeapWord* cur_addr = space->bottom();\n-      HeapWord* const top = space->top();\n-      HeapWord* const first_dead = get_first_dead(i);\n-\n-      while (cur_addr < top) {\n-        prefetch_write_scan(cur_addr);\n-        if (cur_addr < first_dead || cast_to_oop(cur_addr)->is_gc_marked()) {\n-          size_t size = MarkSweep::adjust_pointers(cast_to_oop(cur_addr));\n-          cur_addr += size;\n-        } else {\n-          assert(*(HeapWord**)cur_addr > cur_addr, \"forward progress\");\n-          cur_addr = *(HeapWord**)cur_addr;\n-        }\n-      }\n-    }\n-  }\n-\n-  void phase4_compact() {\n-    for (uint i = 0; i < _num_spaces; ++i) {\n-      ContiguousSpace* space = get_space(i);\n-      HeapWord* cur_addr = space->bottom();\n-      HeapWord* top = space->top();\n-\n-      \/\/ Check if the first obj inside this space is forwarded.\n-      if (!cast_to_oop(cur_addr)->is_forwarded()) {\n-        \/\/ Jump over consecutive (in-place) live-objs-chunk\n-        cur_addr = get_first_dead(i);\n-      }\n-\n-      while (cur_addr < top) {\n-        if (!cast_to_oop(cur_addr)->is_forwarded()) {\n-          cur_addr = *(HeapWord**) cur_addr;\n-          continue;\n-        }\n-        cur_addr += relocate(cur_addr);\n-      }\n-\n-      \/\/ Reset top and unused memory\n-      space->set_top(get_compaction_top(i));\n-      if (ZapUnusedHeapArea) {\n-        space->mangle_unused_area();\n-      }\n-    }\n-  }\n-};\n-\n-void GenMarkSweep::phase1_mark(bool clear_all_softrefs) {\n-  \/\/ Recursively traverse all live objects and mark them\n-  GCTraceTime(Info, gc, phases) tm(\"Phase 1: Mark live objects\", _gc_timer);\n-\n-  SerialHeap* gch = SerialHeap::heap();\n-\n-  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_mark);\n-\n-  ref_processor()->start_discovery(clear_all_softrefs);\n-\n-  {\n-    StrongRootsScope srs(0);\n-\n-    CLDClosure* weak_cld_closure = ClassUnloading ? nullptr : &follow_cld_closure;\n-    MarkingCodeBlobClosure mark_code_closure(&follow_root_closure, !CodeBlobToOopClosure::FixRelocations, true);\n-    gch->process_roots(SerialHeap::SO_None,\n-                       &follow_root_closure,\n-                       &follow_cld_closure,\n-                       weak_cld_closure,\n-                       &mark_code_closure);\n-  }\n-\n-  \/\/ Process reference objects found during marking\n-  {\n-    GCTraceTime(Debug, gc, phases) tm_m(\"Reference Processing\", gc_timer());\n-\n-    ReferenceProcessorPhaseTimes pt(_gc_timer, ref_processor()->max_num_queues());\n-    SerialGCRefProcProxyTask task(is_alive, keep_alive, follow_stack_closure);\n-    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(task, pt);\n-    pt.print_all_references();\n-    gc_tracer()->report_gc_reference_stats(stats);\n-  }\n-\n-  \/\/ This is the point where the entire marking should have completed.\n-  assert(_marking_stack.is_empty(), \"Marking should have completed\");\n-\n-  {\n-    GCTraceTime(Debug, gc, phases) tm_m(\"Weak Processing\", gc_timer());\n-    WeakProcessor::weak_oops_do(&is_alive, &do_nothing_cl);\n-  }\n-\n-  {\n-    GCTraceTime(Debug, gc, phases) tm_m(\"Class Unloading\", gc_timer());\n-\n-    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n-\n-    bool unloading_occurred;\n-    {\n-      CodeCache::UnlinkingScope scope(&is_alive);\n-\n-      \/\/ Unload classes and purge the SystemDictionary.\n-      unloading_occurred = SystemDictionary::do_unloading(gc_timer());\n-\n-      \/\/ Unload nmethods.\n-      CodeCache::do_unloading(unloading_occurred);\n-    }\n-\n-    {\n-      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n-      \/\/ Release unloaded nmethod's memory.\n-      ctx->purge_nmethods();\n-    }\n-    {\n-      GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", gc_timer());\n-      gch->prune_unlinked_nmethods();\n-    }\n-    {\n-      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n-      ctx->free_code_blobs();\n-    }\n-\n-    \/\/ Prune dead klasses from subklass\/sibling\/implementor lists.\n-    Klass::clean_weak_klass_links(unloading_occurred);\n-\n-    \/\/ Clean JVMCI metadata handles.\n-    JVMCI_ONLY(JVMCI::do_unloading(unloading_occurred));\n-  }\n-\n-  {\n-    GCTraceTime(Debug, gc, phases) tm_m(\"Report Object Count\", gc_timer());\n-    gc_tracer()->report_object_count_after_gc(&is_alive, nullptr);\n-  }\n-}\n-\n-void GenMarkSweep::invoke_at_safepoint(bool clear_all_softrefs) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n-\n-  SerialHeap* gch = SerialHeap::heap();\n-#ifdef ASSERT\n-  if (gch->soft_ref_policy()->should_clear_all_soft_refs()) {\n-    assert(clear_all_softrefs, \"Policy should have been checked earlier\");\n-  }\n-#endif\n-\n-  gch->trace_heap_before_gc(_gc_tracer);\n-\n-  \/\/ Increment the invocation count\n-  _total_invocations++;\n-\n-  \/\/ Capture used regions for old-gen to reestablish old-to-young invariant\n-  \/\/ after full-gc.\n-  gch->old_gen()->save_used_region();\n-\n-  allocate_stacks();\n-\n-  phase1_mark(clear_all_softrefs);\n-\n-  Compacter compacter{gch};\n-\n-  {\n-    \/\/ Now all live objects are marked, compute the new object addresses.\n-    GCTraceTime(Info, gc, phases) tm(\"Phase 2: Compute new object addresses\", _gc_timer);\n-\n-    compacter.phase2_calculate_new_addr();\n-  }\n-\n-  \/\/ Don't add any more derived pointers during phase3\n-#if COMPILER2_OR_JVMCI\n-  assert(DerivedPointerTable::is_active(), \"Sanity\");\n-  DerivedPointerTable::set_active(false);\n-#endif\n-\n-  {\n-    \/\/ Adjust the pointers to reflect the new locations\n-    GCTraceTime(Info, gc, phases) tm(\"Phase 3: Adjust pointers\", gc_timer());\n-\n-    ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_adjust);\n-\n-    CodeBlobToOopClosure code_closure(&adjust_pointer_closure, CodeBlobToOopClosure::FixRelocations);\n-    gch->process_roots(SerialHeap::SO_AllCodeCache,\n-                       &adjust_pointer_closure,\n-                       &adjust_cld_closure,\n-                       &adjust_cld_closure,\n-                       &code_closure);\n-\n-    WeakProcessor::oops_do(&adjust_pointer_closure);\n-\n-    adjust_marks();\n-    compacter.phase3_adjust_pointers();\n-  }\n-\n-  {\n-    \/\/ All pointers are now adjusted, move objects accordingly\n-    GCTraceTime(Info, gc, phases) tm(\"Phase 4: Move objects\", _gc_timer);\n-\n-    compacter.phase4_compact();\n-  }\n-\n-  restore_marks();\n-\n-  \/\/ Set saved marks for allocation profiler (and other things? -- dld)\n-  \/\/ (Should this be in general part?)\n-  gch->save_marks();\n-\n-  deallocate_stacks();\n-\n-  MarkSweep::_string_dedup_requests->flush();\n-\n-  bool is_young_gen_empty = (gch->young_gen()->used() == 0);\n-  gch->rem_set()->maintain_old_to_young_invariant(gch->old_gen(), is_young_gen_empty);\n-\n-  gch->prune_scavengable_nmethods();\n-\n-  \/\/ Update heap occupancy information which is used as\n-  \/\/ input to soft ref clearing policy at the next gc.\n-  Universe::heap()->update_capacity_and_used_at_gc();\n-\n-  \/\/ Signal that we have completed a visit to all live objects.\n-  Universe::heap()->record_whole_heap_examined_timestamp();\n-\n-  gch->trace_heap_after_gc(_gc_tracer);\n-}\n-\n-void GenMarkSweep::allocate_stacks() {\n-  void* scratch = nullptr;\n-  size_t num_words;\n-  DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n-  young_gen->contribute_scratch(scratch, num_words);\n-\n-  if (scratch != nullptr) {\n-    _preserved_count_max = num_words * HeapWordSize \/ sizeof(PreservedMark);\n-  } else {\n-    _preserved_count_max = 0;\n-  }\n-\n-  _preserved_marks = (PreservedMark*)scratch;\n-  _preserved_count = 0;\n-\n-  _preserved_overflow_stack_set.init(1);\n-}\n-\n-void GenMarkSweep::deallocate_stacks() {\n-  if (_preserved_count_max != 0) {\n-    DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n-    young_gen->reset_scratch();\n-  }\n-\n-  _preserved_overflow_stack_set.reclaim();\n-  _marking_stack.clear();\n-  _objarray_stack.clear(true);\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":0,"deletions":544,"binary":false,"changes":544,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SERIAL_GENMARKSWEEP_HPP\n-#define SHARE_GC_SERIAL_GENMARKSWEEP_HPP\n-\n-#include \"gc\/serial\/markSweep.hpp\"\n-\n-class GenMarkSweep : public MarkSweep {\n- public:\n-  static void invoke_at_safepoint(bool clear_all_softrefs);\n-\n- private:\n-  \/\/ Mark live objects\n-  static void phase1_mark(bool clear_all_softrefs);\n-\n-  \/\/ Temporary data structures for traversal and storing\/restoring marks\n-  static void allocate_stacks();\n-  static void deallocate_stacks();\n-};\n-\n-#endif \/\/ SHARE_GC_SERIAL_GENMARKSWEEP_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.hpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/space.inline.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"runtime\/prefetch.inline.hpp\"\n@@ -44,1 +46,1 @@\n-\/\/ - TenuredGeneration             - tenured (old object) space (markSweepCompact)\n+\/\/ - TenuredGeneration             - tenured (old object) space (mark-compact)\n@@ -202,0 +204,8 @@\n+  \/\/ Apply \"blk->do_oop\" to the addresses of all reference fields in objects\n+  \/\/ starting with the _saved_mark_word, which was noted during a generation's\n+  \/\/ save_marks and is required to denote the head of an object.\n+  \/\/ Fields in objects allocated by applications of the closure\n+  \/\/ *are* included in the iteration.\n+  \/\/ Updates saved_mark_word to point to just after the last object iterated over.\n+  template <typename OopClosureType>\n+  void oop_since_save_marks_iterate_impl(OopClosureType* blk, ContiguousSpace* space, HeapWord* saved_mark_word);\n@@ -204,0 +214,17 @@\n+template <typename OopClosureType>\n+void Generation::oop_since_save_marks_iterate_impl(OopClosureType* blk, ContiguousSpace* space, HeapWord* saved_mark_word) {\n+  HeapWord* t;\n+  HeapWord* p = saved_mark_word;\n+  assert(p != nullptr, \"expected saved mark\");\n+\n+  const intx interval = PrefetchScanIntervalInBytes;\n+  do {\n+    t = space->top();\n+    while (p < t) {\n+      Prefetch::write(p, interval);\n+      oop m = cast_to_oop(p);\n+      p += m->oop_iterate_size(blk);\n+    }\n+  } while (t < space->top());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,237 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"compiler\/compileBroker.hpp\"\n-#include \"gc\/serial\/markSweep.inline.hpp\"\n-#include \"gc\/shared\/collectedHeap.inline.hpp\"\n-#include \"gc\/shared\/gcTimer.hpp\"\n-#include \"gc\/shared\/gcTrace.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"memory\/iterator.inline.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/compressedOops.inline.hpp\"\n-#include \"oops\/methodData.hpp\"\n-#include \"oops\/objArrayKlass.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"oops\/typeArrayOop.inline.hpp\"\n-#include \"utilities\/stack.inline.hpp\"\n-\n-uint                    MarkSweep::_total_invocations = 0;\n-\n-Stack<oop, mtGC>              MarkSweep::_marking_stack;\n-Stack<ObjArrayTask, mtGC>     MarkSweep::_objarray_stack;\n-\n-PreservedMarksSet       MarkSweep::_preserved_overflow_stack_set(false \/* in_c_heap *\/);\n-size_t                  MarkSweep::_preserved_count = 0;\n-size_t                  MarkSweep::_preserved_count_max = 0;\n-PreservedMark*          MarkSweep::_preserved_marks = nullptr;\n-STWGCTimer*             MarkSweep::_gc_timer        = nullptr;\n-SerialOldTracer*        MarkSweep::_gc_tracer       = nullptr;\n-\n-AlwaysTrueClosure   MarkSweep::_always_true_closure;\n-ReferenceProcessor* MarkSweep::_ref_processor;\n-\n-StringDedup::Requests*  MarkSweep::_string_dedup_requests = nullptr;\n-\n-MarkSweep::FollowRootClosure  MarkSweep::follow_root_closure;\n-\n-MarkAndPushClosure MarkSweep::mark_and_push_closure(ClassLoaderData::_claim_stw_fullgc_mark);\n-CLDToOopClosure    MarkSweep::follow_cld_closure(&mark_and_push_closure, ClassLoaderData::_claim_stw_fullgc_mark);\n-CLDToOopClosure    MarkSweep::adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_stw_fullgc_adjust);\n-\n-template <class T> void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {\n-  mark_and_push(p);\n-}\n-\n-void MarkSweep::push_objarray(oop obj, size_t index) {\n-  ObjArrayTask task(obj, index);\n-  assert(task.is_valid(), \"bad ObjArrayTask\");\n-  _objarray_stack.push(task);\n-}\n-\n-void MarkSweep::follow_array(objArrayOop array) {\n-  mark_and_push_closure.do_klass(array->klass());\n-  \/\/ Don't push empty arrays to avoid unnecessary work.\n-  if (array->length() > 0) {\n-    MarkSweep::push_objarray(array, 0);\n-  }\n-}\n-\n-void MarkSweep::follow_object(oop obj) {\n-  assert(obj->is_gc_marked(), \"should be marked\");\n-  if (obj->is_objArray()) {\n-    \/\/ Handle object arrays explicitly to allow them to\n-    \/\/ be split into chunks if needed.\n-    MarkSweep::follow_array((objArrayOop)obj);\n-  } else {\n-    obj->oop_iterate(&mark_and_push_closure);\n-  }\n-}\n-\n-void MarkSweep::follow_array_chunk(objArrayOop array, int index) {\n-  const int len = array->length();\n-  const int beg_index = index;\n-  assert(beg_index < len || len == 0, \"index too large\");\n-\n-  const int stride = MIN2(len - beg_index, (int) ObjArrayMarkingStride);\n-  const int end_index = beg_index + stride;\n-\n-  array->oop_iterate_range(&mark_and_push_closure, beg_index, end_index);\n-\n-  if (end_index < len) {\n-    MarkSweep::push_objarray(array, end_index); \/\/ Push the continuation.\n-  }\n-}\n-\n-void MarkSweep::follow_stack() {\n-  do {\n-    while (!_marking_stack.is_empty()) {\n-      oop obj = _marking_stack.pop();\n-      assert (obj->is_gc_marked(), \"p must be marked\");\n-      follow_object(obj);\n-    }\n-    \/\/ Process ObjArrays one at a time to avoid marking stack bloat.\n-    if (!_objarray_stack.is_empty()) {\n-      ObjArrayTask task = _objarray_stack.pop();\n-      follow_array_chunk(objArrayOop(task.obj()), task.index());\n-    }\n-  } while (!_marking_stack.is_empty() || !_objarray_stack.is_empty());\n-}\n-\n-MarkSweep::FollowStackClosure MarkSweep::follow_stack_closure;\n-\n-void MarkSweep::FollowStackClosure::do_void() { follow_stack(); }\n-\n-template <class T> void MarkSweep::follow_root(T* p) {\n-  assert(!Universe::heap()->is_in(p),\n-         \"roots shouldn't be things within the heap\");\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    if (!obj->mark().is_marked()) {\n-      mark_object(obj);\n-      follow_object(obj);\n-    }\n-  }\n-  follow_stack();\n-}\n-\n-void MarkSweep::FollowRootClosure::do_oop(oop* p)       { follow_root(p); }\n-void MarkSweep::FollowRootClosure::do_oop(narrowOop* p) { follow_root(p); }\n-\n-\/\/ We preserve the mark which should be replaced at the end and the location\n-\/\/ that it will go.  Note that the object that this markWord belongs to isn't\n-\/\/ currently at that address but it will be after phase4\n-void MarkSweep::preserve_mark(oop obj, markWord mark) {\n-  \/\/ We try to store preserved marks in the to space of the new generation since\n-  \/\/ this is storage which should be available.  Most of the time this should be\n-  \/\/ sufficient space for the marks we need to preserve but if it isn't we fall\n-  \/\/ back to using Stacks to keep track of the overflow.\n-  if (_preserved_count < _preserved_count_max) {\n-    _preserved_marks[_preserved_count++] = PreservedMark(obj, mark);\n-  } else {\n-    _preserved_overflow_stack_set.get()->push_always(obj, mark);\n-  }\n-}\n-\n-void MarkSweep::mark_object(oop obj) {\n-  if (StringDedup::is_enabled() &&\n-      java_lang_String::is_instance(obj) &&\n-      SerialStringDedup::is_candidate_from_mark(obj)) {\n-    _string_dedup_requests->add(obj);\n-  }\n-\n-  \/\/ some marks may contain information we need to preserve so we store them away\n-  \/\/ and overwrite the mark.  We'll restore it at the end of markSweep.\n-  markWord mark = obj->mark();\n-  obj->set_mark(markWord::prototype().set_marked());\n-\n-  ContinuationGCSupport::transform_stack_chunk(obj);\n-\n-  if (obj->mark_must_be_preserved(mark)) {\n-    preserve_mark(obj, mark);\n-  }\n-}\n-\n-template <class T> void MarkSweep::mark_and_push(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    if (!obj->mark().is_marked()) {\n-      mark_object(obj);\n-      _marking_stack.push(obj);\n-    }\n-  }\n-}\n-\n-template <typename T>\n-void MarkAndPushClosure::do_oop_work(T* p)            { MarkSweep::mark_and_push(p); }\n-void MarkAndPushClosure::do_oop(      oop* p)         { do_oop_work(p); }\n-void MarkAndPushClosure::do_oop(narrowOop* p)         { do_oop_work(p); }\n-\n-AdjustPointerClosure MarkSweep::adjust_pointer_closure;\n-\n-void MarkSweep::adjust_marks() {\n-  \/\/ adjust the oops we saved earlier\n-  for (size_t i = 0; i < _preserved_count; i++) {\n-    PreservedMarks::adjust_preserved_mark(_preserved_marks + i);\n-  }\n-\n-  \/\/ deal with the overflow stack\n-  _preserved_overflow_stack_set.get()->adjust_during_full_gc();\n-}\n-\n-void MarkSweep::restore_marks() {\n-  log_trace(gc)(\"Restoring \" SIZE_FORMAT \" marks\", _preserved_count + _preserved_overflow_stack_set.get()->size());\n-\n-  \/\/ restore the marks we saved earlier\n-  for (size_t i = 0; i < _preserved_count; i++) {\n-    _preserved_marks[i].set_mark();\n-  }\n-\n-  \/\/ deal with the overflow\n-  _preserved_overflow_stack_set.restore(nullptr);\n-}\n-\n-MarkSweep::IsAliveClosure   MarkSweep::is_alive;\n-\n-bool MarkSweep::IsAliveClosure::do_object_b(oop p) { return p->is_gc_marked(); }\n-\n-MarkSweep::KeepAliveClosure MarkSweep::keep_alive;\n-\n-void MarkSweep::KeepAliveClosure::do_oop(oop* p)       { MarkSweep::KeepAliveClosure::do_oop_work(p); }\n-void MarkSweep::KeepAliveClosure::do_oop(narrowOop* p) { MarkSweep::KeepAliveClosure::do_oop_work(p); }\n-\n-void MarkSweep::initialize() {\n-  MarkSweep::_gc_timer = new STWGCTimer();\n-  MarkSweep::_gc_tracer = new SerialOldTracer();\n-  MarkSweep::_string_dedup_requests = new StringDedup::Requests();\n-\n-  \/\/ The Full GC operates on the entire heap so all objects should be subject\n-  \/\/ to discovery, hence the _always_true_closure.\n-  MarkSweep::_ref_processor = new ReferenceProcessor(&_always_true_closure);\n-  mark_and_push_closure.set_ref_discoverer(_ref_processor);\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":0,"deletions":237,"binary":false,"changes":237,"status":"deleted"},{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SERIAL_MARKSWEEP_HPP\n-#define SHARE_GC_SERIAL_MARKSWEEP_HPP\n-\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"gc\/shared\/preservedMarks.inline.hpp\"\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n-#include \"gc\/shared\/taskqueue.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/oop.hpp\"\n-#include \"runtime\/timer.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/stack.hpp\"\n-\n-class DataLayout;\n-class SerialOldTracer;\n-class STWGCTimer;\n-\n-\/\/ MarkSweep takes care of global mark-compact garbage collection for a\n-\/\/ SerialHeap using a four-phase pointer forwarding algorithm.  All\n-\/\/ generations are assumed to support marking; those that can also support\n-\/\/ compaction.\n-\/\/\n-\/\/ Class unloading will only occur when a full gc is invoked.\n-\n-\/\/ declared at end\n-class PreservedMark;\n-class MarkAndPushClosure;\n-class AdjustPointerClosure;\n-\n-class MarkSweep : AllStatic {\n-  \/\/\n-  \/\/ Inline closure decls\n-  \/\/\n-  class FollowRootClosure: public BasicOopIterateClosure {\n-   public:\n-    virtual void do_oop(oop* p);\n-    virtual void do_oop(narrowOop* p);\n-  };\n-\n-  class FollowStackClosure: public VoidClosure {\n-   public:\n-    virtual void do_void();\n-  };\n-\n-  \/\/ Used for java\/lang\/ref handling\n-  class IsAliveClosure: public BoolObjectClosure {\n-   public:\n-    virtual bool do_object_b(oop p);\n-  };\n-\n-  class KeepAliveClosure: public OopClosure {\n-   protected:\n-    template <class T> void do_oop_work(T* p);\n-   public:\n-    virtual void do_oop(oop* p);\n-    virtual void do_oop(narrowOop* p);\n-  };\n-\n-  \/\/\n-  \/\/ Friend decls\n-  \/\/\n-  friend class AdjustPointerClosure;\n-  friend class KeepAliveClosure;\n-\n-  \/\/\n-  \/\/ Vars\n-  \/\/\n- protected:\n-  \/\/ Total invocations of a MarkSweep collection\n-  static uint _total_invocations;\n-\n-  \/\/ Traversal stacks used during phase1\n-  static Stack<oop, mtGC>                      _marking_stack;\n-  static Stack<ObjArrayTask, mtGC>             _objarray_stack;\n-\n-  \/\/ Space for storing\/restoring mark word\n-  static PreservedMarksSet               _preserved_overflow_stack_set;\n-  static size_t                          _preserved_count;\n-  static size_t                          _preserved_count_max;\n-  static PreservedMark*                  _preserved_marks;\n-\n-  static AlwaysTrueClosure               _always_true_closure;\n-  static ReferenceProcessor*             _ref_processor;\n-\n-  static STWGCTimer*                     _gc_timer;\n-  static SerialOldTracer*                _gc_tracer;\n-\n-  static StringDedup::Requests* _string_dedup_requests;\n-\n-  \/\/ Non public closures\n-  static KeepAliveClosure keep_alive;\n-\n- public:\n-  static void initialize();\n-\n-  \/\/ Public closures\n-  static IsAliveClosure       is_alive;\n-  static FollowRootClosure    follow_root_closure;\n-  static MarkAndPushClosure   mark_and_push_closure;\n-  static FollowStackClosure   follow_stack_closure;\n-  static CLDToOopClosure      follow_cld_closure;\n-  static AdjustPointerClosure adjust_pointer_closure;\n-  static CLDToOopClosure      adjust_cld_closure;\n-\n-  \/\/ Accessors\n-  static uint total_invocations() { return _total_invocations; }\n-\n-  \/\/ Reference Processing\n-  static ReferenceProcessor* ref_processor() { return _ref_processor; }\n-\n-  static STWGCTimer* gc_timer() { return _gc_timer; }\n-  static SerialOldTracer* gc_tracer() { return _gc_tracer; }\n-\n-  static void preserve_mark(oop p, markWord mark);\n-                                \/\/ Save the mark word so it can be restored later\n-  static void adjust_marks();   \/\/ Adjust the pointers in the preserved marks table\n-  static void restore_marks();  \/\/ Restore the marks that we saved in preserve_mark\n-\n-  static size_t adjust_pointers(oop obj);\n-\n-  static void follow_stack();   \/\/ Empty marking stack.\n-\n-  template <class T> static inline void adjust_pointer(T* p);\n-\n-  \/\/ Check mark and maybe push on marking stack\n-  template <class T> static void mark_and_push(T* p);\n-\n- private:\n-  \/\/ Call backs for marking\n-  static void mark_object(oop obj);\n-  \/\/ Mark pointer and follow contents.  Empty marking stack afterwards.\n-  template <class T> static inline void follow_root(T* p);\n-\n-  static inline void push_objarray(oop obj, size_t index);\n-\n-  static void follow_object(oop obj);\n-\n-  static void follow_array(objArrayOop array);\n-\n-  static void follow_array_chunk(objArrayOop array, int index);\n-};\n-\n-class MarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n-public:\n-  MarkAndPushClosure(int claim) : ClaimMetadataVisitingOopIterateClosure(claim) {}\n-\n-  template <typename T> void do_oop_work(T* p);\n-  virtual void do_oop(      oop* p);\n-  virtual void do_oop(narrowOop* p);\n-\n-  void set_ref_discoverer(ReferenceDiscoverer* rd) {\n-    set_ref_discoverer_internal(rd);\n-  }\n-};\n-\n-class AdjustPointerClosure: public BasicOopIterateClosure {\n- public:\n-  template <typename T> void do_oop_work(T* p);\n-  virtual void do_oop(oop* p);\n-  virtual void do_oop(narrowOop* p);\n-  virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }\n-};\n-\n-#endif \/\/ SHARE_GC_SERIAL_MARKSWEEP_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SERIAL_MARKSWEEP_INLINE_HPP\n-#define SHARE_GC_SERIAL_MARKSWEEP_INLINE_HPP\n-\n-#include \"gc\/serial\/markSweep.hpp\"\n-\n-#include \"classfile\/classLoaderData.inline.hpp\"\n-#include \"classfile\/javaClasses.inline.hpp\"\n-#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n-#include \"gc\/serial\/serialStringDedup.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/compressedOops.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/stack.inline.hpp\"\n-\n-template <class T> inline void MarkSweep::adjust_pointer(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    assert(Universe::heap()->is_in(obj), \"should be in heap\");\n-\n-    if (obj->is_forwarded()) {\n-      oop new_obj = obj->forwardee();\n-      assert(is_object_aligned(new_obj), \"oop must be aligned\");\n-      RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n-    }\n-  }\n-}\n-\n-template <typename T>\n-void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(p); }\n-inline void AdjustPointerClosure::do_oop(oop* p)       { do_oop_work(p); }\n-inline void AdjustPointerClosure::do_oop(narrowOop* p) { do_oop_work(p); }\n-\n-inline size_t MarkSweep::adjust_pointers(oop obj) {\n-  return obj->oop_iterate_size(&MarkSweep::adjust_pointer_closure);\n-}\n-\n-#endif \/\/ SHARE_GC_SERIAL_MARKSWEEP_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -36,2 +36,2 @@\n-SerialBlockOffsetSharedArray::SerialBlockOffsetSharedArray(MemRegion reserved,\n-                                                           size_t init_word_size):\n+SerialBlockOffsetTable::SerialBlockOffsetTable(MemRegion reserved,\n+                                               size_t init_word_size):\n@@ -52,1 +52,1 @@\n-  log_trace(gc, bot)(\"SerialBlockOffsetSharedArray::SerialBlockOffsetSharedArray: \");\n+  log_trace(gc, bot)(\"SerialBlockOffsetTable::SerialBlockOffsetTable: \");\n@@ -59,1 +59,1 @@\n-void SerialBlockOffsetSharedArray::resize(size_t new_word_size) {\n+void SerialBlockOffsetTable::resize(size_t new_word_size) {\n@@ -80,0 +80,5 @@\n+static void fill_range(uint8_t* start, uint8_t* end, uint8_t value) {\n+  \/\/ + 1 for inclusive.\n+  memset(start, value, pointer_delta(end, start, sizeof(uint8_t)) + 1);\n+}\n+\n@@ -115,1 +120,1 @@\n-  uint8_t* const offset_card = _array->entry_for_addr(cur_card_boundary);\n+  uint8_t* const offset_card = entry_for_addr(cur_card_boundary);\n@@ -118,1 +123,1 @@\n-  _array->set_offset_array(offset_card, cur_card_boundary, blk_start);\n+  *offset_card = checked_cast<uint8_t>(pointer_delta(cur_card_boundary, blk_start));\n@@ -121,1 +126,1 @@\n-  uint8_t* end_card = _array->entry_for_addr(blk_end - 1);\n+  uint8_t* end_card = entry_for_addr(blk_end - 1);\n@@ -133,1 +138,1 @@\n-      _array->set_offset_array(start_card_for_region, MIN2(reach, end_card), value);\n+      fill_range(start_card_for_region, MIN2(reach, end_card), value);\n@@ -147,1 +152,1 @@\n-  uint8_t* entry = _array->entry_for_addr(addr);\n+  uint8_t* entry = entry_for_addr(addr);\n@@ -156,1 +161,1 @@\n-  HeapWord* q = _array->addr_for_entry(entry);\n+  HeapWord* q = addr_for_entry(entry);\n@@ -163,2 +168,2 @@\n-  uint8_t* start_card = _array->entry_for_addr(align_up_by_card_size(blk_start));\n-  uint8_t* end_card = _array->entry_for_addr(blk_end - 1);\n+  uint8_t* start_card = entry_for_addr(align_up_by_card_size(blk_start));\n+  uint8_t* end_card = entry_for_addr(blk_end - 1);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -39,1 +39,5 @@\n-class SerialBlockOffsetSharedArray: public CHeapObj<mtGC> {\n+\/\/ SerialBlockOffsetTable divides the covered region into \"N\"-word subregions (where\n+\/\/ \"N\" = 2^\"LogN\".  An array with an entry for each such subregion indicates\n+\/\/ how far back one must go to find the start of the chunk that includes the\n+\/\/ first word of the subregion.\n+class SerialBlockOffsetTable: public CHeapObj<mtGC> {\n@@ -41,1 +45,0 @@\n-  friend class SerialBlockOffsetTable;\n@@ -53,4 +56,0 @@\n-  void fill_range(uint8_t* const start, size_t num_cards, uint8_t offset) {\n-    memset(start, offset, num_cards);\n-  }\n-\n@@ -66,15 +65,1 @@\n-public:\n-  \/\/ Initialize the table to cover from \"base\" to (at least)\n-  \/\/ \"base + init_word_size\".  In the future, the table may be expanded\n-  \/\/ (see \"resize\" below) up to the size of \"_reserved\" (which must be at\n-  \/\/ least \"init_word_size\".)  The contents of the initial table are\n-  \/\/ undefined; it is the responsibility of the constituent\n-  \/\/ SerialBlockOffsetTable(s) to initialize cards.\n-  SerialBlockOffsetSharedArray(MemRegion reserved, size_t init_word_size);\n-\n-  \/\/ Notes a change in the committed size of the region covered by the\n-  \/\/ table.  The \"new_word_size\" may not be larger than the size of the\n-  \/\/ reserved region this table covers.\n-  void resize(size_t new_word_size);\n-\n-  \/\/ Mapping from address to object start array entry\n+  \/\/ Mapping from address to object start array entry.\n@@ -83,1 +68,1 @@\n-  \/\/ Mapping from object start array entry to address of first word\n+  \/\/ Mapping from object start array entry to address of first word.\n@@ -86,26 +71,0 @@\n-  void set_offset_array(uint8_t* const addr, HeapWord* high, HeapWord* low) {\n-    assert(_vs.contains(addr), \"Block offset address out of range\");\n-    assert(high >= low, \"addresses out of order\");\n-    assert(pointer_delta(high, low) < CardTable::card_size_in_words(), \"offset too large\");\n-    *addr = checked_cast<uint8_t>(pointer_delta(high, low));\n-  }\n-\n-  void set_offset_array(uint8_t* const left, uint8_t* const right, uint8_t offset) {\n-    assert(_vs.contains(right), \"right address out of range\");\n-    assert(left <= right, \"precondition\");\n-    size_t num_cards = right - left + 1;\n-\n-    fill_range(left, num_cards, offset);\n-  }\n-};\n-\n-\/\/ SerialBlockOffsetTable divides the covered region into \"N\"-word subregions (where\n-\/\/ \"N\" = 2^\"LogN\".  An array with an entry for each such subregion indicates\n-\/\/ how far back one must go to find the start of the chunk that includes the\n-\/\/ first word of the subregion.\n-class SerialBlockOffsetTable {\n-  friend class VMStructs;\n-\n-  \/\/ The array that contains offset values. Its reacts to heap resizing.\n-  SerialBlockOffsetSharedArray* _array;\n-\n@@ -121,3 +80,7 @@\n-  \/\/ Initialize the table to cover the given space.\n-  \/\/ The contents of the initial table are undefined.\n-  SerialBlockOffsetTable(SerialBlockOffsetSharedArray* array) : _array(array) {}\n+  \/\/ Initialize the table to cover from \"base\" to (at least)\n+  \/\/ \"base + init_word_size\".  In the future, the table may be expanded\n+  \/\/ (see \"resize\" below) up to the size of \"_reserved\" (which must be at\n+  \/\/ least \"init_word_size\".)  The contents of the initial table are\n+  \/\/ undefined; it is the responsibility of the constituent\n+  \/\/ SerialBlockOffsetTable(s) to initialize cards.\n+  SerialBlockOffsetTable(MemRegion reserved, size_t init_word_size);\n@@ -142,0 +105,5 @@\n+\n+  \/\/ Notes a change in the committed size of the region covered by the\n+  \/\/ table.  The \"new_word_size\" may not be larger than the size of the\n+  \/\/ reserved region this table covers.\n+  void resize(size_t new_word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.hpp","additions":19,"deletions":51,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-inline uint8_t* SerialBlockOffsetSharedArray::entry_for_addr(const void* const p) const {\n+inline uint8_t* SerialBlockOffsetTable::entry_for_addr(const void* const p) const {\n@@ -37,1 +37,1 @@\n-inline HeapWord* SerialBlockOffsetSharedArray::addr_for_entry(const uint8_t* const p) const {\n+inline HeapWord* SerialBlockOffsetTable::addr_for_entry(const uint8_t* const p) const {\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,743 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/stringTable.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"compiler\/compileBroker.hpp\"\n+#include \"compiler\/oopMap.hpp\"\n+#include \"gc\/serial\/cardTableRS.hpp\"\n+#include \"gc\/serial\/defNewGeneration.hpp\"\n+#include \"gc\/serial\/serialFullGC.inline.hpp\"\n+#include \"gc\/serial\/serialGcRefProcProxyTask.hpp\"\n+#include \"gc\/serial\/serialHeap.hpp\"\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n+#include \"gc\/shared\/gcHeapSummary.hpp\"\n+#include \"gc\/shared\/gcTimer.hpp\"\n+#include \"gc\/shared\/gcTrace.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/modRefBarrierSet.hpp\"\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n+#include \"gc\/shared\/referencePolicy.hpp\"\n+#include \"gc\/shared\/referenceProcessorPhaseTimes.hpp\"\n+#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n+#include \"gc\/shared\/weakProcessor.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/instanceRefKlass.hpp\"\n+#include \"oops\/methodData.hpp\"\n+#include \"oops\/objArrayKlass.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"runtime\/prefetch.inline.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/stack.inline.hpp\"\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#endif\n+\n+uint                    SerialFullGC::_total_invocations = 0;\n+\n+Stack<oop, mtGC>              SerialFullGC::_marking_stack;\n+Stack<ObjArrayTask, mtGC>     SerialFullGC::_objarray_stack;\n+\n+PreservedMarksSet       SerialFullGC::_preserved_overflow_stack_set(false \/* in_c_heap *\/);\n+size_t                  SerialFullGC::_preserved_count = 0;\n+size_t                  SerialFullGC::_preserved_count_max = 0;\n+PreservedMark*          SerialFullGC::_preserved_marks = nullptr;\n+STWGCTimer*             SerialFullGC::_gc_timer        = nullptr;\n+SerialOldTracer*        SerialFullGC::_gc_tracer       = nullptr;\n+\n+AlwaysTrueClosure   SerialFullGC::_always_true_closure;\n+ReferenceProcessor* SerialFullGC::_ref_processor;\n+\n+StringDedup::Requests*  SerialFullGC::_string_dedup_requests = nullptr;\n+\n+SerialFullGC::FollowRootClosure  SerialFullGC::follow_root_closure;\n+\n+MarkAndPushClosure SerialFullGC::mark_and_push_closure(ClassLoaderData::_claim_stw_fullgc_mark);\n+CLDToOopClosure    SerialFullGC::follow_cld_closure(&mark_and_push_closure, ClassLoaderData::_claim_stw_fullgc_mark);\n+CLDToOopClosure    SerialFullGC::adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_stw_fullgc_adjust);\n+\n+class DeadSpacer : StackObj {\n+  size_t _allowed_deadspace_words;\n+  bool _active;\n+  ContiguousSpace* _space;\n+\n+public:\n+  DeadSpacer(ContiguousSpace* space) : _allowed_deadspace_words(0), _space(space) {\n+    size_t ratio = (_space == SerialHeap::heap()->old_gen()->space())\n+                   ? MarkSweepDeadRatio : 0;\n+    _active = ratio > 0;\n+\n+    if (_active) {\n+      \/\/ We allow some amount of garbage towards the bottom of the space, so\n+      \/\/ we don't start compacting before there is a significant gain to be made.\n+      \/\/ Occasionally, we want to ensure a full compaction, which is determined\n+      \/\/ by the MarkSweepAlwaysCompactCount parameter.\n+      if ((SerialFullGC::total_invocations() % MarkSweepAlwaysCompactCount) != 0) {\n+        _allowed_deadspace_words = (space->capacity() * ratio \/ 100) \/ HeapWordSize;\n+      } else {\n+        _active = false;\n+      }\n+    }\n+  }\n+\n+  bool insert_deadspace(HeapWord* dead_start, HeapWord* dead_end) {\n+    if (!_active) {\n+      return false;\n+    }\n+\n+    size_t dead_length = pointer_delta(dead_end, dead_start);\n+    if (_allowed_deadspace_words >= dead_length) {\n+      _allowed_deadspace_words -= dead_length;\n+      CollectedHeap::fill_with_object(dead_start, dead_length);\n+      oop obj = cast_to_oop(dead_start);\n+      \/\/ obj->set_mark(obj->mark().set_marked());\n+\n+      assert(dead_length == obj->size(), \"bad filler object size\");\n+      log_develop_trace(gc, compaction)(\"Inserting object to dead space: \" PTR_FORMAT \", \" PTR_FORMAT \", \" SIZE_FORMAT \"b\",\n+                                        p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);\n+\n+      return true;\n+    } else {\n+      _active = false;\n+      return false;\n+    }\n+  }\n+};\n+\n+\/\/ Implement the \"compaction\" part of the mark-compact GC algorithm.\n+class Compacter {\n+  \/\/ There are four spaces in total, but only the first three can be used after\n+  \/\/ compact. IOW, old and eden\/from must be enough for all live objs\n+  static constexpr uint max_num_spaces = 4;\n+\n+  struct CompactionSpace {\n+    ContiguousSpace* _space;\n+    \/\/ Will be the new top after compaction is complete.\n+    HeapWord* _compaction_top;\n+    \/\/ The first dead word in this contiguous space. It's an optimization to\n+    \/\/ skip large chunk of live objects at the beginning.\n+    HeapWord* _first_dead;\n+\n+    void init(ContiguousSpace* space) {\n+      _space = space;\n+      _compaction_top = space->bottom();\n+      _first_dead = nullptr;\n+    }\n+  };\n+\n+  CompactionSpace _spaces[max_num_spaces];\n+  \/\/ The num of spaces to be compacted, i.e. containing live objs.\n+  uint _num_spaces;\n+\n+  uint _index;\n+\n+  HeapWord* get_compaction_top(uint index) const {\n+    return _spaces[index]._compaction_top;\n+  }\n+\n+  HeapWord* get_first_dead(uint index) const {\n+    return _spaces[index]._first_dead;\n+  }\n+\n+  ContiguousSpace* get_space(uint index) const {\n+    return _spaces[index]._space;\n+  }\n+\n+  void record_first_dead(uint index, HeapWord* first_dead) {\n+    assert(_spaces[index]._first_dead == nullptr, \"should write only once\");\n+    _spaces[index]._first_dead = first_dead;\n+  }\n+\n+  HeapWord* alloc(size_t words) {\n+    while (true) {\n+      if (words <= pointer_delta(_spaces[_index]._space->end(),\n+                                 _spaces[_index]._compaction_top)) {\n+        HeapWord* result = _spaces[_index]._compaction_top;\n+        _spaces[_index]._compaction_top += words;\n+        if (_index == 0) {\n+          \/\/ old-gen requires BOT update\n+          static_cast<TenuredSpace*>(_spaces[0]._space)->update_for_block(result, result + words);\n+        }\n+        return result;\n+      }\n+\n+      \/\/ out-of-memory in this space\n+      _index++;\n+      assert(_index < max_num_spaces - 1, \"the last space should not be used\");\n+    }\n+  }\n+\n+  static void prefetch_read_scan(void* p) {\n+    if (PrefetchScanIntervalInBytes >= 0) {\n+      Prefetch::read(p, PrefetchScanIntervalInBytes);\n+    }\n+  }\n+\n+  static void prefetch_write_scan(void* p) {\n+    if (PrefetchScanIntervalInBytes >= 0) {\n+      Prefetch::write(p, PrefetchScanIntervalInBytes);\n+    }\n+  }\n+\n+  static void prefetch_write_copy(void* p) {\n+    if (PrefetchCopyIntervalInBytes >= 0) {\n+      Prefetch::write(p, PrefetchCopyIntervalInBytes);\n+    }\n+  }\n+\n+  static void forward_obj(oop obj, HeapWord* new_addr) {\n+    prefetch_write_scan(obj);\n+    if (cast_from_oop<HeapWord*>(obj) != new_addr) {\n+      obj->forward_to(cast_to_oop(new_addr));\n+    } else {\n+      assert(obj->is_gc_marked(), \"inv\");\n+      \/\/ This obj will stay in-place. Fix the markword.\n+      obj->init_mark();\n+    }\n+  }\n+\n+  static HeapWord* find_next_live_addr(HeapWord* start, HeapWord* end) {\n+    for (HeapWord* i_addr = start; i_addr < end; \/* empty *\/) {\n+      prefetch_read_scan(i_addr);\n+      oop obj = cast_to_oop(i_addr);\n+      if (obj->is_gc_marked()) {\n+        return i_addr;\n+      }\n+      i_addr += obj->size();\n+    }\n+    return end;\n+  };\n+\n+  static size_t relocate(HeapWord* addr) {\n+    \/\/ Prefetch source and destination\n+    prefetch_read_scan(addr);\n+\n+    oop obj = cast_to_oop(addr);\n+    oop new_obj = obj->forwardee();\n+    HeapWord* new_addr = cast_from_oop<HeapWord*>(new_obj);\n+    assert(addr != new_addr, \"inv\");\n+    prefetch_write_copy(new_addr);\n+\n+    size_t obj_size = obj->size();\n+    Copy::aligned_conjoint_words(addr, new_addr, obj_size);\n+    new_obj->init_mark();\n+\n+    return obj_size;\n+  }\n+\n+public:\n+  explicit Compacter(SerialHeap* heap) {\n+    \/\/ In this order so that heap is compacted towards old-gen.\n+    _spaces[0].init(heap->old_gen()->space());\n+    _spaces[1].init(heap->young_gen()->eden());\n+    _spaces[2].init(heap->young_gen()->from());\n+\n+    bool is_promotion_failed = (heap->young_gen()->from()->next_compaction_space() != nullptr);\n+    if (is_promotion_failed) {\n+      _spaces[3].init(heap->young_gen()->to());\n+      _num_spaces = 4;\n+    } else {\n+      _num_spaces = 3;\n+    }\n+    _index = 0;\n+  }\n+\n+  void phase2_calculate_new_addr() {\n+    for (uint i = 0; i < _num_spaces; ++i) {\n+      ContiguousSpace* space = get_space(i);\n+      HeapWord* cur_addr = space->bottom();\n+      HeapWord* top = space->top();\n+\n+      bool record_first_dead_done = false;\n+\n+      DeadSpacer dead_spacer(space);\n+\n+      while (cur_addr < top) {\n+        oop obj = cast_to_oop(cur_addr);\n+        size_t obj_size = obj->size();\n+        if (obj->is_gc_marked()) {\n+          HeapWord* new_addr = alloc(obj_size);\n+          forward_obj(obj, new_addr);\n+          cur_addr += obj_size;\n+        } else {\n+          \/\/ Skipping the current known-unmarked obj\n+          HeapWord* next_live_addr = find_next_live_addr(cur_addr + obj_size, top);\n+          if (dead_spacer.insert_deadspace(cur_addr, next_live_addr)) {\n+            \/\/ Register space for the filler obj\n+            alloc(pointer_delta(next_live_addr, cur_addr));\n+          } else {\n+            if (!record_first_dead_done) {\n+              record_first_dead(i, cur_addr);\n+              record_first_dead_done = true;\n+            }\n+            *(HeapWord**)cur_addr = next_live_addr;\n+          }\n+          cur_addr = next_live_addr;\n+        }\n+      }\n+\n+      if (!record_first_dead_done) {\n+        record_first_dead(i, top);\n+      }\n+    }\n+  }\n+\n+  void phase3_adjust_pointers() {\n+    for (uint i = 0; i < _num_spaces; ++i) {\n+      ContiguousSpace* space = get_space(i);\n+      HeapWord* cur_addr = space->bottom();\n+      HeapWord* const top = space->top();\n+      HeapWord* const first_dead = get_first_dead(i);\n+\n+      while (cur_addr < top) {\n+        prefetch_write_scan(cur_addr);\n+        if (cur_addr < first_dead || cast_to_oop(cur_addr)->is_gc_marked()) {\n+          size_t size = SerialFullGC::adjust_pointers(cast_to_oop(cur_addr));\n+          cur_addr += size;\n+        } else {\n+          assert(*(HeapWord**)cur_addr > cur_addr, \"forward progress\");\n+          cur_addr = *(HeapWord**)cur_addr;\n+        }\n+      }\n+    }\n+  }\n+\n+  void phase4_compact() {\n+    for (uint i = 0; i < _num_spaces; ++i) {\n+      ContiguousSpace* space = get_space(i);\n+      HeapWord* cur_addr = space->bottom();\n+      HeapWord* top = space->top();\n+\n+      \/\/ Check if the first obj inside this space is forwarded.\n+      if (!cast_to_oop(cur_addr)->is_forwarded()) {\n+        \/\/ Jump over consecutive (in-place) live-objs-chunk\n+        cur_addr = get_first_dead(i);\n+      }\n+\n+      while (cur_addr < top) {\n+        if (!cast_to_oop(cur_addr)->is_forwarded()) {\n+          cur_addr = *(HeapWord**) cur_addr;\n+          continue;\n+        }\n+        cur_addr += relocate(cur_addr);\n+      }\n+\n+      \/\/ Reset top and unused memory\n+      space->set_top(get_compaction_top(i));\n+      if (ZapUnusedHeapArea) {\n+        space->mangle_unused_area();\n+      }\n+    }\n+  }\n+};\n+\n+template <class T> void SerialFullGC::KeepAliveClosure::do_oop_work(T* p) {\n+  mark_and_push(p);\n+}\n+\n+void SerialFullGC::push_objarray(oop obj, size_t index) {\n+  ObjArrayTask task(obj, index);\n+  assert(task.is_valid(), \"bad ObjArrayTask\");\n+  _objarray_stack.push(task);\n+}\n+\n+void SerialFullGC::follow_array(objArrayOop array) {\n+  mark_and_push_closure.do_klass(array->klass());\n+  \/\/ Don't push empty arrays to avoid unnecessary work.\n+  if (array->length() > 0) {\n+    SerialFullGC::push_objarray(array, 0);\n+  }\n+}\n+\n+void SerialFullGC::follow_object(oop obj) {\n+  assert(obj->is_gc_marked(), \"should be marked\");\n+  if (obj->is_objArray()) {\n+    \/\/ Handle object arrays explicitly to allow them to\n+    \/\/ be split into chunks if needed.\n+    SerialFullGC::follow_array((objArrayOop)obj);\n+  } else {\n+    obj->oop_iterate(&mark_and_push_closure);\n+  }\n+}\n+\n+void SerialFullGC::follow_array_chunk(objArrayOop array, int index) {\n+  const int len = array->length();\n+  const int beg_index = index;\n+  assert(beg_index < len || len == 0, \"index too large\");\n+\n+  const int stride = MIN2(len - beg_index, (int) ObjArrayMarkingStride);\n+  const int end_index = beg_index + stride;\n+\n+  array->oop_iterate_range(&mark_and_push_closure, beg_index, end_index);\n+\n+  if (end_index < len) {\n+    SerialFullGC::push_objarray(array, end_index); \/\/ Push the continuation.\n+  }\n+}\n+\n+void SerialFullGC::follow_stack() {\n+  do {\n+    while (!_marking_stack.is_empty()) {\n+      oop obj = _marking_stack.pop();\n+      assert (obj->is_gc_marked(), \"p must be marked\");\n+      follow_object(obj);\n+    }\n+    \/\/ Process ObjArrays one at a time to avoid marking stack bloat.\n+    if (!_objarray_stack.is_empty()) {\n+      ObjArrayTask task = _objarray_stack.pop();\n+      follow_array_chunk(objArrayOop(task.obj()), task.index());\n+    }\n+  } while (!_marking_stack.is_empty() || !_objarray_stack.is_empty());\n+}\n+\n+SerialFullGC::FollowStackClosure SerialFullGC::follow_stack_closure;\n+\n+void SerialFullGC::FollowStackClosure::do_void() { follow_stack(); }\n+\n+template <class T> void SerialFullGC::follow_root(T* p) {\n+  assert(!Universe::heap()->is_in(p),\n+         \"roots shouldn't be things within the heap\");\n+  T heap_oop = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(heap_oop)) {\n+    oop obj = CompressedOops::decode_not_null(heap_oop);\n+    if (!obj->mark().is_marked()) {\n+      mark_object(obj);\n+      follow_object(obj);\n+    }\n+  }\n+  follow_stack();\n+}\n+\n+void SerialFullGC::FollowRootClosure::do_oop(oop* p)       { follow_root(p); }\n+void SerialFullGC::FollowRootClosure::do_oop(narrowOop* p) { follow_root(p); }\n+\n+\/\/ We preserve the mark which should be replaced at the end and the location\n+\/\/ that it will go.  Note that the object that this markWord belongs to isn't\n+\/\/ currently at that address but it will be after phase4\n+void SerialFullGC::preserve_mark(oop obj, markWord mark) {\n+  \/\/ We try to store preserved marks in the to space of the new generation since\n+  \/\/ this is storage which should be available.  Most of the time this should be\n+  \/\/ sufficient space for the marks we need to preserve but if it isn't we fall\n+  \/\/ back to using Stacks to keep track of the overflow.\n+  if (_preserved_count < _preserved_count_max) {\n+    _preserved_marks[_preserved_count++] = PreservedMark(obj, mark);\n+  } else {\n+    _preserved_overflow_stack_set.get()->push_always(obj, mark);\n+  }\n+}\n+\n+void SerialFullGC::phase1_mark(bool clear_all_softrefs) {\n+  \/\/ Recursively traverse all live objects and mark them\n+  GCTraceTime(Info, gc, phases) tm(\"Phase 1: Mark live objects\", _gc_timer);\n+\n+  SerialHeap* gch = SerialHeap::heap();\n+\n+  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_mark);\n+\n+  ref_processor()->start_discovery(clear_all_softrefs);\n+\n+  {\n+    StrongRootsScope srs(0);\n+\n+    CLDClosure* weak_cld_closure = ClassUnloading ? nullptr : &follow_cld_closure;\n+    MarkingNMethodClosure mark_code_closure(&follow_root_closure, !NMethodToOopClosure::FixRelocations, true);\n+    gch->process_roots(SerialHeap::SO_None,\n+                       &follow_root_closure,\n+                       &follow_cld_closure,\n+                       weak_cld_closure,\n+                       &mark_code_closure);\n+  }\n+\n+  \/\/ Process reference objects found during marking\n+  {\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Reference Processing\", gc_timer());\n+\n+    ReferenceProcessorPhaseTimes pt(_gc_timer, ref_processor()->max_num_queues());\n+    SerialGCRefProcProxyTask task(is_alive, keep_alive, follow_stack_closure);\n+    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(task, pt);\n+    pt.print_all_references();\n+    gc_tracer()->report_gc_reference_stats(stats);\n+  }\n+\n+  \/\/ This is the point where the entire marking should have completed.\n+  assert(_marking_stack.is_empty(), \"Marking should have completed\");\n+\n+  {\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Weak Processing\", gc_timer());\n+    WeakProcessor::weak_oops_do(&is_alive, &do_nothing_cl);\n+  }\n+\n+  {\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Class Unloading\", gc_timer());\n+\n+    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+\n+    bool unloading_occurred;\n+    {\n+      CodeCache::UnlinkingScope scope(&is_alive);\n+\n+      \/\/ Unload classes and purge the SystemDictionary.\n+      unloading_occurred = SystemDictionary::do_unloading(gc_timer());\n+\n+      \/\/ Unload nmethods.\n+      CodeCache::do_unloading(unloading_occurred);\n+    }\n+\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n+      \/\/ Release unloaded nmethod's memory.\n+      ctx->purge_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", gc_timer());\n+      gch->prune_unlinked_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n+      ctx->free_nmethods();\n+    }\n+\n+    \/\/ Prune dead klasses from subklass\/sibling\/implementor lists.\n+    Klass::clean_weak_klass_links(unloading_occurred);\n+\n+    \/\/ Clean JVMCI metadata handles.\n+    JVMCI_ONLY(JVMCI::do_unloading(unloading_occurred));\n+  }\n+\n+  {\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Report Object Count\", gc_timer());\n+    gc_tracer()->report_object_count_after_gc(&is_alive, nullptr);\n+  }\n+}\n+\n+void SerialFullGC::allocate_stacks() {\n+  void* scratch = nullptr;\n+  size_t num_words;\n+  DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n+  young_gen->contribute_scratch(scratch, num_words);\n+\n+  if (scratch != nullptr) {\n+    _preserved_count_max = num_words * HeapWordSize \/ sizeof(PreservedMark);\n+  } else {\n+    _preserved_count_max = 0;\n+  }\n+\n+  _preserved_marks = (PreservedMark*)scratch;\n+  _preserved_count = 0;\n+\n+  _preserved_overflow_stack_set.init(1);\n+}\n+\n+void SerialFullGC::deallocate_stacks() {\n+  if (_preserved_count_max != 0) {\n+    DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n+    young_gen->reset_scratch();\n+  }\n+\n+  _preserved_overflow_stack_set.reclaim();\n+  _marking_stack.clear();\n+  _objarray_stack.clear(true);\n+}\n+\n+void SerialFullGC::mark_object(oop obj) {\n+  if (StringDedup::is_enabled() &&\n+      java_lang_String::is_instance(obj) &&\n+      SerialStringDedup::is_candidate_from_mark(obj)) {\n+    _string_dedup_requests->add(obj);\n+  }\n+\n+  \/\/ some marks may contain information we need to preserve so we store them away\n+  \/\/ and overwrite the mark.  We'll restore it at the end of serial full GC.\n+  markWord mark = obj->mark();\n+  obj->set_mark(markWord::prototype().set_marked());\n+\n+  ContinuationGCSupport::transform_stack_chunk(obj);\n+\n+  if (obj->mark_must_be_preserved(mark)) {\n+    preserve_mark(obj, mark);\n+  }\n+}\n+\n+template <class T> void SerialFullGC::mark_and_push(T* p) {\n+  T heap_oop = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(heap_oop)) {\n+    oop obj = CompressedOops::decode_not_null(heap_oop);\n+    if (!obj->mark().is_marked()) {\n+      mark_object(obj);\n+      _marking_stack.push(obj);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void MarkAndPushClosure::do_oop_work(T* p)            { SerialFullGC::mark_and_push(p); }\n+void MarkAndPushClosure::do_oop(      oop* p)         { do_oop_work(p); }\n+void MarkAndPushClosure::do_oop(narrowOop* p)         { do_oop_work(p); }\n+\n+AdjustPointerClosure SerialFullGC::adjust_pointer_closure;\n+\n+void SerialFullGC::adjust_marks() {\n+  \/\/ adjust the oops we saved earlier\n+  for (size_t i = 0; i < _preserved_count; i++) {\n+    PreservedMarks::adjust_preserved_mark(_preserved_marks + i);\n+  }\n+\n+  \/\/ deal with the overflow stack\n+  _preserved_overflow_stack_set.get()->adjust_during_full_gc();\n+}\n+\n+void SerialFullGC::restore_marks() {\n+  log_trace(gc)(\"Restoring \" SIZE_FORMAT \" marks\", _preserved_count + _preserved_overflow_stack_set.get()->size());\n+\n+  \/\/ restore the marks we saved earlier\n+  for (size_t i = 0; i < _preserved_count; i++) {\n+    _preserved_marks[i].set_mark();\n+  }\n+\n+  \/\/ deal with the overflow\n+  _preserved_overflow_stack_set.restore(nullptr);\n+}\n+\n+SerialFullGC::IsAliveClosure   SerialFullGC::is_alive;\n+\n+bool SerialFullGC::IsAliveClosure::do_object_b(oop p) { return p->is_gc_marked(); }\n+\n+SerialFullGC::KeepAliveClosure SerialFullGC::keep_alive;\n+\n+void SerialFullGC::KeepAliveClosure::do_oop(oop* p)       { SerialFullGC::KeepAliveClosure::do_oop_work(p); }\n+void SerialFullGC::KeepAliveClosure::do_oop(narrowOop* p) { SerialFullGC::KeepAliveClosure::do_oop_work(p); }\n+\n+void SerialFullGC::initialize() {\n+  SerialFullGC::_gc_timer = new STWGCTimer();\n+  SerialFullGC::_gc_tracer = new SerialOldTracer();\n+  SerialFullGC::_string_dedup_requests = new StringDedup::Requests();\n+\n+  \/\/ The Full GC operates on the entire heap so all objects should be subject\n+  \/\/ to discovery, hence the _always_true_closure.\n+  SerialFullGC::_ref_processor = new ReferenceProcessor(&_always_true_closure);\n+  mark_and_push_closure.set_ref_discoverer(_ref_processor);\n+}\n+\n+void SerialFullGC::invoke_at_safepoint(bool clear_all_softrefs) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n+\n+  SerialHeap* gch = SerialHeap::heap();\n+#ifdef ASSERT\n+  if (gch->soft_ref_policy()->should_clear_all_soft_refs()) {\n+    assert(clear_all_softrefs, \"Policy should have been checked earlier\");\n+  }\n+#endif\n+\n+  gch->trace_heap_before_gc(_gc_tracer);\n+\n+  \/\/ Increment the invocation count\n+  _total_invocations++;\n+\n+  \/\/ Capture used regions for old-gen to reestablish old-to-young invariant\n+  \/\/ after full-gc.\n+  gch->old_gen()->save_used_region();\n+\n+  allocate_stacks();\n+\n+  phase1_mark(clear_all_softrefs);\n+\n+  Compacter compacter{gch};\n+\n+  {\n+    \/\/ Now all live objects are marked, compute the new object addresses.\n+    GCTraceTime(Info, gc, phases) tm(\"Phase 2: Compute new object addresses\", _gc_timer);\n+\n+    compacter.phase2_calculate_new_addr();\n+  }\n+\n+  \/\/ Don't add any more derived pointers during phase3\n+#if COMPILER2_OR_JVMCI\n+  assert(DerivedPointerTable::is_active(), \"Sanity\");\n+  DerivedPointerTable::set_active(false);\n+#endif\n+\n+  {\n+    \/\/ Adjust the pointers to reflect the new locations\n+    GCTraceTime(Info, gc, phases) tm(\"Phase 3: Adjust pointers\", gc_timer());\n+\n+    ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_adjust);\n+\n+    NMethodToOopClosure code_closure(&adjust_pointer_closure, NMethodToOopClosure::FixRelocations);\n+    gch->process_roots(SerialHeap::SO_AllCodeCache,\n+                       &adjust_pointer_closure,\n+                       &adjust_cld_closure,\n+                       &adjust_cld_closure,\n+                       &code_closure);\n+\n+    WeakProcessor::oops_do(&adjust_pointer_closure);\n+\n+    adjust_marks();\n+    compacter.phase3_adjust_pointers();\n+  }\n+\n+  {\n+    \/\/ All pointers are now adjusted, move objects accordingly\n+    GCTraceTime(Info, gc, phases) tm(\"Phase 4: Move objects\", _gc_timer);\n+\n+    compacter.phase4_compact();\n+  }\n+\n+  restore_marks();\n+\n+  \/\/ Set saved marks for allocation profiler (and other things? -- dld)\n+  \/\/ (Should this be in general part?)\n+  gch->save_marks();\n+\n+  deallocate_stacks();\n+\n+  SerialFullGC::_string_dedup_requests->flush();\n+\n+  bool is_young_gen_empty = (gch->young_gen()->used() == 0);\n+  gch->rem_set()->maintain_old_to_young_invariant(gch->old_gen(), is_young_gen_empty);\n+\n+  gch->prune_scavengable_nmethods();\n+\n+  \/\/ Update heap occupancy information which is used as\n+  \/\/ input to soft ref clearing policy at the next gc.\n+  Universe::heap()->update_capacity_and_used_at_gc();\n+\n+  \/\/ Signal that we have completed a visit to all live objects.\n+  Universe::heap()->record_whole_heap_examined_timestamp();\n+\n+  gch->trace_heap_after_gc(_gc_tracer);\n+}\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":743,"deletions":0,"binary":false,"changes":743,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SERIAL_SERIALFULLGC_HPP\n+#define SHARE_GC_SERIAL_SERIALFULLGC_HPP\n+\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"gc\/shared\/preservedMarks.hpp\"\n+#include \"gc\/shared\/referenceProcessor.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"gc\/shared\/taskqueue.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"runtime\/timer.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/stack.hpp\"\n+\n+class SerialOldTracer;\n+class STWGCTimer;\n+\n+\/\/ Serial full GC takes care of global mark-compact garbage collection for a\n+\/\/ SerialHeap using a four-phase pointer forwarding algorithm.  All\n+\/\/ generations are assumed to support marking; those that can also support\n+\/\/ compaction.\n+\/\/\n+\/\/ Class unloading will only occur when a full gc is invoked.\n+\n+\/\/ declared at end\n+class MarkAndPushClosure;\n+class AdjustPointerClosure;\n+\n+class SerialFullGC : AllStatic {\n+  \/\/\n+  \/\/ Inline closure decls\n+  \/\/\n+  class FollowRootClosure: public BasicOopIterateClosure {\n+   public:\n+    virtual void do_oop(oop* p);\n+    virtual void do_oop(narrowOop* p);\n+  };\n+\n+  class FollowStackClosure: public VoidClosure {\n+   public:\n+    virtual void do_void();\n+  };\n+\n+  \/\/ Used for java\/lang\/ref handling\n+  class IsAliveClosure: public BoolObjectClosure {\n+   public:\n+    virtual bool do_object_b(oop p);\n+  };\n+\n+  class KeepAliveClosure: public OopClosure {\n+   protected:\n+    template <class T> void do_oop_work(T* p);\n+   public:\n+    virtual void do_oop(oop* p);\n+    virtual void do_oop(narrowOop* p);\n+  };\n+\n+ protected:\n+  \/\/ Total invocations of serial full GC\n+  static uint _total_invocations;\n+\n+  \/\/ Traversal stacks used during phase1\n+  static Stack<oop, mtGC>                      _marking_stack;\n+  static Stack<ObjArrayTask, mtGC>             _objarray_stack;\n+\n+  \/\/ Space for storing\/restoring mark word\n+  static PreservedMarksSet               _preserved_overflow_stack_set;\n+  static size_t                          _preserved_count;\n+  static size_t                          _preserved_count_max;\n+  static PreservedMark*                  _preserved_marks;\n+\n+  static AlwaysTrueClosure               _always_true_closure;\n+  static ReferenceProcessor*             _ref_processor;\n+\n+  static STWGCTimer*                     _gc_timer;\n+  static SerialOldTracer*                _gc_tracer;\n+\n+  static StringDedup::Requests* _string_dedup_requests;\n+\n+  \/\/ Non public closures\n+  static KeepAliveClosure keep_alive;\n+\n+ public:\n+  static void initialize();\n+\n+  \/\/ Public closures\n+  static IsAliveClosure       is_alive;\n+  static FollowRootClosure    follow_root_closure;\n+  static MarkAndPushClosure   mark_and_push_closure;\n+  static FollowStackClosure   follow_stack_closure;\n+  static CLDToOopClosure      follow_cld_closure;\n+  static AdjustPointerClosure adjust_pointer_closure;\n+  static CLDToOopClosure      adjust_cld_closure;\n+\n+  static void invoke_at_safepoint(bool clear_all_softrefs);\n+\n+  \/\/ Accessors\n+  static uint total_invocations() { return _total_invocations; }\n+\n+  \/\/ Reference Processing\n+  static ReferenceProcessor* ref_processor() { return _ref_processor; }\n+\n+  static STWGCTimer* gc_timer() { return _gc_timer; }\n+  static SerialOldTracer* gc_tracer() { return _gc_tracer; }\n+\n+  static void preserve_mark(oop p, markWord mark);\n+                                \/\/ Save the mark word so it can be restored later\n+  static void adjust_marks();   \/\/ Adjust the pointers in the preserved marks table\n+  static void restore_marks();  \/\/ Restore the marks that we saved in preserve_mark\n+\n+  static size_t adjust_pointers(oop obj);\n+\n+  static void follow_stack();   \/\/ Empty marking stack.\n+\n+  template <class T> static inline void adjust_pointer(T* p);\n+\n+  \/\/ Check mark and maybe push on marking stack\n+  template <class T> static void mark_and_push(T* p);\n+\n+ private:\n+  \/\/ Mark live objects\n+  static void phase1_mark(bool clear_all_softrefs);\n+\n+  \/\/ Temporary data structures for traversal and storing\/restoring marks\n+  static void allocate_stacks();\n+  static void deallocate_stacks();\n+\n+  \/\/ Call backs for marking\n+  static void mark_object(oop obj);\n+  \/\/ Mark pointer and follow contents.  Empty marking stack afterwards.\n+  template <class T> static inline void follow_root(T* p);\n+\n+  static inline void push_objarray(oop obj, size_t index);\n+\n+  static void follow_object(oop obj);\n+\n+  static void follow_array(objArrayOop array);\n+\n+  static void follow_array_chunk(objArrayOop array, int index);\n+};\n+\n+class MarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n+public:\n+  MarkAndPushClosure(int claim) : ClaimMetadataVisitingOopIterateClosure(claim) {}\n+\n+  template <typename T> void do_oop_work(T* p);\n+  virtual void do_oop(      oop* p);\n+  virtual void do_oop(narrowOop* p);\n+\n+  void set_ref_discoverer(ReferenceDiscoverer* rd) {\n+    set_ref_discoverer_internal(rd);\n+  }\n+};\n+\n+class AdjustPointerClosure: public BasicOopIterateClosure {\n+ public:\n+  template <typename T> void do_oop_work(T* p);\n+  virtual void do_oop(oop* p);\n+  virtual void do_oop(narrowOop* p);\n+  virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }\n+};\n+\n+#endif \/\/ SHARE_GC_SERIAL_SERIALFULLGC_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.hpp","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SERIAL_SERIALFULLGC_INLINE_HPP\n+#define SHARE_GC_SERIAL_SERIALFULLGC_INLINE_HPP\n+\n+#include \"gc\/serial\/serialFullGC.hpp\"\n+\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n+#include \"gc\/serial\/serialStringDedup.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/stack.inline.hpp\"\n+\n+template <class T> inline void SerialFullGC::adjust_pointer(T* p) {\n+  T heap_oop = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(heap_oop)) {\n+    oop obj = CompressedOops::decode_not_null(heap_oop);\n+    assert(Universe::heap()->is_in(obj), \"should be in heap\");\n+\n+    if (obj->is_forwarded()) {\n+      oop new_obj = obj->forwardee();\n+      assert(is_object_aligned(new_obj), \"oop must be aligned\");\n+      RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void AdjustPointerClosure::do_oop_work(T* p)           { SerialFullGC::adjust_pointer(p); }\n+inline void AdjustPointerClosure::do_oop(oop* p)       { do_oop_work(p); }\n+inline void AdjustPointerClosure::do_oop(narrowOop* p) { do_oop_work(p); }\n+\n+inline size_t SerialFullGC::adjust_pointers(oop obj) {\n+  return obj->oop_iterate_size(&SerialFullGC::adjust_pointer_closure);\n+}\n+\n+#endif \/\/ SHARE_GC_SERIAL_SERIALFULLGC_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.inline.hpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -34,2 +34,1 @@\n-#include \"gc\/serial\/genMarkSweep.hpp\"\n-#include \"gc\/serial\/markSweep.hpp\"\n+#include \"gc\/serial\/serialFullGC.hpp\"\n@@ -253,1 +252,1 @@\n-  MarkSweep::initialize();\n+  SerialFullGC::initialize();\n@@ -564,1 +563,1 @@\n-    GCTraceCPUTime tcpu(GenMarkSweep::gc_tracer());\n+    GCTraceCPUTime tcpu(SerialFullGC::gc_tracer());\n@@ -589,1 +588,1 @@\n-                              false \/* lock_codeblob_free_separately *\/);\n+                              false \/* lock_nmethod_free_separately *\/);\n@@ -729,11 +728,0 @@\n-#ifdef ASSERT\n-class AssertNonScavengableClosure: public OopClosure {\n-public:\n-  virtual void do_oop(oop* p) {\n-    assert(!SerialHeap::heap()->is_in_partial_collection(*p),\n-      \"Referent should not be scavengable.\");  }\n-  virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-};\n-static AssertNonScavengableClosure assert_is_non_scavengable_closure;\n-#endif\n-\n@@ -744,1 +732,1 @@\n-                               CodeBlobToOopClosure* code_roots) {\n+                               NMethodToOopClosure* code_roots) {\n@@ -751,1 +739,1 @@\n-  CodeBlobToOopClosure* roots_from_code_p = (so & SO_AllCodeCache) ? nullptr : code_roots;\n+  NMethodToOopClosure* roots_from_code_p = (so & SO_AllCodeCache) ? nullptr : code_roots;\n@@ -768,1 +756,1 @@\n-    CodeCache::blobs_do(code_roots);\n+    CodeCache::nmethods_do(code_roots);\n@@ -770,4 +758,0 @@\n-  \/\/ Verify that the code cache contents are not subject to\n-  \/\/ movement by a scavenging collection.\n-  DEBUG_ONLY(CodeBlobToOopClosure assert_code_is_non_scavengable(&assert_is_non_scavengable_closure, !CodeBlobToOopClosure::FixRelocations));\n-  DEBUG_ONLY(ScavengableNMethods::asserted_non_scavengable_nmethods_do(&assert_code_is_non_scavengable));\n@@ -873,10 +857,0 @@\n-#ifdef ASSERT\n-\/\/ Don't implement this by using is_in_young().  This method is used\n-\/\/ in some cases to check that is_in_young() is correct.\n-bool SerialHeap::is_in_partial_collection(const void* p) {\n-  assert(is_in_reserved(p) || p == nullptr,\n-    \"Does not work if address is non-null and outside of the heap\");\n-  return p < _young_gen->reserved().end() && p != nullptr;\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":7,"deletions":33,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  friend class GenMarkSweep;\n+  friend class SerialFullGC;\n@@ -181,4 +181,0 @@\n-#ifdef ASSERT\n-  bool is_in_partial_collection(const void* p);\n-#endif\n-\n@@ -279,1 +275,1 @@\n-                     CodeBlobToOopClosure* code_roots);\n+                     NMethodToOopClosure* code_roots);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-                        notproduct,  \\\n","filename":"src\/hotspot\/share\/gc\/serial\/serial_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-#include \"gc\/serial\/genMarkSweep.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"gc\/serial\/serialFullGC.hpp\"\n@@ -40,0 +40,1 @@\n+#include \"utilities\/copy.hpp\"\n@@ -271,1 +272,1 @@\n-  _rs->scan_old_to_young_refs(space());\n+  _rs->scan_old_to_young_refs(space(), saved_mark_word());\n@@ -290,2 +291,2 @@\n-  _bts = new SerialBlockOffsetSharedArray(reserved_mr,\n-                                          heap_word_size(initial_byte_size));\n+  _bts = new SerialBlockOffsetTable(reserved_mr,\n+                                    heap_word_size(initial_byte_size));\n@@ -447,1 +448,1 @@\n-  STWGCTimer* gc_timer = GenMarkSweep::gc_timer();\n+  STWGCTimer* gc_timer = SerialFullGC::gc_timer();\n@@ -450,1 +451,1 @@\n-  SerialOldTracer* gc_tracer = GenMarkSweep::gc_tracer();\n+  SerialOldTracer* gc_tracer = SerialFullGC::gc_tracer();\n@@ -455,1 +456,1 @@\n-  GenMarkSweep::invoke_at_safepoint(clear_all_soft_refs);\n+  SerialFullGC::invoke_at_safepoint(clear_all_soft_refs);\n@@ -495,1 +496,1 @@\n-  _the_space->set_saved_mark();\n+  set_saved_mark_word();\n@@ -499,1 +500,1 @@\n-  return _the_space->saved_mark_at_top();\n+  return saved_mark_at_top();\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-class SerialBlockOffsetSharedArray;\n+class SerialBlockOffsetTable;\n@@ -53,1 +53,1 @@\n-  SerialBlockOffsetSharedArray* _bts;\n+  SerialBlockOffsetTable* _bts;\n@@ -69,0 +69,1 @@\n+  HeapWord*           _saved_mark_word;\n@@ -91,0 +92,3 @@\n+  HeapWord* saved_mark_word() const { return _saved_mark_word; }\n+  void set_saved_mark_word() { _saved_mark_word = _the_space->top(); }\n+  bool saved_mark_at_top() { return _saved_mark_word == space()->top(); }\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,2 @@\n-  _the_space->oop_since_save_marks_iterate(blk);\n+  Generation::oop_since_save_marks_iterate_impl(blk, _the_space, _saved_mark_word);\n+  set_saved_mark_word();\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  nonstatic_field(TenuredGeneration,                 _bts,                   SerialBlockOffsetSharedArray*) \\\n+  nonstatic_field(TenuredGeneration,                 _bts,                   SerialBlockOffsetTable*)       \\\n@@ -57,1 +57,3 @@\n-  nonstatic_field(SerialBlockOffsetTable,            _array,                 SerialBlockOffsetSharedArray*) \\\n+  nonstatic_field(SerialBlockOffsetTable,            _reserved,              MemRegion)                     \\\n+  nonstatic_field(SerialBlockOffsetTable,            _vs,                    VirtualSpace)                  \\\n+  nonstatic_field(SerialBlockOffsetTable,            _offset_base,           u_char*)                       \\\n@@ -59,5 +61,1 @@\n-  nonstatic_field(SerialBlockOffsetSharedArray,      _reserved,              MemRegion)                     \\\n-  nonstatic_field(SerialBlockOffsetSharedArray,      _vs,                    VirtualSpace)                  \\\n-  nonstatic_field(SerialBlockOffsetSharedArray,      _offset_base,           u_char*)                       \\\n-                                                                                                            \\\n-  nonstatic_field(TenuredSpace,                      _offsets,               SerialBlockOffsetTable)        \\\n+  nonstatic_field(TenuredSpace,                      _offsets,               SerialBlockOffsetTable*)       \\\n@@ -81,1 +79,0 @@\n-  declare_toplevel_type(SerialBlockOffsetSharedArray)                         \\\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-void AgeTable::print_age_table(uint tenuring_threshold) {\n+void AgeTable::print_age_table() {\n@@ -121,1 +121,1 @@\n-    print_on(&st, tenuring_threshold);\n+    print_on(&st);\n@@ -125,3 +125,2 @@\n-void AgeTable::print_on(outputStream* st, uint tenuring_threshold) {\n-  st->print_cr(\"Age table with threshold %u (max threshold %u)\",\n-               tenuring_threshold, MaxTenuringThreshold);\n+void AgeTable::print_on(outputStream* st) {\n+  st->print_cr(\"Age table:\");\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-  void print_age_table(uint tenuring_threshold);\n-  void print_on(outputStream* st, uint tenuring_threshold);\n+  void print_age_table();\n+  void print_on(outputStream* st);\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-public:\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -207,4 +207,1 @@\n-  while (cur < last) {\n-    *cur = dirty_card;\n-    cur++;\n-  }\n+  memset(cur, dirty_card, pointer_delta(last, cur, sizeof(CardValue)));\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-public:\n-\n-  typedef CardTable::CardValue CardValue;\n@@ -52,0 +49,1 @@\n+  typedef CardTable::CardValue CardValue;\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-                                             bool lock_codeblob_free_separately) :\n+                                             bool lock_nmethod_free_separately) :\n@@ -42,1 +42,1 @@\n-  _lock_codeblob_free_separately(lock_codeblob_free_separately) {\n+  _lock_nmethod_free_separately(lock_nmethod_free_separately) {\n@@ -126,1 +126,1 @@\n-void ClassUnloadingContext::free_code_blobs() {\n+void ClassUnloadingContext::free_nmethods() {\n@@ -162,1 +162,1 @@\n-  if (_lock_codeblob_free_separately) {\n+  if (_lock_nmethod_free_separately) {\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  bool _lock_codeblob_free_separately;\n+  bool _lock_nmethod_free_separately;\n@@ -56,2 +56,2 @@\n-  \/\/ lock_codeblob_free_separately determines whether freeing the code blobs takes\n-  \/\/     the CodeCache_lock during the whole operation (=false) or per code blob\n+  \/\/ lock_nmethod_free_separately determines whether freeing the nmethods takes\n+  \/\/     the CodeCache_lock during the whole operation (=false) or per nmethod\n@@ -61,1 +61,1 @@\n-                        bool lock_codeblob_free_separately);\n+                        bool lock_nmethod_free_separately);\n@@ -74,1 +74,1 @@\n-  void free_code_blobs();\n+  void free_nmethods();\n@@ -78,1 +78,1 @@\n-    free_code_blobs();\n+    free_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-  if (!Metaspace::contains(object->klass_raw())) {\n+  if (!Metaspace::contains(object->klass_without_asserts())) {\n@@ -465,1 +465,1 @@\n-  ObjArrayAllocator allocator(Universe::fillerArrayKlassObj(), words, (int)len, \/* do_zero *\/ false);\n+  ObjArrayAllocator allocator(Universe::fillerArrayKlass(), words, (int)len, \/* do_zero *\/ false);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -350,5 +350,0 @@\n-  \/\/ If a GC uses a stack watermark barrier, the stack processing is lazy, concurrent,\n-  \/\/ incremental and cooperative. In order for that to work well, mechanisms that stop\n-  \/\/ another thread might want to ensure its roots are in a sane state.\n-  virtual bool uses_stack_watermark_barrier() const { return false; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"code\/compiledMethod.hpp\"\n@@ -32,2 +31,2 @@\n-bool IsUnloadingBehaviour::is_unloading(CompiledMethod* cm) {\n-  if (cm->method()->can_be_allocated_in_NonNMethod_space()) {\n+bool IsUnloadingBehaviour::is_unloading(nmethod* nm) {\n+  if (nm->method()->can_be_allocated_in_NonNMethod_space()) {\n@@ -38,1 +37,1 @@\n-  return _current->has_dead_oop(cm) || cm->as_nmethod()->is_cold();\n+  return _current->has_dead_oop(nm) || nm->is_cold();\n@@ -73,8 +72,4 @@\n-bool ClosureIsUnloadingBehaviour::has_dead_oop(CompiledMethod* cm) const {\n-  if (cm->is_nmethod()) {\n-    IsCompiledMethodUnloadingOopClosure cl(_cl);\n-    static_cast<nmethod*>(cm)->oops_do(&cl, true \/* allow_dead *\/);\n-    return cl.is_unloading();\n-  } else {\n-    return false;\n-  }\n+bool ClosureIsUnloadingBehaviour::has_dead_oop(nmethod* nm) const {\n+  IsCompiledMethodUnloadingOopClosure cl(_cl);\n+  nm->oops_do(&cl, true \/* allow_dead *\/);\n+  return cl.is_unloading();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcBehaviours.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-\/\/ This is the behaviour for checking if a CompiledMethod is unloading\n+\/\/ This is the behaviour for checking if an nmethod is unloading\n@@ -37,2 +37,2 @@\n-  static bool is_unloading(CompiledMethod* cm);\n-  virtual bool has_dead_oop(CompiledMethod* cm) const = 0;\n+  static bool is_unloading(nmethod* nm);\n+  virtual bool has_dead_oop(nmethod* nm) const = 0;\n@@ -51,1 +51,1 @@\n-  virtual bool has_dead_oop(CompiledMethod* cm) const;\n+  virtual bool has_dead_oop(nmethod* nm) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcBehaviours.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-                 notproduct,                                                \\\n@@ -62,1 +61,0 @@\n-    notproduct,                                                             \\\n@@ -71,1 +69,0 @@\n-    notproduct,                                                             \\\n@@ -80,1 +77,0 @@\n-    notproduct,                                                             \\\n@@ -89,1 +85,0 @@\n-    notproduct,                                                             \\\n@@ -98,1 +93,0 @@\n-    notproduct,                                                             \\\n@@ -107,1 +101,0 @@\n-    notproduct,                                                             \\\n@@ -243,1 +236,1 @@\n-  notproduct(bool, ScavengeALot, false,                                     \\\n+  develop(bool, ScavengeALot, false,                                        \\\n@@ -251,1 +244,1 @@\n-  notproduct(bool, GCALotAtAllSafepoints, false,                            \\\n+  develop(bool, GCALotAtAllSafepoints, false,                               \\\n@@ -254,1 +247,1 @@\n-  notproduct(bool, PromotionFailureALot, false,                             \\\n+  develop(bool, PromotionFailureALot, false,                                \\\n@@ -510,3 +503,0 @@\n-  product(bool, VerifyObjectStartArray, true, DIAGNOSTIC,                   \\\n-          \"Verify GC object start array if verify before\/after\")            \\\n-                                                                            \\\n@@ -529,1 +519,1 @@\n-  notproduct(int, ScavengeALotInterval,     1,                              \\\n+  develop(int, ScavengeALotInterval,     1,                                 \\\n@@ -532,1 +522,1 @@\n-  notproduct(int, FullGCALotInterval,     1,                                \\\n+  develop(int, FullGCALotInterval,     1,                                   \\\n@@ -535,1 +525,1 @@\n-  notproduct(int, FullGCALotStart,     0,                                   \\\n+  develop(int, FullGCALotStart,     0,                                      \\\n@@ -538,1 +528,1 @@\n-  notproduct(int, FullGCALotDummies,  32*K,                                 \\\n+  develop(int, FullGCALotDummies,  32*K,                                    \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -48,1 +49,1 @@\n-  Klass* k = (Klass*)oopDesc::load_klass_raw((oopDesc*)obj);\n+  Klass* k = ((oopDesc*)obj)->klass_without_asserts();\n","filename":"src\/hotspot\/share\/gc\/shared\/locationPrinter.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -319,0 +319,1 @@\n+  \/\/ ...and clear or zap just allocated TLAB, if needed.\n@@ -320,1 +321,0 @@\n-    \/\/ ..and clear it.\n@@ -322,3 +322,1 @@\n-  } else {\n-    \/\/ ...and zap just allocated object.\n-#ifdef ASSERT\n+  } else if (ZapTLAB) {\n@@ -330,1 +328,0 @@\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  CompiledMethodIterator iter(CompiledMethodIterator::all_blobs);\n+  NMethodIterator iter(NMethodIterator::all);\n@@ -52,3 +52,3 @@\n-void CodeCacheUnloadingTask::claim_nmethods(CompiledMethod** claimed_nmethods, int *num_claimed_nmethods) {\n-  CompiledMethod* first;\n-  CompiledMethodIterator last(CompiledMethodIterator::all_blobs);\n+void CodeCacheUnloadingTask::claim_nmethods(nmethod** claimed_nmethods, int *num_claimed_nmethods) {\n+  nmethod* first;\n+  NMethodIterator last(NMethodIterator::all);\n@@ -60,1 +60,1 @@\n-    last = CompiledMethodIterator(CompiledMethodIterator::all_blobs, first);\n+    last = NMethodIterator(NMethodIterator::all, first);\n@@ -84,1 +84,1 @@\n-  CompiledMethod* claimed_nmethods[MaxClaimNmethods];\n+  nmethod* claimed_nmethods[MaxClaimNmethods];\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-  CompiledMethod* _first_nmethod;\n-  CompiledMethod* volatile _claimed_nmethod;\n+  nmethod* _first_nmethod;\n+  nmethod* volatile _claimed_nmethod;\n@@ -48,1 +48,1 @@\n-  void claim_nmethods(CompiledMethod** claimed_nmethods, int *num_claimed_nmethods);\n+  void claim_nmethods(nmethod** claimed_nmethods, int *num_claimed_nmethods);\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-void ScavengableNMethods::nmethods_do_and_prune(CodeBlobToOopClosure* cl) {\n+void ScavengableNMethods::nmethods_do_and_prune(NMethodToOopClosure* cl) {\n@@ -145,1 +145,1 @@\n-      cl->do_code_blob(cur);\n+      cl->do_nmethod(cur);\n@@ -160,1 +160,1 @@\n-  debug_only(verify_unlisted_nmethods(nullptr));\n+  debug_only(verify_nmethods());\n@@ -191,1 +191,1 @@\n-  debug_only(verify_unlisted_nmethods(nullptr));\n+  debug_only(verify_nmethods());\n@@ -195,1 +195,1 @@\n-void ScavengableNMethods::nmethods_do(CodeBlobToOopClosure* cl) {\n+void ScavengableNMethods::nmethods_do(NMethodToOopClosure* cl) {\n@@ -199,12 +199,0 @@\n-#ifndef PRODUCT\n-void ScavengableNMethods::asserted_non_scavengable_nmethods_do(CodeBlobClosure* cl) {\n-  \/\/ While we are here, verify the integrity of the list.\n-  mark_on_list_nmethods();\n-  for (nmethod* cur = _head; cur != nullptr; cur = gc_data(cur).next()) {\n-    assert(gc_data(cur).on_list(), \"else shouldn't be on this list\");\n-    gc_data(cur).clear_marked();\n-  }\n-  verify_unlisted_nmethods(cl);\n-}\n-#endif \/\/ PRODUCT\n-\n@@ -231,1 +219,1 @@\n-  NMethodIterator iter(NMethodIterator::all_blobs);\n+  NMethodIterator iter(NMethodIterator::all);\n@@ -242,4 +230,3 @@\n-\/\/ If the closure is given, run it on the unlisted nmethods.\n-\/\/ Also make sure that the effects of mark_on_list_nmethods is gone.\n-void ScavengableNMethods::verify_unlisted_nmethods(CodeBlobClosure* cl) {\n-  NMethodIterator iter(NMethodIterator::all_blobs);\n+\/\/ Make sure that the effects of mark_on_list_nmethods is gone.\n+void ScavengableNMethods::verify_nmethods() {\n+  NMethodIterator iter(NMethodIterator::all);\n@@ -253,4 +240,0 @@\n-\n-    if (cl != nullptr && !gc_data(nm).on_list()) {\n-      cl->do_code_blob(nm);\n-    }\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.cpp","additions":9,"deletions":26,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-class CodeBlobClosure;\n-class CodeBlobToOopClosure;\n@@ -35,0 +33,1 @@\n+class NMethodToOopClosure;\n@@ -56,3 +55,1 @@\n-  static void nmethods_do(CodeBlobToOopClosure* cl);\n-\n-  static void asserted_non_scavengable_nmethods_do(CodeBlobClosure* cl) PRODUCT_RETURN;\n+  static void nmethods_do(NMethodToOopClosure* cl);\n@@ -61,1 +58,1 @@\n-  static void nmethods_do_and_prune(CodeBlobToOopClosure* cl);\n+  static void nmethods_do_and_prune(NMethodToOopClosure* cl);\n@@ -67,1 +64,1 @@\n-  static void verify_unlisted_nmethods(CodeBlobClosure* cl) PRODUCT_RETURN;\n+  static void verify_nmethods() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-  set_saved_mark();\n@@ -196,1 +195,1 @@\n-  HeapWord* cur_block = _offsets.block_start_reaching_into_card(addr);\n+  HeapWord* cur_block = _offsets->block_start_reaching_into_card(addr);\n@@ -211,1 +210,1 @@\n-TenuredSpace::TenuredSpace(SerialBlockOffsetSharedArray* sharedOffsetArray,\n+TenuredSpace::TenuredSpace(SerialBlockOffsetTable* offsets,\n@@ -213,1 +212,1 @@\n-  _offsets(sharedOffsetArray)\n+  _offsets(offsets)\n@@ -217,4 +216,0 @@\n-\n-size_t TenuredSpace::allowed_dead_ratio() const {\n-  return MarkSweepDeadRatio;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,3 +68,0 @@\n-  \/\/ Used in support of save_marks()\n-  HeapWord* _saved_mark_word;\n-\n@@ -93,14 +90,0 @@\n-  HeapWord* saved_mark_word() const  { return _saved_mark_word; }\n-\n-  \/\/ Returns a region that is guaranteed to contain (at least) all objects\n-  \/\/ allocated at the time of the last call to \"save_marks\".  If the space\n-  \/\/ initializes its DirtyCardToOopClosure's specifying the \"contig\" option\n-  \/\/ (that is, if the space is contiguous), then this region must contain only\n-  \/\/ such objects: the memregion will be from the bottom of the region to the\n-  \/\/ saved mark.  Otherwise, the \"obj_allocated_since_save_marks\" method of\n-  \/\/ the space must distinguish between objects in the region allocated before\n-  \/\/ and after the call to save marks.\n-  MemRegion used_region_at_save_marks() const {\n-    return MemRegion(bottom(), saved_mark_word());\n-  }\n-\n@@ -155,4 +138,0 @@\n-  \/\/ The maximum percentage of objects that can be dead in the compacted\n-  \/\/ live part of a compacted space (\"deadwood\" support.)\n-  virtual size_t allowed_dead_ratio() const { return 0; };\n-\n@@ -163,4 +142,0 @@\n-  void set_saved_mark()            { _saved_mark_word = top();    }\n-\n-  bool saved_mark_at_top() const { return saved_mark_word() == top(); }\n-\n@@ -197,10 +172,0 @@\n-  \/\/ Apply \"blk->do_oop\" to the addresses of all reference fields in objects\n-  \/\/ starting with the _saved_mark_word, which was noted during a generation's\n-  \/\/ save_marks and is required to denote the head of an object.\n-  \/\/ Fields in objects allocated by applications of the closure\n-  \/\/ *are* included in the iteration.\n-  \/\/ Updates _saved_mark_word to point to just after the last object\n-  \/\/ iterated over.\n-  template <typename OopClosureType>\n-  void oop_since_save_marks_iterate(OopClosureType* blk);\n-\n@@ -228,1 +193,1 @@\n-  SerialBlockOffsetTable _offsets;\n+  SerialBlockOffsetTable* _offsets;\n@@ -230,2 +195,0 @@\n-  \/\/ Mark sweep support\n-  size_t allowed_dead_ratio() const override;\n@@ -234,1 +197,1 @@\n-  TenuredSpace(SerialBlockOffsetSharedArray* sharedOffsetArray,\n+  TenuredSpace(SerialBlockOffsetTable* offsets,\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":3,"deletions":40,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    _offsets.update_for_block(res, res + size);\n+    _offsets->update_for_block(res, res + size);\n@@ -49,1 +49,1 @@\n-    _offsets.update_for_block(res, res + size);\n+    _offsets->update_for_block(res, res + size);\n@@ -55,1 +55,1 @@\n-  _offsets.update_for_block(start, end);\n+  _offsets->update_for_block(start, end);\n@@ -59,19 +59,0 @@\n-template <typename OopClosureType>\n-void ContiguousSpace::oop_since_save_marks_iterate(OopClosureType* blk) {\n-  HeapWord* t;\n-  HeapWord* p = saved_mark_word();\n-  assert(p != nullptr, \"expected saved mark\");\n-\n-  const intx interval = PrefetchScanIntervalInBytes;\n-  do {\n-    t = top();\n-    while (p < t) {\n-      Prefetch::write(p, interval);\n-      oop m = cast_to_oop(p);\n-      p += m->oop_iterate_size(blk);\n-    }\n-  } while (t < top());\n-\n-  set_saved_mark();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,8 +42,2 @@\n-    \/\/ successful thread-local allocation\n-#ifdef ASSERT\n-    \/\/ Skip mangling the space corresponding to the object header to\n-    \/\/ ensure that the returned space is not considered parsable by\n-    \/\/ any concurrent GC thread.\n-    size_t hdr_size = oopDesc::header_size();\n-    Copy::fill_to_words(obj + hdr_size, size - hdr_size, badHeapWordVal);\n-#endif \/\/ ASSERT\n+    \/\/ Successful thread-local allocation.\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.inline.hpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-                   notproduct,                                              \\\n","filename":"src\/hotspot\/share\/gc\/shared\/tlab_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-  nonstatic_field(ContiguousSpace,             _saved_mark_word,                              HeapWord*)                             \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-class ShenandoahCodeBlobAndDisarmClosure: public CodeBlobToOopClosure {\n+class ShenandoahNMethodAndDisarmClosure: public NMethodToOopClosure {\n@@ -127,2 +127,2 @@\n-  inline ShenandoahCodeBlobAndDisarmClosure(OopClosure* cl);\n-  inline void do_code_blob(CodeBlob* cb);\n+  inline ShenandoahNMethodAndDisarmClosure(OopClosure* cl);\n+  inline void do_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -196,2 +196,2 @@\n-ShenandoahCodeBlobAndDisarmClosure::ShenandoahCodeBlobAndDisarmClosure(OopClosure* cl) :\n-  CodeBlobToOopClosure(cl, true \/* fix_relocations *\/),\n+ShenandoahNMethodAndDisarmClosure::ShenandoahNMethodAndDisarmClosure(OopClosure* cl) :\n+  NMethodToOopClosure(cl, true \/* fix_relocations *\/),\n@@ -201,7 +201,5 @@\n-void ShenandoahCodeBlobAndDisarmClosure::do_code_blob(CodeBlob* cb) {\n-  nmethod* const nm = cb->as_nmethod_or_null();\n-  if (nm != nullptr) {\n-    assert(!ShenandoahNMethod::gc_data(nm)->is_unregistered(), \"Should not be here\");\n-    CodeBlobToOopClosure::do_code_blob(cb);\n-    _bs->disarm(nm);\n-  }\n+void ShenandoahNMethodAndDisarmClosure::do_nmethod(nmethod* nm) {\n+  assert(nm != nullptr, \"Sanity\");\n+  assert(!ShenandoahNMethod::gc_data(nm)->is_unregistered(), \"Should not be here\");\n+  NMethodToOopClosure::do_nmethod(nm);\n+  _bs->disarm(nm);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-void ShenandoahCodeRootsIterator::possibly_parallel_blobs_do(CodeBlobClosure *f) {\n+void ShenandoahCodeRootsIterator::possibly_parallel_nmethods_do(NMethodClosure *f) {\n@@ -221,1 +221,1 @@\n-  _table_snapshot->parallel_blobs_do(f);\n+  _table_snapshot->parallel_nmethods_do(f);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  void possibly_parallel_blobs_do(CodeBlobClosure *f);\n+  void possibly_parallel_nmethods_do(NMethodClosure *f);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    _age_table->print_on(st, ShenandoahHeap::heap()->age_census()->tenuring_threshold());\n+    _age_table->print_on(st);\n@@ -120,1 +120,0 @@\n-    uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n@@ -122,1 +121,1 @@\n-    young_region_ages.print_on(st, tenuring_threshold);\n+    young_region_ages.print_on(st);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -958,0 +959,1 @@\n+  \/\/ ...and clear or zap just allocated TLAB, if needed.\n@@ -959,1 +961,0 @@\n-    \/\/ ..and clear it.\n@@ -961,3 +962,1 @@\n-  } else {\n-    \/\/ ...and zap just allocated object.\n-#ifdef ASSERT\n+  } else if (ZapTLAB) {\n@@ -969,1 +968,0 @@\n-#endif \/\/ ASSERT\n@@ -2275,1 +2273,1 @@\n-                            false \/* lock_codeblob_free_separately *\/);\n+                            false \/* lock_nmethod_free_separately *\/);\n@@ -2916,0 +2914,1 @@\n+  StackWatermarkSet::safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -627,5 +627,0 @@\n-\/\/ ---------- Concurrent Stack Processing support\n-\/\/\n-public:\n-  bool uses_stack_watermark_barrier() const override { return true; }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-void ShenandoahNMethodTableSnapshot::parallel_blobs_do(CodeBlobClosure *f) {\n+void ShenandoahNMethodTableSnapshot::parallel_nmethods_do(NMethodClosure *f) {\n@@ -450,1 +450,1 @@\n-      f->do_code_blob(nmr->nm());\n+      f->do_nmethod(nmr->nm());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  void parallel_blobs_do(CodeBlobClosure *f);\n+  void parallel_nmethods_do(NMethodClosure *f);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-void ShenandoahThreadRoots::oops_do(OopClosure* oops_cl, CodeBlobClosure* code_cl, uint worker_id) {\n+void ShenandoahThreadRoots::oops_do(OopClosure* oops_cl, NMethodClosure* code_cl, uint worker_id) {\n@@ -85,1 +85,1 @@\n-void ShenandoahCodeCacheRoots::code_blobs_do(CodeBlobClosure* blob_cl, uint worker_id) {\n+void ShenandoahCodeCacheRoots::nmethods_do(NMethodClosure* nmethod_cl, uint worker_id) {\n@@ -87,1 +87,1 @@\n-  _coderoots_iterator.possibly_parallel_blobs_do(blob_cl);\n+  _coderoots_iterator.possibly_parallel_nmethods_do(nmethod_cl);\n@@ -162,2 +162,2 @@\n-      CodeBlobToOopClosure blobs(oops, !CodeBlobToOopClosure::FixRelocations);\n-      _codecache_snapshot->parallel_blobs_do(&blobs);\n+      NMethodToOopClosure nmethods(oops, !NMethodToOopClosure::FixRelocations);\n+      _codecache_snapshot->parallel_nmethods_do(&nmethods);\n@@ -206,5 +206,5 @@\n-  CodeBlobToOopClosure code_blob_cl(oops, CodeBlobToOopClosure::FixRelocations);\n-  ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(oops);\n-  CodeBlobToOopClosure* adjust_code_closure = ShenandoahCodeRoots::use_nmethod_barriers_for_mark() ?\n-                                              static_cast<CodeBlobToOopClosure*>(&blobs_and_disarm_Cl) :\n-                                              static_cast<CodeBlobToOopClosure*>(&code_blob_cl);\n+  NMethodToOopClosure code_blob_cl(oops, NMethodToOopClosure::FixRelocations);\n+  ShenandoahNMethodAndDisarmClosure nmethods_and_disarm_Cl(oops);\n+  NMethodToOopClosure* adjust_code_closure = ShenandoahCodeRoots::use_nmethod_barriers_for_mark() ?\n+                                             static_cast<NMethodToOopClosure*>(&nmethods_and_disarm_Cl) :\n+                                             static_cast<NMethodToOopClosure*>(&code_blob_cl);\n@@ -219,1 +219,1 @@\n-  _code_roots.code_blobs_do(adjust_code_closure, worker_id);\n+  _code_roots.nmethods_do(adjust_code_closure, worker_id);\n@@ -232,1 +232,1 @@\n-class ShenandoahMarkCodeBlobClosure : public CodeBlobClosure {\n+class ShenandoahMarkNMethodClosure : public NMethodClosure {\n@@ -238,1 +238,1 @@\n-  ShenandoahMarkCodeBlobClosure(OopClosure* oops) :\n+  ShenandoahMarkNMethodClosure(OopClosure* oops) :\n@@ -242,10 +242,5 @@\n-  virtual void do_code_blob(CodeBlob* cb) {\n-    nmethod* const nm = cb->as_nmethod_or_null();\n-    if (nm != nullptr) {\n-      if (_bs_nm != nullptr) {\n-        \/\/ Make sure it only sees to-space objects\n-        _bs_nm->nmethod_entry_barrier(nm);\n-      }\n-      ShenandoahNMethod* const snm = ShenandoahNMethod::gc_data(nm);\n-      assert(snm != nullptr, \"Sanity\");\n-      snm->oops_do(_oops, false \/*fix_relocations*\/);\n+  virtual void do_nmethod(nmethod* nm) {\n+    assert(nm != nullptr, \"Sanity\");\n+    if (_bs_nm != nullptr) {\n+      \/\/ Make sure it only sees to-space objects\n+      _bs_nm->nmethod_entry_barrier(nm);\n@@ -253,0 +248,3 @@\n+    ShenandoahNMethod* const snm = ShenandoahNMethod::gc_data(nm);\n+    assert(snm != nullptr, \"Sanity\");\n+    snm->oops_do(_oops, false \/*fix_relocations*\/);\n@@ -259,1 +257,1 @@\n-  ShenandoahMarkCodeBlobClosure code(oops);\n+  ShenandoahMarkNMethodClosure code(oops);\n@@ -270,1 +268,1 @@\n-  _code_roots.code_blobs_do(&code, 0);\n+  _code_roots.nmethods_do(&code, 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  void oops_do(OopClosure* oops_cl, CodeBlobClosure* code_cl, uint worker_id);\n+  void oops_do(OopClosure* oops_cl, NMethodClosure* code_cl, uint worker_id);\n@@ -106,1 +106,1 @@\n-  void code_blobs_do(CodeBlobClosure* blob_cl, uint worker_id);\n+  void nmethods_do(NMethodClosure* nmethod_cl, uint worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-  CodeBlobClosure* _cf;\n+  NMethodClosure* _cf;\n@@ -133,1 +133,1 @@\n-  ShenandoahParallelOopsDoThreadClosure(OopClosure* f, CodeBlobClosure* cf, ThreadClosure* thread_cl) :\n+  ShenandoahParallelOopsDoThreadClosure(OopClosure* f, NMethodClosure* cf, ThreadClosure* thread_cl) :\n@@ -155,1 +155,1 @@\n-  MarkingCodeBlobClosure blobs_cl(oops, !CodeBlobToOopClosure::FixRelocations, true \/*FIXME*\/);\n+  MarkingNMethodClosure nmethods_cl(oops, !NMethodToOopClosure::FixRelocations, true \/*FIXME*\/);\n@@ -160,1 +160,1 @@\n-    _thread_roots.oops_do(oops, &blobs_cl, worker_id);\n+    _thread_roots.oops_do(oops, &nmethods_cl, worker_id);\n@@ -164,1 +164,1 @@\n-    _code_roots.code_blobs_do(&blobs_cl, worker_id);\n+    _code_roots.nmethods_do(&nmethods_cl, worker_id);\n@@ -173,5 +173,5 @@\n-  CodeBlobToOopClosure update_blobs(keep_alive, CodeBlobToOopClosure::FixRelocations);\n-  ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(keep_alive);\n-  CodeBlobToOopClosure* codes_cl = ShenandoahCodeRoots::use_nmethod_barriers_for_mark() ?\n-                                   static_cast<CodeBlobToOopClosure*>(&blobs_and_disarm_Cl) :\n-                                   static_cast<CodeBlobToOopClosure*>(&update_blobs);\n+  NMethodToOopClosure update_nmethods(keep_alive, NMethodToOopClosure::FixRelocations);\n+  ShenandoahNMethodAndDisarmClosure nmethods_and_disarm_Cl(keep_alive);\n+  NMethodToOopClosure* codes_cl = ShenandoahCodeRoots::use_nmethod_barriers_for_mark() ?\n+                                  static_cast<NMethodToOopClosure*>(&nmethods_and_disarm_Cl) :\n+                                  static_cast<NMethodToOopClosure*>(&update_nmethods);\n@@ -187,1 +187,1 @@\n-  _code_roots.code_blobs_do(codes_cl, worker_id);\n+  _code_roots.nmethods_do(codes_cl, worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.inline.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-  CodeBlobToOopClosure blobs(oops, !CodeBlobToOopClosure::FixRelocations);\n-  CodeCache::blobs_do(&blobs);\n+  NMethodToOopClosure blobs(oops, !NMethodToOopClosure::FixRelocations);\n+  CodeCache::nmethods_do(&blobs);\n@@ -104,2 +104,2 @@\n-  CodeBlobToOopClosure blobs(oops, !CodeBlobToOopClosure::FixRelocations);\n-  Threads::possibly_parallel_oops_do(true, oops, &blobs);\n+  NMethodToOopClosure nmethods(oops, !NMethodToOopClosure::FixRelocations);\n+  Threads::possibly_parallel_oops_do(true, oops, &nmethods);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-ShenandoahOnStackCodeBlobClosure::ShenandoahOnStackCodeBlobClosure() :\n+ShenandoahOnStackNMethodClosure::ShenandoahOnStackNMethodClosure() :\n@@ -42,6 +42,4 @@\n-void ShenandoahOnStackCodeBlobClosure::do_code_blob(CodeBlob* cb) {\n-  nmethod* const nm = cb->as_nmethod_or_null();\n-  if (nm != nullptr) {\n-    const bool result = _bs_nm->nmethod_entry_barrier(nm);\n-    assert(result, \"NMethod on-stack must be alive\");\n-  }\n+void ShenandoahOnStackNMethodClosure::do_nmethod(nmethod* nm) {\n+  assert(nm != nullptr, \"Sanity\");\n+  const bool result = _bs_nm->nmethod_entry_barrier(nm);\n+  assert(result, \"NMethod on-stack must be alive\");\n@@ -69,1 +67,1 @@\n-  _cb_cl() {}\n+  _nm_cl() {}\n@@ -105,1 +103,1 @@\n-    _jt->oops_do_no_frames(closure_from_context(context), &_cb_cl);\n+    _jt->oops_do_no_frames(closure_from_context(context), &_nm_cl);\n@@ -112,1 +110,1 @@\n-    _jt->oops_do_no_frames(closure_from_context(context), &_cb_cl);\n+    _jt->oops_do_no_frames(closure_from_context(context), &_nm_cl);\n@@ -139,1 +137,1 @@\n-  fr.oops_do(oops, &_cb_cl, &register_map, DerivedPointerIterationMode::_directly);\n+  fr.oops_do(oops, &_nm_cl, &register_map, DerivedPointerIterationMode::_directly);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStackWatermark.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-class ShenandoahOnStackCodeBlobClosure : public CodeBlobClosure {\n+class ShenandoahOnStackNMethodClosure : public NMethodClosure {\n@@ -45,1 +45,1 @@\n-  void do_code_blob(CodeBlob* cb);\n+  void do_nmethod(nmethod* nm);\n@@ -47,1 +47,1 @@\n-  ShenandoahOnStackCodeBlobClosure();\n+  ShenandoahOnStackNMethodClosure();\n@@ -59,1 +59,1 @@\n-  ShenandoahOnStackCodeBlobClosure     _cb_cl;\n+  ShenandoahOnStackNMethodClosure      _nm_cl;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStackWatermark.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,2 +82,1 @@\n-  virtual bool has_dead_oop(CompiledMethod* method) const {\n-    nmethod* const nm = method->as_nmethod();\n+  virtual bool has_dead_oop(nmethod* nm) const {\n@@ -94,2 +94,1 @@\n-  virtual bool lock(CompiledMethod* method) {\n-    nmethod* const nm = method->as_nmethod();\n+  virtual bool lock(nmethod* nm) {\n@@ -102,2 +101,1 @@\n-  virtual void unlock(CompiledMethod* method) {\n-    nmethod* const nm = method->as_nmethod();\n+  virtual void unlock(nmethod* nm) {\n@@ -109,2 +107,2 @@\n-  virtual bool is_safe(CompiledMethod* method) {\n-    if (SafepointSynchronize::is_at_safepoint() || method->is_unloading()) {\n+  virtual bool is_safe(nmethod* nm) {\n+    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading()) {\n@@ -114,1 +112,0 @@\n-    nmethod* const nm = method->as_nmethod();\n@@ -145,1 +142,1 @@\n-                            true \/* lock_codeblob_free_separately *\/);\n+                            true \/* lock_nmethod_free_separately *\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-                            notproduct,                                     \\\n@@ -593,1 +592,1 @@\n-  notproduct(bool, ShenandoahEnableCardStats, false,                        \\\n+  develop(bool, ShenandoahEnableCardStats, false,                           \\\n@@ -596,1 +595,1 @@\n-  notproduct(int, ShenandoahCardStatsLogInterval, 50,                       \\\n+  develop(int, ShenandoahCardStatsLogInterval, 50,                          \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -218,4 +219,0 @@\n-bool XCollectedHeap::uses_stack_watermark_barrier() const {\n-  return true;\n-}\n-\n@@ -280,0 +277,1 @@\n+  StackWatermarkSet::safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/gc\/x\/xCollectedHeap.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,0 @@\n-  bool uses_stack_watermark_barrier() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/x\/xCollectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-                            true \/* lock_codeblob_free_separately *\/);\n+                            true \/* lock_nmethod_free_separately *\/);\n","filename":"src\/hotspot\/share\/gc\/x\/xHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,2 +306,2 @@\n-  OopClosure* const        _cl;\n-  CodeBlobToNMethodClosure _cb_cl;\n+  OopClosure* const     _cl;\n+  NMethodClosure* const _nm_cl;\n@@ -312,1 +312,1 @@\n-      _cb_cl(nm_cl) {}\n+      _nm_cl(nm_cl) {}\n@@ -315,1 +315,1 @@\n-    thread->oops_do(_cl, &_cb_cl);\n+    thread->oops_do(_cl, _nm_cl);\n","filename":"src\/hotspot\/share\/gc\/x\/xHeapIterator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-XOnStackCodeBlobClosure::XOnStackCodeBlobClosure() :\n+XOnStackNMethodClosure::XOnStackNMethodClosure() :\n@@ -39,6 +39,3 @@\n-void XOnStackCodeBlobClosure::do_code_blob(CodeBlob* cb) {\n-  nmethod* const nm = cb->as_nmethod_or_null();\n-  if (nm != nullptr) {\n-    const bool result = _bs_nm->nmethod_entry_barrier(nm);\n-    assert(result, \"NMethod on-stack must be alive\");\n-  }\n+void XOnStackNMethodClosure::do_nmethod(nmethod* nm) {\n+  const bool result = _bs_nm->nmethod_entry_barrier(nm);\n+  assert(result, \"NMethod on-stack must be alive\");\n@@ -58,1 +55,1 @@\n-    _cb_cl(),\n+    _nm_cl(),\n@@ -75,1 +72,1 @@\n-  _jt->oops_do_no_frames(closure_from_context(context), &_cb_cl);\n+  _jt->oops_do_no_frames(closure_from_context(context), &_nm_cl);\n@@ -98,1 +95,1 @@\n-  fr.oops_do(closure_from_context(context), &_cb_cl, &register_map, DerivedPointerIterationMode::_directly);\n+  fr.oops_do(closure_from_context(context), &_nm_cl, &register_map, DerivedPointerIterationMode::_directly);\n","filename":"src\/hotspot\/share\/gc\/x\/xStackWatermark.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-class XOnStackCodeBlobClosure : public CodeBlobClosure {\n+class XOnStackNMethodClosure : public NMethodClosure {\n@@ -44,1 +44,1 @@\n-  virtual void do_code_blob(CodeBlob* cb);\n+  virtual void do_nmethod(nmethod* nm);\n@@ -47,1 +47,1 @@\n-  XOnStackCodeBlobClosure();\n+  XOnStackNMethodClosure();\n@@ -52,3 +52,3 @@\n-  XLoadBarrierOopClosure  _jt_cl;\n-  XOnStackCodeBlobClosure _cb_cl;\n-  ThreadLocalAllocStats   _stats;\n+  XLoadBarrierOopClosure _jt_cl;\n+  XOnStackNMethodClosure _nm_cl;\n+  ThreadLocalAllocStats  _stats;\n","filename":"src\/hotspot\/share\/gc\/x\/xStackWatermark.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,2 +78,1 @@\n-  virtual bool has_dead_oop(CompiledMethod* method) const {\n-    nmethod* const nm = method->as_nmethod();\n+  virtual bool has_dead_oop(nmethod* nm) const {\n@@ -90,2 +89,1 @@\n-  virtual bool lock(CompiledMethod* method) {\n-    nmethod* const nm = method->as_nmethod();\n+  virtual bool lock(nmethod* nm) {\n@@ -97,2 +95,1 @@\n-  virtual void unlock(CompiledMethod* method) {\n-    nmethod* const nm = method->as_nmethod();\n+  virtual void unlock(nmethod* nm) {\n@@ -103,2 +100,2 @@\n-  virtual bool is_safe(CompiledMethod* method) {\n-    if (SafepointSynchronize::is_at_safepoint() || method->is_unloading()) {\n+  virtual bool is_safe(nmethod* nm) {\n+    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading()) {\n@@ -108,1 +105,0 @@\n-    nmethod* const nm = method->as_nmethod();\n","filename":"src\/hotspot\/share\/gc\/x\/xUnload.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -100,10 +100,0 @@\n-class XVerifyCodeBlobClosure : public CodeBlobToOopClosure {\n-public:\n-  XVerifyCodeBlobClosure(XVerifyRootClosure* _cl) :\n-      CodeBlobToOopClosure(_cl, false \/* fix_relocations *\/) {}\n-\n-  virtual void do_code_blob(CodeBlob* cb) {\n-    CodeBlobToOopClosure::do_code_blob(cb);\n-  }\n-};\n-\n@@ -169,1 +159,1 @@\n-    XVerifyCodeBlobClosure cb_cl(_cl);\n+    NMethodToOopClosure nm_cl(_cl, false \/* fix_relocations *\/);\n@@ -174,1 +164,1 @@\n-      frame.oops_do(this, &cb_cl, frames.register_map(), DerivedPointerIterationMode::_ignore);\n+      frame.oops_do(this, &nm_cl, frames.register_map(), DerivedPointerIterationMode::_ignore);\n","filename":"src\/hotspot\/share\/gc\/x\/xVerify.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-                   notproduct,                                       \\\n","filename":"src\/hotspot\/share\/gc\/x\/x_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-                          notproduct,                                       \\\n@@ -95,1 +94,0 @@\n-    notproduct,                                                             \\\n@@ -104,1 +102,0 @@\n-    notproduct,                                                             \\\n","filename":"src\/hotspot\/share\/gc\/z\/shared\/z_shared_globals.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,1 +251,0 @@\n-  static zpointer set_remset_bits(zpointer ptr);\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,4 @@\n+inline bool operator<=(zoffset_end first, zoffset second) {\n+  return untype(first) <= untype(second);\n+}\n+\n@@ -457,7 +461,0 @@\n-inline zpointer ZPointer::set_remset_bits(zpointer ptr) {\n-  uintptr_t raw_addr = untype(ptr);\n-  assert(raw_addr != 0, \"raw nulls should have been purged in promotion to old gen\");\n-  raw_addr |= ZPointerRemembered0 | ZPointerRemembered1;\n-  return to_zpointer(raw_addr);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,0 @@\n-  friend class ZAllocatorEden;\n-  friend class ZAllocatorSurvivor;\n-  friend class ZAllocatorOld;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -243,4 +244,0 @@\n-bool ZCollectedHeap::uses_stack_watermark_barrier() const {\n-  return true;\n-}\n-\n@@ -341,0 +338,1 @@\n+  StackWatermarkSet::safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,2 +91,0 @@\n-  bool uses_stack_watermark_barrier() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1326,1 +1326,1 @@\n-                            true \/* lock_codeblob_free_separately *\/);\n+                            true \/* lock_nmethod_free_separately *\/);\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -378,2 +378,2 @@\n-  OopClosure* const        _cl;\n-  CodeBlobToNMethodClosure _cb_cl;\n+  OopClosure* const     _cl;\n+  NMethodClosure* const _nm_cl;\n@@ -384,1 +384,1 @@\n-      _cb_cl(nm_cl) {}\n+      _nm_cl(nm_cl) {}\n@@ -387,1 +387,1 @@\n-    thread->oops_do(_cl, &_cb_cl);\n+    thread->oops_do(_cl, _nm_cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -309,0 +309,1 @@\n+  assert(nm != nullptr, \"did not find nmethod\");\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,3 +35,3 @@\n-  zoffset _start;\n-  zoffset _end;\n-  bool    _committed;\n+  zoffset     _start;\n+  zoffset_end _end;\n+  bool        _committed;\n@@ -44,1 +44,1 @@\n-  zoffset end() const;\n+  zoffset_end end() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemory.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    _end(zoffset(UINTPTR_MAX)),\n+    _end(zoffset_end(UINTPTR_MAX)),\n@@ -39,1 +39,1 @@\n-    _end(start + size),\n+    _end(to_zoffset_end(start, size)),\n@@ -46,1 +46,1 @@\n-inline zoffset ZPhysicalMemorySegment::end() const {\n+inline zoffset_end ZPhysicalMemorySegment::end() const {\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemory.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-ZOnStackCodeBlobClosure::ZOnStackCodeBlobClosure()\n+ZOnStackNMethodClosure::ZOnStackNMethodClosure()\n@@ -43,6 +43,4 @@\n-void ZOnStackCodeBlobClosure::do_code_blob(CodeBlob* cb) {\n-  nmethod* const nm = cb->as_nmethod_or_null();\n-  if (nm != nullptr) {\n-    const bool result = _bs_nm->nmethod_entry_barrier(nm);\n-    assert(result, \"NMethod on-stack must be alive\");\n-  }\n+void ZOnStackNMethodClosure::do_nmethod(nmethod* nm) {\n+  assert(nm != nullptr, \"Sanity\");\n+  const bool result = _bs_nm->nmethod_entry_barrier(nm);\n+  assert(result, \"NMethod on-stack must be alive\");\n@@ -169,1 +167,1 @@\n-  ZOnStackCodeBlobClosure cb_cl;\n+  ZOnStackNMethodClosure nm_cl;\n@@ -171,1 +169,1 @@\n-  _jt->oops_do_no_frames(&cl, &cb_cl);\n+  _jt->oops_do_no_frames(&cl, &nm_cl);\n@@ -212,1 +210,1 @@\n-  ZOnStackCodeBlobClosure cb_cl;\n+  ZOnStackNMethodClosure nm_cl;\n@@ -214,1 +212,1 @@\n-  fr.oops_do(&cl, &cb_cl, &register_map, DerivedPointerIterationMode::_directly);\n+  fr.oops_do(&cl, &nm_cl, &register_map, DerivedPointerIterationMode::_directly);\n","filename":"src\/hotspot\/share\/gc\/z\/zStackWatermark.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-class ZOnStackCodeBlobClosure : public CodeBlobClosure {\n+class ZOnStackNMethodClosure : public NMethodClosure {\n@@ -45,1 +45,1 @@\n-  virtual void do_code_blob(CodeBlob* cb);\n+  virtual void do_nmethod(nmethod* nm);\n@@ -48,1 +48,1 @@\n-  ZOnStackCodeBlobClosure();\n+  ZOnStackNMethodClosure();\n","filename":"src\/hotspot\/share\/gc\/z\/zStackWatermark.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,1 @@\n-  virtual bool has_dead_oop(CompiledMethod* method) const {\n-    nmethod* const nm = method->as_nmethod();\n+  virtual bool has_dead_oop(nmethod* nm) const {\n@@ -93,2 +92,1 @@\n-  virtual bool lock(CompiledMethod* method) {\n-    nmethod* const nm = method->as_nmethod();\n+  virtual bool lock(nmethod* nm) {\n@@ -100,2 +98,1 @@\n-  virtual void unlock(CompiledMethod* method) {\n-    nmethod* const nm = method->as_nmethod();\n+  virtual void unlock(nmethod* nm) {\n@@ -106,2 +103,2 @@\n-  virtual bool is_safe(CompiledMethod* method) {\n-    if (SafepointSynchronize::is_at_safepoint() || method->is_unloading()) {\n+  virtual bool is_safe(nmethod* nm) {\n+    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading()) {\n@@ -111,1 +108,0 @@\n-    nmethod* const nm = method->as_nmethod();\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -243,10 +243,0 @@\n-class ZVerifyCodeBlobClosure : public CodeBlobToOopClosure {\n-public:\n-  ZVerifyCodeBlobClosure(OopClosure* cl)\n-    : CodeBlobToOopClosure(cl, false \/* fix_relocations *\/) {}\n-\n-  virtual void do_code_blob(CodeBlob* cb) {\n-    CodeBlobToOopClosure::do_code_blob(cb);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-                   notproduct,                                              \\\n","filename":"src\/hotspot\/share\/gc\/z\/z_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1610,1 +1610,1 @@\n-          if (arrObj->klass() == Universe::boolArrayKlassObj()) {\n+          if (arrObj->klass() == Universe::boolArrayKlass()) {\n@@ -1613,1 +1613,1 @@\n-            assert(arrObj->klass() == Universe::byteArrayKlassObj(),\n+            assert(arrObj->klass() == Universe::byteArrayKlass(),\n@@ -1994,5 +1994,3 @@\n-              \/\/ Initialize object field block:\n-              \/\/   - if TLAB is pre-zeroed, we can skip this path\n-              \/\/   - in debug mode, ThreadLocalAllocBuffer::allocate mangles\n-              \/\/     this area, and we still need to initialize it\n-              if (DEBUG_ONLY(true ||) !ZeroTLAB) {\n+              \/\/ Initialize object field block.\n+              if (!ZeroTLAB) {\n+                \/\/ The TLAB was not pre-zeroed, we need to clear the memory here.\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-  writer->write(cld_id(get_cld(Universe::boolArrayKlassObj()), false));\n+  writer->write(cld_id(get_cld(Universe::boolArrayKlass()), false));\n@@ -455,1 +455,1 @@\n-  writer->write(package_id(Universe::boolArrayKlassObj(), false));\n+  writer->write(package_id(Universe::boolArrayKlass(), false));\n@@ -471,8 +471,8 @@\n-  write_primitive(_writer, Universe::boolArrayKlassObj());\n-  write_primitive(_writer, Universe::byteArrayKlassObj());\n-  write_primitive(_writer, Universe::charArrayKlassObj());\n-  write_primitive(_writer, Universe::shortArrayKlassObj());\n-  write_primitive(_writer, Universe::intArrayKlassObj());\n-  write_primitive(_writer, Universe::longArrayKlassObj());\n-  write_primitive(_writer, Universe::floatArrayKlassObj());\n-  write_primitive(_writer, Universe::doubleArrayKlassObj());\n+  write_primitive(_writer, Universe::boolArrayKlass());\n+  write_primitive(_writer, Universe::byteArrayKlass());\n+  write_primitive(_writer, Universe::charArrayKlass());\n+  write_primitive(_writer, Universe::shortArrayKlass());\n+  write_primitive(_writer, Universe::intArrayKlass());\n+  write_primitive(_writer, Universe::longArrayKlass());\n+  write_primitive(_writer, Universe::floatArrayKlass());\n+  write_primitive(_writer, Universe::doubleArrayKlass());\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -488,2 +488,2 @@\n-  bool isLongArray = klass == Universe::longArrayKlassObj();\n-  bool isByteArray = klass == Universe::byteArrayKlassObj();\n+  bool isLongArray = klass == Universe::longArrayKlass();\n+  bool isByteArray = klass == Universe::byteArrayKlass();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,3 +232,6 @@\n-      const char* disable_msg = err_msg(\"JVMCI compiler disabled \"\n-      \"after %d of %d upcalls had errors (Last error: \\\"%s\\\"). \"\n-      \"Use -Xlog:jit+compilation for more detail.\", err, total, error);\n+      \/\/ Using stringStream instead of err_msg to avoid truncation\n+      stringStream st;\n+      st.print(\"JVMCI compiler disabled \"\n+               \"after %d of %d upcalls had errors (Last error: \\\"%s\\\"). \"\n+               \"Use -Xlog:jit+compilation for more detail.\", err, total, error);\n+      const char* disable_msg = st.freeze();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -639,1 +639,1 @@\n-        resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(ss.type()))->array_klass(ndim, CHECK_NULL);\n+        resolved_klass = Universe::typeArrayKlass(ss.type())->array_klass(ndim, CHECK_NULL);\n@@ -659,1 +659,1 @@\n-    array_klass = Universe::typeArrayKlassObj(type);\n+    array_klass = Universe::typeArrayKlass(type);\n@@ -1308,1 +1308,1 @@\n-  CompiledMethod* code = method->code();\n+  nmethod* code = method->code();\n@@ -1753,2 +1753,1 @@\n-    assert(fst.current()->cb()->is_nmethod(), \"nmethod expected\");\n-    ((nmethod*) fst.current()->cb())->make_not_entrant();\n+    fst.current()->cb()->as_nmethod()->make_not_entrant();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -43,1 +44,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n@@ -242,2 +242,4 @@\n-  JVMCI_THROW_MSG(InternalError, err_msg(\"Error creating or attaching to libjvmci (err: %d, description: %s)\",\n-                  _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg));\n+  stringStream st;\n+  st.print(\"Error creating or attaching to libjvmci (err: %d, description: %s)\",\n+           _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg);\n+  JVMCI_THROW_MSG(InternalError, st.freeze());\n@@ -253,2 +255,4 @@\n-  THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), err_msg(\"Error creating or attaching to libjvmci (err: %d, description: %s)\",\n-            _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg));\n+  stringStream st;\n+  st.print(\"Error creating or attaching to libjvmci (err: %d, description: %s)\",\n+           _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg);\n+  THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), st.freeze());\n@@ -414,0 +418,5 @@\n+  static bool debug_translated_exception() {\n+      const char* prop_value = Arguments::get_property(\"jdk.internal.vm.TranslatedException.debug\");\n+      return prop_value != nullptr && strcmp(\"true\", prop_value) == 0;\n+  }\n+\n@@ -509,1 +518,1 @@\n-                                format, buffer, false);\n+                                format, buffer, false, debug_translated_exception());\n@@ -542,0 +551,1 @@\n+    jargs.push_int(debug_translated_exception());\n@@ -1423,1 +1433,1 @@\n-    Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())->array_klass(CHECK_(JVMCIObject()));\n+    Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlass())->array_klass(CHECK_(JVMCIObject()));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* current, oopDesc* ex, address pc, CompiledMethod*& cm))\n+JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* current, oopDesc* ex, address pc, nmethod*& nm))\n@@ -270,2 +270,2 @@\n-  cm = CodeCache::find_compiled(pc);\n-  assert(cm != nullptr, \"this is not a compiled method\");\n+  nm = CodeCache::find_nmethod(pc);\n+  assert(nm != nullptr, \"did not find nmethod\");\n@@ -273,1 +273,1 @@\n-  if (cm->is_deopt_pc(pc)) {\n+  if (nm->is_deopt_pc(pc)) {\n@@ -294,1 +294,1 @@\n-    assert(cm->method() != nullptr, \"Unexpected null method()\");\n+    assert(nm->method() != nullptr, \"Unexpected null method()\");\n@@ -297,1 +297,1 @@\n-                 cm->method()->print_value_string(), p2i(pc), p2i(current));\n+                 nm->method()->print_value_string(), p2i(pc), p2i(current));\n@@ -335,1 +335,1 @@\n-    address fast_continuation = cm->handler_for_exception_and_pc(exception, pc);\n+    address fast_continuation = nm->handler_for_exception_and_pc(exception, pc);\n@@ -338,1 +338,1 @@\n-      current->set_is_method_handle_return(cm->is_method_handle_return(pc));\n+      current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -359,1 +359,1 @@\n-    continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);\n+    continuation = SharedRuntime::compute_compiled_exc_handler(nm, pc, exception, false, false, recursive_exception);\n@@ -371,1 +371,1 @@\n-      cm->add_handler_for_exception_and_pc(exception, pc, continuation);\n+      nm->add_handler_for_exception_and_pc(exception, pc, continuation);\n@@ -376,1 +376,1 @@\n-  current->set_is_method_handle_return(cm->is_method_handle_return(pc));\n+  current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -398,1 +398,1 @@\n-  CompiledMethod* cm = nullptr;\n+  nmethod* nm = nullptr;\n@@ -403,1 +403,1 @@\n-    continuation = exception_handler_for_pc_helper(current, exception, pc, cm);\n+    continuation = exception_handler_for_pc_helper(current, exception, pc, nm);\n@@ -409,1 +409,1 @@\n-  if (cm != nullptr && caller_is_deopted()) {\n+  if (nm != nullptr && caller_is_deopted()) {\n@@ -678,1 +678,1 @@\n-        tty->print(\"%s [\" INTPTR_FORMAT \"+\" JLONG_FORMAT \"]\", cb->as_nmethod_or_null()->method()->name_and_sig_as_C_string(buf, O_BUFLEN), p2i(cb->code_begin()), (jlong)((address)v - cb->code_begin()));\n+        tty->print(\"%s [\" INTPTR_FORMAT \"+\" JLONG_FORMAT \"]\", cb->as_nmethod()->method()->name_and_sig_as_C_string(buf, O_BUFLEN), p2i(cb->code_begin()), (jlong)((address)v - cb->code_begin()));\n@@ -1976,1 +1976,4 @@\n-    const char* failure_reason = os::strdup(err_msg(\"uncaught exception in %s [%s]\", function, pending_string), mtJVMCI);\n+    \/\/ Using stringStream instead of err_msg to avoid truncation\n+    stringStream st;\n+    st.print(\"uncaught exception in %s [%s]\", function, pending_string);\n+    const char* failure_reason = os::strdup(st.freeze(), mtJVMCI);\n@@ -2208,1 +2211,1 @@\n-            CompiledMethod* old = method->code();\n+            nmethod* old = method->code();\n@@ -2226,1 +2229,1 @@\n-            MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+            MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n@@ -2240,1 +2243,1 @@\n-            MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+            MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n@@ -2249,1 +2252,1 @@\n-          MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+          MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":23,"deletions":20,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  JVMCI_FLAGS(params4, params3, params4, params3, params4, IGNORE_RANGE, IGNORE_CONSTRAINT)\n+  JVMCI_FLAGS(params4, params3, params4, params3, IGNORE_RANGE, IGNORE_CONSTRAINT)\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-                    notproduct,                                             \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-  volatile_nonstatic_field(Method,             _code,                                         CompiledMethod*)                       \\\n+  volatile_nonstatic_field(Method,             _code,                                         nmethod*)                              \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -617,1 +617,1 @@\n-  out->print_cr(\"  If the filename contains %%p and\/or %%t, they will expand to the JVM's PID and startup timestamp, respectively.\");\n+  out->print_cr(\"  If the filename contains %%p, %%t and\/or %%hn, they will expand to the JVM's PID, startup timestamp and host name, respectively.\");\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+const char* const LogFileOutput::HostnameFilenamePlaceholder = \"%hn\";\n@@ -381,0 +382,1 @@\n+  char hostname_string[HostnameBufferSize];\n@@ -383,1 +385,1 @@\n-  \/\/ Lets start finding out if we have any %d and\/or %t in the name.\n+  \/\/ Lets start finding out if we have any %p, %t and\/or %hn in the name.\n@@ -387,0 +389,1 @@\n+  const char* hostname = strstr(file_name, HostnameFilenamePlaceholder);\n@@ -388,1 +391,1 @@\n-  if (pid == nullptr && timestamp == nullptr) {\n+  if (pid == nullptr && timestamp == nullptr && hostname == nullptr) {\n@@ -394,9 +397,1 @@\n-  const char* first = \"\";\n-  size_t first_pos = SIZE_MAX;\n-  size_t first_replace_len = 0;\n-\n-  const char* second = \"\";\n-  size_t second_pos = SIZE_MAX;\n-  size_t second_replace_len = 0;\n-\n-  \/\/ If we found a %p, then setup our variables accordingly\n+  size_t result_len =  strlen(file_name);\n@@ -404,9 +399,2 @@\n-    if (timestamp == nullptr || pid < timestamp) {\n-      first = pid_string;\n-      first_pos = pid - file_name;\n-      first_replace_len = strlen(PidFilenamePlaceholder);\n-    } else {\n-      second = pid_string;\n-      second_pos = pid - file_name;\n-      second_replace_len = strlen(PidFilenamePlaceholder);\n-    }\n+    result_len -= strlen(PidFilenamePlaceholder);\n+    result_len += strlen(pid_string);\n@@ -414,1 +402,0 @@\n-\n@@ -416,8 +403,7 @@\n-    if (pid == nullptr || timestamp < pid) {\n-      first = timestamp_string;\n-      first_pos = timestamp - file_name;\n-      first_replace_len = strlen(TimestampFilenamePlaceholder);\n-    } else {\n-      second = timestamp_string;\n-      second_pos = timestamp - file_name;\n-      second_replace_len = strlen(TimestampFilenamePlaceholder);\n+    result_len -= strlen(TimestampFilenamePlaceholder);\n+    result_len += strlen(timestamp_string);\n+  }\n+  if (hostname != nullptr) {\n+    if (!os::get_host_name(hostname_string, sizeof(hostname_string))) {\n+      int res = jio_snprintf(hostname_string, sizeof(hostname_string), \"unknown-host\");\n+      assert(res > 0, \"Hostname buffer too small\");\n@@ -425,0 +411,2 @@\n+    result_len -= strlen(HostnameFilenamePlaceholder);\n+    result_len += strlen(hostname_string);\n@@ -426,4 +414,0 @@\n-\n-  size_t first_len = strlen(first);\n-  size_t second_len = strlen(second);\n-\n@@ -431,1 +415,0 @@\n-  size_t result_len =  strlen(file_name) + first_len - first_replace_len + second_len - second_replace_len;\n@@ -438,16 +421,29 @@\n-    if (file_name_pos == first_pos) {\n-      \/\/ We are in the range of the first placeholder\n-      strcpy(result + i, first);\n-      \/\/ Bump output buffer position with length of replacing string\n-      i += first_len;\n-      \/\/ Bump source buffer position to skip placeholder\n-      file_name_pos += first_replace_len;\n-    } else if (file_name_pos == second_pos) {\n-      \/\/ We are in the range of the second placeholder\n-      strcpy(result + i, second);\n-      i += second_len;\n-      file_name_pos += second_replace_len;\n-    } else {\n-      \/\/ Else, copy char by char of the original file\n-      result[i] = file_name[file_name_pos++];\n-      i++;\n+    if (file_name[file_name_pos] == '%') {\n+      \/\/ Replace the first occurrence of any placeholder\n+      if (pid != nullptr && strncmp(&file_name[file_name_pos],\n+                                    PidFilenamePlaceholder,\n+                                    strlen(PidFilenamePlaceholder)) == 0) {\n+        strcpy(result + i, pid_string);\n+        i += strlen(pid_string);\n+        file_name_pos += strlen(PidFilenamePlaceholder);\n+        pid = nullptr;\n+        continue;\n+      }\n+      if (timestamp != nullptr && strncmp(&file_name[file_name_pos],\n+                                          TimestampFilenamePlaceholder,\n+                                          strlen(TimestampFilenamePlaceholder)) == 0) {\n+        strcpy(result + i, timestamp_string);\n+        i += strlen(timestamp_string);\n+        file_name_pos += strlen(TimestampFilenamePlaceholder);\n+        timestamp = nullptr;\n+        continue;\n+      }\n+      if (hostname != nullptr && strncmp(&file_name[file_name_pos],\n+                                         HostnameFilenamePlaceholder,\n+                                         strlen(HostnameFilenamePlaceholder)) == 0) {\n+        strcpy(result + i, hostname_string);\n+        i += strlen(hostname_string);\n+        file_name_pos += strlen(HostnameFilenamePlaceholder);\n+        hostname = nullptr;\n+        continue;\n+      }\n@@ -455,0 +451,2 @@\n+    \/\/ Else, copy char by char of the original file\n+    result[i++] = file_name[file_name_pos++];\n@@ -456,0 +454,3 @@\n+  assert(i == result_len, \"should be\");\n+  assert(file_name[file_name_pos] == '\\0', \"should be\");\n+\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":52,"deletions":51,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+  static const char* const HostnameFilenamePlaceholder;\n@@ -46,0 +47,1 @@\n+  static const size_t HostnameBufferSize = 512;\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,0 +107,1 @@\n+  LOG_TAG(jmethod) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,8 +86,8 @@\n-    if (_klass == Universe::boolArrayKlassObj())         name = \"<boolArrayKlass>\";         else\n-    if (_klass == Universe::charArrayKlassObj())         name = \"<charArrayKlass>\";         else\n-    if (_klass == Universe::floatArrayKlassObj())        name = \"<floatArrayKlass>\";        else\n-    if (_klass == Universe::doubleArrayKlassObj())       name = \"<doubleArrayKlass>\";       else\n-    if (_klass == Universe::byteArrayKlassObj())         name = \"<byteArrayKlass>\";         else\n-    if (_klass == Universe::shortArrayKlassObj())        name = \"<shortArrayKlass>\";        else\n-    if (_klass == Universe::intArrayKlassObj())          name = \"<intArrayKlass>\";          else\n-    if (_klass == Universe::longArrayKlassObj())         name = \"<longArrayKlass>\";         else\n+    if (_klass == Universe::boolArrayKlass())         name = \"<boolArrayKlass>\";         else\n+    if (_klass == Universe::charArrayKlass())         name = \"<charArrayKlass>\";         else\n+    if (_klass == Universe::floatArrayKlass())        name = \"<floatArrayKlass>\";        else\n+    if (_klass == Universe::doubleArrayKlass())       name = \"<doubleArrayKlass>\";       else\n+    if (_klass == Universe::byteArrayKlass())         name = \"<byteArrayKlass>\";         else\n+    if (_klass == Universe::shortArrayKlass())        name = \"<shortArrayKlass>\";        else\n+    if (_klass == Universe::intArrayKlass())          name = \"<intArrayKlass>\";          else\n+    if (_klass == Universe::longArrayKlass())         name = \"<longArrayKlass>\";         else\n@@ -173,1 +173,1 @@\n-  _ref = (HeapWord*) Universe::boolArrayKlassObj();\n+  _ref = (uintptr_t) Universe::boolArrayKlass();\n@@ -199,1 +199,1 @@\n-  return (uint)(((uintptr_t)p - (uintptr_t)_ref) >> 2);\n+  return (uint)(((uintptr_t)p - _ref) >> 2);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -111,3 +111,2 @@\n-  \/\/ address in the perm gen) used for hashing klass\n-  \/\/ objects.\n-  HeapWord* _ref;\n+  \/\/ address in the metaspace) used for hashing klasses.\n+  uintptr_t _ref;\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-void CodeBlobToOopClosure::do_nmethod(nmethod* nm) {\n+void NMethodToOopClosure::do_nmethod(nmethod* nm) {\n@@ -51,10 +51,3 @@\n-void CodeBlobToOopClosure::do_code_blob(CodeBlob* cb) {\n-  nmethod* nm = cb->as_nmethod_or_null();\n-  if (nm != nullptr) {\n-    do_nmethod(nm);\n-  }\n-}\n-\n-void MarkingCodeBlobClosure::do_code_blob(CodeBlob* cb) {\n-  nmethod* nm = cb->as_nmethod_or_null();\n-  if (nm != nullptr && nm->oops_do_try_claim()) {\n+void MarkingNMethodClosure::do_nmethod(nmethod* nm) {\n+  assert(nm != nullptr, \"Unexpected nullptr\");\n+  if (nm->oops_do_try_claim()) {\n@@ -79,7 +72,0 @@\n-\n-void CodeBlobToNMethodClosure::do_code_blob(CodeBlob* cb) {\n-  nmethod* nm = cb->as_nmethod_or_null();\n-  if (nm != nullptr) {\n-    _nm_cl->do_nmethod(nm);\n-  }\n-}\n","filename":"src\/hotspot\/share\/memory\/iterator.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-\/\/ CodeBlobClosure is used for iterating through code blobs\n+\/\/ NMethodClosure is used for iterating through nmethods\n@@ -238,1 +238,1 @@\n-class CodeBlobClosure : public Closure {\n+class NMethodClosure : public Closure {\n@@ -240,2 +240,1 @@\n-  \/\/ Called for each code blob.\n-  virtual void do_code_blob(CodeBlob* cb) = 0;\n+  virtual void do_nmethod(nmethod* n) = 0;\n@@ -244,1 +243,1 @@\n-\/\/ Applies an oop closure to all ref fields in code blobs\n+\/\/ Applies an oop closure to all ref fields in nmethods\n@@ -246,1 +245,1 @@\n-class CodeBlobToOopClosure : public CodeBlobClosure {\n+class NMethodToOopClosure : public NMethodClosure {\n@@ -250,1 +249,0 @@\n-  void do_nmethod(nmethod* nm);\n@@ -254,2 +252,2 @@\n-  CodeBlobToOopClosure(OopClosure* cl, bool fix_relocations) : _cl(cl), _fix_relocations(fix_relocations) {}\n-  virtual void do_code_blob(CodeBlob* cb);\n+  NMethodToOopClosure(OopClosure* cl, bool fix_relocations) : _cl(cl), _fix_relocations(fix_relocations) {}\n+  void do_nmethod(nmethod* nm) override;\n@@ -261,1 +259,1 @@\n-class MarkingCodeBlobClosure : public CodeBlobToOopClosure {\n+class MarkingNMethodClosure : public NMethodToOopClosure {\n@@ -265,2 +263,2 @@\n-  MarkingCodeBlobClosure(OopClosure* cl, bool fix_relocations, bool keepalive_nmethods) :\n-      CodeBlobToOopClosure(cl, fix_relocations),\n+  MarkingNMethodClosure(OopClosure* cl, bool fix_relocations, bool keepalive_nmethods) :\n+      NMethodToOopClosure(cl, fix_relocations),\n@@ -269,16 +267,2 @@\n-  \/\/ Called for each code blob, but at most once per unique blob.\n-  virtual void do_code_blob(CodeBlob* cb);\n-};\n-\n-class NMethodClosure : public Closure {\n- public:\n-  virtual void do_nmethod(nmethod* n) = 0;\n-};\n-\n-class CodeBlobToNMethodClosure : public CodeBlobClosure {\n-  NMethodClosure* const _nm_cl;\n-\n- public:\n-  CodeBlobToNMethodClosure(NMethodClosure* nm_cl) : _nm_cl(nm_cl) {}\n-\n-  virtual void do_code_blob(CodeBlob* cb);\n+  \/\/ Called for each nmethod.\n+  virtual void do_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":12,"deletions":28,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  return TypeArrayKlass::cast(Universe::boolArrayKlassObj())->allocate(length, THREAD);\n+  return Universe::boolArrayKlass()->allocate(length, THREAD);\n@@ -48,1 +48,1 @@\n-  return TypeArrayKlass::cast(Universe::charArrayKlassObj())->allocate(length, THREAD);\n+  return Universe::charArrayKlass()->allocate(length, THREAD);\n@@ -52,1 +52,1 @@\n-  return TypeArrayKlass::cast(Universe::floatArrayKlassObj())->allocate(length, THREAD);\n+  return Universe::floatArrayKlass()->allocate(length, THREAD);\n@@ -56,1 +56,1 @@\n-  return TypeArrayKlass::cast(Universe::doubleArrayKlassObj())->allocate(length, THREAD);\n+  return Universe::doubleArrayKlass()->allocate(length, THREAD);\n@@ -60,1 +60,1 @@\n-  return TypeArrayKlass::cast(Universe::byteArrayKlassObj())->allocate(length, THREAD);\n+  return Universe::byteArrayKlass()->allocate(length, THREAD);\n@@ -64,1 +64,1 @@\n-  return TypeArrayKlass::cast(Universe::shortArrayKlassObj())->allocate(length, THREAD);\n+  return Universe::shortArrayKlass()->allocate(length, THREAD);\n@@ -68,1 +68,1 @@\n-  return TypeArrayKlass::cast(Universe::intArrayKlassObj())->allocate(length, THREAD);\n+  return Universe::intArrayKlass()->allocate(length, THREAD);\n@@ -72,1 +72,1 @@\n-  return TypeArrayKlass::cast(Universe::longArrayKlassObj())->allocate(length, THREAD);\n+  return Universe::longArrayKlass()->allocate(length, THREAD);\n@@ -77,2 +77,2 @@\n-  assert(Universe::objectArrayKlassObj() != nullptr, \"Too early?\");\n-  return ObjArrayKlass::cast(Universe::objectArrayKlassObj())->allocate(length, THREAD);\n+  assert(Universe::objectArrayKlass() != nullptr, \"Too early?\");\n+  return Universe::objectArrayKlass()->allocate(length, THREAD);\n@@ -91,4 +91,2 @@\n-  Klass* type_asKlassOop = Universe::typeArrayKlassObj(type);\n-  TypeArrayKlass* type_asArrayKlass = TypeArrayKlass::cast(type_asKlassOop);\n-  typeArrayOop result = type_asArrayKlass->allocate(length, THREAD);\n-  return result;\n+  TypeArrayKlass* klass = Universe::typeArrayKlass(type);\n+  return klass->allocate(length, THREAD);\n@@ -103,4 +101,1 @@\n-  Klass* type_asKlassOop = Universe::typeArrayKlassObj(type);\n-  TypeArrayKlass* type_asArrayKlass = TypeArrayKlass::cast(type_asKlassOop);\n-  typeArrayOop result = type_asArrayKlass->allocate(length, THREAD);\n-  return result;\n+  return new_typeArray(type, length, THREAD);\n@@ -110,4 +105,2 @@\n-  Klass* type_asKlassOop = Universe::typeArrayKlassObj(type);\n-  TypeArrayKlass* type_asArrayKlass = TypeArrayKlass::cast(type_asKlassOop);\n-  typeArrayOop result = type_asArrayKlass->allocate_common(length, false, THREAD);\n-  return result;\n+  TypeArrayKlass* klass = Universe::typeArrayKlass(type);\n+  return klass->allocate_common(length, false, THREAD);\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -90,0 +90,23 @@\n+\/\/ A helper class for caching a Method* when the user of the cache\n+\/\/ only cares about the latest version of the Method*. This cache safely\n+\/\/ interacts with the RedefineClasses API.\n+class LatestMethodCache {\n+  \/\/ We save the InstanceKlass* and the idnum of Method* in order to get\n+  \/\/ the current Method*.\n+  InstanceKlass*        _klass;\n+  int                   _method_idnum;\n+\n+ public:\n+  LatestMethodCache()   { _klass = nullptr; _method_idnum = -1; }\n+\n+  void init(JavaThread* current, InstanceKlass* ik, const char* method,\n+            Symbol* signature, bool is_static);\n+  Method* get_method();\n+};\n+\n+static LatestMethodCache _finalizer_register_cache;         \/\/ Finalizer.register()\n+static LatestMethodCache _loader_addClass_cache;            \/\/ ClassLoader.addClass()\n+static LatestMethodCache _throw_illegal_access_error_cache; \/\/ Unsafe.throwIllegalAccessError()\n+static LatestMethodCache _throw_no_such_method_error_cache; \/\/ Unsafe.throwNoSuchMethodError()\n+static LatestMethodCache _do_stack_walk_cache;              \/\/ AbstractStackWalker.doStackWalk()\n+\n@@ -91,3 +114,3 @@\n-Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { nullptr \/*, nullptr...*\/ };\n-Klass* Universe::_objectArrayKlassObj                 = nullptr;\n-Klass* Universe::_fillerArrayKlassObj                 = nullptr;\n+TypeArrayKlass* Universe::_typeArrayKlasses[T_LONG+1] = { nullptr \/*, nullptr...*\/ };\n+ObjArrayKlass* Universe::_objectArrayKlass            = nullptr;\n+Klass* Universe::_fillerArrayKlass                    = nullptr;\n@@ -129,4 +152,0 @@\n-OopHandle Universe::_null_ptr_exception_instance;\n-OopHandle Universe::_arithmetic_exception_instance;\n-OopHandle Universe::_virtual_machine_error_instance;\n-\n@@ -136,5 +155,0 @@\n-LatestMethodCache* Universe::_finalizer_register_cache = nullptr;\n-LatestMethodCache* Universe::_loader_addClass_cache    = nullptr;\n-LatestMethodCache* Universe::_throw_illegal_access_error_cache = nullptr;\n-LatestMethodCache* Universe::_throw_no_such_method_error_cache = nullptr;\n-LatestMethodCache* Universe::_do_stack_walk_cache     = nullptr;\n@@ -171,0 +185,46 @@\n+\/\/ These are the exceptions that are always created and are guatanteed to exist.\n+\/\/ If possible, they can be stored as CDS archived objects to speed up AOT code.\n+class BuiltinException {\n+  OopHandle _instance;\n+  CDS_JAVA_HEAP_ONLY(int _archived_root_index;)\n+\n+public:\n+  BuiltinException() : _instance() {\n+    CDS_JAVA_HEAP_ONLY(_archived_root_index = 0);\n+  }\n+\n+  void init_if_empty(Symbol* symbol, TRAPS) {\n+    if (_instance.is_empty()) {\n+      Klass* k = SystemDictionary::resolve_or_fail(symbol, true, CHECK);\n+      oop obj = InstanceKlass::cast(k)->allocate_instance(CHECK);\n+      _instance = OopHandle(Universe::vm_global(), obj);\n+    }\n+  }\n+\n+  oop instance() {\n+    return _instance.resolve();\n+  }\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  void store_in_cds() {\n+    _archived_root_index = HeapShared::archive_exception_instance(instance());\n+  }\n+\n+  void load_from_cds() {\n+    if (_archived_root_index >= 0) {\n+      oop obj = HeapShared::get_root(_archived_root_index);\n+      assert(obj != nullptr, \"must be\");\n+      _instance = OopHandle(Universe::vm_global(), obj);\n+    }\n+  }\n+\n+  void serialize(SerializeClosure *f) {\n+    f->do_int(&_archived_root_index);\n+  }\n+#endif\n+};\n+\n+static BuiltinException _null_ptr_exception;\n+static BuiltinException _arithmetic_exception;\n+static BuiltinException _virtual_machine_error;\n+\n@@ -184,3 +244,3 @@\n-oop Universe::null_ptr_exception_instance()       { return _null_ptr_exception_instance.resolve(); }\n-oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception_instance.resolve(); }\n-oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error_instance.resolve(); }\n+oop Universe::null_ptr_exception_instance()       { return _null_ptr_exception.instance(); }\n+oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception.instance(); }\n+oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error.instance(); }\n@@ -208,1 +268,1 @@\n-    closure->do_klass(_typeArrayKlassObjs[i]);\n+    closure->do_klass(_typeArrayKlasses[i]);\n@@ -211,1 +271,1 @@\n-  \/\/ _fillerArrayKlassObj is used only by GC, which doesn't need to see\n+  \/\/ _fillerArrayKlass is used only by GC, which doesn't need to see\n@@ -214,5 +274,1 @@\n-  \/\/ closure->do_klass(_fillerArrayKlassObj);\n-}\n-\n-void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {\n-  it->push(&_klass);\n+  \/\/ closure->do_klass(_fillerArrayKlass);\n@@ -222,1 +278,1 @@\n-  it->push(&_fillerArrayKlassObj);\n+  it->push(&_fillerArrayKlass);\n@@ -224,1 +280,1 @@\n-    it->push(&_typeArrayKlassObjs[i]);\n+    it->push(&_typeArrayKlasses[i]);\n@@ -226,1 +282,1 @@\n-  it->push(&_objectArrayKlassObj);\n+  it->push(&_objectArrayKlass);\n@@ -234,6 +290,0 @@\n-\n-  _finalizer_register_cache->metaspace_pointers_do(it);\n-  _loader_addClass_cache->metaspace_pointers_do(it);\n-  _throw_illegal_access_error_cache->metaspace_pointers_do(it);\n-  _throw_no_such_method_error_cache->metaspace_pointers_do(it);\n-  _do_stack_walk_cache->metaspace_pointers_do(it);\n@@ -249,1 +299,7 @@\n-void Universe::update_archived_basic_type_mirrors() {\n+void Universe::archive_exception_instances() {\n+  _null_ptr_exception.store_in_cds();\n+  _arithmetic_exception.store_in_cds();\n+  _virtual_machine_error.store_in_cds();\n+}\n+\n+void Universe::load_archived_object_instances() {\n@@ -259,0 +315,4 @@\n+\n+    _null_ptr_exception.load_from_cds();\n+    _arithmetic_exception.load_from_cds();\n+    _virtual_machine_error.load_from_cds();\n@@ -270,1 +330,1 @@\n-    \/\/ updated later in Universe::update_archived_basic_type_mirrors().\n+    \/\/ updated later in Universe::load_archived_object_instances().\n@@ -272,0 +332,3 @@\n+  _null_ptr_exception.serialize(f);\n+  _arithmetic_exception.serialize(f);\n+  _virtual_machine_error.serialize(f);\n@@ -274,1 +337,1 @@\n-  f->do_ptr(&_fillerArrayKlassObj);\n+  f->do_ptr(&_fillerArrayKlass);\n@@ -276,1 +339,1 @@\n-    f->do_ptr(&_typeArrayKlassObjs[i]);\n+    f->do_ptr(&_typeArrayKlasses[i]);\n@@ -279,1 +342,1 @@\n-  f->do_ptr(&_objectArrayKlassObj);\n+  f->do_ptr(&_objectArrayKlass);\n@@ -286,5 +349,0 @@\n-  _finalizer_register_cache->serialize(f);\n-  _loader_addClass_cache->serialize(f);\n-  _throw_illegal_access_error_cache->serialize(f);\n-  _throw_no_such_method_error_cache->serialize(f);\n-  _do_stack_walk_cache->serialize(f);\n@@ -341,1 +399,1 @@\n-      _fillerArrayKlassObj = TypeArrayKlass::create_klass(T_INT, \"[Ljdk\/internal\/vm\/FillerElement;\", CHECK);\n+      _fillerArrayKlass = TypeArrayKlass::create_klass(T_INT, \"[Ljdk\/internal\/vm\/FillerElement;\", CHECK);\n@@ -343,1 +401,1 @@\n-        _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);\n+        _typeArrayKlasses[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);\n@@ -382,1 +440,1 @@\n-    initialize_basic_type_klass(_fillerArrayKlassObj, CHECK);\n+    initialize_basic_type_klass(_fillerArrayKlass, CHECK);\n@@ -384,8 +442,8 @@\n-    initialize_basic_type_klass(boolArrayKlassObj(), CHECK);\n-    initialize_basic_type_klass(charArrayKlassObj(), CHECK);\n-    initialize_basic_type_klass(floatArrayKlassObj(), CHECK);\n-    initialize_basic_type_klass(doubleArrayKlassObj(), CHECK);\n-    initialize_basic_type_klass(byteArrayKlassObj(), CHECK);\n-    initialize_basic_type_klass(shortArrayKlassObj(), CHECK);\n-    initialize_basic_type_klass(intArrayKlassObj(), CHECK);\n-    initialize_basic_type_klass(longArrayKlassObj(), CHECK);\n+    initialize_basic_type_klass(boolArrayKlass(), CHECK);\n+    initialize_basic_type_klass(charArrayKlass(), CHECK);\n+    initialize_basic_type_klass(floatArrayKlass(), CHECK);\n+    initialize_basic_type_klass(doubleArrayKlass(), CHECK);\n+    initialize_basic_type_klass(byteArrayKlass(), CHECK);\n+    initialize_basic_type_klass(shortArrayKlass(), CHECK);\n+    initialize_basic_type_klass(intArrayKlass(), CHECK);\n+    initialize_basic_type_klass(longArrayKlass(), CHECK);\n@@ -393,1 +451,1 @@\n-    assert(_fillerArrayKlassObj != intArrayKlassObj(),\n+    assert(_fillerArrayKlass != intArrayKlass(),\n@@ -417,2 +475,4 @@\n-  _objectArrayKlassObj = InstanceKlass::\n-    cast(vmClasses::Object_klass())->array_klass(1, CHECK);\n+  {\n+    Klass* oak = vmClasses::Object_klass()->array_klass(CHECK);\n+    _objectArrayKlass = ObjArrayKlass::cast(oak);\n+  }\n@@ -425,1 +485,1 @@\n-  _objectArrayKlassObj->append_to_sibling_list();\n+  _objectArrayKlass->append_to_sibling_list();\n@@ -813,8 +873,0 @@\n-  \/\/ We have a heap so create the Method* caches before\n-  \/\/ Metaspace::initialize_shared_spaces() tries to populate them.\n-  Universe::_finalizer_register_cache = new LatestMethodCache();\n-  Universe::_loader_addClass_cache    = new LatestMethodCache();\n-  Universe::_throw_illegal_access_error_cache = new LatestMethodCache();\n-  Universe::_throw_no_such_method_error_cache = new LatestMethodCache();\n-  Universe::_do_stack_walk_cache = new LatestMethodCache();\n-\n@@ -927,5 +979,2 @@\n-static void initialize_known_method(LatestMethodCache* method_cache,\n-                                    InstanceKlass* ik,\n-                                    const char* method,\n-                                    Symbol* signature,\n-                                    bool is_static, TRAPS)\n+void LatestMethodCache::init(JavaThread* current, InstanceKlass* ik,\n+                             const char* method, Symbol* signature, bool is_static)\n@@ -936,1 +985,1 @@\n-  if (!ik->link_class_or_fail(THREAD) ||\n+  if (!ik->link_class_or_fail(current) ||\n@@ -939,1 +988,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -945,1 +994,14 @@\n-  method_cache->init(ik, m);\n+\n+  _klass = ik;\n+  _method_idnum = m->method_idnum();\n+  assert(_method_idnum >= 0, \"sanity check\");\n+}\n+\n+Method* LatestMethodCache::get_method() {\n+  if (_klass == nullptr) {\n+    return nullptr;\n+  } else {\n+    Method* m = _klass->method_with_idnum(_method_idnum);\n+    assert(m != nullptr, \"sanity check\");\n+    return m;\n+  }\n@@ -948,1 +1010,7 @@\n-void Universe::initialize_known_methods(TRAPS) {\n+Method* Universe::finalizer_register_method()     { return _finalizer_register_cache.get_method(); }\n+Method* Universe::loader_addClass_method()        { return _loader_addClass_cache.get_method(); }\n+Method* Universe::throw_illegal_access_error()    { return _throw_illegal_access_error_cache.get_method(); }\n+Method* Universe::throw_no_such_method_error()    { return _throw_no_such_method_error_cache.get_method(); }\n+Method* Universe::do_stack_walk_method()          { return _do_stack_walk_cache.get_method(); }\n+\n+void Universe::initialize_known_methods(JavaThread* current) {\n@@ -950,1 +1018,1 @@\n-  initialize_known_method(_finalizer_register_cache,\n+  _finalizer_register_cache.init(current,\n@@ -953,1 +1021,1 @@\n-                          vmSymbols::object_void_signature(), true, CHECK);\n+                          vmSymbols::object_void_signature(), true);\n@@ -955,1 +1023,1 @@\n-  initialize_known_method(_throw_illegal_access_error_cache,\n+  _throw_illegal_access_error_cache.init(current,\n@@ -958,1 +1026,1 @@\n-                          vmSymbols::void_method_signature(), true, CHECK);\n+                          vmSymbols::void_method_signature(), true);\n@@ -960,1 +1028,1 @@\n-  initialize_known_method(_throw_no_such_method_error_cache,\n+  _throw_no_such_method_error_cache.init(current,\n@@ -963,1 +1031,1 @@\n-                          vmSymbols::void_method_signature(), true, CHECK);\n+                          vmSymbols::void_method_signature(), true);\n@@ -966,1 +1034,1 @@\n-  initialize_known_method(_loader_addClass_cache,\n+  _loader_addClass_cache.init(current,\n@@ -969,1 +1037,1 @@\n-                          vmSymbols::class_void_signature(), false, CHECK);\n+                          vmSymbols::class_void_signature(), false);\n@@ -972,1 +1040,1 @@\n-  initialize_known_method(_do_stack_walk_cache,\n+  _do_stack_walk_cache.init(current,\n@@ -975,1 +1043,1 @@\n-                          vmSymbols::doStackWalk_signature(), false, CHECK);\n+                          vmSymbols::doStackWalk_signature(), false);\n@@ -1013,11 +1081,4 @@\n-  \/\/ Setup preallocated NullPointerException\n-  \/\/ (this is currently used for a cheap & dirty solution in compiler exception handling)\n-  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_NullPointerException(), true, CHECK_false);\n-  instance = InstanceKlass::cast(k)->allocate_instance(CHECK_false);\n-  Universe::_null_ptr_exception_instance = OopHandle(Universe::vm_global(), instance);\n-\n-  \/\/ Setup preallocated ArithmeticException\n-  \/\/ (this is currently used for a cheap & dirty solution in compiler exception handling)\n-  k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ArithmeticException(), true, CHECK_false);\n-  instance = InstanceKlass::cast(k)->allocate_instance(CHECK_false);\n-  Universe::_arithmetic_exception_instance = OopHandle(Universe::vm_global(), instance);\n+  \/\/ Setup preallocated NullPointerException\/ArithmeticException\n+  \/\/ (used for a cheap & dirty solution in compiler exception handling)\n+  _null_ptr_exception.init_if_empty(vmSymbols::java_lang_NullPointerException(), CHECK_false);\n+  _arithmetic_exception.init_if_empty(vmSymbols::java_lang_ArithmeticException(), CHECK_false);\n@@ -1026,1 +1087,1 @@\n-  k = vmClasses::VirtualMachineError_klass();\n+  Klass* k = vmClasses::VirtualMachineError_klass();\n@@ -1032,2 +1093,1 @@\n-  instance = InstanceKlass::cast(k)->allocate_instance(CHECK_false);\n-  Universe::_virtual_machine_error_instance = OopHandle(Universe::vm_global(), instance);\n+  _virtual_machine_error.init_if_empty(vmSymbols::java_lang_VirtualMachineError(), CHECK_false);\n@@ -1043,1 +1103,1 @@\n-  Universe::initialize_known_methods(CHECK_false);\n+  Universe::initialize_known_methods(THREAD);\n@@ -1258,29 +1318,0 @@\n-\n-void LatestMethodCache::init(Klass* k, Method* m) {\n-  if (!UseSharedSpaces) {\n-    _klass = k;\n-  }\n-#ifndef PRODUCT\n-  else {\n-    \/\/ sharing initialization should have already set up _klass\n-    assert(_klass != nullptr, \"just checking\");\n-  }\n-#endif\n-\n-  _method_idnum = m->method_idnum();\n-  assert(_method_idnum >= 0, \"sanity check\");\n-}\n-\n-\n-Method* LatestMethodCache::get_method() {\n-  if (klass() == nullptr) return nullptr;\n-  InstanceKlass* ik = InstanceKlass::cast(klass());\n-  Method* m = ik->method_with_idnum(method_idnum());\n-  assert(m != nullptr, \"sanity check\");\n-  return m;\n-}\n-\n-void LatestMethodCache::serialize(SerializeClosure* f) {\n-  f->do_ptr(&_klass);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":158,"deletions":127,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,27 +48,0 @@\n-\/\/ A helper class for caching a Method* when the user of the cache\n-\/\/ only cares about the latest version of the Method*.  This cache safely\n-\/\/ interacts with the RedefineClasses API.\n-\n-class LatestMethodCache : public CHeapObj<mtClass> {\n-  \/\/ We save the Klass* and the idnum of Method* in order to get\n-  \/\/ the current cached Method*.\n- private:\n-  Klass*                _klass;\n-  int                   _method_idnum;\n-\n- public:\n-  LatestMethodCache()   { _klass = nullptr; _method_idnum = -1; }\n-  ~LatestMethodCache()  { _klass = nullptr; _method_idnum = -1; }\n-\n-  void   init(Klass* k, Method* m);\n-  Klass* klass() const           { return _klass; }\n-  int    method_idnum() const    { return _method_idnum; }\n-\n-  Method* get_method();\n-\n-  \/\/ CDS support.  Replace the klass in this with the archive version\n-  \/\/ could use this for Enhanced Class Redefinition also.\n-  void serialize(SerializeClosure* f);\n-  void metaspace_pointers_do(MetaspaceClosure* it);\n-};\n-\n@@ -77,1 +50,1 @@\n-  friend class MarkSweep;\n+  friend class SerialFullGC;\n@@ -95,2 +68,2 @@\n-  static Klass* _typeArrayKlassObjs[T_LONG+1];\n-  static Klass* _objectArrayKlassObj;\n+  static TypeArrayKlass* _typeArrayKlasses[T_LONG+1];\n+  static ObjArrayKlass* _objectArrayKlass;\n@@ -99,1 +72,1 @@\n-  static Klass* _fillerArrayKlassObj;\n+  static Klass* _fillerArrayKlass;\n@@ -118,6 +91,0 @@\n-  static LatestMethodCache* _finalizer_register_cache; \/\/ static method for registering finalizable objects\n-  static LatestMethodCache* _loader_addClass_cache;    \/\/ method for registering loaded classes in class loader vector\n-  static LatestMethodCache* _throw_illegal_access_error_cache; \/\/ Unsafe.throwIllegalAccessError() method\n-  static LatestMethodCache* _throw_no_such_method_error_cache; \/\/ Unsafe.throwNoSuchMethodError() method\n-  static LatestMethodCache* _do_stack_walk_cache;      \/\/ method for stack walker callback\n-\n@@ -142,4 +109,0 @@\n-  static OopHandle    _null_ptr_exception_instance;   \/\/ preallocated exception object\n-  static OopHandle    _arithmetic_exception_instance; \/\/ preallocated exception object\n-  static OopHandle    _virtual_machine_error_instance; \/\/ preallocated exception object\n-\n@@ -214,8 +177,8 @@\n-  static Klass* boolArrayKlassObj()                 { return typeArrayKlassObj(T_BOOLEAN); }\n-  static Klass* byteArrayKlassObj()                 { return typeArrayKlassObj(T_BYTE); }\n-  static Klass* charArrayKlassObj()                 { return typeArrayKlassObj(T_CHAR); }\n-  static Klass* intArrayKlassObj()                  { return typeArrayKlassObj(T_INT); }\n-  static Klass* shortArrayKlassObj()                { return typeArrayKlassObj(T_SHORT); }\n-  static Klass* longArrayKlassObj()                 { return typeArrayKlassObj(T_LONG); }\n-  static Klass* floatArrayKlassObj()                { return typeArrayKlassObj(T_FLOAT); }\n-  static Klass* doubleArrayKlassObj()               { return typeArrayKlassObj(T_DOUBLE); }\n+  static TypeArrayKlass* boolArrayKlass()        { return typeArrayKlass(T_BOOLEAN); }\n+  static TypeArrayKlass* byteArrayKlass()        { return typeArrayKlass(T_BYTE); }\n+  static TypeArrayKlass* charArrayKlass()        { return typeArrayKlass(T_CHAR); }\n+  static TypeArrayKlass* intArrayKlass()         { return typeArrayKlass(T_INT); }\n+  static TypeArrayKlass* shortArrayKlass()       { return typeArrayKlass(T_SHORT); }\n+  static TypeArrayKlass* longArrayKlass()        { return typeArrayKlass(T_LONG); }\n+  static TypeArrayKlass* floatArrayKlass()       { return typeArrayKlass(T_FLOAT); }\n+  static TypeArrayKlass* doubleArrayKlass()      { return typeArrayKlass(T_DOUBLE); }\n@@ -223,1 +186,1 @@\n-  static Klass* objectArrayKlassObj()               { return _objectArrayKlassObj; }\n+  static ObjArrayKlass* objectArrayKlass()       { return _objectArrayKlass; }\n@@ -225,1 +188,1 @@\n-  static Klass* fillerArrayKlassObj()               { return _fillerArrayKlassObj; }\n+  static Klass* fillerArrayKlass()               { return _fillerArrayKlass; }\n@@ -227,1 +190,1 @@\n-  static Klass* typeArrayKlassObj(BasicType t) {\n+  static TypeArrayKlass* typeArrayKlass(BasicType t) {\n@@ -230,2 +193,2 @@\n-    assert(_typeArrayKlassObjs[t] != nullptr, \"domain check\");\n-    return _typeArrayKlassObjs[t];\n+    assert(_typeArrayKlasses[t] != nullptr, \"domain check\");\n+    return _typeArrayKlasses[t];\n@@ -247,0 +210,1 @@\n+  static void load_archived_object_instances() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -249,1 +213,1 @@\n-  static void update_archived_basic_type_mirrors();\n+  static void archive_exception_instances();\n@@ -269,5 +233,0 @@\n-  static Method*      finalizer_register_method()     { return _finalizer_register_cache->get_method(); }\n-  static Method*      loader_addClass_method()        { return _loader_addClass_cache->get_method(); }\n-\n-  static Method*      throw_illegal_access_error()    { return _throw_illegal_access_error_cache->get_method(); }\n-  static Method*      throw_no_such_method_error()    { return _throw_no_such_method_error_cache->get_method(); }\n@@ -275,1 +234,5 @@\n-  static Method*      do_stack_walk_method()          { return _do_stack_walk_cache->get_method(); }\n+  static Method*      finalizer_register_method();\n+  static Method*      loader_addClass_method();\n+  static Method*      throw_illegal_access_error();\n+  static Method*      throw_no_such_method_error();\n+  static Method*      do_stack_walk_method();\n@@ -281,1 +244,1 @@\n-  static void initialize_known_methods(TRAPS);\n+  static void initialize_known_methods(JavaThread* current);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":26,"deletions":63,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -317,3 +317,1 @@\n-\n-ReservedSpace\n-ReservedSpace::last_part(size_t partition_size, size_t alignment) {\n+ReservedSpace ReservedSpace::last_part(size_t partition_size, size_t alignment) {\n@@ -326,0 +324,5 @@\n+ReservedSpace ReservedSpace::partition(size_t offset, size_t partition_size, size_t alignment) {\n+  assert(offset + partition_size <= size(), \"partition failed\");\n+  ReservedSpace result(base() + offset, partition_size, alignment, page_size(), special(), executable());\n+  return result;\n+}\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  ReservedSpace partition (size_t offset, size_t partition_size, size_t alignment);\n@@ -102,0 +103,1 @@\n+  inline ReservedSpace partition (size_t offset, size_t partition_size);\n@@ -116,2 +118,1 @@\n-ReservedSpace\n-ReservedSpace::first_part(size_t partition_size)\n+ReservedSpace ReservedSpace::first_part(size_t partition_size)\n@@ -127,0 +128,5 @@\n+ReservedSpace ReservedSpace::partition(size_t offset, size_t partition_size)\n+{\n+  return partition(offset, partition_size, alignment());\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  friend class ArchiveBuilder;\n@@ -67,0 +68,5 @@\n+  static inline Klass* decode_not_null_without_asserts(narrowKlass v, address base, int shift);\n+  static inline Klass* decode_not_null(narrowKlass v, address base, int shift);\n+\n+  static inline narrowKlass encode_not_null(Klass* v, address base, int shift);\n+\n@@ -95,2 +101,4 @@\n-  static inline Klass* decode_raw(narrowKlass v, address base, int shift);\n-  static inline Klass* decode_raw(narrowKlass v);\n+  \/\/ Versions without asserts\n+  static inline Klass* decode_not_null_without_asserts(narrowKlass v);\n+  static inline Klass* decode_without_asserts(narrowKlass v);\n+\n@@ -98,1 +106,0 @@\n-  static inline Klass* decode_not_null(narrowKlass v, address base, int shift);\n@@ -100,0 +107,1 @@\n+\n@@ -101,1 +109,0 @@\n-  static inline narrowKlass encode_not_null(Klass* v, address base, int shift);\n@@ -103,1 +110,0 @@\n-\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,5 +39,1 @@\n-inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v) {\n-  return decode_raw(v, base(), shift());\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v, address narrow_base, int shift) {\n+inline Klass* CompressedKlassPointers::decode_not_null_without_asserts(narrowKlass v, address narrow_base, int shift) {\n@@ -47,4 +43,0 @@\n-inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v) {\n-  return decode_not_null(v, base(), shift());\n-}\n-\n@@ -53,1 +45,1 @@\n-  Klass* result = decode_raw(v, narrow_base, shift);\n+  Klass* result = decode_not_null_without_asserts(v, narrow_base, shift);\n@@ -58,8 +50,0 @@\n-inline Klass* CompressedKlassPointers::decode(narrowKlass v) {\n-  return is_null(v) ? nullptr : decode_not_null(v);\n-}\n-\n-inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v) {\n-  return encode_not_null(v, base(), shift());\n-}\n-\n@@ -77,0 +61,20 @@\n+inline Klass* CompressedKlassPointers::decode_not_null_without_asserts(narrowKlass v) {\n+  return decode_not_null_without_asserts(v, base(), shift());\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_without_asserts(narrowKlass v) {\n+  return is_null(v) ? nullptr : decode_not_null_without_asserts(v);\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v) {\n+  return decode_not_null(v, base(), shift());\n+}\n+\n+inline Klass* CompressedKlassPointers::decode(narrowKlass v) {\n+  return is_null(v) ? nullptr : decode_not_null(v);\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v) {\n+  return encode_not_null(v, base(), shift());\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.inline.hpp","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2270,0 +2270,11 @@\n+jmethodID InstanceKlass::update_jmethod_id(jmethodID* jmeths, Method* method, int idnum) {\n+  if (method->is_old() && !method->is_obsolete()) {\n+    \/\/ If the method passed in is old (but not obsolete), use the current version.\n+    method = method_with_idnum((int)idnum);\n+    assert(method != nullptr, \"old and but not obsolete, so should exist\");\n+  }\n+  jmethodID new_id = Method::make_jmethod_id(class_loader_data(), method);\n+  Atomic::release_store(&jmeths[idnum + 1], new_id);\n+  return new_id;\n+}\n+\n@@ -2276,1 +2287,2 @@\n-  size_t idnum = (size_t)method_h->method_idnum();\n+  Method* method = method_h();\n+  int idnum = method->method_idnum();\n@@ -2278,2 +2290,0 @@\n-  size_t length = 0;\n-  jmethodID id = nullptr;\n@@ -2291,1 +2301,1 @@\n-  \/\/ generally acquired in those two cases.\n+  \/\/ acquired in those two cases.\n@@ -2293,38 +2303,12 @@\n-  \/\/ If the RedefineClasses() API has been used, then this cache can\n-  \/\/ grow and we'll have transitions from non-null to bigger non-null.\n-  \/\/ Cache creation requires no leaks and we require safety between all\n-  \/\/ cache accesses and freeing of the old cache so a lock is generally\n-  \/\/ acquired when the RedefineClasses() API has been used.\n-\n-  if (jmeths != nullptr) {\n-    \/\/ the cache already exists\n-    if (!idnum_can_increment()) {\n-      \/\/ the cache can't grow so we can just get the current values\n-      get_jmethod_id_length_value(jmeths, idnum, &length, &id);\n-    } else {\n-      MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n-      get_jmethod_id_length_value(jmeths, idnum, &length, &id);\n-    }\n-  }\n-  \/\/ implied else:\n-  \/\/ we need to allocate a cache so default length and id values are good\n-\n-  if (jmeths == nullptr ||   \/\/ no cache yet\n-      length <= idnum ||     \/\/ cache is too short\n-      id == nullptr) {       \/\/ cache doesn't contain entry\n-\n-    \/\/ This function can be called by the VMThread or GC worker threads so we\n-    \/\/ have to do all things that might block on a safepoint before grabbing the lock.\n-    \/\/ Otherwise, we can deadlock with the VMThread or have a cache\n-    \/\/ consistency issue. These vars keep track of what we might have\n-    \/\/ to free after the lock is dropped.\n-    jmethodID  to_dealloc_id     = nullptr;\n-    jmethodID* to_dealloc_jmeths = nullptr;\n-\n-    \/\/ may not allocate new_jmeths or use it if we allocate it\n-    jmethodID* new_jmeths = nullptr;\n-    if (length <= idnum) {\n-      \/\/ allocate a new cache that might be used\n-      size_t size = MAX2(idnum+1, (size_t)idnum_allocated_count());\n-      new_jmeths = NEW_C_HEAP_ARRAY(jmethodID, size+1, mtClass);\n-      memset(new_jmeths, 0, (size+1)*sizeof(jmethodID));\n+  \/\/ If the RedefineClasses() API has been used, then this cache grows\n+  \/\/ in the redefinition safepoint.\n+\n+  if (jmeths == nullptr) {\n+    MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n+    jmeths = methods_jmethod_ids_acquire();\n+    \/\/ Still null?\n+    if (jmeths == nullptr) {\n+      size_t size = idnum_allocated_count();\n+      assert(size > (size_t)idnum, \"should already have space\");\n+      jmeths = NEW_C_HEAP_ARRAY(jmethodID, size + 1, mtClass);\n+      memset(jmeths, 0, (size + 1) * sizeof(jmethodID));\n@@ -2332,17 +2316,2 @@\n-      new_jmeths[0] = (jmethodID)size;\n-    }\n-\n-    \/\/ allocate a new jmethodID that might be used\n-    {\n-      MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n-      jmethodID new_id = nullptr;\n-      if (method_h->is_old() && !method_h->is_obsolete()) {\n-        \/\/ The method passed in is old (but not obsolete), we need to use the current version\n-        Method* current_method = method_with_idnum((int)idnum);\n-        assert(current_method != nullptr, \"old and but not obsolete, so should exist\");\n-        new_id = Method::make_jmethod_id(class_loader_data(), current_method);\n-      } else {\n-        \/\/ It is the current version of the method or an obsolete method,\n-        \/\/ use the version passed in\n-        new_id = Method::make_jmethod_id(class_loader_data(), method_h());\n-      }\n+      jmeths[0] = (jmethodID)size;\n+      jmethodID new_id = update_jmethod_id(jmeths, method, idnum);\n@@ -2350,2 +2319,3 @@\n-      id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,\n-                                          &to_dealloc_id, &to_dealloc_jmeths);\n+      \/\/ publish jmeths\n+      release_set_methods_jmethod_ids(jmeths);\n+      return new_id;\n@@ -2353,0 +2323,1 @@\n+  }\n@@ -2354,8 +2325,7 @@\n-    \/\/ The lock has been dropped so we can free resources.\n-    \/\/ Free up either the old cache or the new cache if we allocated one.\n-    if (to_dealloc_jmeths != nullptr) {\n-      FreeHeap(to_dealloc_jmeths);\n-    }\n-    \/\/ free up the new ID since it wasn't needed\n-    if (to_dealloc_id != nullptr) {\n-      Method::destroy_jmethod_id(class_loader_data(), to_dealloc_id);\n+  jmethodID id = Atomic::load_acquire(&jmeths[idnum + 1]);\n+  if (id == nullptr) {\n+    MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n+    id = jmeths[idnum + 1];\n+    \/\/ Still null?\n+    if (id == nullptr) {\n+      return update_jmethod_id(jmeths, method, idnum);\n@@ -2367,0 +2337,23 @@\n+void InstanceKlass::update_methods_jmethod_cache() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"only called at safepoint\");\n+  jmethodID* cache = _methods_jmethod_ids;\n+  if (cache != nullptr) {\n+    size_t size = idnum_allocated_count();\n+    size_t old_size = (size_t)cache[0];\n+    if (old_size < size + 1) {\n+      \/\/ Allocate a larger one and copy entries to the new one.\n+      \/\/ They've already been updated to point to new methods where applicable (i.e., not obsolete).\n+      jmethodID* new_cache = NEW_C_HEAP_ARRAY(jmethodID, size + 1, mtClass);\n+      memset(new_cache, 0, (size + 1) * sizeof(jmethodID));\n+      \/\/ The cache size is stored in element[0]; the other elements are offset by one.\n+      new_cache[0] = (jmethodID)size;\n+\n+      for (int i = 1; i <= (int)old_size; i++) {\n+        new_cache[i] = cache[i];\n+      }\n+      _methods_jmethod_ids = new_cache;\n+      FREE_C_HEAP_ARRAY(jmethodID, cache);\n+    }\n+  }\n+}\n+\n@@ -2387,71 +2380,0 @@\n-\/\/ Common code to fetch the jmethodID from the cache or update the\n-\/\/ cache with the new jmethodID. This function should never do anything\n-\/\/ that causes the caller to go to a safepoint or we can deadlock with\n-\/\/ the VMThread or have cache consistency issues.\n-\/\/\n-jmethodID InstanceKlass::get_jmethod_id_fetch_or_update(\n-            size_t idnum, jmethodID new_id,\n-            jmethodID* new_jmeths, jmethodID* to_dealloc_id_p,\n-            jmethodID** to_dealloc_jmeths_p) {\n-  assert(new_id != nullptr, \"sanity check\");\n-  assert(to_dealloc_id_p != nullptr, \"sanity check\");\n-  assert(to_dealloc_jmeths_p != nullptr, \"sanity check\");\n-  assert(JmethodIdCreation_lock->owned_by_self(), \"sanity check\");\n-\n-  \/\/ reacquire the cache - we are locked, single threaded or at a safepoint\n-  jmethodID* jmeths = methods_jmethod_ids_acquire();\n-  jmethodID  id     = nullptr;\n-  size_t     length = 0;\n-\n-  if (jmeths == nullptr ||                      \/\/ no cache yet\n-      (length = (size_t)jmeths[0]) <= idnum) {  \/\/ cache is too short\n-    if (jmeths != nullptr) {\n-      \/\/ copy any existing entries from the old cache\n-      for (size_t index = 0; index < length; index++) {\n-        new_jmeths[index+1] = jmeths[index+1];\n-      }\n-      *to_dealloc_jmeths_p = jmeths;  \/\/ save old cache for later delete\n-    }\n-    release_set_methods_jmethod_ids(jmeths = new_jmeths);\n-  } else {\n-    \/\/ fetch jmethodID (if any) from the existing cache\n-    id = jmeths[idnum+1];\n-    *to_dealloc_jmeths_p = new_jmeths;  \/\/ save new cache for later delete\n-  }\n-  if (id == nullptr) {\n-    \/\/ No matching jmethodID in the existing cache or we have a new\n-    \/\/ cache or we just grew the cache. This cache write is done here\n-    \/\/ by the first thread to win the foot race because a jmethodID\n-    \/\/ needs to be unique once it is generally available.\n-    id = new_id;\n-\n-    \/\/ The jmethodID cache can be read while unlocked so we have to\n-    \/\/ make sure the new jmethodID is complete before installing it\n-    \/\/ in the cache.\n-    Atomic::release_store(&jmeths[idnum+1], id);\n-  } else {\n-    *to_dealloc_id_p = new_id; \/\/ save new id for later delete\n-  }\n-  return id;\n-}\n-\n-\n-\/\/ Common code to get the jmethodID cache length and the jmethodID\n-\/\/ value at index idnum if there is one.\n-\/\/\n-void InstanceKlass::get_jmethod_id_length_value(jmethodID* cache,\n-       size_t idnum, size_t *length_p, jmethodID* id_p) {\n-  assert(cache != nullptr, \"sanity check\");\n-  assert(length_p != nullptr, \"sanity check\");\n-  assert(id_p != nullptr, \"sanity check\");\n-\n-  \/\/ cache size is stored in element[0], other elements offset by one\n-  *length_p = (size_t)cache[0];\n-  if (*length_p <= idnum) {  \/\/ cache is too short\n-    *id_p = nullptr;\n-  } else {\n-    *id_p = cache[idnum+1];  \/\/ fetch jmethodID (if any)\n-  }\n-}\n-\n-\n@@ -2460,1 +2382,1 @@\n-  size_t idnum = (size_t)method->method_idnum();\n+  int idnum = method->method_idnum();\n@@ -2462,7 +2384,1 @@\n-  size_t length;                                \/\/ length assigned as debugging crumb\n-  jmethodID id = nullptr;\n-  if (jmeths != nullptr &&                      \/\/ If there is a cache\n-      (length = (size_t)jmeths[0]) > idnum) {   \/\/ and if it is long enough,\n-    id = jmeths[idnum+1];                       \/\/ Look up the id (may be null)\n-  }\n-  return id;\n+  return (jmeths != nullptr) ? jmeths[idnum + 1] : nullptr;\n@@ -2887,1 +2803,1 @@\n-  if (jmeths != (jmethodID*)nullptr) {\n+  if (jmeths != nullptr) {\n@@ -3442,1 +3358,1 @@\n-  assert_lock_strong(CompiledMethod_lock);\n+  assert_lock_strong(NMethodState_lock);\n@@ -3467,1 +3383,1 @@\n-  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -3508,1 +3424,1 @@\n-  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -3523,1 +3439,1 @@\n-  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":69,"deletions":153,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,3 +240,3 @@\n-  JNIid*          _jni_ids;              \/\/ First JNI identifier for static fields in this class\n-  jmethodID*      volatile _methods_jmethod_ids;  \/\/ jmethodIDs corresponding to method_idnum, or null if none\n-  nmethodBucket*  volatile _dep_context;          \/\/ packed DependencyContext structure\n+  JNIid*          _jni_ids;                  \/\/ First JNI identifier for static fields in this class\n+  jmethodID* volatile _methods_jmethod_ids;  \/\/ jmethodIDs corresponding to method_idnum, or null if none\n+  nmethodBucket*  volatile _dep_context;     \/\/ packed DependencyContext structure\n@@ -797,6 +797,0 @@\n-  jmethodID get_jmethod_id_fetch_or_update(size_t idnum,\n-                     jmethodID new_id, jmethodID* new_jmeths,\n-                     jmethodID* to_dealloc_id_p,\n-                     jmethodID** to_dealloc_jmeths_p);\n-  static void get_jmethod_id_length_value(jmethodID* cache, size_t idnum,\n-                size_t *length_p, jmethodID* id_p);\n@@ -805,0 +799,1 @@\n+  void update_methods_jmethod_cache();\n@@ -1076,5 +1071,0 @@\n-  \/\/ The RedefineClasses() API can cause new method idnums to be needed\n-  \/\/ which will cause the caches to grow. Safety requires different\n-  \/\/ cache management logic if the caches can grow instead of just\n-  \/\/ going from null to non-null.\n-  bool idnum_can_increment() const      { return has_been_redefined(); }\n@@ -1085,0 +1075,1 @@\n+  jmethodID update_jmethod_id(jmethodID* jmeths, Method* method, int idnum);\n@@ -1086,1 +1077,0 @@\n-  \/\/ Lock during initialization\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,2 @@\n-    if (is_neutral()) {   \/\/ last bits = 01\n-      st->print(\"is_neutral\");\n+    if (is_unlocked()) {   \/\/ last bits = 01\n+      st->print(\"is_unlocked\");\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,1 @@\n-  bool is_neutral()  const {\n+  bool is_neutral()  const {  \/\/ Not locked, or marked - a \"clean\" neutral state\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1014,1 +1014,1 @@\n-  CompiledMethod* nm = code(); \/\/ Put it into local variable to guard against concurrent updates\n+  nmethod* nm = code(); \/\/ Put it into local variable to guard against concurrent updates\n@@ -1162,2 +1162,2 @@\n-void Method::unlink_code(CompiledMethod *compare) {\n-  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+void Method::unlink_code(nmethod *compare) {\n+  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -1174,1 +1174,1 @@\n-  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -1306,1 +1306,1 @@\n-  CompiledMethod *code = Atomic::load_acquire(&_code);\n+  nmethod *code = Atomic::load_acquire(&_code);\n@@ -1311,2 +1311,2 @@\n-void Method::set_code(const methodHandle& mh, CompiledMethod *code) {\n-  assert_lock_strong(CompiledMethod_lock);\n+void Method::set_code(const methodHandle& mh, nmethod *code) {\n+  assert_lock_strong(NMethodState_lock);\n@@ -2146,8 +2146,0 @@\n-  \/\/ Doesn't really destroy it, just marks it as free so it can be reused.\n-  void destroy_method(Method** m) {\n-#ifdef ASSERT\n-    assert(contains(m), \"should be a methodID\");\n-#endif \/\/ ASSERT\n-    *m = _free_method;\n-  }\n-\n@@ -2206,0 +2198,3 @@\n+\n+  ResourceMark rm;\n+  log_debug(jmethod)(\"Creating jmethodID for Method %s\", m->external_name());\n@@ -2218,8 +2213,0 @@\n-\/\/ Mark a jmethodID as free.  This is called when there is a data race in\n-\/\/ InstanceKlass while creating the jmethodID cache.\n-void Method::destroy_jmethod_id(ClassLoaderData* cld, jmethodID m) {\n-  Method** ptr = (Method**)m;\n-  assert(cld->jmethod_ids() != nullptr, \"should have method handles\");\n-  cld->jmethod_ids()->destroy_method(ptr);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-class CompiledMethod;\n+class nmethod;\n@@ -96,1 +96,1 @@\n-  volatile address _from_compiled_entry;        \/\/ Cache of: _code ? _code->entry_point() : _adapter->c2i_entry()\n+  volatile address _from_compiled_entry;     \/\/ Cache of: _code ? _code->entry_point() : _adapter->c2i_entry()\n@@ -102,2 +102,2 @@\n-  CompiledMethod* volatile _code;                       \/\/ Points to the corresponding piece of native code\n-  volatile address           _from_interpreted_entry; \/\/ Cache of _code ? _adapter->i2c_entry() : _i2i_entry\n+  nmethod* volatile _code;                   \/\/ Points to the corresponding piece of native code\n+  volatile address  _from_interpreted_entry; \/\/ Cache of _code ? _adapter->i2c_entry() : _i2i_entry\n@@ -360,1 +360,1 @@\n-  CompiledMethod* code() const;\n+  nmethod* code() const;\n@@ -362,3 +362,3 @@\n-  \/\/ Locks CompiledMethod_lock if not held.\n-  void unlink_code(CompiledMethod *compare);\n-  \/\/ Locks CompiledMethod_lock if not held.\n+  \/\/ Locks NMethodState_lock if not held.\n+  void unlink_code(nmethod *compare);\n+  \/\/ Locks NMethodState_lock if not held.\n@@ -368,1 +368,1 @@\n-  \/\/ Either called with CompiledMethod_lock held or from constructor.\n+  \/\/ Either called with NMethodState_lock held or from constructor.\n@@ -376,1 +376,1 @@\n-  static void set_code(const methodHandle& mh, CompiledMethod* code);\n+  static void set_code(const methodHandle& mh, nmethod* code);\n@@ -703,1 +703,0 @@\n-  static void destroy_jmethod_id(ClassLoaderData* cld, jmethodID mid);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-inline CompiledMethod* Method::code() const {\n+inline nmethod* Method::code() const {\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,10 +168,0 @@\n-void* oopDesc::load_klass_raw(oop obj) {\n-  if (UseCompressedClassPointers) {\n-    narrowKlass narrow_klass = obj->_metadata._compressed_klass;\n-    if (narrow_klass == 0) return nullptr;\n-    return (void*)CompressedKlassPointers::decode_raw(narrow_klass);\n-  } else {\n-    return obj->_metadata._klass;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -88,2 +88,2 @@\n-  \/\/ Get the raw value without any checks.\n-  inline Klass* klass_raw() const;\n+  \/\/ Get the klass without running any asserts.\n+  inline Klass* klass_without_asserts() const;\n@@ -319,1 +319,0 @@\n-  static void* load_klass_raw(oop obj);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-Klass* oopDesc::klass_raw() const {\n+Klass* oopDesc::klass_without_asserts() const {\n@@ -116,1 +116,1 @@\n-    return CompressedKlassPointers::decode_raw(_metadata._compressed_klass);\n+    return CompressedKlassPointers::decode_without_asserts(_metadata._compressed_klass);\n@@ -259,1 +259,0 @@\n-\/\/ Used only for markSweep, scavenging\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-#include \"code\/compiledMethod.hpp\"\n+#include \"code\/nmethod.hpp\"\n@@ -111,1 +111,1 @@\n-static int num_java_frames(CompiledMethod* cm, address pc) {\n+static int num_java_frames(nmethod* nm, address pc) {\n@@ -113,1 +113,1 @@\n-  for (ScopeDesc* scope = cm->scope_desc_at(pc); scope != nullptr; scope = scope->sender()) {\n+  for (ScopeDesc* scope = nm->scope_desc_at(pc); scope != nullptr; scope = scope->sender()) {\n@@ -121,2 +121,2 @@\n-         || (f.cb() != nullptr && f.cb()->is_compiled() && f.cb()->as_compiled_method()->is_java_method()), \"\");\n-  return f.is_interpreted() ? 1 : num_java_frames(f.cb()->as_compiled_method(), f.orig_pc());\n+         || (f.cb() != nullptr && f.cb()->is_nmethod() && f.cb()->as_nmethod()->is_java_method()), \"\");\n+  return f.is_interpreted() ? 1 : num_java_frames(f.cb()->as_nmethod(), f.orig_pc());\n@@ -563,1 +563,1 @@\n-  if (closure._cb != nullptr && closure._cb->is_compiled()) {\n+  if (closure._cb != nullptr && closure._cb->is_nmethod()) {\n@@ -565,1 +565,1 @@\n-      (closure._cb->as_compiled_method()->method()->num_stack_arg_slots()*VMRegImpl::stack_slot_size) >>LogBytesPerWord,\n+      (closure._cb->as_nmethod()->method()->num_stack_arg_slots()*VMRegImpl::stack_slot_size) >>LogBytesPerWord,\n@@ -567,1 +567,1 @@\n-      (closure._cb->as_compiled_method()->method()->num_stack_arg_slots()*VMRegImpl::stack_slot_size) >>LogBytesPerWord);\n+      (closure._cb->as_nmethod()->method()->num_stack_arg_slots()*VMRegImpl::stack_slot_size) >>LogBytesPerWord);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-                 notproduct,                                                \\\n@@ -107,1 +106,1 @@\n-  notproduct(intx, IndexSetWatch, 0,                                        \\\n+  develop(intx, IndexSetWatch, 0,                                           \\\n@@ -122,1 +121,1 @@\n-  notproduct(bool, PrintIdeal, false,                                       \\\n+  develop(bool, PrintIdeal, false,                                          \\\n@@ -125,1 +124,1 @@\n-  notproduct(bool, PrintOpto, false,                                        \\\n+  develop(bool, PrintOpto, false,                                           \\\n@@ -128,1 +127,1 @@\n-  notproduct(bool, PrintOptoInlining, false,                                \\\n+  develop(bool, PrintOptoInlining, false,                                   \\\n@@ -131,1 +130,1 @@\n-  notproduct(bool, VerifyIdealNodeCount, false,                             \\\n+  develop(bool, VerifyIdealNodeCount, false,                                \\\n@@ -134,1 +133,1 @@\n-  notproduct(bool, PrintIdealNodeCount, false,                              \\\n+  develop(bool, PrintIdealNodeCount, false,                                 \\\n@@ -143,1 +142,1 @@\n-  notproduct(bool, OptoBreakpointOSR, false,                                \\\n+  develop(bool, OptoBreakpointOSR, false,                                   \\\n@@ -146,1 +145,1 @@\n-  notproduct(uint64_t, BreakAtNode, 0,                                      \\\n+  develop(uint64_t, BreakAtNode, 0,                                         \\\n@@ -149,1 +148,1 @@\n-  notproduct(bool, OptoBreakpointC2R, false,                                \\\n+  develop(bool, OptoBreakpointC2R, false,                                   \\\n@@ -152,1 +151,1 @@\n-  notproduct(bool, OptoNoExecute, false,                                    \\\n+  develop(bool, OptoNoExecute, false,                                       \\\n@@ -155,1 +154,1 @@\n-  notproduct(bool, PrintOptoStatistics, false,                              \\\n+  develop(bool, PrintOptoStatistics, false,                                 \\\n@@ -164,1 +163,1 @@\n-  notproduct(bool, PrintFrameConverterAssembly, false,                      \\\n+  develop(bool, PrintFrameConverterAssembly, false,                         \\\n@@ -167,1 +166,1 @@\n-  notproduct(bool, PrintParseStatistics, false,                             \\\n+  develop(bool, PrintParseStatistics, false,                                \\\n@@ -170,1 +169,1 @@\n-  notproduct(bool, PrintOptoPeephole, false,                                \\\n+  develop(bool, PrintOptoPeephole, false,                                   \\\n@@ -195,1 +194,1 @@\n-  notproduct(bool, TraceSuperWordLoopUnrollAnalysis, false,                 \\\n+  develop(bool, TraceSuperWordLoopUnrollAnalysis, false,                    \\\n@@ -224,1 +223,1 @@\n-  notproduct(bool, TraceProfileTripCount, false,                            \\\n+  develop(bool, TraceProfileTripCount, false,                               \\\n@@ -281,1 +280,1 @@\n-  notproduct(bool, VerifyGraphEdges , false,                                \\\n+  develop(bool, VerifyGraphEdges , false,                                   \\\n@@ -284,1 +283,1 @@\n-  notproduct(bool, VerifyDUIterators, true,                                 \\\n+  develop(bool, VerifyDUIterators, true,                                    \\\n@@ -287,1 +286,1 @@\n-  notproduct(bool, VerifyHashTableKeys, true,                               \\\n+  develop(bool, VerifyHashTableKeys, true,                                  \\\n@@ -290,1 +289,1 @@\n-  notproduct(bool, VerifyRegisterAllocator , false,                         \\\n+  develop(bool, VerifyRegisterAllocator , false,                            \\\n@@ -305,1 +304,1 @@\n-  notproduct(bool, TraceOptoPipelining, false,                              \\\n+  develop(bool, TraceOptoPipelining, false,                                 \\\n@@ -308,1 +307,1 @@\n-  notproduct(bool, TraceOptoOutput, false,                                  \\\n+  develop(bool, TraceOptoOutput, false,                                     \\\n@@ -324,1 +323,1 @@\n-  notproduct(bool, TracePartialPeeling, false,                              \\\n+  develop(bool, TracePartialPeeling, false,                                 \\\n@@ -336,1 +335,1 @@\n-  notproduct(bool, TraceLoopUnswitching, false,                             \\\n+  develop(bool, TraceLoopUnswitching, false,                                \\\n@@ -351,1 +350,1 @@\n-  notproduct(bool, TraceSuperWord, false,                                   \\\n+  develop(bool, TraceSuperWord, false,                                      \\\n@@ -354,1 +353,1 @@\n-  notproduct(bool, TraceNewVectors, false,                                  \\\n+  develop(bool, TraceNewVectors, false,                                     \\\n@@ -364,1 +363,1 @@\n-  notproduct(bool, PrintIdealGraph, false,                                  \\\n+  develop(bool, PrintIdealGraph, false,                                     \\\n@@ -368,1 +367,1 @@\n-  notproduct(intx, PrintIdealGraphLevel, 0,                                 \\\n+  develop(intx, PrintIdealGraphLevel, 0,                                    \\\n@@ -377,1 +376,1 @@\n-  notproduct(intx, PrintIdealGraphPort, 4444,                               \\\n+  develop(intx, PrintIdealGraphPort, 4444,                                  \\\n@@ -381,1 +380,1 @@\n-  notproduct(ccstr, PrintIdealGraphAddress, \"127.0.0.1\",                    \\\n+  develop(ccstr, PrintIdealGraphAddress, \"127.0.0.1\",                       \\\n@@ -384,1 +383,1 @@\n-  notproduct(ccstr, PrintIdealGraphFile, nullptr,                           \\\n+  develop(ccstr, PrintIdealGraphFile, nullptr,                              \\\n@@ -452,1 +451,1 @@\n-  notproduct(bool, PrintLockStatistics, false,                              \\\n+  develop(bool, PrintLockStatistics, false,                                 \\\n@@ -458,1 +457,1 @@\n-  notproduct(bool, PrintEliminateLocks, false,                              \\\n+  develop(bool, PrintEliminateLocks, false,                                 \\\n@@ -477,1 +476,1 @@\n-  notproduct(bool, TraceReduceAllocationMerges, false,                      \\\n+  develop(bool, TraceReduceAllocationMerges, false,                         \\\n@@ -493,1 +492,1 @@\n-  notproduct(bool, PrintEscapeAnalysis, false,                              \\\n+  develop(bool, PrintEscapeAnalysis, false,                                 \\\n@@ -499,1 +498,1 @@\n-  notproduct(bool, PrintEliminateAllocations, false,                        \\\n+  develop(bool, PrintEliminateAllocations, false,                           \\\n@@ -513,1 +512,1 @@\n-  notproduct(bool, PrintOptimizePtrCompare, false,                          \\\n+  develop(bool, PrintOptimizePtrCompare, false,                             \\\n@@ -516,1 +515,1 @@\n-  notproduct(bool, VerifyConnectionGraph , true,                            \\\n+  develop(bool, VerifyConnectionGraph , true,                               \\\n@@ -522,1 +521,1 @@\n-  notproduct(bool, PrintOptimizeStringConcat, false,                        \\\n+  develop(bool, PrintOptimizeStringConcat, false,                           \\\n@@ -583,1 +582,1 @@\n-  notproduct(bool, TracePhaseCCP, false,                                    \\\n+  develop(bool, TracePhaseCCP, false,                                       \\\n@@ -617,1 +616,1 @@\n-  notproduct(bool, VerifyLoopOptimizations, false,                          \\\n+  develop(bool, VerifyLoopOptimizations, false,                             \\\n@@ -633,1 +632,1 @@\n-  notproduct(bool, TraceCISCSpill, false,                                   \\\n+  develop(bool, TraceCISCSpill, false,                                      \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":42,"deletions":43,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+    init_class_id(Class_CastPP);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5017,10 +5017,1 @@\n-#ifdef ASSERT\n-          if (!in_hash) {\n-            tty->print_cr(\"current graph:\");\n-            n->dump_bfs(MaxNodeLimit, nullptr, \"S$\");\n-            tty->cr();\n-            tty->print_cr(\"erroneous node:\");\n-            n->dump();\n-            assert(false, \"node should be in igvn hash table\");\n-          }\n-#endif\n+          assert(in_hash || n->hash() == Node::NO_HASH, \"node should be in igvn hash table\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+#include \"opto\/narrowptrnode.hpp\"\n+#include \"opto\/castnode.hpp\"\n@@ -413,8 +415,11 @@\n-  \/\/ 6. Remove reducible allocation merges from ideal graph\n-  if (reducible_merges.size() > 0) {\n-    bool delay = _igvn->delay_transform();\n-    _igvn->set_delay_transform(true);\n-    for (uint i = 0; i < reducible_merges.size(); i++ ) {\n-      Node* n = reducible_merges.at(i);\n-      reduce_phi(n->as_Phi());\n-      if (C->failing()) {\n+  \/\/ 6. Reduce allocation merges used as debug information. This is done after\n+  \/\/ split_unique_types because the methods used to create SafePointScalarObject\n+  \/\/ need to traverse the memory graph to find values for object fields. We also\n+  \/\/ set to null the scalarized inputs of reducible Phis so that the Allocate\n+  \/\/ that they point can be later scalar replaced.\n+  bool delay = _igvn->delay_transform();\n+  _igvn->set_delay_transform(true);\n+  for (uint i = 0; i < reducible_merges.size(); i++) {\n+    Node* n = reducible_merges.at(i);\n+    if (n->outcnt() > 0) {\n+      if (!reduce_phi_on_safepoints(n->as_Phi())) {\n@@ -422,0 +427,1 @@\n+        C->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n@@ -424,0 +430,4 @@\n+\n+      \/\/ Now we set the scalar replaceable inputs of ophi to null, which is\n+      \/\/ the last piece that would prevent it from being scalar replaceable.\n+      reset_scalar_replaceable_entries(n->as_Phi());\n@@ -425,1 +435,0 @@\n-    _igvn->set_delay_transform(delay);\n@@ -427,0 +436,1 @@\n+  _igvn->set_delay_transform(delay);\n@@ -451,2 +461,1 @@\n-\/\/ if at least one scalar replaceable allocation participates in the merge and\n-\/\/ no input to the Phi is nullable.\n+\/\/ if at least one scalar replaceable allocation participates in the merge.\n@@ -454,1 +463,0 @@\n-  \/\/ Check if there is a scalar replaceable allocate in the Phi\n@@ -458,8 +466,0 @@\n-    \/\/ Right now we can't restore a \"null\" pointer during deoptimization\n-    const Type* inp_t = _igvn->type(ophi->in(i));\n-    if (inp_t == nullptr || inp_t->make_oopptr() == nullptr || inp_t->make_oopptr()->maybe_null()) {\n-      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Input %d is nullable.\", ophi->_idx, _invocation, i);)\n-      return false;\n-    }\n-\n-    \/\/ We are looking for at least one SR object in the merge\n@@ -468,1 +468,0 @@\n-      assert(ptn->ideal_node() != nullptr && ptn->ideal_node()->is_Allocate(), \"sanity\");\n@@ -471,0 +470,6 @@\n+      \/\/ Don't handle arrays.\n+      if (alloc->Opcode() != Op_Allocate) {\n+        assert(alloc->Opcode() == Op_AllocateArray, \"Unexpected type of allocation.\");\n+        continue;\n+      }\n+\n@@ -474,0 +479,1 @@\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"%dth input of Phi %d is SR but can't be eliminated.\", i, ophi->_idx);)\n@@ -483,5 +489,42 @@\n-\/\/ Check if we are able to untangle the merge. Right now we only reduce Phis\n-\/\/ which are only used as debug information.\n-bool ConnectionGraph::can_reduce_phi_check_users(PhiNode* ophi) const {\n-  for (DUIterator_Fast imax, i = ophi->fast_outs(imax); i < imax; i++) {\n-    Node* use = ophi->fast_out(i);\n+\/\/ We can reduce the Cmp if it's a comparison between the Phi and a constant.\n+\/\/ I require the 'other' input to be a constant so that I can move the Cmp\n+\/\/ around safely.\n+bool ConnectionGraph::can_reduce_cmp(Node* n, Node* cmp) const {\n+  Node* left = cmp->in(1);\n+  Node* right = cmp->in(2);\n+\n+  return (cmp->Opcode() == Op_CmpP || cmp->Opcode() == Op_CmpN) &&\n+         (left == n || right == n) &&\n+         (left->is_Con() || right->is_Con()) &&\n+         cmp->outcnt() == 1;\n+}\n+\n+\/\/ We are going to check if any of the SafePointScalarMerge entries\n+\/\/ in the SafePoint reference the Phi that we are checking.\n+bool ConnectionGraph::has_been_reduced(PhiNode* n, SafePointNode* sfpt) const {\n+  JVMState *jvms = sfpt->jvms();\n+\n+  for (uint i = jvms->debug_start(); i < jvms->debug_end(); i++) {\n+    Node* sfpt_in = sfpt->in(i);\n+    if (sfpt_in->is_SafePointScalarMerge()) {\n+      SafePointScalarMergeNode* smerge = sfpt_in->as_SafePointScalarMerge();\n+      Node* nsr_ptr = sfpt->in(smerge->merge_pointer_idx(jvms));\n+      if (nsr_ptr == n) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ Check if we are able to untangle the merge. The following patterns are\n+\/\/ supported:\n+\/\/  - Phi -> SafePoints\n+\/\/  - Phi -> CmpP\/N\n+\/\/  - Phi -> AddP -> Load\n+\/\/  - Phi -> CastPP -> SafePoints\n+\/\/  - Phi -> CastPP -> AddP -> Load\n+bool ConnectionGraph::can_reduce_check_users(Node* n, uint nesting) const {\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* use = n->fast_out(i);\n@@ -490,2 +533,5 @@\n-      if (use->is_Call() && use->as_Call()->has_non_debug_use(ophi)) {\n-        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Call has non_debug_use().\", ophi->_idx, _invocation);)\n+      if (use->is_Call() && use->as_Call()->has_non_debug_use(n)) {\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Call has non_debug_use().\", n->_idx, _invocation);)\n+        return false;\n+      } else if (has_been_reduced(n->is_Phi() ? n->as_Phi() : n->as_CastPP()->in(1)->as_Phi(), use->as_SafePoint())) {\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. It has already been reduced.\", n->_idx, _invocation);)\n@@ -498,0 +544,2 @@\n+        const Type* load_type = _igvn->type(use_use);\n+\n@@ -499,1 +547,4 @@\n-          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. AddP user isn't a [splittable] Load(): %s\", ophi->_idx, _invocation, use_use->Name());)\n+          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. AddP user isn't a [splittable] Load(): %s\", n->_idx, _invocation, use_use->Name());)\n+          return false;\n+        } else if (nesting > 0 && load_type->isa_narrowklass()) {\n+          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Nested NarrowKlass Load: %s\", n->_idx, _invocation, use_use->Name());)\n@@ -503,0 +554,34 @@\n+    } else if (nesting > 0) {\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Unsupported user %s at nesting level %d.\", n->_idx, _invocation, use->Name(), nesting);)\n+      return false;\n+    } else if (use->is_CastPP()) {\n+      const Type* cast_t = _igvn->type(use);\n+      if (cast_t == nullptr || cast_t->make_ptr()->isa_instptr() == nullptr) {\n+        NOT_PRODUCT(use->dump();)\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP is not to an instance.\", n->_idx, _invocation);)\n+        return false;\n+      }\n+\n+      bool is_trivial_control = use->in(0) == nullptr || use->in(0) == n->in(0);\n+      if (!is_trivial_control) {\n+        \/\/ If it's not a trivial control then we check if we can reduce the\n+        \/\/ CmpP\/N used by the If controlling the cast.\n+        if (use->in(0)->is_IfTrue() || use->in(0)->is_IfFalse()) {\n+          Node* iff = use->in(0)->in(0);\n+          Node* iff_cmp = iff->in(1)->in(1); \/\/ if->bool->cmp\n+          if (!can_reduce_cmp(n, iff_cmp)) {\n+            NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);)\n+            NOT_PRODUCT(n->dump(5);)\n+            return false;\n+          }\n+        }\n+      }\n+\n+      if (!can_reduce_check_users(use, nesting+1)) {\n+        return false;\n+      }\n+    } else if (use->Opcode() == Op_CmpP || use->Opcode() == Op_CmpN) {\n+      if (!can_reduce_cmp(n, use)) {\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CmpP\/N %d isn't reducible.\", n->_idx, _invocation, use->_idx);)\n+        return false;\n+      }\n@@ -504,1 +589,1 @@\n-      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. One of the uses is: %d %s\", ophi->_idx, _invocation, use->_idx, use->Name());)\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. One of the uses is: %d %s\", n->_idx, _invocation, use->_idx, use->Name());)\n@@ -520,2 +605,1 @@\n-  \/\/ If EliminateAllocations is False, there is no point in reducing merges.\n-  if (!_compile->do_reduce_allocation_merges()) {\n+  if (!_compile->do_reduce_allocation_merges() || ophi->region()->Opcode() != Op_Region) {\n@@ -526,4 +610,3 @@\n-  if (phi_t == nullptr || phi_t->make_ptr() == nullptr ||\n-                          phi_t->make_ptr()->isa_instptr() == nullptr ||\n-                          !phi_t->make_ptr()->isa_instptr()->klass_is_exact()) {\n-    NOT_PRODUCT(if (TraceReduceAllocationMerges) { tty->print_cr(\"Can NOT reduce Phi %d during invocation %d because it's nullable.\", ophi->_idx, _invocation); })\n+  if (phi_t == nullptr ||\n+      phi_t->make_ptr() == nullptr ||\n+      phi_t->make_ptr()->isa_aryptr() != nullptr) {\n@@ -533,1 +616,1 @@\n-  if (!can_reduce_phi_check_inputs(ophi) || !can_reduce_phi_check_users(ophi)) {\n+  if (!can_reduce_phi_check_inputs(ophi) || !can_reduce_check_users(ophi, \/* nesting: *\/ 0)) {\n@@ -541,11 +624,19 @@\n-void ConnectionGraph::reduce_phi_on_field_access(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist) {\n-  \/\/ We'll pass this to 'split_through_phi' so that it'll do the split even\n-  \/\/ though the load doesn't have an unique instance type.\n-  bool ignore_missing_instance_id = true;\n-\n-#ifdef ASSERT\n-  if (VerifyReduceAllocationMerges && !can_reduce_phi(ophi)) {\n-    TraceReduceAllocationMerges = true;\n-    ophi->dump(2);\n-    ophi->dump(-2);\n-    assert(can_reduce_phi(ophi), \"Sanity: previous reducible Phi is no longer reducible inside reduce_phi_on_field_access.\");\n+\/\/ This method will return a CmpP\/N that we need to use on the If controlling a\n+\/\/ CastPP after it was split. This method is only called on bases that are\n+\/\/ nullable therefore we always need a controlling if for the splitted CastPP.\n+\/\/\n+\/\/ 'curr_ctrl' is the control of the CastPP that we want to split through phi.\n+\/\/ If the CastPP currently doesn't have a control then the CmpP\/N will be\n+\/\/ against the NULL constant, otherwise it will be against the constant input of\n+\/\/ the existing CmpP\/N. It's guaranteed that there will be a CmpP\/N in the later\n+\/\/ case because we have constraints on it and because the CastPP has a control\n+\/\/ input.\n+Node* ConnectionGraph::specialize_cmp(Node* base, Node* curr_ctrl) {\n+  const Type* t = base->bottom_type();\n+  Node* con = nullptr;\n+\n+  if (curr_ctrl == nullptr || curr_ctrl->is_Region()) {\n+    con = _igvn->zerocon(t->basic_type());\n+  } else {\n+    Node* curr_cmp = curr_ctrl->in(0)->in(1)->in(1); \/\/ true\/false -> if -> bool -> cmp\n+    con = curr_cmp->in(1)->is_Con() ? curr_cmp->in(1) : curr_cmp->in(2);\n@@ -553,1 +644,0 @@\n-#endif\n@@ -555,33 +645,2 @@\n-  \/\/ Iterate over Phi outputs looking for an AddP\n-  for (int j = ophi->outcnt()-1; j >= 0;) {\n-    Node* previous_addp = ophi->raw_out(j);\n-    if (previous_addp->is_AddP()) {\n-      \/\/ All AddPs are present in the connection graph\n-      FieldNode* fn = ptnode_adr(previous_addp->_idx)->as_Field();\n-\n-      \/\/ Iterate over AddP looking for a Load\n-      for (int k = previous_addp->outcnt()-1; k >= 0;) {\n-        Node* previous_load = previous_addp->raw_out(k);\n-        if (previous_load->is_Load()) {\n-          Node* data_phi = previous_load->as_Load()->split_through_phi(_igvn, ignore_missing_instance_id);\n-          _igvn->replace_node(previous_load, data_phi);\n-          assert(data_phi != nullptr, \"Output of split_through_phi is null.\");\n-          assert(data_phi != previous_load, \"Output of split_through_phi is same as input.\");\n-          assert(data_phi->is_Phi(), \"Return of split_through_phi should be a Phi.\");\n-\n-          \/\/ Push the newly created AddP on alloc_worklist and patch\n-          \/\/ the connection graph. Note that the changes in the CG below\n-          \/\/ won't affect the ES of objects since the new nodes have the\n-          \/\/ same status as the old ones.\n-          for (uint i = 1; i < data_phi->req(); i++) {\n-            Node* new_load = data_phi->in(i);\n-            if (new_load->is_Load()) {\n-              Node* new_addp = new_load->in(MemNode::Address);\n-              Node* base = get_addp_base(new_addp);\n-\n-              \/\/ The base might not be something that we can create an unique\n-              \/\/ type for. If that's the case we are done with that input.\n-              PointsToNode* jobj_ptn = unique_java_object(base);\n-              if (jobj_ptn == nullptr || !jobj_ptn->scalar_replaceable()) {\n-                continue;\n-              }\n+  return CmpNode::make(base, con, t->basic_type());\n+}\n@@ -589,20 +648,85 @@\n-              \/\/ Push to alloc_worklist since the base has an unique_type\n-              alloc_worklist.append_if_missing(new_addp);\n-\n-              \/\/ Now let's add the node to the connection graph\n-              _nodes.at_grow(new_addp->_idx, nullptr);\n-              add_field(new_addp, fn->escape_state(), fn->offset());\n-              add_base(ptnode_adr(new_addp->_idx)->as_Field(), ptnode_adr(base->_idx));\n-\n-              \/\/ If the load doesn't load an object then it won't be\n-              \/\/ part of the connection graph\n-              PointsToNode* curr_load_ptn = ptnode_adr(previous_load->_idx);\n-              if (curr_load_ptn != nullptr) {\n-                _nodes.at_grow(new_load->_idx, nullptr);\n-                add_local_var(new_load, curr_load_ptn->escape_state());\n-                add_edge(ptnode_adr(new_load->_idx), ptnode_adr(new_addp->_idx)->as_Field());\n-              }\n-            }\n-          }\n-        }\n-        k = MIN2(--k, (int)previous_addp->outcnt()-1);\n+\/\/ This method 'specializes' the CastPP passed as parameter to the base passed\n+\/\/ as parameter. Note that the existing CastPP input is a Phi. \"Specialize\"\n+\/\/ means that the CastPP now will be specific for a given base instead of a Phi.\n+\/\/ An If-Then-Else-Region block is inserted to control the CastPP. The control\n+\/\/ of the CastPP is a copy of the current one (if there is one) or a check\n+\/\/ against NULL.\n+\/\/\n+\/\/ Before:\n+\/\/\n+\/\/    C1     C2  ... Cn\n+\/\/     \\      |      \/\n+\/\/      \\     |     \/\n+\/\/       \\    |    \/\n+\/\/        \\   |   \/\n+\/\/         \\  |  \/\n+\/\/          \\ | \/\n+\/\/           \\|\/\n+\/\/          Region     B1      B2  ... Bn\n+\/\/            |          \\      |      \/\n+\/\/            |           \\     |     \/\n+\/\/            |            \\    |    \/\n+\/\/            |             \\   |   \/\n+\/\/            |              \\  |  \/\n+\/\/            |               \\ | \/\n+\/\/            ---------------> Phi\n+\/\/                              |\n+\/\/                      X       |\n+\/\/                      |       |\n+\/\/                      |       |\n+\/\/                      ------> CastPP\n+\/\/\n+\/\/ After (only partial illustration; base = B2, current_control = C2):\n+\/\/\n+\/\/                      C2\n+\/\/                      |\n+\/\/                      If\n+\/\/                     \/ \\\n+\/\/                    \/   \\\n+\/\/                   T     F\n+\/\/                  \/\\     \/\n+\/\/                 \/  \\   \/\n+\/\/                \/    \\ \/\n+\/\/      C1    CastPP   Reg        Cn\n+\/\/       |              |          |\n+\/\/       |              |          |\n+\/\/       |              |          |\n+\/\/       -------------- | ----------\n+\/\/                    | | |\n+\/\/                    Region\n+\/\/\n+Node* ConnectionGraph::specialize_castpp(Node* castpp, Node* base, Node* current_control) {\n+  Node* control_successor  = current_control->unique_ctrl_out();\n+  Node* minus_one          = _igvn->transform(ConINode::make(-1));\n+  Node* cmp                = _igvn->transform(specialize_cmp(base, castpp->in(0)));\n+  Node* boll               = _igvn->transform(new BoolNode(cmp, BoolTest::ne));\n+  IfNode* if_ne            = _igvn->transform(new IfNode(current_control, boll, PROB_MIN, COUNT_UNKNOWN))->as_If();\n+  Node* not_eq_control     = _igvn->transform(new IfTrueNode(if_ne));\n+  Node* yes_eq_control     = _igvn->transform(new IfFalseNode(if_ne));\n+  Node* end_region         = _igvn->transform(new RegionNode(3));\n+\n+  \/\/ Insert the new if-else-region block into the graph\n+  end_region->set_req(1, not_eq_control);\n+  end_region->set_req(2, yes_eq_control);\n+  control_successor->replace_edge(current_control, end_region, _igvn);\n+\n+  _igvn->_worklist.push(current_control);\n+  _igvn->_worklist.push(control_successor);\n+\n+  return _igvn->transform(ConstraintCastNode::make_cast_for_type(not_eq_control, base, _igvn->type(castpp), ConstraintCastNode::UnconditionalDependency, nullptr));\n+}\n+\n+Node* ConnectionGraph::split_castpp_load_through_phi(Node* curr_addp, Node* curr_load, Node* region, GrowableArray<Node*>* bases_for_loads, GrowableArray<Node *>  &alloc_worklist) {\n+  const Type* load_type = _igvn->type(curr_load);\n+  Node* nsr_value       = _igvn->zerocon(load_type->basic_type());\n+  Node* data_phi        = _igvn->transform(PhiNode::make(region, nsr_value, load_type));\n+  Node* memory          = curr_load->in(MemNode::Memory);\n+\n+  for (int i = 1; i < bases_for_loads->length(); i++) {\n+    Node* base = bases_for_loads->at(i);\n+    Node* cmp_region = nullptr;\n+    if (base != nullptr) {\n+      if (base->is_CFG()) { \/\/ means that we added a CastPP as child of this CFG node\n+        cmp_region = base->unique_ctrl_out_or_null();\n+        assert(cmp_region != nullptr, \"There should be.\");\n+        base = base->find_out_with(Op_CastPP);\n@@ -611,3 +735,16 @@\n-      \/\/ Remove the old AddP from the processing list because it's dead now\n-      alloc_worklist.remove_if_existing(previous_addp);\n-      _igvn->remove_globally_dead_node(previous_addp);\n+      Node* addr = _igvn->transform(new AddPNode(base, base, curr_addp->in(AddPNode::Offset)));\n+      Node* mem = (memory->is_Phi() && (memory->in(0) == region)) ? memory->in(i) : memory;\n+      Node* load = _igvn->transform(curr_load->clone());\n+      load->set_req(0, nullptr);\n+      load->set_req(1, mem);\n+      load->set_req(2, addr);\n+\n+      if (cmp_region != nullptr) { \/\/ see comment on previous if\n+        Node* intermediate_phi = _igvn->transform(PhiNode::make(cmp_region, nsr_value, load_type));\n+        intermediate_phi->set_req(1, load);\n+        load = intermediate_phi;\n+      }\n+\n+      data_phi->set_req(i, load);\n+    } else {\n+      \/\/ Just use the default, which is already in phi\n@@ -615,1 +752,0 @@\n-    j = MIN2(--j, (int)ophi->outcnt()-1);\n@@ -618,8 +754,109 @@\n-#ifdef ASSERT\n-  if (VerifyReduceAllocationMerges) {\n-    for (uint j = 0; j < ophi->outcnt(); j++) {\n-      Node* use = ophi->raw_out(j);\n-      if (!use->is_SafePoint()) {\n-        ophi->dump(2);\n-        ophi->dump(-2);\n-        assert(false, \"Should be a SafePoint.\");\n+  \/\/ Takes care of updating CG and split_unique_types worklists due to cloned\n+  \/\/ AddP->Load.\n+  updates_after_load_split(data_phi, curr_load, alloc_worklist);\n+\n+  return data_phi;\n+}\n+\n+\/\/ This method only reduces CastPP fields loads; SafePoints are handled\n+\/\/ separately. The idea here is basically to clone the CastPP and place copies\n+\/\/ on each input of the Phi, including non-scalar replaceable inputs.\n+\/\/ Experimentation shows that the resulting IR graph is simpler that way than if\n+\/\/ we just split the cast through scalar-replaceable inputs.\n+\/\/\n+\/\/ The reduction process requires that CastPP's control be one of:\n+\/\/  1) no control,\n+\/\/  2) the same region as Ophi, or\n+\/\/  3) an IfTrue\/IfFalse coming from an CmpP\/N between Ophi and a constant.\n+\/\/\n+\/\/ After splitting the CastPP we'll put it under an If-Then-Else-Region control\n+\/\/ flow. If the CastPP originally had an IfTrue\/False control input then we'll\n+\/\/ use a similar CmpP\/N to control the new If-Then-Else-Region. Otherwise, we'll\n+\/\/ juse use a CmpP\/N against the NULL constant.\n+\/\/\n+\/\/ The If-Then-Else-Region isn't always needed. For instance, if input to\n+\/\/ splitted cast was not nullable (or if it was the NULL constant) then we don't\n+\/\/ need (shouldn't) use a CastPP at all.\n+\/\/\n+\/\/ After the casts are splitted we'll split the AddP->Loads through the Phi and\n+\/\/ connect them to the just split CastPPs.\n+\/\/\n+\/\/ Before (CastPP control is same as Phi):\n+\/\/\n+\/\/          Region     Allocate   Null    Call\n+\/\/            |             \\      |      \/\n+\/\/            |              \\     |     \/\n+\/\/            |               \\    |    \/\n+\/\/            |                \\   |   \/\n+\/\/            |                 \\  |  \/\n+\/\/            |                  \\ | \/\n+\/\/            ------------------> Phi            # Oop Phi\n+\/\/            |                    |\n+\/\/            |                    |\n+\/\/            |                    |\n+\/\/            |                    |\n+\/\/            ----------------> CastPP\n+\/\/                                 |\n+\/\/                               AddP\n+\/\/                                 |\n+\/\/                               Load\n+\/\/\n+\/\/ After (Very much simplified):\n+\/\/\n+\/\/                         Call  NULL\n+\/\/                            \\  \/\n+\/\/                            CmpP\n+\/\/                             |\n+\/\/                           Bool#NE\n+\/\/                             |\n+\/\/                             If\n+\/\/                            \/ \\\n+\/\/                           T   F\n+\/\/                          \/ \\ \/\n+\/\/                         \/   R\n+\/\/                     CastPP  |\n+\/\/                       |     |\n+\/\/                     AddP    |\n+\/\/                       |     |\n+\/\/                     Load    |\n+\/\/                         \\   |   0\n+\/\/            Allocate      \\  |  \/\n+\/\/                \\          \\ | \/\n+\/\/               AddP         Phi\n+\/\/                  \\         \/\n+\/\/                 Load      \/\n+\/\/                    \\  0  \/\n+\/\/                     \\ | \/\n+\/\/                      \\|\/\n+\/\/                      Phi        # \"Field\" Phi\n+\/\/\n+void ConnectionGraph::reduce_phi_on_castpp_field_load(Node* curr_castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist) {\n+  Node* ophi = curr_castpp->in(1);\n+  assert(ophi->is_Phi(), \"Expected this to be a Phi node.\");\n+\n+  \/\/ Identify which base should be used for AddP->Load later when spliting the\n+  \/\/ CastPP->Loads through ophi. Three kind of values may be stored in this\n+  \/\/ array, depending on the nullability status of the corresponding input in\n+  \/\/ ophi.\n+  \/\/\n+  \/\/  - nullptr:    Meaning that the base is actually the NULL constant and therefore\n+  \/\/                we won't try to load from it.\n+  \/\/\n+  \/\/  - CFG Node:   Meaning that the base is a CastPP that was specialized for\n+  \/\/                this input of Ophi. I.e., we added an If->Then->Else-Region\n+  \/\/                that will 'activate' the CastPp only when the input is not Null.\n+  \/\/\n+  \/\/  - Other Node: Meaning that the base is not nullable and therefore we'll try\n+  \/\/                to load directly from it.\n+  GrowableArray<Node*> bases_for_loads(ophi->req(), ophi->req(), nullptr);\n+\n+  for (uint i = 1; i < ophi->req(); i++) {\n+    Node* base = ophi->in(i);\n+    const Type* base_t = _igvn->type(base);\n+\n+    if (base_t->maybe_null()) {\n+      if (base->is_Con()) {\n+        \/\/ Nothing todo as bases_for_loads[i] is already nullptr\n+      } else {\n+        Node* new_castpp = specialize_castpp(curr_castpp, base, ophi->in(0)->in(i));\n+        bases_for_loads.at_put(i, new_castpp->in(0)); \/\/ Use the ctrl of the new node just as a flag\n@@ -627,0 +864,2 @@\n+    } else {\n+      bases_for_loads.at_put(i, base);\n@@ -629,1 +868,25 @@\n-#endif\n+\n+  \/\/ Now let's split the CastPP->Loads through the Phi\n+  for (int i = curr_castpp->outcnt()-1; i >= 0;) {\n+    Node* use = curr_castpp->raw_out(i);\n+    if (use->is_AddP()) {\n+      for (int j = use->outcnt()-1; j >= 0;) {\n+        Node* use_use = use->raw_out(j);\n+        assert(use_use->is_Load(), \"Expected this to be a Load node.\");\n+\n+        \/\/ We can't make an unconditional load from a nullable input. The\n+        \/\/ 'split_castpp_load_through_phi` method will add an\n+        \/\/ 'If-Then-Else-Region` around nullable bases and only load from them\n+        \/\/ when the input is not null.\n+        Node* phi = split_castpp_load_through_phi(use, use_use, ophi->in(0), &bases_for_loads, alloc_worklist);\n+        _igvn->replace_node(use_use, phi);\n+\n+        --j;\n+        j = MIN2(j, (int)use->outcnt()-1);\n+      }\n+\n+      _igvn->remove_dead_node(use);\n+    }\n+    --i;\n+    i = MIN2(i, (int)curr_castpp->outcnt()-1);\n+  }\n@@ -632,7 +895,8 @@\n-\/\/ This method will create a SafePointScalarObjectNode for each combination of\n-\/\/ scalar replaceable allocation in 'ophi' and SafePoint node in 'safepoints'.\n-\/\/ The method will create a SafePointScalarMERGEnode for each combination of\n-\/\/ 'ophi' and SafePoint node in 'safepoints'.\n-\/\/ Each SafePointScalarMergeNode created here may describe multiple scalar\n-\/\/ replaced objects - check detailed description in SafePointScalarMergeNode\n-\/\/ class header.\n+\/\/ This method split a given CmpP\/N through the Phi used in one of its inputs.\n+\/\/ As a result we convert a comparison with a pointer to a comparison with an\n+\/\/ integer.\n+\/\/ The only requirement is that one of the inputs of the CmpP\/N must be a Phi\n+\/\/ while the other must be a constant.\n+\/\/ The splitting process is basically just cloning the CmpP\/N above the input\n+\/\/ Phi.  However, some (most) of the cloned CmpP\/Ns won't be requred because we\n+\/\/ can prove at compile time the result of the comparison.\n@@ -640,8 +904,44 @@\n-\/\/ This method will set entries in the Phi that are scalar replaceable to 'null'.\n-void ConnectionGraph::reduce_phi_on_safepoints(PhiNode* ophi, Unique_Node_List* safepoints) {\n-  Node* minus_one           = _igvn->register_new_node_with_optimizer(ConINode::make(-1));\n-  Node* selector            = _igvn->register_new_node_with_optimizer(PhiNode::make(ophi->region(), minus_one, TypeInt::INT));\n-  Node* null_ptr            = _igvn->makecon(TypePtr::NULL_PTR);\n-  const TypeOopPtr* merge_t = _igvn->type(ophi)->make_oopptr();\n-  uint number_of_sr_objects = 0;\n-  PhaseMacroExpand mexp(*_igvn);\n+\/\/ Before:\n+\/\/\n+\/\/             in1    in2 ... inN\n+\/\/              \\      |      \/\n+\/\/               \\     |     \/\n+\/\/                \\    |    \/\n+\/\/                 \\   |   \/\n+\/\/                  \\  |  \/\n+\/\/                   \\ | \/\n+\/\/                    Phi\n+\/\/                     |   Other\n+\/\/                     |    \/\n+\/\/                     |   \/\n+\/\/                     |  \/\n+\/\/                    CmpP\/N\n+\/\/\n+\/\/ After:\n+\/\/\n+\/\/        in1  Other   in2 Other  inN  Other\n+\/\/         |    |      |   |      |    |\n+\/\/         \\    |      |   |      |    |\n+\/\/          \\  \/       |   \/      |    \/\n+\/\/          CmpP\/N    CmpP\/N     CmpP\/N\n+\/\/          Bool      Bool       Bool\n+\/\/            \\        |        \/\n+\/\/             \\       |       \/\n+\/\/              \\      |      \/\n+\/\/               \\     |     \/\n+\/\/                \\    |    \/\n+\/\/                 \\   |   \/\n+\/\/                  \\  |  \/\n+\/\/                   \\ | \/\n+\/\/                    Phi\n+\/\/                     |\n+\/\/                     |   Zero\n+\/\/                     |    \/\n+\/\/                     |   \/\n+\/\/                     |  \/\n+\/\/                     CmpI\n+\/\/\n+\/\/\n+void ConnectionGraph::reduce_phi_on_cmp(Node* cmp) {\n+  Node* ophi = cmp->in(1)->is_Con() ? cmp->in(2) : cmp->in(1);\n+  assert(ophi->is_Phi(), \"Expected this to be a Phi node.\");\n@@ -649,1 +949,28 @@\n-  _igvn->hash_delete(ophi);\n+  Node* other = cmp->in(1)->is_Con() ? cmp->in(1) : cmp->in(2);\n+  Node* zero = _igvn->intcon(0);\n+  BoolTest::mask mask = cmp->unique_out()->as_Bool()->_test._test;\n+\n+  \/\/ This Phi will merge the result of the Cmps split through the Phi\n+  Node* res_phi  = _igvn->transform(PhiNode::make(ophi->in(0), zero, TypeInt::INT));\n+\n+  for (uint i=1; i<ophi->req(); i++) {\n+    Node* ophi_input = ophi->in(i);\n+    Node* res_phi_input = nullptr;\n+\n+    const TypeInt* tcmp = optimize_ptr_compare(ophi_input, other);\n+    if (tcmp->singleton()) {\n+      res_phi_input = _igvn->makecon(tcmp);\n+    } else {\n+      Node* ncmp = _igvn->transform(cmp->clone());\n+      ncmp->set_req(1, ophi_input);\n+      ncmp->set_req(2, other);\n+      Node* boll = _igvn->transform(new BoolNode(ncmp, mask));\n+      res_phi_input = boll->as_Bool()->as_int_value(_igvn);\n+    }\n+\n+    res_phi->set_req(i, res_phi_input);\n+  }\n+\n+  Node* new_cmp = _igvn->transform(new CmpINode(res_phi, zero));\n+  _igvn->replace_node(cmp, new_cmp);\n+}\n@@ -651,5 +978,95 @@\n-  \/\/ Fill in the 'selector' Phi. If index 'i' of the selector is:\n-  \/\/ -> a '-1' constant, the i'th input of the original Phi is NSR.\n-  \/\/ -> a 'x' constant >=0, the i'th input of of original Phi will be SR and the\n-  \/\/    info about the scalarized object will be at index x of\n-  \/\/    ObjectMergeValue::possible_objects\n+\/\/ Push the newly created AddP on alloc_worklist and patch\n+\/\/ the connection graph. Note that the changes in the CG below\n+\/\/ won't affect the ES of objects since the new nodes have the\n+\/\/ same status as the old ones.\n+void ConnectionGraph::updates_after_load_split(Node* data_phi, Node* previous_load, GrowableArray<Node *>  &alloc_worklist) {\n+  assert(data_phi != nullptr, \"Output of split_through_phi is null.\");\n+  assert(data_phi != previous_load, \"Output of split_through_phi is same as input.\");\n+  assert(data_phi->is_Phi(), \"Output of split_through_phi isn't a Phi.\");\n+\n+  if (data_phi == nullptr || !data_phi->is_Phi()) {\n+    \/\/ Make this a retry?\n+    return ;\n+  }\n+\n+  Node* previous_addp = previous_load->in(MemNode::Address);\n+  FieldNode* fn = ptnode_adr(previous_addp->_idx)->as_Field();\n+  for (uint i = 1; i < data_phi->req(); i++) {\n+    Node* new_load = data_phi->in(i);\n+\n+    if (new_load->is_Phi()) {\n+      \/\/ new_load is currently the \"intermediate_phi\" from an specialized\n+      \/\/ CastPP.\n+      new_load = new_load->in(1);\n+    }\n+\n+    \/\/ \"new_load\" might actually be a constant, parameter, etc.\n+    if (new_load->is_Load()) {\n+      Node* new_addp = new_load->in(MemNode::Address);\n+      Node* base = get_addp_base(new_addp);\n+\n+      \/\/ The base might not be something that we can create an unique\n+      \/\/ type for. If that's the case we are done with that input.\n+      PointsToNode* jobj_ptn = unique_java_object(base);\n+      if (jobj_ptn == nullptr || !jobj_ptn->scalar_replaceable()) {\n+        continue;\n+      }\n+\n+      \/\/ Push to alloc_worklist since the base has an unique_type\n+      alloc_worklist.append_if_missing(new_addp);\n+\n+      \/\/ Now let's add the node to the connection graph\n+      _nodes.at_grow(new_addp->_idx, nullptr);\n+      add_field(new_addp, fn->escape_state(), fn->offset());\n+      add_base(ptnode_adr(new_addp->_idx)->as_Field(), ptnode_adr(base->_idx));\n+\n+      \/\/ If the load doesn't load an object then it won't be\n+      \/\/ part of the connection graph\n+      PointsToNode* curr_load_ptn = ptnode_adr(previous_load->_idx);\n+      if (curr_load_ptn != nullptr) {\n+        _nodes.at_grow(new_load->_idx, nullptr);\n+        add_local_var(new_load, curr_load_ptn->escape_state());\n+        add_edge(ptnode_adr(new_load->_idx), ptnode_adr(new_addp->_idx)->as_Field());\n+      }\n+    }\n+  }\n+}\n+\n+void ConnectionGraph::reduce_phi_on_field_access(Node* previous_addp, GrowableArray<Node *>  &alloc_worklist) {\n+  \/\/ We'll pass this to 'split_through_phi' so that it'll do the split even\n+  \/\/ though the load doesn't have an unique instance type.\n+  bool ignore_missing_instance_id = true;\n+\n+  \/\/ All AddPs are present in the connection graph\n+  FieldNode* fn = ptnode_adr(previous_addp->_idx)->as_Field();\n+\n+  \/\/ Iterate over AddP looking for a Load\n+  for (int k = previous_addp->outcnt()-1; k >= 0;) {\n+    Node* previous_load = previous_addp->raw_out(k);\n+    if (previous_load->is_Load()) {\n+      Node* data_phi = previous_load->as_Load()->split_through_phi(_igvn, ignore_missing_instance_id);\n+\n+      \/\/ Takes care of updating CG and split_unique_types worklists due to cloned\n+      \/\/ AddP->Load.\n+      updates_after_load_split(data_phi, previous_load, alloc_worklist);\n+\n+      _igvn->replace_node(previous_load, data_phi);\n+    }\n+    --k;\n+    k = MIN2(k, (int)previous_addp->outcnt()-1);\n+  }\n+\n+  \/\/ Remove the old AddP from the processing list because it's dead now\n+  assert(previous_addp->outcnt() == 0, \"AddP should be dead now.\");\n+  alloc_worklist.remove_if_existing(previous_addp);\n+}\n+\n+\/\/ Create a 'selector' Phi based on the inputs of 'ophi'. If index 'i' of the\n+\/\/ selector is:\n+\/\/    -> a '-1' constant, the i'th input of the original Phi is NSR.\n+\/\/    -> a 'x' constant >=0, the i'th input of of original Phi will be SR and\n+\/\/       the info about the scalarized object will be at index x of ObjectMergeValue::possible_objects\n+PhiNode* ConnectionGraph::create_selector(PhiNode* ophi) const {\n+  Node* minus_one = _igvn->register_new_node_with_optimizer(ConINode::make(-1));\n+  Node* selector  = _igvn->register_new_node_with_optimizer(PhiNode::make(ophi->region(), minus_one, TypeInt::INT));\n+  uint number_of_sr_objects = 0;\n@@ -657,1 +1074,1 @@\n-    Node* base          = ophi->in(i);\n+    Node* base = ophi->in(i);\n@@ -667,3 +1084,104 @@\n-  \/\/ Update the debug information of all safepoints in turn\n-  for (uint spi = 0; spi < safepoints->size(); spi++) {\n-    SafePointNode* sfpt = safepoints->at(spi)->as_SafePoint();\n+  return selector->as_Phi();\n+}\n+\n+\/\/ Returns true if the AddP node 'n' has at least one base that is a reducible\n+\/\/ merge. If the base is a CastPP\/CheckCastPP then the input of the cast is\n+\/\/ checked instead.\n+bool ConnectionGraph::has_reducible_merge_base(AddPNode* n, Unique_Node_List &reducible_merges) {\n+  PointsToNode* ptn = ptnode_adr(n->_idx);\n+  if (ptn == nullptr || !ptn->is_Field() || ptn->as_Field()->base_count() < 2) {\n+    return false;\n+  }\n+\n+  for (BaseIterator i(ptn->as_Field()); i.has_next(); i.next()) {\n+    Node* base = i.get()->ideal_node();\n+\n+    if (reducible_merges.member(base)) {\n+      return true;\n+    }\n+\n+    if (base->is_CastPP() || base->is_CheckCastPP()) {\n+      base = base->in(1);\n+      if (reducible_merges.member(base)) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ This method will call its helper method to reduce SafePoint nodes that use\n+\/\/ 'ophi' or a casted version of 'ophi'. All SafePoint nodes using the same\n+\/\/ \"version\" of Phi use the same debug information (regarding the Phi).\n+\/\/ Therefore, I collect all safepoints and patch them all at once.\n+\/\/\n+\/\/ The safepoints using the Phi node have to be processed before safepoints of\n+\/\/ CastPP nodes. The reason is, when reducing a CastPP we add a reference (the\n+\/\/ NSR merge pointer) to the input of the CastPP (i.e., the Phi) in the\n+\/\/ safepoint. If we process CastPP's safepoints before Phi's safepoints the\n+\/\/ algorithm that process Phi's safepoints will think that the added Phi\n+\/\/ reference is a regular reference.\n+bool ConnectionGraph::reduce_phi_on_safepoints(PhiNode* ophi) {\n+  PhiNode* selector = create_selector(ophi);\n+  Unique_Node_List safepoints;\n+  Unique_Node_List casts;\n+\n+  \/\/ Just collect the users of the Phis for later processing\n+  \/\/ in the needed order.\n+  for (uint i = 0; i < ophi->outcnt(); i++) {\n+    Node* use = ophi->raw_out(i);\n+    if (use->is_SafePoint()) {\n+      safepoints.push(use);\n+    } else if (use->is_CastPP()) {\n+      casts.push(use);\n+    } else {\n+      assert(use->outcnt() == 0, \"Only CastPP & SafePoint users should be left.\");\n+    }\n+  }\n+\n+  \/\/ Need to process safepoints using the Phi first\n+  if (!reduce_phi_on_safepoints_helper(ophi, nullptr, selector, safepoints)) {\n+    return false;\n+  }\n+\n+  \/\/ Now process CastPP->safepoints\n+  for (uint i = 0; i < casts.size(); i++) {\n+    Node* cast = casts.at(i);\n+    Unique_Node_List cast_sfpts;\n+\n+    for (DUIterator_Fast jmax, j = cast->fast_outs(jmax); j < jmax; j++) {\n+      Node* use_use = cast->fast_out(j);\n+      if (use_use->is_SafePoint()) {\n+        cast_sfpts.push(use_use);\n+      } else {\n+        assert(use_use->outcnt() == 0, \"Only SafePoint users should be left.\");\n+      }\n+    }\n+\n+    if (!reduce_phi_on_safepoints_helper(ophi, cast, selector, cast_sfpts)) {\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+\/\/ This method will create a SafePointScalarMERGEnode for each SafePoint in\n+\/\/ 'safepoints'. It then will iterate on the inputs of 'ophi' and create a\n+\/\/ SafePointScalarObjectNode for each scalar replaceable input. Each\n+\/\/ SafePointScalarMergeNode may describe multiple scalar replaced objects -\n+\/\/ check detailed description in SafePointScalarMergeNode class header.\n+bool ConnectionGraph::reduce_phi_on_safepoints_helper(Node* ophi, Node* cast, Node* selector, Unique_Node_List& safepoints) {\n+  PhaseMacroExpand mexp(*_igvn);\n+  Node* original_sfpt_parent =  cast != nullptr ? cast : ophi;\n+  const TypeOopPtr* merge_t = _igvn->type(original_sfpt_parent)->make_oopptr();\n+\n+  Node* nsr_merge_pointer = ophi;\n+  if (cast != nullptr) {\n+    const Type* new_t = merge_t->meet(TypePtr::NULL_PTR);\n+    nsr_merge_pointer = _igvn->transform(ConstraintCastNode::make_cast_for_type(cast->in(0), cast->in(1), new_t, ConstraintCastNode::RegularDependency, nullptr));\n+  }\n+\n+  for (uint spi = 0; spi < safepoints.size(); spi++) {\n+    SafePointNode* sfpt = safepoints.at(spi)->as_SafePoint();\n@@ -683,1 +1201,1 @@\n-    sfpt->add_req(ophi);\n+    sfpt->add_req(nsr_merge_pointer);\n@@ -687,1 +1205,1 @@\n-      Node* base          = ophi->in(i);\n+      Node* base = ophi->in(i);\n@@ -699,2 +1217,1 @@\n-        _compile->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n-        return;\n+        return false;\n@@ -712,2 +1229,2 @@\n-    \/\/ Replaces debug information references to \"ophi\" in \"sfpt\" with references to \"smerge\"\n-    sfpt->replace_edges_in_range(ophi, smerge, debug_start, jvms->debug_end(), _igvn);\n+    \/\/ Replaces debug information references to \"original_sfpt_parent\" in \"sfpt\" with references to \"smerge\"\n+    sfpt->replace_edges_in_range(original_sfpt_parent, smerge, debug_start, jvms->debug_end(), _igvn);\n@@ -718,1 +1235,1 @@\n-    sfpt->set_req(smerge->merge_pointer_idx(jvms), ophi);\n+    sfpt->set_req(smerge->merge_pointer_idx(jvms), nsr_merge_pointer);\n@@ -722,4 +1239,53 @@\n-  \/\/ Now we can change ophi since we don't need to know the types\n-  \/\/ of the input allocations anymore.\n-  const Type* new_t = merge_t->meet(TypePtr::NULL_PTR);\n-  Node* new_phi = _igvn->register_new_node_with_optimizer(PhiNode::make(ophi->region(), null_ptr, new_t));\n+  return true;\n+}\n+\n+void ConnectionGraph::reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist) {\n+  bool delay = _igvn->delay_transform();\n+  _igvn->set_delay_transform(true);\n+  _igvn->hash_delete(ophi);\n+\n+  \/\/ Copying all users first because some will be removed and others won't.\n+  \/\/ Ophi also may acquire some new users as part of Cast reduction.\n+  \/\/ CastPPs also need to be processed before CmpPs.\n+  Unique_Node_List castpps;\n+  Unique_Node_List others;\n+  for (DUIterator_Fast imax, i = ophi->fast_outs(imax); i < imax; i++) {\n+    Node* use = ophi->fast_out(i);\n+\n+    if (use->is_CastPP()) {\n+      castpps.push(use);\n+    } else if (use->is_AddP() || use->is_Cmp()) {\n+      others.push(use);\n+    } else if (use->is_SafePoint()) {\n+      \/\/ processed later\n+    } else {\n+      assert(use->is_SafePoint(), \"Unexpected user of reducible Phi %d -> %d:%s:%d\", ophi->_idx, use->_idx, use->Name(), use->outcnt());\n+    }\n+  }\n+\n+  \/\/ CastPPs need to be processed before Cmps because during the process of\n+  \/\/ splitting CastPPs we make reference to the inputs of the Cmp that is used\n+  \/\/ by the If controlling the CastPP.\n+  for (uint i = 0; i < castpps.size(); i++) {\n+    reduce_phi_on_castpp_field_load(castpps.at(i), alloc_worklist, memnode_worklist);\n+  }\n+\n+  for (uint i = 0; i < others.size(); i++) {\n+    Node* use = others.at(i);\n+\n+    if (use->is_AddP()) {\n+      reduce_phi_on_field_access(use, alloc_worklist);\n+    } else if(use->is_Cmp()) {\n+      reduce_phi_on_cmp(use);\n+    }\n+  }\n+\n+  _igvn->set_delay_transform(delay);\n+}\n+\n+void ConnectionGraph::reset_scalar_replaceable_entries(PhiNode* ophi) {\n+  Node* null_ptr            = _igvn->makecon(TypePtr::NULL_PTR);\n+  const TypeOopPtr* merge_t = _igvn->type(ophi)->make_oopptr();\n+  const Type* new_t         = merge_t->meet(TypePtr::NULL_PTR);\n+  Node* new_phi             = _igvn->register_new_node_with_optimizer(PhiNode::make(ophi->region(), null_ptr, new_t));\n+\n@@ -737,4 +1303,2 @@\n-  _igvn->replace_node(ophi, new_phi);\n-  _igvn->hash_insert(ophi);\n-  _igvn->_worklist.push(ophi);\n-}\n+  for (int i = ophi->outcnt()-1; i >= 0;) {\n+    Node* out = ophi->raw_out(i);\n@@ -742,2 +1306,4 @@\n-void ConnectionGraph::reduce_phi(PhiNode* ophi) {\n-  Unique_Node_List safepoints;\n+    if (out->is_ConstraintCast()) {\n+      const Type* out_t = _igvn->type(out)->make_ptr();\n+      const Type* out_new_t = out_t->meet(TypePtr::NULL_PTR);\n+      bool change = out_new_t != out_t;\n@@ -745,2 +1311,7 @@\n-  for (uint i = 0; i < ophi->outcnt(); i++) {\n-    Node* use = ophi->raw_out(i);\n+      for (int j = out->outcnt()-1; change && j >= 0; --j) {\n+        Node* out2 = out->raw_out(j);\n+        if (!out2->is_SafePoint()) {\n+          change = false;\n+          break;\n+        }\n+      }\n@@ -748,13 +1319,5 @@\n-    \/\/ All SafePoint nodes using the same Phi node use the same debug\n-    \/\/ information (regarding the Phi). Furthermore, reducing the Phi used by a\n-    \/\/ SafePoint requires changing the Phi. Therefore, I collect all safepoints\n-    \/\/ and patch them all at once later.\n-    if (use->is_SafePoint()) {\n-      safepoints.push(use->as_SafePoint());\n-    } else {\n-#ifdef ASSERT\n-      ophi->dump(-3);\n-      assert(false, \"Unexpected user of reducible Phi %d -> %d:%s\", ophi->_idx, use->_idx, use->Name());\n-#endif\n-      _compile->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n-      return;\n+      if (change) {\n+        Node* new_cast = ConstraintCastNode::make_cast_for_type(out->in(0), out->in(1), out_new_t, ConstraintCastNode::StrongDependency, nullptr);\n+        _igvn->replace_node(out, new_cast);\n+        _igvn->register_new_node_with_optimizer(new_cast);\n+      }\n@@ -762,1 +1325,0 @@\n-  }\n@@ -764,2 +1326,2 @@\n-  if (safepoints.size() > 0) {\n-    reduce_phi_on_safepoints(ophi, &safepoints);\n+    --i;\n+    i = MIN2(i, (int)ophi->outcnt()-1);\n@@ -767,0 +1329,2 @@\n+\n+  _igvn->replace_node(ophi, new_phi);\n@@ -2331,0 +2895,6 @@\n+        \/\/ These other local vars may point to multiple objects through a Phi\n+        \/\/ In this case we skip them and see if we can reduce the Phi.\n+        if (use_n->is_CastPP() || use_n->is_CheckCastPP()) {\n+          use_n = use_n->in(1);\n+        }\n+\n@@ -2332,4 +2902,1 @@\n-        if (candidates.member(use_n)) {\n-          continue;\n-        } else if (reducible_merges.member(use_n)) {\n-          candidates.push(use_n);\n+        if (candidates.member(use_n) || reducible_merges.member(use_n)) {\n@@ -2409,9 +2976,11 @@\n-      for (BaseIterator i(field); i.has_next(); i.next()) {\n-        PointsToNode* base = i.get();\n-        \/\/ Don't take into account LocalVar nodes which\n-        \/\/ may point to only one object which should be also\n-        \/\/ this field's base by now.\n-        if (base->is_JavaObject() && base != jobj) {\n-          \/\/ Mark all bases.\n-          set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"may point to more than one object\"));\n-          set_not_scalar_replaceable(base NOT_PRODUCT(COMMA \"may point to more than one object\"));\n+      if (has_non_reducible_merge(field, reducible_merges)) {\n+        for (BaseIterator i(field); i.has_next(); i.next()) {\n+          PointsToNode* base = i.get();\n+          \/\/ Don't take into account LocalVar nodes which\n+          \/\/ may point to only one object which should be also\n+          \/\/ this field's base by now.\n+          if (base->is_JavaObject() && base != jobj) {\n+            \/\/ Mark all bases.\n+            set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"may point to more than one object\"));\n+            set_not_scalar_replaceable(base NOT_PRODUCT(COMMA \"may point to more than one object\"));\n+          }\n@@ -2419,1 +2988,0 @@\n-      }\n@@ -2421,2 +2989,3 @@\n-      if (!jobj->scalar_replaceable()) {\n-        return;\n+        if (!jobj->scalar_replaceable()) {\n+          return;\n+        }\n@@ -2437,0 +3006,10 @@\n+bool ConnectionGraph::has_non_reducible_merge(FieldNode* field, Unique_Node_List& reducible_merges) {\n+  for (BaseIterator i(field); i.has_next(); i.next()) {\n+    Node* base = i.get()->ideal_node();\n+    if (base->is_Phi() && !reducible_merges.member(base)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -2569,1 +3148,2 @@\n-      const TypeInt* tcmp = optimize_ptr_compare(n);\n+      assert(n->Opcode() == Op_CmpN || n->Opcode() == Op_CmpP, \"must be\");\n+      const TypeInt* tcmp = optimize_ptr_compare(n->in(1), n->in(2));\n@@ -2602,1 +3182,1 @@\n-const TypeInt* ConnectionGraph::optimize_ptr_compare(Node* n) {\n+const TypeInt* ConnectionGraph::optimize_ptr_compare(Node* left, Node* right) {\n@@ -2604,1 +3184,0 @@\n-  assert(n->Opcode() == Op_CmpN || n->Opcode() == Op_CmpP, \"must be\");\n@@ -2609,4 +3188,13 @@\n-  PointsToNode* ptn1 = ptnode_adr(n->in(1)->_idx);\n-  PointsToNode* ptn2 = ptnode_adr(n->in(2)->_idx);\n-  JavaObjectNode* jobj1 = unique_java_object(n->in(1));\n-  JavaObjectNode* jobj2 = unique_java_object(n->in(2));\n+  PointsToNode* ptn1 = ptnode_adr(left->_idx);\n+  PointsToNode* ptn2 = ptnode_adr(right->_idx);\n+  JavaObjectNode* jobj1 = unique_java_object(left);\n+  JavaObjectNode* jobj2 = unique_java_object(right);\n+\n+  \/\/ The use of this method during allocation merge reduction may cause 'left'\n+  \/\/ or 'right' be something (e.g., a Phi) that isn't in the connection graph or\n+  \/\/ that doesn't reference an unique java object.\n+  if (ptn1 == nullptr || ptn2 == nullptr ||\n+      jobj1 == nullptr || jobj2 == nullptr) {\n+    return UNKNOWN;\n+  }\n+\n@@ -3803,2 +4391,1 @@\n-      Node* addp_base = get_addp_base(n);\n-      if (addp_base != nullptr && reducible_merges.member(addp_base)) {\n+      if (has_reducible_merge_base(n->as_AddP(), reducible_merges)) {\n@@ -3808,0 +4395,1 @@\n+      Node* addp_base = get_addp_base(n);\n@@ -3829,1 +4417,3 @@\n-      \/\/ Reducible Phi's will be removed from the graph after split_unique_types finishes\n+      \/\/ Reducible Phi's will be removed from the graph after split_unique_types\n+      \/\/ finishes. For now we just try to split out the SR inputs of the merge.\n+      Node* parent = n->in(1);\n@@ -3831,2 +4421,1 @@\n-        \/\/ Split loads through phi\n-        reduce_phi_on_field_access(n->as_Phi(), alloc_worklist);\n+        reduce_phi(n->as_Phi(), alloc_worklist, memnode_worklist);\n@@ -3839,0 +4428,4 @@\n+      } else if (reducible_merges.member(parent)) {\n+        \/\/ 'n' is an user of a reducible merge (a Phi). It will be simplified as\n+        \/\/ part of reduce_merge.\n+        continue;\n@@ -3951,1 +4544,0 @@\n-    \/\/ At this point reducible Phis shouldn't have AddP users anymore; only SafePoints.\n@@ -3961,0 +4553,1 @@\n+      \/\/ At this point reducible Phis shouldn't have AddP users anymore; only SafePoints or Casts.\n@@ -3963,1 +4556,1 @@\n-        if (!use->is_SafePoint()) {\n+        if (!use->is_SafePoint() && !use->is_CastPP()) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":798,"deletions":205,"binary":false,"changes":1003,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-  const TypeInt* optimize_ptr_compare(Node* n);\n+  const TypeInt* optimize_ptr_compare(Node* left, Node* right);\n@@ -593,1 +593,11 @@\n-\n+  bool has_non_reducible_merge(FieldNode* field, Unique_Node_List& reducible_merges);\n+  PhiNode* create_selector(PhiNode* ophi) const;\n+  void updates_after_load_split(Node* data_phi, Node* previous_load, GrowableArray<Node *>  &alloc_worklist);\n+  Node* split_castpp_load_through_phi(Node* curr_addp, Node* curr_load, Node* region, GrowableArray<Node*>* bases_for_loads, GrowableArray<Node *>  &alloc_worklist);\n+  void reset_scalar_replaceable_entries(PhiNode* ophi);\n+  bool has_reducible_merge_base(AddPNode* n, Unique_Node_List &reducible_merges);\n+  Node* specialize_cmp(Node* base, Node* curr_ctrl);\n+  Node* specialize_castpp(Node* castpp, Node* base, Node* current_control);\n+\n+  bool can_reduce_cmp(Node* n, Node* cmp) const;\n+  bool has_been_reduced(PhiNode* n, SafePointNode* sfpt) const;\n@@ -595,1 +605,1 @@\n-  bool can_reduce_phi_check_users(PhiNode* ophi) const;\n+  bool can_reduce_check_users(Node* n, uint nesting) const;\n@@ -598,3 +608,6 @@\n-  void reduce_phi_on_field_access(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist);\n-  void reduce_phi_on_safepoints(PhiNode* ophi, Unique_Node_List* safepoints);\n-  void reduce_phi(PhiNode* ophi);\n+  void reduce_phi_on_field_access(Node* previous_addp, GrowableArray<Node *>  &alloc_worklist);\n+  void reduce_phi_on_castpp_field_load(Node* castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist);\n+  void reduce_phi_on_cmp(Node* cmp);\n+  bool reduce_phi_on_safepoints(PhiNode* ophi);\n+  bool reduce_phi_on_safepoints_helper(Node* ophi, Node* cast, Node* selector, Unique_Node_List& safepoints);\n+  void reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2712,1 +2712,12 @@\n-    switch (C->static_subtype_check(superk, subk)) {\n+    \/\/\n+    \/\/ Do not skip the static sub type check with StressReflectiveCode during\n+    \/\/ parsing (i.e. with ExpandSubTypeCheckAtParseTime) because the\n+    \/\/ associated CheckCastNodePP could already be folded when the type\n+    \/\/ system can prove it's an impossible type. Therefore, we should also\n+    \/\/ do the static sub type check here to ensure control is folded as well.\n+    \/\/ Otherwise, the graph is left in a broken state.\n+    \/\/ At macro expansion, we would have already folded the SubTypeCheckNode\n+    \/\/ being expanded here because we always perform the static sub type\n+    \/\/ check in SubTypeCheckNode::sub() regardless of whether\n+    \/\/ StressReflectiveCode is set or not.\n+    switch (C->static_subtype_check(superk, subk, !ExpandSubTypeCheckAtParseTime)) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4330,1 +4330,1 @@\n-    \/\/ Bail out if length is negative.\n+    \/\/ Bail out if length is negative (i.e., if start > end).\n@@ -4336,0 +4336,4 @@\n+    \/\/ Bail out if start is larger than the original length\n+    Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));\n+    generate_negative_guard(orig_tail, bailout, &orig_tail);\n+\n@@ -4345,2 +4349,1 @@\n-      \/\/ The answer is MinI(orig_length - start, length).\n-      Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));\n+      \/\/ The answer is MinI(orig_tail, length).\n@@ -4394,1 +4397,1 @@\n-        ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,\n+        ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, true,\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -368,1 +368,2 @@\n-IfProjNode* PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(Node* iff, IfProjNode* predicate,\n+IfProjNode* PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate,\n+                                                                           IfProjNode* predicate,\n@@ -371,3 +372,5 @@\n-  Node* bol = create_bool_from_template_assertion_predicate(iff, nullptr, nullptr, parse_predicate_proj);\n-  IfProjNode* if_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, iff->Opcode(), false);\n-  _igvn.replace_input_of(if_proj->in(0), 1, bol);\n+  TemplateAssertionPredicateExpression template_assertion_predicate_expression(\n+      template_assertion_predicate->in(1)->as_Opaque4());\n+  Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(parse_predicate_proj, this);\n+  IfProjNode* if_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, template_assertion_predicate->Opcode(), false);\n+  _igvn.replace_input_of(if_proj->in(0), 1, cloned_opaque4_node);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1491,80 +1491,0 @@\n-\/\/ Create a new Bool node from the provided Template Assertion Predicate.\n-\/\/ Unswitched loop: new_init and new_stride are both null. Clone OpaqueLoopInit and OpaqueLoopStride.\n-\/\/ Otherwise: Replace found OpaqueLoop* nodes with new_init and new_stride, respectively.\n-Node* PhaseIdealLoop::create_bool_from_template_assertion_predicate(Node* template_assertion_predicate, Node* new_init,\n-                                                                    Node* new_stride, Node* control) {\n-  Node_Stack to_clone(2);\n-  Node* opaque4 = template_assertion_predicate->in(1);\n-  assert(opaque4->Opcode() == Op_Opaque4, \"must be Opaque4\");\n-  to_clone.push(opaque4, 1);\n-  uint current = C->unique();\n-  Node* result = nullptr;\n-  bool is_unswitched_loop = new_init == nullptr && new_stride == nullptr;\n-  assert(new_init != nullptr || is_unswitched_loop, \"new_init must be set when new_stride is non-null\");\n-  \/\/ Look for the opaque node to replace with the new value\n-  \/\/ and clone everything in between. We keep the Opaque4 node\n-  \/\/ so the duplicated predicates are eliminated once loop\n-  \/\/ opts are over: they are here only to keep the IR graph\n-  \/\/ consistent.\n-  do {\n-    Node* n = to_clone.node();\n-    uint i = to_clone.index();\n-    Node* m = n->in(i);\n-    if (is_part_of_template_assertion_predicate_bool(m)) {\n-      to_clone.push(m, 1);\n-      continue;\n-    }\n-    if (m->is_Opaque1()) {\n-      if (n->_idx < current) {\n-        n = n->clone();\n-        register_new_node(n, control);\n-      }\n-      int op = m->Opcode();\n-      if (op == Op_OpaqueLoopInit) {\n-        if (is_unswitched_loop && m->_idx < current && new_init == nullptr) {\n-          new_init = m->clone();\n-          register_new_node(new_init, control);\n-        }\n-        n->set_req(i, new_init);\n-      } else {\n-        assert(op == Op_OpaqueLoopStride, \"unexpected opaque node\");\n-        if (is_unswitched_loop && m->_idx < current && new_stride == nullptr) {\n-          new_stride = m->clone();\n-          register_new_node(new_stride, control);\n-        }\n-        if (new_stride != nullptr) {\n-          n->set_req(i, new_stride);\n-        }\n-      }\n-      to_clone.set_node(n);\n-    }\n-    while (true) {\n-      Node* cur = to_clone.node();\n-      uint j = to_clone.index();\n-      if (j+1 < cur->req()) {\n-        to_clone.set_index(j+1);\n-        break;\n-      }\n-      to_clone.pop();\n-      if (to_clone.size() == 0) {\n-        result = cur;\n-        break;\n-      }\n-      Node* next = to_clone.node();\n-      j = to_clone.index();\n-      if (next->in(j) != cur) {\n-        assert(cur->_idx >= current || next->in(j)->Opcode() == Op_Opaque1, \"new node or Opaque1 being replaced\");\n-        if (next->_idx < current) {\n-          next = next->clone();\n-          register_new_node(next, control);\n-          to_clone.set_node(next);\n-        }\n-        next->set_req(j, cur);\n-      }\n-    }\n-  } while (result == nullptr);\n-  assert(result->_idx >= current, \"new node expected\");\n-  assert(!is_unswitched_loop || new_init != nullptr, \"new_init must always be found and cloned\");\n-  return result;\n-}\n-\n@@ -1576,1 +1496,11 @@\n-  Node* result = create_bool_from_template_assertion_predicate(iff, new_init, new_stride, control);\n+  TemplateAssertionPredicateExpression template_assertion_predicate_expression(iff->in(1)->as_Opaque4());\n+  Opaque4Node* new_opaque4_node;\n+  if (new_stride == nullptr) {\n+    \/\/ Only set a new OpaqueLoopInitNode node and clone the existing OpaqueLoopStrideNode without modification.\n+    \/\/ This is done when creating a new Template Assertion Predicate for the main loop which requires a new init node.\n+    assert(new_init->is_OpaqueLoopInit(), \"only for creating new Template Assertion Predicates\");\n+    new_opaque4_node = template_assertion_predicate_expression.clone_and_replace_init(new_init, control, this);\n+  } else {\n+    new_opaque4_node = template_assertion_predicate_expression.clone_and_replace_init_and_stride(new_init, new_stride,\n+                                                                                                 control, this);\n+  }\n@@ -1580,1 +1510,1 @@\n-  new_iff->set_req(1, result);\n+  new_iff->set_req(1, new_opaque4_node);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":12,"deletions":82,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -952,2 +953,0 @@\n-  Node* create_bool_from_template_assertion_predicate(Node* template_assertion_predicate, Node* new_init, Node* new_stride,\n-                                                      Node* control);\n@@ -1662,1 +1661,1 @@\n-  IfProjNode* clone_assertion_predicate_for_unswitched_loops(Node* iff, IfProjNode* predicate,\n+  IfProjNode* clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate, IfProjNode* predicate,\n@@ -1676,0 +1675,6 @@\n+  Node* clone_and_register(Node* n, Node* ctrl) {\n+    n = n->clone();\n+    register_new_node(n, ctrl);\n+    return n;\n+  }\n+\n@@ -1909,0 +1914,2 @@\n+  void clone_data_nodes_and_transform_opaque_loop_nodes(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+                                                        Node* new_ctrl);\n@@ -1910,0 +1917,1 @@\n+  void transform_opaque_node(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* node);\n@@ -1920,0 +1928,13 @@\n+\n+  \/\/ Create a copy of the data nodes provided to the constructor by doing the following:\n+  \/\/ Clone all non-OpaqueLoop* nodes and rewire them to create an identical subgraph copy. For the OpaqueLoop* nodes,\n+  \/\/ apply the provided transformation strategy and include the transformed node into the subgraph copy to get a complete\n+  \/\/ \"cloned-and-transformed\" graph copy. For all newly cloned nodes (which could also be new OpaqueLoop* nodes), set\n+  \/\/ `new_ctrl` as ctrl.\n+  const OrigToNewHashtable& clone_with_opaque_loop_transform_strategy(\n+      const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+      Node* new_ctrl) {\n+    clone_data_nodes_and_transform_opaque_loop_nodes(transform_strategy, new_ctrl);\n+    rewire_clones_to_cloned_inputs();\n+    return _orig_to_new;\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -4505,1 +4505,1 @@\n-\/\/ Clone the given node and set it up properly. Set `new_ctrl` as ctrl.\n+\/\/ Clone the given node and set it up properly. Set 'new_ctrl' as ctrl.\n@@ -4526,0 +4526,27 @@\n+\n+\/\/ Clone all non-OpaqueLoop* nodes and apply the provided transformation strategy for OpaqueLoop* nodes.\n+\/\/ Set 'new_ctrl' as ctrl for all cloned non-OpaqueLoop* nodes.\n+void DataNodeGraph::clone_data_nodes_and_transform_opaque_loop_nodes(\n+    const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+    Node* new_ctrl) {\n+  for (uint i = 0; i < _data_nodes.size(); i++) {\n+    Node* data_node = _data_nodes[i];\n+    if (data_node->is_Opaque1()) {\n+      transform_opaque_node(transform_strategy, data_node);\n+    } else {\n+      clone(data_node, new_ctrl);\n+    }\n+  }\n+}\n+\n+void DataNodeGraph::transform_opaque_node(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* node) {\n+  Node* transformed_node;\n+  if (node->is_OpaqueLoopInit()) {\n+    transformed_node = transform_strategy.transform_opaque_init(node->as_OpaqueLoopInit());\n+  } else {\n+    assert(node->is_OpaqueLoopStride(), \"must be OpaqueLoopStrideNode\");\n+    transformed_node = transform_strategy.transform_opaque_stride(node->as_OpaqueLoopStride());\n+  }\n+  \/\/ Add an orig->new mapping to correctly update the inputs of the copied graph in rewire_clones_to_cloned_inputs().\n+  _orig_to_new.put(node, transformed_node);\n+}\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1269,1 +1269,1 @@\n-                       true, !ac->is_copyofrange());\n+                       true, ac->has_negative_length_guard());\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-      if (t_oop->is_aryptr()) {\n+      if (t_oop->isa_aryptr()) {\n@@ -947,0 +947,1 @@\n+  case T_NARROWOOP:\n@@ -1551,0 +1552,2 @@\n+\/\/ Some differences from original method (split_through_phi):\n+\/\/  - If base->is_CastPP(): base = base->in(1)\n@@ -1556,1 +1559,0 @@\n-  bool base_is_phi = (base != nullptr) && base->is_Phi();\n@@ -1558,1 +1560,5 @@\n-  if (req() > 3 || !base_is_phi) {\n+  if (base->is_CastPP()) {\n+    base = base->in(1);\n+  }\n+\n+  if (req() > 3 || base == nullptr || !base->is_Phi()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+class CastPPNode;\n@@ -137,0 +138,3 @@\n+class OpaqueLoopInitNode;\n+class OpaqueLoopStrideNode;\n+class Opaque4Node;\n@@ -716,0 +720,1 @@\n+        DEFINE_CLASS_ID(CastPP, ConstraintCast, 6)\n@@ -789,3 +794,6 @@\n-    DEFINE_CLASS_ID(Move,     Node, 17)\n-    DEFINE_CLASS_ID(LShift,   Node, 18)\n-    DEFINE_CLASS_ID(Neg,      Node, 19)\n+      DEFINE_CLASS_ID(OpaqueLoopInit, Opaque1, 0)\n+      DEFINE_CLASS_ID(OpaqueLoopStride, Opaque1, 1)\n+    DEFINE_CLASS_ID(Opaque4,  Node, 17)\n+    DEFINE_CLASS_ID(Move,     Node, 18)\n+    DEFINE_CLASS_ID(LShift,   Node, 19)\n+    DEFINE_CLASS_ID(Neg,      Node, 20)\n@@ -893,0 +901,1 @@\n+  DEFINE_CLASS_QUERY(CastPP)\n@@ -958,0 +967,3 @@\n+  DEFINE_CLASS_QUERY(Opaque4)\n+  DEFINE_CLASS_QUERY(OpaqueLoopInit)\n+  DEFINE_CLASS_QUERY(OpaqueLoopStride)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    init_class_id(Class_OpaqueLoopInit);\n@@ -70,0 +71,1 @@\n+    init_class_id(Class_OpaqueLoopStride);\n@@ -123,0 +125,1 @@\n+    init_class_id(Class_Opaque4);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"opto\/loopnode.hpp\"\n+#include \"opto\/node.hpp\"\n@@ -150,0 +152,183 @@\n+\n+\/\/ This strategy clones the OpaqueLoopInit and OpaqueLoopStride nodes.\n+class CloneStrategy : public TransformStrategyForOpaqueLoopNodes {\n+  PhaseIdealLoop* const _phase;\n+  Node* const _new_ctrl;\n+\n+ public:\n+  CloneStrategy(PhaseIdealLoop* phase, Node* new_ctrl)\n+      : _phase(phase),\n+        _new_ctrl(new_ctrl) {}\n+  NONCOPYABLE(CloneStrategy);\n+\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const override {\n+    return _phase->clone_and_register(opaque_init, _new_ctrl)->as_OpaqueLoopInit();\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const override {\n+    return _phase->clone_and_register(opaque_stride, _new_ctrl)->as_OpaqueLoopStride();\n+  }\n+};\n+\n+\/\/ This strategy replaces the OpaqueLoopInitNode with the provided init node and clones the OpaqueLoopStrideNode.\n+class ReplaceInitAndCloneStrideStrategy : public TransformStrategyForOpaqueLoopNodes {\n+  Node* const _new_init;\n+  Node* const _new_ctrl;\n+  PhaseIdealLoop* const _phase;\n+\n+ public:\n+  ReplaceInitAndCloneStrideStrategy(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase)\n+      : _new_init(new_init),\n+        _new_ctrl(new_ctrl),\n+        _phase(phase) {}\n+  NONCOPYABLE(ReplaceInitAndCloneStrideStrategy);\n+\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const override {\n+    return _new_init;\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const override {\n+    return _phase->clone_and_register(opaque_stride, _new_ctrl)->as_OpaqueLoopStride();\n+  }\n+};\n+\n+\/\/ This strategy replaces the OpaqueLoopInit and OpaqueLoopStride nodes with the provided init and stride nodes,\n+\/\/ respectively.\n+class ReplaceInitAndStrideStrategy : public TransformStrategyForOpaqueLoopNodes {\n+  Node* const _new_init;\n+  Node* const _new_stride;\n+\n+ public:\n+  ReplaceInitAndStrideStrategy(Node* new_init, Node* new_stride)\n+      : _new_init(new_init),\n+        _new_stride(new_stride) {}\n+  NONCOPYABLE(ReplaceInitAndStrideStrategy);\n+\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const override {\n+    return _new_init;\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const override {\n+    return _new_stride;\n+  }\n+};\n+\n+\/\/ Creates an identical clone of this Template Assertion Predicate Expression (i.e.cloning all nodes from the Opaque4Node\n+\/\/ to and including the OpaqueLoop* nodes). The cloned nodes are rewired to reflect the same graph structure as found for\n+\/\/ this Template Assertion Predicate Expression. The cloned nodes get 'new_ctrl' as ctrl. There is no other update done\n+\/\/ for the cloned nodes. Return the newly cloned Opaque4Node.\n+Opaque4Node* TemplateAssertionPredicateExpression::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n+  CloneStrategy clone_init_and_stride_strategy(phase, new_ctrl);\n+  return clone(clone_init_and_stride_strategy, new_ctrl, phase);\n+}\n+\n+\/\/ Same as clone() but instead of cloning the OpaqueLoopInitNode, we replace it with the provided 'new_init' node.\n+Opaque4Node* TemplateAssertionPredicateExpression::clone_and_replace_init(Node* new_init, Node* new_ctrl,\n+                                                                          PhaseIdealLoop* phase) {\n+  ReplaceInitAndCloneStrideStrategy replace_init_and_clone_stride_strategy(new_init, new_ctrl, phase);\n+  return clone(replace_init_and_clone_stride_strategy, new_ctrl, phase);\n+}\n+\n+\/\/ Same as clone() but instead of cloning the OpaqueLoopInit and OpaqueLoopStride node, we replace them with the provided\n+\/\/ 'new_init' and 'new_stride' nodes, respectively.\n+Opaque4Node* TemplateAssertionPredicateExpression::clone_and_replace_init_and_stride(Node* new_init, Node* new_stride,\n+                                                                                     Node* new_ctrl,\n+                                                                                     PhaseIdealLoop* phase) {\n+  ReplaceInitAndStrideStrategy replace_init_and_stride_strategy(new_init, new_stride);\n+  return clone(replace_init_and_stride_strategy, new_ctrl, phase);\n+}\n+\n+\/\/ Class to collect data nodes from a source to target nodes by following the inputs of the source node recursively.\n+\/\/ The class takes a node filter to decide which input nodes to follow and a target node predicate to start backtracking\n+\/\/ from. All nodes found on all paths from source->target(s) are returned in a Unique_Node_List (without duplicates).\n+class DataNodesOnPathsToTargets : public StackObj {\n+  typedef bool (*NodeCheck)(const Node*);\n+\n+  \/\/ Node filter function to decide if we should process a node or not while searching for targets.\n+  NodeCheck _node_filter;\n+  \/\/ Function to decide if a node is a target node (i.e. where we should start backtracking). This check should also\n+  \/\/ trivially pass the _node_filter.\n+  NodeCheck _is_target_node;\n+  \/\/ The resulting node collection of all nodes on paths from source->target(s).\n+  Unique_Node_List _collected_nodes;\n+  \/\/ List to track all nodes visited on the search for target nodes starting at a start node. These nodes are then used\n+  \/\/ in backtracking to find the nodes actually being on a start->target(s) path. This list also serves as visited set\n+  \/\/ to avoid double visits of a node which could happen with diamonds shapes.\n+  Unique_Node_List _nodes_to_visit;\n+\n+ public:\n+  DataNodesOnPathsToTargets(NodeCheck node_filter, NodeCheck is_target_node)\n+      : _node_filter(node_filter),\n+        _is_target_node(is_target_node) {}\n+  NONCOPYABLE(DataNodesOnPathsToTargets);\n+\n+  \/\/ Collect all input nodes from 'start_node'->target(s) by applying the node filter to discover new input nodes and\n+  \/\/ the target node predicate to stop discovering more inputs and start backtracking. The implementation is done\n+  \/\/ with two BFS traversal: One to collect the target nodes (if any) and one to backtrack from the target nodes to\n+  \/\/ find all other nodes on the start->target(s) paths.\n+  const Unique_Node_List& collect(Node* start_node) {\n+    assert(_collected_nodes.size() == 0 && _nodes_to_visit.size() == 0, \"should not call this method twice in a row\");\n+    assert(!_is_target_node(start_node), \"no trivial paths where start node is also a target node\");\n+\n+    collect_target_nodes(start_node);\n+    backtrack_from_target_nodes();\n+    assert(_collected_nodes.size() == 0 || _collected_nodes.member(start_node),\n+           \"either target node predicate was never true or must find start node again when doing backtracking work\");\n+    return _collected_nodes;\n+  }\n+\n+ private:\n+  \/\/ Do a BFS from the start_node to collect all target nodes. We can then do another BFS from the target nodes to\n+  \/\/ find all nodes on the paths from start->target(s).\n+  \/\/ Note: We could do a single DFS pass to search targets and backtrack in one walk. But this is much more complex.\n+  \/\/       Given that the typical Template Assertion Predicate Expression only consists of a few nodes, we aim for\n+  \/\/       simplicity here.\n+  void collect_target_nodes(Node* start_node) {\n+    _nodes_to_visit.push(start_node);\n+    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n+      Node* next = _nodes_to_visit[i];\n+      for (uint j = 1; j < next->req(); j++) {\n+        Node* input = next->in(j);\n+        if (_is_target_node(input)) {\n+          assert(_node_filter(input), \"must also pass node filter\");\n+          _collected_nodes.push(input);\n+        } else if (_node_filter(input)) {\n+          _nodes_to_visit.push(input);\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ Backtrack from all previously collected target nodes by using the visited set of the start->target(s) search. If no\n+  \/\/ node was collected in the first place (i.e. target node predicate was never true), then nothing needs to be done.\n+  void backtrack_from_target_nodes() {\n+    for (uint i = 0; i < _collected_nodes.size(); i++) {\n+      Node* node_on_path = _collected_nodes[i];\n+      for (DUIterator_Fast jmax, j = node_on_path->fast_outs(jmax); j < jmax; j++) {\n+        Node* use = node_on_path->fast_out(j);\n+        if (_nodes_to_visit.member(use)) {\n+          \/\/ use must be on a path from start->target(s) because it was also visited in the first BFS starting from\n+          \/\/ the start node.\n+          _collected_nodes.push(use);\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Clones this Template Assertion Predicate Expression and applies the given strategy to transform the OpaqueLoop* nodes.\n+Opaque4Node* TemplateAssertionPredicateExpression::clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+                                                         Node* new_ctrl, PhaseIdealLoop* phase) {\n+  ResourceMark rm;\n+  auto is_opaque_loop_node = [](const Node* node) {\n+    return node->is_Opaque1();\n+  };\n+  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpression::maybe_contains,\n+                                                          is_opaque_loop_node);\n+  const Unique_Node_List& collected_nodes = data_nodes_on_path_to_targets.collect(_opaque4_node);\n+  DataNodeGraph data_node_graph(collected_nodes, phase);\n+  const OrigToNewHashtable& orig_to_new = data_node_graph.clone_with_opaque_loop_transform_strategy(transform_strategy, new_ctrl);\n+  assert(orig_to_new.contains(_opaque4_node), \"must exist\");\n+  Node* opaque4_clone = *orig_to_new.get(_opaque4_node);\n+  return opaque4_clone->as_Opaque4();\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":185,"deletions":0,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -266,0 +267,47 @@\n+\/\/ Interface to transform OpaqueLoopInit and OpaqueLoopStride nodes of a Template Assertion Predicate Expression.\n+class TransformStrategyForOpaqueLoopNodes : public StackObj {\n+ public:\n+  virtual Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const = 0;\n+  virtual Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const = 0;\n+};\n+\n+\/\/ A Template Assertion Predicate Expression represents the Opaque4Node for the initial value or the last value of a\n+\/\/ Template Assertion Predicate and all the nodes up to and including the OpaqueLoop* nodes.\n+class TemplateAssertionPredicateExpression : public StackObj {\n+  Opaque4Node* _opaque4_node;\n+\n+ public:\n+  explicit TemplateAssertionPredicateExpression(Opaque4Node* opaque4_node) : _opaque4_node(opaque4_node) {}\n+\n+ private:\n+  Opaque4Node* clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* new_ctrl, PhaseIdealLoop* phase);\n+\n+ public:\n+  \/\/ Is 'n' a node that could be part of a Template Assertion Predicate Expression (i.e. could be found on the input\n+  \/\/ chain of a Template Assertion Predicate Opaque4Node up to and including the OpaqueLoop* nodes)?\n+  static bool maybe_contains(const Node* n) {\n+    const int opcode = n->Opcode();\n+    return (opcode == Op_OpaqueLoopInit ||\n+            opcode == Op_OpaqueLoopStride ||\n+            n->is_Bool() ||\n+            n->is_Cmp() ||\n+            opcode == Op_AndL ||\n+            opcode == Op_OrL ||\n+            opcode == Op_RShiftL ||\n+            opcode == Op_LShiftL ||\n+            opcode == Op_LShiftI ||\n+            opcode == Op_AddL ||\n+            opcode == Op_AddI ||\n+            opcode == Op_MulL ||\n+            opcode == Op_MulI ||\n+            opcode == Op_SubL ||\n+            opcode == Op_SubI ||\n+            opcode == Op_ConvI2L ||\n+            opcode == Op_CastII);\n+  }\n+\n+  Opaque4Node* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl,PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init_and_stride(Node* new_init, Node* new_stride, Node* new_ctrl, PhaseIdealLoop* phase);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"code\/compiledMethod.inline.hpp\"\n@@ -87,1 +86,1 @@\n-\/\/  MarkSweep::invoke(0, \"Debugging\");\n+\/\/  Universe::heap()->collect();\n@@ -1854,3 +1853,2 @@\n-  if (blob->is_compiled()) {\n-    CompiledMethod* cm = blob->as_compiled_method_or_null();\n-    cm->method()->print_value_on(&tempst);\n+  if (blob->is_nmethod()) {\n+    blob->as_nmethod()->method()->print_value_on(&tempst);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -104,2 +105,3 @@\n-        Node* bol = create_bool_from_template_assertion_predicate(m, nullptr, nullptr, m->in(0));\n-        _igvn.replace_input_of(m, 1, bol);\n+        TemplateAssertionPredicateExpression template_assertion_predicate_expression(m->in(1)->as_Opaque4());\n+        Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(m->in(0), this);\n+        _igvn.replace_input_of(m, 1, cloned_opaque4_node);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -646,0 +646,8 @@\n+    case T_OBJECT:\n+    case T_ARRAY:\n+    case T_ADDRESS:\n+    case T_METADATA:\n+      return new CmpPNode(in1, in2);\n+    case T_NARROWOOP:\n+    case T_NARROWKLASS:\n+      return new CmpNNode(in1, in2);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-  _packset(arena(), 8,  0, nullptr),                        \/\/ packs for the current block\n@@ -49,1 +48,5 @@\n-  _race_possible(false),                                    \/\/ cases where SDMU is true\n+  _pairset(&_arena, _vloop_analyzer),\n+  _packset(&_arena, _vloop_analyzer\n+           NOT_PRODUCT(COMMA is_trace_superword_packset())\n+           NOT_PRODUCT(COMMA is_trace_superword_rejections())\n+           ),\n@@ -457,1 +460,1 @@\n-  if (_packset.length() == 0) {\n+  if (_pairset.is_empty()) {\n@@ -467,1 +470,1 @@\n-  extend_packset_with_more_pairs_by_following_use_and_def();\n+  extend_pairset_with_more_pairs_by_following_use_and_def();\n@@ -471,2 +474,0 @@\n-  construct_my_pack_map();\n-\n@@ -478,1 +479,0 @@\n-  \/\/ Now we only remove packs:\n@@ -534,1 +534,1 @@\n-    VPointer align_to_ref_p(mem_ref, _vloop);\n+    const VPointer& align_to_ref_p = vpointer(mem_ref);\n@@ -540,1 +540,1 @@\n-        VPointer p2(s, _vloop);\n+        const VPointer& p2 = vpointer(s);\n@@ -558,3 +558,0 @@\n-            Node_List* pair = new Node_List();\n-            pair->push(s1);\n-            pair->push(s2);\n@@ -562,1 +559,1 @@\n-              _packset.append(pair);\n+              _pairset.add_pair(s1, s2);\n@@ -578,2 +575,2 @@\n-  assert(_packset.is_empty() || align_to_mem_ref != nullptr,\n-         \"packset empty or we find the alignment reference\");\n+  assert(_pairset.is_empty() || align_to_mem_ref != nullptr,\n+         \"pairset empty or we find the alignment reference\");\n@@ -584,1 +581,1 @@\n-    print_packset();\n+    _pairset.print();\n@@ -599,1 +596,1 @@\n-    VPointer p1(s1, _vloop);\n+    const VPointer& p1 = vpointer(s1);\n@@ -603,1 +600,1 @@\n-        VPointer p2(s2, _vloop);\n+        const VPointer& p2 = vpointer(s2);\n@@ -624,1 +621,1 @@\n-      VPointer p(s, _vloop);\n+      const VPointer& p = vpointer(s);\n@@ -647,1 +644,1 @@\n-        VPointer p(s, _vloop);\n+        const VPointer& p = vpointer(s);\n@@ -720,1 +717,1 @@\n-  VPointer align_to_ref_p(mem_ref, _vloop);\n+  const VPointer& align_to_ref_p = vpointer(mem_ref);\n@@ -846,1 +843,1 @@\n-      if (!exists_at(s1, 0) && !exists_at(s2, 1)) {\n+      if (!_pairset.is_left(s1) && !_pairset.is_right(s2)) {\n@@ -862,12 +859,0 @@\n-\/\/------------------------------exists_at---------------------------\n-\/\/ Does s exist in a pack at position pos?\n-bool SuperWord::exists_at(Node* s, uint pos) {\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n-    if (p->at(pos) == s) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n@@ -876,1 +861,1 @@\n-bool SuperWord::are_adjacent_refs(Node* s1, Node* s2) {\n+bool SuperWord::are_adjacent_refs(Node* s1, Node* s2) const {\n@@ -893,2 +878,2 @@\n-  VPointer p1(s1->as_Mem(), _vloop);\n-  VPointer p2(s2->as_Mem(), _vloop);\n+  const VPointer& p1 = vpointer(s1->as_Mem());\n+  const VPointer& p2 = vpointer(s2->as_Mem());\n@@ -1027,1 +1012,1 @@\n-bool VLoopReductions::is_marked_reduction_pair(Node* s1, Node* s2) const {\n+bool VLoopReductions::is_marked_reduction_pair(const Node* s1, const Node* s2) const {\n@@ -1052,2 +1037,2 @@\n-\/\/ Extend packset by following use->def and def->use links from pack members.\n-void SuperWord::extend_packset_with_more_pairs_by_following_use_and_def() {\n+\/\/ Extend pairset by following use->def and def->use links from pair members.\n+void SuperWord::extend_pairset_with_more_pairs_by_following_use_and_def() {\n@@ -1056,1 +1041,0 @@\n-    packset_sort(_packset.length());\n@@ -1058,4 +1042,6 @@\n-    for (int i = 0; i < _packset.length(); i++) {\n-      Node_List* p = _packset.at(i);\n-      changed |= follow_use_defs(p);\n-      changed |= follow_def_uses(p);\n+    \/\/ Iterate the pairs in insertion order.\n+    for (int i = 0; i < _pairset.length(); i++) {\n+      Node* left  = _pairset.left_at_in_insertion_order(i);\n+      Node* right = _pairset.right_at_in_insertion_order(i);\n+      changed |= extend_pairset_with_more_pairs_by_following_def(left, right);\n+      changed |= extend_pairset_with_more_pairs_by_following_use(left, right);\n@@ -1065,5 +1051,11 @@\n-  if (_race_possible) {\n-    for (int i = 0; i < _packset.length(); i++) {\n-      Node_List* p = _packset.at(i);\n-      order_def_uses(p);\n-    }\n+  \/\/ During extend_pairset_with_more_pairs_by_following_use, we may have re-ordered the\n+  \/\/ inputs of some nodes, when calling order_inputs_of_uses_to_match_def_pair. If a def\n+  \/\/ node has multiple uses, we may have re-ordered some of the inputs one use after\n+  \/\/ packing another use with the old order. Now that we have all pairs, we must ensure\n+  \/\/ that the order between the pairs is matching again. Since the PairSetIterator visits\n+  \/\/ all pair-chains from left-to-right, we essencially impose the order of the first\n+  \/\/ element on all other elements in the pair-chain.\n+  for (PairSetIterator pair(_pairset); !pair.done(); pair.next()) {\n+    Node* left  = pair.left();\n+    Node* right = pair.right();\n+    order_inputs_of_all_use_pairs_to_match_def_pair(left, right);\n@@ -1074,2 +1066,2 @@\n-    tty->print_cr(\"\\nAfter Superword::extend_packset_with_more_pairs_by_following_use_and_def\");\n-    print_packset();\n+    tty->print_cr(\"\\nAfter Superword::extend_pairset_with_more_pairs_by_following_use_and_def\");\n+    _pairset.print();\n@@ -1096,6 +1088,2 @@\n-\/\/------------------------------follow_use_defs---------------------------\n-\/\/ Extend the packset by visiting operand definitions of nodes in pack p\n-bool SuperWord::follow_use_defs(Node_List* p) {\n-  assert(p->size() == 2, \"just checking\");\n-  Node* s1 = p->at(0);\n-  Node* s2 = p->at(1);\n+bool SuperWord::extend_pairset_with_more_pairs_by_following_def(Node* s1, Node* s2) {\n+  assert(_pairset.is_pair(s1, s2), \"(s1, s2) must be a pair\");\n@@ -1109,1 +1097,1 @@\n-    tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\",\n+    tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_def: s1 %d, align %d\",\n@@ -1126,5 +1114,2 @@\n-      if (est_savings(t1, t2) >= 0) {\n-        Node_List* pair = new Node_List();\n-        pair->push(t1);\n-        pair->push(t2);\n-        _packset.append(pair);\n+      if (estimate_cost_savings_when_packing_as_pair(t1, t2) >= 0) {\n+        _pairset.add_pair(t1, t2);\n@@ -1133,1 +1118,1 @@\n-          tty->print_cr(\"SuperWord::follow_use_defs: set_alignment(%d, %d, %d)\",\n+          tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_def: set_alignment(%d, %d, %d)\",\n@@ -1145,7 +1130,5 @@\n-\/\/------------------------------follow_def_uses---------------------------\n-\/\/ Extend the packset by visiting uses of nodes in pack p\n-bool SuperWord::follow_def_uses(Node_List* p) {\n-  bool changed = false;\n-  Node* s1 = p->at(0);\n-  Node* s2 = p->at(1);\n-  assert(p->size() == 2, \"just checking\");\n+\/\/ Note: we only extend with a single pair (the one with most savings) for every call. Since we keep\n+\/\/       calling this method as long as there are some changes, we will eventually pack all pairs that\n+\/\/       can be packed.\n+bool SuperWord::extend_pairset_with_more_pairs_by_following_use(Node* s1, Node* s2) {\n+  assert(_pairset.is_pair(s1, s2), \"(s1, s2) must be a pair\");\n@@ -1160,1 +1143,1 @@\n-    tty->print_cr(\"SuperWord::follow_def_uses: s1 %d, align %d\",\n+    tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_use: s1 %d, align %d\",\n@@ -1165,1 +1148,0 @@\n-  int num_s1_uses = 0;\n@@ -1170,1 +1152,0 @@\n-    num_s1_uses++;\n@@ -1182,2 +1163,1 @@\n-      if (!opnd_positions_match(s1, t1, s2, t2))\n-        continue;\n+      if (order_inputs_of_uses_to_match_def_pair(s1, s2, t1, t2) != PairOrderStatus::Ordered) { continue; }\n@@ -1187,1 +1167,1 @@\n-        int my_savings = est_savings(t1, t2);\n+        int my_savings = estimate_cost_savings_when_packing_as_pair(t1, t2);\n@@ -1197,3 +1177,0 @@\n-  if (num_s1_uses > 1) {\n-    _race_possible = true;\n-  }\n@@ -1201,4 +1178,1 @@\n-    Node_List* pair = new Node_List();\n-    pair->push(u1);\n-    pair->push(u2);\n-    _packset.append(pair);\n+    _pairset.add_pair(u1, u2);\n@@ -1207,1 +1181,1 @@\n-      tty->print_cr(\"SuperWord::follow_def_uses: set_alignment(%d, %d, %d)\",\n+      tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_use: set_alignment(%d, %d, %d)\",\n@@ -1212,1 +1186,1 @@\n-    changed = true;\n+    return true; \/\/ changed\n@@ -1214,1 +1188,1 @@\n-  return changed;\n+  return false; \/\/ no change\n@@ -1217,4 +1191,4 @@\n-\/\/------------------------------order_def_uses---------------------------\n-\/\/ For extended packsets, ordinally arrange uses packset by major component\n-void SuperWord::order_def_uses(Node_List* p) {\n-  Node* s1 = p->at(0);\n+\/\/ For a pair (def1, def2), find all use packs (use1, use2), and ensure that their inputs have an order\n+\/\/ that matches the (def1, def2) pair.\n+void SuperWord::order_inputs_of_all_use_pairs_to_match_def_pair(Node* def1, Node* def2) {\n+  assert(_pairset.is_pair(def1, def2), \"(def1, def2) must be a pair\");\n@@ -1222,1 +1196,1 @@\n-  if (s1->is_Store()) return;\n+  if (def1->is_Store()) return;\n@@ -1225,1 +1199,1 @@\n-  if (is_marked_reduction(s1)) return;\n+  if (is_marked_reduction(def1)) return;\n@@ -1227,2 +1201,2 @@\n-  for (DUIterator_Fast imax, i = s1->fast_outs(imax); i < imax; i++) {\n-    Node* t1 = s1->fast_out(i);\n+  for (DUIterator_Fast imax, i = def1->fast_outs(imax); i < imax; i++) {\n+    Node* use1 = def1->fast_out(i);\n@@ -1231,1 +1205,1 @@\n-    if (!t1->is_Add() && !t1->is_Mul() && !VectorNode::is_muladds2i(t1)) {\n+    if (!use1->is_Add() && !use1->is_Mul() && !VectorNode::is_muladds2i(use1)) {\n@@ -1235,18 +1209,5 @@\n-    \/\/ Now find t1's packset\n-    Node_List* p2 = nullptr;\n-    for (int j = 0; j < _packset.length(); j++) {\n-      p2 = _packset.at(j);\n-      Node* first = p2->at(0);\n-      if (t1 == first) {\n-        break;\n-      }\n-      p2 = nullptr;\n-    }\n-    \/\/ Arrange all sub components by the major component\n-    if (p2 != nullptr) {\n-      for (uint j = 1; j < p->size(); j++) {\n-        Node* d1 = p->at(j);\n-        Node* u1 = p2->at(j);\n-        opnd_positions_match(s1, t1, d1, u1);\n-      }\n-    }\n+    \/\/ Find pair (use1, use2)\n+    Node* use2 = _pairset.get_right_or_null_for(use1);\n+    if (use2 == nullptr) { break; }\n+\n+    order_inputs_of_uses_to_match_def_pair(def1, def2, use1, use2);\n@@ -1256,10 +1217,42 @@\n-\/\/---------------------------opnd_positions_match-------------------------\n-\/\/ Is the use of d1 in u1 at the same operand position as d2 in u2?\n-bool SuperWord::opnd_positions_match(Node* d1, Node* u1, Node* d2, Node* u2) {\n-  \/\/ check reductions to see if they are marshalled to represent the reduction\n-  \/\/ operator in a specified opnd\n-  if (is_marked_reduction(u1) && is_marked_reduction(u2)) {\n-    \/\/ ensure reductions have phis and reduction definitions feeding the 1st operand\n-    Node* first = u1->in(2);\n-    if (first->is_Phi() || is_marked_reduction(first)) {\n-      u1->swap_edges(1, 2);\n+\/\/ For a def-pair (def1, def2), and their use-nodes (use1, use2):\n+\/\/ Ensure that the input order of (use1, use2) matches the order of (def1, def2).\n+\/\/\n+\/\/ We have different cases:\n+\/\/\n+\/\/ 1. Reduction (use1, use2): must always reduce left-to-right. Make sure that we have pattern:\n+\/\/\n+\/\/    phi\/reduction x1  phi\/reduction x2                    phi\/reduction x1\n+\/\/                | |               | |    and hopefully:               | |\n+\/\/                use1              use2                                use1 x2\n+\/\/                                                                         | |\n+\/\/                                                                         use2\n+\/\/\n+\/\/ 2: Commutative operations, just as Add\/Mul and their subclasses: we can try to swap edges:\n+\/\/\n+\/\/     def1 x1   x2 def2           def1 x1   def2 x2\n+\/\/        | |     | |       ==>       | |       | |\n+\/\/        use1    use2                use1      use2\n+\/\/\n+\/\/ 3: MulAddS2I (use1, use2): we can try to swap edges:\n+\/\/\n+\/\/    (x1 * x2) + (x3 * x4)    ==>  3.a: (x2 * x1) + (x4 * x3)\n+\/\/                                  3.b: (x4 * x3) + (x2 * x1)\n+\/\/                                  3.c: (x3 * x4) + (x1 * x2)\n+\/\/\n+\/\/    Note: MulAddS2I with its 4 inputs is too complicated, if there is any mismatch, we always\n+\/\/          return PairOrderStatus::Unknown.\n+\/\/          Therefore, extend_pairset_with_more_pairs_by_following_use cannot extend to MulAddS2I,\n+\/\/          but there is a chance that extend_pairset_with_more_pairs_by_following_def can do it.\n+\/\/\n+\/\/ 4: Otherwise, check if the inputs of (use1, use2) already match (def1, def2), i.e. for all input indices i:\n+\/\/\n+\/\/    use1->in(i) == def1 || use2->in(i) == def2   ->    use1->in(i) == def1 && use2->in(i) == def2\n+\/\/\n+SuperWord::PairOrderStatus SuperWord::order_inputs_of_uses_to_match_def_pair(Node* def1, Node* def2, Node* use1, Node* use2) {\n+  assert(_pairset.is_pair(def1, def2), \"(def1, def2) must be a pair\");\n+\n+  \/\/ 1. Reduction\n+  if (is_marked_reduction(use1) && is_marked_reduction(use2)) {\n+    Node* use1_in2 = use1->in(2);\n+    if (use1_in2->is_Phi() || is_marked_reduction(use1_in2)) {\n+      use1->swap_edges(1, 2);\n@@ -1267,4 +1260,3 @@\n-    \/\/ ensure reductions have phis and reduction definitions feeding the 1st operand\n-    first = u2->in(2);\n-    if (first->is_Phi() || is_marked_reduction(first)) {\n-      u2->swap_edges(1, 2);\n+    Node* use2_in2 = use2->in(2);\n+    if (use2_in2->is_Phi() || is_marked_reduction(use2_in2)) {\n+      use2->swap_edges(1, 2);\n@@ -1272,1 +1264,1 @@\n-    return true;\n+    return PairOrderStatus::Ordered;\n@@ -1275,2 +1267,2 @@\n-  uint ct = u1->req();\n-  if (ct != u2->req()) return false;\n+  uint ct = use1->req();\n+  if (ct != use2->req()) { return PairOrderStatus::Unordered; };\n@@ -1280,2 +1272,2 @@\n-    for (i1++; i1 < ct; i1++) if (u1->in(i1) == d1) break;\n-    for (i2++; i2 < ct; i2++) if (u2->in(i2) == d2) break;\n+    for (i1++; i1 < ct; i1++) { if (use1->in(i1) == def1) { break; } }\n+    for (i2++; i2 < ct; i2++) { if (use2->in(i2) == def2) { break; } }\n@@ -1283,4 +1275,5 @@\n-      if ((i1 == (3-i2)) && (u2->is_Add() || u2->is_Mul())) {\n-        \/\/ Further analysis relies on operands position matching.\n-        u2->swap_edges(i1, i2);\n-      } else if (VectorNode::is_muladds2i(u2) && u1 != u2) {\n+      if ((i1 == (3-i2)) && (use2->is_Add() || use2->is_Mul())) {\n+        \/\/ 2. Commutative: swap edges, and hope the other position matches too.\n+        use2->swap_edges(i1, i2);\n+      } else if (VectorNode::is_muladds2i(use2) && use1 != use2) {\n+        \/\/ 3.a\/b: MulAddS2I.\n@@ -1288,2 +1281,2 @@\n-          u2->swap_edges(1, 2);\n-          u2->swap_edges(3, 4);\n+          use2->swap_edges(1, 2);\n+          use2->swap_edges(3, 4);\n@@ -1292,2 +1285,2 @@\n-          u2->swap_edges(2, 3);\n-          u2->swap_edges(1, 4);\n+          use2->swap_edges(2, 3);\n+          use2->swap_edges(1, 4);\n@@ -1295,1 +1288,1 @@\n-        return false; \/\/ Just swap the edges, the muladds2i nodes get packed in follow_use_defs\n+        return PairOrderStatus::Unknown;\n@@ -1297,1 +1290,2 @@\n-        return false;\n+        \/\/ 4. The inputs are not ordered, and we cannot do anything about it.\n+        return PairOrderStatus::Unordered;\n@@ -1299,4 +1293,5 @@\n-    } else if (i1 == i2 && VectorNode::is_muladds2i(u2) && u1 != u2) {\n-      u2->swap_edges(1, 3);\n-      u2->swap_edges(2, 4);\n-      return false; \/\/ Just swap the edges, the muladds2i nodes get packed in follow_use_defs\n+    } else if (i1 == i2 && VectorNode::is_muladds2i(use2) && use1 != use2) {\n+      \/\/ 3.c: MulAddS2I.\n+      use2->swap_edges(1, 3);\n+      use2->swap_edges(2, 4);\n+      return PairOrderStatus::Unknown;\n@@ -1305,1 +1300,3 @@\n-  return true;\n+\n+  \/\/ 4. All inputs match.\n+  return PairOrderStatus::Ordered;\n@@ -1308,3 +1305,2 @@\n-\/\/------------------------------est_savings---------------------------\n-\/\/ Estimate the savings from executing s1 and s2 as a pack\n-int SuperWord::est_savings(Node* s1, Node* s2) {\n+\/\/ Estimate the savings from executing s1 and s2 as a pair.\n+int SuperWord::estimate_cost_savings_when_packing_as_pair(const Node* s1, const Node* s2) const {\n@@ -1313,0 +1309,4 @@\n+  const int adjacent_profit = 2;\n+  auto pack_cost       = [&] (const int size) { return size; };\n+  auto unpack_cost     = [&] (const int size) { return size; };\n+\n@@ -1319,2 +1319,2 @@\n-        save_in += adjacent_profit(x1, x2);\n-      } else if (!in_packset(x1, x2)) {\n+        save_in += adjacent_profit;\n+      } else if (!_pairset.is_pair(x1, x2)) {\n@@ -1329,1 +1329,1 @@\n-  uint ct = 0;\n+  uint number_of_packed_use_pairs = 0;\n@@ -1332,12 +1332,17 @@\n-    Node* s1_use = s1->fast_out(i);\n-    for (int j = 0; j < _packset.length(); j++) {\n-      Node_List* p = _packset.at(j);\n-      if (p->at(0) == s1_use) {\n-        for (DUIterator_Fast kmax, k = s2->fast_outs(kmax); k < kmax; k++) {\n-          Node* s2_use = s2->fast_out(k);\n-          if (p->at(p->size()-1) == s2_use) {\n-            ct++;\n-            if (are_adjacent_refs(s1_use, s2_use)) {\n-              save_use += adjacent_profit(s1_use, s2_use);\n-            }\n-          }\n+    Node* use1 = s1->fast_out(i);\n+\n+    \/\/ Find pair (use1, use2)\n+    Node* use2 = _pairset.get_right_or_null_for(use1);\n+    if (use2 == nullptr) { continue; }\n+\n+    for (DUIterator_Fast kmax, k = s2->fast_outs(kmax); k < kmax; k++) {\n+      if (use2 == s2->fast_out(k)) {\n+        \/\/ We have pattern:\n+        \/\/\n+        \/\/   s1    s2\n+        \/\/    |    |\n+        \/\/ [use1, use2]\n+        \/\/\n+        number_of_packed_use_pairs++;\n+        if (are_adjacent_refs(use1, use2)) {\n+          save_use += adjacent_profit;\n@@ -1349,2 +1354,2 @@\n-  if (ct < s1->outcnt()) save_use += unpack_cost(1);\n-  if (ct < s2->outcnt()) save_use += unpack_cost(1);\n+  if (number_of_packed_use_pairs < s1->outcnt()) save_use += unpack_cost(1);\n+  if (number_of_packed_use_pairs < s2->outcnt()) save_use += unpack_cost(1);\n@@ -1355,6 +1360,1 @@\n-\/\/------------------------------costs---------------------------\n-int SuperWord::adjacent_profit(Node* s1, Node* s2) { return 2; }\n-int SuperWord::pack_cost(int ct)   { return ct; }\n-int SuperWord::unpack_cost(int ct) { return ct; }\n-\n-\/\/ Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last\n+\/\/ Combine pairs (n1, n2), (n2, n3), ... into pack (n1, n2, n3 ...)\n@@ -1363,5 +1363,2 @@\n-  assert(!_packset.is_empty(), \"packset not empty\");\n-  for (int i = 0; i < _packset.length(); i++) {\n-    assert(_packset.at(i) != nullptr, \"no nullptr in packset\");\n-    assert(_packset.at(i)->size() == 2, \"all packs are pairs\");\n-  }\n+  assert(!_pairset.is_empty(), \"pairset not empty\");\n+  assert(_packset.is_empty(), \"packset not empty\");\n@@ -1370,19 +1367,15 @@\n-  bool changed = true;\n-  \/\/ Combine packs regardless max vector size.\n-  while (changed) {\n-    changed = false;\n-    for (int i = 0; i < _packset.length(); i++) {\n-      Node_List* p1 = _packset.at(i);\n-      if (p1 == nullptr) continue;\n-      \/\/ Because of sorting we can start at i + 1\n-      for (int j = i + 1; j < _packset.length(); j++) {\n-        Node_List* p2 = _packset.at(j);\n-        if (p2 == nullptr) continue;\n-        if (p1->at(p1->size()-1) == p2->at(0)) {\n-          for (uint k = 1; k < p2->size(); k++) {\n-            p1->push(p2->at(k));\n-          }\n-          _packset.at_put(j, nullptr);\n-          changed = true;\n-        }\n-      }\n+  \/\/ Iterate pair-chain by pair-chain, each from left-most to right-most.\n+  Node_List* pack = nullptr;\n+  for (PairSetIterator pair(_pairset); !pair.done(); pair.next()) {\n+    Node* left  = pair.left();\n+    Node* right = pair.right();\n+    if (_pairset.is_left_in_a_left_most_pair(left)) {\n+      assert(pack == nullptr, \"no unfinished pack\");\n+      pack = new (arena()) Node_List(arena());\n+      pack->push(left);\n+    }\n+    assert(pack != nullptr, \"must have unfinished pack\");\n+    pack->push(right);\n+    if (_pairset.is_right_in_a_right_most_pair(right)) {\n+      _packset.add_pack(pack);\n+      pack = nullptr;\n@@ -1391,3 +1384,1 @@\n-\n-  \/\/ Remove all nullptr from packset\n-  compress_packset();\n+  assert(pack == nullptr, \"no unfinished pack\");\n@@ -1400,1 +1391,1 @@\n-    print_packset();\n+    _packset.print();\n@@ -1405,3 +1396,3 @@\n-SuperWord::SplitStatus SuperWord::split_pack(const char* split_name,\n-                                             Node_List* pack,\n-                                             SplitTask task)\n+SplitStatus PackSet::split_pack(const char* split_name,\n+                                Node_List* pack,\n+                                SplitTask task)\n@@ -1419,1 +1410,1 @@\n-        tty->print_cr(\"WARNING: Removed pack during split: %s:\", task.message());\n+        tty->print_cr(\"WARNING: Removed pack: %s:\", task.message());\n@@ -1423,4 +1414,1 @@\n-    for (uint i = 0; i < pack_size; i++) {\n-      Node* n = pack->at(i);\n-      set_my_pack(n, nullptr);\n-    }\n+    unmap_all_nodes_in_pack(pack);\n@@ -1456,4 +1444,1 @@\n-    for (uint i = 0; i < pack_size; i++) {\n-      Node* n = pack->at(i);\n-      set_my_pack(n, nullptr);\n-    }\n+    unmap_all_nodes_in_pack(pack);\n@@ -1467,1 +1452,1 @@\n-    set_my_pack(n, nullptr);\n+    unmap_node_in_pack(n);\n@@ -1483,1 +1468,1 @@\n-    set_my_pack(n, nullptr);\n+    unmap_node_in_pack(n);\n@@ -1501,1 +1486,1 @@\n-    set_my_pack(n, new_pack);\n+    remap_node_in_pack(n, new_pack);\n@@ -1514,2 +1499,2 @@\n-void SuperWord::split_packs(const char* split_name,\n-                            SplitStrategy strategy) {\n+void PackSet::split_packs(const char* split_name,\n+                          SplitStrategy strategy) {\n@@ -1520,2 +1505,2 @@\n-    for (int i = 0; i < _packset.length(); i++) {\n-      Node_List* pack = _packset.at(i);\n+    for (int i = 0; i < _packs.length(); i++) {\n+      Node_List* pack = _packs.at(i);\n@@ -1528,1 +1513,1 @@\n-      _packset.at_put(i, nullptr); \/\/ take out pack\n+      _packs.at_put(i, nullptr); \/\/ take out pack\n@@ -1532,1 +1517,1 @@\n-        _packset.at_put(new_packset_length++, first_pack);\n+        _packs.at_put(new_packset_length++, first_pack);\n@@ -1536,1 +1521,1 @@\n-        _packset.append(second_pack);\n+        _packs.append(second_pack);\n@@ -1539,1 +1524,1 @@\n-    _packset.trunc_to(new_packset_length);\n+    _packs.trunc_to(new_packset_length);\n@@ -1545,1 +1530,1 @@\n-    print_packset();\n+    print();\n@@ -1552,10 +1537,10 @@\n-  split_packs(\"SuperWord::split_packs_at_use_def_boundaries\",\n-               [&](const Node_List* pack) {\n-                 uint pack_size = pack->size();\n-                 uint boundary = find_use_def_boundary(pack);\n-                 assert(boundary < pack_size, \"valid boundary %d\", boundary);\n-                 if (boundary != 0) {\n-                   return SplitTask::make_split(pack_size - boundary, \"found a use\/def boundary\");\n-                 }\n-                 return SplitTask::make_unchanged();\n-               });\n+  auto split_strategy = [&](const Node_List* pack) {\n+    uint pack_size = pack->size();\n+    uint boundary = find_use_def_boundary(pack);\n+    assert(boundary < pack_size, \"valid boundary %d\", boundary);\n+    if (boundary != 0) {\n+      return SplitTask::make_split(pack_size - boundary, \"found a use\/def boundary\");\n+    }\n+    return SplitTask::make_unchanged();\n+  };\n+  _packset.split_packs(\"SuperWord::split_packs_at_use_def_boundaries\", split_strategy);\n@@ -1567,13 +1552,13 @@\n-  split_packs(\"SuperWord::split_packs_only_implemented_with_smaller_size\",\n-               [&](const Node_List* pack) {\n-                 uint pack_size = pack->size();\n-                 uint implemented_size = max_implemented_size(pack);\n-                 if (implemented_size == 0)  {\n-                   return SplitTask::make_rejected(\"not implemented at any smaller size\");\n-                 }\n-                 assert(is_power_of_2(implemented_size), \"power of 2 size or zero: %d\", implemented_size);\n-                 if (implemented_size != pack_size) {\n-                   return SplitTask::make_split(implemented_size, \"only implemented at smaller size\");\n-                 }\n-                 return SplitTask::make_unchanged();\n-               });\n+  auto split_strategy = [&](const Node_List* pack) {\n+    uint pack_size = pack->size();\n+    uint implemented_size = max_implemented_size(pack);\n+    if (implemented_size == 0)  {\n+      return SplitTask::make_rejected(\"not implemented at any smaller size\");\n+    }\n+    assert(is_power_of_2(implemented_size), \"power of 2 size or zero: %d\", implemented_size);\n+    if (implemented_size != pack_size) {\n+      return SplitTask::make_split(implemented_size, \"only implemented at smaller size\");\n+    }\n+    return SplitTask::make_unchanged();\n+  };\n+  _packset.split_packs(\"SuperWord::split_packs_only_implemented_with_smaller_size\", split_strategy);\n@@ -1584,12 +1569,12 @@\n-  split_packs(\"SuperWord::split_packs_to_break_mutual_dependence\",\n-               [&](const Node_List* pack) {\n-                 uint pack_size = pack->size();\n-                 assert(is_power_of_2(pack_size), \"ensured by earlier splits %d\", pack_size);\n-                 if (!is_marked_reduction(pack->at(0)) &&\n-                     !mutually_independent(pack)) {\n-                   \/\/ As a best guess, we split the pack in half. This way, we iteratively make the\n-                   \/\/ packs smaller, until there is no dependency.\n-                   return SplitTask::make_split(pack_size >> 1, \"was not mutually independent\");\n-                 }\n-                 return SplitTask::make_unchanged();\n-               });\n+  auto split_strategy = [&](const Node_List* pack) {\n+    uint pack_size = pack->size();\n+    assert(is_power_of_2(pack_size), \"ensured by earlier splits %d\", pack_size);\n+    if (!is_marked_reduction(pack->at(0)) &&\n+        !mutually_independent(pack)) {\n+      \/\/ As a best guess, we split the pack in half. This way, we iteratively make the\n+      \/\/ packs smaller, until there is no dependency.\n+      return SplitTask::make_split(pack_size >> 1, \"was not mutually independent\");\n+    }\n+    return SplitTask::make_unchanged();\n+  };\n+  _packset.split_packs(\"SuperWord::split_packs_to_break_mutual_dependence\", split_strategy);\n@@ -1599,2 +1584,2 @@\n-void SuperWord::filter_packs(const char* filter_name,\n-                             const char* error_message,\n+void PackSet::filter_packs(const char* filter_name,\n+                             const char* rejection_message,\n@@ -1602,4 +1587,1 @@\n-  int new_packset_length = 0;\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* pack = _packset.at(i);\n-    assert(pack != nullptr, \"no nullptr in packset\");\n+  auto split_strategy = [&](const Node_List* pack) {\n@@ -1607,2 +1589,1 @@\n-      assert(i >= new_packset_length, \"only move packs down\");\n-      _packset.at_put(new_packset_length++, pack);\n+      return SplitTask::make_unchanged();\n@@ -1610,8 +1591,1 @@\n-      remove_pack_at(i);\n-#ifndef PRODUCT\n-      if (is_trace_superword_rejections()) {\n-        tty->cr();\n-        tty->print_cr(\"WARNING: Removed pack: %s:\", error_message);\n-        print_pack(pack);\n-      }\n-#endif\n+      return SplitTask::make_rejected(rejection_message);\n@@ -1619,11 +1593,2 @@\n-  }\n-\n-  assert(_packset.length() >= new_packset_length, \"filter only reduces number of packs\");\n-  _packset.trunc_to(new_packset_length);\n-\n-#ifndef PRODUCT\n-  if (is_trace_superword_packset() && filter_name != nullptr) {\n-    tty->print_cr(\"\\nAfter %s:\", filter_name);\n-    print_packset();\n-  }\n-#endif\n+  };\n+  split_packs(filter_name, split_strategy);\n@@ -1633,5 +1598,5 @@\n-  filter_packs(\"SuperWord::filter_packs_for_power_of_2_size\",\n-               \"size is not a power of 2\",\n-               [&](const Node_List* pack) {\n-                 return is_power_of_2(pack->size());\n-               });\n+  auto filter = [&](const Node_List* pack) {\n+    return is_power_of_2(pack->size());\n+  };\n+  _packset.filter_packs(\"SuperWord::filter_packs_for_power_of_2_size\",\n+                        \"size is not a power of 2\", filter);\n@@ -1661,7 +1626,7 @@\n-  filter_packs(\"SuperWord::filter_packs_for_mutual_independence\",\n-               \"found dependency between nodes at distance greater than 1\",\n-               [&](const Node_List* pack) {\n-                 \/\/ reductions are trivially connected\n-                 return is_marked_reduction(pack->at(0)) ||\n-                        mutually_independent(pack);\n-               });\n+  auto filter = [&](const Node_List* pack) {\n+    \/\/ reductions are trivially connected\n+    return is_marked_reduction(pack->at(0)) ||\n+           mutually_independent(pack);\n+  };\n+  _packset.filter_packs(\"SuperWord::filter_packs_for_mutual_independence\",\n+                        \"found dependency between nodes at distance greater than 1\", filter);\n@@ -1675,1 +1640,1 @@\n-  VPointer mem_ref_p(mem_ref, _vloop);\n+  const VPointer& mem_ref_p = vpointer(mem_ref);\n@@ -1716,8 +1681,6 @@\n-  filter_packs(\"SuperWord::filter_packs_for_alignment\",\n-               \"rejected by AlignVector (strict alignment requirement)\",\n-               [&](const Node_List* pack) {\n-                 \/\/ Only memops need to be aligned.\n-                 if (!pack->at(0)->is_Load() &&\n-                     !pack->at(0)->is_Store()) {\n-                   return true; \/\/ accept all non memops\n-                 }\n+  auto filter = [&](const Node_List* pack) {\n+    \/\/ Only memops need to be aligned.\n+    if (!pack->at(0)->is_Load() &&\n+        !pack->at(0)->is_Store()) {\n+      return true; \/\/ accept all non memops\n+    }\n@@ -1725,3 +1688,3 @@\n-                 mem_ops_count++;\n-                 const AlignmentSolution* s = pack_alignment_solution(pack);\n-                 const AlignmentSolution* intersect = current->filter(s);\n+    mem_ops_count++;\n+    const AlignmentSolution* s = pack_alignment_solution(pack);\n+    const AlignmentSolution* intersect = current->filter(s);\n@@ -1730,6 +1693,6 @@\n-                 if (is_trace_align_vector()) {\n-                   tty->print(\"  solution for pack:         \");\n-                   s->print();\n-                   tty->print(\"  intersection with current: \");\n-                   intersect->print();\n-                 }\n+    if (is_trace_align_vector()) {\n+      tty->print(\"  solution for pack:         \");\n+      s->print();\n+      tty->print(\"  intersection with current: \");\n+      intersect->print();\n+    }\n@@ -1737,4 +1700,4 @@\n-                 if (intersect->is_empty()) {\n-                   mem_ops_rejected++;\n-                   return false; \/\/ reject because of empty solution\n-                 }\n+    if (intersect->is_empty()) {\n+      mem_ops_rejected++;\n+      return false; \/\/ reject because of empty solution\n+    }\n@@ -1742,3 +1705,6 @@\n-                 current = intersect;\n-                 return true; \/\/ accept because of non-empty solution\n-               });\n+    current = intersect;\n+    return true; \/\/ accept because of non-empty solution\n+  };\n+\n+  _packset.filter_packs(\"SuperWord::filter_packs_for_alignment\",\n+                        \"rejected by AlignVector (strict alignment requirement)\", filter);\n@@ -1763,34 +1729,0 @@\n-\/\/ Compress packset, such that it has no nullptr entries\n-void SuperWord::compress_packset() {\n-  int j = 0;\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n-    if (p != nullptr) {\n-      _packset.at_put(j, p);\n-      j++;\n-    }\n-  }\n-  _packset.trunc_to(j);\n-}\n-\n-\/\/-----------------------------construct_my_pack_map--------------------------\n-\/\/ Construct the map from nodes to packs.  Only valid after the\n-\/\/ point where a node is only in one pack (after combine_pairs_to_longer_packs).\n-void SuperWord::construct_my_pack_map() {\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n-    for (uint j = 0; j < p->size(); j++) {\n-      Node* s = p->at(j);\n-#ifdef ASSERT\n-      if (my_pack(s) != nullptr) {\n-        s->dump(1);\n-        tty->print_cr(\"packs[%d]:\", i);\n-        print_pack(p);\n-        assert(false, \"only in one pack\");\n-      }\n-#endif\n-      set_my_pack(s, p);\n-    }\n-  }\n-}\n-\n@@ -1799,5 +1731,5 @@\n-  filter_packs(\"SuperWord::filter_packs_for_implemented\",\n-               \"Unimplemented\",\n-               [&](const Node_List* pack) {\n-                 return implemented(pack, pack->size());\n-               });\n+  auto filter = [&](const Node_List* pack) {\n+    return implemented(pack, pack->size());\n+  };\n+  _packset.filter_packs(\"SuperWord::filter_packs_for_implemented\",\n+                        \"Unimplemented\", filter);\n@@ -1821,20 +1753,5 @@\n-  while (true) {\n-    int old_packset_length = _packset.length();\n-    filter_packs(nullptr, \/\/ don't dump each time\n-                 \"not profitable\",\n-                 [&](const Node_List* pack) {\n-                   return profitable(pack);\n-                 });\n-    \/\/ Repeat until stable\n-    if (old_packset_length == _packset.length()) {\n-      break;\n-    }\n-  }\n-\n-#ifndef PRODUCT\n-  if (is_trace_superword_packset()) {\n-    tty->print_cr(\"\\nAfter Superword::filter_packs_for_profitable\");\n-    print_packset();\n-    tty->cr();\n-  }\n-#endif\n+  auto filter = [&](const Node_List* pack) {\n+    return profitable(pack);\n+  };\n+  _packset.filter_packs(\"Superword::filter_packs_for_profitable\",\n+                        \"not profitable\", filter);\n@@ -1844,1 +1761,1 @@\n-bool SuperWord::implemented(const Node_List* pack, uint size) {\n+bool SuperWord::implemented(const Node_List* pack, const uint size) const {\n@@ -1920,1 +1837,1 @@\n-bool SuperWord::same_inputs(const Node_List* p, int idx) {\n+bool SuperWord::same_inputs(const Node_List* p, int idx) const {\n@@ -1936,1 +1853,1 @@\n-bool SuperWord::profitable(const Node_List* p) {\n+bool SuperWord::profitable(const Node_List* p) const {\n@@ -1954,1 +1871,1 @@\n-    Node_List* second_pk = my_pack(second_in);\n+    Node_List* second_pk = get_pack(second_in);\n@@ -1967,1 +1884,1 @@\n-    Node_List* cnt_pk = my_pack(cnt);\n+    Node_List* cnt_pk = get_pack(cnt);\n@@ -2020,1 +1937,1 @@\n-    if (bol == nullptr || my_pack(bol) == nullptr) {\n+    if (bol == nullptr || get_pack(bol) == nullptr) {\n@@ -2025,1 +1942,1 @@\n-    if (cmp == nullptr || my_pack(cmp) == nullptr) {\n+    if (cmp == nullptr || get_pack(cmp) == nullptr) {\n@@ -2033,2 +1950,4 @@\n-void SuperWord::verify_packs() {\n-  \/\/ Verify independence at pack level.\n+void SuperWord::verify_packs() const {\n+  _packset.verify();\n+\n+  \/\/ All packs must be:\n@@ -2036,3 +1955,5 @@\n-    Node_List* p = _packset.at(i);\n-    if (!is_marked_reduction(p->at(0)) &&\n-        !mutually_independent(p)) {\n+    Node_List* pack = _packset.at(i);\n+\n+    \/\/ 1. Mutually independent (or a reduction).\n+    if (!is_marked_reduction(pack->at(0)) &&\n+        !mutually_independent(pack)) {\n@@ -2040,1 +1961,1 @@\n-      print_pack(p);\n+      _packset.print_pack(pack);\n@@ -2043,0 +1964,14 @@\n+\n+    \/\/ 2. Implemented.\n+    if (!implemented(pack, pack->size())) {\n+      tty->print_cr(\"FAILURE: nodes not implementable in pack[%d]\", i);\n+      _packset.print_pack(pack);\n+      assert(false, \"pack not implementable\");\n+    }\n+\n+    \/\/ 3. Profitable.\n+    if (!profitable(pack)) {\n+      tty->print_cr(\"FAILURE: nodes not profitable in pack[%d]\", i);\n+      _packset.print_pack(pack);\n+      assert(false, \"pack not profitable\");\n+    }\n@@ -2044,0 +1979,1 @@\n+}\n@@ -2045,1 +1981,2 @@\n-  \/\/ Verify all nodes in packset have my_pack set correctly.\n+void PackSet::verify() const {\n+  \/\/ Verify all nodes in packset have pack set correctly.\n@@ -2048,2 +1985,2 @@\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n+  for (int i = 0; i < _packs.length(); i++) {\n+    Node_List* p = _packs.at(i);\n@@ -2052,1 +1989,1 @@\n-      assert(in_bb(n), \"only nodes in bb can be in packset\");\n+      assert(_vloop.in_bb(n), \"only nodes in bb can be in packset\");\n@@ -2054,1 +1991,1 @@\n-      assert(my_pack(n) == p, \"n has consisten packset info\");\n+      assert(get_pack(n) == p, \"n has consisten packset info\");\n@@ -2059,3 +1996,3 @@\n-  \/\/ Check that no other node has my_pack set.\n-  for (int i = 0; i < body().length(); i++) {\n-    Node* n = body().at(i);\n+  \/\/ Check that no other node has pack set.\n+  for (int i = 0; i < _body.body().length(); i++) {\n+    Node* n = _body.body().at(i);\n@@ -2063,1 +2000,1 @@\n-      assert(my_pack(n) == nullptr, \"should not have pack if not in packset\");\n+      assert(get_pack(n) == nullptr, \"should not have pack if not in packset\");\n@@ -2090,1 +2027,1 @@\n-  GrowableArray<Node*> _pid_to_node;       \/\/ one node per pid, find rest via my_pack\n+  GrowableArray<Node*> _pid_to_node;       \/\/ one node per pid, find rest via _packset.pack\n@@ -2144,1 +2081,1 @@\n-    const GrowableArray<Node_List*>& packset = _slp->packset();\n+    const PackSet& packset = _slp->packset();\n@@ -2153,1 +2090,1 @@\n-        assert(_slp->my_pack(n) == p, \"matching packset\");\n+        assert(packset.get_pack(n) == p, \"matching packset\");\n@@ -2169,1 +2106,1 @@\n-        assert(_slp->my_pack(n) == nullptr, \"no packset\");\n+        assert(packset.get_pack(n) == nullptr, \"no packset\");\n@@ -2235,1 +2172,1 @@\n-      Node_List* p = _slp->my_pack(n);\n+      Node_List* p = _slp->packset().get_pack(n);\n@@ -2443,1 +2380,1 @@\n-  if (_packset.length() == 0) {\n+  if (_packset.is_empty()) {\n@@ -2464,1 +2401,1 @@\n-    Node_List* p = my_pack(n);\n+    Node_List* p = get_pack(n);\n@@ -2554,1 +2491,1 @@\n-        Node_List* p_bol = my_pack(bol);\n+        Node_List* p_bol = get_pack(bol);\n@@ -2567,1 +2504,1 @@\n-        Node_List* p_cmp = my_pack(cmp);\n+        Node_List* p_cmp = get_pack(cmp);\n@@ -2886,1 +2823,1 @@\n-    if (my_pack(in) != nullptr) {\n+    if (get_pack(in) != nullptr) {\n@@ -2894,1 +2831,1 @@\n-      if (my_pack(in2) != nullptr) {\n+      if (get_pack(in2) != nullptr) {\n@@ -2927,1 +2864,1 @@\n-            Node_List* p_use = my_pack(use);\n+            Node_List* p_use = get_pack(use);\n@@ -2940,2 +2877,2 @@\n-  Node_List* pack = my_pack(n_super);\n-  assert(pack != nullptr && pack == my_pack(n_sub), \"must have the same pack\");\n+  Node_List* pack = get_pack(n_super);\n+  assert(pack != nullptr && pack == get_pack(n_sub), \"must have the same pack\");\n@@ -2946,1 +2883,1 @@\n-    Node_List* pack_use_sub = my_pack(use_sub);\n+    Node_List* pack_use_sub = get_pack(use_sub);\n@@ -2959,1 +2896,1 @@\n-        Node_List* pack_use_super = my_pack(use_super);\n+        Node_List* pack_use_super = get_pack(use_super);\n@@ -3008,1 +2945,1 @@\n-      if (my_pack(n0_in) != my_pack(n1_in) &&\n+      if (get_pack(n0_in) != get_pack(n1_in) &&\n@@ -3028,2 +2965,2 @@\n-bool SuperWord::is_vector_use(Node* use, int u_idx) {\n-  Node_List* u_pk = my_pack(use);\n+bool SuperWord::is_vector_use(Node* use, int u_idx) const {\n+  Node_List* u_pk = get_pack(use);\n@@ -3033,1 +2970,1 @@\n-  Node_List* d_pk = my_pack(def);\n+  Node_List* d_pk = get_pack(def);\n@@ -3172,0 +3109,22 @@\n+\n+      \/\/ If a Load depends on the same memory state as a Store, we must make sure that\n+      \/\/ the Load is ordered before the Store.\n+      \/\/\n+      \/\/      mem\n+      \/\/       |\n+      \/\/    +--+--+\n+      \/\/    |     |\n+      \/\/    |    Load (n)\n+      \/\/    |\n+      \/\/   Store (mem_use)\n+      \/\/\n+      if (n->is_Load()) {\n+        Node* mem = n->in(MemNode::Memory);\n+        for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n+          Node* mem_use = mem->fast_out(i);\n+          if (mem_use->is_Store() && _vloop.in_bb(mem_use) && !visited.test(bb_idx(mem_use))) {\n+            stack.push(mem_use); \/\/ Ordering edge: Load (n) -> Store (mem_use)\n+          }\n+        }\n+      }\n+\n@@ -3177,1 +3136,1 @@\n-          stack.push(use);\n+          stack.push(use); \/\/ Ordering edge: n -> use\n@@ -3180,0 +3139,1 @@\n+\n@@ -3216,1 +3176,1 @@\n-BasicType SuperWord::longer_type_for_conversion(Node* n) {\n+BasicType SuperWord::longer_type_for_conversion(Node* n) const {\n@@ -3376,1 +3336,1 @@\n-  VPointer p(s, _vloop);\n+  const VPointer& p = vpointer(s);\n@@ -3430,43 +3390,0 @@\n-\/\/------------------------------in_packset---------------------------\n-\/\/ Are s1 and s2 in a pack pair and ordered as s1,s2?\n-bool SuperWord::in_packset(Node* s1, Node* s2) {\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n-    assert(p->size() == 2, \"must be\");\n-    if (p->at(0) == s1 && p->at(p->size()-1) == s2) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/------------------------------remove_pack_at---------------------------\n-\/\/ Remove the pack at position pos in the packset\n-void SuperWord::remove_pack_at(int pos) {\n-  Node_List* p = _packset.at(pos);\n-  for (uint i = 0; i < p->size(); i++) {\n-    Node* s = p->at(i);\n-    set_my_pack(s, nullptr);\n-  }\n-  _packset.at_put(pos, nullptr);\n-}\n-\n-void SuperWord::packset_sort(int n) {\n-  \/\/ simple bubble sort so that we capitalize with O(n) when its already sorted\n-  do {\n-    int max_swap_index = 0;\n-    for (int i = 1; i < n; i++) {\n-      Node_List* q_low = _packset.at(i-1);\n-      Node_List* q_i = _packset.at(i);\n-\n-      \/\/ only swap when we find something to swap\n-      if (alignment(q_low->at(0)) > alignment(q_i->at(0))) {\n-        *(_packset.adr_at(i)) = q_low;\n-        *(_packset.adr_at(i-1)) = q_i;\n-        max_swap_index = i;\n-      }\n-    }\n-    n = max_swap_index;\n-  } while (n > 1);\n-}\n-\n@@ -3522,1 +3439,1 @@\n-  VPointer align_to_ref_p(align_to_ref, _vloop);\n+  const VPointer& align_to_ref_p = vpointer(align_to_ref);\n@@ -3825,2 +3742,0 @@\n-\/\/------------------------------print_packset---------------------------\n-void SuperWord::print_packset() {\n@@ -3828,5 +3743,24 @@\n-  tty->print_cr(\"packset\");\n-  for (int i = 0; i < _packset.length(); i++) {\n-    tty->print_cr(\"Pack: %d\", i);\n-    Node_List* p = _packset.at(i);\n-    if (p == nullptr) {\n+void PairSet::print() const {\n+  tty->print_cr(\"\\nPairSet::print: %d pairs\", length());\n+  int chain = 0;\n+  int chain_index = 0;\n+  for (PairSetIterator pair(*this); !pair.done(); pair.next()) {\n+    Node* left  = pair.left();\n+    Node* right = pair.right();\n+    if (is_left_in_a_left_most_pair(left)) {\n+      chain_index = 0;\n+      tty->print_cr(\" Pair-chain %d:\", chain++);\n+      tty->print(\"  %3d: \", chain_index++);\n+      left->dump();\n+    }\n+    tty->print(\"  %3d: \", chain_index++);\n+    right->dump();\n+  }\n+}\n+\n+void PackSet::print() const {\n+  tty->print_cr(\"\\nPackSet::print: %d packs\", _packs.length());\n+  for (int i = 0; i < _packs.length(); i++) {\n+    tty->print_cr(\" Pack: %d\", i);\n+    Node_List* pack = _packs.at(i);\n+    if (pack == nullptr) {\n@@ -3835,1 +3769,1 @@\n-      print_pack(p);\n+      print_pack(pack);\n@@ -3838,1 +3772,0 @@\n-#endif\n@@ -3841,4 +3774,4 @@\n-\/\/------------------------------print_pack---------------------------\n-void SuperWord::print_pack(Node_List* p) {\n-  for (uint i = 0; i < p->size(); i++) {\n-    print_stmt(p->at(i));\n+void PackSet::print_pack(Node_List* pack) {\n+  for (uint i = 0; i < pack->size(); i++) {\n+    tty->print(\"  %3d: \", i);\n+    pack->at(i)->dump();\n@@ -3847,0 +3780,1 @@\n+#endif\n@@ -3861,8 +3795,0 @@\n-\/\/------------------------------print_stmt---------------------------\n-void SuperWord::print_stmt(Node* s) {\n-#ifndef PRODUCT\n-  tty->print(\" align: %d \\t\", alignment(s));\n-  s->dump();\n-#endif\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":421,"deletions":495,"binary":false,"changes":916,"status":"modified"},{"patch":"@@ -60,0 +60,327 @@\n+\/\/ The PairSet is a set of pairs. These are later combined to packs,\n+\/\/ and stored in the PackSet.\n+class PairSet : public StackObj {\n+private:\n+  const VLoop& _vloop;\n+  const VLoopBody& _body;\n+\n+  \/\/ Doubly-linked pairs. If not linked: -1\n+  GrowableArray<int> _left_to_right; \/\/ bb_idx -> bb_idx\n+  GrowableArray<int> _right_to_left; \/\/ bb_idx -> bb_idx\n+  \/\/ Example:\n+  \/\/\n+  \/\/   Pairs: (n1, n2) and (n2, n3)\n+  \/\/   bb_idx(n1) = 1\n+  \/\/   bb_idx(n2) = 3\n+  \/\/   bb_idx(n3) = 5\n+  \/\/\n+  \/\/   index \/ bb_idx:   0   1   2   3   4   5   6\n+  \/\/\n+  \/\/   left_to_right:  |   | 3 |   | 5 |   |   |   |\n+  \/\/                         n1----->\n+  \/\/                                 n2----->\n+  \/\/\n+  \/\/   right_to_left:  |   |   |   | 1 |   | 3 |   |\n+  \/\/                          <------n2\n+  \/\/                                  <------n3\n+  \/\/\n+  \/\/   Nodes with bb_idx 0, 2, 4, and 6 are in no pair, they are thus neither left nor right elements,\n+  \/\/   and hence have no entries in the mapping.\n+  \/\/\n+  \/\/   Nodes with bb_idx 1 and 3 (n1 and n2) are both a left element in some pair. Therefore, they both\n+  \/\/   have an entry in the left_to_right mapping. This mapping indicates which right element they are\n+  \/\/   paired with, namely the nodes with bb_idx 3 and 5 (n2 and n3), respectively.\n+  \/\/\n+  \/\/   Nodes with bb_idx 3 and 5 (n2 and n4) are both a right element in some pair. Therefore, they both\n+  \/\/   have an entry in the right_to_left mapping. This mapping indicates which left element they are\n+  \/\/   paired with, namely the nodes with bb_idx 1 and 3 (n1 and n2), respectively.\n+  \/\/\n+  \/\/   Node n1 with bb_idx 1 is not a right element in any pair, thus its right_to_left is empty.\n+  \/\/\n+  \/\/   Node n2 with bb_idx 3 is both a left element of pair (n2, n3), and a right element of pair (n1, n2).\n+  \/\/   Thus it has entries in both left_to_right (mapping n2->n3) and right_to_left (mapping n2->n1).\n+  \/\/\n+  \/\/   Node n3 with bb_idx 5 is not a left element in any pair, thus its left_to_right is empty.\n+\n+  \/\/ List of all left elements bb_idx, in the order of pair addition.\n+  GrowableArray<int> _lefts_in_insertion_order;\n+\n+public:\n+  \/\/ Initialize empty, i.e. all not linked (-1).\n+  PairSet(Arena* arena, const VLoopAnalyzer& vloop_analyzer) :\n+    _vloop(vloop_analyzer.vloop()),\n+    _body(vloop_analyzer.body()),\n+    _left_to_right(arena, _body.body().length(), _body.body().length(), -1),\n+    _right_to_left(arena, _body.body().length(), _body.body().length(), -1),\n+    _lefts_in_insertion_order(arena, 8, 0, 0) {}\n+\n+  const VLoopBody& body() const { return _body; }\n+\n+  bool is_empty() const { return _lefts_in_insertion_order.is_empty(); }\n+\n+  bool is_left(int i)  const { return _left_to_right.at(i) != -1; }\n+  bool is_right(int i) const { return _right_to_left.at(i) != -1; }\n+  bool is_left(const Node* n)  const { return _vloop.in_bb(n) && is_left( _body.bb_idx(n)); }\n+  bool is_right(const Node* n) const { return _vloop.in_bb(n) && is_right(_body.bb_idx(n)); }\n+\n+  bool is_pair(const Node* n1, const Node* n2) const { return is_left(n1) && get_right_for(n1) == n2; }\n+\n+  bool is_left_in_a_left_most_pair(int i)   const { return is_left(i) && !is_right(i); }\n+  bool is_right_in_a_right_most_pair(int i) const { return !is_left(i) && is_right(i); }\n+  bool is_left_in_a_left_most_pair(const Node* n)   const { return is_left_in_a_left_most_pair( _body.bb_idx(n)); }\n+  bool is_right_in_a_right_most_pair(const Node* n) const { return is_right_in_a_right_most_pair(_body.bb_idx(n)); }\n+\n+  int get_right_for(int i) const { return _left_to_right.at(i); }\n+  Node* get_right_for(const Node* n) const { return _body.body().at(get_right_for(_body.bb_idx(n))); }\n+  Node* get_right_or_null_for(const Node* n) const { return is_left(n) ? get_right_for(n) : nullptr; }\n+\n+  \/\/ To access elements in insertion order:\n+  int length() const { return _lefts_in_insertion_order.length(); }\n+  Node* left_at_in_insertion_order(int i)  const { return _body.body().at(_lefts_in_insertion_order.at(i)); }\n+  Node* right_at_in_insertion_order(int i) const { return _body.body().at(get_right_for(_lefts_in_insertion_order.at(i))); }\n+\n+  void add_pair(Node* n1, Node* n2) {\n+    assert(n1 != nullptr && n2 != nullptr && n1 != n2, \"no nullptr, and different nodes\");\n+    assert(!is_left(n1) && !is_right(n2), \"cannot be left twice, or right twice\");\n+    int bb_idx_1 = _body.bb_idx(n1);\n+    int bb_idx_2 = _body.bb_idx(n2);\n+    _left_to_right.at_put(bb_idx_1, bb_idx_2);\n+    _right_to_left.at_put(bb_idx_2, bb_idx_1);\n+    _lefts_in_insertion_order.append(bb_idx_1);\n+    assert(is_left(n1) && is_right(n2), \"must be set now\");\n+  }\n+\n+  NOT_PRODUCT(void print() const;)\n+};\n+\n+\/\/ Iterate over the PairSet, pair-chain by pair-chain.\n+\/\/ A pair-chain starts with a \"left-most\" pair (n1, n2), where n1 is never a right-element\n+\/\/ in any pair. We walk a chain: (n2, n3), (n3, n4) ... until we hit a \"right-most\" pair\n+\/\/ where the right-element is never a left-element of any pair.\n+\/\/ These pair-chains will later be combined into packs by combine_pairs_to_longer_packs.\n+class PairSetIterator : public StackObj {\n+private:\n+  const PairSet& _pairset;\n+  const VLoopBody& _body;\n+\n+  int _chain_start_bb_idx; \/\/ bb_idx of left-element in the left-most pair.\n+  int _current_bb_idx;     \/\/ bb_idx of left-element of the current pair.\n+  const int _end_bb_idx;\n+\n+public:\n+  PairSetIterator(const PairSet& pairset) :\n+    _pairset(pairset),\n+    _body(pairset.body()),\n+    _chain_start_bb_idx(-1),\n+    _current_bb_idx(-1),\n+    _end_bb_idx(_body.body().length())\n+  {\n+    next_chain();\n+  }\n+\n+  bool done() const {\n+    return _chain_start_bb_idx >= _end_bb_idx;\n+  }\n+\n+  Node* left() const {\n+    return _body.body().at(_current_bb_idx);\n+  }\n+\n+  Node* right() const {\n+    int bb_idx_2 = _pairset.get_right_for(_current_bb_idx);\n+    return _body.body().at(bb_idx_2);\n+  }\n+\n+  \/\/ Try to keep walking on the current pair-chain, else find a new pair-chain.\n+  void next() {\n+    assert(_pairset.is_left(_current_bb_idx), \"current was valid\");\n+    _current_bb_idx = _pairset.get_right_for(_current_bb_idx);\n+    if (!_pairset.is_left(_current_bb_idx)) {\n+      next_chain();\n+    }\n+  }\n+\n+private:\n+  void next_chain() {\n+    do {\n+      _chain_start_bb_idx++;\n+    } while (!done() && !_pairset.is_left_in_a_left_most_pair(_chain_start_bb_idx));\n+    _current_bb_idx = _chain_start_bb_idx;\n+  }\n+};\n+\n+class SplitTask {\n+private:\n+  enum Kind {\n+    \/\/ The lambda method for split_packs can return one of these tasks:\n+    Unchanged, \/\/ The pack is left in the packset, unchanged.\n+    Rejected,  \/\/ The pack is removed from the packset.\n+    Split,     \/\/ Split away split_size nodes from the end of the pack.\n+  };\n+  const Kind _kind;\n+  const uint _split_size;\n+  const char* _message;\n+\n+  SplitTask(const Kind kind, const uint split_size, const char* message) :\n+      _kind(kind), _split_size(split_size), _message(message)\n+  {\n+    assert(message != nullptr, \"must have message\");\n+    assert(_kind != Unchanged || split_size == 0, \"unchanged task conditions\");\n+    assert(_kind != Rejected  || split_size == 0, \"reject task conditions\");\n+    assert(_kind != Split     || split_size != 0, \"split task conditions\");\n+  }\n+\n+public:\n+  static SplitTask make_split(const uint split_size, const char* message) {\n+    return SplitTask(Split, split_size, message);\n+  }\n+\n+  static SplitTask make_unchanged() {\n+    return SplitTask(Unchanged, 0, \"unchanged\");\n+  }\n+\n+  static SplitTask make_rejected(const char* message) {\n+    return SplitTask(Rejected, 0, message);\n+  }\n+\n+  bool is_unchanged() const { return _kind == Unchanged; }\n+  bool is_rejected() const { return _kind == Rejected; }\n+  bool is_split() const { return _kind == Split; }\n+  const char* message() const { return _message; }\n+\n+  uint split_size() const {\n+    assert(is_split(), \"only split tasks have split_size\");\n+    return _split_size;\n+  }\n+};\n+\n+class SplitStatus {\n+private:\n+  enum Kind {\n+    \/\/ After split_pack, we have:                              first_pack   second_pack\n+    Unchanged, \/\/ The pack is left in the pack, unchanged.     old_pack     nullptr\n+    Rejected,  \/\/ The pack is removed from the packset.        nullptr      nullptr\n+    Modified,  \/\/ The pack had some nodes removed.             old_pack     nullptr\n+    Split,     \/\/ The pack was split into two packs.           pack1        pack2\n+  };\n+  Kind _kind;\n+  Node_List* _first_pack;\n+  Node_List* _second_pack;\n+\n+  SplitStatus(Kind kind, Node_List* first_pack, Node_List* second_pack) :\n+    _kind(kind), _first_pack(first_pack), _second_pack(second_pack)\n+  {\n+    assert(_kind != Unchanged || (first_pack != nullptr && second_pack == nullptr), \"unchanged status conditions\");\n+    assert(_kind != Rejected  || (first_pack == nullptr && second_pack == nullptr), \"rejected status conditions\");\n+    assert(_kind != Modified  || (first_pack != nullptr && second_pack == nullptr), \"modified status conditions\");\n+    assert(_kind != Split     || (first_pack != nullptr && second_pack != nullptr), \"split status conditions\");\n+  }\n+\n+public:\n+  static SplitStatus make_unchanged(Node_List* old_pack) {\n+    return SplitStatus(Unchanged, old_pack, nullptr);\n+  }\n+\n+  static SplitStatus make_rejected() {\n+    return SplitStatus(Rejected, nullptr, nullptr);\n+  }\n+\n+  static SplitStatus make_modified(Node_List* first_pack) {\n+    return SplitStatus(Modified, first_pack, nullptr);\n+  }\n+\n+  static SplitStatus make_split(Node_List* first_pack, Node_List* second_pack) {\n+    return SplitStatus(Split, first_pack, second_pack);\n+  }\n+\n+  bool is_unchanged() const { return _kind == Unchanged; }\n+  Node_List* first_pack() const { return _first_pack; }\n+  Node_List* second_pack() const { return _second_pack; }\n+};\n+\n+class PackSet : public StackObj {\n+private:\n+  const VLoop& _vloop;\n+  const VLoopBody& _body;\n+\n+  \/\/ Set of all packs:\n+  GrowableArray<Node_List*> _packs;\n+\n+  \/\/ Mapping from nodes to their pack: bb_idx -> pack\n+  GrowableArray<Node_List*> _node_to_pack;\n+\n+  NOT_PRODUCT(const bool _trace_packset;)\n+  NOT_PRODUCT(const bool _trace_rejections;)\n+\n+public:\n+  \/\/ Initialize empty, i.e. no packs, and unmapped (nullptr).\n+  PackSet(Arena* arena, const VLoopAnalyzer& vloop_analyzer\n+          NOT_PRODUCT(COMMA bool trace_packset COMMA bool trace_rejections)\n+          ) :\n+    _vloop(vloop_analyzer.vloop()),\n+    _body(vloop_analyzer.body()),\n+    _packs(arena, 8, 0, nullptr),\n+    _node_to_pack(arena, _body.body().length(), _body.body().length(), nullptr)\n+    NOT_PRODUCT(COMMA _trace_packset(trace_packset))\n+    NOT_PRODUCT(COMMA _trace_rejections(trace_rejections))\n+    {}\n+\n+  \/\/ Accessors to iterate over packs.\n+  int length() const { return _packs.length(); }\n+  bool is_empty() const { return _packs.is_empty(); }\n+  Node_List* at(int i) const { return _packs.at(i); }\n+\n+private:\n+  void map_node_in_pack(const Node* n, Node_List* new_pack) {\n+    assert(get_pack(n) == nullptr, \"was previously unmapped\");\n+    _node_to_pack.at_put(_body.bb_idx(n), new_pack);\n+  }\n+\n+  void remap_node_in_pack(const Node* n, Node_List* new_pack) {\n+    assert(get_pack(n) != nullptr && new_pack != nullptr && get_pack(n) != new_pack, \"was previously mapped\");\n+    _node_to_pack.at_put(_body.bb_idx(n), new_pack);\n+  }\n+\n+  void unmap_node_in_pack(const Node* n) {\n+    assert(get_pack(n) != nullptr, \"was previously mapped\");\n+    _node_to_pack.at_put(_body.bb_idx(n), nullptr);\n+  }\n+\n+  void unmap_all_nodes_in_pack(Node_List* old_pack) {\n+    for (uint i = 0; i < old_pack->size(); i++) {\n+      unmap_node_in_pack(old_pack->at(i));\n+    }\n+  }\n+public:\n+  Node_List* get_pack(const Node* n) const { return !_vloop.in_bb(n) ? nullptr : _node_to_pack.at(_body.bb_idx(n)); }\n+\n+  void add_pack(Node_List* pack) {\n+    _packs.append(pack);\n+    for (uint i = 0; i < pack->size(); i++) {\n+      Node* n = pack->at(i);\n+      map_node_in_pack(n, pack);\n+    }\n+  }\n+\n+private:\n+  SplitStatus split_pack(const char* split_name, Node_List* pack, SplitTask task);\n+public:\n+  template <typename SplitStrategy>\n+  void split_packs(const char* split_name, SplitStrategy strategy);\n+\n+  template <typename FilterPredicate>\n+  void filter_packs(const char* filter_name,\n+                    const char* rejection_message,\n+                    FilterPredicate filter);\n+\n+  void clear() { _packs.clear(); }\n+\n+private:\n+  NOT_PRODUCT(bool is_trace_superword_packset() const { return _trace_packset; })\n+  NOT_PRODUCT(bool is_trace_superword_rejections() const { return _trace_rejections; })\n+public:\n+  DEBUG_ONLY(void verify() const;)\n+  NOT_PRODUCT(void print() const;)\n+  NOT_PRODUCT(static void print_pack(Node_List* pack);)\n+};\n+\n@@ -67,1 +394,0 @@\n-  Node_List*  _my_pack;   \/\/ pack containing this node\n@@ -69,1 +395,1 @@\n-  SWNodeInfo() : _alignment(-1), _my_pack(nullptr) {}\n+  SWNodeInfo() : _alignment(-1) {}\n@@ -86,2 +412,0 @@\n-  GrowableArray<Node_List*> _packset;    \/\/ Packs for the current block\n-\n@@ -92,0 +416,3 @@\n+  PairSet _pairset;\n+  PackSet _packset;\n+\n@@ -101,1 +428,1 @@\n-  \/\/ VLoop Accessors\n+  \/\/ VLoop accessors\n@@ -110,1 +437,1 @@\n-  \/\/ VLoopReductions Accessors\n+  \/\/ VLoopReductions accessors\n@@ -115,1 +442,1 @@\n-  bool reduction(Node* n1, Node* n2) const {\n+  bool reduction(const Node* n1, const Node* n2) const {\n@@ -119,1 +446,1 @@\n-  \/\/ VLoopMemorySlices Accessors\n+  \/\/ VLoopMemorySlices accessors\n@@ -124,1 +451,1 @@\n-  \/\/ VLoopBody Accessors\n+  \/\/ VLoopBody accessors\n@@ -133,1 +460,1 @@\n-  \/\/ VLoopTypes Accessors\n+  \/\/ VLoopTypes accessors\n@@ -158,1 +485,1 @@\n-  \/\/ VLoopDependencyGraph Accessors\n+  \/\/ VLoopDependencyGraph accessors\n@@ -171,0 +498,5 @@\n+  \/\/ VLoopVPointer accessors\n+  const VPointer& vpointer(const MemNode* mem) const {\n+    return _vloop_analyzer.vpointers().vpointer(mem);\n+  }\n+\n@@ -222,1 +554,3 @@\n-  const GrowableArray<Node_List*>& packset() const { return _packset; }\n+  const PackSet& packset() const { return _packset; }\n+  Node_List* get_pack(const Node* n) const { return _packset.get_pack(n); }\n+\n@@ -224,1 +558,0 @@\n-  bool           _race_possible;   \/\/ In cases where SDMU is true\n@@ -243,1 +576,1 @@\n-  int alignment(Node* n)                     { return _node_info.adr_at(bb_idx(n))->_alignment; }\n+  int alignment(Node* n) const               { return _node_info.adr_at(bb_idx(n))->_alignment; }\n@@ -246,5 +579,0 @@\n-  \/\/ my_pack\n- public:\n-  Node_List* my_pack(const Node* n)     const { return !in_bb(n) ? nullptr : _node_info.adr_at(bb_idx(n))->_my_pack; }\n- private:\n-  void set_my_pack(Node* n, Node_List* p)     { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)->_my_pack = p; }\n@@ -254,1 +582,1 @@\n-  bool same_inputs(const Node_List* p, int idx);\n+  bool same_inputs(const Node_List* p, int idx) const;\n@@ -270,2 +598,0 @@\n-  \/\/ Does s exist in a pack at position pos?\n-  bool exists_at(Node* s, uint pos);\n@@ -273,1 +599,1 @@\n-  bool are_adjacent_refs(Node* s1, Node* s2);\n+  bool are_adjacent_refs(Node* s1, Node* s2) const;\n@@ -282,2 +608,0 @@\n-  \/\/ Extend packset by following use->def and def->use links from pack members.\n-  void extend_packset_with_more_pairs_by_following_use_and_def();\n@@ -285,98 +609,0 @@\n-  \/\/ Extend the packset by visiting operand definitions of nodes in pack p\n-  bool follow_use_defs(Node_List* p);\n-  \/\/ Extend the packset by visiting uses of nodes in pack p\n-  bool follow_def_uses(Node_List* p);\n-  \/\/ For extended packsets, ordinally arrange uses packset by major component\n-  void order_def_uses(Node_List* p);\n-  \/\/ Estimate the savings from executing s1 and s2 as a pack\n-  int est_savings(Node* s1, Node* s2);\n-  int adjacent_profit(Node* s1, Node* s2);\n-  int pack_cost(int ct);\n-  int unpack_cost(int ct);\n-\n-  \/\/ Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last\n-  void combine_pairs_to_longer_packs();\n-\n-  class SplitTask {\n-  private:\n-    enum Kind {\n-      \/\/ The lambda method for split_packs can return one of these tasks:\n-      Unchanged, \/\/ The pack is left in the packset, unchanged.\n-      Rejected,  \/\/ The pack is removed from the packset.\n-      Split,     \/\/ Split away split_size nodes from the end of the pack.\n-    };\n-    const Kind _kind;\n-    const uint _split_size;\n-    const char* _message;\n-\n-    SplitTask(const Kind kind, const uint split_size, const char* message) :\n-        _kind(kind), _split_size(split_size), _message(message)\n-    {\n-      assert(message != nullptr, \"must have message\");\n-      assert(_kind != Unchanged || split_size == 0, \"unchanged task conditions\");\n-      assert(_kind != Rejected  || split_size == 0, \"reject task conditions\");\n-      assert(_kind != Split     || split_size != 0, \"split task conditions\");\n-    }\n-\n-  public:\n-    static SplitTask make_split(const uint split_size, const char* message) {\n-      return SplitTask(Split, split_size, message);\n-    }\n-\n-    static SplitTask make_unchanged() {\n-      return SplitTask(Unchanged, 0, \"unchanged\");\n-    }\n-\n-    static SplitTask make_rejected(const char* message) {\n-      return SplitTask(Rejected, 0, message);\n-    }\n-\n-    bool is_unchanged() const { return _kind == Unchanged; }\n-    bool is_rejected() const { return _kind == Rejected; }\n-    bool is_split() const { return _kind == Split; }\n-    const char* message() const { return _message; }\n-\n-    uint split_size() const {\n-      assert(is_split(), \"only split tasks have split_size\");\n-      return _split_size;\n-    }\n-  };\n-\n-  class SplitStatus {\n-  private:\n-    enum Kind {\n-      \/\/ After split_pack, we have:                              first_pack   second_pack\n-      Unchanged, \/\/ The pack is left in the pack, unchanged.     old_pack     nullptr\n-      Rejected,  \/\/ The pack is removed from the packset.        nullptr      nullptr\n-      Modified,  \/\/ The pack had some nodes removed.             old_pack     nullptr\n-      Split,     \/\/ The pack was split into two packs.           pack1        pack2\n-    };\n-    Kind _kind;\n-    Node_List* _first_pack;\n-    Node_List* _second_pack;\n-\n-    SplitStatus(Kind kind, Node_List* first_pack, Node_List* second_pack) :\n-      _kind(kind), _first_pack(first_pack), _second_pack(second_pack)\n-    {\n-      assert(_kind != Unchanged || (first_pack != nullptr && second_pack == nullptr), \"unchanged status conditions\");\n-      assert(_kind != Rejected  || (first_pack == nullptr && second_pack == nullptr), \"rejected status conditions\");\n-      assert(_kind != Modified  || (first_pack != nullptr && second_pack == nullptr), \"modified status conditions\");\n-      assert(_kind != Split     || (first_pack != nullptr && second_pack != nullptr), \"split status conditions\");\n-    }\n-\n-  public:\n-    static SplitStatus make_unchanged(Node_List* old_pack) {\n-      return SplitStatus(Unchanged, old_pack, nullptr);\n-    }\n-\n-    static SplitStatus make_rejected() {\n-      return SplitStatus(Rejected, nullptr, nullptr);\n-    }\n-\n-    static SplitStatus make_modified(Node_List* first_pack) {\n-      return SplitStatus(Modified, first_pack, nullptr);\n-    }\n-\n-    static SplitStatus make_split(Node_List* first_pack, Node_List* second_pack) {\n-      return SplitStatus(Split, first_pack, second_pack);\n-    }\n@@ -384,4 +610,7 @@\n-    bool is_unchanged() const { return _kind == Unchanged; }\n-    Node_List* first_pack() const { return _first_pack; }\n-    Node_List* second_pack() const { return _second_pack; }\n-  };\n+  void extend_pairset_with_more_pairs_by_following_use_and_def();\n+  bool extend_pairset_with_more_pairs_by_following_def(Node* s1, Node* s2);\n+  bool extend_pairset_with_more_pairs_by_following_use(Node* s1, Node* s2);\n+  void order_inputs_of_all_use_pairs_to_match_def_pair(Node* def1, Node* def2);\n+  enum PairOrderStatus { Ordered, Unordered, Unknown };\n+  PairOrderStatus order_inputs_of_uses_to_match_def_pair(Node* def1, Node* def2, Node* use1, Node* use2);\n+  int estimate_cost_savings_when_packing_as_pair(const Node* s1, const Node* s2) const;\n@@ -389,3 +618,1 @@\n-  SplitStatus split_pack(const char* split_name, Node_List* pack, SplitTask task);\n-  template <typename SplitStrategy>\n-  void split_packs(const char* split_name, SplitStrategy strategy);\n+  void combine_pairs_to_longer_packs();\n@@ -397,5 +624,0 @@\n-  \/\/ Filter out packs with various filter predicates\n-  template <typename FilterPredicate>\n-  void filter_packs(const char* filter_name,\n-                    const char* error_message,\n-                    FilterPredicate filter);\n@@ -404,1 +626,0 @@\n-  \/\/ Ensure all packs are aligned, if AlignVector is on.\n@@ -406,1 +627,0 @@\n-  \/\/ Find the set of alignment solutions for load\/store pack.\n@@ -408,5 +628,0 @@\n-  \/\/ Compress packset, such that it has no nullptr entries.\n-  void compress_packset();\n-  \/\/ Construct the map from nodes to packs.\n-  void construct_my_pack_map();\n-  \/\/ Remove packs that are not implemented.\n@@ -414,1 +629,0 @@\n-  \/\/ Remove packs that are not profitable.\n@@ -416,3 +630,3 @@\n-  \/\/ Verify that for every pack, all nodes are mutually independent.\n-  \/\/ Also verify that packset and my_pack are consistent.\n-  DEBUG_ONLY(void verify_packs();)\n+\n+  DEBUG_ONLY(void verify_packs() const;)\n+\n@@ -430,1 +644,1 @@\n-  bool implemented(const Node_List* pack, uint size);\n+  bool implemented(const Node_List* pack, const uint size) const;\n@@ -435,1 +649,2 @@\n-  bool profitable(const Node_List* p);\n+  bool profitable(const Node_List* p) const;\n+\n@@ -443,0 +658,1 @@\n+\n@@ -444,1 +660,1 @@\n-  bool is_vector_use(Node* use, int u_idx);\n+  bool is_vector_use(Node* use, int u_idx) const;\n@@ -448,2 +664,0 @@\n-  \/\/ Compute max depth for expressions from beginning of block\n-  void compute_max_depth();\n@@ -451,1 +665,1 @@\n-  BasicType longer_type_for_conversion(Node* n);\n+  BasicType longer_type_for_conversion(Node* n) const;\n@@ -454,4 +668,1 @@\n-  \/\/ Are s1 and s2 in a pack pair and ordered as s1,s2?\n-  bool in_packset(Node* s1, Node* s2);\n-  \/\/ Remove the pack at position pos in the packset\n-  void remove_pack_at(int pos);\n+\n@@ -463,9 +674,0 @@\n-  \/\/ Is the use of d1 in u1 at the same operand position as d2 in u2?\n-  bool opnd_positions_match(Node* d1, Node* u1, Node* d2, Node* u2);\n-\n-  \/\/ print methods\n-  void print_packset();\n-  void print_pack(Node_List* p);\n-  void print_stmt(Node* s);\n-\n-  void packset_sort(int n);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":367,"deletions":165,"binary":false,"changes":532,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  flags(POINTER_ANALYSIS,     \"Trace VPointer\") \\\n+  flags(POINTER_ANALYSIS,     \"Trace VPointer (verbose)\") \\\n@@ -38,0 +38,1 @@\n+  flags(POINTERS,             \"Trace VLoopPointers\") \\\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6347,1 +6347,2 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->intersection_with(tp_interfaces)->eq(tp_interfaces) && !tp->klass_is_exact()) {\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->contains(tp_interfaces) &&\n+          !tp->klass_is_exact()) {\n@@ -6365,1 +6366,2 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->intersection_with(tp_interfaces)->eq(tp_interfaces) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->contains(tp_interfaces) &&\n+            !tp->klass_is_exact()) {\n@@ -6399,1 +6401,2 @@\n-    return other->klass() == ciEnv::current()->Object_klass() && other->_interfaces->intersection_with(this_one->_interfaces)->eq(other->_interfaces) && other_exact;\n+    return other->klass() == ciEnv::current()->Object_klass() && this_one->_interfaces->contains(other->_interfaces) &&\n+           other_exact;\n@@ -6461,3 +6464,1 @@\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -6467,1 +6468,2 @@\n-    return other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces->intersection_with(this_one->_interfaces)->eq(other->_interfaces);\n+    return other->klass()->equals(ciEnv::current()->Object_klass()) &&\n+           this_one->_interfaces->contains(other->_interfaces);\n@@ -6469,0 +6471,7 @@\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (this_top_or_bottom) {\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -34,0 +34,13 @@\n+#ifndef PRODUCT\n+static void print_con_or_idx(const Node* n) {\n+  if (n == nullptr) {\n+    tty->print(\"(   0)\");\n+  } else if (n->is_ConI()) {\n+    jint val = n->as_ConI()->get_int();\n+    tty->print(\"(%4d)\", val);\n+  } else {\n+    tty->print(\"[%4d]\", n->_idx);\n+  }\n+}\n+#endif\n+\n@@ -164,0 +177,2 @@\n+  _vpointers.compute_vpointers();\n+\n@@ -169,0 +184,49 @@\n+void VLoopVPointers::compute_vpointers() {\n+  count_vpointers();\n+  allocate_vpointers_array();\n+  compute_and_cache_vpointers();\n+  NOT_PRODUCT( if (_vloop.is_trace_vpointers()) { print(); } )\n+}\n+\n+void VLoopVPointers::count_vpointers() {\n+  _vpointers_length = 0;\n+  _body.for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+    _vpointers_length++;\n+  });\n+}\n+\n+void VLoopVPointers::allocate_vpointers_array() {\n+  uint bytes = _vpointers_length * sizeof(VPointer);\n+  _vpointers = (VPointer*)_arena->Amalloc(bytes);\n+}\n+\n+void VLoopVPointers::compute_and_cache_vpointers() {\n+  int pointers_idx = 0;\n+  _body.for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+    \/\/ Placement new: construct directly into the array.\n+    ::new (&_vpointers[pointers_idx]) VPointer(mem, _vloop);\n+    _bb_idx_to_vpointer.at_put(bb_idx, pointers_idx);\n+    pointers_idx++;\n+  });\n+}\n+\n+const VPointer& VLoopVPointers::vpointer(const MemNode* mem) const {\n+  assert(mem != nullptr && _vloop.in_bb(mem), \"only mem in loop\");\n+  int bb_idx = _body.bb_idx(mem);\n+  int pointers_idx = _bb_idx_to_vpointer.at(bb_idx);\n+  assert(0 <= pointers_idx && pointers_idx < _vpointers_length, \"valid range\");\n+  return _vpointers[pointers_idx];\n+}\n+\n+#ifndef PRODUCT\n+void VLoopVPointers::print() const {\n+  tty->print_cr(\"\\nVLoopVPointers::print:\");\n+\n+  _body.for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+    const VPointer& p = vpointer(mem);\n+    tty->print(\"  \");\n+    p.print();\n+  });\n+}\n+#endif\n+\n@@ -196,1 +260,1 @@\n-      VPointer p1(n1, _vloop);\n+      const VPointer& p1 = _vpointers.vpointer(n1);\n@@ -204,1 +268,1 @@\n-        VPointer p2(n2, _vloop);\n+        const VPointer& p2 = _vpointers.vpointer(n2);\n@@ -231,0 +295,13 @@\n+int VLoopDependencyGraph::find_max_pred_depth(const Node* n) const {\n+  int max_pred_depth = 0;\n+  if (!n->is_Phi()) { \/\/ ignore backedge\n+    for (PredsIterator it(*this, n); !it.done(); it.next()) {\n+      Node* pred = it.current();\n+      if (_vloop.in_bb(pred)) {\n+        max_pred_depth = MAX2(max_pred_depth, depth(pred));\n+      }\n+    }\n+  }\n+  return max_pred_depth;\n+}\n+\n@@ -237,8 +314,11 @@\n-    int max_pred_depth = 0;\n-    if (n->is_Phi()) {\n-      for (PredsIterator it(*this, n); !it.done(); it.next()) {\n-        Node* pred = it.current();\n-        if (_vloop.in_bb(pred)) {\n-          max_pred_depth = MAX2(max_pred_depth, depth(pred));\n-        }\n-      }\n+    set_depth(n, find_max_pred_depth(n) + 1);\n+  }\n+\n+#ifdef ASSERT\n+  for (int i = 0; i < _body.body().length(); i++) {\n+    Node* n = _body.body().at(i);\n+    int max_pred_depth = find_max_pred_depth(n);\n+    if (depth(n) != max_pred_depth + 1) {\n+      print();\n+      tty->print_cr(\"Incorrect depth: %d vs %d\", depth(n), max_pred_depth + 1);\n+      n->dump();\n@@ -246,1 +326,1 @@\n-    set_depth(n, max_pred_depth + 1);\n+    assert(depth(n) == max_pred_depth + 1, \"must have correct depth\");\n@@ -248,0 +328,1 @@\n+#endif\n@@ -396,0 +477,19 @@\n+  \/\/ In the pointer analysis, and especially the AlignVector, analysis we assume that\n+  \/\/ stride and scale are not too large. For example, we multiply \"scale * stride\",\n+  \/\/ and assume that this does not overflow the int range. We also take \"abs(scale)\"\n+  \/\/ and \"abs(stride)\", which would overflow for min_int = -(2^31). Still, we want\n+  \/\/ to at least allow small and moderately large stride and scale. Therefore, we\n+  \/\/ allow values up to 2^30, which is only a factor 2 smaller than the max\/min int.\n+  \/\/ Normal performance relevant code will have much lower values. And the restriction\n+  \/\/ allows us to keep the rest of the autovectorization code much simpler, since we\n+  \/\/ do not have to deal with overflows.\n+  jlong long_scale  = _scale;\n+  jlong long_stride = _vloop.iv_stride();\n+  jlong max_val = 1 << 30;\n+  if (abs(long_scale) >= max_val ||\n+      abs(long_stride) >= max_val ||\n+      abs(long_scale * long_stride) >= max_val) {\n+    assert(!valid(), \"adr stride*scale is too large\");\n+    return;\n+  }\n+\n@@ -707,2 +807,0 @@\n-\/\/ Function for printing the fields of a VPointer\n-void VPointer::print() {\n@@ -710,9 +808,15 @@\n-  tty->print(\"base: [%d]  adr: [%d]  scale: %d  offset: %d\",\n-             _base != nullptr ? _base->_idx : 0,\n-             _adr  != nullptr ? _adr->_idx  : 0,\n-             _scale, _offset);\n-  if (_invar != nullptr) {\n-    tty->print(\"  invar: [%d]\", _invar->_idx);\n-  }\n-  tty->cr();\n-#endif\n+\/\/ Function for printing the fields of a VPointer\n+void VPointer::print() const {\n+  tty->print(\"VPointer[mem: %4d %10s, \", _mem->_idx, _mem->Name());\n+  tty->print(\"base: %4d, \", _base != nullptr ? _base->_idx : 0);\n+  tty->print(\"adr: %4d, \", _adr != nullptr ? _adr->_idx : 0);\n+\n+  tty->print(\" base\");\n+  print_con_or_idx(_base);\n+\n+  tty->print(\" + offset(%4d)\", _offset);\n+\n+  tty->print(\" + invar\");\n+  print_con_or_idx(_invar);\n+\n+  tty->print_cr(\" + scale(%4d) * iv]\", _scale);\n@@ -720,0 +824,1 @@\n+#endif\n@@ -1486,11 +1591,0 @@\n-static void print_con_or_idx(const Node* n) {\n-  if (n == nullptr) {\n-    tty->print(\"(0)\");\n-  } else if (n->is_ConI()) {\n-    jint val = n->as_ConI()->get_int();\n-    tty->print(\"(%d)\", val);\n-  } else {\n-    tty->print(\"[%d]\", n->_idx);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":127,"deletions":33,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+class VPointer;\n+\n@@ -157,0 +159,4 @@\n+  bool is_trace_vpointers() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::POINTERS);\n+  }\n+\n@@ -278,1 +284,1 @@\n-  bool is_marked_reduction_pair(Node* s1, Node* s2) const;\n+  bool is_marked_reduction_pair(const Node* s1, const Node* s2) const;\n@@ -359,0 +365,10 @@\n+  template<typename Callback>\n+  void for_each_mem(Callback callback) const {\n+    for (int i = 0; i < _body.length(); i++) {\n+      MemNode* mem = _body.at(i)->isa_Mem();\n+      if (mem != nullptr && _vloop.in_bb(mem)) {\n+        callback(mem, i);\n+      }\n+    }\n+  }\n+\n@@ -448,0 +464,39 @@\n+\/\/ Submodule of VLoopAnalyzer.\n+\/\/ We compute and cache the VPointer for every load and store.\n+class VLoopVPointers : public StackObj {\n+private:\n+  Arena*                   _arena;\n+  const VLoop&             _vloop;\n+  const VLoopBody&         _body;\n+\n+  \/\/ Array of cached pointers\n+  VPointer* _vpointers;\n+  int _vpointers_length;\n+\n+  \/\/ Map bb_idx -> index in _vpointers. -1 if not mapped.\n+  GrowableArray<int> _bb_idx_to_vpointer;\n+\n+public:\n+  VLoopVPointers(Arena* arena,\n+                 const VLoop& vloop,\n+                 const VLoopBody& body) :\n+    _arena(arena),\n+    _vloop(vloop),\n+    _body(body),\n+    _vpointers(nullptr),\n+    _bb_idx_to_vpointer(arena,\n+                        vloop.estimated_body_length(),\n+                        vloop.estimated_body_length(),\n+                        -1) {}\n+  NONCOPYABLE(VLoopVPointers);\n+\n+  void compute_vpointers();\n+  const VPointer& vpointer(const MemNode* mem) const;\n+  NOT_PRODUCT( void print() const; )\n+\n+private:\n+  void count_vpointers();\n+  void allocate_vpointers_array();\n+  void compute_and_cache_vpointers();\n+};\n+\n@@ -464,0 +519,1 @@\n+  const VLoopVPointers&    _vpointers;\n@@ -475,1 +531,2 @@\n-                       const VLoopMemorySlices& memory_slices) :\n+                       const VLoopMemorySlices& memory_slices,\n+                       const VLoopVPointers& pointers) :\n@@ -480,0 +537,1 @@\n+    _vpointers(pointers),\n@@ -498,0 +556,1 @@\n+  int find_max_pred_depth(const Node* n) const;\n@@ -573,0 +632,1 @@\n+  VLoopVPointers       _vpointers;\n@@ -584,1 +644,2 @@\n-    _dependency_graph(&_arena, vloop, _body, _memory_slices)\n+    _vpointers       (&_arena, vloop, _body),\n+    _dependency_graph(&_arena, vloop, _body, _memory_slices, _vpointers)\n@@ -598,0 +659,1 @@\n+  const VLoopVPointers& vpointers()              const { return _vpointers; }\n@@ -681,1 +743,1 @@\n-  bool invar_equals(VPointer& q) {\n+  bool invar_equals(const VPointer& q) const {\n@@ -689,1 +751,1 @@\n-  int cmp(VPointer& q) {\n+  int cmp(const VPointer& q) const {\n@@ -701,1 +763,1 @@\n-  bool overlap_possible_with_any_in(Node_List* p) {\n+  bool overlap_possible_with_any_in(const Node_List* p) const {\n@@ -715,3 +777,3 @@\n-  bool not_equal(VPointer& q)     { return not_equal(cmp(q)); }\n-  bool equal(VPointer& q)         { return equal(cmp(q)); }\n-  bool comparable(VPointer& q)    { return comparable(cmp(q)); }\n+  bool not_equal(const VPointer& q)  const { return not_equal(cmp(q)); }\n+  bool equal(const VPointer& q)      const { return equal(cmp(q)); }\n+  bool comparable(const VPointer& q) const { return comparable(cmp(q)); }\n@@ -722,1 +784,1 @@\n-  void print();\n+  NOT_PRODUCT( void print() const; )\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":72,"deletions":10,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-bool VectorNode::is_muladds2i(Node* n) {\n+bool VectorNode::is_muladds2i(const Node* n) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  static bool is_muladds2i(Node* n);\n+  static bool is_muladds2i(const Node* n);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-static bool is_decipherable_compiled_frame(JavaThread* thread, frame* fr, CompiledMethod* nm);\n+static bool is_decipherable_compiled_frame(JavaThread* thread, frame* fr, nmethod* nm);\n@@ -153,1 +153,1 @@\n-static bool is_decipherable_compiled_frame(JavaThread* thread, frame* fr, CompiledMethod* nm) {\n+static bool is_decipherable_compiled_frame(JavaThread* thread, frame* fr, nmethod* nm) {\n@@ -416,1 +416,1 @@\n-    if (candidate.cb()->is_compiled()) {\n+    if (candidate.cb()->is_nmethod()) {\n@@ -418,1 +418,1 @@\n-      CompiledMethod* nm = candidate.cb()->as_compiled_method();\n+      nmethod* nm = candidate.cb()->as_nmethod();\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n+      write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n@@ -125,1 +125,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n+      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n@@ -383,0 +383,14 @@\n+void JvmtiClassFileReconstituter::write_annotations_attribute(const char* attr_name,\n+                                                              const char* fallback_attr_name,\n+                                                              AnnotationArray* annos) {\n+  TempNewSymbol sym = SymbolTable::probe(attr_name, (int)strlen(attr_name));\n+  if (sym != nullptr) {\n+    if (symbol_to_cpool_index(sym) != 0) {\n+      write_annotations_attribute(attr_name, annos);\n+      return;\n+    }\n+  }\n+  \/\/ use fallback name\n+  write_annotations_attribute(fallback_attr_name, annos);\n+}\n+\n@@ -522,1 +536,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleAnnotations\", component->annotations());\n+      write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", component->annotations());\n@@ -525,1 +539,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", component->type_annotations());\n+      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", component->type_annotations());\n@@ -764,1 +778,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n+    write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n@@ -767,1 +781,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleParameterAnnotations\", param_anno);\n+    write_annotations_attribute(\"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\", param_anno);\n@@ -770,1 +784,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n+    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n@@ -830,1 +844,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n+    write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n@@ -833,1 +847,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n+    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,7 @@\n+  \/\/ With PreserveAllAnnotations option \"runtime invisible\" annotations\n+  \/\/ (RuntimeInvisibleAnnotations\/RuntimeInvisibleTypeAnnotations\/RuntimeInvisibleParameterAnnotations)\n+  \/\/ are considered \"runtime visible\" and ClassFileReconstituter writes them as\n+  \/\/ RuntimeVisibleAnnotations\/RuntimeVisibleTypeAnnotations\/RuntimeVisibleParameterAnnotations.\n+  \/\/ This helper method is for the corner case when \"runtime visible\" attribute name is not presents\n+  \/\/ in the class constant pool and the annotations are written with fallback \"runtime invisible\" name.\n+  void write_annotations_attribute(const char* attr_name, const char* fallback_attr_name, AnnotationArray* annos);\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-      NMethodIterator iter(NMethodIterator::only_not_unloading);\n+      NMethodIterator iter(NMethodIterator::not_unloading);\n","filename":"src\/hotspot\/share\/prims\/jvmtiCodeBlobEvents.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1681,1 +1681,0 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n@@ -1684,1 +1683,0 @@\n-\n@@ -1687,1 +1685,0 @@\n-    ThreadsListHandle tlh(current_thread);\n@@ -1690,16 +1687,0 @@\n-    JavaThread *java_thread;\n-    oop thread_obj = nullptr;\n-    err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-\n-    if (java_lang_VirtualThread::is_instance(thread_obj) && java_thread == nullptr) {\n-      \/\/ Target virtual thread is unmounted.\n-      ResourceMark rm(current_thread);\n-      MultipleStackTracesCollector collector(this, max_frame_count);\n-      collector.fill_frames(thread, java_thread, thread_obj);\n-      collector.allocate_and_fill_stacks(\/* thread_count *\/ 1);\n-      *stack_info_ptr = collector.stack_info();\n-      return collector.result();\n-    }\n@@ -1708,1 +1689,1 @@\n-    Handshake::execute(&op, &tlh, java_thread);\n+    JvmtiHandshake::execute(&op, thread);\n@@ -1714,0 +1695,2 @@\n+    JvmtiVTMSTransitionDisabler disabler;\n+\n@@ -1751,0 +1734,1 @@\n+  Handle thread_handle(current_thread, thread_obj);\n@@ -1777,5 +1761,1 @@\n-  if (self) {\n-    op.doit(java_thread, self);\n-  } else {\n-    Handshake::execute(&op, java_thread);\n-  }\n+  JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2056,2 +2056,2 @@\n-GetSingleStackTraceClosure::do_thread(Thread *target) {\n-  JavaThread *jt = JavaThread::cast(target);\n+GetSingleStackTraceClosure::doit() {\n+  JavaThread *jt = _target_jt;\n@@ -2060,1 +2060,1 @@\n-  if (!jt->is_exiting() && thread_oop != nullptr) {\n+  if ((jt == nullptr || !jt->is_exiting()) && thread_oop != nullptr) {\n@@ -2064,0 +2064,1 @@\n+    set_result(_collector.result());\n@@ -2067,0 +2068,12 @@\n+void\n+GetSingleStackTraceClosure::do_thread(Thread *target) {\n+  assert(_target_jt == JavaThread::cast(target), \"sanity check\");\n+  doit();\n+}\n+\n+void\n+GetSingleStackTraceClosure::do_vthread(Handle target_h) {\n+  assert(_target_jt == nullptr || _target_jt->vthread() == target_h(), \"sanity check\");\n+  doit();\n+}\n+\n@@ -2169,0 +2182,1 @@\n+  Handle thread_handle(current_thread, thread_obj);\n@@ -2189,0 +2203,1 @@\n+  MutexLocker mu(JvmtiThreadState_lock);\n@@ -2190,5 +2205,1 @@\n-  if (self) {\n-    op.doit(java_thread, self);\n-  } else {\n-    Handshake::execute(&op, java_thread);\n-  }\n+  JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n@@ -2199,1 +2210,1 @@\n-SetForceEarlyReturn::doit(Thread *target, bool self) {\n+SetForceEarlyReturn::doit(Thread *target) {\n@@ -2334,1 +2345,1 @@\n-UpdateForPopTopFrameClosure::doit(Thread *target, bool self) {\n+UpdateForPopTopFrameClosure::doit(Thread *target) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -459,10 +459,0 @@\n-class JvmtiHandshakeClosure : public HandshakeClosure {\n- protected:\n-  jvmtiError _result;\n- public:\n-  JvmtiHandshakeClosure(const char* name)\n-    : HandshakeClosure(name),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n-  jvmtiError result() { return _result; }\n-};\n-\n@@ -502,1 +492,1 @@\n-class SetForceEarlyReturn : public JvmtiHandshakeClosure {\n+class SetForceEarlyReturn : public JvmtiUnitedHandshakeClosure {\n@@ -509,1 +499,1 @@\n-    : JvmtiHandshakeClosure(\"SetForceEarlyReturn\"),\n+    : JvmtiUnitedHandshakeClosure(\"SetForceEarlyReturn\"),\n@@ -513,0 +503,1 @@\n+  void doit(Thread *target);\n@@ -514,1 +505,6 @@\n-    doit(target, false \/* self *\/);\n+    doit(target);\n+  }\n+  void do_vthread(Handle target_h) {\n+    assert(_target_jt != nullptr, \"sanity check\");\n+    assert(_target_jt->vthread() == target_h(), \"sanity check\");\n+    doit(_target_jt); \/\/ mounted virtual thread\n@@ -516,1 +512,0 @@\n-  void doit(Thread *target, bool self);\n@@ -520,1 +515,1 @@\n-class UpdateForPopTopFrameClosure : public JvmtiHandshakeClosure {\n+class UpdateForPopTopFrameClosure : public JvmtiUnitedHandshakeClosure {\n@@ -526,1 +521,1 @@\n-    : JvmtiHandshakeClosure(\"UpdateForPopTopFrame\"),\n+    : JvmtiUnitedHandshakeClosure(\"UpdateForPopTopFrame\"),\n@@ -528,0 +523,1 @@\n+  void doit(Thread *target);\n@@ -529,1 +525,6 @@\n-    doit(target, false \/* self *\/);\n+    doit(target);\n+  }\n+  void do_vthread(Handle target_h) {\n+    assert(_target_jt != nullptr, \"sanity check\");\n+    assert(_target_jt->vthread() == target_h(), \"sanity check\");\n+    doit(_target_jt); \/\/ mounted virtual thread\n@@ -531,1 +532,0 @@\n-  void doit(Thread *target, bool self);\n@@ -727,1 +727,1 @@\n-class GetSingleStackTraceClosure : public HandshakeClosure {\n+class GetSingleStackTraceClosure : public JvmtiUnitedHandshakeClosure {\n@@ -736,1 +736,1 @@\n-    : HandshakeClosure(\"GetSingleStackTrace\"),\n+    : JvmtiUnitedHandshakeClosure(\"GetSingleStackTrace\"),\n@@ -742,0 +742,2 @@\n+  void do_vthread(Handle target_h);\n+  void doit();\n@@ -743,1 +745,1 @@\n-  jvmtiError result()             { return _collector.result(); }\n+  jvmtiError result()             { return _result; }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1017,1 +1017,1 @@\n-void JvmtiDeferredEvent::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+void JvmtiDeferredEvent::oops_do(OopClosure* f, NMethodClosure* cf) {\n@@ -1019,1 +1019,1 @@\n-    cf->do_code_blob(_event_data.compiled_method_load);\n+    cf->do_nmethod(_event_data.compiled_method_load);\n@@ -1025,1 +1025,1 @@\n-void JvmtiDeferredEvent::nmethods_do(CodeBlobClosure* cf) {\n+void JvmtiDeferredEvent::nmethods_do(NMethodClosure* cf) {\n@@ -1027,1 +1027,1 @@\n-    cf->do_code_blob(_event_data.compiled_method_load);\n+    cf->do_nmethod(_event_data.compiled_method_load);\n@@ -1095,1 +1095,1 @@\n-void JvmtiDeferredEventQueue::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+void JvmtiDeferredEventQueue::oops_do(OopClosure* f, NMethodClosure* cf) {\n@@ -1101,1 +1101,1 @@\n-void JvmtiDeferredEventQueue::nmethods_do(CodeBlobClosure* cf) {\n+void JvmtiDeferredEventQueue::nmethods_do(NMethodClosure* cf) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -502,1 +502,1 @@\n-  void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  void nmethods_do(NMethodClosure* cf) NOT_JVMTI_RETURN;\n@@ -504,1 +504,1 @@\n-  void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  void oops_do(OopClosure* f, NMethodClosure* cf) NOT_JVMTI_RETURN;\n@@ -545,1 +545,1 @@\n-  void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  void nmethods_do(NMethodClosure* cf) NOT_JVMTI_RETURN;\n@@ -547,1 +547,1 @@\n-  void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  void oops_do(OopClosure* f, NMethodClosure* cf) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4353,1 +4353,2 @@\n-  \/\/ Leave arrays of jmethodIDs and itable index cache unchanged\n+  \/\/ Update jmethodID cache if present.\n+  the_class->update_methods_jmethod_cache();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -987,1 +987,1 @@\n-void JvmtiThreadState::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+void JvmtiThreadState::oops_do(OopClosure* f, NMethodClosure* cf) {\n@@ -996,1 +996,1 @@\n-void JvmtiThreadState::nmethods_do(CodeBlobClosure* cf) {\n+void JvmtiThreadState::nmethods_do(NMethodClosure* cf) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -528,2 +528,2 @@\n-  void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN; \/\/ GC support\n-  void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  void oops_do(OopClosure* f, NMethodClosure* cf) NOT_JVMTI_RETURN; \/\/ GC support\n+  void nmethods_do(NMethodClosure* cf) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1055,1 +1055,1 @@\n-    if (box.not_null() && box->klass() == Universe::objectArrayKlassObj() && box->length() > 0) {\n+    if (box.not_null() && box->klass() == Universe::objectArrayKlass() && box->length() > 0) {\n@@ -1258,1 +1258,1 @@\n-      index_info_oop->klass() != Universe::intArrayKlassObj() ||\n+      index_info_oop->klass() != Universe::intArrayKlass() ||\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n+  TypeArrayKlass* tak = Universe::typeArrayKlass(elem_bt);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -771,3 +771,3 @@\n-                CompiledMethod* cm = CodeCache::find_compiled(f->pc());\n-                assert(cm != nullptr, \"sanity check\");\n-                cm->make_not_entrant();\n+                nmethod* nm = CodeCache::find_nmethod(f->pc());\n+                assert(nm != nullptr, \"did not find nmethod\");\n+                nm->make_not_entrant();\n@@ -823,1 +823,1 @@\n-      MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+      MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n@@ -842,1 +842,1 @@\n-  CompiledMethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  nmethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n@@ -941,1 +941,1 @@\n-  CompiledMethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  nmethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n@@ -1026,1 +1026,1 @@\n-  CompiledMethod* code = mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);\n+  nmethod* code = mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);\n@@ -1100,2 +1100,2 @@\n-    CompiledMethod* code = mh->code();\n-    if (code != nullptr && code->as_nmethod_or_null() != nullptr) {\n+    nmethod* code = mh->code();\n+    if (code != nullptr) {\n@@ -1559,1 +1559,1 @@\n-  CompiledMethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  nmethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n@@ -1611,1 +1611,1 @@\n-      ::new (blob) BufferBlob(\"WB::DummyBlob\", full_size);\n+      ::new (blob) BufferBlob(\"WB::DummyBlob\", CodeBlobKind::Buffer, full_size);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -540,0 +540,1 @@\n+  { \"UseNeon\",                      JDK_Version::undefined(), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n@@ -1135,2 +1136,1 @@\n-      bool mismatched = ((msg_type == JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD) ||\n-                         (msg_type == JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD));\n+      bool mismatched = msg_type == JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD;\n@@ -1264,1 +1264,3 @@\n-  CDSConfig::check_system_property(key, value);\n+  if (internal == ExternalProperty) {\n+    CDSConfig::check_incompatible_property(key, value);\n+  }\n@@ -1903,0 +1905,1 @@\n+  CDSConfig::check_internal_module_property(prop_name, prop_value);\n@@ -1922,0 +1925,1 @@\n+  CDSConfig::check_internal_module_property(prop_base_name, prop_value);\n@@ -3415,2 +3419,1 @@\n-#ifndef PRODUCT\n-  \/\/ UseDebuggerErgo is notproduct\n+#ifdef ASSERT\n@@ -3420,1 +3423,0 @@\n-#endif\n@@ -3422,1 +3424,0 @@\n-#ifndef PRODUCT\n@@ -3428,1 +3429,0 @@\n-#endif\n@@ -3437,0 +3437,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-  \/\/ case, the displaced_header() is unlocked\/is_neutral, because the\n+  \/\/ case, the displaced_header() is unlocked\/neutral, because the\n@@ -46,1 +46,1 @@\n-  \/\/ does not matter, this inflation will just a no-op. For other cases,\n+  \/\/ does not matter, this inflation will just be a no-op. For other cases,\n@@ -66,1 +66,1 @@\n-  \/\/ is small (given the support for inflated fast-path locking in the fast_lock, etc)\n+  \/\/ small (given the support for inflated fast-path locking in the fast_lock, etc)\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+  \/\/ This is either the actual displaced header from a locked object, or\n+  \/\/ a sentinel zero value indicating a recursive stack-lock.\n@@ -49,1 +51,1 @@\n-  \/\/ move a basic lock (used during deoptimization\n+  \/\/ move a basic lock (used during deoptimization)\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-  if (f.cb() == nullptr || !f.cb()->is_compiled()) {\n+  if (f.cb() == nullptr || !f.cb()->is_nmethod()) {\n@@ -111,1 +111,1 @@\n-  Method* m = f.cb()->as_compiled_method()->method();\n+  Method* m = f.cb()->as_nmethod()->method();\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-CompiledMethod* ContinuationEntry::_enter_special = nullptr;\n+nmethod* ContinuationEntry::_enter_special = nullptr;\n@@ -43,1 +43,1 @@\n-void ContinuationEntry::set_enter_code(CompiledMethod* cm, int interpreted_entry_offset) {\n+void ContinuationEntry::set_enter_code(nmethod* nm, int interpreted_entry_offset) {\n@@ -45,1 +45,1 @@\n-  _return_pc = cm->code_begin() + _return_pc_offset;\n+  _return_pc = nm->code_begin() + _return_pc_offset;\n@@ -47,1 +47,1 @@\n-  _enter_special = cm;\n+  _enter_special = nm;\n@@ -144,1 +144,1 @@\n-    assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n+    assert(cb->as_nmethod()->method()->is_continuation_enter_intrinsic(), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-class CompiledMethod;\n@@ -37,0 +36,1 @@\n+class nmethod;\n@@ -59,1 +59,1 @@\n-  static void set_enter_code(CompiledMethod* cm, int interpreted_entry_offset);\n+  static void set_enter_code(nmethod* nm, int interpreted_entry_offset);\n@@ -64,1 +64,1 @@\n-  static CompiledMethod* _enter_special;\n+  static nmethod* _enter_special;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"code\/compiledMethod.inline.hpp\"\n+#include \"code\/nmethod.inline.hpp\"\n@@ -1073,2 +1073,2 @@\n-      assert(f.cb()->as_compiled_method()->is_deopt_pc(f.raw_pc()), \"\");\n-      assert(f.cb()->as_compiled_method()->is_deopt_pc(ContinuationHelper::Frame::real_pc(f)), \"\");\n+      assert(f.cb()->as_nmethod()->is_deopt_pc(f.raw_pc()), \"\");\n+      assert(f.cb()->as_nmethod()->is_deopt_pc(ContinuationHelper::Frame::real_pc(f)), \"\");\n@@ -1473,1 +1473,1 @@\n-  ResourceMark rm; \/\/ used for scope traversal in num_java_frames(CompiledMethod*, address)\n+  ResourceMark rm; \/\/ used for scope traversal in num_java_frames(nmethod*, address)\n@@ -2293,1 +2293,1 @@\n-              || (_cont.is_preempted() && f.cb()->as_compiled_method()->is_marked_for_deoptimization())) {\n+              || (_cont.is_preempted() && f.cb()->as_nmethod()->is_marked_for_deoptimization())) {\n@@ -2312,1 +2312,1 @@\n-    int stack_args_slots = f.cb()->as_compiled_method()->method()->num_stack_arg_slots(false \/* rounded *\/);\n+    int stack_args_slots = f.cb()->as_nmethod()->method()->num_stack_arg_slots(false \/* rounded *\/);\n@@ -2407,1 +2407,1 @@\n-  assert(!f.is_compiled_frame() || f.is_deoptimized_frame() == f.cb()->as_compiled_method()->is_deopt_pc(f.raw_pc()), \"\");\n+  assert(!f.is_compiled_frame() || f.is_deoptimized_frame() == f.cb()->as_nmethod()->is_deopt_pc(f.raw_pc()), \"\");\n@@ -2494,4 +2494,4 @@\n-    if (fst.current()->cb()->is_compiled()) {\n-      CompiledMethod* cm = fst.current()->cb()->as_compiled_method();\n-      if (!cm->method()->is_continuation_native_intrinsic()) {\n-        cm->make_deoptimized();\n+    if (fst.current()->cb()->is_nmethod()) {\n+      nmethod* nm = fst.current()->cb()->as_nmethod();\n+      if (!nm->method()->is_continuation_native_intrinsic()) {\n+        nm->make_deoptimized();\n@@ -2537,1 +2537,1 @@\n-  CodeBlobToOopClosure cf(&cl, false);\n+  NMethodToOopClosure cf(&cl, false);\n@@ -2543,1 +2543,1 @@\n-    if (fst.current()->cb()->is_compiled() && fst.current()->cb()->as_compiled_method()->is_marked_for_deoptimization()) {\n+    if (fst.current()->cb()->is_nmethod() && fst.current()->cb()->as_nmethod()->is_marked_for_deoptimization()) {\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  return f.is_interpreted_frame() ? f.interpreter_frame_method() : f.cb()->as_compiled_method()->method();\n+  return f.is_interpreted_frame() ? f.interpreter_frame_method() : f.cb()->as_nmethod()->method();\n@@ -82,2 +82,2 @@\n-  CompiledMethod* cm = sender.cb()->as_compiled_method();\n-  return cm->is_deopt_pc(pc);\n+  nmethod* nm = sender.cb()->as_nmethod();\n+  return nm->is_deopt_pc(pc);\n@@ -165,2 +165,2 @@\n-  CompiledMethod* cm = f.cb()->as_compiled_method();\n-  assert(!cm->is_compiled() || !cm->as_compiled_method()->is_native_method(), \"\"); \/\/ See compiledVFrame::compiledVFrame(...) in vframe_hp.cpp\n+  nmethod* nm = f.cb()->as_nmethod();\n+  assert(!nm->is_native_method(), \"\"); \/\/ See compiledVFrame::compiledVFrame(...) in vframe_hp.cpp\n@@ -168,1 +168,1 @@\n-  if (!cm->has_monitors()) {\n+  if (!nm->has_monitors()) {\n@@ -174,1 +174,1 @@\n-  for (ScopeDesc* scope = cm->scope_desc_at(f.pc()); scope != nullptr; scope = scope->sender()) {\n+  for (ScopeDesc* scope = nm->scope_desc_at(f.pc()); scope != nullptr; scope = scope->sender()) {\n@@ -189,1 +189,1 @@\n-        \/\/assert(cm->has_monitors(), \"\");\n+        \/\/assert(nm->has_monitors(), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n@@ -120,2 +120,2 @@\n-void DeoptimizationScope::mark(CompiledMethod* cm, bool inc_recompile_counts) {\n-  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+void DeoptimizationScope::mark(nmethod* nm, bool inc_recompile_counts) {\n+  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -124,2 +124,2 @@\n-  if (cm->is_marked_for_deoptimization()) {\n-    dependent(cm);\n+  if (nm->is_marked_for_deoptimization()) {\n+    dependent(nm);\n@@ -129,3 +129,3 @@\n-  CompiledMethod::DeoptimizationStatus status =\n-    inc_recompile_counts ? CompiledMethod::deoptimize : CompiledMethod::deoptimize_noupdate;\n-  Atomic::store(&cm->_deoptimization_status, status);\n+  nmethod::DeoptimizationStatus status =\n+    inc_recompile_counts ? nmethod::deoptimize : nmethod::deoptimize_noupdate;\n+  Atomic::store(&nm->_deoptimization_status, status);\n@@ -135,1 +135,1 @@\n-  assert(cm->_deoptimization_generation == 0, \"Is already marked\");\n+  assert(nm->_deoptimization_generation == 0, \"Is already marked\");\n@@ -137,1 +137,1 @@\n-  cm->_deoptimization_generation = DeoptimizationScope::_active_deopt_gen;\n+  nm->_deoptimization_generation = DeoptimizationScope::_active_deopt_gen;\n@@ -141,2 +141,2 @@\n-void DeoptimizationScope::dependent(CompiledMethod* cm) {\n-  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+void DeoptimizationScope::dependent(nmethod* nm) {\n+  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -146,2 +146,2 @@\n-  if (_required_gen < cm->_deoptimization_generation) {\n-    _required_gen = cm->_deoptimization_generation;\n+  if (_required_gen < nm->_deoptimization_generation) {\n+    _required_gen = nm->_deoptimization_generation;\n@@ -173,1 +173,1 @@\n-      ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+      ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -201,1 +201,1 @@\n-        ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+        ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -304,1 +304,0 @@\n-    Klass* k = java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()());\n@@ -307,3 +306,0 @@\n-    st.print(\"     object <\" INTPTR_FORMAT \"> of type \", p2i(sv->value()()));\n-    k->print_value_on(&st);\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n@@ -311,3 +307,2 @@\n-      st.print(\" allocation failed\");\n-    } else {\n-      st.print(\" allocated (\" SIZE_FORMAT \" bytes)\", obj->size() * HeapWordSize);\n+      st.print_cr(\"     nullptr\");\n+      continue;\n@@ -315,1 +310,0 @@\n-    st.cr();\n@@ -317,1 +311,7 @@\n-    if (Verbose && !obj.is_null()) {\n+    Klass* k = java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()());\n+\n+    st.print(\"     object <\" INTPTR_FORMAT \"> of type \", p2i(sv->value()()));\n+    k->print_value_on(&st);\n+    st.print_cr(\" allocated (\" SIZE_FORMAT \" bytes)\", obj->size() * HeapWordSize);\n+\n+    if (Verbose && k != nullptr) {\n@@ -324,1 +324,1 @@\n-static bool rematerialize_objects(JavaThread* thread, int exec_mode, CompiledMethod* compiled_method,\n+static bool rematerialize_objects(JavaThread* thread, int exec_mode, nmethod* compiled_method,\n@@ -442,1 +442,1 @@\n-  CompiledMethod* cm = deoptee.cb()->as_compiled_method_or_null();\n+  nmethod* nm = deoptee.cb()->as_nmethod_or_null();\n@@ -451,1 +451,1 @@\n-    realloc_failures = rematerialize_objects(thread, Unpack_none, cm, deoptee, map, chunk, deoptimized_objects);\n+    realloc_failures = rematerialize_objects(thread, Unpack_none, nm, deoptee, map, chunk, deoptimized_objects);\n@@ -495,2 +495,2 @@\n-  CompiledMethod* cm = deoptee.cb()->as_compiled_method_or_null();\n-  current->set_deopt_compiled_method(cm);\n+  nmethod* nm = deoptee.cb()->as_nmethod_or_null();\n+  current->set_deopt_compiled_method(nm);\n@@ -525,1 +525,1 @@\n-    realloc_failures = rematerialize_objects(current, exec_mode, cm, deoptee, map, chunk, unused);\n+    realloc_failures = rematerialize_objects(current, exec_mode, nm, deoptee, map, chunk, unused);\n@@ -1223,2 +1223,2 @@\n-      CompiledMethod* cm = fr->cb()->as_compiled_method_or_null();\n-      if (cm->is_compiled_by_jvmci() && sv->is_auto_box()) {\n+      nmethod* nm = fr->cb()->as_nmethod_or_null();\n+      if (nm->is_compiled_by_jvmci() && sv->is_auto_box()) {\n@@ -1750,2 +1750,2 @@\n-    CompiledMethod* cm = fr.cb()->as_compiled_method_or_null();\n-    assert(cm != nullptr, \"only compiled methods can deopt\");\n+    nmethod* nm = fr.cb()->as_nmethod_or_null();\n+    assert(nm != nullptr, \"only compiled methods can deopt\");\n@@ -1755,1 +1755,1 @@\n-    cm->log_identity(xtty);\n+    nm->log_identity(xtty);\n@@ -1757,1 +1757,1 @@\n-    for (ScopeDesc* sd = cm->scope_desc_at(fr.pc()); ; sd = sd->sender()) {\n+    for (ScopeDesc* sd = nm->scope_desc_at(fr.pc()); ; sd = sd->sender()) {\n@@ -1785,1 +1785,1 @@\n-address Deoptimization::deoptimize_for_missing_exception_handler(CompiledMethod* cm) {\n+address Deoptimization::deoptimize_for_missing_exception_handler(nmethod* nm) {\n@@ -1787,1 +1787,1 @@\n-  cm->make_not_entrant();\n+  nm->make_not_entrant();\n@@ -1800,1 +1800,1 @@\n-  assert(caller_frame.cb()->as_compiled_method_or_null() == cm, \"expect top frame compiled method\");\n+  assert(caller_frame.cb()->as_nmethod_or_null() == nm, \"expect top frame compiled method\");\n@@ -1818,1 +1818,1 @@\n-  MethodData* trap_mdo = get_method_data(thread, methodHandle(thread, cm->method()), true);\n+  MethodData* trap_mdo = get_method_data(thread, methodHandle(thread, nm->method()), true);\n@@ -1953,1 +1953,1 @@\n-static void post_deoptimization_event(CompiledMethod* nm,\n+static void post_deoptimization_event(nmethod* nm,\n@@ -1982,1 +1982,1 @@\n-static void log_deopt(CompiledMethod* nm, Method* tm, intptr_t pc, frame& fr, int trap_bci,\n+static void log_deopt(nmethod* nm, Method* tm, intptr_t pc, frame& fr, int trap_bci,\n@@ -2044,1 +2044,1 @@\n-    CompiledMethod* nm = cvf->code();\n+    nmethod* nm = cvf->code();\n@@ -2061,1 +2061,1 @@\n-      nm->as_nmethod()->update_speculation(current);\n+      nm->update_speculation(current);\n@@ -2181,2 +2181,2 @@\n-        if (nm->is_nmethod()) {\n-          const char* installed_code_name = nm->as_nmethod()->jvmci_name();\n+        if (nm->is_compiled_by_jvmci()) {\n+          const char* installed_code_name = nm->jvmci_name();\n@@ -2436,1 +2436,1 @@\n-          UseRTMDeopt && (nm->as_nmethod()->rtm_state() != ProfileRTM)) {\n+          UseRTMDeopt && (nm->rtm_state() != ProfileRTM)) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  void mark(CompiledMethod* cm, bool inc_recompile_counts = true);\n+  void mark(nmethod* nm, bool inc_recompile_counts = true);\n@@ -62,1 +62,1 @@\n-  void dependent(CompiledMethod* cm);\n+  void dependent(nmethod* nm);\n@@ -187,1 +187,1 @@\n-  static address deoptimize_for_missing_exception_handler(CompiledMethod* cm);\n+  static address deoptimize_for_missing_exception_handler(nmethod* nm);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-    notproduct,               \\\n@@ -52,1 +51,0 @@\n-    notproduct,               \\\n@@ -59,1 +57,0 @@\n-    notproduct,               \\\n@@ -68,1 +65,0 @@\n-    notproduct,               \\\n@@ -77,1 +73,0 @@\n-    notproduct,               \\\n@@ -86,1 +81,0 @@\n-    notproduct,               \\\n@@ -95,1 +89,0 @@\n-    notproduct,               \\\n@@ -104,1 +97,0 @@\n-    notproduct,               \\\n@@ -113,1 +105,0 @@\n-    notproduct,               \\\n@@ -122,1 +113,0 @@\n-    notproduct,               \\\n@@ -131,1 +121,0 @@\n-    notproduct,               \\\n@@ -140,1 +129,0 @@\n-    notproduct,               \\\n@@ -149,1 +137,0 @@\n-    notproduct,               \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/allFlags.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-                            notproduct,                                     \\\n@@ -58,1 +57,0 @@\n-                            notproduct,                                     \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/debug_globals.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * true for notproduct and develop flags in product builds.\n+ * true for develop flags in product builds.\n@@ -62,1 +62,1 @@\n-  return is_notproduct() || is_develop();\n+  return is_develop();\n@@ -124,5 +124,0 @@\n-  if (is_notproduct() && is_product_build()) {\n-    jio_snprintf(buf, buflen, \"Error: VM option '%s' is notproduct and is available only in debug version of VM.\\n\",\n-                 _name);\n-    return JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD;\n-  }\n@@ -145,1 +140,1 @@\n-  \/\/ Don't print notproduct and develop flags in a product build.\n+  \/\/ Don't print develop flags in a product build.\n@@ -347,1 +342,0 @@\n-    { KIND_NOT_PRODUCT, \"notproduct\" },\n@@ -461,6 +455,6 @@\n-\/\/                                                  dev     dev-pd  pro     pro-pd  notpro  range     constraint\n-enum FlagCounter_LP64  { LP64_RUNTIME_FLAGS(        ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)  num_flags_LP64   };\n-enum FlagCounter_ARCH  { ARCH_FLAGS(                ENUM_F,         ENUM_F,         ENUM_F, IGNORE_F, IGNORE_F)  num_flags_ARCH   };\n-enum FlagCounter_JVMCI { JVMCI_ONLY(JVMCI_FLAGS(    ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_JVMCI  };\n-enum FlagCounter_C1    { COMPILER1_PRESENT(C1_FLAGS(ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_C1     };\n-enum FlagCounter_C2    { COMPILER2_PRESENT(C2_FLAGS(ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_C2     };\n+\/\/                                                  dev     dev-pd  pro     pro-pd  range     constraint\n+enum FlagCounter_LP64  { LP64_RUNTIME_FLAGS(        ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)  num_flags_LP64   };\n+enum FlagCounter_ARCH  { ARCH_FLAGS(                ENUM_F,         ENUM_F,         IGNORE_F, IGNORE_F)  num_flags_ARCH   };\n+enum FlagCounter_JVMCI { JVMCI_ONLY(JVMCI_FLAGS(    ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_JVMCI  };\n+enum FlagCounter_C1    { COMPILER1_PRESENT(C1_FLAGS(ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_C1     };\n+enum FlagCounter_C2    { COMPILER2_PRESENT(C2_FLAGS(ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_C2     };\n@@ -506,1 +500,0 @@\n-const int NOTPROD_KIND     = JVMFlag::KIND_NOT_PRODUCT;\n@@ -513,1 +506,0 @@\n-#define INITIALIZE_NOTPROD_FLAG(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), FLAG_TYPE(type), XSTR(name), (void*)&name, NOTPROD_KIND,    __VA_ARGS__),\n@@ -525,1 +517,0 @@\n-            INITIALIZE_NOTPROD_FLAG,     \\\n@@ -562,1 +553,1 @@\n-    \/\/ Don't report notproduct and develop flags in product builds.\n+    \/\/ Don't report develop flags in product builds.\n@@ -688,2 +679,1 @@\n-      assert((flags & KIND_NOT_PRODUCT) == 0 &&\n-             (flags & KIND_DEVELOP) == 0,\n+      assert((flags & KIND_DEVELOP) == 0,\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,8 +66,7 @@\n-    KIND_NOT_PRODUCT        = 1 << 8,\n-    KIND_DEVELOP            = 1 << 9,\n-    KIND_PLATFORM_DEPENDENT = 1 << 10,\n-    KIND_C1                 = 1 << 11,\n-    KIND_C2                 = 1 << 12,\n-    KIND_ARCH               = 1 << 13,\n-    KIND_LP64_PRODUCT       = 1 << 14,\n-    KIND_JVMCI              = 1 << 15,\n+    KIND_DEVELOP            = 1 << 8,\n+    KIND_PLATFORM_DEPENDENT = 1 << 9,\n+    KIND_C1                 = 1 << 10,\n+    KIND_C2                 = 1 << 11,\n+    KIND_ARCH               = 1 << 12,\n+    KIND_LP64_PRODUCT       = 1 << 13,\n+    KIND_JVMCI              = 1 << 14,\n@@ -117,2 +116,1 @@\n-    DEVELOPER_FLAG_BUT_PRODUCT_BUILD,\n-    NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD\n+    DEVELOPER_FLAG_BUT_PRODUCT_BUILD\n@@ -251,1 +249,0 @@\n-  bool is_notproduct() const      { return (_flags & KIND_NOT_PRODUCT) != 0;                  }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,0 @@\n-           FLAG_LIMIT_DEFINE_DUMMY,\n@@ -118,1 +117,0 @@\n-           FLAG_LIMIT_DEFINE,\n@@ -133,1 +131,0 @@\n-            FLAG_LIMIT_PTR_NONE,\n@@ -141,1 +138,0 @@\n-            FLAG_LIMIT_PTR,\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-            DO_FLAG,\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLookup.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -208,3 +208,4 @@\n-    CompiledMethod* cm = cb()->as_compiled_method_or_null();\n-    if (cm->is_method_handle_return(pc()))\n-      return cm->deopt_mh_handler_begin() - pc_return_offset;\n+    nmethod* nm = cb()->as_nmethod_or_null();\n+    assert(nm != nullptr, \"only nmethod is expected here\");\n+    if (nm->is_method_handle_return(pc()))\n+      return nm->deopt_mh_handler_begin() - pc_return_offset;\n@@ -212,1 +213,1 @@\n-      return cm->deopt_handler_begin() - pc_return_offset;\n+      return nm->deopt_handler_begin() - pc_return_offset;\n@@ -316,2 +317,2 @@\n-  assert(_cb != nullptr && _cb->is_compiled(), \"must be an nmethod\");\n-  CompiledMethod* nm = (CompiledMethod *)_cb;\n+  assert(_cb != nullptr && _cb->is_nmethod(), \"must be an nmethod\");\n+  nmethod* nm = _cb->as_nmethod();\n@@ -336,1 +337,1 @@\n-  CompiledMethod* nm = (CompiledMethod*)_cb;\n+  nmethod* nm = _cb->as_nmethod();\n@@ -349,1 +350,1 @@\n-  assert(_cb != nullptr && _cb->is_compiled(), \"must be\");\n+  assert(_cb != nullptr && _cb->is_nmethod(), \"must be\");\n@@ -352,4 +353,4 @@\n-  CompiledMethod* cm = (CompiledMethod*) _cb;\n-  address deopt = cm->is_method_handle_return(pc()) ?\n-                        cm->deopt_mh_handler_begin() :\n-                        cm->deopt_handler_begin();\n+  nmethod* nm = _cb->as_nmethod();\n+  address deopt = nm->is_method_handle_return(pc()) ?\n+                        nm->deopt_mh_handler_begin() :\n+                        nm->deopt_handler_begin();\n@@ -360,1 +361,1 @@\n-  cm->set_original_pc(this, pc());\n+  nm->set_original_pc(this, pc());\n@@ -677,3 +678,3 @@\n-    } else if (_cb->is_compiled()) {\n-      CompiledMethod* cm = (CompiledMethod*)_cb;\n-      Method* m = cm->method();\n+    } else if (_cb->is_nmethod()) {\n+      nmethod* nm = _cb->as_nmethod();\n+      Method* m = nm->method();\n@@ -681,5 +682,2 @@\n-        if (cm->is_nmethod()) {\n-          nmethod* nm = cm->as_nmethod();\n-          st->print(\"J %d%s\", nm->compile_id(), (nm->is_osr_method() ? \"%\" : \"\"));\n-          st->print(\" %s\", nm->compiler_name());\n-        }\n+        st->print(\"J %d%s\", nm->compile_id(), (nm->is_osr_method() ? \"%\" : \"\"));\n+        st->print(\" %s\", nm->compiler_name());\n@@ -700,6 +698,3 @@\n-        if (cm->is_nmethod()) {\n-          nmethod* nm = cm->as_nmethod();\n-          const char* jvmciName = nm->jvmci_name();\n-          if (jvmciName != nullptr) {\n-            st->print(\" (%s)\", jvmciName);\n-          }\n+        const char* jvmciName = nm->jvmci_name();\n+        if (jvmciName != nullptr) {\n+          st->print(\" (%s)\", jvmciName);\n@@ -970,1 +965,1 @@\n-void frame::oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, DerivedOopClosure* df, DerivedPointerIterationMode derived_mode, const RegisterMap* reg_map) const {\n+void frame::oops_nmethod_do(OopClosure* f, NMethodClosure* cf, DerivedOopClosure* df, DerivedPointerIterationMode derived_mode, const RegisterMap* reg_map) const {\n@@ -991,2 +986,2 @@\n-  if (cf != nullptr)\n-    cf->do_code_blob(_cb);\n+  if (cf != nullptr && _cb->is_nmethod())\n+    cf->do_nmethod(_cb->as_nmethod());\n@@ -1139,1 +1134,1 @@\n-void frame::oops_do_internal(OopClosure* f, CodeBlobClosure* cf,\n+void frame::oops_do_internal(OopClosure* f, NMethodClosure* cf,\n@@ -1156,1 +1151,1 @@\n-    oops_code_blob_do(f, cf, df, derived_mode, map);\n+    oops_nmethod_do(f, cf, df, derived_mode, map);\n@@ -1162,1 +1157,1 @@\n-void frame::nmethods_do(CodeBlobClosure* cf) const {\n+void frame::nmethod_do(NMethodClosure* cf) const {\n@@ -1164,1 +1159,1 @@\n-    cf->do_code_blob(_cb);\n+    cf->do_nmethod(_cb->as_nmethod());\n@@ -1406,1 +1401,1 @@\n-  } else if (cb()->is_compiled()) {\n+  } else if (cb()->is_nmethod()) {\n@@ -1408,1 +1403,1 @@\n-    CompiledMethod* cm = cb()->as_compiled_method();\n+    nmethod* nm = cb()->as_nmethod();\n@@ -1411,2 +1406,2 @@\n-                                       p2i(cm),\n-                                       cm->method()->name_and_sig_as_C_string(),\n+                                       p2i(nm),\n+                                       nm->method()->name_and_sig_as_C_string(),\n@@ -1419,1 +1414,1 @@\n-      Method* m = cm->method();\n+      Method* m = nm->method();\n@@ -1421,1 +1416,1 @@\n-      int stack_slot_offset = cm->frame_size() * wordSize; \/\/ offset, in bytes, to caller sp\n+      int stack_slot_offset = nm->frame_size() * wordSize; \/\/ offset, in bytes, to caller sp\n@@ -1472,1 +1467,1 @@\n-      for (ScopeDesc* scope = cm->scope_desc_at(pc()); scope != nullptr; scope = scope->sender(), scope_no++) {\n+      for (ScopeDesc* scope = nm->scope_desc_at(pc()); scope != nullptr; scope = scope->sender(), scope_no++) {\n@@ -1510,1 +1505,1 @@\n-    if (cm->method()->is_continuation_enter_intrinsic()) {\n+    if (nm->method()->is_continuation_enter_intrinsic()) {\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":37,"deletions":42,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-class CompiledMethod;\n@@ -125,0 +124,5 @@\n+  \/\/ Return the original PC for the given PC if:\n+  \/\/ (a) the given PC belongs to an nmethod and\n+  \/\/ (b) it is a deopt PC\n+  address get_deopt_original_pc() const;\n+\n@@ -454,1 +458,1 @@\n-  void oops_do_internal(OopClosure* f, CodeBlobClosure* cf,\n+  void oops_do_internal(OopClosure* f, NMethodClosure* cf,\n@@ -459,3 +463,3 @@\n-  void oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf,\n-                         DerivedOopClosure* df, DerivedPointerIterationMode derived_mode,\n-                         const RegisterMap* map) const;\n+  void oops_nmethod_do(OopClosure* f, NMethodClosure* cf,\n+                       DerivedOopClosure* df, DerivedPointerIterationMode derived_mode,\n+                       const RegisterMap* map) const;\n@@ -464,1 +468,1 @@\n-  void oops_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* map) {\n+  void oops_do(OopClosure* f, NMethodClosure* cf, const RegisterMap* map) {\n@@ -475,1 +479,1 @@\n-  void oops_do(OopClosure* f, CodeBlobClosure* cf, DerivedOopClosure* df, const RegisterMap* map) {\n+  void oops_do(OopClosure* f, NMethodClosure* cf, DerivedOopClosure* df, const RegisterMap* map) {\n@@ -479,1 +483,1 @@\n-  void oops_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* map,\n+  void oops_do(OopClosure* f, NMethodClosure* cf, const RegisterMap* map,\n@@ -484,1 +488,1 @@\n-  void nmethods_do(CodeBlobClosure* cf) const;\n+  void nmethod_do(NMethodClosure* cf) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"code\/compiledMethod.inline.hpp\"\n+#include \"code\/nmethod.inline.hpp\"\n@@ -67,2 +67,2 @@\n-      _cb->is_compiled() &&\n-      ((CompiledMethod*)_cb)->is_java_method()) {\n+      _cb->is_nmethod() &&\n+      _cb->as_nmethod()->is_java_method()) {\n@@ -74,0 +74,10 @@\n+inline address frame::get_deopt_original_pc() const {\n+  if (_cb == nullptr)  return nullptr;\n+\n+  nmethod* nm = _cb->as_nmethod_or_null();\n+  if (nm != nullptr && nm->is_deopt_pc(_pc)) {\n+    return nm->get_original_pc(this);\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, ...)\n@@ -38,1 +37,0 @@\n-#define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, ...)   type name = value;\n@@ -45,1 +43,0 @@\n-          MATERIALIZE_NOTPRODUCT_FLAG,\n","filename":"src\/hotspot\/share\/runtime\/globals.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\/\/ notproduct flags are settable \/ visible only during development and are not declared in the PRODUCT version\n@@ -121,1 +120,0 @@\n-                           notproduct,                                      \\\n@@ -145,1 +143,0 @@\n-                           notproduct,                                      \\\n@@ -158,1 +155,0 @@\n-                      notproduct,                                           \\\n@@ -162,1 +158,1 @@\n-  notproduct(bool, CheckCompressedOops, true,                               \\\n+  develop(bool, CheckCompressedOops, true,                                  \\\n@@ -285,1 +281,1 @@\n-  notproduct(bool, TraceCodeBlobStacks, false,                              \\\n+  develop(bool, TraceCodeBlobStacks, false,                                 \\\n@@ -288,1 +284,1 @@\n-  notproduct(bool, PrintRewrites, false,                                    \\\n+  develop(bool, PrintRewrites, false,                                       \\\n@@ -387,1 +383,1 @@\n-  notproduct(ccstrlist, DeoptimizeOnlyAt, \"\",                               \\\n+  develop(ccstrlist, DeoptimizeOnlyAt, \"\",                                  \\\n@@ -393,1 +389,1 @@\n-  notproduct(bool, ZombieALot, false,                                       \\\n+  develop(bool, ZombieALot, false,                                          \\\n@@ -396,1 +392,1 @@\n-  notproduct(bool, WalkStackALot, false,                                    \\\n+  develop(bool, WalkStackALot, false,                                       \\\n@@ -422,1 +418,1 @@\n-  notproduct(bool, VerifyLastFrame, false,                                  \\\n+  develop(bool, VerifyLastFrame, false,                                     \\\n@@ -465,1 +461,1 @@\n-  notproduct(bool, VerifyCodeCache, false,                                  \\\n+  develop(bool, VerifyCodeCache, false,                                     \\\n@@ -471,1 +467,1 @@\n-  notproduct(bool, ZapVMHandleArea, trueInDebug,                            \\\n+  develop(bool, ZapVMHandleArea, trueInDebug,                               \\\n@@ -474,1 +470,1 @@\n-  notproduct(bool, ZapStackSegments, trueInDebug,                           \\\n+  develop(bool, ZapStackSegments, trueInDebug,                              \\\n@@ -486,0 +482,3 @@\n+  develop(bool, ZapTLAB, trueInDebug,                                       \\\n+          \"Zap allocated TLABs\")                                            \\\n+                                                                            \\\n@@ -618,1 +617,1 @@\n-  notproduct(bool, PrintNMethodStatistics, false,                           \\\n+  develop(bool, PrintNMethodStatistics, false,                              \\\n@@ -695,1 +694,1 @@\n-  notproduct(bool, PrintSystemDictionaryAtExit, false,                      \\\n+  develop(bool, PrintSystemDictionaryAtExit, false,                         \\\n@@ -698,1 +697,1 @@\n-  notproduct(bool, PrintClassLoaderDataGraphAtExit, false,                  \\\n+  develop(bool, PrintClassLoaderDataGraphAtExit, false,                     \\\n@@ -812,1 +811,1 @@\n-  notproduct(bool, PrintFieldLayout, false,                                 \\\n+  develop(bool, PrintFieldLayout, false,                                    \\\n@@ -876,1 +875,1 @@\n-  notproduct(bool, TraceInvocationCounterOverflow, false,                   \\\n+  develop(bool, TraceInvocationCounterOverflow, false,                      \\\n@@ -1020,1 +1019,1 @@\n-  notproduct(bool, PrintFlagsWithComments, false,                           \\\n+  develop(bool, PrintFlagsWithComments, false,                              \\\n@@ -1070,1 +1069,1 @@\n-  notproduct(bool, PrintSymbolTableSizeHistogram, false,                    \\\n+  develop(bool, PrintSymbolTableSizeHistogram, false,                       \\\n@@ -1096,1 +1095,1 @@\n-  notproduct(bool, TraceLivenessQuery, false,                               \\\n+  develop(bool, TraceLivenessQuery, false,                                  \\\n@@ -1099,1 +1098,1 @@\n-  notproduct(bool, CollectIndexSetStatistics, false,                        \\\n+  develop(bool, CollectIndexSetStatistics, false,                           \\\n@@ -1129,1 +1128,1 @@\n-  notproduct(bool, ICMissHistogram, false,                                  \\\n+  develop(bool, ICMissHistogram, false,                                     \\\n@@ -1155,1 +1154,1 @@\n-  notproduct(bool, TraceOnStackReplacement, false,                          \\\n+  develop(bool, TraceOnStackReplacement, false,                             \\\n@@ -1213,1 +1212,1 @@\n-  notproduct(bool, CrashGCForDumpingJavaThread, false,                      \\\n+  develop(bool, CrashGCForDumpingJavaThread, false,                         \\\n@@ -1309,1 +1308,1 @@\n-  notproduct(int, MaxElementPrintSize, 256,                                 \\\n+  develop(int, MaxElementPrintSize, 256,                                    \\\n@@ -1312,1 +1311,1 @@\n-  notproduct(intx, MaxSubklassPrintSize, 4,                                 \\\n+  develop(intx, MaxSubklassPrintSize, 4,                                    \\\n@@ -1326,1 +1325,1 @@\n-  notproduct(intx, DeoptimizeALotInterval,     5,                           \\\n+  develop(intx, DeoptimizeALotInterval,     5,                              \\\n@@ -1329,1 +1328,1 @@\n-  notproduct(intx, ZombieALotInterval,     5,                               \\\n+  develop(intx, ZombieALotInterval,     5,                                  \\\n@@ -1562,1 +1561,1 @@\n-  notproduct(bool, ExitOnFullCodeCache, false,                              \\\n+  develop(bool, ExitOnFullCodeCache, false,                                 \\\n@@ -1711,1 +1710,1 @@\n-  notproduct(bool, UseDebuggerErgo, false,                                  \\\n+  develop(bool, UseDebuggerErgo, false,                                     \\\n@@ -1715,1 +1714,1 @@\n-  notproduct(bool, UseDebuggerErgo1, false,                                 \\\n+  develop(bool, UseDebuggerErgo1, false,                                    \\\n@@ -1719,1 +1718,1 @@\n-  notproduct(bool, UseDebuggerErgo2, false,                                 \\\n+  develop(bool, UseDebuggerErgo2, false,                                    \\\n@@ -1722,1 +1721,1 @@\n-  notproduct(bool, EnableJVMTIStackDepthAsserts, true,                      \\\n+  develop(bool, EnableJVMTIStackDepthAsserts, true,                         \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-            DEFINE_FLAG_MEMBER_ENUM,\n@@ -67,1 +66,0 @@\n-          IGNORE_FLAG,               \/\/ not-product : is not declared\n@@ -75,1 +73,0 @@\n-          DEFINE_FLAG_MEMBER_SETTER,\n","filename":"src\/hotspot\/share\/runtime\/globals_extension.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,0 @@\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, ...)   const type name = value;\n@@ -81,1 +80,0 @@\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, ...)   extern \"C\" type name;\n@@ -89,1 +87,0 @@\n-               DECLARE_NOTPRODUCT_FLAG,   \\\n@@ -96,1 +93,0 @@\n-               DECLARE_NOTPRODUCT_FLAG,   \\\n","filename":"src\/hotspot\/share\/runtime\/globals_shared.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -432,1 +432,0 @@\n-  _Stalled(0),\n@@ -1294,2 +1293,2 @@\n-        address pc = fst.current()->pc();\n-        nmethod* nm =  (nmethod*) fst.current()->cb();\n+        address    pc = fst.current()->pc();\n+        nmethod*   nm = fst.current()->cb()->as_nmethod();\n@@ -1337,0 +1336,1 @@\n+      assert(nm != nullptr, \"did not find nmethod\");\n@@ -1385,1 +1385,1 @@\n-void JavaThread::oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf) {\n+void JavaThread::oops_do_no_frames(OopClosure* f, NMethodClosure* cf) {\n@@ -1443,1 +1443,1 @@\n-void JavaThread::oops_do_frames(OopClosure* f, CodeBlobClosure* cf) {\n+void JavaThread::oops_do_frames(OopClosure* f, NMethodClosure* cf) {\n@@ -1462,1 +1462,1 @@\n-void JavaThread::nmethods_do(CodeBlobClosure* cf) {\n+void JavaThread::nmethods_do(NMethodClosure* cf) {\n@@ -1469,1 +1469,1 @@\n-      fst.current()->nmethods_do(cf);\n+      fst.current()->nmethod_do(cf);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  CompiledMethod*       _deopt_nmethod;         \/\/ CompiledMethod that is currently being deoptimized\n+  nmethod*      _deopt_nmethod;                  \/\/ nmethod that is currently being deoptimized\n@@ -161,2 +161,0 @@\n-  volatile intptr_t _Stalled;\n-\n@@ -691,2 +689,2 @@\n-  void set_deopt_compiled_method(CompiledMethod* nm)  { _deopt_nmethod = nm; }\n-  CompiledMethod* deopt_compiled_method()        { return _deopt_nmethod; }\n+  void set_deopt_compiled_method(nmethod* nm)    { _deopt_nmethod = nm; }\n+  nmethod* deopt_compiled_method()               { return _deopt_nmethod; }\n@@ -896,2 +894,2 @@\n-  void oops_do_frames(OopClosure* f, CodeBlobClosure* cf);\n-  void oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf);\n+  void oops_do_frames(OopClosure* f, NMethodClosure* cf);\n+  void oops_do_no_frames(OopClosure* f, NMethodClosure* cf);\n@@ -900,1 +898,1 @@\n-  virtual void nmethods_do(CodeBlobClosure* cf);\n+  virtual void nmethods_do(NMethodClosure* cf);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -98,0 +100,7 @@\n+\n+    if (log_is_enabled(Debug, monitorinflation)) {\n+      \/\/ The VMThread calls do_final_audit_and_print_stats() which calls\n+      \/\/ audit_and_print_stats() at the Info level at VM exit time.\n+      LogStreamHandle(Debug, monitorinflation) ls;\n+      ObjectSynchronizer::audit_and_print_stats(&ls, false \/* on_exit *\/);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-Mutex*   CompiledMethod_lock          = nullptr;\n+Mutex*   NMethodState_lock            = nullptr;\n@@ -330,1 +330,1 @@\n-  MUTEX_DEFL(CompiledMethod_lock            , PaddedMutex  , CodeCache_lock);\n+  MUTEX_DEFL(NMethodState_lock              , PaddedMutex  , CodeCache_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-extern Mutex*   CompiledMethod_lock;             \/\/ a lock used to guard a compiled method and OSR queues\n+extern Mutex*   NMethodState_lock;               \/\/ a lock used to guard a compiled method state\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,1 +272,0 @@\n-  _Spinner(0),\n@@ -404,2 +403,0 @@\n-  assert(current->_Stalled == 0, \"invariant\");\n-  current->_Stalled = intptr_t(this);\n@@ -419,1 +416,0 @@\n-    current->_Stalled = 0;\n@@ -440,1 +436,0 @@\n-    current->_Stalled = 0;\n@@ -503,1 +498,0 @@\n-  current->_Stalled = 0;\n@@ -1514,2 +1508,0 @@\n-  assert(current->_Stalled == 0, \"invariant\");\n-  current->_Stalled = intptr_t(this);\n@@ -1649,3 +1641,0 @@\n-    assert(current->_Stalled != 0, \"invariant\");\n-    current->_Stalled = 0;\n-\n@@ -2193,1 +2182,0 @@\n-\/\/   _Spinner = 0\n@@ -2223,1 +2211,0 @@\n-  st->print_cr(\"  _Spinner = %d\", _Spinner);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -178,1 +178,0 @@\n-  volatile int _Spinner;            \/\/ for exit->spinner handoff optimization\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1259,1 +1259,1 @@\n-    Klass* k = CompressedKlassPointers::decode_raw(narrow_klass);\n+    Klass* k = CompressedKlassPointers::decode_without_asserts(narrow_klass);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-    return Universe::typeArrayKlassObj(type);\n+    return Universe::typeArrayKlass(type);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -513,1 +513,0 @@\n-  bool _do_lazy_roots;\n@@ -534,3 +533,1 @@\n-    _subtasks(SafepointSynchronize::SAFEPOINT_CLEANUP_NUM_TASKS),\n-    _do_lazy_roots(!VMThread::vm_operation()->skip_thread_oop_barriers() &&\n-                   Universe::heap()->uses_stack_watermark_barrier()) {}\n+    _subtasks(SafepointSynchronize::SAFEPOINT_CLEANUP_NUM_TASKS) {}\n@@ -541,4 +538,0 @@\n-    if (_do_lazy_roots) {\n-      workers++;\n-    }\n-\n@@ -549,14 +542,0 @@\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_LAZY_ROOT_PROCESSING)) {\n-      if (_do_lazy_roots) {\n-        Tracer t(\"lazy partial thread root processing\");\n-        class LazyRootClosure : public ThreadClosure {\n-        public:\n-          void do_thread(Thread* thread) {\n-            StackWatermarkSet::start_processing(JavaThread::cast(thread), StackWatermarkKind::gc);\n-          }\n-        };\n-        LazyRootClosure cl;\n-        Threads::java_threads_do(&cl);\n-      }\n-    }\n-\n@@ -591,6 +570,0 @@\n-\n-  if (log_is_enabled(Debug, monitorinflation)) {\n-    \/\/ The VMThread calls do_final_audit_and_print_stats() which calls\n-    \/\/ audit_and_print_stats() at the Info level at VM exit time.\n-    ObjectSynchronizer::audit_and_print_stats(false \/* on_exit *\/);\n-  }\n@@ -874,2 +847,2 @@\n-  assert(cb != nullptr && cb->is_compiled(), \"return address should be in nmethod\");\n-  CompiledMethod* nm = (CompiledMethod*)cb;\n+  assert(cb != nullptr && cb->is_nmethod(), \"return address should be in nmethod\");\n+  nmethod* nm = cb->as_nmethod();\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":3,"deletions":30,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-    SAFEPOINT_CLEANUP_LAZY_ROOT_PROCESSING,\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-void ServiceThread::oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf) {\n+void ServiceThread::oops_do_no_frames(OopClosure* f, NMethodClosure* cf) {\n@@ -223,1 +223,1 @@\n-void ServiceThread::nmethods_do(CodeBlobClosure* cf) {\n+void ServiceThread::nmethods_do(NMethodClosure* cf) {\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-  void oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf);\n-  void nmethods_do(CodeBlobClosure* cf);\n+  void oops_do_no_frames(OopClosure* f, NMethodClosure* cf);\n+  void nmethods_do(NMethodClosure* cf);\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"code\/compiledMethod.inline.hpp\"\n+#include \"code\/nmethod.inline.hpp\"\n@@ -488,1 +488,1 @@\n-  CompiledMethod* nm = (blob != nullptr) ? blob->as_compiled_method_or_null() : nullptr;\n+  nmethod* nm = (blob != nullptr) ? blob->as_nmethod_or_null() : nullptr;\n@@ -561,1 +561,1 @@\n-  guarantee(cb != nullptr && cb->is_compiled(), \"safepoint polling: pc must refer to an nmethod\");\n+  guarantee(cb != nullptr && cb->is_nmethod(), \"safepoint polling: pc must refer to an nmethod\");\n@@ -564,1 +564,1 @@\n-  assert(((CompiledMethod*)cb)->is_at_poll_or_poll_return(pc),\n+  assert(cb->as_nmethod()->is_at_poll_or_poll_return(pc),\n@@ -575,2 +575,2 @@\n-  bool at_poll_return = ((CompiledMethod*)cb)->is_at_poll_return(pc);\n-  bool has_wide_vectors = ((CompiledMethod*)cb)->has_wide_vectors();\n+  bool at_poll_return = cb->as_nmethod()->is_at_poll_return(pc);\n+  bool has_wide_vectors = cb->as_nmethod()->has_wide_vectors();\n@@ -686,1 +686,1 @@\n-address SharedRuntime::compute_compiled_exc_handler(CompiledMethod* cm, address ret_pc, Handle& exception,\n+address SharedRuntime::compute_compiled_exc_handler(nmethod* nm, address ret_pc, Handle& exception,\n@@ -688,1 +688,1 @@\n-  assert(cm != nullptr, \"must exist\");\n+  assert(nm != nullptr, \"must exist\");\n@@ -692,1 +692,1 @@\n-  if (cm->is_compiled_by_jvmci()) {\n+  if (nm->is_compiled_by_jvmci()) {\n@@ -694,2 +694,2 @@\n-    int catch_pco = pointer_delta_as_int(ret_pc, cm->code_begin());\n-    ExceptionHandlerTable table(cm);\n+    int catch_pco = pointer_delta_as_int(ret_pc, nm->code_begin());\n+    ExceptionHandlerTable table(nm);\n@@ -698,1 +698,1 @@\n-      return cm->code_begin() + t->pco();\n+      return nm->code_begin() + t->pco();\n@@ -700,1 +700,1 @@\n-      return Deoptimization::deoptimize_for_missing_exception_handler(cm);\n+      return Deoptimization::deoptimize_for_missing_exception_handler(nm);\n@@ -705,1 +705,0 @@\n-  nmethod* nm = cm->as_nmethod();\n@@ -916,1 +915,1 @@\n-          if (!cb->is_compiled()) {\n+          if (!cb->is_nmethod()) {\n@@ -928,2 +927,2 @@\n-          CompiledMethod* cm = (CompiledMethod*)cb;\n-          if (cm->inlinecache_check_contains(pc)) {\n+          nmethod* nm = cb->as_nmethod();\n+          if (nm->inlinecache_check_contains(pc)) {\n@@ -938,1 +937,1 @@\n-          if (cm->method()->is_method_handle_intrinsic()) {\n+          if (nm->method()->is_method_handle_intrinsic()) {\n@@ -947,1 +946,1 @@\n-          target_pc = cm->continuation_for_implicit_null_exception(pc);\n+          target_pc = nm->continuation_for_implicit_null_exception(pc);\n@@ -958,2 +957,2 @@\n-        CompiledMethod* cm = CodeCache::find_compiled(pc);\n-        guarantee(cm != nullptr, \"must have containing compiled method for implicit division-by-zero exceptions\");\n+        nmethod* nm = CodeCache::find_nmethod(pc);\n+        guarantee(nm != nullptr, \"must have containing compiled method for implicit division-by-zero exceptions\");\n@@ -963,1 +962,1 @@\n-        target_pc = cm->continuation_for_implicit_div0_exception(pc);\n+        target_pc = nm->continuation_for_implicit_div0_exception(pc);\n@@ -1112,1 +1111,1 @@\n-  CompiledMethod* caller = vfst.nm();\n+  nmethod* caller = vfst.nm();\n@@ -1298,2 +1297,2 @@\n-  guarantee(caller_cb != nullptr && caller_cb->is_compiled(), \"must be called from compiled method\");\n-  CompiledMethod* caller_nm = caller_cb->as_compiled_method();\n+  guarantee(caller_cb != nullptr && caller_cb->is_nmethod(), \"must be called from compiled method\");\n+  nmethod* caller_nm = caller_cb->as_nmethod();\n@@ -1509,2 +1508,2 @@\n-      enter_special = caller.cb() != nullptr && caller.cb()->is_compiled()\n-        && caller.cb()->as_compiled_method()->method()->is_continuation_enter_intrinsic();\n+      enter_special = caller.cb() != nullptr && caller.cb()->is_nmethod()\n+        && caller.cb()->as_nmethod()->method()->is_continuation_enter_intrinsic();\n@@ -1606,1 +1605,1 @@\n-  CompiledMethod* caller_nm = cb->as_compiled_method();\n+  nmethod* caller_nm = cb->as_nmethod();\n@@ -1637,1 +1636,1 @@\n-      (caller.is_native_frame() && ((CompiledMethod*)caller.cb())->method()->is_continuation_enter_intrinsic())) {\n+      (caller.is_native_frame() && caller.cb()->as_nmethod()->method()->is_continuation_enter_intrinsic())) {\n@@ -1641,1 +1640,2 @@\n-    CompiledMethod* caller_nm = CodeCache::find_compiled(pc);\n+    nmethod* caller_nm = CodeCache::find_nmethod(pc);\n+    assert(caller_nm != nullptr, \"did not find caller nmethod\");\n@@ -1769,1 +1769,1 @@\n-  CompiledMethod* callee = method->code();\n+  nmethod* callee = method->code();\n@@ -1778,1 +1778,1 @@\n-  if (cb == nullptr || !cb->is_compiled() || !callee->is_in_use() || callee->is_unloading()) {\n+  if (cb == nullptr || !cb->is_nmethod() || !callee->is_in_use() || callee->is_unloading()) {\n@@ -1782,2 +1782,2 @@\n-  \/\/ The check above makes sure this is a nmethod.\n-  CompiledMethod* caller = cb->as_compiled_method();\n+  \/\/ The check above makes sure this is an nmethod.\n+  nmethod* caller = cb->as_nmethod();\n@@ -2784,1 +2784,1 @@\n-          MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+          MutexLocker pl(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n@@ -2790,1 +2790,1 @@\n-        DirectiveSet* directive = DirectivesStack::getDefaultDirective(CompileBroker::compiler(CompLevel_simple));\n+        DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, CompileBroker::compiler(CompLevel_simple));\n@@ -3046,1 +3046,1 @@\n-  CompiledMethod* nm = nullptr;\n+  nmethod* nm = nullptr;\n@@ -3069,2 +3069,2 @@\n-      if (cb != nullptr && cb->is_compiled()) {\n-        nm = cb->as_compiled_method();\n+      if (cb != nullptr && cb->is_nmethod()) {\n+        nm = cb->as_nmethod();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-  static address compute_compiled_exc_handler(CompiledMethod* nm, address ret_pc, Handle& exception,\n+  static address compute_compiled_exc_handler(nmethod* nm, address ret_pc, Handle& exception,\n@@ -331,1 +331,1 @@\n-  static bool handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm, const frame& caller_frame,\n+  static bool handle_ic_miss_helper_internal(Handle receiver, nmethod* caller_nm, const frame& caller_frame,\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,2 @@\n-\/* Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +114,1 @@\n-  return cb() != nullptr && _cb->is_compiled();\n+  return cb() != nullptr && _cb->is_nmethod();\n@@ -191,3 +192,3 @@\n-  assert(cb()->is_compiled(), \"\");\n-  assert(cb()->as_compiled_method()->method() != nullptr, \"\");\n-  return (cb()->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  assert(cb()->is_nmethod(), \"\");\n+  assert(cb()->as_nmethod()->method() != nullptr, \"\");\n+  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n@@ -268,1 +269,1 @@\n-  assert(!is_compiled() || !cb()->as_compiled_method()->is_deopt_pc(pc), \"\");\n+  assert(!is_compiled() || !cb()->as_nmethod()->is_deopt_pc(pc), \"\");\n@@ -320,3 +321,3 @@\n-  CompiledMethod* cm = cb()->as_compiled_method();\n-  if (cm->is_deopt_pc(pc1)) {\n-    pc1 = *(address*)((address)unextended_sp() + cm->orig_pc_offset());\n+  nmethod* nm = cb()->as_nmethod();\n+  if (nm->is_deopt_pc(pc1)) {\n+    pc1 = *(address*)((address)unextended_sp() + nm->orig_pc_offset());\n@@ -326,1 +327,1 @@\n-  assert(!cm->is_deopt_pc(pc1), \"\");\n+  assert(!nm->is_deopt_pc(pc1), \"\");\n@@ -347,1 +348,1 @@\n-    if (cb()->as_compiled_method()->is_deopt_pc(pc1)) {\n+    if (cb()->as_nmethod()->is_deopt_pc(pc1)) {\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -251,2 +251,3 @@\n-    Handle ov = ((ObjectValue *)sv)->value();\n-    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n+    ObjectValue* ov = (ObjectValue *)sv;\n+    Handle hdl = ov->value();\n+    return new StackValue(hdl, hdl.is_null() && ov->is_scalar_replaced() ? 1 : 0);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -121,1 +124,0 @@\n-  assert(!jt->is_terminated(), \"Poll after termination is a bug\");\n@@ -161,0 +163,10 @@\n+\n+void StackWatermarkSet::safepoint_synchronize_begin() {\n+  if (VMThread::vm_operation()->skip_thread_oop_barriers()) {\n+    return;\n+  }\n+\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n+    StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+\n+  \/\/ We are synchronizing a safepoint, so we might want to ensure processing has at least\n+  \/\/ started, as safepoint operations sometimes assume that is the case\n+  static void safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-      while (mark.is_neutral()) {\n+      while (mark.is_unlocked()) {\n@@ -628,1 +628,1 @@\n-      if (mark.is_neutral()) {\n+      if (mark.is_unlocked()) {\n@@ -699,1 +699,1 @@\n-          assert(!mark.is_neutral(), \"invariant\");\n+          assert(!mark.is_unlocked(), \"invariant\");\n@@ -1012,1 +1012,1 @@\n-    if (mark.is_neutral() || (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked())) {\n+    if (mark.is_unlocked() || (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked())) {\n@@ -1142,1 +1142,1 @@\n-  assert(mark.is_neutral(), \"sanity check\");\n+  assert(mark.is_unlocked(), \"sanity check\");\n@@ -1175,1 +1175,1 @@\n-  \/\/ assert(mark.is_neutral(), \"sanity check\");\n+  \/\/ assert(mark.is_unlocked(), \"sanity check\");\n@@ -1426,1 +1426,1 @@\n-    \/\/ *  neutral      - Aggressively inflate the object.\n+    \/\/ *  unlocked     - Aggressively inflate the object.\n@@ -1604,1 +1604,1 @@\n-    \/\/ CASE: neutral\n+    \/\/ CASE: unlocked\n@@ -1613,3 +1613,1 @@\n-    \/\/ Catch if the object's header is not neutral (not locked and\n-    \/\/ not marked is what we care about here).\n-    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n@@ -1638,1 +1636,1 @@\n-      lsh.print_cr(\"inflate(neutral): object=\" INTPTR_FORMAT \", mark=\"\n+      lsh.print_cr(\"inflate(unlocked): object=\" INTPTR_FORMAT \", mark=\"\n@@ -1953,3 +1951,2 @@\n-    \/\/ The other audit_and_print_stats() call is done at the Debug\n-    \/\/ level at a safepoint in SafepointSynchronize::do_cleanup_tasks.\n-    audit_and_print_stats(true \/* on_exit *\/);\n+    LogStreamHandle(Info, monitorinflation) ls;\n+    audit_and_print_stats(&ls, true \/* on_exit *\/);\n@@ -1959,5 +1956,3 @@\n-\/\/ This function can be called at a safepoint or it can be called when\n-\/\/ we are trying to exit the VM. When we are trying to exit the VM, the\n-\/\/ list walker functions can run in parallel with the other list\n-\/\/ operations so spin-locking is used for safety.\n-\/\/\n+\/\/ This function can be called by the MonitorDeflationThread or it can be called when\n+\/\/ we are trying to exit the VM. The list walker functions can run in parallel with\n+\/\/ the other list operations.\n@@ -1965,3 +1960,1 @@\n-\/\/ aid; pass 'true' for the 'on_exit' parameter to have in-use monitor\n-\/\/ details logged at the Info level and 'false' for the 'on_exit'\n-\/\/ parameter to have in-use monitor details logged at the Trace level.\n+\/\/ aid.\n@@ -1969,16 +1962,1 @@\n-void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {\n-  assert(on_exit || SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-\n-  LogStreamHandle(Debug, monitorinflation) lsh_debug;\n-  LogStreamHandle(Info, monitorinflation) lsh_info;\n-  LogStreamHandle(Trace, monitorinflation) lsh_trace;\n-  LogStream* ls = nullptr;\n-  if (log_is_enabled(Trace, monitorinflation)) {\n-    ls = &lsh_trace;\n-  } else if (log_is_enabled(Debug, monitorinflation)) {\n-    ls = &lsh_debug;\n-  } else if (log_is_enabled(Info, monitorinflation)) {\n-    ls = &lsh_info;\n-  }\n-  assert(ls != nullptr, \"sanity check\");\n-\n+void ObjectSynchronizer::audit_and_print_stats(outputStream* ls, bool on_exit) {\n@@ -1996,6 +1974,8 @@\n-  if ((on_exit && log_is_enabled(Info, monitorinflation)) ||\n-      (!on_exit && log_is_enabled(Trace, monitorinflation))) {\n-    \/\/ When exiting this log output is at the Info level. When called\n-    \/\/ at a safepoint, this log output is at the Trace level since\n-    \/\/ there can be a lot of it.\n-    log_in_use_monitor_details(ls, !on_exit \/* log_all *\/);\n+  \/\/ When exiting, only log the interesting entries at the Info level.\n+  \/\/ When called at intervals by the MonitorDeflationThread, log output\n+  \/\/ at the Trace level since there can be a lot of it.\n+  if (!on_exit && log_is_enabled(Trace, monitorinflation)) {\n+    LogStreamHandle(Trace, monitorinflation) ls_tr;\n+    log_in_use_monitor_details(&ls_tr, true \/* log_all *\/);\n+  } else if (on_exit) {\n+    log_in_use_monitor_details(ls, false \/* log_all *\/);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":25,"deletions":45,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  static void audit_and_print_stats(bool on_exit);\n+  static void audit_and_print_stats(outputStream* out, bool on_exit);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -402,1 +402,1 @@\n-void Thread::oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf) {\n+void Thread::oops_do_no_frames(OopClosure* f, NMethodClosure* cf) {\n@@ -432,1 +432,1 @@\n-void Thread::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+void Thread::oops_do(OopClosure* f, NMethodClosure* cf) {\n@@ -494,0 +494,2 @@\n+      \/\/ Use raw field members for stack base\/size as this could be\n+      \/\/ called before a thread has run enough to initialize them.\n@@ -495,2 +497,2 @@\n-                osthread()->thread_id(), p2i(stack_end()), p2i(stack_base()),\n-                PROPERFMTARGS(stack_size()));\n+                osthread()->thread_id(), p2i(_stack_base - _stack_size), p2i(_stack_base),\n+                PROPERFMTARGS(_stack_size));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+class NMethodClosure;\n@@ -52,0 +53,1 @@\n+class OopClosure;\n@@ -61,2 +63,0 @@\n-class OopClosure;\n-class CodeBlobClosure;\n@@ -446,4 +446,4 @@\n-  \/\/ Apply \"cf->do_code_blob\" (if !nullptr) to all code blobs active in frames\n-  virtual void oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf);\n-  virtual void oops_do_frames(OopClosure* f, CodeBlobClosure* cf) {}\n-  void oops_do(OopClosure* f, CodeBlobClosure* cf);\n+  \/\/ Apply \"cf->do_nmethod\" (if !nullptr) to all nmethods active in frames\n+  virtual void oops_do_no_frames(OopClosure* f, NMethodClosure* cf);\n+  virtual void oops_do_frames(OopClosure* f, NMethodClosure* cf) {}\n+  void oops_do(OopClosure* f, NMethodClosure* cf);\n@@ -660,0 +660,1 @@\n+  bool _saved_in_asgct;\n@@ -663,1 +664,2 @@\n-    assert(!thread->in_asgct(), \"invariant\");\n+    \/\/ Allow AsyncGetCallTrace to be reentrant - save the previous state.\n+    _saved_in_asgct = thread->in_asgct();\n@@ -668,1 +670,1 @@\n-    _thread->set_in_asgct(false);\n+    _thread->set_in_asgct(_saved_in_asgct);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1021,1 +1021,1 @@\n-  Events::log(p, \"Thread added: \" INTPTR_FORMAT, p2i(p));\n+  Events::log(Thread::current(), \"Thread added: \" INTPTR_FORMAT, p2i(p));\n@@ -1084,1 +1084,1 @@\n-  Events::log(p, \"Thread exited: \" INTPTR_FORMAT, p2i(p));\n+  Events::log(Thread::current(), \"Thread exited: \" INTPTR_FORMAT, p2i(p));\n@@ -1094,1 +1094,1 @@\n-void Threads::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+void Threads::oops_do(OopClosure* f, NMethodClosure* cf) {\n@@ -1151,1 +1151,1 @@\n-  CodeBlobClosure* _cf;\n+  NMethodClosure* _cf;\n@@ -1153,1 +1153,1 @@\n-  ParallelOopsDoThreadClosure(OopClosure* f, CodeBlobClosure* cf) : _f(f), _cf(cf) {}\n+  ParallelOopsDoThreadClosure(OopClosure* f, NMethodClosure* cf) : _f(f), _cf(cf) {}\n@@ -1159,1 +1159,1 @@\n-void Threads::possibly_parallel_oops_do(bool is_par, OopClosure* f, CodeBlobClosure* cf) {\n+void Threads::possibly_parallel_oops_do(bool is_par, OopClosure* f, NMethodClosure* cf) {\n@@ -1339,4 +1339,1 @@\n-  cl.do_thread(VMThread::vm_thread());\n-  Universe::heap()->gc_threads_do(&cl);\n-  cl.do_thread(WatcherThread::watcher_thread());\n-  cl.do_thread(AsyncLogWriter::instance());\n+  non_java_threads_do(&cl);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+class MetadataClosure;\n+class OopClosure;\n@@ -41,4 +43,0 @@\n-class CodeBlobClosure;\n-class MetadataClosure;\n-class OopClosure;\n-\n@@ -109,1 +107,1 @@\n-  static void oops_do(OopClosure* f, CodeBlobClosure* cf);\n+  static void oops_do(OopClosure* f, NMethodClosure* cf);\n@@ -111,1 +109,1 @@\n-  static void possibly_parallel_oops_do(bool is_par, OopClosure* f, CodeBlobClosure* cf);\n+  static void possibly_parallel_oops_do(bool is_par, OopClosure* f, NMethodClosure* cf);\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,2 @@\n-    if (cb->is_compiled()) {\n-      CompiledMethod* nm = (CompiledMethod*)cb;\n+    if (cb->is_nmethod()) {\n+      nmethod* nm = cb->as_nmethod();\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,4 +295,4 @@\n-  CodeBlob*         cb()         const { return _frame.cb();  }\n-  CompiledMethod*   nm()         const {\n-      assert( cb() != nullptr && cb()->is_compiled(), \"usage\");\n-      return (CompiledMethod*) cb();\n+  CodeBlob* cb() const { return _frame.cb();  }\n+  nmethod*  nm() const {\n+    assert(cb() != nullptr, \"usage\");\n+    return cb()->as_nmethod();\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-  if (cb() != nullptr && cb()->is_compiled()) {\n+  if (cb() != nullptr && cb()->is_nmethod()) {\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,1 +245,1 @@\n-    CompiledMethod* nm = code();\n+    nmethod* nm = code();\n@@ -302,1 +302,1 @@\n-compiledVFrame::compiledVFrame(const frame* fr, const RegisterMap* reg_map, JavaThread* thread, CompiledMethod* nm)\n+compiledVFrame::compiledVFrame(const frame* fr, const RegisterMap* reg_map, JavaThread* thread, nmethod* nm)\n@@ -308,1 +308,1 @@\n-  if (!nm->is_compiled() || !nm->as_compiled_method()->is_native_method()) {\n+  if (!nm->is_native_method()) {\n@@ -336,2 +336,2 @@\n-CompiledMethod* compiledVFrame::code() const {\n-  return CodeCache::find_compiled(_fr.pc());\n+nmethod* compiledVFrame::code() const {\n+  return CodeCache::find_nmethod(_fr.pc());\n@@ -344,1 +344,1 @@\n-    nmethod* nm = code()->as_nmethod();\n+    nmethod* nm = code();\n@@ -361,1 +361,1 @@\n-    nmethod* nm = code()->as_nmethod();\n+    nmethod* nm = code();\n@@ -371,1 +371,1 @@\n-    nmethod* nm = code()->as_nmethod();\n+    nmethod* nm = code();\n@@ -381,1 +381,1 @@\n-    assert(code()->as_nmethod()->is_native_method(), \"must be native\");\n+    assert(code()->is_native_method(), \"must be native\");\n@@ -390,1 +390,1 @@\n-    assert(code()->as_nmethod()->is_native_method(), \"must be native\");\n+    assert(code()->is_native_method(), \"must be native\");\n@@ -400,1 +400,1 @@\n-    nmethod* nm = code()->as_nmethod();\n+    nmethod* nm = code();\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-  compiledVFrame(const frame* fr, const RegisterMap* reg_map, JavaThread* thread, CompiledMethod* nm);\n+  compiledVFrame(const frame* fr, const RegisterMap* reg_map, JavaThread* thread, nmethod* nm);\n@@ -80,1 +80,1 @@\n-  CompiledMethod*  code() const;\n+  nmethod*  code() const;\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-  template(HeapDumpMerge)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -256,1 +256,0 @@\n-  volatile_nonstatic_field(InstanceKlass,      _methods_jmethod_ids,                          jmethodID*)                            \\\n@@ -310,1 +309,1 @@\n-  volatile_nonstatic_field(Method,             _code,                                         CompiledMethod*)                       \\\n+  volatile_nonstatic_field(Method,             _code,                                         nmethod*)                              \\\n@@ -552,11 +551,11 @@\n-  nonstatic_field(CodeBlob,                 _name,                                   const char*)                                    \\\n-  nonstatic_field(CodeBlob,                 _size,                                   int)                                            \\\n-  nonstatic_field(CodeBlob,                 _header_size,                            int)                                            \\\n-  nonstatic_field(CodeBlob,                 _frame_complete_offset,                  int)                                            \\\n-  nonstatic_field(CodeBlob,                 _data_offset,                            int)                                            \\\n-  nonstatic_field(CodeBlob,                 _frame_size,                             int)                                            \\\n-  nonstatic_field(CodeBlob,                 _oop_maps,                               ImmutableOopMapSet*)                            \\\n-  nonstatic_field(CodeBlob,                 _code_begin,                             address)                                        \\\n-  nonstatic_field(CodeBlob,                 _code_end,                               address)                                        \\\n-  nonstatic_field(CodeBlob,                 _content_begin,                          address)                                        \\\n-  nonstatic_field(CodeBlob,                 _data_end,                               address)                                        \\\n+  nonstatic_field(CodeBlob,                    _name,                                         const char*)                           \\\n+  nonstatic_field(CodeBlob,                    _size,                                         int)                                   \\\n+  nonstatic_field(CodeBlob,                    _header_size,                                  int)                                   \\\n+  nonstatic_field(CodeBlob,                    _relocation_size,                              int)                                   \\\n+  nonstatic_field(CodeBlob,                    _content_offset,                               int)                                   \\\n+  nonstatic_field(CodeBlob,                    _code_offset,                                  int)                                   \\\n+  nonstatic_field(CodeBlob,                    _frame_complete_offset,                        int)                                   \\\n+  nonstatic_field(CodeBlob,                    _data_offset,                                  int)                                   \\\n+  nonstatic_field(CodeBlob,                    _frame_size,                                   int)                                   \\\n+  nonstatic_field(CodeBlob,                    _oop_maps,                                     ImmutableOopMapSet*)                   \\\n+  nonstatic_field(CodeBlob,                    _caller_must_gc_arguments,                     bool)                                  \\\n@@ -566,12 +565,0 @@\n-  nonstatic_field(RuntimeStub,                 _caller_must_gc_arguments,                     bool)                                  \\\n-                                                                                                                                     \\\n-  \/********************************************************\/                                                                         \\\n-  \/* CompiledMethod (NOTE: incomplete, but only a little) *\/                                                                         \\\n-  \/********************************************************\/                                                                         \\\n-                                                                                                                                     \\\n-  nonstatic_field(CompiledMethod,                     _method,                                       Method*)                        \\\n-  volatile_nonstatic_field(CompiledMethod,            _exception_cache,                              ExceptionCache*)                \\\n-  nonstatic_field(CompiledMethod,                     _scopes_data_begin,                            address)                        \\\n-  nonstatic_field(CompiledMethod,                     _deopt_handler_begin,                          address)                        \\\n-  nonstatic_field(CompiledMethod,                     _deopt_mh_handler_begin,                       address)                        \\\n-                                                                                                                                     \\\n@@ -582,0 +569,1 @@\n+  nonstatic_field(nmethod,                     _method,                                       Method*)                               \\\n@@ -586,0 +574,2 @@\n+  nonstatic_field(nmethod,                     _deopt_handler_offset,                         int)                                   \\\n+  nonstatic_field(nmethod,                     _deopt_mh_handler_offset,                      int)                                   \\\n@@ -591,0 +581,1 @@\n+  nonstatic_field(nmethod,                     _scopes_data_offset,                           int)                                   \\\n@@ -601,0 +592,1 @@\n+  volatile_nonstatic_field(nmethod,            _exception_cache,                              ExceptionCache*)                       \\\n@@ -1314,2 +1306,1 @@\n-  declare_type(CompiledMethod,           CodeBlob)                        \\\n-  declare_type(nmethod,                  CompiledMethod)                  \\\n+  declare_type(nmethod,                  CodeBlob)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":18,"deletions":27,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2169,14 +2169,0 @@\n-\/\/ The VM operation wraps DumpMerger so that it could be performed by VM thread\n-class VM_HeapDumpMerge : public VM_Operation {\n-private:\n-  DumpMerger* _merger;\n-public:\n-  VM_HeapDumpMerge(DumpMerger* merger) : _merger(merger) {}\n-  VMOp_Type type() const { return VMOp_HeapDumpMerge; }\n-  \/\/ heap dump merge could happen outside safepoint\n-  virtual bool evaluate_at_safepoint() const { return false; }\n-  void doit() {\n-    _merger->do_merge();\n-  }\n-};\n-\n@@ -2662,11 +2648,4 @@\n-  Thread* current_thread = Thread::current();\n-  if (current_thread->is_AttachListener_thread()) {\n-    \/\/ perform heapdump file merge operation in the current thread prevents us\n-    \/\/ from occupying the VM Thread, which in turn affects the occurrence of\n-    \/\/ GC and other VM operations.\n-    merger.do_merge();\n-  } else {\n-    \/\/ otherwise, performs it by VM thread\n-    VM_HeapDumpMerge op(&merger);\n-    VMThread::execute(&op);\n-  }\n+  \/\/ Perform heapdump file merge operation in the current thread prevents us\n+  \/\/ from occupying the VM Thread, which in turn affects the occurrence of\n+  \/\/ GC and other VM operations.\n+  merger.do_merge();\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1436,1 +1436,1 @@\n-    \/\/ Exclude notproduct and develop flags in product builds.\n+    \/\/ Exclude develop flags in product builds.\n@@ -1593,1 +1593,1 @@\n-      \/\/ Exclude notproduct and develop flags in product builds.\n+      \/\/ Exclude develop flags in product builds.\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include <inttypes.h>\n@@ -38,0 +39,1 @@\n+#include <stdint.h>\n@@ -52,1 +54,0 @@\n-#include <inttypes.h>\n@@ -82,22 +83,0 @@\n-#if !defined(LINUX) && !defined(_ALLBSD_SOURCE)\n-\/\/ Compiler-specific primitive types\n-typedef unsigned short     uint16_t;\n-#ifndef _UINT32_T\n-#define _UINT32_T\n-typedef unsigned int       uint32_t;\n-#endif \/\/ _UINT32_T\n-\n-#if !defined(_SYS_INT_TYPES_H)\n-#ifndef _UINT64_T\n-#define _UINT64_T\n-typedef unsigned long long uint64_t;\n-#endif \/\/ _UINT64_T\n-\/\/ %%%% how to access definition of intptr_t portably in 5.5 onward?\n-typedef int                     intptr_t;\n-typedef unsigned int            uintptr_t;\n-\/\/ If this gets an error, figure out a symbol XXX that implies the\n-\/\/ prior definition of intptr_t, and add \"&& !defined(XXX)\" above.\n-#endif \/\/ _SYS_INT_TYPES_H\n-\n-#endif \/\/ !LINUX && !_ALLBSD_SOURCE\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-  GrowableArrayView<E>(E* data, int capacity, int initial_len) :\n+  GrowableArrayView(E* data, int capacity, int initial_len) :\n@@ -126,1 +126,1 @@\n-  bool operator==(const GrowableArrayView<E>& rhs) const {\n+  bool operator==(const GrowableArrayView& rhs) const {\n@@ -137,1 +137,1 @@\n-  bool operator!=(const GrowableArrayView<E>& rhs) const {\n+  bool operator!=(const GrowableArrayView& rhs) const {\n@@ -354,1 +354,1 @@\n-  GrowableArrayFromArray<E>(E* data, int len) :\n+  GrowableArrayFromArray(E* data, int len) :\n@@ -489,1 +489,1 @@\n-  void swap(GrowableArrayWithAllocator<E, Derived>* other) {\n+  void swap(GrowableArrayWithAllocator* other) {\n@@ -691,2 +691,2 @@\n-class GrowableArray : public GrowableArrayWithAllocator<E, GrowableArray<E> > {\n-  friend class GrowableArrayWithAllocator<E, GrowableArray<E> >;\n+class GrowableArray : public GrowableArrayWithAllocator<E, GrowableArray<E>> {\n+  friend class GrowableArrayWithAllocator<E, GrowableArray>;\n@@ -740,1 +740,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+      GrowableArrayWithAllocator<E, GrowableArray>(\n@@ -748,1 +748,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+      GrowableArrayWithAllocator<E, GrowableArray>(\n@@ -756,1 +756,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+      GrowableArrayWithAllocator<E, GrowableArray>(\n@@ -764,1 +764,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+      GrowableArrayWithAllocator<E, GrowableArray>(\n@@ -772,1 +772,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+      GrowableArrayWithAllocator<E, GrowableArray>(\n@@ -855,2 +855,2 @@\n-  GrowableArrayIterator<E>& operator++() { ++_position; return *this; }\n-  E operator*()                          { return _array->at(_position); }\n+  GrowableArrayIterator& operator++() { ++_position; return *this; }\n+  E operator*()                       { return _array->at(_position); }\n@@ -858,1 +858,1 @@\n-  bool operator==(const GrowableArrayIterator<E>& rhs)  {\n+  bool operator==(const GrowableArrayIterator& rhs)  {\n@@ -863,1 +863,1 @@\n-  bool operator!=(const GrowableArrayIterator<E>& rhs)  {\n+  bool operator!=(const GrowableArrayIterator& rhs)  {\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,2 @@\n-     * behaves in exactly the same way as the invocation\n+     * when {@code csq} is not {@code null}, behaves in exactly the same way\n+     * as the invocation\n","filename":"src\/java.base\/share\/classes\/java\/io\/CharArrayWriter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1447,1 +1447,2 @@\n-     * behaves in exactly the same way as the invocation\n+     * when {@code csq} is not {@code null}, behaves in exactly the same way\n+     * as the invocation\n@@ -1455,1 +1456,1 @@\n-     * appended.  For instance, invoking then {@code toString} method of a\n+     * appended.  For instance, invoking the {@code toString} method of a\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintStream.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1290,1 +1290,2 @@\n-     * behaves in exactly the same way as the invocation\n+     * when {@code csq} is not {@code null}, behaves in exactly the same way\n+     * as the invocation\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintWriter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,2 @@\n-     * behaves in exactly the same way as the invocation\n+     * when {@code csq} is not {@code null}, behaves in exactly the same way\n+     * as the invocation\n","filename":"src\/java.base\/share\/classes\/java\/io\/StringWriter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -341,1 +341,2 @@\n-     * behaves in exactly the same way as the invocation\n+     * when {@code csq} is not {@code null}, behaves in exactly the same way\n+     * as the invocation\n@@ -372,1 +373,0 @@\n-     * {@code Appendable}.\n","filename":"src\/java.base\/share\/classes\/java\/io\/Writer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -818,4 +818,0 @@\n-     * <p> To interpret localized string representations of a\n-     * floating-point value, use subclasses of {@link\n-     * java.text.NumberFormat}.\n-     *\n@@ -892,0 +888,10 @@\n+     * @apiNote To interpret localized string representations of a\n+     * floating-point value, or string representations that have\n+     * non-ASCII digits, use {@link java.text.NumberFormat}. For\n+     * example,\n+     * {@snippet lang=\"java\" :\n+     *     NumberFormat.getInstance(l).parse(s).doubleValue();\n+     * }\n+     * where {@code l} is the desired locale, or\n+     * {@link java.util.Locale#ROOT} if locale insensitive.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -492,4 +492,0 @@\n-     * <p>To interpret localized string representations of a\n-     * floating-point value, use subclasses of {@link\n-     * java.text.NumberFormat}.\n-     *\n@@ -519,0 +515,10 @@\n+     * @apiNote To interpret localized string representations of a\n+     * floating-point value, or string representations that have\n+     * non-ASCII digits, use {@link java.text.NumberFormat}. For\n+     * example,\n+     * {@snippet lang=\"java\" :\n+     *     NumberFormat.getInstance(l).parse(s).floatValue();\n+     * }\n+     * where {@code l} is the desired locale, or\n+     * {@link java.util.Locale#ROOT} if locale insensitive.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1338,1 +1338,7 @@\n-        byte[] dst = new byte[sl * 3];\n+        \/\/ UTF-8 encoded can be as much as 3 times the string length\n+        \/\/ For very large estimate, (as in overflow of 32 bit int), precompute the exact size\n+        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val, doReplace) : sl * 3;\n+        if (allocLen > (long)Integer.MAX_VALUE) {\n+            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n+        }\n+        byte[] dst = new byte[(int) allocLen];\n@@ -1388,0 +1394,41 @@\n+    \/**\n+     * {@return the exact size required to UTF_8 encode this UTF16 string}\n+     * @param val UTF16 encoded byte array\n+     * @param doReplace true to replace unmappable characters\n+     *\/\n+    private static long computeSizeUTF8_UTF16(byte[] val, boolean doReplace) {\n+        long dp = 0L;\n+        int sp = 0;\n+        int sl = val.length >> 1;\n+\n+        while (sp < sl) {\n+            char c = StringUTF16.getChar(val, sp++);\n+            if (c < 0x80) {\n+                dp++;\n+            } else if (c < 0x800) {\n+                dp += 2;\n+            } else if (Character.isSurrogate(c)) {\n+                int uc = -1;\n+                char c2;\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n+                    uc = Character.toCodePoint(c, c2);\n+                }\n+                if (uc < 0) {\n+                    if (doReplace) {\n+                        dp++;\n+                    } else {\n+                        throwUnmappable(sp - 1);\n+                    }\n+                } else {\n+                    dp += 4;\n+                    sp++;  \/\/ 2 chars\n+                }\n+            } else {\n+                \/\/ 3 bytes, 16 bits\n+                dp += 3;\n+            }\n+        }\n+        return dp;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-     * Default is {@code FAIL_ON_DEAD_LABELS} to throw IllegalStateException\n+     * Default is {@code FAIL_ON_DEAD_LABELS} to throw IllegalArgumentException\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -648,1 +648,1 @@\n-    IFNONNULL(ClassFile.IFNONNULL, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFNONNULL(ClassFile.IFNONNULL, 3, Kind.BRANCH, TypeKind.ReferenceType),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Opcode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,6 +177,2 @@\n- *   <li>{@link java.lang.classfile.ClassFile.StackMapsOption}\n- * -- generate stackmaps (default is {@code STACK_MAPS_WHEN_REQUIRED})<\/li>\n- *   <li>{@link java.lang.classfile.ClassFile.DebugElementsOption}\n- * -- processing of debug information, such as local variable metadata (default is {@code PASS_DEBUG}) <\/li>\n- *   <li>{@link java.lang.classfile.ClassFile.LineNumbersOption}\n- * -- processing of line numbers (default is {@code PASS_LINE_NUMBERS}) <\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.AttributeMapperOption#of(java.util.function.Function)}\n+ * -- specify format of custom attributes<\/li>\n@@ -185,2 +181,0 @@\n- *   <li>{@link java.lang.classfile.ClassFile.ConstantPoolSharingOption}}\n- * -- share constant pool when transforming (default is {@code SHARED_POOL})<\/li>\n@@ -189,2 +183,14 @@\n- *   <li>{@link java.lang.classfile.ClassFile.AttributeMapperOption#of(java.util.function.Function)}\n- * -- specify format of custom attributes<\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.ConstantPoolSharingOption}}\n+ * -- share constant pool when transforming (default is {@code SHARED_POOL})<\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.DeadCodeOption}}\n+ * -- patch out unreachable code (default is {@code PATCH_DEAD_CODE})<\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.DeadLabelsOption}}\n+ * -- filter unresolved labels (default is {@code FAIL_ON_DEAD_LABELS})<\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.DebugElementsOption}\n+ * -- processing of debug information, such as local variable metadata (default is {@code PASS_DEBUG}) <\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.LineNumbersOption}\n+ * -- processing of line numbers (default is {@code PASS_LINE_NUMBERS}) <\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.ShortJumpsOption}\n+ * -- automatically rewrite short jumps to long when necessary (default is {@code FIX_SHORT_JUMPS})<\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.StackMapsOption}\n+ * -- generate stackmaps (default is {@code STACK_MAPS_WHEN_REQUIRED})<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,2 +85,2 @@\n-     * Note the exponent range of decimal32 is <em>not<\/em> used for\n-     * rounding.\n+     * Note the exponent range of decimal32 (min exponent of -95, max\n+     * exponent of 96) is <em>not<\/em> used for rounding.\n@@ -95,2 +95,2 @@\n-     * Note the exponent range of decimal64 is <em>not<\/em> used for\n-     * rounding.\n+     * Note the exponent range of decimal64 (min exponent of -383, max\n+     * exponent of 384) is <em>not<\/em> used for rounding.\n@@ -105,2 +105,2 @@\n-     * Note the exponent range of decimal64 is <em>not<\/em> used for\n-     * rounding.\n+     * Note the exponent range of decimal128 (min exponent of -6143,\n+     * max exponent of 6144) is <em>not<\/em> used for rounding.\n","filename":"src\/java.base\/share\/classes\/java\/math\/MathContext.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,3 +143,4 @@\n-     * If the application has specified a server socket implementation\n-     * factory, that factory's {@code createSocketImpl} method is called to\n-     * create the actual socket implementation. Otherwise a system-default\n+     * If the application has specified a {@linkplain SocketImplFactory server\n+     * socket implementation factory}, that factory's\n+     * {@linkplain SocketImplFactory#createSocketImpl() createSocketImpl} method\n+     * is called to create the actual socket implementation. Otherwise a system-default\n@@ -166,1 +167,0 @@\n-     * @see        java.net.SocketImpl\n@@ -186,3 +186,4 @@\n-     * If the application has specified a server socket implementation\n-     * factory, that factory's {@code createSocketImpl} method is called to\n-     * create the actual socket implementation. Otherwise a system-default\n+     * If the application has specified a {@linkplain SocketImplFactory server\n+     * socket implementation factory}, that factory's\n+     * {@linkplain SocketImplFactory#createSocketImpl() createSocketImpl} method\n+     * is called to create the actual socket implementation. Otherwise a system-default\n@@ -217,1 +218,0 @@\n-     * @see        java.net.SocketImpl\n@@ -264,2 +264,0 @@\n-     * @see SocketOptions\n-     * @see SocketImpl\n@@ -804,1 +802,1 @@\n-     * a <B>java.net.SocketTimeoutException<\/B> is raised, though the\n+     * a {@link java.net.SocketTimeoutException} is raised, though the\n@@ -846,1 +844,1 @@\n-     * Enable\/disable the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\n+     * Enable\/disable the {@link StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR}\n@@ -858,3 +856,3 @@\n-     * Enabling {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} prior to\n-     * binding the socket using {@link #bind(SocketAddress)} allows the socket\n-     * to be bound even though a previous connection is in a timeout state.\n+     * Enabling {@code SO_REUSEADDR} prior to binding the socket using\n+     * {@link #bind(SocketAddress)} allows the socket to be bound even\n+     * though a previous connection is in a timeout state.\n@@ -863,3 +861,3 @@\n-     * of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is not defined.\n-     * Applications can use {@link #getReuseAddress()} to determine the initial\n-     * setting of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}.\n+     * of {@code SO_REUSEADDR} is not defined. Applications can use\n+     * {@link #getReuseAddress()} to determine the initial\n+     * setting of {@code SO_REUSEADDR}.\n@@ -867,2 +865,2 @@\n-     * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is\n-     * enabled or disabled after a socket is bound (See {@link #isBound()})\n+     * The behaviour when {@code SO_REUSEADDR} is enabled or disabled\n+     * after a socket is bound (See {@link #isBound()})\n@@ -873,1 +871,1 @@\n-     *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\n+     *            disabling the {@code SO_REUSEADDR}\n@@ -888,1 +886,1 @@\n-     * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.\n+     * Tests if {@link StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.\n@@ -891,1 +889,1 @@\n-     *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.\n+     *         {@code SO_REUSEADDR} is enabled.\n@@ -984,1 +982,1 @@\n-     * {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option for sockets\n+     * {@link StandardSocketOptions#SO_RCVBUF SO_RCVBUF} option for sockets\n@@ -990,2 +988,2 @@\n-     * The value of {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is used both to\n-     * set the size of the internal socket receive buffer, and to set the size\n+     * The value of {@code SO_RCVBUF} is used both to set the size of\n+     * the internal socket receive buffer, and to set the size\n@@ -1027,1 +1025,1 @@\n-     * Gets the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option\n+     * Gets the value of the {@link StandardSocketOptions#SO_RCVBUF SO_RCVBUF} option\n@@ -1033,2 +1031,1 @@\n-     * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}\n-     *         option for this {@code Socket}.\n+     * @return the value of the {@code SO_RCVBUF} option for this {@code Socket}.\n","filename":"src\/java.base\/share\/classes\/java\/net\/ServerSocket.java","additions":27,"deletions":30,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,4 +175,5 @@\n-     * If the application has specified a client socket implementation\n-     * factory, that factory's {@code createSocketImpl} method is called to\n-     * create the actual socket implementation. Otherwise a system-default\n-     * socket implementation is created.\n+     * If the application has specified a {@linkplain SocketImplFactory client\n+     * socket implementation factory}, that factory's\n+     * {@linkplain SocketImplFactory#createSocketImpl() createSocketImpl}\n+     * method is called to create the actual socket implementation. Otherwise\n+     * a system-default socket implementation is created.\n@@ -298,4 +299,5 @@\n-     * If the application has specified a client socket implementation\n-     * factory, that factory's {@code createSocketImpl} method is called to\n-     * create the actual socket implementation. Otherwise a system-default\n-     * socket implementation is created.\n+     * If the application has specified a {@linkplain SocketImplFactory client\n+     * socket implementation factory}, that factory's\n+     * {@linkplain SocketImplFactory#createSocketImpl() createSocketImpl}\n+     * method is called to create the actual socket implementation. Otherwise\n+     * a system-default socket implementation is created.\n@@ -320,1 +322,0 @@\n-     * @see        java.net.SocketImpl\n@@ -336,4 +337,5 @@\n-     * If the application has specified a client socket implementation\n-     * factory, that factory's {@code createSocketImpl} method is called to\n-     * create the actual socket implementation. Otherwise a system-default\n-     * socket implementation is created.\n+     * If the application has specified a {@linkplain SocketImplFactory client\n+     * socket implementation factory}, that factory's\n+     * {@linkplain SocketImplFactory#createSocketImpl() createSocketImpl}\n+     * method is called to create the actual socket implementation. Otherwise\n+     * a system-default socket implementation is created.\n@@ -355,1 +357,0 @@\n-     * @see        java.net.SocketImpl\n@@ -464,4 +465,5 @@\n-     * If the application has specified a client socket implementation\n-     * factory, that factory's {@code createSocketImpl} method is called to\n-     * create the actual socket implementation. Otherwise a system-default\n-     * socket implementation is created.\n+     * If the application has specified a {@linkplain SocketImplFactory client\n+     * socket implementation factory}, that factory's\n+     * {@linkplain SocketImplFactory#createSocketImpl() createSocketImpl}\n+     * method is called to create the actual socket implementation. Otherwise\n+     * a system-default socket implementation is created.\n@@ -486,1 +488,0 @@\n-     * @see        java.net.SocketImpl\n@@ -506,4 +507,5 @@\n-     * If the application has specified a client socket implementation\n-     * factory, that factory's {@code createSocketImpl} method is called to\n-     * create the actual socket implementation. Otherwise a system-default\n-     * socket implementation is created.\n+     * If the application has specified a {@linkplain SocketImplFactory client\n+     * socket implementation factory}, that factory's\n+     * {@linkplain SocketImplFactory#createSocketImpl() createSocketImpl}\n+     * method is called to create the actual socket implementation. Otherwise\n+     * a system-default socket implementation is created.\n@@ -529,1 +531,0 @@\n-     * @see        java.net.SocketImpl\n@@ -1247,1 +1248,1 @@\n-     * Enable\/disable {@link SocketOptions#TCP_NODELAY TCP_NODELAY}\n+     * Enable\/disable {@link StandardSocketOptions#TCP_NODELAY TCP_NODELAY}\n@@ -1250,1 +1251,1 @@\n-     * @param on {@code true} to enable TCP_NODELAY,\n+     * @param on {@code true} to enable {@code TCP_NODELAY},\n@@ -1267,1 +1268,1 @@\n-     * Tests if {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.\n+     * Tests if {@link StandardSocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.\n@@ -1270,1 +1271,1 @@\n-     *         {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.\n+     *         {@code TCP_NODELAY} is enabled.\n@@ -1283,1 +1284,1 @@\n-     * Enable\/disable {@link SocketOptions#SO_LINGER SO_LINGER} with the\n+     * Enable\/disable {@link StandardSocketOptions#SO_LINGER SO_LINGER} with the\n@@ -1313,1 +1314,1 @@\n-     * Returns setting for {@link SocketOptions#SO_LINGER SO_LINGER}.\n+     * Returns setting for {@link StandardSocketOptions#SO_LINGER SO_LINGER}.\n@@ -1319,1 +1320,1 @@\n-     * @return the setting for {@link SocketOptions#SO_LINGER SO_LINGER}.\n+     * @return the setting for {@code SO_LINGER}.\n@@ -1367,2 +1368,1 @@\n-     * @param on {@code true} to enable\n-     *           {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE},\n+     * @param on {@code true} to enable {@code SO_OOBINLINE},\n@@ -1388,1 +1388,1 @@\n-     *         {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.\n+     *         {@code SO_OOBINLINE} is enabled.\n@@ -1430,1 +1430,1 @@\n-     * @return the setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}\n+     * @return the setting for {@code SO_TIMEOUT}\n@@ -1450,1 +1450,1 @@\n-     * Sets the {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option to the\n+     * Sets the {@link StandardSocketOptions#SO_SNDBUF SO_SNDBUF} option to the\n@@ -1452,3 +1452,2 @@\n-     * The {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option is used by the\n-     * platform's networking code as a hint for the size to set the underlying\n-     * network I\/O buffers.\n+     * The {@code SO_SNDBUF} option is used by the platform's networking code\n+     * as a hint for the size to set the underlying network I\/O buffers.\n@@ -1456,3 +1455,2 @@\n-     * <p>Because {@link SocketOptions#SO_SNDBUF SO_SNDBUF} is a hint,\n-     * applications that want to verify what size the buffers were set to\n-     * should call {@link #getSendBufferSize()}.\n+     * <p>Because {@code SO_SNDBUF} is a hint, applications that want to verify\n+     * what size the buffers were set to should call {@link #getSendBufferSize()}.\n@@ -1481,1 +1479,1 @@\n-     * Get value of the {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option\n+     * Get value of the {@link StandardSocketOptions#SO_SNDBUF SO_SNDBUF} option\n@@ -1484,2 +1482,1 @@\n-     * @return the value of the {@link SocketOptions#SO_SNDBUF SO_SNDBUF}\n-     *         option for this {@code Socket}.\n+     * @return the value of the {@code SO_SNDBUF} option for this {@code Socket}.\n@@ -1505,1 +1502,1 @@\n-     * Sets the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option to the\n+     * Sets the {@link StandardSocketOptions#SO_RCVBUF SO_RCVBUF} option to the\n@@ -1507,3 +1504,2 @@\n-     * {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option is\n-     * used by the platform's networking code as a hint for the size to set\n-     * the underlying network I\/O buffers.\n+     * {@code SO_RCVBUF} option is used by the platform's networking code\n+     * as a hint for the size to set the underlying network I\/O buffers.\n@@ -1515,3 +1511,2 @@\n-     * <p>Because {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is a hint,\n-     * applications that want to verify what size the buffers were set to\n-     * should call {@link #getReceiveBufferSize()}.\n+     * <p>Because {@code SO_RCVBUF} is a hint, applications that want to verify\n+     * what size the buffers were set to should call {@link #getReceiveBufferSize()}.\n@@ -1519,2 +1514,2 @@\n-     * <p>The value of {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is also used\n-     * to set the TCP receive window that is advertised to the remote peer.\n+     * <p>The value of {@code SO_RCVBUF} is also used to set the TCP receive window\n+     * that is advertised to the remote peer.\n@@ -1553,1 +1548,1 @@\n-     * Gets the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option\n+     * Gets the value of the {@link StandardSocketOptions#SO_RCVBUF SO_RCVBUF} option\n@@ -1557,2 +1552,1 @@\n-     * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}\n-     *         option for this {@code Socket}.\n+     * @return the value of the {@code SO_RCVBUF} option for this {@code Socket}.\n@@ -1576,1 +1570,1 @@\n-     * Enable\/disable {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE}.\n+     * Enable\/disable {@link StandardSocketOptions#SO_KEEPALIVE SO_KEEPALIVE}.\n@@ -1591,1 +1585,1 @@\n-     * Tests if {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.\n+     * Tests if {@link StandardSocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.\n@@ -1594,1 +1588,1 @@\n-     *         {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.\n+     *         {@code SO_KEEPALIVE} is enabled.\n@@ -1650,1 +1644,1 @@\n-     * @see SocketOptions#IP_TOS\n+     * @see StandardSocketOptions#IP_TOS\n@@ -1674,1 +1668,1 @@\n-     * @see SocketOptions#IP_TOS\n+     * @see StandardSocketOptions#IP_TOS\n@@ -1681,1 +1675,1 @@\n-     * Enable\/disable the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\n+     * Enable\/disable the {@link StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR}\n@@ -1693,4 +1687,3 @@\n-     * Enabling {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\n-     * prior to binding the socket using {@link #bind(SocketAddress)} allows\n-     * the socket to be bound even though a previous connection is in a timeout\n-     * state.\n+     * Enabling {@code SO_REUSEADDR} prior to binding the socket using\n+     * {@link #bind(SocketAddress)} allows the socket to be bound even\n+     * though a previous connection is in a timeout state.\n@@ -1699,1 +1692,1 @@\n-     * of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is disabled.\n+     * of {@code SO_REUSEADDR} is disabled.\n@@ -1701,3 +1694,2 @@\n-     * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is\n-     * enabled or disabled after a socket is bound (See {@link #isBound()})\n-     * is not defined.\n+     * The behaviour when {@code SO_REUSEADDR} is enabled or disabled after\n+     * a socket is bound (See {@link #isBound()}) is not defined.\n@@ -1707,1 +1699,1 @@\n-     *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\n+     *            disabling the {@code SO_REUSEADDR}\n@@ -1722,1 +1714,1 @@\n-     * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.\n+     * Tests if {@link StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.\n@@ -1725,1 +1717,1 @@\n-     *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.\n+     *         {@code SO_REUSEADDR} is enabled.\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":67,"deletions":75,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,3 @@\n- * implemented by: <B>SocketImpl<\/B> and  <B>DatagramSocketImpl<\/B>.\n- * Subclasses of these should override the methods\n- * of this interface in order to support their own options.\n+ * implemented by {@link SocketImpl} and {@link DatagramSocketImpl}.\n+ * Subclasses of these two classes should override the {@link #getOption(int)} and\n+ * {@link #setOption(int, Object)} methods of this interface in order to support their own options.\n@@ -36,5 +36,5 @@\n- * The methods and constants which specify options in this interface are\n- * for implementation only.  If you're not subclassing SocketImpl or\n- * DatagramSocketImpl, <B>you won't use these directly.<\/B> There are\n- * type-safe methods to get\/set each of these options in Socket, ServerSocket,\n- * DatagramSocket and MulticastSocket.\n+ * The methods and constants defined in this interface are\n+ * for implementation only. If you're not subclassing {@code SocketImpl} or\n+ * {@code DatagramSocketImpl}, then you won't use these directly. There are\n+ * type-safe methods to get\/set each of these options in {@link Socket}, {@link ServerSocket},\n+ *  {@link DatagramSocket} and {@link MulticastSocket}.\n@@ -50,5 +50,5 @@\n-     * Enable\/disable the option specified by <I>optID<\/I>.  If the option\n-     * is to be enabled, and it takes an option-specific \"value\",  this is\n-     * passed in <I>value<\/I>.  The actual type of value is option-specific,\n-     * and it is an error to pass something that isn't of the expected type:\n-     * <BR><PRE>\n+     * Enable\/disable the option specified by {@code optID}. If the option\n+     * is to be enabled, and it takes an option-specific \"value\", this is passed in {@code value}.\n+     * The actual type of {@code value} is option-specific, and it is an error to pass something\n+     * that isn't of the expected type:\n+     * {@snippet lang=java :\n@@ -61,4 +61,3 @@\n-     *<\/PRE>\n-     * If the requested option is binary, it can be set using this method by\n-     * a java.lang.Boolean:\n-     * <BR><PRE>\n+     *}\n+     * If the requested option is binary, it can be set using this method by a {@link Boolean}:\n+     * {@snippet lang=java :\n@@ -67,4 +66,3 @@\n-     * <\/PRE>\n-     * <BR>\n-     * Any option can be disabled using this method with a Boolean.FALSE:\n-     * <BR><PRE>\n+     * }\n+     * Any option can be disabled using this method with a {@link Boolean#FALSE}:\n+     * {@snippet lang=java :\n@@ -75,9 +73,4 @@\n-     * <\/PRE>\n-     * <BR>\n-     * For an option that has a notion of on and off, and requires\n-     * a non-boolean parameter, setting its value to anything other than\n-     * <I>Boolean.FALSE<\/I> implicitly enables it.\n-     * <BR>\n-     * Throws SocketException if the option is unrecognized,\n-     * the socket is closed, or some low-level error occurred\n-     * <BR>\n+     * }\n+     * For an option that has a notion of on and off, and requires a non-boolean parameter, setting\n+     * its value to anything other than {@link Boolean#FALSE} implicitly enables it.\n+     *\n@@ -86,2 +79,2 @@\n-     * @throws SocketException if the option is unrecognized,\n-     *         the socket is closed, or some low-level error occurred\n+     * @throws SocketException if the option is unrecognized, the socket is closed, or some\n+     *                         low-level error occurred\n@@ -90,2 +83,1 @@\n-    public void\n-        setOption(int optID, Object value) throws SocketException;\n+    public void setOption(int optID, Object value) throws SocketException;\n@@ -94,4 +86,3 @@\n-     * Fetch the value of an option.\n-     * Binary options will return java.lang.Boolean.TRUE\n-     * if enabled, java.lang.Boolean.FALSE if disabled, e.g.:\n-     * <BR><PRE>\n+     * Fetch the value of an option. Binary options will return {@link Boolean#TRUE} if enabled,\n+     * {@link Boolean#FALSE} if disabled, e.g.:\n+     * {@snippet lang=java :\n@@ -105,1 +96,1 @@\n-     * <\/PRE>\n+     * }\n@@ -107,4 +98,3 @@\n-     * For options that take a particular type as a parameter,\n-     * getOption(int) will return the parameter's value, else\n-     * it will return java.lang.Boolean.FALSE:\n-     * <PRE>\n+     * For options that take a particular type as a parameter, this method will return the\n+     * parameter's value, else it will return {@link Boolean#FALSE}:\n+     * {@snippet lang=java :\n@@ -117,1 +107,1 @@\n-     * <\/PRE>\n+     * }\n@@ -121,3 +111,2 @@\n-     * @throws SocketException if the socket is closed\n-     * @throws SocketException if <I>optID<\/I> is unknown along the\n-     *         protocol stack (including the SocketImpl)\n+     * @throws SocketException if the socket is closed or if {@code optID} is unknown along the\n+     *                         protocol stack\n@@ -128,3 +117,1 @@\n-    \/**\n-     * The java-supported BSD-style options.\n-     *\/\n+    \/\/ Java supported BSD-style options follow\n@@ -133,5 +120,1 @@\n-     * Disable Nagle's algorithm for this connection.  Written data\n-     * to the network is not buffered pending acknowledgement of\n-     * previously written data.\n-     *<P>\n-     * Valid for TCP only: SocketImpl.\n+     * See {@link StandardSocketOptions#TCP_NODELAY} for description of this socket option.\n@@ -142,1 +125,0 @@\n-\n@@ -146,5 +128,4 @@\n-     * Fetch the local address binding of a socket (this option cannot\n-     * be \"set\" only \"gotten\", since sockets are bound at creation time,\n-     * and so the locally bound address cannot be changed).  The default local\n-     * address of a socket is INADDR_ANY, meaning any local address on a\n-     * multi-homed host.  A multi-homed host can use this option to accept\n+     * Fetch the local address binding of a socket. This option cannot be set and can only be\n+     * fetched. The default local address of a socket is\n+     * {@link InetAddress#isAnyLocalAddress() INADDR_ANY}, meaning any local\n+     * address on a multi-homed host. A multi-homed host can use this option to accept\n@@ -152,7 +133,3 @@\n-     * ServerSocket or DatagramSocket), or to specify its return address\n-     * to the peer (for a Socket or DatagramSocket).  The parameter of\n-     * this option is an InetAddress.\n-     * <P>\n-     * This option <B>must<\/B> be specified in the constructor.\n-     * <P>\n-     * Valid for: SocketImpl, DatagramSocketImpl\n+     * {@link ServerSocket} or {@link DatagramSocket}), or to specify its return address\n+     * to the peer (for a {@link Socket} or {@link DatagramSocket}). The type of this option's\n+     * value is an {@link InetAddress}.\n@@ -163,1 +140,0 @@\n-\n@@ -166,4 +142,2 @@\n-    \/** Sets SO_REUSEADDR for a socket.  This is used only for MulticastSockets\n-     * in java, and it is set by default for MulticastSockets.\n-     * <P>\n-     * Valid for: DatagramSocketImpl\n+    \/**\n+     * See {@link StandardSocketOptions#SO_REUSEADDR} for description of this socket option.\n@@ -171,1 +145,0 @@\n-\n@@ -174,6 +147,2 @@\n-    \/** Sets SO_REUSEPORT for a socket. This option enables and disables\n-     *  the ability to have multiple sockets listen to the same address\n-     *  and port.\n-     * <P>\n-     * Valid for: SocketImpl, DatagramSocketImpl\n-     *\n+    \/**\n+     * See {@link StandardSocketOptions#SO_REUSEPORT} for description of this socket option.\n@@ -181,1 +150,0 @@\n-     * @see StandardSocketOptions#SO_REUSEPORT\n@@ -186,5 +154,1 @@\n-     * Sets SO_BROADCAST for a socket. This option enables and disables\n-     * the ability of the process to send broadcast messages. It is supported\n-     * for only datagram sockets and only on networks that support\n-     * the concept of a broadcast message (e.g. Ethernet, token ring, etc.),\n-     * and it is set by default for DatagramSockets.\n+     * See {@link StandardSocketOptions#SO_BROADCAST} for description of this socket option.\n@@ -193,1 +157,0 @@\n-\n@@ -196,5 +159,2 @@\n-    \/** Set which outgoing interface on which to send multicast packets.\n-     * Useful on hosts with multiple network interfaces, where applications\n-     * want to use other than the system default.  Takes\/returns an InetAddress.\n-     * <P>\n-     * Valid for Multicast: DatagramSocketImpl\n+    \/**\n+     * See {@link StandardSocketOptions#IP_MULTICAST_IF} for description of this socket option.\n@@ -205,1 +165,0 @@\n-\n@@ -208,4 +167,5 @@\n-    \/** Same as above. This option is introduced so that the behaviour\n-     *  with IP_MULTICAST_IF will be kept the same as before, while\n-     *  this new option can support setting outgoing interfaces with either\n-     *  IPv4 and IPv6 addresses.\n+    \/**\n+     * This option is used to both set and fetch the outgoing interface on which the multicast\n+     * packets are sent. Useful on hosts with multiple network interfaces, where applications\n+     * want to use other than the system default. This option supports setting outgoing interfaces\n+     * with either IPv4 and IPv6 addresses.\n@@ -213,1 +173,0 @@\n-     *  NOTE: make sure there is no conflict with this\n@@ -221,2 +180,1 @@\n-     * This option enables or disables local loopback of multicast datagrams.\n-     * This option is enabled by default for Multicast Sockets.\n+     * See {@link StandardSocketOptions#IP_MULTICAST_LOOP} for description of this socket option.\n@@ -225,1 +183,0 @@\n-\n@@ -229,2 +186,1 @@\n-     * This option sets the type-of-service or traffic class field\n-     * in the IP header for a TCP or UDP socket.\n+     * See {@link StandardSocketOptions#IP_TOS} for description of this socket option.\n@@ -233,1 +189,0 @@\n-\n@@ -237,11 +192,1 @@\n-     * Specify a linger-on-close timeout.  This option disables\/enables\n-     * immediate return from a <B>close()<\/B> of a TCP Socket.  Enabling\n-     * this option with a non-zero Integer <I>timeout<\/I> means that a\n-     * <B>close()<\/B> will block pending the transmission and acknowledgement\n-     * of all data written to the peer, at which point the socket is closed\n-     * <I>gracefully<\/I>.  Upon reaching the linger timeout, the socket is\n-     * closed <I>forcefully<\/I>, with a TCP RST. Enabling the option with a\n-     * timeout of zero does a forceful close immediately. If the specified\n-     * timeout value exceeds 65,535 it will be reduced to 65,535.\n-     * <P>\n-     * Valid only for TCP: SocketImpl\n+     * See {@link StandardSocketOptions#SO_LINGER} for description of this socket option.\n@@ -254,12 +199,8 @@\n-    \/** Set a timeout on blocking Socket operations:\n-     * <PRE>\n-     * ServerSocket.accept();\n-     * SocketInputStream.read();\n-     * DatagramSocket.receive();\n-     * <\/PRE>\n-     *\n-     * <P> The option must be set prior to entering a blocking\n-     * operation to take effect.  If the timeout expires and the\n-     * operation would continue to block,\n-     * <B>java.io.InterruptedIOException<\/B> is raised.  The Socket is\n-     * not closed in this case.\n+    \/**\n+     * This option is used to both set and fetch a timeout value on blocking\n+     * {@code Socket} operations:\n+     * <ul>\n+     *     <li>{@linkplain ServerSocket#accept() ServerSocket.accept()}<\/li>\n+     *     <li>{@linkplain Socket#getInputStream()  Socket InputStream.read()}<\/li>\n+     *     <li>{@linkplain DatagramSocket#receive(DatagramPacket) DatagramSocket.receive()}<\/li>\n+     * <\/ul>\n@@ -267,1 +208,5 @@\n-     * <P> Valid for all sockets: SocketImpl, DatagramSocketImpl\n+     * <P>\n+     * This option must be set prior to entering a blocking operation to take effect. If the\n+     * timeout expires and the operation would continue to block, then\n+     * {@link java.io.InterruptedIOException} is raised. The {@code Socket} is not closed\n+     * in such cases.\n@@ -276,8 +221,1 @@\n-     * Set a hint the size of the underlying buffers used by the\n-     * platform for outgoing network I\/O. When used in set, this is a\n-     * suggestion to the kernel from the application about the size of\n-     * buffers to use for the data to be sent over the socket. When\n-     * used in get, this must return the size of the buffer actually\n-     * used by the platform when sending out data on this socket.\n-     *\n-     * Valid for all sockets: SocketImpl, DatagramSocketImpl\n+     * See {@link StandardSocketOptions#SO_SNDBUF} for description of this socket option.\n@@ -293,9 +231,1 @@\n-     * Set a hint the size of the underlying buffers used by the\n-     * platform for incoming network I\/O. When used in set, this is a\n-     * suggestion to the kernel from the application about the size of\n-     * buffers to use for the data to be received over the\n-     * socket. When used in get, this must return the size of the\n-     * buffer actually used by the platform when receiving in data on\n-     * this socket.\n-     *\n-     * Valid for all sockets: SocketImpl, DatagramSocketImpl\n+     * See {@link StandardSocketOptions#SO_RCVBUF} for description of this socket option.\n@@ -311,16 +241,1 @@\n-     * When the keepalive option is set for a TCP socket and no data\n-     * has been exchanged across the socket in either direction for\n-     * 2 hours (NOTE: the actual value is implementation dependent),\n-     * TCP automatically sends a keepalive probe to the peer. This probe is a\n-     * TCP segment to which the peer must respond.\n-     * One of three responses is expected:\n-     * 1. The peer responds with the expected ACK. The application is not\n-     *    notified (since everything is OK). TCP will send another probe\n-     *    following another 2 hours of inactivity.\n-     * 2. The peer responds with an RST, which tells the local TCP that\n-     *    the peer host has crashed and rebooted. The socket is closed.\n-     * 3. There is no response from the peer. The socket is closed.\n-     *\n-     * The purpose of this option is to detect if the peer host crashes.\n-     *\n-     * Valid only for TCP socket: SocketImpl\n+     * See {@link StandardSocketOptions#SO_KEEPALIVE} for description of this socket option.\n@@ -334,4 +249,3 @@\n-     * When the OOBINLINE option is set, any TCP urgent data received on\n-     * the socket will be received through the socket input stream.\n-     * When the option is disabled (which is the default) urgent data\n-     * is silently discarded.\n+     * When this option is set, any TCP urgent data received on the socket will be received\n+     * through the socket input stream. When the option is disabled (which is the default)\n+     * urgent data is silently discarded.\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketOptions.java","additions":80,"deletions":166,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,2 +134,1 @@\n-        List<Service> list = GetInstance.getServices(\"KeyFactory\", algorithm);\n-        serviceIterator = list.iterator();\n+        serviceIterator = GetInstance.getServices(\"KeyFactory\", algorithm);\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyFactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,3 +233,1 @@\n-        List<Service> list =\n-                GetInstance.getServices(\"KeyPairGenerator\", algorithm);\n-        Iterator<Service> t = list.iterator();\n+        Iterator<Service> t = GetInstance.getServices(\"KeyPairGenerator\", algorithm);\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyPairGenerator.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -260,1 +260,1 @@\n-        List<Service> list;\n+        Iterator<Service> t;\n@@ -262,1 +262,1 @@\n-            list = GetInstance.getServices(rsaIds);\n+            t = GetInstance.getServices(rsaIds);\n@@ -264,1 +264,1 @@\n-            list = GetInstance.getServices(\"Signature\", algorithm);\n+            t = GetInstance.getServices(\"Signature\", algorithm);\n@@ -266,1 +266,0 @@\n-        Iterator<Service> t = list.iterator();\n","filename":"src\/java.base\/share\/classes\/java\/security\/Signature.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,0 +164,2 @@\n+     * <tr><th scope=\"row\">1.3.6.1.5.5.7.1.1<\/th>\n+     * <td>AuthorityInformationAccess<\/td><\/tr>\n@@ -168,2 +170,0 @@\n-     * <tr><th scope=\"row\">2.5.29.16<\/th>\n-     * <td>PrivateKeyUsage<\/td><\/tr>\n@@ -178,0 +178,4 @@\n+     * <tr><th scope=\"row\">2.5.29.31<\/th>\n+     * <td>CRLDistributionPoints<\/td><\/tr>\n+     * <tr><th scope=\"row\">2.5.29.32<\/th>\n+     * <td>CertificatePolicies<\/td><\/tr>\n@@ -184,0 +188,2 @@\n+     * <tr><th scope=\"row\">2.5.29.37<\/th>\n+     * <td>ExtendedKeyUsage<\/td><\/tr>\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509Extension.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -261,0 +261,2 @@\n+        @Override public E       removeFirst() { throw uoe(); }\n+        @Override public E       removeLast() { throw uoe(); }\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1143,6 +1143,1 @@\n-            if (sm == null) {\n-                if (isCommon)\n-                    return new ForkJoinWorkerThread.InnocuousForkJoinWorkerThread(pool);\n-                else\n-                    return new ForkJoinWorkerThread(null, pool, true, false);\n-            } else if (isCommon)\n+            if (sm != null && isCommon)\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -542,1 +542,0 @@\n-        List<Service> services = GetInstance.getServices(cipherServices);\n@@ -545,1 +544,1 @@\n-        Iterator<Service> t = services.iterator();\n+        Iterator<Service> t = GetInstance.getServices(cipherServices);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-        List<Service> services = GetInstance.getServices(type, algorithm);\n+        Iterator<Service> t = GetInstance.getServices(type, algorithm);\n@@ -159,1 +159,2 @@\n-        for (Service s : services) {\n+        while (t.hasNext()) {\n+            Service s = t.next();\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/JceSecurity.java.template","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Iterator;\n@@ -540,1 +541,1 @@\n-        List<Provider.Service> list = GetInstance.getServices(\n+        Iterator<Provider.Service> t = GetInstance.getServices(\n@@ -544,1 +545,2 @@\n-        for (Provider.Service s : list) {\n+        while (t.hasNext()) {\n+            Provider.Service s = t.next();\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEM.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,2 +183,0 @@\n-        List<Service> services =\n-                GetInstance.getServices(\"KeyAgreement\", algorithm);\n@@ -186,1 +184,1 @@\n-        Iterator<Service> t = services.iterator();\n+        Iterator<Service> t = GetInstance.getServices(\"KeyAgreement\", algorithm);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KeyAgreement.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,3 +170,1 @@\n-        List<Service> list =\n-                GetInstance.getServices(\"KeyGenerator\", algorithm);\n-        serviceIterator = list.iterator();\n+        serviceIterator = GetInstance.getServices(\"KeyGenerator\", algorithm);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KeyGenerator.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,1 +180,0 @@\n-        List<Service> services = GetInstance.getServices(\"Mac\", algorithm);\n@@ -182,1 +181,1 @@\n-        Iterator<Service> t = services.iterator();\n+        Iterator<Service> t = GetInstance.getServices(\"Mac\", algorithm);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Mac.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,3 +113,1 @@\n-        List<Service> list =\n-                GetInstance.getServices(\"SecretKeyFactory\", algorithm);\n-        serviceIterator = list.iterator();\n+        serviceIterator = GetInstance.getServices(\"SecretKeyFactory\", algorithm);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/SecretKeyFactory.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -863,1 +863,1 @@\n-            return 0;\n+            return constant;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -820,1 +820,2 @@\n-                        case InvokeDynamicInstruction invd -> in.with(leafs(\n+                        case InvokeDynamicInstruction invd -> {\n+                            in.with(leafs(\n@@ -823,4 +824,5 @@\n-                                \"kind\", invd.bootstrapMethod().kind().name(),\n-                                \"owner\", invd.bootstrapMethod().owner().descriptorString(),\n-                                \"method name\", invd.bootstrapMethod().methodName(),\n-                                \"invocation type\", invd.bootstrapMethod().invocationType().descriptorString()));\n+                                \"bootstrap method\", invd.bootstrapMethod().kind().name()\n+                                     + \" \" + Util.toInternalName(invd.bootstrapMethod().owner())\n+                                     + \"::\" + invd.bootstrapMethod().methodName()));\n+                            in.with(list(\"arguments\", \"arg\", invd.bootstrapArgs().stream()));\n+                        }\n@@ -887,1 +889,3 @@\n-                        return map(\"bm\",\n+                        var bmNode = new MapNodeImpl(FLOW, \"bm\");\n+                        bmNode.with(leafs(\n+                                \"index\", bm.bsmIndex(),\n@@ -890,3 +894,4 @@\n-                                \"owner\", mref.owner().name().stringValue(),\n-                                \"name\", mref.nameAndType().name().stringValue(),\n-                                \"type\", mref.nameAndType().type().stringValue());\n+                                \"owner\", mref.owner().asInternalName(),\n+                                \"name\", mref.nameAndType().name().stringValue()));\n+                        bmNode.with(list(\"args\", \"arg\", bm.arguments().stream().map(LoadableConstantEntry::constantValue)));\n+                        return bmNode;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.internal.misc.ThreadTracker;\n@@ -136,0 +137,12 @@\n+    private static class ThreadTrackHolder {\n+        static final ThreadTracker TRACKER = new ThreadTracker();\n+    }\n+\n+    private static Object tryBeginLookup() {\n+        return ThreadTrackHolder.TRACKER.tryBegin();\n+    }\n+\n+    private static void endLookup(Object key) {\n+        ThreadTrackHolder.TRACKER.end(key);\n+    }\n+\n@@ -144,6 +157,13 @@\n-        \/\/ Avoid a bootstrap issue where the commitEvent attempts to\n-        \/\/ trigger early loading of System Logger but where\n-        \/\/ the verification process still has JarFiles locked\n-        if (securityLogger == null && !JUJA.isInitializing()) {\n-            LOGGER_HANDLE.compareAndSet( null, System.getLogger(SECURITY_LOGGER_NAME));\n-            loggingSecurity = securityLogger.isLoggable(LOG_LEVEL);\n+        Object key;\n+        \/\/ Avoid bootstrap issues where\n+        \/\/ * commitEvent triggers early loading of System Logger but where\n+        \/\/   the verification process still has JarFiles locked\n+        \/\/ * the loading of the logging libraries involves recursive\n+        \/\/   calls to security libraries triggering recursion\n+        if (securityLogger == null && !JUJA.isInitializing() && (key = tryBeginLookup()) != null) {\n+            try {\n+                LOGGER_HANDLE.compareAndSet(null, System.getLogger(SECURITY_LOGGER_NAME));\n+                loggingSecurity = securityLogger.isLoggable(LOG_LEVEL);\n+            } finally {\n+                endLookup(key);\n+            }\n@@ -153,1 +173,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/EventHelper.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        @JEP(number=457, title=\"ClassFile API\", status=\"Preview\")\n+        @JEP(number=466, title=\"ClassFile API\", status=\"Second Preview\")\n@@ -84,0 +84,1 @@\n+        LANGUAGE_MODEL,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -125,2 +125,2 @@\n-    private static void debugPrintStackTrace(Throwable throwable) {\n-        if (Boolean.getBoolean(\"jdk.internal.vm.TranslatedException.debug\")) {\n+    private static void debugPrintStackTrace(Throwable throwable, boolean debug) {\n+        if (debug) {\n@@ -132,1 +132,1 @@\n-    private static Throwable initCause(Throwable throwable, Throwable cause) {\n+    private static Throwable initCause(Throwable throwable, Throwable cause, boolean debug) {\n@@ -138,1 +138,1 @@\n-                debugPrintStackTrace(e);\n+                debugPrintStackTrace(e, debug);\n@@ -144,1 +144,1 @@\n-    private static Throwable create(String className, String message, Throwable cause) {\n+    private static Throwable create(String className, String message, Throwable cause, boolean debug) {\n@@ -160,1 +160,1 @@\n-                return initCause((Throwable) cons.newInstance(), cause);\n+                return initCause((Throwable) cons.newInstance(), cause, debug);\n@@ -163,1 +163,1 @@\n-            return initCause((Throwable) cons.newInstance(message), cause);\n+            return initCause((Throwable) cons.newInstance(message), cause, debug);\n@@ -165,2 +165,2 @@\n-            debugPrintStackTrace(translationFailure);\n-            return initCause(new TranslatedException(message, className), cause);\n+            debugPrintStackTrace(translationFailure, debug);\n+            return initCause(new TranslatedException(message, className), cause, debug);\n@@ -256,1 +256,1 @@\n-    static Throwable decodeThrowable(byte[] encodedThrowable) {\n+    static Throwable decodeThrowable(byte[] encodedThrowable, boolean debug) {\n@@ -265,1 +265,1 @@\n-                throwable = create(exceptionClassName, exceptionMessage, cause);\n+                throwable = create(exceptionClassName, exceptionMessage, cause, debug);\n@@ -313,1 +313,1 @@\n-            debugPrintStackTrace(translationFailure);\n+            debugPrintStackTrace(translationFailure, debug);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/TranslatedException.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+     * @param debug specifies whether debug stack traces should be enabled in case of translation failure\n@@ -129,1 +130,1 @@\n-    public static void decodeAndThrowThrowable(int format, long buffer, boolean inJVMHeap) throws Throwable {\n+    public static void decodeAndThrowThrowable(int format, long buffer, boolean inJVMHeap, boolean debug) throws Throwable {\n@@ -145,1 +146,1 @@\n-        throw TranslatedException.decodeThrowable(bufferToBytes(buffer));\n+        throw TranslatedException.decodeThrowable(bufferToBytes(buffer), debug);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -227,0 +227,33 @@\n+\n+    \/**\n+     * Convenience method for fetching System property values that are booleans.\n+     *\n+     * @param prop the name of the System property\n+     * @param def a default value\n+     * @param dbg a Debug object, if null no debug messages will be sent\n+     *\n+     * @return a boolean value corresponding to the value in the System property.\n+     *      If the property value is neither \"true\" or \"false\", the default value\n+     *      will be returned.\n+     *\/\n+    public static boolean privilegedGetBooleanProp(String prop, boolean def, Debug dbg) {\n+        String rawPropVal = privilegedGetProperty(prop, \"\");\n+        if (\"\".equals(rawPropVal)) {\n+            return def;\n+        }\n+\n+        String lower = rawPropVal.toLowerCase(Locale.ROOT);\n+        if (\"true\".equals(lower)) {\n+            return true;\n+        } else if (\"false\".equals(lower)) {\n+            return false;\n+        } else {\n+            if (dbg != null) {\n+                dbg.println(\"Warning: Unexpected value for \" + prop +\n+                            \": \" + rawPropVal +\n+                            \". Using default value: \" + def);\n+            }\n+            return def;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/action\/GetPropertyAction.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import sun.security.util.BitArray;\n@@ -62,1 +63,0 @@\n-    @SuppressWarnings(\"deprecation\")\n@@ -70,1 +70,2 @@\n-        key = ECUtil.encodePoint(w, params.getCurve());\n+        byte[] key = ECUtil.encodePoint(w, params.getCurve());\n+        setKey(new BitArray(key.length * 8, key));\n@@ -95,7 +96,0 @@\n-    \/\/ Internal API to get the encoded point. Currently used by SunPKCS11.\n-    \/\/ This may change\/go away depending on what we do with the public API.\n-    @SuppressWarnings(\"deprecation\")\n-    public byte[] getEncodedPublicValue() {\n-        return key.clone();\n-    }\n-\n@@ -105,1 +99,0 @@\n-    @SuppressWarnings(\"deprecation\")\n@@ -115,1 +108,1 @@\n-            w = ECUtil.decodePoint(key, params.getCurve());\n+            w = ECUtil.decodePoint(getKey().toByteArray(), params.getCurve());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPublicKeyImpl.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,2 +107,2 @@\n-     * Return a List of all the available Services that implement\n-     * (type, algorithm). Note that the list is initialized lazily\n+     * Return an iterator over all the available Services that implement\n+     * (type, algorithm). Note that the iterator is initialized lazily\n@@ -112,1 +112,1 @@\n-    public static List<Service> getServices(String type, String algorithm) {\n+    public static Iterator<Service> getServices(String type, String algorithm) {\n@@ -118,13 +118,1 @@\n-     * This method exists for compatibility with JCE only. It will be removed\n-     * once JCE has been changed to use the replacement method.\n-     * @deprecated use {@code getServices(List<ServiceId>)} instead\n-     *\/\n-    @Deprecated\n-    public static List<Service> getServices(String type,\n-            List<String> algorithms) {\n-        ProviderList list = Providers.getProviderList();\n-        return list.getServices(type, algorithms);\n-    }\n-\n-    \/**\n-     * Return a List of all the available Services that implement any of\n+     * Return an iterator over all the available Services that implement any of\n@@ -133,1 +121,1 @@\n-    public static List<Service> getServices(List<ServiceId> ids) {\n+    public static Iterator<Service> getServices(List<ServiceId> ids) {\n@@ -170,1 +158,3 @@\n-        for (Service s : list.getServices(type, algorithm)) {\n+        Iterator<Service> services = list.getServices(type, algorithm);\n+        while (services.hasNext()) {\n+            Service s = services.next();\n@@ -186,1 +176,1 @@\n-        List<Service> services = getServices(type, algorithm);\n+        Iterator<Service> services = getServices(type, algorithm);\n@@ -188,1 +178,2 @@\n-        for (Service s : services) {\n+        while (services.hasNext()) {\n+            Service s = services.next();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/GetInstance.java","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -394,1 +394,1 @@\n-     * Return a List containing all the Services describing implementations\n+     * Return an iterator over all the Services describing implementations\n@@ -396,1 +396,1 @@\n-     * exists, this method returns an empty List.\n+     * exists, this method returns an empty iterator.\n@@ -398,1 +398,1 @@\n-     * The elements of this list are determined lazily on demand.\n+     * The elements of this iterator are determined lazily on demand.\n@@ -400,1 +400,1 @@\n-     * The List returned is NOT thread safe.\n+     * The iterator returned is NOT thread safe.\n@@ -402,2 +402,2 @@\n-    public List<Service> getServices(String type, String algorithm) {\n-        return new ServiceList(type, algorithm);\n+    public Iterator<Service> getServices(String type, String algorithm) {\n+        return new ServiceIterator(type, algorithm);\n@@ -406,16 +406,2 @@\n-    \/**\n-     * This method exists for compatibility with JCE only. It will be removed\n-     * once JCE has been changed to use the replacement method.\n-     * @deprecated use {@code getServices(List<ServiceId>)} instead\n-     *\/\n-    @Deprecated\n-    public List<Service> getServices(String type, List<String> algorithms) {\n-        List<ServiceId> ids = new ArrayList<>();\n-        for (String alg : algorithms) {\n-            ids.add(new ServiceId(type, alg));\n-        }\n-        return getServices(ids);\n-    }\n-\n-    public List<Service> getServices(List<ServiceId> ids) {\n-        return new ServiceList(ids);\n+    public Iterator<Service> getServices(List<ServiceId> ids) {\n+        return new ServiceIterator(ids);\n@@ -425,1 +411,1 @@\n-     * Inner class for a List of Services. Custom List implementation in\n+     * Inner class for an iterator over Services. Customized implementation in\n@@ -429,1 +415,1 @@\n-    private final class ServiceList extends AbstractList<Service> {\n+    private final class ServiceIterator implements Iterator<Service> {\n@@ -452,1 +438,1 @@\n-        \/\/ Matching preferred provider list for this ServiceList\n+        \/\/ Matching preferred provider list for this ServiceIterator\n@@ -456,1 +442,1 @@\n-        ServiceList(String type, String algorithm) {\n+        ServiceIterator(String type, String algorithm) {\n@@ -462,1 +448,1 @@\n-        ServiceList(List<ServiceId> ids) {\n+        ServiceIterator(List<ServiceId> ids) {\n@@ -537,1 +523,9 @@\n-        public Service get(int index) {\n+        int index;\n+\n+        @Override\n+        public boolean hasNext() {\n+            return tryGet(index) != null;\n+        }\n+\n+        @Override\n+        public Service next() {\n@@ -540,1 +534,1 @@\n-                throw new IndexOutOfBoundsException();\n+                throw new NoSuchElementException();\n@@ -542,0 +536,1 @@\n+            index++;\n@@ -545,41 +540,3 @@\n-        public int size() {\n-            int n;\n-            if (services != null) {\n-                n = services.size();\n-            } else {\n-                n = (firstService != null) ? 1 : 0;\n-            }\n-            while (tryGet(n) != null) {\n-                n++;\n-            }\n-            return n;\n-        }\n-\n-        \/\/ override isEmpty() and iterator() to not call size()\n-        \/\/ this avoids loading + checking all Providers\n-\n-        public boolean isEmpty() {\n-            return (tryGet(0) == null);\n-        }\n-\n-        public Iterator<Service> iterator() {\n-            return new Iterator<>() {\n-                int index;\n-\n-                public boolean hasNext() {\n-                    return tryGet(index) != null;\n-                }\n-\n-                public Service next() {\n-                    Service s = tryGet(index);\n-                    if (s == null) {\n-                        throw new NoSuchElementException();\n-                    }\n-                    index++;\n-                    return s;\n-                }\n-\n-                public void remove() {\n-                    throw new UnsupportedOperationException();\n-                }\n-            };\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n@@ -595,1 +552,1 @@\n-         * ServiceList.\n+         * ServiceIterator.\n@@ -597,1 +554,1 @@\n-        ArrayList<PreferredEntry> getAll(ServiceList s) {\n+        ArrayList<PreferredEntry> getAll(ServiceIterator s) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderList.java","additions":30,"deletions":73,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,2 +104,1 @@\n-            List<DistributionPoint> points =\n-                    ext.getDistributionPoints();\n+            List<DistributionPoint> points = ext.getDistributionPoints();\n@@ -107,0 +106,1 @@\n+            CertStoreException savedCSE = null;\n@@ -109,5 +109,17 @@\n-                DistributionPoint point = t.next();\n-                Collection<X509CRL> crls = getCRLs(selector, certImpl,\n-                    point, reasonsMask, signFlag, prevKey, prevCert, provider,\n-                    certStores, trustAnchors, validity, variant, anchor);\n-                results.addAll(crls);\n+                try {\n+                    DistributionPoint point = t.next();\n+                    Collection<X509CRL> crls = getCRLs(selector, certImpl,\n+                        point, reasonsMask, signFlag, prevKey, prevCert, provider,\n+                        certStores, trustAnchors, validity, variant, anchor);\n+                    results.addAll(crls);\n+                } catch (CertStoreException cse) {\n+                    if (savedCSE == null) {\n+                        savedCSE = cse;\n+                    } else {\n+                        savedCSE.addSuppressed(cse);\n+                    }\n+                }\n+            }\n+            \/\/ only throw CertStoreException if no CRLs are retrieved\n+            if (results.isEmpty() && savedCSE != null) {\n+                throw savedCSE;\n@@ -185,1 +197,5 @@\n-                savedCSE = cse;\n+                if (savedCSE == null) {\n+                    savedCSE = cse;\n+                } else {\n+                    savedCSE.addSuppressed(cse);\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/DistributionPointFetcher.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-            \"com.sun.security.ocsp.useget\", \"true\");\n+            \"com.sun.security.ocsp.useget\", true);\n@@ -124,3 +124,3 @@\n-    private static boolean initializeBoolean(String prop, String def) {\n-        String flag = GetPropertyAction.privilegedGetProperty(prop, def);\n-        boolean value = Boolean.parseBoolean(flag);\n+    private static boolean initializeBoolean(String prop, boolean def) {\n+        boolean value =\n+                GetPropertyAction.privilegedGetBooleanProp(prop, def, debug);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSP.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n@@ -44,0 +47,2 @@\n+    private boolean printDateTime;\n+    private boolean printThreadDetails;\n@@ -46,0 +51,4 @@\n+    private static boolean threadInfoAll;\n+    private static boolean timeStampInfoAll;\n+    private static final String TIMESTAMP_OPTION = \"+timestamp\";\n+    private static final String THREAD_OPTION = \"+thread\";\n@@ -64,0 +73,10 @@\n+            } else if (args.contains(\"all\")) {\n+                \/\/ \"all\" option has special handling for decorator options\n+                \/\/ If the thread or timestamp decorator option is detected\n+                \/\/ with the \"all\" option, then it impacts decorator options\n+                \/\/ for other categories\n+                int beginIndex = args.lastIndexOf(\"all\") + \"all\".length();\n+                int commaIndex = args.indexOf(',', beginIndex);\n+                if (commaIndex == -1) commaIndex = args.length();\n+                threadInfoAll = args.substring(beginIndex, commaIndex).contains(THREAD_OPTION);\n+                timeStampInfoAll = args.substring(beginIndex, commaIndex).contains(TIMESTAMP_OPTION);\n@@ -68,2 +87,1 @@\n-    public static void Help()\n-    {\n+    public static void Help() {\n@@ -98,0 +116,5 @@\n+        System.err.println(\"+timestamp can be appended to any of above options to print\");\n+        System.err.println(\"              a timestamp for that debug option\");\n+        System.err.println(\"+thread can be appended to any of above options to print\");\n+        System.err.println(\"              thread and caller information for that debug option\");\n+        System.err.println();\n@@ -142,2 +165,1 @@\n-    public static Debug getInstance(String option)\n-    {\n+    public static Debug getInstance(String option) {\n@@ -151,2 +173,1 @@\n-    public static Debug getInstance(String option, String prefix)\n-    {\n+    public static Debug getInstance(String option, String prefix) {\n@@ -156,0 +177,1 @@\n+            d.configureExtras(option);\n@@ -162,0 +184,35 @@\n+    private static String formatCaller() {\n+        return StackWalker.getInstance().walk(s ->\n+                s.dropWhile(f ->\n+                    f.getClassName().startsWith(\"sun.security.util.Debug\"))\n+                        .map(f -> f.getFileName() + \":\" + f.getLineNumber())\n+                        .findFirst().orElse(\"unknown caller\"));\n+    }\n+\n+    \/\/ parse an option string to determine if extra details,\n+    \/\/ like thread and timestamp, should be printed\n+    private void configureExtras(String option) {\n+        \/\/ treat \"all\" as special case, only used for java.security.debug property\n+        this.printDateTime = timeStampInfoAll;\n+        this.printThreadDetails = threadInfoAll;\n+\n+        if (printDateTime && printThreadDetails) {\n+            \/\/ nothing left to configure\n+            return;\n+        }\n+\n+        \/\/ args is converted to lower case for the most part via marshal method\n+        int optionIndex = args.lastIndexOf(option);\n+        if (optionIndex == -1) {\n+            \/\/ option not in args list. Only here since \"all\" was present\n+            \/\/ in debug property argument. \"all\" option already parsed\n+            return;\n+        }\n+        int beginIndex = optionIndex + option.length();\n+        int commaIndex = args.indexOf(',', beginIndex);\n+        if (commaIndex == -1) commaIndex = args.length();\n+        String subOpt = args.substring(beginIndex, commaIndex);\n+        printDateTime = printDateTime || subOpt.contains(TIMESTAMP_OPTION);\n+        printThreadDetails = printThreadDetails || subOpt.contains(THREAD_OPTION);\n+    }\n+\n@@ -176,1 +233,7 @@\n-     * @param option the debug option name\n+     *\n+     * +timestamp string can be appended to property value\n+     * to print timestamp information. (e.g. true+timestamp)\n+     * +thread string can be appended to property value\n+     * to print thread and caller information. (e.g. true+thread)\n+     *\n+     * @param prefix the debug option name\n@@ -180,2 +243,2 @@\n-    public static Debug of(String option, String property) {\n-        if (\"true\".equalsIgnoreCase(property)) {\n+    public static Debug of(String prefix, String property) {\n+        if (property != null && property.toLowerCase(Locale.ROOT).startsWith(\"true\")) {\n@@ -183,1 +246,3 @@\n-            d.prefix = option;\n+            d.prefix = prefix;\n+            d.printThreadDetails = property.contains(THREAD_OPTION);\n+            d.printDateTime = property.contains(TIMESTAMP_OPTION);\n@@ -193,2 +258,1 @@\n-    public static boolean isOn(String option)\n-    {\n+    public static boolean isOn(String option) {\n@@ -217,3 +281,2 @@\n-    public void println(String message)\n-    {\n-        System.err.println(prefix + \": \"+message);\n+    public void println(String message) {\n+        System.err.println(prefix + extraInfo() + \": \" + message);\n@@ -226,3 +289,2 @@\n-    public void println(Object obj, String message)\n-    {\n-        System.err.println(prefix + \" [\" + obj.getClass().getSimpleName() +\n+    public void println(Object obj, String message) {\n+        System.err.println(prefix + extraInfo() + \" [\" + obj.getClass().getSimpleName() +\n@@ -236,3 +298,2 @@\n-    public void println()\n-    {\n-        System.err.println(prefix + \":\");\n+    public void println() {\n+        System.err.println(prefix + extraInfo() + \":\");\n@@ -245,3 +306,22 @@\n-    public static void println(String prefix, String message)\n-    {\n-        System.err.println(prefix + \": \"+message);\n+    public void println(String prefix, String message) {\n+        System.err.println(prefix + extraInfo() + \": \" + message);\n+    }\n+\n+    \/**\n+     * If thread debug option enabled, include information containing\n+     * hex value of threadId and the current thread name\n+     * If timestamp debug option enabled, include timestamp string\n+     * @return extra info if debug option enabled.\n+     *\/\n+    private String extraInfo() {\n+        String retString = \"\";\n+        if (printThreadDetails) {\n+            retString = \"0x\" + Long.toHexString(\n+                    Thread.currentThread().threadId()).toUpperCase(Locale.ROOT) +\n+                    \"|\" + Thread.currentThread().getName() + \"|\" + formatCaller();\n+        }\n+        if (printDateTime) {\n+            retString += (retString.isEmpty() ? \"\" : \"|\")\n+                    + FormatHolder.DATE_TIME_FORMATTER.format(Instant.now());\n+        }\n+        return retString.isEmpty() ? \"\" : \"[\" + retString + \"]\";\n@@ -367,0 +447,7 @@\n+    \/\/ Holder class to break cyclic dependency seen during build\n+    private static class FormatHolder {\n+        private static final String PATTERN = \"yyyy-MM-dd kk:mm:ss.SSS\";\n+        private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter\n+                .ofPattern(PATTERN, Locale.ENGLISH)\n+                .withZone(ZoneId.systemDefault());\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":111,"deletions":24,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,18 +68,0 @@\n-    \/**\n-     * The key bytes, without the algorithm information.\n-     * @deprecated Use the BitArray form which does not require keys to\n-     * be byte aligned.\n-     * @see sun.security.x509.X509Key#setKey(BitArray)\n-     * @see sun.security.x509.X509Key#getKey()\n-     *\/\n-    @Deprecated\n-    protected byte[] key = null;\n-\n-    \/*\n-     * The number of bits unused in the last byte of the key.\n-     * Added to keep the byte[] key form consistent with the BitArray\n-     * form. Can de deleted when byte[] key is deleted.\n-     *\/\n-    @Deprecated\n-    private int unusedBits = 0;\n-\n@@ -115,9 +97,0 @@\n-\n-        \/*\n-         * Do this to keep the byte array form consistent with\n-         * this. Can delete when byte[] key is deleted.\n-         *\/\n-        this.key = key.toByteArray();\n-        int remaining = key.length() % 8;\n-        this.unusedBits =\n-            ((remaining == 0) ? 0 : 8 - remaining);\n@@ -131,12 +104,0 @@\n-        \/*\n-         * Do this for consistency in case a subclass\n-         * modifies byte[] key directly. Remove when\n-         * byte[] key is deleted.\n-         * Note: the consistency checks fail when the subclass\n-         * modifies a non byte-aligned key (into a byte-aligned key)\n-         * using the deprecated byte[] key field.\n-         *\/\n-        this.bitStringKey = new BitArray(\n-                          this.key.length * 8 - this.unusedBits,\n-                          this.key);\n-\n@@ -334,1 +295,1 @@\n-            + \", unparsed keybits = \\n\" + encoder.encodeBuffer(key);\n+            + \", unparsed keybits = \\n\" + encoder.encodeBuffer(bitStringKey.toByteArray());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":2,"deletions":41,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -895,1 +895,1 @@\n-#   WeakKeyLimit:\n+#   KeyLimit:\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4311,3 +4311,3 @@\n-When using \\f[V]file=\\f[R]\\f[I]filename\\f[R], specifying \\f[V]%p\\f[R]\n-and\/or \\f[V]%t\\f[R] in the file name expands to the JVM\\[aq]s PID and\n-startup timestamp, respectively.\n+When using \\f[V]file=\\f[R]\\f[I]filename\\f[R], specifying \\f[V]%p\\f[R],\n+\\f[V]%t\\f[R] and\/or \\f[V]%hn\\f[R] in the file name expands to the\n+JVM\\[aq]s PID, startup timestamp and host name, respectively.\n","filename":"src\/java.base\/share\/man\/java.1","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,2 @@\n+     * @see <a href=\"https:\/\/openjdk.org\/jeps\/12\">\n+     * JEP 12: Preview Features<\/a>\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/ProcessingEnvironment.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.lang.model.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import static javax.lang.model.SourceVersion.*;\n+import javax.lang.model.SourceVersion;\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.annotation.processing.ProcessingEnvironment;\n+\n+\/**\n+ * A skeletal visitor for annotation values with default behavior\n+ * appropriate for a {@linkplain\n+ * ProcessingEnvironment#isPreviewEnabled preview} source version.\n+ *\n+ * @param <R> the return type of this visitor's methods\n+ * @param <P> the type of the additional parameter to this visitor's methods.\n+ *\n+ * @see <a href=\"AbstractAnnotationValueVisitor6.html#note_for_subclasses\">\n+ * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see AbstractAnnotationValueVisitor6\n+ * @see AbstractAnnotationValueVisitor7\n+ * @see AbstractAnnotationValueVisitor8\n+ * @see AbstractAnnotationValueVisitor9\n+ * @see AbstractAnnotationValueVisitor14\n+ * @since 23\n+ *\/\n+@SupportedSourceVersion(RELEASE_23)\n+@PreviewFeature(feature=PreviewFeature.Feature.LANGUAGE_MODEL, reflective=true)\n+public abstract class AbstractAnnotationValueVisitorPreview<R, P> extends AbstractAnnotationValueVisitor14<R, P> {\n+\n+    \/**\n+     * Constructor for concrete subclasses to call.\n+     *\/\n+    protected AbstractAnnotationValueVisitorPreview() {\n+        super();\n+    }\n+}\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitorPreview.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.lang.model.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.ElementVisitor;\n+import javax.lang.model.element.RecordComponentElement;\n+import static javax.lang.model.SourceVersion.*;\n+\n+\/**\n+ * A skeletal visitor of program elements with default behavior\n+ * appropriate for a {@linkplain\n+ * ProcessingEnvironment#isPreviewEnabled preview} source version.\n+ *\n+ * @param <R> the return type of this visitor's methods.  Use {@link\n+ *            Void} for visitors that do not need to return results.\n+ * @param <P> the type of the additional parameter to this visitor's\n+ *            methods.  Use {@code Void} for visitors that do not need an\n+ *            additional parameter.\n+ *\n+ * @see <a href=\"AbstractElementVisitor6.html#note_for_subclasses\">\n+ * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see AbstractElementVisitor6\n+ * @see AbstractElementVisitor7\n+ * @see AbstractElementVisitor8\n+ * @see AbstractElementVisitor9\n+ * @see AbstractElementVisitor14\n+ * @since 23\n+ *\/\n+@SupportedSourceVersion(RELEASE_23)\n+@PreviewFeature(feature=PreviewFeature.Feature.LANGUAGE_MODEL, reflective=true)\n+public abstract class AbstractElementVisitorPreview<R, P> extends AbstractElementVisitor14<R, P> {\n+    \/**\n+     * Constructor for concrete subclasses to call.\n+     *\/\n+    protected AbstractElementVisitorPreview(){\n+        super();\n+    }\n+}\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitorPreview.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.lang.model.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.SourceVersion;\n+import static javax.lang.model.SourceVersion.*;\n+\n+\/**\n+ * A skeletal visitor of types with default behavior appropriate for a\n+ * {@linkplain ProcessingEnvironment#isPreviewEnabled preview} source\n+ * version.\n+ *\n+ * @param <R> the return type of this visitor's methods.  Use {@link\n+ *            Void} for visitors that do not need to return results.\n+ * @param <P> the type of the additional parameter to this visitor's\n+ *            methods.  Use {@code Void} for visitors that do not need an\n+ *            additional parameter.\n+ *\n+ * @see <a href=\"AbstractTypeVisitor6.html#note_for_subclasses\">\n+ * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see AbstractTypeVisitor6\n+ * @see AbstractTypeVisitor7\n+ * @see AbstractTypeVisitor8\n+ * @see AbstractTypeVisitor9\n+ * @see AbstractTypeVisitor14\n+ * @since 23\n+ *\/\n+@SupportedSourceVersion(RELEASE_23)\n+@PreviewFeature(feature=PreviewFeature.Feature.LANGUAGE_MODEL, reflective=true)\n+public abstract class AbstractTypeVisitorPreview<R, P> extends AbstractTypeVisitor14<R, P> {\n+    \/**\n+     * Constructor for concrete subclasses to call.\n+     *\/\n+    protected AbstractTypeVisitorPreview() {\n+        super();\n+    }\n+}\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitorPreview.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.lang.model.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.element.*;\n+import javax.lang.model.SourceVersion;\n+import static javax.lang.model.SourceVersion.*;\n+\n+\/**\n+ * A visitor of program elements based on their {@linkplain\n+ * ElementKind kind} with default behavior appropriate for a\n+ * {@linkplain ProcessingEnvironment#isPreviewEnabled preview} source\n+ * version.\n+ *\n+ * For {@linkplain\n+ * Element elements} <code><i>Xyz<\/i><\/code> that may have more than one\n+ * kind, the <code>visit<i>Xyz<\/i><\/code> methods in this class delegate\n+ * to the <code>visit<i>Xyz<\/i>As<i>Kind<\/i><\/code> method corresponding to the\n+ * first argument's kind.  The <code>visit<i>Xyz<\/i>As<i>Kind<\/i><\/code> methods\n+ * call {@link #defaultAction defaultAction}, passing their arguments\n+ * to {@code defaultAction}'s corresponding parameters.\n+ *\n+ * @apiNote\n+ * Methods in this class may be overridden subject to their general\n+ * contract.\n+ *\n+ * @param <R> the return type of this visitor's methods.  Use {@link\n+ *            Void} for visitors that do not need to return results.\n+ * @param <P> the type of the additional parameter to this visitor's\n+ *            methods.  Use {@code Void} for visitors that do not need an\n+ *            additional parameter.\n+ *\n+ * @see <a href=\"ElementKindVisitor6.html#note_for_subclasses\">\n+ * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see ElementKindVisitor6\n+ * @see ElementKindVisitor7\n+ * @see ElementKindVisitor8\n+ * @see ElementKindVisitor9\n+ * @see ElementKindVisitor14\n+ * @since 23\n+ *\/\n+@SupportedSourceVersion(RELEASE_23)\n+@PreviewFeature(feature=PreviewFeature.Feature.LANGUAGE_MODEL, reflective=true)\n+public class ElementKindVisitorPreview<R, P> extends ElementKindVisitor14<R, P> {\n+    \/**\n+     * Constructor for concrete subclasses; uses {@code null} for the\n+     * default value.\n+     *\/\n+    protected ElementKindVisitorPreview() {\n+        super(null);\n+    }\n+\n+    \/**\n+     * Constructor for concrete subclasses; uses the argument for the\n+     * default value.\n+     *\n+     * @param defaultValue the value to assign to {@link #DEFAULT_VALUE}\n+     *\/\n+    protected ElementKindVisitorPreview(R defaultValue) {\n+        super(defaultValue);\n+    }\n+}\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitorPreview.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.lang.model.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.element.*;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.ElementVisitor;\n+import static javax.lang.model.SourceVersion.*;\n+\n+\/**\n+ * A scanning visitor of program elements with default behavior\n+ * appropriate for a {@linkplain\n+ * ProcessingEnvironment#isPreviewEnabled preview} source version.\n+ *\n+ * The <code>visit<i>Xyz<\/i><\/code> methods in this class scan their\n+ * component elements by calling {@link ElementScanner6#scan(Element,\n+ * Object) scan} on their {@linkplain Element#getEnclosedElements\n+ * enclosed elements}, {@linkplain ExecutableElement#getParameters\n+ * parameters}, etc., as indicated in the individual method\n+ * specifications.  A subclass can control the order elements are\n+ * visited by overriding the <code>visit<i>Xyz<\/i><\/code> methods.\n+ * Note that clients of a scanner may get the desired behavior by\n+ * invoking {@code v.scan(e, p)} rather than {@code v.visit(e, p)} on\n+ * the root objects of interest.\n+ *\n+ * <p>When a subclass overrides a <code>visit<i>Xyz<\/i><\/code> method, the\n+ * new method can cause the enclosed elements to be scanned in the\n+ * default way by calling <code>super.visit<i>Xyz<\/i><\/code>.  In this\n+ * fashion, the concrete visitor can control the ordering of traversal\n+ * over the component elements with respect to the additional\n+ * processing; for example, consistently calling\n+ * <code>super.visit<i>Xyz<\/i><\/code> at the start of the overridden\n+ * methods will yield a preorder traversal, etc.  If the component\n+ * elements should be traversed in some other order, instead of\n+ * calling <code>super.visit<i>Xyz<\/i><\/code>, an overriding visit method\n+ * should call {@code scan} with the elements in the desired order.\n+ *\n+ * @apiNote\n+ * Methods in this class may be overridden subject to their general\n+ * contract.\n+ *\n+ * @param <R> the return type of this visitor's methods.  Use {@link\n+ *            Void} for visitors that do not need to return results.\n+ * @param <P> the type of the additional parameter to this visitor's\n+ *            methods.  Use {@code Void} for visitors that do not need an\n+ *            additional parameter.\n+ *\n+ * @see <a href=\"ElementScanner6.html#note_for_subclasses\"><strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see ElementScanner6\n+ * @see ElementScanner7\n+ * @see ElementScanner8\n+ * @see ElementScanner9\n+ * @see ElementScanner14\n+ * @since 23\n+ *\/\n+@SupportedSourceVersion(RELEASE_23)\n+@PreviewFeature(feature=PreviewFeature.Feature.LANGUAGE_MODEL, reflective=true)\n+public class ElementScannerPreview<R, P> extends ElementScanner14<R, P> {\n+    \/**\n+     * Constructor for concrete subclasses; uses {@code null} for the\n+     * default value.\n+     *\/\n+    protected ElementScannerPreview(){\n+        super(null);\n+    }\n+\n+    \/**\n+     * Constructor for concrete subclasses; uses the argument for the\n+     * default value.\n+     *\n+     * @param defaultValue the default value\n+     *\/\n+    protected ElementScannerPreview(R defaultValue){\n+        super(defaultValue);\n+    }\n+}\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScannerPreview.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.lang.model.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.SourceVersion;\n+import static javax.lang.model.SourceVersion.*;\n+\n+\/**\n+ * A simple visitor for annotation values with default behavior\n+ * appropriate for a {@linkplain\n+ * ProcessingEnvironment#isPreviewEnabled preview} source version.\n+ *\n+ * Visit methods call {@link #defaultAction\n+ * defaultAction} passing their arguments to {@code defaultAction}'s\n+ * corresponding parameters.\n+ *\n+ * @apiNote\n+ * Methods in this class may be overridden subject to their general\n+ * contract.\n+ *\n+ * @param <R> the return type of this visitor's methods\n+ * @param <P> the type of the additional parameter to this visitor's methods.\n+ *\n+ * @see <a href=\"SimpleAnnotationValueVisitor6.html#note_for_subclasses\">\n+ * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see SimpleAnnotationValueVisitor6\n+ * @see SimpleAnnotationValueVisitor7\n+ * @see SimpleAnnotationValueVisitor8\n+ * @see SimpleAnnotationValueVisitor9\n+ * @see SimpleAnnotationValueVisitor14\n+ * @since 23\n+ *\/\n+@SupportedSourceVersion(RELEASE_23)\n+@PreviewFeature(feature=PreviewFeature.Feature.LANGUAGE_MODEL, reflective=true)\n+public class SimpleAnnotationValueVisitorPreview<R, P> extends SimpleAnnotationValueVisitor14<R, P> {\n+    \/**\n+     * Constructor for concrete subclasses; uses {@code null} for the\n+     * default value.\n+     *\/\n+    protected SimpleAnnotationValueVisitorPreview() {\n+        super(null);\n+    }\n+\n+    \/**\n+     * Constructor for concrete subclasses; uses the argument for the\n+     * default value.\n+     *\n+     * @param defaultValue the value to assign to {@link #DEFAULT_VALUE}\n+     *\/\n+    protected SimpleAnnotationValueVisitorPreview(R defaultValue) {\n+        super(defaultValue);\n+    }\n+}\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitorPreview.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.lang.model.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.ElementVisitor;\n+import javax.lang.model.element.RecordComponentElement;\n+import static javax.lang.model.SourceVersion.*;\n+\n+\/**\n+ * A simple visitor of program elements with default behavior\n+ * appropriate for a {@linkplain\n+ * ProcessingEnvironment#isPreviewEnabled preview} source version.\n+ *\n+ * Visit methods corresponding to {@code RELEASE_14} and earlier\n+ * language constructs call {@link #defaultAction defaultAction},\n+ * passing their arguments to {@code defaultAction}'s corresponding\n+ * parameters.\n+ *\n+ * @apiNote\n+ * Methods in this class may be overridden subject to their general\n+ * contract.\n+ *\n+ * @param <R> the return type of this visitor's methods.  Use {@code Void}\n+ *             for visitors that do not need to return results.\n+ * @param <P> the type of the additional parameter to this visitor's methods.  Use {@code Void}\n+ *              for visitors that do not need an additional parameter.\n+ *\n+ * @see <a href=\"SimpleElementVisitor6.html#note_for_subclasses\">\n+ * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see SimpleElementVisitor6\n+ * @see SimpleElementVisitor7\n+ * @see SimpleElementVisitor8\n+ * @see SimpleElementVisitor9\n+ * @see SimpleElementVisitor14\n+ * @since 23\n+ *\/\n+@SupportedSourceVersion(RELEASE_23)\n+@PreviewFeature(feature=PreviewFeature.Feature.LANGUAGE_MODEL, reflective=true)\n+public class SimpleElementVisitorPreview<R, P> extends SimpleElementVisitor14<R, P> {\n+    \/**\n+     * Constructor for concrete subclasses; uses {@code null} for the\n+     * default value.\n+     *\/\n+    protected SimpleElementVisitorPreview(){\n+        super(null);\n+    }\n+\n+    \/**\n+     * Constructor for concrete subclasses; uses the argument for the\n+     * default value.\n+     *\n+     * @param defaultValue the value to assign to {@link #DEFAULT_VALUE}\n+     *\/\n+    protected SimpleElementVisitorPreview(R defaultValue){\n+        super(defaultValue);\n+    }\n+}\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitorPreview.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.lang.model.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.SourceVersion;\n+import static javax.lang.model.SourceVersion.*;\n+\n+\/**\n+ * A simple visitor of types with default behavior appropriate for a\n+ * {@linkplain ProcessingEnvironment#isPreviewEnabled preview} source\n+ * version.\n+ *\n+ * Visit methods corresponding to {@code RELEASE_14} and earlier\n+ * language constructs call {@link #defaultAction defaultAction},\n+ * passing their arguments to {@code defaultAction}'s corresponding\n+ * parameters.\n+ *\n+ * @apiNote\n+ * Methods in this class may be overridden subject to their general\n+ * contract.\n+ *\n+ * @param <R> the return type of this visitor's methods.  Use {@link\n+ *            Void} for visitors that do not need to return results.\n+ * @param <P> the type of the additional parameter to this visitor's\n+ *            methods.  Use {@code Void} for visitors that do not need an\n+ *            additional parameter.\n+ *\n+ * @see <a href=\"SimpleTypeVisitor6.html#note_for_subclasses\">\n+ * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see SimpleTypeVisitor6\n+ * @see SimpleTypeVisitor7\n+ * @see SimpleTypeVisitor8\n+ * @see SimpleTypeVisitor9\n+ * @see SimpleTypeVisitor14\n+ * @since 23\n+ *\/\n+@SupportedSourceVersion(RELEASE_23)\n+@PreviewFeature(feature=PreviewFeature.Feature.LANGUAGE_MODEL, reflective=true)\n+public class SimpleTypeVisitorPreview<R, P> extends SimpleTypeVisitor14<R, P> {\n+    \/**\n+     * Constructor for concrete subclasses; uses {@code null} for the\n+     * default value.\n+     *\/\n+    protected SimpleTypeVisitorPreview(){\n+        super(null);\n+    }\n+\n+    \/**\n+     * Constructor for concrete subclasses; uses the argument for the\n+     * default value.\n+     *\n+     * @param defaultValue the value to assign to {@link #DEFAULT_VALUE}\n+     *\/\n+    protected SimpleTypeVisitorPreview(R defaultValue){\n+        super(defaultValue);\n+    }\n+}\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitorPreview.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.lang.model.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.type.*;\n+import static javax.lang.model.SourceVersion.*;\n+\n+\/**\n+ * A visitor of types based on their {@linkplain TypeKind kind} with\n+ * default behavior appropriate for a {@linkplain\n+ * ProcessingEnvironment#isPreviewEnabled preview} source version.\n+ *\n+ * For {@linkplain\n+ * TypeMirror types} <code><i>Xyz<\/i><\/code> that may have more than one\n+ * kind, the <code>visit<i>Xyz<\/i><\/code> methods in this class delegate\n+ * to the <code>visit<i>Xyz<\/i>As<i>Kind<\/i><\/code> method corresponding to the\n+ * first argument's kind.  The <code>visit<i>Xyz<\/i>As<i>Kind<\/i><\/code> methods\n+ * call {@link #defaultAction defaultAction}, passing their arguments\n+ * to {@code defaultAction}'s corresponding parameters.\n+ *\n+ * @apiNote\n+ * Methods in this class may be overridden subject to their general\n+ * contract.\n+ *\n+ * @param <R> the return type of this visitor's methods.  Use {@link\n+ *            Void} for visitors that do not need to return results.\n+ * @param <P> the type of the additional parameter to this visitor's\n+ *            methods.  Use {@code Void} for visitors that do not need an\n+ *            additional parameter.\n+ *\n+ * @see <a href=\"TypeKindVisitor6.html#note_for_subclasses\">\n+ * <strong>Compatibility note for subclasses<\/strong><\/a>\n+ * @see TypeKindVisitor6\n+ * @see TypeKindVisitor7\n+ * @see TypeKindVisitor8\n+ * @see TypeKindVisitor9\n+ * @see TypeKindVisitor14\n+ * @since 23\n+ *\/\n+@SupportedSourceVersion(RELEASE_23)\n+@PreviewFeature(feature=PreviewFeature.Feature.LANGUAGE_MODEL, reflective=true)\n+public class TypeKindVisitorPreview<R, P> extends TypeKindVisitor14<R, P> {\n+    \/**\n+     * Constructor for concrete subclasses to call; uses {@code null}\n+     * for the default value.\n+     *\/\n+    protected TypeKindVisitorPreview() {\n+        super(null);\n+    }\n+\n+    \/**\n+     * Constructor for concrete subclasses to call; uses the argument\n+     * for the default value.\n+     *\n+     * @param defaultValue the value to assign to {@link #DEFAULT_VALUE}\n+     *\/\n+    protected TypeKindVisitorPreview(R defaultValue) {\n+        super(defaultValue);\n+    }\n+}\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitorPreview.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -622,10 +622,0 @@\n-            kit.read(r, doc, 0);\n-        } catch (BadLocationException e) {\n-            throw new IOException(e.getMessage());\n-        } catch (ChangedCharSetException changedCharSetException) {\n-            String charSetSpec = changedCharSetException.getCharSetSpec();\n-            if (changedCharSetException.keyEqualsCharSet()) {\n-                putClientProperty(\"charset\", charSetSpec);\n-            } else {\n-                setCharsetFromContentTypeParameters(charSetSpec);\n-            }\n@@ -633,8 +623,7 @@\n-                in.reset();\n-            } catch (IOException exception) {\n-                \/\/mark was invalidated\n-                in.close();\n-                URL url = (URL)doc.getProperty(Document.StreamDescriptionProperty);\n-                if (url != null) {\n-                    URLConnection conn = url.openConnection();\n-                    in = conn.getInputStream();\n+                kit.read(r, doc, 0);\n+            } catch (BadLocationException e) {\n+                throw new IOException(e.getMessage());\n+            } catch (ChangedCharSetException changedCharSetException) {\n+                String charSetSpec = changedCharSetException.getCharSetSpec();\n+                if (changedCharSetException.keyEqualsCharSet()) {\n+                    putClientProperty(\"charset\", charSetSpec);\n@@ -642,2 +631,15 @@\n-                    \/\/there is nothing we can do to recover stream\n-                    throw changedCharSetException;\n+                    setCharsetFromContentTypeParameters(charSetSpec);\n+                }\n+                try {\n+                    in.reset();\n+                } catch (IOException exception) {\n+                    \/\/mark was invalidated\n+                    in.close();\n+                    URL url = (URL)doc.getProperty(Document.StreamDescriptionProperty);\n+                    if (url != null) {\n+                        URLConnection conn = url.openConnection();\n+                        in = conn.getInputStream();\n+                    } else {\n+                        \/\/there is nothing we can do to recover stream\n+                        throw changedCharSetException;\n+                    }\n@@ -645,0 +647,5 @@\n+                try {\n+                    doc.remove(0, doc.getLength());\n+                } catch (BadLocationException e) {}\n+                doc.putProperty(\"IgnoreCharsetDirective\", Boolean.valueOf(true));\n+                read(in, doc);\n@@ -646,5 +653,0 @@\n-            try {\n-                doc.remove(0, doc.getLength());\n-            } catch (BadLocationException e) {}\n-            doc.putProperty(\"IgnoreCharsetDirective\", Boolean.valueOf(true));\n-            read(in, doc);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JEditorPane.java","additions":28,"deletions":26,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,0 @@\n-\/\/\/ PENDING(klobad) Who should be opaque in this component?\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JRootPane.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import java.util.Vector;\n@@ -215,4 +214,3 @@\n-        \/**\n-         * if either superscript or subscript is\n-         * is set, we need to reduce the font size\n-         * by 2.\n+        \/*\n+         * If either superscript or subscript is set,\n+         * we need to reduce the font size by 2.\n@@ -766,1 +764,0 @@\n-        unusedSets = f.get(\"unusedSets\", 0);\n@@ -788,8 +785,0 @@\n-    \/**\n-     * Number of immutable sets that are not currently\n-     * being used.  This helps indicate when the sets need\n-     * to be cleaned out of the hashtable they are stored\n-     * in.\n-     *\/\n-    private int unusedSets;\n-\n@@ -1058,1 +1047,1 @@\n-    static class KeyEnumeration implements Enumeration<Object> {\n+    static final class KeyEnumeration implements Enumeration<Object> {\n@@ -1096,139 +1085,0 @@\n-    \/**\n-     * Sorts the key strings so that they can be very quickly compared\n-     * in the attribute set searches.\n-     *\/\n-    static class KeyBuilder {\n-\n-        public void initialize(AttributeSet a) {\n-            if (a instanceof SmallAttributeSet) {\n-                initialize(((SmallAttributeSet)a).attributes);\n-            } else {\n-                keys.removeAllElements();\n-                data.removeAllElements();\n-                Enumeration<?> names = a.getAttributeNames();\n-                while (names.hasMoreElements()) {\n-                    Object name = names.nextElement();\n-                    addAttribute(name, a.getAttribute(name));\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Initialize with a set of already sorted\n-         * keys (data from an existing SmallAttributeSet).\n-         *\/\n-        private void initialize(Object[] sorted) {\n-            keys.removeAllElements();\n-            data.removeAllElements();\n-            int n = sorted.length;\n-            for (int i = 0; i < n; i += 2) {\n-                keys.addElement(sorted[i]);\n-                data.addElement(sorted[i+1]);\n-            }\n-        }\n-\n-        \/**\n-         * Creates a table of sorted key\/value entries\n-         * suitable for creation of an instance of\n-         * SmallAttributeSet.\n-         *\/\n-        public Object[] createTable() {\n-            int n = keys.size();\n-            Object[] tbl = new Object[2 * n];\n-            for (int i = 0; i < n; i ++) {\n-                int offs = 2 * i;\n-                tbl[offs] = keys.elementAt(i);\n-                tbl[offs + 1] = data.elementAt(i);\n-            }\n-            return tbl;\n-        }\n-\n-        \/**\n-         * The number of key\/value pairs contained\n-         * in the current key being forged.\n-         *\/\n-        int getCount() {\n-            return keys.size();\n-        }\n-\n-        \/**\n-         * Adds a key\/value to the set.\n-         *\/\n-        public void addAttribute(Object key, Object value) {\n-            keys.addElement(key);\n-            data.addElement(value);\n-        }\n-\n-        \/**\n-         * Adds a set of key\/value pairs to the set.\n-         *\/\n-        public void addAttributes(AttributeSet attr) {\n-            if (attr instanceof SmallAttributeSet) {\n-                \/\/ avoid searching the keys, they are already interned.\n-                Object[] tbl = ((SmallAttributeSet)attr).attributes;\n-                int n = tbl.length;\n-                for (int i = 0; i < n; i += 2) {\n-                    addAttribute(tbl[i], tbl[i+1]);\n-                }\n-            } else {\n-                Enumeration<?> names = attr.getAttributeNames();\n-                while (names.hasMoreElements()) {\n-                    Object name = names.nextElement();\n-                    addAttribute(name, attr.getAttribute(name));\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Removes the given name from the set.\n-         *\/\n-        public void removeAttribute(Object key) {\n-            int n = keys.size();\n-            for (int i = 0; i < n; i++) {\n-                if (keys.elementAt(i).equals(key)) {\n-                    keys.removeElementAt(i);\n-                    data.removeElementAt(i);\n-                    return;\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Removes the set of keys from the set.\n-         *\/\n-        public void removeAttributes(Enumeration<?> names) {\n-            while (names.hasMoreElements()) {\n-                Object name = names.nextElement();\n-                removeAttribute(name);\n-            }\n-        }\n-\n-        \/**\n-         * Removes the set of matching attributes from the set.\n-         *\/\n-        public void removeAttributes(AttributeSet attr) {\n-            Enumeration<?> names = attr.getAttributeNames();\n-            while (names.hasMoreElements()) {\n-                Object name = names.nextElement();\n-                Object value = attr.getAttribute(name);\n-                removeSearchAttribute(name, value);\n-            }\n-        }\n-\n-        private void removeSearchAttribute(Object ikey, Object value) {\n-            int n = keys.size();\n-            for (int i = 0; i < n; i++) {\n-                if (keys.elementAt(i).equals(ikey)) {\n-                    if (data.elementAt(i).equals(value)) {\n-                        keys.removeElementAt(i);\n-                        data.removeElementAt(i);\n-                    }\n-                    return;\n-                }\n-            }\n-        }\n-\n-        private Vector<Object> keys = new Vector<Object>();\n-        private Vector<Object> data = new Vector<Object>();\n-    }\n-\n@@ -1238,1 +1088,1 @@\n-    static class FontKey {\n+    static final class FontKey {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StyleContext.java","additions":6,"deletions":156,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,13 +85,0 @@\n-\/* Place holders for the old native interface. *\/\n-\n-long\n-sun_awt_image_GifImageDecoder_parseImage()\n-{\n-  return 0;\n-}\n-\n-void\n-sun_awt_image_GifImageDecoder_initIDs()\n-{\n-}\n-\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/gif\/gifdecoder.c","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-IMGEXTERN jfieldID g_RasterBaseRasterID;\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/imageInitIDs.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -381,27 +381,0 @@\n-int\n-HandleError(Display * disp, XErrorEvent * err) {\n-    \/\/ silently ignore non-fatal errors\n-    \/*\n-    char msg[0x1000];\n-    char buf[0x1000];\n-    XGetErrorText(disp, err->error_code, msg, sizeof(msg));\n-    fprintf(stderr, \"Xerror %s, XID %x, ser# %d\\n\", msg, err->resourceid,\n-        err->serial);\n-    snprintf(buf, sizeof(buf), \"%d\", err->request_code);\n-    XGetErrorDatabaseText(disp, \"XRequest\", buf, \"Unknown\", msg, sizeof(msg));\n-    fprintf(stderr, \"Major opcode %d (%s)\\n\", err->request_code, msg);\n-    if (err->request_code > 128) {\n-        fprintf(stderr, \"Minor opcode %d\\n\", err->minor_code);\n-    }\n-    *\/\n-    return 0;\n-}\n-\n-int\n-HandleIOError(Display * display) {\n-    \/\/ for really bad errors, we should exit the thread we're on\n-    SplashCleanup(SplashGetInstance());\n-    pthread_exit(NULL);\n-    return 0;\n-}\n-\n@@ -420,4 +393,0 @@\n-    \/\/ We should not ignore any errors.\n-    \/\/XSetErrorHandler(HandleError);\n-\/\/    XSetIOErrorHandler(HandleIOError);\n-    XSetIOErrorHandler(NULL);\n","filename":"src\/java.desktop\/unix\/native\/libsplashscreen\/splashscreen_sys.c","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -525,1 +525,1 @@\n-        if (special1 || special2) {\n+        if (special1 && special2) {\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/shell\/Win32ShellFolderManager2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-void D3DGlyphCache_FlushGlyphVertexCache();\n+static void D3DGlyphCache_FlushGlyphVertexCache();\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DGlyphCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -880,14 +880,0 @@\n-INLINE BOOL RectInMonitorRect(RECT *rCheck, RECT *rContainer)\n-{\n-    \/\/ Assumption: left <= right, top <= bottom\n-    if (rCheck->left >= rContainer->left &&\n-        rCheck->right <= rContainer->right &&\n-        rCheck->top >= rContainer->top &&\n-        rCheck->bottom <= rContainer->bottom)\n-    {\n-        return TRUE;\n-    } else {\n-        return FALSE;\n-    }\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/windows\/GDIRenderer.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -256,38 +256,0 @@\n-static BOOL GDIWinSD_CheckMonitorArea(GDIWinSDOps *wsdo,\n-                                     SurfaceDataBounds *bounds,\n-                                     HDC hDC)\n-{\n-    HWND hW = wsdo->window;\n-    BOOL retCode = TRUE;\n-\n-    J2dTraceLn(J2D_TRACE_INFO, \"GDIWinSD_CheckMonitorArea\");\n-    int numScreens;\n-    {\n-        Devices::InstanceAccess devices;\n-        numScreens = devices->GetNumDevices();\n-    }\n-    if( numScreens > 1 ) {\n-\n-        LPMONITORINFO miInfo;\n-        RECT rSect ={0,0,0,0};\n-        RECT rView ={bounds->x1, bounds->y1, bounds->x2, bounds->y2};\n-        retCode = FALSE;\n-\n-        miInfo = wsdo->device->GetMonitorInfo();\n-\n-        POINT ptOrig = {0, 0};\n-        ::ClientToScreen(hW, &ptOrig);\n-        ::OffsetRect(&rView,\n-            (ptOrig.x), (ptOrig.y));\n-\n-        ::IntersectRect(&rSect,&rView,&(miInfo->rcMonitor));\n-\n-        if( FALSE == ::IsRectEmpty(&rSect) ) {\n-            if( TRUE == ::EqualRect(&rSect,&rView) ) {\n-                retCode = TRUE;\n-            }\n-        }\n-    }\n-    return retCode;\n-}\n-\n@@ -555,105 +517,0 @@\n-static jboolean GDIWinSD_SimpleClip(JNIEnv *env, GDIWinSDOps *wsdo,\n-                                   SurfaceDataBounds *bounds,\n-                                   HDC hDC)\n-{\n-    RECT rClip;\n-\n-    J2dTraceLn(J2D_TRACE_INFO, \"GDIWinSD_SimpleClip\");\n-    if (hDC == NULL) {\n-        return JNI_FALSE;\n-    }\n-\n-    int nComplexity = ::GetClipBox(hDC, &rClip);\n-\n-    switch (nComplexity) {\n-    case COMPLEXREGION:\n-        {\n-            J2dTraceLn(J2D_TRACE_VERBOSE,\n-                       \"  complex clipping region\");\n-            \/\/ if complex user\/system clip, more detailed testing required\n-            \/\/ check to see if the view itself has a complex clip.\n-            \/\/ ::GetClipBox is only API which returns overlapped window status\n-            \/\/ so we set the rView as our clip, and then see if resulting\n-            \/\/ clip is complex.\n-            \/\/ Only other way to figure this out would be to walk the\n-            \/\/ overlapping windows (no API to get the actual visible clip\n-            \/\/ list).  Then we'd still have to merge that info with the\n-            \/\/ clip region for the dc (if it exists).\n-            \/\/ REMIND: we can cache the CreateRectRgnIndirect result,\n-            \/\/ and only override with ::SetRectRgn\n-\n-            \/\/ First, create a region handle (need existing HRGN for\n-            \/\/ the following call).\n-            HRGN rgnSave = ::CreateRectRgn(0, 0, 0, 0);\n-            int  clipStatus = ::GetClipRgn(hDC, rgnSave);\n-            if (-1 == clipStatus) {\n-                J2dTraceLn(J2D_TRACE_WARNING,\n-                           \"GDIWinSD_SimpleClip: failed due to clip status\");\n-                ::DeleteObject(rgnSave);\n-                return JNI_FALSE;\n-            }\n-            HRGN rgnBounds = ::CreateRectRgn(\n-                bounds->x1 - wsdo->insets.left,\n-                bounds->y1 - wsdo->insets.top,\n-                bounds->x2 - wsdo->insets.left,\n-                bounds->y2 - wsdo->insets.top);\n-            ::SelectClipRgn(hDC, rgnBounds);\n-            nComplexity = ::GetClipBox(hDC, &rClip);\n-            ::SelectClipRgn(hDC, clipStatus? rgnSave: NULL);\n-            ::DeleteObject(rgnSave);\n-            ::DeleteObject(rgnBounds);\n-\n-            \/\/ Now, test the new clip box.  If it's still not a\n-            \/\/ SIMPLE region, then our bounds must intersect part of\n-            \/\/ the clipping article\n-            if (SIMPLEREGION != nComplexity) {\n-                J2dTraceLn(J2D_TRACE_WARNING,\n-                           \"GDIWinSD_SimpleClip: failed due to complexity\");\n-                return JNI_FALSE;\n-            }\n-        }\n-        \/\/ NOTE: No break here - we want to fall through into the\n-        \/\/ SIMPLE case, adjust our bounds by the new rClip rect\n-        \/\/ and make sure that our locking bounds are not empty.\n-    case SIMPLEREGION:\n-        J2dTraceLn(J2D_TRACE_VERBOSE, \"  simple clipping region\");\n-        \/\/ Constrain the bounds to the given clip box\n-        if (bounds->x1 < rClip.left) {\n-            bounds->x1 = rClip.left;\n-        }\n-        if (bounds->y1 < rClip.top) {\n-            bounds->y1 = rClip.top;\n-        }\n-        if (bounds->x2 > rClip.right) {\n-            bounds->x2 = rClip.right;\n-        }\n-        if (bounds->y2 > rClip.bottom) {\n-            bounds->y2 = rClip.bottom;\n-        }\n-        \/\/ If the bounds are 0 or negative, then the bounds have\n-        \/\/ been obscured by the clip box, so return FALSE\n-        if ((bounds->x2 <= bounds->x1) ||\n-            (bounds->y2 <= bounds->y1)) {\n-            \/\/ REMIND: We should probably do something different here\n-            \/\/ instead of simply returning FALSE.  Since the bounds are\n-            \/\/ empty we won't end up drawing anything, so why spend the\n-            \/\/ effort of returning false and having GDI do a LOCK_BY_DIB?\n-            \/\/ Perhaps we need a new lock code that will indicate that we\n-            \/\/ shouldn't bother drawing?\n-            J2dTraceLn(J2D_TRACE_WARNING,\n-                       \"GDIWinSD_SimpleClip: failed due to empty bounds\");\n-            return JNI_FALSE;\n-        }\n-        break;\n-    case NULLREGION:\n-    case ERROR:\n-    default:\n-        J2dTraceLn1(J2D_TRACE_ERROR,\n-                   \"GDIWinSD_SimpleClip: failed due to incorrect complexity=%d\",\n-                    nComplexity);\n-        return JNI_FALSE;\n-    }\n-\n-    return JNI_TRUE;\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/windows\/GDIWindowSurfaceData.cpp","additions":1,"deletions":144,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,21 +47,0 @@\n-\n-static BOOL IsSupportedLevel(HANDLE hPrinter, DWORD dwLevel) {\n-    BOOL isSupported = FALSE;\n-    DWORD cbBuf = 0;\n-    LPBYTE pPrinter = NULL;\n-\n-    DASSERT(hPrinter != NULL);\n-\n-    VERIFY(::GetPrinter(hPrinter, dwLevel, NULL, 0, &cbBuf) == 0);\n-    if (::GetLastError() == ERROR_INSUFFICIENT_BUFFER) {\n-        pPrinter = new BYTE[cbBuf];\n-        if (::GetPrinter(hPrinter, dwLevel, pPrinter, cbBuf, &cbBuf)) {\n-            isSupported = TRUE;\n-        }\n-        delete[] pPrinter;\n-    }\n-\n-    return isSupported;\n-}\n-\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/WPrinterJob.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,35 +255,0 @@\n-struct EnvHolder\n-{\n-    JavaVM *m_pVM;\n-    JNIEnv *m_env;\n-    bool    m_isOwner;\n-    EnvHolder(\n-        JavaVM *pVM,\n-        LPCSTR name = \"COM holder\",\n-        jint ver = JNI_VERSION_1_2)\n-    : m_pVM(pVM),\n-      m_env((JNIEnv *)JNU_GetEnv(pVM, ver)),\n-      m_isOwner(false)\n-    {\n-        if (NULL == m_env) {\n-            JavaVMAttachArgs attachArgs;\n-            attachArgs.version  = ver;\n-            attachArgs.name     = const_cast<char *>(name);\n-            attachArgs.group    = NULL;\n-            jint status = m_pVM->AttachCurrentThread(\n-                (void**)&m_env,\n-                &attachArgs);\n-            m_isOwner = (NULL!=m_env);\n-        }\n-    }\n-    ~EnvHolder() {\n-        if (m_isOwner) {\n-            m_pVM->DetachCurrentThread();\n-        }\n-    }\n-    operator bool()  const { return NULL!=m_env; }\n-    bool operator !()  const { return NULL==m_env; }\n-    operator JNIEnv*() const { return m_env; }\n-    JNIEnv* operator ->() const { return m_env; }\n-};\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt.h","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-    SetEraseBackgroundStruct *sebs = (SetEraseBackgroundStruct *)param;\n+    SetEraseBackgroundStruct *sebs = static_cast<SetEraseBackgroundStruct *>(param);\n@@ -214,2 +214,16 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(canvas, ret);\n+    AwtCanvas *c = NULL;\n+\n+    if (canvas == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"canvas\");\n+        delete sebs;\n+        return;\n+    } else {\n+        c = (AwtCanvas*)JNI_GET_PDATA(canvas);\n+        if (c == NULL) {\n+            THROW_NULL_PDATA_IF_NOT_DESTROYED(canvas);\n+            env->DeleteGlobalRef(canvas);\n+            delete sebs;\n+            return;\n+        }\n+    }\n@@ -217,1 +231,0 @@\n-    AwtCanvas *c = (AwtCanvas*)pData;\n@@ -221,1 +234,0 @@\n-ret:\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Canvas.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,0 @@\n-static HWND g_hwndDown = NULL;\n@@ -201,4 +200,0 @@\n-static BOOL bLeftShiftIsDown = false;\n-static BOOL bRightShiftIsDown = false;\n-static UINT lastShiftKeyPressed = 0; \/\/ init to safe value\n-\n@@ -1295,1 +1290,0 @@\n-        WIN_MSG(WM_AWT_PRINT_COMPONENT)\n@@ -1301,2 +1295,0 @@\n-        WIN_MSG(WM_AWT_FORWARD_BYTE)\n-        WIN_MSG(WM_AWT_SET_SCROLL_INFO)\n@@ -1308,4 +1300,0 @@\n-        WIN_MSG(WM_AWT_PRE_KEYDOWN)\n-        WIN_MSG(WM_AWT_PRE_KEYUP)\n-        WIN_MSG(WM_AWT_PRE_SYSKEYDOWN)\n-        WIN_MSG(WM_AWT_PRE_SYSKEYUP)\n@@ -1323,1 +1311,0 @@\n-        WIN_MSG(WM_AWT_SETCURSOR,)\n@@ -1327,2 +1314,0 @@\n-        WIN_MSG(WM_AWT_EXECUTE_SYNC,)\n-        WIN_MSG(WM_AWT_CURSOR_SYNC)\n@@ -1332,2 +1317,0 @@\n-        WIN_MSG(WM_AWT_SHOWCURSOR)\n-        WIN_MSG(WM_AWT_HIDECURSOR)\n@@ -1420,6 +1403,0 @@\n-      case WM_AWT_SHOWCURSOR:\n-          ::ShowCursor(TRUE);\n-          break;\n-      case WM_AWT_HIDECURSOR:\n-          ::ShowCursor(FALSE);\n-          break;\n@@ -1843,4 +1820,0 @@\n-      case WM_AWT_FORWARD_BYTE:\n-          mr = HandleEvent( (MSG *) lParam, (BOOL) wParam);\n-          break;\n-\n@@ -1979,7 +1952,0 @@\n-      case WM_AWT_SET_SCROLL_INFO: {\n-          SCROLLINFO *si = (SCROLLINFO *) lParam;\n-          ::SetScrollInfo(GetHWnd(), (int) wParam, si, TRUE);\n-          delete si;\n-          mr = mrConsume;\n-          break;\n-      }\n@@ -5236,83 +5202,0 @@\n-void AwtComponent::SendFocusEvent(jint id, HWND opposite)\n-{\n-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);\n-\n-    CriticalSection::Lock l(GetLock());\n-    if (GetPeer(env) == NULL) {\n-        \/* event received during termination. *\/\n-        return;\n-    }\n-\n-    static jclass focusEventCls;\n-    if (focusEventCls == NULL) {\n-        jclass focusEventClsLocal\n-            = env->FindClass(\"java\/awt\/event\/FocusEvent\");\n-        DASSERT(focusEventClsLocal);\n-        CHECK_NULL(focusEventClsLocal);\n-        focusEventCls = (jclass)env->NewGlobalRef(focusEventClsLocal);\n-        env->DeleteLocalRef(focusEventClsLocal);\n-    }\n-\n-    static jmethodID focusEventConst;\n-    if (focusEventConst == NULL) {\n-        focusEventConst =\n-            env->GetMethodID(focusEventCls, \"<init>\",\n-                             \"(Ljava\/awt\/Component;IZLjava\/awt\/Component;)V\");\n-        DASSERT(focusEventConst);\n-        CHECK_NULL(focusEventConst);\n-    }\n-\n-    static jclass sequencedEventCls;\n-    if (sequencedEventCls == NULL) {\n-        jclass sequencedEventClsLocal =\n-            env->FindClass(\"java\/awt\/SequencedEvent\");\n-        DASSERT(sequencedEventClsLocal);\n-        CHECK_NULL(sequencedEventClsLocal);\n-        sequencedEventCls =\n-            (jclass)env->NewGlobalRef(sequencedEventClsLocal);\n-        env->DeleteLocalRef(sequencedEventClsLocal);\n-    }\n-\n-    static jmethodID sequencedEventConst;\n-    if (sequencedEventConst == NULL) {\n-        sequencedEventConst =\n-            env->GetMethodID(sequencedEventCls, \"<init>\",\n-                             \"(Ljava\/awt\/AWTEvent;)V\");\n-        DASSERT(sequencedEventConst);\n-        CHECK_NULL(sequencedEventConst);\n-    }\n-\n-    if (env->EnsureLocalCapacity(3) < 0) {\n-        return;\n-    }\n-\n-    jobject target = GetTarget(env);\n-    jobject jOpposite = NULL;\n-    if (opposite != NULL) {\n-        AwtComponent *awtOpposite = AwtComponent::GetComponent(opposite);\n-        if (awtOpposite != NULL) {\n-            jOpposite = awtOpposite->GetTarget(env);\n-        }\n-    }\n-    jobject focusEvent = env->NewObject(focusEventCls, focusEventConst,\n-                                        target, id, JNI_FALSE, jOpposite);\n-    DASSERT(!safe_ExceptionOccurred(env));\n-    DASSERT(focusEvent != NULL);\n-    if (jOpposite != NULL) {\n-        env->DeleteLocalRef(jOpposite); jOpposite = NULL;\n-    }\n-    env->DeleteLocalRef(target); target = NULL;\n-    CHECK_NULL(focusEvent);\n-\n-    jobject sequencedEvent = env->NewObject(sequencedEventCls,\n-                                            sequencedEventConst,\n-                                            focusEvent);\n-    DASSERT(!safe_ExceptionOccurred(env));\n-    DASSERT(sequencedEvent != NULL);\n-    env->DeleteLocalRef(focusEvent); focusEvent = NULL;\n-    CHECK_NULL(sequencedEvent);\n-    SendEvent(sequencedEvent);\n-\n-    env->DeleteLocalRef(sequencedEvent);\n-}\n-\n@@ -6363,1 +6246,1 @@\n-        SetParentStruct *data = (SetParentStruct*) param;\n+        SetParentStruct *data = static_cast<SetParentStruct*>(param);\n@@ -6370,5 +6253,33 @@\n-        PDATA pData;\n-        JNI_CHECK_PEER_GOTO(self, ret);\n-        awtComponent = (AwtComponent *)pData;\n-        JNI_CHECK_PEER_GOTO(parent, ret);\n-        awtParent = (AwtComponent *)pData;\n+        if (self == NULL) {\n+            env->ExceptionClear();\n+            JNU_ThrowNullPointerException(env, \"self\");\n+            env->DeleteGlobalRef(parent);\n+            delete data;\n+            return;\n+        } else {\n+            awtComponent = (AwtComponent *)JNI_GET_PDATA(self);;\n+            if (awtComponent == NULL) {\n+                THROW_NULL_PDATA_IF_NOT_DESTROYED(self);\n+                env->DeleteGlobalRef(self);\n+                env->DeleteGlobalRef(parent);\n+                delete data;\n+                return;\n+            }\n+        }\n+\n+        if (parent == NULL) {\n+            env->ExceptionClear();\n+            JNU_ThrowNullPointerException(env, \"parent\");\n+            env->DeleteGlobalRef(self);\n+            delete data;\n+            return;\n+        } else {\n+            awtParent = (AwtComponent *)JNI_GET_PDATA(parent);\n+            if (awtParent == NULL) {\n+                THROW_NULL_PDATA_IF_NOT_DESTROYED(parent);\n+                env->DeleteGlobalRef(self);\n+                env->DeleteGlobalRef(parent);\n+                delete data;\n+                return;\n+            }\n+        }\n@@ -6383,1 +6294,1 @@\n-ret:\n+\n@@ -6542,1 +6453,1 @@\n-    GetInsetsStruct *gis = (GetInsetsStruct *)param;\n+    GetInsetsStruct *gis = static_cast<GetInsetsStruct *>(param);\n@@ -6548,3 +6459,16 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtComponent *component = (AwtComponent *)pData;\n+    AwtComponent *component = NULL;\n+\n+    if (self == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"self\");\n+        delete gis;\n+        return;\n+    } else {\n+        component = (AwtComponent *)JNI_GET_PDATA(self);\n+        if (component == NULL) {\n+            THROW_NULL_PDATA_IF_NOT_DESTROYED(self);\n+            env->DeleteGlobalRef(self);\n+            delete gis;\n+            return;\n+        }\n+    }\n@@ -6554,1 +6478,0 @@\n-  ret:\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":53,"deletions":130,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,7 +405,0 @@\n-    \/*\n-     * Allocate and initialize a new java.awt.event.FocusEvent, and\n-     * post it to the peer's target object.  No response is expected\n-     * from the target.\n-     *\/\n-    void SendFocusEvent(jint id, HWND opposite);\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.h","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -522,1 +522,1 @@\n-        ::SetCursor(hCursor); \/\/ don't need WM_AWT_SETCURSOR\n+        ::SetCursor(hCursor);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Cursor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,54 +73,0 @@\n-static void DumpRegion(HRGN rgn) {\n-    DWORD size = ::GetRegionData(rgn, 0, NULL);\n-    char* buffer = (char *)safe_Malloc(size);\n-    memset(buffer, 0, size);\n-    LPRGNDATA rgndata = (LPRGNDATA)buffer;\n-    rgndata->rdh.dwSize = sizeof(RGNDATAHEADER);\n-    rgndata->rdh.iType = RDH_RECTANGLES;\n-    VERIFY(::GetRegionData(rgn, size, rgndata));\n-\n-    RECT* r = (RECT*)(buffer + rgndata->rdh.dwSize);\n-    for (DWORD i=0; i<rgndata->rdh.nCount; i++) {\n-        if ( !::IsRectEmpty(r) ) {\n-            DTrace_PrintImpl(\"\\trect %d %d %d %d\\n\", r->left, r->top, r->right, r->bottom);\n-        }\n-        r++;\n-    }\n-\n-    free(buffer);\n-}\n-\n-\/*\n- * DTRACE print callback to dump HDC clip region bounding rectangle\n- *\/\n-void DumpClipRectangle(const char * file, int line, int argc, const char * fmt, va_list arglist) {\n-    const char *msg = va_arg(arglist, const char *);\n-    HDC         hdc = va_arg(arglist, HDC);\n-    RECT        r;\n-\n-    DASSERT(argc == 2 && hdc != NULL);\n-    DASSERT(msg != NULL);\n-\n-    ::GetClipBox(hdc, &r);\n-    DTrace_PrintImpl(\"%s: hdc=%x, %d %d %d %d\\n\", msg, hdc, r.left, r.top, r.right, r.bottom);\n-}\n-\n-\/*\n- * DTRACE print callback to dump window's update region bounding rectangle\n- *\/\n-void DumpUpdateRectangle(const char * file, int line, int argc, const char * fmt, va_list arglist) {\n-    const char *msg = va_arg(arglist, const char *);\n-    HWND        hwnd = va_arg(arglist, HWND);\n-    RECT        r;\n-\n-    DASSERT(argc == 2 && ::IsWindow(hwnd));\n-    DASSERT(msg != NULL);\n-\n-    ::GetUpdateRect(hwnd, &r, FALSE);\n-    HRGN rgn = ::CreateRectRgn(0,0,1,1);\n-    int updated = ::GetUpdateRgn(hwnd, rgn, FALSE);\n-    DTrace_PrintImpl(\"%s: hwnd=%x, %d %d %d %d\\n\", msg, hwnd, r.left, r.top, r.right, r.bottom);\n-    DumpRegion(rgn);\n-    DeleteObject(rgn);\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Debug.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,8 +57,0 @@\n-    extern void DumpClipRectangle(const char * file, int line, int argc, const char * fmt, va_list arglist);\n-    extern void DumpUpdateRectangle(const char * file, int line, int argc, const char * fmt, va_list arglist);\n-\n-    #define AWT_DUMP_UPDATE_RECTANGLE(_msg, _hwnd) \\\n-        _DTrace_Template(DumpUpdateRectangle, 2, \"\", (_msg), (_hwnd), 0, 0, 0, 0, 0, 0)\n-\n-    #define AWT_DUMP_CLIP_RECTANGLE(_msg, _hwnd) \\\n-        _DTrace_Template(DumpClipRectangle, 2, \"\", (_msg), (_hwnd), 0, 0, 0, 0, 0, 0)\n@@ -74,3 +66,0 @@\n-    #define AWT_DUMP_UPDATE_RECTANGLE(_msg, _hwnd) ((void)0)\n-    #define AWT_DUMP_CLIP_RECTANGLE(_msg, _hwnd) ((void)0)\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Debug.h","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-#include <awt.h>\n@@ -45,0 +44,5 @@\n+\/\/ These files must be included before awt.h, since the latter redefines malloc\n+\/\/ to Do_Not_Use_Malloc, etc, and that will break these files.\n+#include \"awt_ole.h\"\n+#include \"awt_DCHolder.h\"\n+\n@@ -46,0 +50,1 @@\n+#include \"awt.h\"\n@@ -57,3 +62,0 @@\n-#include \"awt_ole.h\"\n-#include \"awt_DCHolder.h\"\n-\n@@ -157,1 +159,0 @@\n-        static FORMATETC fm = {0};\n@@ -1269,2 +1270,0 @@\n-DECLARE_JAVA_CLASS(awtIEClazz, \"java\/awt\/event\/InputEvent\")\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDS.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -267,1 +267,0 @@\n-        static jclass           awtIEClazz;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDS.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+\/\/ awt_ole.h must be included before awt.h, since the latter redefines malloc\n+\/\/ to Do_Not_Use_Malloc, etc, and that will break awt_ole.h.\n+#include \"awt_ole.h\"\n@@ -34,1 +37,0 @@\n-#include \"awt_ole.h\"\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDT.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1267,1 +1267,1 @@\n-            AwtWindow::WinThreadExecProc(args);\n+            DASSERT(FALSE);\n@@ -1343,1 +1343,1 @@\n-    SetStateStruct *sss = (SetStateStruct *)param;\n+    SetStateStruct *sss = static_cast<SetStateStruct *>(param);\n@@ -1349,3 +1349,15 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    f = (AwtFrame *)pData;\n+    if (self == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"self\");\n+        delete sss;\n+        return;\n+    } else {\n+        f = (AwtFrame *)JNI_GET_PDATA(self);\n+        if (f == NULL) {\n+            THROW_NULL_PDATA_IF_NOT_DESTROYED(self);\n+            env->DeleteGlobalRef(self);\n+            delete sss;\n+            return;\n+        }\n+    }\n+\n@@ -1408,1 +1420,1 @@\n-ret:\n+\n@@ -1572,1 +1584,1 @@\n-    NotifyModalBlockedStruct *nmbs = (NotifyModalBlockedStruct *)param;\n+    NotifyModalBlockedStruct *nmbs = static_cast<NotifyModalBlockedStruct *>(param);\n@@ -1578,1 +1590,1 @@\n-    PDATA pData;\n+    AwtFrame *f = NULL;\n@@ -1580,2 +1592,20 @@\n-    JNI_CHECK_PEER_GOTO(peer, ret);\n-    AwtFrame *f = (AwtFrame *)pData;\n+    if (peer == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"peer\");\n+        env->DeleteGlobalRef(self);\n+        env->DeleteGlobalRef(blockerPeer);\n+\n+        delete nmbs;\n+        return;\n+    } else {\n+        f = (AwtFrame *)JNI_GET_PDATA(peer);\n+        if (f == NULL) {\n+            THROW_NULL_PDATA_IF_NOT_DESTROYED(peer);\n+            env->DeleteGlobalRef(self);\n+            env->DeleteGlobalRef(peer);\n+            env->DeleteGlobalRef(blockerPeer);\n+\n+            delete nmbs;\n+            return;\n+        }\n+    }\n@@ -1585,2 +1615,22 @@\n-    JNI_CHECK_PEER_GOTO(blockerPeer, ret);\n-    AwtDialog *d = (AwtDialog *)pData;\n+    AwtDialog *d = NULL;\n+\n+    if (blockerPeer == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"blockerPeer\");\n+        env->DeleteGlobalRef(self);\n+        env->DeleteGlobalRef(peer);\n+\n+        delete nmbs;\n+        return;\n+    } else {\n+        d = (AwtDialog *)JNI_GET_PDATA(blockerPeer);\n+        if (d == NULL) {\n+            THROW_NULL_PDATA_IF_NOT_DESTROYED(blockerPeer);\n+            env->DeleteGlobalRef(self);\n+            env->DeleteGlobalRef(peer);\n+            env->DeleteGlobalRef(blockerPeer);\n+\n+            delete nmbs;\n+            return;\n+        }\n+    }\n@@ -1637,1 +1687,1 @@\n-ret:\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Frame.cpp","additions":64,"deletions":14,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,47 +177,0 @@\n-\/\/\n-\/\/ (static)\n-\/\/ Switches to Windows thread via SendMessage and synchronously\n-\/\/ calls AwtObject::WinThreadExecProc with the given command id\n-\/\/ and parameters.\n-\/\/\n-\/\/ Useful for writing code that needs to be synchronized with\n-\/\/ what's happening on the Windows thread.\n-\/\/\n-LRESULT AwtObject::WinThreadExec(\n-    jobject                             peerObject,\n-    UINT                                cmdId,\n-    LPARAM                              param1,\n-    LPARAM                              param2,\n-    LPARAM                              param3,\n-    LPARAM                              param4 )\n-{\n-    DASSERT( peerObject != NULL);\n-\n-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);\n-    \/\/ since we pass peerObject to another thread we must\n-    \/\/   make a global ref\n-    jobject peerObjectGlobalRef = env->NewGlobalRef(peerObject);\n-\n-    ExecuteArgs         args;\n-    LRESULT         retVal;\n-\n-    \/\/ setup arguments\n-    args.cmdId = cmdId;\n-    args.param1 = param1;\n-    args.param2 = param2;\n-    args.param3 = param3;\n-    args.param4 = param4;\n-\n-    \/\/ call WinThreadExecProc on the toolkit thread\n-    retVal = AwtToolkit::GetInstance().SendMessage(WM_AWT_EXECUTE_SYNC,\n-                                                   (WPARAM)peerObjectGlobalRef,\n-                                                   (LPARAM)&args);\n-    return retVal;\n-}\n-\n-LRESULT AwtObject::WinThreadExecProc(ExecuteArgs * args)\n-{\n-    DASSERT(FALSE); \/\/ no default handler\n-    return 0L;\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Object.cpp","additions":1,"deletions":48,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,5 +123,0 @@\n-    \/\/ execute given code on Windows message-pump thread\n-    static LRESULT WinThreadExec(jobject peerObject, UINT cmdId, LPARAM param1 = 0L, LPARAM param2 = 0L, LPARAM param3 = 0L, LPARAM param4 = 0L);\n-    \/\/ callback function to execute code on Windows message-pump thread\n-    virtual LRESULT WinThreadExecProc(AwtObject::ExecuteArgs * args);\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Object.h","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,4 +38,4 @@\n-    static jfieldID AwtPrintDialog::controlID;\n-    static jfieldID AwtPrintDialog::parentID;\n-    static jfieldID AwtPrintDialog::pageID;\n-    static jmethodID AwtPrintDialog::setHWndMID;\n+    static jfieldID controlID;\n+    static jfieldID parentID;\n+    static jfieldID pageID;\n+    static jmethodID setHWndMID;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintDialog.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+jfieldID AwtPrintDialog::pageID;\n+\n@@ -66,5 +68,0 @@\n-\/*** Private Constants ***\/\n-\n-static const char *kJavaIntStr = \"I\";\n-static const char *kJavaLongStr = \"J\";\n-\n@@ -212,1 +209,0 @@\n-jfieldID AwtPrintDialog::pageID;\n@@ -310,3 +306,0 @@\n-static jboolean jFontToWFontA(JNIEnv *env, HDC printDC, jstring fontName,\n-                        jfloat fontSize, jboolean isBold, jboolean isItalic,\n-                        jint rotation, jfloat awScale);\n@@ -318,4 +311,0 @@\n-static int CALLBACK fontEnumProcA(ENUMLOGFONTEXA  *logfont,\n-                                  NEWTEXTMETRICEX  *lpntme,\n-                                  int FontType,\n-                                  LPARAM lParam);\n@@ -496,0 +485,12 @@\n+#define CLEANUP_SHOW {                      \\\n+    env->DeleteGlobalRef(peerGlobalRef);    \\\n+    if (target != NULL) {                   \\\n+        env->DeleteLocalRef(target);        \\\n+    }                                       \\\n+    if (parent != NULL) {                   \\\n+        env->DeleteLocalRef(parent);        \\\n+    }                                       \\\n+    env->DeleteLocalRef(page);              \\\n+    env->DeleteLocalRef(self);              \\\n+}\n+\n@@ -524,2 +525,0 @@\n-\n-    jboolean doIt = JNI_FALSE; \/\/ Assume the user will cancel the dialog.\n@@ -575,1 +574,1 @@\n-        (void)::PageSetupDlg(&setup);\n+        static_cast<void>(::PageSetupDlg(&setup));\n@@ -580,2 +579,2 @@\n-            doIt = JNI_FALSE;\n-            goto done;\n+            CLEANUP_SHOW;\n+            return JNI_FALSE;\n@@ -608,2 +607,2 @@\n-        doIt = JNI_FALSE;\n-        goto done;\n+        CLEANUP_SHOW;\n+        return JNI_FALSE;\n@@ -622,2 +621,2 @@\n-            doIt = JNI_FALSE;\n-            goto done;\n+            CLEANUP_SHOW;\n+            return JNI_FALSE;\n@@ -663,3 +662,3 @@\n-         if (env->ExceptionCheck()) {\n-             doIt = JNI_FALSE;\n-             goto done;\n+        if (env->ExceptionCheck()) {\n+            CLEANUP_SHOW;\n+            return JNI_FALSE;\n@@ -673,2 +672,2 @@\n-             doIt = JNI_FALSE;\n-             goto done;\n+            CLEANUP_SHOW;\n+            return JNI_FALSE;\n@@ -678,2 +677,2 @@\n-             doIt = JNI_FALSE;\n-             goto done;\n+            CLEANUP_SHOW;\n+            return JNI_FALSE;\n@@ -687,2 +686,2 @@\n-                        doIt = JNI_FALSE;\n-                        goto done;\n+                        CLEANUP_SHOW;\n+                        return JNI_FALSE;\n@@ -694,1 +693,0 @@\n-        doIt = JNI_TRUE;\n@@ -711,10 +709,1 @@\n-done:\n-    env->DeleteGlobalRef(peerGlobalRef);\n-    if (target != NULL) {\n-        env->DeleteLocalRef(target);\n-    }\n-    if (parent != NULL) {\n-        env->DeleteLocalRef(parent);\n-    }\n-    env->DeleteLocalRef(page);\n-    env->DeleteLocalRef(self);\n+    CLEANUP_SHOW;\n@@ -722,1 +711,1 @@\n-    return doIt;\n+    return JNI_TRUE;\n@@ -884,0 +873,15 @@\n+#define CLEANUP_VALIDATE_PAPER {                                               \\\n+    if (privateDC == TRUE) {                                                   \\\n+        if (printDC != NULL) {                                                 \\\n+            \/* In this case we know that this DC has no GDI objects to free *\/ \\\n+             ::DeleteDC(printDC);                                              \\\n+        }                                                                      \\\n+        if (hDevMode != NULL) {                                                \\\n+            ::GlobalFree(hDevMode);                                            \\\n+        }                                                                      \\\n+        if (hDevNames != NULL) {                                               \\\n+            ::GlobalFree(hDevNames);                                           \\\n+        }                                                                      \\\n+    }                                                                          \\\n+}\n+\n@@ -922,1 +926,6 @@\n-    JNI_CHECK_NULL_GOTO(printDC, \"Invalid printDC\", done);\n+    if (printDC == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"Invalid printDC\");\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -935,1 +944,4 @@\n-    if (err) goto done;\n+    if (err) {\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -943,1 +955,6 @@\n-    JNI_CHECK_NULL_GOTO(paperClass, \"paper class not found\", done);\n+    if (paperClass == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"paper class not found\");\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -945,1 +962,6 @@\n-    JNI_CHECK_NULL_GOTO(getID, \"no getWidth method\", done);\n+    if (getID == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"no getWidth method\");\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -948,1 +970,6 @@\n-    JNI_CHECK_NULL_GOTO(getID, \"no getHeight method\", done);\n+    if (getID == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"no getHeight method\");\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -951,1 +978,6 @@\n-    JNI_CHECK_NULL_GOTO(getID, \"no getX method\", done);\n+    if (getID == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"no getX method\");\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -954,1 +986,6 @@\n-    JNI_CHECK_NULL_GOTO(getID, \"no getY method\", done);\n+    if (getID == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"no getY method\");\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -957,1 +994,6 @@\n-    JNI_CHECK_NULL_GOTO(getID, \"no getW method\", done);\n+    if (getID == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"no getW method\");\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -960,1 +1002,6 @@\n-    JNI_CHECK_NULL_GOTO(getID, \"no getH method\", done);\n+    if (getID == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"no getH method\");\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -1053,1 +1100,6 @@\n-    JNI_CHECK_NULL_GOTO(setSizeID, \"no setSize method\", done);\n+    if (setSizeID == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"no setSize method\");\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -1057,1 +1109,6 @@\n-    JNI_CHECK_NULL_GOTO(setImageableID, \"no setImageable method\", done);\n+    if (setImageableID == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"no setImageable method\");\n+        CLEANUP_VALIDATE_PAPER;\n+        return;\n+    }\n@@ -1062,1 +1119,0 @@\n-done:\n@@ -1064,12 +1120,1 @@\n-    if (privateDC == TRUE) {\n-        if (printDC != NULL) {\n-            \/* In this case we know that this DC has no GDI objects to free *\/\n-             ::DeleteDC(printDC);\n-        }\n-        if (hDevMode != NULL) {\n-            ::GlobalFree(hDevMode);\n-        }\n-        if (hDevNames != NULL) {\n-            ::GlobalFree(hDevNames);\n-        }\n-    }\n+    CLEANUP_VALIDATE_PAPER;\n@@ -2256,125 +2301,0 @@\n-\/**\n- * Try to convert a java font to a GDI font. On entry, 'printDC',\n- * is the device context we want to draw into. 'fontName' is\n- * the name of the font to be matched and 'fontSize' is the\n- * size of the font in device coordinates. If there is an\n- * equivalent GDI font then this function sets that font\n- * into 'printDC' and returns a 'true'. If there is no equivalent\n- * font then 'false' is returned.\n- *\/\n-static jboolean jFontToWFontA(JNIEnv *env, HDC printDC, jstring fontName,\n-                        jfloat fontSize, jboolean isBold, jboolean isItalic,\n-                        jint rotation, jfloat awScale)\n-{\n-    LOGFONTA lf;\n-    LOGFONTA matchedLogFont;\n-    BOOL foundFont = false;     \/\/ Assume we didn't find a matching GDI font.\n-\n-    memset(&matchedLogFont, 0, sizeof(matchedLogFont));\n-\n-    LPCWSTR fontNameW = JNU_GetStringPlatformChars(env, fontName, NULL);\n-\n-\n-    \/* Some fontnames of Non-ASCII fonts like 'MS Minchou' are themselves\n-     * Non-ASCII.  They are assumed to be written in Unicode.\n-     * Hereby, they are converted into platform codeset.\n-     *\/\n-    int maxlen = static_cast<int>(sizeof(lf.lfFaceName)) - 1;\n-    \/\/ maxlen is int due to cbMultiByte parameter is int\n-    int destLen = WideCharToMultiByte(CP_ACP,        \/\/ convert to ASCII code page\n-                                      0,             \/\/ flags\n-                                      fontNameW,     \/\/ Unicode string\n-                                      -1,            \/\/ Unicode length is calculated automatically\n-                                      lf.lfFaceName, \/\/ Put ASCII string here\n-                                      maxlen,        \/\/ max len\n-                                      NULL,          \/\/ default handling of unmappables\n-                                      NULL);         \/\/ do not care if def char is used\n-\n-    \/* If WideCharToMultiByte succeeded then the number\n-     * of bytes it copied into the face name buffer will\n-     * be greater than zero and we just need to NULL terminate\n-     * the string. If there was an error then the number of\n-     * bytes copied is zero and we can not match the font.\n-     *\/\n-    if (destLen > 0) {\n-\n-        DASSERT(destLen < sizeof(lf.lfFaceName));\n-        lf.lfFaceName[destLen] = '\\0';\n-        lf.lfCharSet = DEFAULT_CHARSET;\n-        lf.lfPitchAndFamily = 0;\n-\n-        foundFont = !EnumFontFamiliesExA((HDC)printDC, &lf,\n-                                        (FONTENUMPROCA) fontEnumProcA,\n-                                        (LPARAM) &matchedLogFont, 0);\n-    }\n-\n-\n-    if (foundFont) {\n-\n-        \/* Build a font of the requested size with no\n-         * width modifications. A negative font height\n-         * tells GDI that we want that values absolute\n-         * value as the font's point size. If the font\n-         * is successfully built then set it as the current\n-         * GDI font.\n-         *\/\n-        matchedLogFont.lfHeight = -ROUND_TO_LONG(fontSize);\n-        matchedLogFont.lfWidth = 0;\n-        matchedLogFont.lfEscapement = rotation;\n-        matchedLogFont.lfOrientation = rotation;\n-        matchedLogFont.lfUnderline = 0;\n-        matchedLogFont.lfStrikeOut = 0;\n-\n-        \/* Force bold or italic if requested. The font name\n-           such as Arial Bold may have already set a weight\n-           so here we just try to increase it.\n-        *\/\n-        if (isBold) {\n-            matchedLogFont.lfWeight = embolden(matchedLogFont.lfWeight);\n-        } else {\n-            matchedLogFont.lfWeight = FW_REGULAR;\n-        }\n-\n-        if (isItalic) {\n-            matchedLogFont.lfItalic = 0xff;     \/\/ TRUE\n-        }  else {\n-            matchedLogFont.lfItalic = FALSE;\n-        }\n-\n-        HFONT font = CreateFontIndirectA(&matchedLogFont);\n-        if (font) {\n-            HFONT oldFont = (HFONT)::SelectObject(printDC, font);\n-            if (oldFont != NULL) {\n-                ::DeleteObject(oldFont);\n-                if (awScale != 1.0) {\n-                    TEXTMETRIC tm;\n-                    DWORD avgWidth;\n-                    GetTextMetrics(printDC, &tm);\n-                    avgWidth = tm.tmAveCharWidth;\n-                    matchedLogFont.lfWidth = (LONG)((fabs)(avgWidth*awScale));\n-                    font = CreateFontIndirectA(&matchedLogFont);\n-                    if (font) {\n-                        oldFont = (HFONT)::SelectObject(printDC, font);\n-                        if (oldFont != NULL) {\n-                            ::DeleteObject(oldFont);\n-                            GetTextMetrics(printDC, &tm);\n-                        } else {\n-                            foundFont = false;\n-                        }\n-                    } else {\n-                        foundFont = false;\n-                    }\n-                }\n-            } else {\n-                foundFont = false;\n-            }\n-        } else {\n-            foundFont = false;\n-        }\n-    }\n-\n-    JNU_ReleaseStringPlatformChars(env, fontName, fontNameW);\n-\n-    return foundFont ? JNI_TRUE : JNI_FALSE;\n-}\n-\n@@ -2515,23 +2435,0 @@\n-    if (matchedLogFont != NULL) {\n-        *matchedLogFont = logfont->elfLogFont;\n-    }\n-\n-    return stop;\n-}\n-\n-\/**\n- * Invoked by GDI as a result of the EnumFontFamiliesExA\n- * call this routine choses a GDI font that matches\n- * a Java font. When a match is found then function\n- * returns a zero result to terminate the EnumFontFamiliesExA\n- * call. The information about the chosen font is copied into\n- * the LOGFONTA structure pointed to by 'lParam'.\n- *\/\n-static int CALLBACK fontEnumProcA(ENUMLOGFONTEXA *logfont,\/\/ logical-font data\n-                    NEWTEXTMETRICEX *lpntme,              \/\/ physical-font data\n-                    int FontType,                         \/\/ type of font\n-                    LPARAM lParam)\n-{\n-    LOGFONTA *matchedLogFont = (LOGFONTA *) lParam;\n-    int stop = 0;          \/\/ Take the first style found.\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":113,"deletions":216,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+jmethodID AwtTextComponent::canAccessClipboardMID;\n+AwtTextComponent::OleCallback AwtTextComponent::sm_oleCallback;\n+WNDPROC AwtTextComponent::sm_pDefWindowProc = NULL;\n+\n@@ -60,2 +64,0 @@\n-jmethodID AwtTextComponent::canAccessClipboardMID;\n-\n@@ -914,2 +916,0 @@\n-AwtTextComponent::OleCallback AwtTextComponent::sm_oleCallback;\n-\n@@ -1043,2 +1043,0 @@\n-WNDPROC AwtTextComponent::sm_pDefWindowProc = NULL;\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_TextComponent.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -914,14 +914,0 @@\n-      case WM_AWT_EXECUTE_SYNC: {\n-          jobject peerObject = (jobject)wParam;\n-          AwtObject* object = (AwtObject *)JNI_GET_PDATA(peerObject);\n-          DASSERT( !IsBadReadPtr(object, sizeof(AwtObject)));\n-          AwtObject::ExecuteArgs *args = (AwtObject::ExecuteArgs *)lParam;\n-          DASSERT(!IsBadReadPtr(args, sizeof(AwtObject::ExecuteArgs)));\n-          LRESULT result = 0;\n-          if (object != NULL)\n-          {\n-              result = object->WinThreadExecProc(args);\n-          }\n-          env->DeleteGlobalRef(peerObject);\n-          return result;\n-      }\n@@ -1283,4 +1269,0 @@\n-      case WM_AWT_SETCURSOR: {\n-          ::SetCursor((HCURSOR)wParam);\n-          return TRUE;\n-      }\n@@ -1972,6 +1954,0 @@\n-void AwtToolkit::SetHeapCheck(long flag) {\n-    if (flag) {\n-        printf(\"heap checking not supported with this build\\n\");\n-    }\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -416,1 +416,0 @@\n-    INLINE void SetHeapCheck(long flag);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -715,10 +715,0 @@\n-\/**\n- * Disables offscreen acceleration for this device.  This\n- * sets a flag in the java object that is used to determine\n- * whether offscreen surfaces can be created on the device.\n- *\/\n-void AwtWin32GraphicsDevice::DisableOffscreenAcceleration()\n-{\n-    \/\/ REMIND: noop for now\n-}\n-\n@@ -738,1 +728,0 @@\n-    DisableOffscreenAcceleration();\n@@ -805,16 +794,0 @@\n-void AwtWin32GraphicsDevice::DisableOffscreenAccelerationForDevice(\n-    HMONITOR hMonitor)\n-{\n-    Devices::InstanceAccess devices;\n-    if (hMonitor == NULL) {\n-        devices->GetDevice(0)->DisableOffscreenAcceleration();\n-    } else {\n-        int devicesNum = devices->GetNumDevices();\n-        for (int i = 0; i < devicesNum; ++i) {\n-            if (devices->GetDevice(i)->GetMonitor() == hMonitor) {\n-                devices->GetDevice(i)->DisableOffscreenAcceleration();\n-            }\n-        }\n-    }\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsDevice.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,0 @@\n-    void                    DisableOffscreenAcceleration();\n@@ -99,1 +98,0 @@\n-    static void             DisableOffscreenAccelerationForDevice(HMONITOR hMonitor);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsDevice.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1022,1 +1022,1 @@\n-        (RepositionSecurityWarningStruct *)param;\n+        static_cast<RepositionSecurityWarningStruct *>(param);\n@@ -1025,3 +1025,16 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    AwtWindow *window = NULL;\n+\n+    if (self == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"self\");\n+        delete rsws;\n+        return;\n+    } else {\n+        window = (AwtWindow *)JNI_GET_PDATA(self);\n+        if (window == NULL) {\n+            THROW_NULL_PDATA_IF_NOT_DESTROYED(self);\n+            env->DeleteGlobalRef(self);\n+            delete rsws;\n+            return;\n+        }\n+    }\n@@ -1031,1 +1044,0 @@\n-  ret:\n@@ -3119,1 +3131,1 @@\n-    ModalDisableStruct *mds = (ModalDisableStruct *)param;\n+    ModalDisableStruct *mds = static_cast<ModalDisableStruct *>(param);\n@@ -3126,4 +3138,3 @@\n-    JNI_CHECK_NULL_GOTO(self, \"peer\", ret);\n-    PDATA pData = JNI_GET_PDATA(self);\n-    if (pData == NULL) {\n-        env->DeleteGlobalRef(self);\n+    if (self == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"self\");\n@@ -3132,0 +3143,7 @@\n+    } else {\n+        window = (AwtWindow *)JNI_GET_PDATA(self);\n+        if (window == NULL) {\n+            env->DeleteGlobalRef(self);\n+            delete mds;\n+            return;\n+        }\n@@ -3134,1 +3152,0 @@\n-    window = (AwtWindow *)pData;\n@@ -3140,1 +3157,0 @@\n-ret:\n@@ -3150,1 +3166,1 @@\n-    jobject self = (jobject)param;\n+    jobject self = static_cast<jobject>(param);\n@@ -3155,4 +3171,3 @@\n-    JNI_CHECK_NULL_GOTO(self, \"peer\", ret);\n-    PDATA pData = JNI_GET_PDATA(self);\n-    if (pData == NULL) {\n-        env->DeleteGlobalRef(self);\n+    if (self == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"self\");\n@@ -3160,0 +3175,6 @@\n+    } else {\n+        window = (AwtWindow *)JNI_GET_PDATA(self);\n+        if (window == NULL) {\n+            env->DeleteGlobalRef(self);\n+            return;\n+        }\n@@ -3162,1 +3183,0 @@\n-    window = (AwtWindow *)pData;\n@@ -3168,1 +3188,0 @@\n-  ret:\n@@ -3176,1 +3195,1 @@\n-    OpacityStruct *os = (OpacityStruct *)param;\n+    OpacityStruct *os = static_cast<OpacityStruct *>(param);\n@@ -3180,3 +3199,16 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    AwtWindow *window = NULL;\n+\n+    if (self == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"self\");\n+        delete os;\n+        return;\n+    } else {\n+        window = (AwtWindow *)JNI_GET_PDATA(self);\n+        if (window == NULL) {\n+            THROW_NULL_PDATA_IF_NOT_DESTROYED(self);\n+            env->DeleteGlobalRef(self);\n+            delete os;\n+            return;\n+        }\n+    }\n@@ -3186,1 +3218,0 @@\n-  ret:\n@@ -3195,1 +3226,1 @@\n-    OpaqueStruct *os = (OpaqueStruct *)param;\n+    OpaqueStruct *os = static_cast<OpaqueStruct *>(param);\n@@ -3199,3 +3230,16 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    AwtWindow *window = NULL;\n+\n+    if (self == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"self\");\n+        delete os;\n+        return;\n+    } else {\n+        window = (AwtWindow *)JNI_GET_PDATA(self);\n+        if (window == NULL) {\n+            THROW_NULL_PDATA_IF_NOT_DESTROYED(self);\n+            env->DeleteGlobalRef(self);\n+            delete os;\n+            return;\n+        }\n+    }\n@@ -3205,1 +3249,0 @@\n-  ret:\n@@ -3214,1 +3257,1 @@\n-    UpdateWindowStruct *uws = (UpdateWindowStruct *)param;\n+    UpdateWindowStruct *uws = static_cast<UpdateWindowStruct *>(param);\n@@ -3218,3 +3261,22 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    AwtWindow *window = NULL;\n+\n+    if (self == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"self\");\n+        if (data != NULL) {\n+            env->DeleteGlobalRef(data);\n+        }\n+        delete uws;\n+        return;\n+    } else {\n+        window = (AwtWindow *)JNI_GET_PDATA(self);\n+        if (window == NULL) {\n+            THROW_NULL_PDATA_IF_NOT_DESTROYED(self);\n+            env->DeleteGlobalRef(self);\n+            if (data != NULL) {\n+                env->DeleteGlobalRef(data);\n+            }\n+            delete uws;\n+            return;\n+        }\n+    }\n@@ -3225,1 +3287,0 @@\n-  ret:\n@@ -3242,3 +3303,16 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    AwtWindow *window = NULL;\n+\n+    if (self == NULL) {\n+        env->ExceptionClear();\n+        JNU_ThrowNullPointerException(env, \"self\");\n+        delete data;\n+        return;\n+    } else {\n+        window = (AwtWindow *)JNI_GET_PDATA(self);\n+        if (window == NULL) {\n+            THROW_NULL_PDATA_IF_NOT_DESTROYED(self);\n+            env->DeleteGlobalRef(self);\n+            delete data;\n+            return;\n+        }\n+    }\n@@ -3248,1 +3322,0 @@\n-  ret:\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.cpp","additions":111,"deletions":38,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,11 +183,0 @@\n-struct OLEHolder\n-{\n-    OLEHolder()\n-    : m_hr(::OleInitialize(NULL))\n-    {}\n-\n-    ~OLEHolder(){}\n-    operator bool() const { return S_OK==SUCCEEDED(m_hr); }\n-    HRESULT m_hr;\n-};\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_ole.h","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,1 +212,0 @@\n-    WM_AWT_PRINT_COMPONENT,\n@@ -218,2 +217,0 @@\n-    WM_AWT_FORWARD_BYTE,\n-    WM_AWT_SET_SCROLL_INFO,\n@@ -225,7 +222,0 @@\n-    WM_AWT_PRE_KEYDOWN,\n-    WM_AWT_PRE_KEYUP,\n-    WM_AWT_PRE_SYSKEYDOWN,\n-    WM_AWT_PRE_SYSKEYUP,\n-\n-    \/* deleted DND mesg's *\/\n-\n@@ -244,1 +234,0 @@\n-    WM_AWT_SETCURSOR,\n@@ -248,1 +237,0 @@\n-    WM_AWT_EXECUTE_SYNC,\n@@ -251,1 +239,0 @@\n-    WM_AWT_CURSOR_SYNC,\n@@ -255,2 +242,0 @@\n-    WM_AWT_SHOWCURSOR,\n-    WM_AWT_HIDECURSOR,\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awtmsg.h","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,5 @@\n+ * <p>JMX Subject Delegation has been removed. All methods that take a\n+ * {@code delegationSubject} parameter will throw {@code UnsupportedOperationException}\n+ * if it is non-null. This parameter is kept for interoperability with older\n+ * remote clients.\n+ *\n@@ -126,3 +131,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -155,2 +158,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -158,0 +161,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -178,3 +182,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -209,2 +211,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -212,0 +214,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -241,3 +244,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -270,2 +271,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -273,0 +274,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -304,3 +306,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -335,2 +335,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -338,0 +338,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -359,3 +360,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -373,2 +372,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -376,0 +375,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -388,3 +388,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -402,1 +400,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -405,0 +404,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -423,3 +423,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -431,2 +429,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -434,0 +432,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -454,3 +453,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -462,2 +459,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -465,0 +462,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -477,3 +475,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -487,2 +483,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -490,0 +486,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -498,3 +495,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -504,2 +499,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -507,0 +502,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -520,3 +516,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -541,2 +535,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -544,0 +538,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -565,3 +560,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -578,2 +571,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -581,0 +574,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -603,3 +597,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -622,2 +614,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -625,0 +617,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -650,3 +643,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -664,2 +655,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -667,0 +658,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -696,3 +688,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -710,2 +700,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -716,0 +706,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -732,3 +723,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -738,2 +727,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -741,0 +730,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -749,3 +739,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -755,2 +743,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -758,0 +746,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -767,3 +756,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -780,2 +767,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -786,0 +773,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -801,3 +789,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -810,2 +796,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -816,0 +802,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -842,3 +829,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -854,2 +839,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -857,0 +842,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -877,3 +863,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -885,2 +869,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -891,0 +875,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -918,3 +903,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -927,2 +910,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to perform this operation.\n+     * @throws SecurityException if the client does not have permission\n+     * to perform this operation.\n@@ -933,0 +916,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -975,6 +959,1 @@\n-     * @param delegationSubjects the <code>Subjects<\/code> on behalf\n-     * of which the listeners are being added.  Elements of this array\n-     * can be null.  Also, the <code>delegationSubjects<\/code>\n-     * parameter itself can be null, which is equivalent to an array\n-     * of null values with the same size as the <code>names<\/code> and\n-     * <code>filters<\/code> arrays.\n+     * @param delegationSubjects must be {@code null}.\n@@ -996,2 +975,1 @@\n-     * client, or the delegated Subject if any, does not have\n-     * permission to add a listener.\n+     * client does not have permission to add a listener.\n@@ -999,0 +977,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n@@ -1025,3 +1004,1 @@\n-     * @param delegationSubject The <code>Subject<\/code> containing the\n-     * delegation principals or <code>null<\/code> if the authentication\n-     * principal is used instead.\n+     * @param delegationSubject must be {@code null}.\n@@ -1035,2 +1012,2 @@\n-     * @throws SecurityException if the client, or the delegated Subject\n-     * if any, does not have permission to remove the listeners.\n+     * @throws SecurityException if the client does not have permission\n+     * to remove the listeners.\n@@ -1041,0 +1018,1 @@\n+     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnection.java","additions":101,"deletions":123,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-import com.sun.jmx.remote.security.SubjectDelegator;\n@@ -113,1 +112,0 @@\n-        this.subjectDelegator = new SubjectDelegator();\n@@ -117,1 +115,0 @@\n-            this.removeCallerContext = false;\n@@ -119,9 +116,3 @@\n-            this.removeCallerContext =\n-                SubjectDelegator.checkRemoveCallerContext(subject);\n-            if (this.removeCallerContext) {\n-                this.acc =\n-                    JMXSubjectDomainCombiner.getDomainCombinerContext(subject);\n-            } else {\n-                this.acc =\n-                    JMXSubjectDomainCombiner.getContext(subject);\n-            }\n+            \/\/ An authenticated Subject was provided.\n+            \/\/ Subject Delegation has been removed.\n+            this.acc = JMXSubjectDomainCombiner.getContext(subject);\n@@ -239,0 +230,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -281,0 +273,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -329,0 +322,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -389,0 +383,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -456,0 +451,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -484,0 +480,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -514,0 +511,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -549,0 +547,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -584,0 +583,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -601,0 +601,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -622,0 +623,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -659,0 +661,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -691,0 +694,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -744,0 +748,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -790,0 +795,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -847,0 +853,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -868,0 +875,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -888,0 +896,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -923,0 +932,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -953,0 +963,2 @@\n+\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -962,3 +974,4 @@\n-\n-        Subject[] sbjs = (delegationSubjects != null) ? delegationSubjects :\n-        new Subject[names.length];\n+        if (delegationSubjects != null) {\n+            throw new UnsupportedOperationException(\"Subject Delegation has been removed.\");\n+        }\n+        Subject[] sbjs = new Subject[names.length];\n@@ -1040,0 +1053,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -1099,0 +1113,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -1140,0 +1155,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -1176,0 +1192,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -1378,0 +1395,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -1384,0 +1402,5 @@\n+        \/\/ Subject Delegation is removed: locally this is caught earlier, in getMBeanServerConnection,\n+        \/\/ but remote connections call into RMIConnectionImpl over RMI, so deny them here:\n+        if (delegationSubject != null) {\n+            throw new UnsupportedOperationException(\"Subject Delegation has been removed.\");\n+        }\n@@ -1386,18 +1409,2 @@\n-\n-            final AccessControlContext reqACC;\n-            if (delegationSubject == null)\n-                reqACC = acc;\n-            else {\n-                if (subject == null) {\n-                    final String msg =\n-                        \"Subject delegation cannot be enabled unless \" +\n-                        \"an authenticated subject is put in place\";\n-                    throw new SecurityException(msg);\n-                }\n-                reqACC = subjectDelegator.delegatedContext(\n-                    acc, delegationSubject, removeCallerContext);\n-            }\n-\n-            PrivilegedOperation op =\n-                new PrivilegedOperation(operation, params);\n-            if (reqACC == null) {\n+            PrivilegedOperation op = new PrivilegedOperation(operation, params);\n+            if (acc == null) {\n@@ -1412,1 +1419,1 @@\n-                return AccessController.doPrivileged(op, reqACC);\n+                return AccessController.doPrivileged(op, acc);\n@@ -1566,0 +1573,6 @@\n+\n+        \/\/ Subject Delegation is removed: locally this is caught earlier, in getMBeanServerConnection,\n+        \/\/ but remote connections call into RMIConnectionImpl over RMI, so deny them here:\n+        if (delegationSubject != null) {\n+            throw new UnsupportedOperationException(\"Subject Delegation has been removed.\");\n+        }\n@@ -1572,14 +1585,1 @@\n-                final AccessControlContext reqACC;\n-                if (delegationSubject == null)\n-                    reqACC = acc;\n-                else {\n-                    if (subject == null) {\n-                        final String msg =\n-                            \"Subject delegation cannot be enabled unless \" +\n-                            \"an authenticated subject is put in place\";\n-                        throw new SecurityException(msg);\n-                    }\n-                    reqACC = subjectDelegator.delegatedContext(\n-                        acc, delegationSubject, removeCallerContext);\n-                }\n-                if(reqACC != null){\n+                if (acc != null) {\n@@ -1588,1 +1588,1 @@\n-                                    wrappedClass.cast(mo.get()), reqACC);\n+                                    wrappedClass.cast(mo.get()), acc);\n@@ -1707,4 +1707,0 @@\n-    private final SubjectDelegator subjectDelegator;\n-\n-    private final boolean removeCallerContext;\n-\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnectionImpl.java","additions":50,"deletions":54,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,0 +117,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -133,0 +134,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -164,0 +166,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -187,0 +190,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -212,0 +216,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -237,0 +242,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -278,0 +284,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -301,0 +308,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -335,0 +343,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -350,0 +359,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -365,0 +375,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -380,0 +391,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -401,0 +413,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -418,0 +431,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -439,0 +453,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -456,0 +471,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -471,0 +487,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -486,0 +503,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -501,0 +519,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -519,0 +538,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -537,0 +557,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -555,0 +576,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -579,0 +601,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n@@ -598,0 +621,1 @@\n+    \/** @throws UnsupportedOperationException {@inheritDoc} *\/\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnectionImpl_Stub.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -388,10 +388,1 @@\n-    public synchronized MBeanServerConnection getMBeanServerConnection()\n-    throws IOException {\n-        return getMBeanServerConnection(null);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    public synchronized MBeanServerConnection\n-            getMBeanServerConnection(Subject delegationSubject)\n-            throws IOException {\n-\n+    public synchronized MBeanServerConnection getMBeanServerConnection() throws IOException {\n@@ -409,2 +400,1 @@\n-\n-        return getConnectionWithSubject(delegationSubject);\n+        return getConnection();\n@@ -519,4 +509,0 @@\n-        \/\/ Clean up MBeanServerConnection table\n-        \/\/\n-        rmbscMap.clear();\n-\n@@ -566,3 +552,0 @@\n-        final Subject[] delegationSubjects = new Subject[] {\n-            delegationSubject\n-        };\n@@ -571,1 +554,1 @@\n-                addListenersWithSubjects(names,filters,delegationSubjects,\n+                addListenersWithSubjects(names,filters,null,\n@@ -597,1 +580,1 @@\n-                    delegationSubjects);\n+                    null);\n@@ -605,1 +588,1 @@\n-                        delegationSubjects);\n+                        null);\n@@ -626,1 +609,0 @@\n-        private Subject delegationSubject;\n@@ -629,5 +611,0 @@\n-            this(null);\n-        }\n-\n-        public RemoteMBeanServerConnection(Subject delegationSubject) {\n-            this.delegationSubject = delegationSubject;\n@@ -653,1 +630,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -659,1 +636,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -687,1 +664,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -695,1 +672,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -725,1 +702,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -733,1 +710,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -765,1 +742,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -774,1 +751,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -789,1 +766,1 @@\n-                connection.unregisterMBean(name, delegationSubject);\n+                connection.unregisterMBean(name, null);\n@@ -793,1 +770,1 @@\n-                connection.unregisterMBean(name, delegationSubject);\n+                connection.unregisterMBean(name, null);\n@@ -807,1 +784,1 @@\n-                return connection.getObjectInstance(name, delegationSubject);\n+                return connection.getObjectInstance(name, null);\n@@ -811,1 +788,1 @@\n-                return connection.getObjectInstance(name, delegationSubject);\n+                return connection.getObjectInstance(name, null);\n@@ -827,1 +804,1 @@\n-                return connection.queryMBeans(name, sQuery, delegationSubject);\n+                return connection.queryMBeans(name, sQuery, null);\n@@ -831,1 +808,1 @@\n-                return connection.queryMBeans(name, sQuery, delegationSubject);\n+                return connection.queryMBeans(name, sQuery, null);\n@@ -847,1 +824,1 @@\n-                return connection.queryNames(name, sQuery, delegationSubject);\n+                return connection.queryNames(name, sQuery, null);\n@@ -851,1 +828,1 @@\n-                return connection.queryNames(name, sQuery, delegationSubject);\n+                return connection.queryNames(name, sQuery, null);\n@@ -864,1 +841,1 @@\n-                return connection.isRegistered(name, delegationSubject);\n+                return connection.isRegistered(name, null);\n@@ -868,1 +845,1 @@\n-                return connection.isRegistered(name, delegationSubject);\n+                return connection.isRegistered(name, null);\n@@ -880,1 +857,1 @@\n-                return connection.getMBeanCount(delegationSubject);\n+                return connection.getMBeanCount(null);\n@@ -884,1 +861,1 @@\n-                return connection.getMBeanCount(delegationSubject);\n+                return connection.getMBeanCount(null);\n@@ -905,1 +882,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -911,1 +888,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -930,1 +907,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -937,1 +914,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -961,1 +938,1 @@\n-                connection.setAttribute(name, sAttribute, delegationSubject);\n+                connection.setAttribute(name, sAttribute, null);\n@@ -965,1 +942,1 @@\n-                connection.setAttribute(name, sAttribute, delegationSubject);\n+                connection.setAttribute(name, sAttribute, null);\n@@ -989,1 +966,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -995,1 +972,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1024,1 +1001,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1032,1 +1009,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1045,1 +1022,1 @@\n-                return connection.getDefaultDomain(delegationSubject);\n+                return connection.getDefaultDomain(null);\n@@ -1049,1 +1026,1 @@\n-                return connection.getDefaultDomain(delegationSubject);\n+                return connection.getDefaultDomain(null);\n@@ -1060,1 +1037,1 @@\n-                return connection.getDomains(delegationSubject);\n+                return connection.getDomains(null);\n@@ -1064,1 +1041,1 @@\n-                return connection.getDomains(delegationSubject);\n+                return connection.getDomains(null);\n@@ -1079,1 +1056,1 @@\n-                return connection.getMBeanInfo(name, delegationSubject);\n+                return connection.getMBeanInfo(name, null);\n@@ -1083,1 +1060,1 @@\n-                return connection.getMBeanInfo(name, delegationSubject);\n+                return connection.getMBeanInfo(name, null);\n@@ -1102,1 +1079,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1108,1 +1085,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1137,1 +1114,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1145,1 +1122,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1166,1 +1143,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1172,1 +1149,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1203,1 +1180,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1211,1 +1188,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1240,1 +1217,1 @@\n-                    delegationSubject,true);\n+                    null, true);\n@@ -1242,2 +1219,1 @@\n-                    filter, handback,\n-                    delegationSubject);\n+                    filter, handback);\n@@ -1270,1 +1246,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1276,1 +1252,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1312,1 +1288,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1318,1 +1294,1 @@\n-                        delegationSubject);\n+                        null);\n@@ -1436,1 +1412,0 @@\n-            final Subject[] subjects = new Subject[] {null};\n@@ -1441,1 +1416,1 @@\n-                        subjects);\n+                        null);\n@@ -1449,1 +1424,1 @@\n-                        subjects);\n+                        null);\n@@ -1567,1 +1542,0 @@\n-            final Subject[] subjects = new Subject[len];\n@@ -1576,1 +1550,0 @@\n-                subjects[i]  = old[i].getDelegationSubject();\n@@ -1585,1 +1558,1 @@\n-                Integer[] ids = addListenersWithSubjects(names,mFilters,subjects,false);\n+                Integer[] ids = addListenersWithSubjects(names,mFilters,null,false);\n@@ -1592,2 +1565,1 @@\n-                            handbacks[i],\n-                            subjects[i]);\n+                            handbacks[i]);\n@@ -1608,1 +1580,1 @@\n-                            subjects[i],\n+                            null,\n@@ -1615,2 +1587,1 @@\n-                            handbacks[i],\n-                            subjects[i]);\n+                            handbacks[i]);\n@@ -1748,1 +1719,0 @@\n-        rmbscMap = new WeakHashMap<Subject, WeakReference<MBeanServerConnection>>();\n@@ -1896,1 +1866,1 @@\n-    private MBeanServerConnection getConnectionWithSubject(Subject delegationSubject) {\n+    private MBeanServerConnection getConnection() {\n@@ -1899,12 +1869,4 @@\n-        if (delegationSubject == null) {\n-            if (nullSubjectConnRef == null\n-                    || (conn = nullSubjectConnRef.get()) == null) {\n-                conn = new RemoteMBeanServerConnection(null);\n-                nullSubjectConnRef = new WeakReference<MBeanServerConnection>(conn);\n-            }\n-        } else {\n-            WeakReference<MBeanServerConnection> wr = rmbscMap.get(delegationSubject);\n-            if (wr == null || (conn = wr.get()) == null) {\n-                conn = new RemoteMBeanServerConnection(delegationSubject);\n-                rmbscMap.put(delegationSubject, new WeakReference<MBeanServerConnection>(conn));\n-            }\n+        if (nullSubjectConnRef == null\n+                || (conn = nullSubjectConnRef.get()) == null) {\n+            conn = new RemoteMBeanServerConnection();\n+            nullSubjectConnRef = new WeakReference<MBeanServerConnection>(conn);\n@@ -2282,1 +2244,0 @@\n-    private transient WeakHashMap<Subject, WeakReference<MBeanServerConnection>> rmbscMap;\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnector.java","additions":67,"deletions":106,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,0 @@\n-import javax.security.auth.Subject;\n-\n-\n@@ -46,2 +43,1 @@\n-                              Object handback,\n-                              Subject delegationSubject) {\n+                              Object handback) {\n@@ -53,1 +49,0 @@\n-        this.delegationSubject = delegationSubject;\n@@ -76,5 +71,0 @@\n-    public Subject getDelegationSubject() {\n-        return delegationSubject;\n-    }\n-\n-\n@@ -105,1 +95,0 @@\n-    private final Subject delegationSubject;\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ClientListenerInfo.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,2 +170,1 @@\n-                                        Object handback,\n-                                        Subject delegationSubject)\n+                                        Object handback)\n@@ -184,3 +183,1 @@\n-                                            handback,\n-                                            delegationSubject));\n-\n+                                            handback));\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ClientNotifForwarder.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.jmx.remote.security;\n-\n-import java.security.AccessController;\n-import java.security.AccessControlContext;\n-import java.security.Permission;\n-import java.security.Principal;\n-import java.security.PrivilegedAction;\n-import javax.security.auth.Subject;\n-\n-import javax.management.remote.SubjectDelegationPermission;\n-\n-import java.util.*;\n-\n-public class SubjectDelegator {\n-    \/* Return the AccessControlContext appropriate to execute an\n-       operation on behalf of the delegatedSubject.  If the\n-       authenticatedAccessControlContext does not have permission to\n-       delegate to that subject, throw SecurityException.  *\/\n-    @SuppressWarnings(\"removal\")\n-    public AccessControlContext\n-        delegatedContext(AccessControlContext authenticatedACC,\n-                         Subject delegatedSubject,\n-                         boolean removeCallerContext)\n-            throws SecurityException {\n-\n-        if (System.getSecurityManager() != null && authenticatedACC == null) {\n-            throw new SecurityException(\"Illegal AccessControlContext: null\");\n-        }\n-\n-        \/\/ Check if the subject delegation permission allows the\n-        \/\/ authenticated subject to assume the identity of each\n-        \/\/ principal in the delegated subject\n-        \/\/\n-        Collection<Principal> ps = getSubjectPrincipals(delegatedSubject);\n-        final Collection<Permission> permissions = new ArrayList<>(ps.size());\n-        for(Principal p : ps) {\n-            final String pname = p.getClass().getName() + \".\" + p.getName();\n-            permissions.add(new SubjectDelegationPermission(pname));\n-        }\n-        PrivilegedAction<Void> action =\n-            new PrivilegedAction<>() {\n-                public Void run() {\n-                    for (Permission sdp : permissions) {\n-                        AccessController.checkPermission(sdp);\n-                    }\n-                    return null;\n-                }\n-            };\n-        AccessController.doPrivileged(action, authenticatedACC);\n-\n-        return getDelegatedAcc(delegatedSubject, removeCallerContext);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private AccessControlContext getDelegatedAcc(Subject delegatedSubject, boolean removeCallerContext) {\n-        if (removeCallerContext) {\n-            return JMXSubjectDomainCombiner.getDomainCombinerContext(delegatedSubject);\n-        } else {\n-            return JMXSubjectDomainCombiner.getContext(delegatedSubject);\n-        }\n-    }\n-\n-    \/**\n-     * Check if the connector server creator can assume the identity of each\n-     * principal in the authenticated subject, i.e. check if the connector\n-     * server creator codebase contains a subject delegation permission for\n-     * each principal present in the authenticated subject.\n-     *\n-     * @return {@code true} if the connector server creator can delegate to all\n-     * the authenticated principals in the subject. Otherwise, {@code false}.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public static synchronized boolean\n-        checkRemoveCallerContext(Subject subject) {\n-        try {\n-            for (Principal p : getSubjectPrincipals(subject)) {\n-                final String pname =\n-                    p.getClass().getName() + \".\" + p.getName();\n-                final Permission sdp =\n-                    new SubjectDelegationPermission(pname);\n-                AccessController.checkPermission(sdp);\n-            }\n-        } catch (SecurityException e) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Retrieves the {@linkplain Subject} principals\n-     * @param subject The subject\n-     * @return If the {@code Subject} is immutable it will return the principals directly.\n-     *         If the {@code Subject} is mutable it will create an unmodifiable copy.\n-     *\/\n-    private static Collection<Principal> getSubjectPrincipals(Subject subject) {\n-        if (subject.isReadOnly()) {\n-            return subject.getPrincipals();\n-        }\n-\n-        List<Principal> principals = Arrays.asList(subject.getPrincipals().toArray(new Principal[0]));\n-        return Collections.unmodifiableList(principals);\n-    }\n-}\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/SubjectDelegator.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,6 +118,0 @@\n-     * <p>Calling this method is equivalent to calling\n-     * {@link #getMBeanServerConnection(Subject) getMBeanServerConnection(null)}\n-     * meaning that no delegation subject is specified and that all the\n-     * operations called on the <code>MBeanServerConnection<\/code> must\n-     * use the authenticated subject, if any.<\/p>\n-     *\n@@ -138,6 +132,2 @@\n-     * <p>Returns an <code>MBeanServerConnection<\/code> object representing\n-     * a remote MBean server on which operations are performed on behalf of\n-     * the supplied delegation subject. For a given <code>JMXConnector<\/code>\n-     * and <code>Subject<\/code>, two successful calls to this method will\n-     * usually return the same <code>MBeanServerConnection<\/code> object,\n-     * though this is not required.<\/p>\n+     * <p>When {@code delegationSubject} is {@code null}, calling his method\n+     * is equivalent to calling {@link #getMBeanServerConnection()}.\n@@ -145,12 +135,3 @@\n-     * <p>For each method in the returned\n-     * <code>MBeanServerConnection<\/code>, calling the method causes\n-     * the corresponding method to be called in the remote MBean\n-     * server on behalf of the given delegation subject instead of the\n-     * authenticated subject. The value returned by the MBean server\n-     * method is the value returned to the client. If the MBean server\n-     * method produces an <code>Exception<\/code>, the same\n-     * <code>Exception<\/code> is seen by the client. If the MBean\n-     * server method, or the attempt to call it, produces an\n-     * <code>Error<\/code>, the <code>Error<\/code> is wrapped in a\n-     * {@link JMXServerErrorException}, which is seen by the\n-     * client.<\/p>\n+     * @implSpec The default implementation of this method throws\n+     * {@code UnsupportedOperationException} if {@code delegationSubject} is\n+     * non-null. Otherwise it calls {@link getMBeanServerConnection()}.\n@@ -158,4 +139,1 @@\n-     * @param delegationSubject the <code>Subject<\/code> on behalf of\n-     * which requests will be performed.  Can be null, in which case\n-     * requests will be performed on behalf of the authenticated\n-     * Subject, if any.\n+     * @param delegationSubject must be {@code null}.\n@@ -164,2 +142,1 @@\n-     * interface by forwarding its methods to the remote MBean server on behalf\n-     * of a given delegation subject.\n+     * interface by forwarding its methods to the remote MBean server.\n@@ -172,0 +149,2 @@\n+     * @exception UnsupportedOperationException if {@code delegationSubject} is non-null.\n+     *\n@@ -173,3 +152,1 @@\n-     * and is only useful in conjunction with other APIs which are deprecated and\n-     * subject to removal in a future release. Consequently, this method is also\n-     * deprecated and subject to removal. There is no replacement.\n+     * which has been removed.  There is no replacement.\n@@ -178,3 +155,8 @@\n-    public MBeanServerConnection getMBeanServerConnection(\n-                                               Subject delegationSubject)\n-            throws IOException;\n+    public default MBeanServerConnection getMBeanServerConnection(Subject delegationSubject)\n+            throws IOException {\n+\n+        if (delegationSubject != null) {\n+            throw new UnsupportedOperationException(\"Subject Delegation has been removed.\");\n+        }\n+        return getMBeanServerConnection();\n+    }\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/JMXConnector.java","additions":19,"deletions":37,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1044,1 +1044,1 @@\n-        EXCEPTION_CHECK(\"Getting ParentWithRole - call to CallObjectMethod()\", (AccessibleContext)0);\n+        EXCEPTION_CHECK(\"Getting ParentWithRole - call to CallObjectMethod()\", reinterpret_cast<jobject>((AccessibleContext)0));\n@@ -1114,1 +1114,1 @@\n-        EXCEPTION_CHECK(\"Getting ParentWithRoleElseRoot - call to CallObjectMethod()\", (AccessibleContext)0);\n+        EXCEPTION_CHECK(\"Getting ParentWithRoleElseRoot - call to CallObjectMethod()\", reinterpret_cast<jobject>((AccessibleContext)0));\n@@ -1171,1 +1171,1 @@\n-        EXCEPTION_CHECK(\"Getting ActiveDescendent - call to CallObjectMethod()\", (AccessibleContext)0);\n+        EXCEPTION_CHECK(\"Getting ActiveDescendent - call to CallObjectMethod()\", reinterpret_cast<jobject>((AccessibleContext)0));\n@@ -1180,1 +1180,1 @@\n-        return (AccessibleContext)0;\n+        return reinterpret_cast<jobject>((AccessibleContext)0);\n","filename":"src\/jdk.accessibility\/windows\/native\/libjavaaccessbridge\/AccessBridgeJavaEntryPoints.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1997,1 +1997,2 @@\n-            long flags = flags();\n+            \/\/ just in case the method is restricted but that is not a modifier\n+            long flags = flags() & ~RESTRICTED;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -331,7 +331,0 @@\n-    \/** The current `this' symbol.\n-     *  @param env    The current environment.\n-     *\/\n-    Symbol thisSym(DiagnosticPosition pos, Env<AttrContext> env) {\n-        return rs.resolveSelf(pos, env, env.enclClass.sym, names._this);\n-    }\n-\n@@ -964,4 +957,4 @@\n-                \/\/ If this class appears as an anonymous class in a constructor\n-                \/\/ prologue, disable implicit outer instance from being passed.\n-                \/\/ (This would be an illegal access to \"this before super\").\n-                if (ctorProloguePrev && env.tree.hasTag(NEWCLASS)) {\n+                \/\/ If a class declaration appears in a constructor prologue,\n+                \/\/ that means it's either a local class or an anonymous class.\n+                \/\/ Either way, there is no immediately enclosing instance.\n+                if (ctorProloguePrev) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1846,1 +1846,0 @@\n-            Assert.error();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic;\n@@ -396,1 +395,1 @@\n-            Type seltype = selector.type.hasTag(BOT)\n+            Type seltype = selector.type.hasTag(BOT) || target.usesReferenceOnlySelectorTypes()\n@@ -499,1 +498,0 @@\n-            boolean primitiveSelector = seltype.isPrimitive();\n@@ -504,1 +502,0 @@\n-            Type resolvedSelectorType = seltype;\n@@ -506,1 +503,1 @@\n-                    List.of(resolvedSelectorType, syms.intType),\n+                    List.of(seltype, syms.intType),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -229,0 +229,6 @@\n+\n+    \/** Releases prior to JDK 23 expect a less precise SwitchBootstraps.typeSwitch signature on the selectorType\n+     *\/\n+    public boolean usesReferenceOnlySelectorTypes() {\n+        return compareTo(Target.JDK1_23) < 0;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,0 @@\n-    dlerror(); \/* clear any old error message not fetched *\/\n@@ -127,3 +126,0 @@\n-    \/\/ clear any old error message not fetched\n-    dlerror();\n-\n@@ -161,1 +157,14 @@\n-    if (jGetFunctionList != NULL) {\n+    \/\/ if none specified, then we try 3.0 API first before trying 2.40\n+    if (jGetFunctionList == NULL) {\n+        C_GetInterface = (CK_C_GetInterface) dlsym(hModule, \"C_GetInterface\");\n+        if (C_GetInterface != NULL) {\n+            TRACE0(\"Connect: Found C_GetInterface func\\n\");\n+            rv = (C_GetInterface)(NULL, NULL, &interface, 0L);\n+            \/\/ don't use ckAssertReturnValueOK as we want to continue trying\n+            \/\/ C_GetFunctionList() or method named by \"getFunctionListStr\"\n+            if (rv == CKR_OK) {\n+                goto setModuleData;\n+            }\n+        }\n+        getFunctionListStr = \"C_GetFunctionList\";\n+    } else {\n@@ -167,1 +176,4 @@\n-        C_GetFunctionList = (CK_C_GetFunctionList) dlsym(hModule,\n+    }\n+\n+    dlerror(); \/\/ clear any old error message not fetched\n+    C_GetFunctionList = (CK_C_GetFunctionList) dlsym(hModule,\n@@ -169,0 +181,1 @@\n+    if (C_GetFunctionList == NULL) {\n@@ -170,0 +183,2 @@\n+            TRACE2(\"Connect: error finding %s func: %s\\n\", getFunctionListStr,\n+                systemErrorMessage);\n@@ -171,3 +186,1 @@\n-            goto cleanup;\n-        }\n-        if (C_GetFunctionList == NULL) {\n+        } else {\n@@ -176,1 +189,0 @@\n-            goto cleanup;\n@@ -178,23 +190,1 @@\n-        TRACE1(\"Connect: Found %s func\\n\", getFunctionListStr);\n-    } else {\n-        \/\/ if none specified, then we try 3.0 API first before trying 2.40\n-        C_GetInterface = (CK_C_GetInterface) dlsym(hModule, \"C_GetInterface\");\n-        if ((C_GetInterface != NULL) && (dlerror() == NULL)) {\n-            TRACE0(\"Connect: Found C_GetInterface func\\n\");\n-            rv = (C_GetInterface)(NULL, NULL, &interface, 0L);\n-            if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {\n-                goto setModuleData;\n-            }\n-        }\n-        C_GetFunctionList = (CK_C_GetFunctionList) dlsym(hModule,\n-                \"C_GetFunctionList\");\n-        if ((systemErrorMessage = dlerror()) != NULL){\n-            p11ThrowIOException(env, systemErrorMessage);\n-            goto cleanup;\n-        }\n-        if (C_GetFunctionList == NULL) {\n-            TRACE0(\"Connect: No C_GetFunctionList func\\n\");\n-            p11ThrowIOException(env, \"ERROR: C_GetFunctionList == NULL\");\n-            goto cleanup;\n-        }\n-        TRACE0(\"Connect: Found C_GetFunctionList func\\n\");\n+        goto cleanup;\n@@ -202,0 +192,1 @@\n+    TRACE1(\"Connect: Found %s func\\n\", getFunctionListStr);\n","filename":"src\/jdk.crypto.cryptoki\/unix\/native\/libj2pkcs11\/p11_md.c","additions":25,"deletions":34,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,3 @@\n-  private static AddressField  contentBeginField;\n-  private static AddressField  codeBeginField;\n-  private static AddressField  codeEndField;\n-  private static AddressField  dataEndField;\n+  private static CIntegerField relocationSizeField;\n+  private static CIntegerField contentOffsetField;\n+  private static CIntegerField codeOffsetField;\n@@ -66,0 +65,3 @@\n+    relocationSizeField      = type.getCIntegerField(\"_relocation_size\");\n+    contentOffsetField       = type.getCIntegerField(\"_content_offset\");\n+    codeOffsetField          = type.getCIntegerField(\"_code_offset\");\n@@ -67,4 +69,0 @@\n-    contentBeginField        = type.getAddressField(\"_content_begin\");\n-    codeBeginField           = type.getAddressField(\"_code_begin\");\n-    codeEndField             = type.getAddressField(\"_code_end\");\n-    dataEndField             = type.getAddressField(\"_data_end\");\n@@ -89,1 +87,1 @@\n-  public Address headerBegin() { return getAddress(); }\n+  public Address headerBegin()    { return getAddress(); }\n@@ -91,1 +89,1 @@\n-  public Address headerEnd() { return getAddress().addOffsetTo(getHeaderSize()); }\n+  public Address headerEnd()      { return getAddress().addOffsetTo(getHeaderSize()); }\n@@ -93,1 +91,1 @@\n-  public Address contentBegin() { return contentBeginField.getValue(addr); }\n+  public Address contentBegin()   { return headerBegin().addOffsetTo(getContentOffset()); }\n@@ -95,1 +93,1 @@\n-  public Address contentEnd() { return headerBegin().addOffsetTo(getDataOffset()); }\n+  public Address contentEnd()     { return headerBegin().addOffsetTo(getDataOffset()); }\n@@ -97,1 +95,1 @@\n-  public Address codeBegin() { return codeBeginField.getValue(addr); }\n+  public Address codeBegin()      { return headerBegin().addOffsetTo(getCodeOffset()); }\n@@ -99,1 +97,1 @@\n-  public Address codeEnd() { return codeEndField.getValue(addr); }\n+  public Address codeEnd()        { return headerBegin().addOffsetTo(getDataOffset()); }\n@@ -101,1 +99,1 @@\n-  public Address dataBegin() { return headerBegin().addOffsetTo(getDataOffset()); }\n+  public Address dataBegin()      { return headerBegin().addOffsetTo(getDataOffset()); }\n@@ -103,1 +101,6 @@\n-  public Address dataEnd() { return dataEndField.getValue(addr); }\n+  public Address dataEnd()        { return headerBegin().addOffsetTo(getSize()); }\n+\n+  \/\/ Offsets\n+  public int getContentOffset()   { return (int) contentOffsetField.getValue(addr); }\n+\n+  public int getCodeOffset()      { return (int) codeOffsetField   .getValue(addr); }\n@@ -107,1 +110,1 @@\n-  public int getDataOffset()       { return (int) dataOffsetField.getValue(addr); }\n+  public int getDataOffset()      { return (int) dataOffsetField.getValue(addr); }\n@@ -110,1 +113,1 @@\n-  public int getSize()             { return (int) sizeField.getValue(addr); }\n+  public int getSize()            { return (int) sizeField.getValue(addr); }\n@@ -112,1 +115,1 @@\n-  public int getHeaderSize()       { return (int) headerSizeField.getValue(addr); }\n+  public int getHeaderSize()      { return (int) headerSizeField.getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeBlob.java","additions":23,"deletions":20,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.jvm.hotspot.code;\n-\n-import java.util.*;\n-\n-import sun.jvm.hotspot.debugger.Address;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public abstract class CompiledMethod extends CodeBlob {\n-  private static AddressField  methodField;\n-  private static AddressField  deoptHandlerBeginField;\n-  private static AddressField  deoptMhHandlerBeginField;\n-  private static AddressField  scopesDataBeginField;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"CompiledMethod\");\n-\n-    methodField                 = type.getAddressField(\"_method\");\n-    deoptHandlerBeginField      = type.getAddressField(\"_deopt_handler_begin\");\n-    deoptMhHandlerBeginField    = type.getAddressField(\"_deopt_mh_handler_begin\");\n-    scopesDataBeginField        = type.getAddressField(\"_scopes_data_begin\");\n-  }\n-\n-  public CompiledMethod(Address addr) {\n-    super(addr);\n-  }\n-\n-  public Method getMethod() {\n-    return (Method)Metadata.instantiateWrapperFor(methodField.getValue(addr));\n-  }\n-\n-  public Address deoptHandlerBegin()    { return deoptHandlerBeginField.getValue(addr);              }\n-  public Address deoptMhHandlerBegin()  { return deoptMhHandlerBeginField.getValue(addr);            }\n-  public Address scopesDataBegin()      { return scopesDataBeginField.getValue(addr);                }\n-\n-  public static int getMethodOffset()                { return (int) methodField.getOffset();                }\n-\n-  @Override\n-  public boolean isCompiled() {\n-    return true;\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompiledMethod.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import sun.jvm.hotspot.memory.*;\n@@ -37,1 +38,1 @@\n-public class NMethod extends CompiledMethod {\n+public class NMethod extends CodeBlob {\n@@ -39,0 +40,1 @@\n+  private static AddressField  methodField;\n@@ -46,0 +48,2 @@\n+  private static CIntegerField deoptHandlerOffsetField;\n+  private static CIntegerField deoptMhHandlerOffsetField;\n@@ -50,0 +54,1 @@\n+  private static CIntegerField scopesDataOffsetField;\n@@ -79,0 +84,1 @@\n+    methodField                 = type.getAddressField(\"_method\");\n@@ -83,0 +89,2 @@\n+    deoptHandlerOffsetField     = type.getCIntegerField(\"_deopt_handler_offset\");\n+    deoptMhHandlerOffsetField   = type.getCIntegerField(\"_deopt_mh_handler_offset\");\n@@ -87,0 +95,1 @@\n+    scopesDataOffsetField       = type.getCIntegerField(\"_scopes_data_offset\");\n@@ -108,0 +117,4 @@\n+  public Method getMethod() {\n+    return (Method)Metadata.instantiateWrapperFor(methodField.getValue(addr));\n+  }\n+\n@@ -120,0 +133,2 @@\n+  public Address deoptHandlerBegin()    { return headerBegin().addOffsetTo(getDeoptHandlerOffset());   }\n+  public Address deoptMhHandlerBegin()  { return headerBegin().addOffsetTo(getDeoptMhHandlerOffset()); }\n@@ -125,1 +140,2 @@\n-  public Address metadataEnd()          { return scopesDataBegin();                                  }\n+  public Address metadataEnd()          { return headerBegin().addOffsetTo(getScopesDataOffset());   }\n+  public Address scopesDataBegin()      { return headerBegin().addOffsetTo(getScopesDataOffset());   }\n@@ -423,0 +439,1 @@\n+  public static int getMethodOffset()                { return (int) methodField.getOffset();                }\n@@ -500,0 +517,2 @@\n+  private int getDeoptHandlerOffset()   { return (int) deoptHandlerOffsetField  .getValue(addr); }\n+  private int getDeoptMhHandlerOffset() { return (int) deoptMhHandlerOffsetField.getValue(addr); }\n@@ -503,0 +522,1 @@\n+  private int getScopesDataOffset()   { return (int) scopesDataOffsetField  .getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-                                  out.print(((CompiledMethod)cb).getMethod().externalNameAndSignature());\n+                                  out.print(((NMethod)cb).getMethod().externalNameAndSignature());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/PStack.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -193,1 +193,0 @@\n-        UseNeon,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/aarch64\/AArch64.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,1 @@\n-    final int methodCodeOffset = getFieldOffset(\"Method::_code\", Integer.class, \"CompiledMethod*\");\n+    final int methodCodeOffset = getFieldOffset(\"Method::_code\", Integer.class, \"nmethod*\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,3 +61,0 @@\n-        if (config.useNeon) {\n-            flags.add(AArch64.Flag.UseNeon);\n-        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-    final boolean useNeon = getFlag(\"UseNeon\", Boolean.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotVMConfig.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-                writer.tableOfContents.addLink(htmlIds.forMember(typeElement, (ExecutableElement) member),\n+                writer.tableOfContents.addLink(htmlIds.forMember((ExecutableElement) member).getFirst(),\n@@ -213,1 +213,1 @@\n-                .setId(htmlIds.forMember(typeElement, (ExecutableElement) member));\n+                .setId(htmlIds.forMember((ExecutableElement) member).getFirst());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                writer.tableOfContents.addLink(htmlIds.forMember(currentConstructor),\n+                writer.tableOfContents.addLink(htmlIds.forMember(currentConstructor).getFirst(),\n@@ -192,3 +192,4 @@\n-        HtmlId erasureAnchor = htmlIds.forErasure(constructor);\n-        if (erasureAnchor != null) {\n-            heading.setId(erasureAnchor);\n+\n+        var anchors = htmlIds.forMember(constructor);\n+        if (anchors.size() > 1) {\n+            heading.setId(anchors.getLast());\n@@ -198,1 +199,1 @@\n-                .setId(htmlIds.forMember(constructor));\n+                .setId(anchors.getFirst());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1040,1 +1040,1 @@\n-            HtmlId id = isProperty ? htmlIds.forProperty(ee) : htmlIds.forMember(ee);\n+            HtmlId id = isProperty ? htmlIds.forProperty(ee) : htmlIds.forMember(ee).getFirst();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.HashMap;\n+import java.util.HashSet;\n@@ -32,0 +34,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -33,0 +37,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -162,3 +167,3 @@\n-     * Returns an id for an executable element, suitable for use when the\n-     * simple name and argument list will be unique within the page, such as\n-     * in the page for the declaration of the enclosing class or interface.\n+     * {@return a non-empty list of ids to a constructor or a method}\n+     * The ids from the returned list are alternative: the given constructor\n+     * or method can be equally referred to by any of those ids.\n@@ -166,3 +171,1 @@\n-     * @param element the element\n-     *\n-     * @return the id\n+     * @param executable a constructor or method\n@@ -170,1 +173,71 @@\n-    HtmlId forMember(ExecutableElement element) {\n+    List<HtmlId> forMember(ExecutableElement executable) {\n+        var htmlId = ids.get(executable);\n+        if (htmlId != null)\n+            return htmlId;\n+        if (executable.getKind() != ElementKind.CONSTRUCTOR\n+                && executable.getKind() != ElementKind.METHOD)\n+            throw new IllegalArgumentException(String.valueOf(executable.getKind()));\n+        var vmt = configuration.getVisibleMemberTable((TypeElement) executable.getEnclosingElement());\n+        var ctors = vmt.getVisibleMembers(VisibleMemberTable.Kind.CONSTRUCTORS);\n+        var methods = vmt.getVisibleMembers(VisibleMemberTable.Kind.METHODS);\n+        record Erased(ExecutableElement element, HtmlId id) { }\n+        \/\/ split elements into two buckets:\n+        \/\/  - elements whose erased id is present\n+        \/\/  - elements whose erased id is absent (i.e. is null)\n+        enum ErasedId { PRESENT, ABSENT }\n+        var buckets = Stream.concat(ctors.stream(), methods.stream())\n+                .map(e -> (ExecutableElement) e)\n+                .map(e -> new Erased(e, forErasure(e)))\n+                .collect(Collectors.groupingBy(erased -> erased.id == null ?\n+                        ErasedId.ABSENT : ErasedId.PRESENT));\n+        var dups = new HashSet<String>();\n+        \/\/ the order of elements in each bucket is important for reproducibility\n+        \/\/ of ids: the same executable element must have the same id in any\n+        \/\/ javadoc run\n+        \/\/ Use simple id, unless we have to use erased id; for that, do the\n+        \/\/ following _in order_:\n+        \/\/ 1. Map all elements that can _only_ be addressed by the simple id\n+        for (var e : buckets.getOrDefault(ErasedId.ABSENT, List.of())) {\n+            var simpleId = forMember0(e.element);\n+            ids.put(e.element, List.of(simpleId));\n+            boolean added = dups.add(simpleId.name());\n+            \/\/ we assume that the simple id for an executable member that\n+            \/\/ does not use type parameters is unique\n+            assert added;\n+        }\n+        \/\/ 2. Map all elements that can be addressed by simple id or erased id;\n+        \/\/ if the simple id is not yet used, use it, otherwise use the erased id\n+        for (var e : buckets.getOrDefault(ErasedId.PRESENT, List.of())) {\n+            var simpleId = forMember0(e.element);\n+            if (dups.add(simpleId.name())) {\n+                ids.put(e.element, List.of(simpleId, e.id));\n+            } else {\n+                ids.put(e.element, List.of(e.id));\n+                boolean added = dups.add(e.id.name());\n+                \/\/ Not only must an erased id not clash with any simple id,\n+                \/\/ but it must also not clash with any other erased id.\n+                \/\/ The latter is because JLS 8.4.2. Method Signature:\n+                \/\/ it is a compile-time error to declare two methods\n+                \/\/ with override-equivalent signatures in a class\n+                assert added;\n+            }\n+        }\n+        \/\/ Safety net: if for whatever reason we cannot find the element\n+        \/\/ among those we just expanded, return the simple id. It might\n+        \/\/ not be always right, but at least it won't fail.\n+        \/\/\n+        \/\/ - one example where it might happen is linking to an inherited\n+        \/\/   undocumented method (see test case T5093723)\n+        \/\/   TODO the above will need to be revisited if and when we redesign\n+        \/\/    VisibleMemberTable, which currently cannot correctly return the\n+        \/\/    owner of such a method\n+        \/\/\n+        \/\/ - another example is annotation interface methods: they are not\n+        \/\/   included in VisibleMemberTable.Kind.METHODS and so cannot be\n+        \/\/   found among them\n+        return ids.computeIfAbsent(executable, e -> List.of(forMember0(e)));\n+    }\n+\n+    private final Map<ExecutableElement, List<HtmlId>> ids = new HashMap<>();\n+\n+    private HtmlId forMember0(ExecutableElement element) {\n@@ -177,13 +250,0 @@\n-    \/**\n-     * Returns an id for an executable element, including the context\n-     * of its documented enclosing class or interface.\n-     *\n-     * @param typeElement the enclosing class or interface\n-     * @param member      the element\n-     *\n-     * @return the id\n-     *\/\n-    HtmlId forMember(TypeElement typeElement, ExecutableElement member) {\n-        return HtmlId.of(utils.getSimpleName(member) + utils.signature(member, typeElement));\n-    }\n-\n@@ -232,1 +292,1 @@\n-    protected HtmlId forErasure(ExecutableElement executableElement) {\n+    private HtmlId forErasure(ExecutableElement executableElement) {\n@@ -486,1 +546,1 @@\n-            case CONSTRUCTOR, METHOD -> forMember((ExecutableElement) el).name();\n+            case CONSTRUCTOR, METHOD -> forMember((ExecutableElement) el).getFirst().name();\n@@ -500,1 +560,1 @@\n-        return HtmlId.of(\"restricted-\" + forMember(el).name());\n+        return HtmlId.of(\"restricted-\" + forMember(el).getFirst().name());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":83,"deletions":23,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-                    String url = HtmlTree.encodeURL(htmlIds.forMember((ExecutableElement) element).name());\n+                    String url = HtmlTree.encodeURL(htmlIds.forMember((ExecutableElement) element).getFirst().name());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIndexBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                writer.tableOfContents.addLink(htmlIds.forMember(currentMethod),\n+                writer.tableOfContents.addLink(htmlIds.forMember(currentMethod).getFirst(),\n@@ -207,3 +207,3 @@\n-        HtmlId erasureAnchor;\n-        if ((erasureAnchor = htmlIds.forErasure(method)) != null) {\n-            heading.setId(erasureAnchor);\n+        var anchors = htmlIds.forMember(method);\n+        if (anchors.size() > 1) {\n+            heading.setId(anchors.getLast());\n@@ -213,1 +213,1 @@\n-                .setId(htmlIds.forMember(method));\n+                .setId(anchors.getFirst());\n@@ -378,1 +378,1 @@\n-                        .fragment(writer.htmlIds.forMember(method).name())\n+                        .fragment(writer.htmlIds.forMember(method).getFirst().name())\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriter.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import javax.lang.model.element.TypeParameterElement;\n@@ -41,0 +42,1 @@\n+import java.util.Arrays;\n@@ -146,1 +148,5 @@\n-                    return compareModuleNames(e1, e2);\n+                    result = compareModuleNames(e1, e2);\n+                    if (result != 0) {\n+                        return result;\n+                    }\n+                    return compareTypeParameters(e1, e2);\n@@ -267,1 +273,4 @@\n-                    return compareModuleNames(e1, e2);\n+                    result = compareModuleNames(e1, e2);\n+                    if (result != 0)\n+                        return result;\n+                    return compareTypeParameters(e1, e2);\n@@ -367,1 +376,8 @@\n-                    return compareModuleNames(e1, e2);\n+                    result = compareModuleNames(e1, e2);\n+                    if (result != 0) {\n+                        return result;\n+                    }\n+                    \/\/ this might not be needed: if e1 != e2 and both are\n+                    \/\/ executables they must differ in FQN and thus we\n+                    \/\/ shouldn't reach here\n+                    return compareTypeParameters(e1, e2);\n@@ -426,0 +442,15 @@\n+        protected final int compareTypeParameters(Element e1, Element e2) {\n+            if (!e1.getKind().isExecutable() || !e2.getKind().isExecutable())\n+                return 0;\n+            var typeParameters1 = ((ExecutableElement) e1).getTypeParameters();\n+            var typeParameters2 = ((ExecutableElement) e2).getTypeParameters();\n+            var parameters1 = typeParameters1.toArray(new TypeParameterElement[0]);\n+            var parameters2 = typeParameters2.toArray(new TypeParameterElement[0]);\n+            return Arrays.compare(parameters1, parameters2, (p1, p2) -> {\n+                var bounds1 = p1.getBounds().toArray(new TypeMirror[0]);\n+                var bounds2 = p2.getBounds().toArray(new TypeMirror[0]);\n+                return Arrays.compare(bounds1, bounds2, (b1, b2) ->\n+                        utils.compareStrings(true, b1.toString(), b2.toString()));\n+            });\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Comparators.java","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -221,5 +221,13 @@\n-\\    -J<flag>              Pass <flag> directly to the runtime system.\\n\\\n-\\                            Use one -J for each runtime flag or flag argument\\n\\\n-\\    -R<flag>              Pass <flag> to the remote runtime system.\\n\\\n-\\                            Use one -R for each remote flag or flag argument\\n\\\n-\\    -C<flag>              Pass <flag> to the compiler.\\n\\\n+\\    -J<flag>              passes <flag> to the runtime system, but has no effect\\n\\\n+\\                            on the execution of code snippets. To specify flags\\n\\\n+\\                            that affect the execution of code snippets, use\\n\\\n+\\                            -R<flag>. Alternatively, use -J<flag> with\\n\\\n+\\                            --execution local.\\n\\\n+\\    -R<flag>              passes <flag> to the runtime system only when code\\n\\\n+\\                            snippets are executed. For example, -R-Dfoo=bar\\n\\\n+\\                            means that execution of the snippet\\n\\\n+\\                            System.getProperty(\"foo\") will return \"bar\".\\n\\\n+\\    -C<flag>              passes <flag> to the Java compiler inside JShell.\\n\\\n+\\                            For example, -C-Xlint enables all the recommended\\n\\\n+\\                            lint warnings, and -C--release=<N> compiles for\\n\\\n+\\                            Java SE N, as if --release N was specified.\\n\\\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n.properties","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -125,3 +125,4 @@\n-Provides a flag to pass to the compiler.\n-To pass more than one flag, provide an instance of this option for each\n-flag or flag argument needed.\n+passes \\f[I]flag\\f[R] to the Java compiler inside JShell.\n+For example, \\f[V]-C-Xlint\\f[R] enables all the recommended lint\n+warnings, and \\f[V]-C--release=<N>\\f[R] compiles for Java SE N, as if\n+--release N was specified.\n@@ -190,3 +191,6 @@\n-Provides a flag to pass to the runtime system.\n-To pass more than one flag, provide an instance of this option for each\n-flag or flag argument needed.\n+passes \\f[I]flag\\f[R] to the runtime system, but has no effect on the\n+execution of code snippets.\n+To specify flags that affect the execution of code snippets, use\n+\\f[V]-R\\f[R]\\f[I]flag\\f[R].\n+Alternatively, use \\f[V]-J\\f[R]\\f[I]flag\\f[R] with\n+\\f[V]--execution local\\f[R].\n@@ -211,3 +215,5 @@\n-Provides a flag to pass to the remote runtime system.\n-To pass more than one flag, provide an instance of this option for each\n-flag or flag argument to pass.\n+passes \\f[I]flag\\f[R] to the runtime system only when code snippets are\n+executed.\n+For example, \\f[V]-R-Dfoo=bar\\f[R] means that execution of the snippet\n+\\f[V]System.getProperty(\\[dq]foo\\[dq])\\f[R] will return\n+\\f[V]\\[dq]bar\\[dq]\\f[R].\n","filename":"src\/jdk.jshell\/share\/man\/jshell.1","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+JNIEXPORT\n@@ -124,3 +125,0 @@\n-#ifdef DLL_ENTRY\n-  DLL_ENTRY\n-#endif\n@@ -148,0 +146,1 @@\n+JNIEXPORT\n@@ -149,3 +148,0 @@\n-#ifdef DLL_ENTRY\n-  DLL_ENTRY\n-#endif\n","filename":"src\/utils\/hsdis\/binutils\/hsdis-binutils.c","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -123,3 +123,1 @@\n-#ifdef _WIN32\n-__declspec(dllexport)\n-#endif\n+JNIEXPORT\n","filename":"src\/utils\/hsdis\/capstone\/hsdis-capstone.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+#include \"jni.h\"\n+\n","filename":"src\/utils\/hsdis\/hsdis.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+JNIEXPORT\n@@ -345,0 +346,1 @@\n+JNIEXPORT\n","filename":"src\/utils\/hsdis\/llvm\/hsdis-llvm.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  const char* const _locale;\n+  char* const _locale;\n@@ -38,1 +38,1 @@\n-  DirectivesParserTest() : _locale(setlocale(LC_NUMERIC, nullptr)) {\n+  DirectivesParserTest() : _locale(os::strdup(setlocale(LC_NUMERIC, nullptr), mtTest)) {\n@@ -43,0 +43,1 @@\n+    os::free(_locale);\n","filename":"test\/hotspot\/gtest\/compiler\/test_directivesParser.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,18 @@\n+class ZAddressOffsetMaxSetter {\n+private:\n+  const size_t _old_max;\n+  const size_t _old_mask;\n+\n+public:\n+  ZAddressOffsetMaxSetter()\n+    : _old_max(ZAddressOffsetMax),\n+      _old_mask(ZAddressOffsetMask) {\n+    ZAddressOffsetMax = size_t(16) * G * 1024;\n+    ZAddressOffsetMask = ZAddressOffsetMax - 1;\n+  }\n+  ~ZAddressOffsetMaxSetter() {\n+    ZAddressOffsetMax = _old_max;\n+    ZAddressOffsetMask = _old_mask;\n+  }\n+};\n+\n@@ -29,0 +47,2 @@\n+  ZAddressOffsetMaxSetter setter;\n+\n@@ -55,0 +75,2 @@\n+  ZAddressOffsetMaxSetter setter;\n+\n@@ -117,0 +139,2 @@\n+  ZAddressOffsetMaxSetter setter;\n+\n@@ -133,0 +157,2 @@\n+  ZAddressOffsetMaxSetter setter;\n+\n@@ -161,0 +187,2 @@\n+  ZAddressOffsetMaxSetter setter;\n+\n@@ -175,0 +203,17 @@\n+\n+TEST(ZPhysicalMemoryTest, limits) {\n+  ZAddressOffsetMaxSetter setter;\n+\n+  const size_t HalfZAddressOffsetMax = ZAddressOffsetMax >> 1;\n+  ZPhysicalMemory pmem0;\n+  pmem0.add_segment(ZPhysicalMemorySegment(zoffset(0), HalfZAddressOffsetMax, true));\n+  pmem0.add_segment(ZPhysicalMemorySegment(zoffset(HalfZAddressOffsetMax), HalfZAddressOffsetMax, false));\n+  EXPECT_EQ(pmem0.nsegments(), 2);\n+  EXPECT_EQ(pmem0.size(), ZAddressOffsetMax);\n+\n+  ZPhysicalMemory pmem1 = pmem0.split_committed();\n+  EXPECT_EQ(pmem0.nsegments(), 1);\n+  EXPECT_EQ(pmem0.size(), HalfZAddressOffsetMax);\n+  EXPECT_EQ(pmem1.nsegments(), 1);\n+  EXPECT_EQ(pmem1.size(), HalfZAddressOffsetMax);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zPhysicalMemory.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-  assert_test_pattern(h_obj, \"is_neutral no_hash\");\n+  assert_test_pattern(h_obj, \"is_unlocked no_hash\");\n@@ -95,1 +95,1 @@\n-  assert_test_pattern(h_obj, \"is_neutral hash=0x\");\n+  assert_test_pattern(h_obj, \"is_unlocked hash=0x\");\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  o->set_klass(Universe::boolArrayKlassObj());\n+  o->set_klass(Universe::boolArrayKlass());\n","filename":"test\/hotspot\/gtest\/oops\/test_typeArrayOop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,3 @@\n-vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM03\/cm03t001\/TestDescription.java 8299493 macosx-x64\n+vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM03\/cm03t001\/TestDescription.java 8299493 macosx-x64,windows-x64\n+\n+vmTestbase\/nsk\/stress\/thread\/thread006.java 8321476 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+containers\/docker\/TestJFREvents.java 8327723 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323682\n+ * @summary Test that the appropriate guards are generated for the copyOfRange\n+ *          intrinsic, even if the result of the array copy is not used.\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.arraycopy.TestArrayCopyOfRangeGuards::test\n+ *                   -Xbatch\n+ *                   compiler.arraycopy.TestArrayCopyOfRangeGuards\n+ *\/\n+\n+package compiler.arraycopy;\n+\n+import java.util.Arrays;\n+\n+public class TestArrayCopyOfRangeGuards {\n+    static int counter = 0;\n+\n+    public static void main(String[] args) {\n+        Object[] array = new Object[10];\n+        for (int i = 0; i < 50_000; i++) {\n+            test(array);\n+        }\n+        if (counter != 50_000) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    static void test(Object[] array) {\n+        try {\n+            Arrays.copyOfRange(array, 15, 20, Object[].class);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            \/\/ Expected\n+            counter++;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyOfRangeGuards.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -34,0 +34,2 @@\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation -Xbatch\n+ *   -XX:InitArrayShortSize=32768 -XX:MaxVectorSize=8 -XX:-IdealizeClearArrayNode -XX:UseAVX=3 compiler.c2.ClearArray\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/ClearArray.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests correct code generation of lightweight locking when using -XX:+ShowMessageBoxOnError; times-out on failure\n+ * @bug 8329726\n+ * @run main\/othervm -XX:+ShowMessageBoxOnError -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestLWLockingCodeGen::sync TestLWLockingCodeGen\n+ *\/\n+public class TestLWLockingCodeGen {\n+    private static int val = 0;\n+    public static void main(String[] args) {\n+        sync();\n+    }\n+    private static synchronized void sync() {\n+        val = val + (int)(Math.random() * 42);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestLWLockingCodeGen.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -49,0 +49,1 @@\n+                                   \"-XX:CompileCommand=inline,*Nested::*\",\n@@ -95,1 +96,3 @@\n-                 \"testString_two_C2\"\n+                 \"testString_two_C2\",\n+                 \"testLoadNarrowKlass_C2\",\n+                 \"testReReduce_C2\"\n@@ -150,0 +153,2 @@\n+        Asserts.assertEQ(testLoadNarrowKlass_Interp(cond1),                         testLoadNarrowKlass_C2(cond1));\n+        Asserts.assertEQ(testReReduce_Interp(cond1, x, y),                          testReReduce_C2(cond1, x, y));\n@@ -298,2 +303,1 @@\n-    @IR(counts = { IRNode.ALLOC, \"2\" })\n-    \/\/ Merge won't be reduced because the inputs to the Phi have different Klasses\n+    @IR(failOn = { IRNode.ALLOC })\n@@ -407,2 +411,1 @@\n-    @IR(counts = { IRNode.ALLOC, \"1\" })\n-    \/\/ The merge won't be simplified because the merge with NULL\n+    @IR(failOn = { IRNode.ALLOC })\n@@ -513,1 +516,0 @@\n-    \/\/ Merge won't be reduced because, among other things, one of the inputs is null.\n@@ -533,2 +535,1 @@\n-    @IR(counts = { IRNode.ALLOC, \"1\" })\n-    \/\/ The allocation won't be removed because the merge doesn't have exact type\n+    @IR(failOn = { IRNode.ALLOC })\n@@ -565,3 +566,1 @@\n-    @IR(counts = { IRNode.ALLOC, \"2\" })\n-    \/\/ The initial allocation assigned to 's' will always be dead.\n-    \/\/ The other two allocations assigned to 's' won't be removed because they have different type.\n+    @IR(failOn = { IRNode.ALLOC })\n@@ -593,1 +592,1 @@\n-    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    @IR(failOn = { IRNode.ALLOC })\n@@ -623,3 +622,1 @@\n-    @IR(counts = { IRNode.ALLOC, \"2\" })\n-    \/\/ The unused allocation will be removed.\n-    \/\/ The other two allocations assigned to 's' won't be removed because they have different type.\n+    @IR(failOn = { IRNode.ALLOC })\n@@ -1234,1 +1231,1 @@\n-    @IR(counts = { IRNode.ALLOC, \"0\" })\n+    @IR(failOn = { IRNode.ALLOC })\n@@ -1255,1 +1252,1 @@\n-    @IR(counts = { IRNode.ALLOC, \"0\" })\n+    @IR(failOn = { IRNode.ALLOC })\n@@ -1261,0 +1258,56 @@\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    Class testLoadNarrowKlass(boolean cond1) {\n+        Object p = new Circle(10);\n+\n+        if (cond1) {\n+            p = dummy(1, 2);\n+        }\n+\n+        return p.getClass();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ The allocation won't be reduced because we don't support NarrowKlass\n+    \/\/ loads under CastPPs.\n+    Class testLoadNarrowKlass_C2(boolean cond1) { return testLoadNarrowKlass(cond1); }\n+\n+    @DontCompile\n+    Class testLoadNarrowKlass_Interp(boolean cond1) { return testLoadNarrowKlass(cond1); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testReReduce(boolean cond, int x, int y) {\n+        Nested A = new Nested(x, y);\n+        Nested B = new Nested(y, x);\n+        Nested C = new Nested(y, x);\n+        Nested P = null;\n+\n+        if (x == y) {\n+            A.other = B;\n+            P = A;\n+        } else if (x > y) {\n+            P = B;\n+        } else {\n+            C.other = B;\n+            P = C;\n+        }\n+\n+        if (x == y)\n+            dummy_defaults();\n+\n+        return P.x;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ The last allocation won't be reduced because it would cause the creation\n+    \/\/ of a nested SafePointScalarMergeNode.\n+    int testReReduce_C2(boolean cond1, int x, int y) { return testReReduce(cond1, x, y); }\n+\n+    @DontCompile\n+    int testReReduce_Interp(boolean cond1, int x, int y) { return testReReduce(cond1, x, y); }\n+\n@@ -1292,0 +1345,10 @@\n+    static class Nested {\n+        int x, y;\n+        Nested other;\n+        Nested(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+            this.other = null;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":80,"deletions":17,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8329126 8329421\n+ * @summary check that native methods get compiled and printed\n+ *\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/native compiler.calls.NativeCalls\n+ *\/\n+\n+package compiler.calls;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class NativeCalls {\n+    static Method emptyStaticNativeMethod;\n+    static Method callNativeMethod;\n+    static {\n+        init();\n+    }\n+    static void init() {\n+        System.loadLibrary(\"NativeCalls\");\n+        try {\n+            emptyStaticNativeMethod = NativeCalls.class.getDeclaredMethod(\"emptyStaticNative\");\n+            callNativeMethod = NativeCalls.class.getDeclaredMethod(\"callNative\");\n+        } catch (NoSuchMethodException nsme) {\n+            throw new Error(\"TEST BUG: can't find test method\", nsme);\n+        }\n+    }\n+\n+    native static void emptyStaticNative();\n+\n+    static void callNative() {\n+        emptyStaticNative();\n+    }\n+\n+    static public void main(String[] args) throws Exception {\n+\n+        ArrayList<String> baseOptions = new ArrayList<String>();\n+        baseOptions.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        baseOptions.add(\"-XX:+WhiteBoxAPI\");\n+        baseOptions.add(\"-Xbootclasspath\/a:.\");\n+        baseOptions.add(\"-Xbatch\");\n+        baseOptions.add(\"-XX:-UseOnStackReplacement\");\n+        baseOptions.add(\"-XX:+PrintCompilation\");\n+        baseOptions.add(Executor.class.getName());\n+        String nativeMethodName = NativeCalls.class.getName() + \"::\" + emptyStaticNativeMethod.getName();\n+        List<Variant> variants = List.of(new Variant(List.of(\"-XX:+TieredCompilation\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\",\n+                                                             \"-XX:+PreferInterpreterNativeStubs\"), \"false\", \"false\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:+PreferInterpreterNativeStubs\"), \"false\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=2\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=3\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=4\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\",\n+                                                             \"-XX:CompileCommand=print,\" + nativeMethodName), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:CompileCommand=print,\" + nativeMethodName), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintAssembly\"), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintNativeNMethods\"), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\",\n+                                                             \"-XX:CompileCommand=exclude,\" + nativeMethodName), \"false\", \"false\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:CompileCommand=exclude,\" + nativeMethodName), \"false\", \"false\"));\n+        for (Variant v : variants) {\n+            ArrayList<String> command = new ArrayList<String>(v.options);\n+            command.addAll(baseOptions);\n+            command.add(v.compile);\n+            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(command);\n+            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+            analyzer.shouldHaveExitValue(0);\n+            System.out.println(analyzer.getOutput());\n+            if (Boolean.valueOf(v.print).booleanValue() &&\n+                analyzer.asLines().stream().\n+                filter(Pattern.compile(\"Compiled method.+\" + nativeMethodName + \".*\").asPredicate()).\n+                findAny().isEmpty()) {\n+                throw new Error(nativeMethodName + \" not printed\");\n+            }\n+        }\n+    }\n+\n+    public static class Variant {\n+        Collection<String> options;\n+        String compile;\n+        String print;\n+        public Variant(Collection<String> options, String compile, String print) {\n+            this.options = options;\n+            this. compile = compile;\n+            this. print = print;\n+        }\n+    }\n+\n+    public static class Executor {\n+\n+        static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+        static public void main(String[] args) {\n+\n+            if (args.length != 1) {\n+                throw new Error(\"Expected two arguments\");\n+            }\n+            boolean compile = Boolean.valueOf(args[0]);\n+            for (int i = 0; i < 20_000; i++) {\n+                callNative();\n+            }\n+            if (wb.getMethodCompilationLevel(callNativeMethod) > 0) {\n+                if (compile && !wb.isMethodCompiled(emptyStaticNativeMethod)) {\n+                    throw new Error(\"TEST BUG: '\" + emptyStaticNativeMethod + \"' should be compiled\");\n+                }\n+                if (!compile && wb.isMethodCompiled(emptyStaticNativeMethod)) {\n+                    throw new Error(\"TEST BUG: '\" + emptyStaticNativeMethod + \"' should not be compiled\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/NativeCalls.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+JNIEXPORT\n+void JNICALL Java_compiler_calls_NativeCalls_emptyStaticNative(JNIEnv* env, jclass jclazz) {}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/libNativeCalls.c","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -85,0 +85,30 @@\n+    private static void verifyCodeHeapSize(ProcessBuilder pb, String heapName, long heapSize) throws Exception {\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+\n+        long actualHeapSize = Long.parseLong(out.firstMatch(heapName + \"\\\\s+=\\\\s(\\\\d+)\", 1));\n+        if (heapSize != actualHeapSize) {\n+            throw new RuntimeException(\"Unexpected \" + heapName + \" size: \" + actualHeapSize + \" != \" + heapSize);\n+        }\n+\n+        \/\/ Sanity checks:\n+        \/\/ - segment sizes are aligned to at least 1KB\n+        \/\/ - sum of segment sizes equals ReservedCodeCacheSize\n+\n+        long nonNMethodCodeHeapSize = Long.parseLong(out.firstMatch(\"NonNMethodCodeHeapSize\\\\s+=\\\\s(\\\\d+)\", 1));\n+        long nonProfiledCodeHeapSize = Long.parseLong(out.firstMatch(\"NonProfiledCodeHeapSize\\\\s+=\\\\s(\\\\d+)\", 1));\n+        long profiledCodeHeapSize = Long.parseLong(out.firstMatch(\" ProfiledCodeHeapSize\\\\s+=\\\\s(\\\\d+)\", 1));\n+        long reservedCodeCacheSize = Long.parseLong(out.firstMatch(\"ReservedCodeCacheSize\\\\s+=\\\\s(\\\\d+)\", 1));\n+\n+        if (reservedCodeCacheSize != nonNMethodCodeHeapSize + nonProfiledCodeHeapSize + profiledCodeHeapSize) {\n+            throw new RuntimeException(\"Unexpected segments size sum: \" + reservedCodeCacheSize + \" != \" +\n+                    nonNMethodCodeHeapSize + \"+\" + nonProfiledCodeHeapSize + \"+\" + profiledCodeHeapSize);\n+        }\n+\n+        if ((reservedCodeCacheSize % 1024 != 0) || (nonNMethodCodeHeapSize % 1024 != 0) ||\n+            (nonProfiledCodeHeapSize % 1024 != 0) || (profiledCodeHeapSize % 1024 != 0)) {\n+            throw new RuntimeException(\"Unexpected segments size alignment: \" + reservedCodeCacheSize + \", \" +\n+                    nonNMethodCodeHeapSize + \", \" + nonProfiledCodeHeapSize + \", \" + profiledCodeHeapSize);\n+        }\n+    }\n+\n@@ -163,0 +193,1 @@\n+                                                              \"-XX:NonNMethodCodeHeapSize=\" + minSize,\n@@ -167,0 +198,50 @@\n+\n+        \/\/ Try different combination of Segment Sizes\n+\n+        \/\/ Fails if there is not enough space for code cache.\n+        \/\/ All segments are set to minimum allowed value, but VM still fails\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+SegmentedCodeCache\",\n+                                                              \"-XX:ReservedCodeCacheSize=\" + minSize,\n+                                                              \"-XX:InitialCodeCacheSize=100K\",\n+                                                              \"-version\");\n+        failsWith(pb, \"Invalid code heap sizes\");\n+\n+\n+        \/\/ Reserved code cache is set but not equal to the sum of other segments\n+        \/\/ that are explicitly specified - fails\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+SegmentedCodeCache\",\n+                                                              \"-XX:ReservedCodeCacheSize=100M\",\n+                                                              \"-XX:NonNMethodCodeHeapSize=10M\",\n+                                                              \"-XX:ProfiledCodeHeapSize=10M\",\n+                                                              \"-XX:NonProfiledCodeHeapSize=10M\",\n+                                                              \"-version\");\n+        failsWith(pb, \"Invalid code heap sizes\");\n+\n+        \/\/ Reserved code cache is not set - it's automatically adjusted to the sum of other segments\n+        \/\/ that are explicitly specified\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+SegmentedCodeCache\",\n+                                                              \"-XX:NonNMethodCodeHeapSize=10M\",\n+                                                              \"-XX:ProfiledCodeHeapSize=10M\",\n+                                                              \"-XX:NonProfiledCodeHeapSize=10M\",\n+                                                              \"-XX:+PrintFlagsFinal\",\n+                                                              \"-version\");\n+        verifyCodeHeapSize(pb, \"ReservedCodeCacheSize\", 31457280);\n+\n+        \/\/ Reserved code cache is set, NonNmethod segment size is set, two other segments is automatically\n+        \/\/ adjusted to half of the remaining space\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+SegmentedCodeCache\",\n+                                                              \"-XX:ReservedCodeCacheSize=100M\",\n+                                                              \"-XX:NonNMethodCodeHeapSize=10M\",\n+                                                              \"-XX:+PrintFlagsFinal\",\n+                                                              \"-version\");\n+        verifyCodeHeapSize(pb, \" ProfiledCodeHeapSize\", 47185920);\n+\n+        \/\/ Reserved code cache is set but NonNmethodCodeHeapSize is not set.\n+        \/\/ It's calculated based on the number of compiler threads\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+SegmentedCodeCache\",\n+                                                              \"-XX:ReservedCodeCacheSize=100M\",\n+                                                              \"-XX:ProfiledCodeHeapSize=10M\",\n+                                                              \"-XX:NonProfiledCodeHeapSize=10M\",\n+                                                              \"-XX:+PrintFlagsFinal\",\n+                                                              \"-version\");\n+        verifyCodeHeapSize(pb, \"NonNMethodCodeHeapSize\", 83886080);\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318562\n+ * @run main\/othervm\/timeout=200 -XX:CompileCommand=compileonly,TestConvertImplicitNullCheck::test -XX:-TieredCompilation -Xbatch TestConvertImplicitNullCheck\n+ * @summary Exercise float to double conversion with implicit null check\n+ *\n+ *\/\n+\n+\n+public class TestConvertImplicitNullCheck {\n+\n+    float f = 42;\n+\n+    static double test(TestConvertImplicitNullCheck t) {\n+        return t.f; \/\/ float to double conversion with implicit null check of 't'\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup to trigger C2 compilation\n+        TestConvertImplicitNullCheck t = new TestConvertImplicitNullCheck();\n+        for (int i = 0; i < 50_000; ++i) {\n+            test(t);\n+        }\n+        \/\/ implicit null check\n+        try {\n+            test(null);\n+            throw new RuntimeException(\"Test failed as no NullPointerException is thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestConvertImplicitNullCheck.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-        \/\/ Line example: ccstr PrintIdealGraphAddress = 127.0.0.1 {C2 notproduct} {default}\n+        \/\/ Line example: ccstr PrintIdealGraphAddress = 127.0.0.1 {C2 develop} {default}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/GetFlagValueTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+\/*\n+ * @test\n+ * @bug 8327978\n+ * @summary Test compile time for large compilation, where SuperWord takes especially much time.\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm\/timeout=30 -XX:LoopUnrollLimit=1000 -Xbatch\n+ *                              -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestLargeCompilation::test*\n+ *                              compiler.loopopts.superword.TestLargeCompilation\n+ *\/\n+\n+import java.util.Random;\n+\n+public class TestLargeCompilation {\n+    private static final Random random = new Random();\n+    static final int RANGE_CON = 1024 * 8;\n+\n+    static int init = 593436;\n+    static int limit = 599554;\n+    static int offset1 = -592394;\n+    static int offset2 = -592386;\n+    static final int offset3 = -592394;\n+    static final int stride =  4;\n+    static final int scale =   1;\n+    static final int hand_unrolling1 = 2;\n+    static final int hand_unrolling2 = 8;\n+    static final int hand_unrolling3 = 15;\n+\n+    public static void main(String[] args) {\n+        byte[] aB = generateB();\n+        byte[] bB = generateB();\n+        byte[] cB = generateB();\n+\n+        for (int i = 1; i < 100; i++) {\n+            testUUBBBH(aB, bB, cB);\n+        }\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static Object[] testUUBBBH(byte[] a, byte[] b, byte[] c) {\n+        int h1 = hand_unrolling1;\n+        int h2 = hand_unrolling2;\n+        int h3 = hand_unrolling3;\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestLargeCompilation.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8328938\n+ * @summary Test autovectorization with large scale and stride\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main compiler.loopopts.superword.TestLargeScaleAndStride\n+ *\/\n+\n+\/*\n+ * @test id=AlignVector\n+ * @bug 8328938\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:+AlignVector compiler.loopopts.superword.TestLargeScaleAndStride\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestLargeScaleAndStride {\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static int RANGE = 100_000;\n+\n+    public static void main(String[] args) {\n+        byte[] a = new byte[100];\n+        fill(a);\n+\n+        byte[] gold1a = a.clone();\n+        byte[] gold1b = a.clone();\n+        byte[] gold2a = a.clone();\n+        byte[] gold2b = a.clone();\n+        byte[] gold2c = a.clone();\n+        byte[] gold2d = a.clone();\n+        byte[] gold3  = a.clone();\n+        test1a(gold1a);\n+        test1b(gold1b);\n+        test2a(gold2a);\n+        test2b(gold2b);\n+        test2c(gold2c);\n+        test2d(gold2d);\n+        test3(gold3);\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test1a(c);\n+            verify(c, gold1a);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test1b(c);\n+            verify(c, gold1b);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2a(c);\n+            verify(c, gold2a);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2b(c);\n+            verify(c, gold2b);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2c(c);\n+            verify(c, gold2c);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2d(c);\n+            verify(c, gold2d);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test3(c);\n+            verify(c, gold3);\n+        }\n+    }\n+\n+    static void fill(byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+          a[i] = (byte)i;\n+        }\n+    }\n+\n+    static void verify(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] != b[i]) {\n+                throw new RuntimeException(\"wrong value: \" + i + \": \" + a[i] + \" != \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    static void test1a(byte[] a) {\n+        int scale = 1 << 31;\n+        for (int i = 0; i < RANGE; i+=2) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 2\n+            \/\/ 2 * (1 >> 31) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test1b(byte[] a) {\n+        int scale = 1 << 31;\n+        for (int i = RANGE-2; i >= 0; i-=2) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 2\n+            \/\/ 2 * (1 >> 31) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test2a(byte[] a) {\n+        int scale = 1 << 30;\n+        for (int i = 0; i < RANGE; i+=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+\n+    static void test2b(byte[] a) {\n+        int scale = 1 << 30;\n+        for (int i = RANGE-4; i >= 0; i-=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test2c(byte[] a) {\n+        int scale = -(1 << 30);\n+        for (int i = 0; i < RANGE; i+=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test2d(byte[] a) {\n+        int scale = -(1 << 30);\n+        for (int i = RANGE-4; i >= 0; i-=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test3(byte[] a) {\n+        int scale =   1 << 28;\n+        int stride =  1 << 4;\n+        int start = -(1 << 30);\n+        int end =     1 << 30;\n+        for (int i = start; i < end; i+=stride) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestLargeScaleAndStride.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8310886\n+ * @bug 8310886 8325252\n@@ -39,1 +39,1 @@\n-    static final int RANGE = 1024;\n+    static final int RANGE = 1024*16;\n@@ -44,0 +44,1 @@\n+    static int[] ioutArr = new int[RANGE];\n@@ -47,0 +48,5 @@\n+    static final int[] GOLDEN_D;\n+    static final int[] GOLDEN_E;\n+    static final int[] GOLDEN_F;\n+    static final int[] GOLDEN_G;\n+    static final int[] GOLDEN_H;\n@@ -56,0 +62,5 @@\n+        GOLDEN_D = testd();\n+        GOLDEN_E = teste();\n+        GOLDEN_F = testf();\n+        GOLDEN_G = testg();\n+        GOLDEN_H = testh();\n@@ -68,1 +79,1 @@\n-    @Run(test = {\"testa\", \"testb\", \"testc\"})\n+    @Run(test = {\"testa\", \"testb\", \"testc\", \"testd\", \"teste\", \"testf\", \"testg\", \"testh\"})\n@@ -73,1 +84,6 @@\n-        compare(testb(), GOLDEN_C, \"testc\");\n+        compare(testc(), GOLDEN_C, \"testc\");\n+        compare(testd(), GOLDEN_D, \"testd\");\n+        compare(teste(), GOLDEN_E, \"teste\");\n+        compare(testf(), GOLDEN_F, \"testf\");\n+        compare(testg(), GOLDEN_G, \"testg\");\n+        compare(testh(), GOLDEN_H, \"testh\");\n@@ -136,0 +152,95 @@\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] testd() {\n+        int[] out = ioutArr;\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with the same structure.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out[i+1] += ((sArr1[2*i+2] * sArr2[2*i+2]) + (sArr1[2*i+3] * sArr2[2*i+3]));\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] teste() {\n+        int[] out = ioutArr;\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out[i+1] += ((sArr2[2*i+2] * sArr1[2*i+2]) + (sArr1[2*i+3] * sArr2[2*i+3])); \/\/ swap(1 2)\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] testf() {\n+        int[] out = ioutArr;\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out[i+1] += ((sArr2[2*i+2] * sArr1[2*i+2]) + (sArr2[2*i+3] * sArr1[2*i+3])); \/\/ swap(1 2), swap(3 4)\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] testg() {\n+        int[] out = ioutArr;\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out[i+1] += ((sArr1[2*i+3] * sArr2[2*i+3]) + (sArr1[2*i+2] * sArr2[2*i+2])); \/\/ swap(1 3), swap(2 4)\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] testh() {\n+        int[] out = ioutArr;\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out[i+1] += ((sArr2[2*i+3] * sArr1[2*i+3]) + (sArr2[2*i+2] * sArr1[2*i+2])); \/\/ swap(1 4), swap(2 3)\n+        }\n+        return out;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":115,"deletions":4,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327110 8327111\n+ * @requires vm.compiler2.enabled\n+ * @summary Test that DFS algorithm for cloning Template Assertion Predicate Expression does not endlessly process paths.\n+ * @run main\/othervm\/timeout=30 -Xcomp -XX:LoopMaxUnroll=0\n+ *                              -XX:CompileCommand=compileonly,*TestCloningWithManyDiamondsInExpression::test*\n+ *                              -XX:CompileCommand=inline,*TestCloningWithManyDiamondsInExpression::create*\n+ *                              compiler.predicates.TestCloningWithManyDiamondsInExpression\n+ * @run main\/othervm\/timeout=30 -Xbatch -XX:LoopMaxUnroll=0\n+ *                              -XX:CompileCommand=compileonly,*TestCloningWithManyDiamondsInExpression::test*\n+ *                              -XX:CompileCommand=inline,*TestCloningWithManyDiamondsInExpression::create*\n+ *                              compiler.predicates.TestCloningWithManyDiamondsInExpression\n+ * @run main\/timeout=30 compiler.predicates.TestCloningWithManyDiamondsInExpression\n+ *\/\n+\n+ \/*\n+  * @test\n+  * @bug 8327111\n+  * @summary Test that DFS algorithm for cloning Template Assertion Predicate Expression does not endlessly process paths.\n+  * @run main\/othervm\/timeout=30 -Xcomp\n+  *                              -XX:CompileCommand=compileonly,*TestCloningWithManyDiamondsInExpression::test*\n+  *                              -XX:CompileCommand=inline,*TestCloningWithManyDiamondsInExpression::create*\n+  *                              compiler.predicates.TestCloningWithManyDiamondsInExpression\n+  * @run main\/othervm\/timeout=30 -Xbatch\n+  *                              -XX:CompileCommand=compileonly,*TestCloningWithManyDiamondsInExpression::test*\n+  *                              -XX:CompileCommand=inline,*TestCloningWithManyDiamondsInExpression::create*\n+  *                              compiler.predicates.TestCloningWithManyDiamondsInExpression\n+  *\/\n+\n+package compiler.predicates;\n+\n+public class TestCloningWithManyDiamondsInExpression {\n+    static int limit = 100;\n+    static int iFld;\n+    static boolean flag;\n+    static int[] iArr;\n+\n+    public static void main(String[] strArr) {\n+        Math.min(10, 13); \/\/ Load class for Xcomp mode.\n+        for (int i = 0; i < 10_000; i++) {\n+            testSplitIf(i % 2);\n+            testLoopUnswitching(i % 2);\n+            testLoopUnrolling(i % 2);\n+            testLoopPeeling(i % 2);\n+        }\n+    }\n+\n+    static void testLoopUnswitching(int x) {\n+        \/\/ We create an array with a positive size whose type range is known by the C2 compiler to be positive.\n+        \/\/ Loop Predication will then be able to hoist the array check out of the loop by creating a Hoisted\n+        \/\/ Check Predicate accompanied by a Template Assertion Predicate. The Template Assertion Predicate\n+        \/\/ Expression gets the size as an input. When splitting the loop further (i.e. when doing Loop Unswitching),\n+        \/\/ the predicate needs to be updated. We need to clone all nodes of the Tempalte Assertion Predicate\n+        \/\/ Expression. We first need to find them by doing a DFS walk.\n+        \/\/\n+        \/\/ createExpressionWithManyDiamonds() creates an expression with many diamonds. The current implementation\n+        \/\/ (found in create_bool_from_template_assertion_predicate()) to clone the Template Assertion Predicate\n+        \/\/ does not use a visited set. Therefore, the DFS implementation visits nodes twice to discover more paths.\n+        \/\/ The more diamonds we add, the more possible paths we get to visit. This leads to an exponential explosion\n+        \/\/ of paths and time required to visit them all. This example here will get \"stuck\" during DFS while trying\n+        \/\/ to walk all the possible paths.\n+        \/\/\n+        int[] a = new int[createExpressionWithManyDiamonds(x) + 1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = i; \/\/ Loop Predication hoists this check and creates a Template Assertion Predicate.\n+            \/\/ Triggers Loop Unswitching -> we need to clone the Template Assertion Predicates\n+            \/\/ to both the true- and false-path loop. Will take forever (see explanation above).\n+            if (x == 0) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as for Loop Unswitching but triggered in Split If when the Tempalte Assertion Predicate Expression\n+    \/\/ needs to be cloned. This time it's not the size of the array that contains many diamonds but the array\n+    \/\/ index for the first and last value Template Assertion Predicate Expression.\n+    static void testSplitIf(int x) {\n+        int e = createExpressionWithManyDiamonds(x);\n+        iArr = new int[1000];\n+        int a;\n+        if (flag) {\n+            a = 4;\n+        } else {\n+            a = 3;\n+        }\n+\n+        for (int i = a; i < 100; i++) {\n+            iArr[i+e] = 34;\n+        }\n+    }\n+\n+    static void testLoopUnrolling(int x) {\n+        int[] a = new int[createExpressionWithManyDiamonds(x) + 1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = i; \/\/ Loop Predication hoists this check and creates a Template Assertion Predicate.\n+        }\n+    }\n+\n+    static void testLoopPeeling(int x) {\n+        int[] a = new int[createExpressionWithManyDiamonds(x) + 1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = i; \/\/ Loop Predication hoists this check and creates a Template Assertion Predicate.\n+            if (x == 0) { \/\/ Reason to peel with LoopMaxUnroll=0\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/\/ Creates in int expression with many diamonds. This method is forced-inlined.\n+    static int createExpressionWithManyDiamonds(int x) {\n+        int e = Math.min(10, Math.max(1, x));\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2) - 823542;\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2) - 823542;\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2) - 823542;\n+        return e;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestCloningWithManyDiamondsInExpression.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -82,1 +82,1 @@\n-              new OrPredicate(new CPUSpecificPredicate(\"riscv64.*\", new String[] { \"sha256\"       }, null),\n+              new OrPredicate(new CPUSpecificPredicate(\"riscv64.*\", new String[] { \"zvkn\"         }, null),\n@@ -95,1 +95,1 @@\n-              new OrPredicate(new CPUSpecificPredicate(\"riscv64.*\", new String[] { \"sha512\"       }, null),\n+              new OrPredicate(new CPUSpecificPredicate(\"riscv64.*\", new String[] { \"zvkn\"         }, null),\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/sha\/predicate\/IntrinsicPredicates.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp\n+ * @bug 8328702\n+ * @summary Check that SubTypeCheckNode is properly folded when having an array with bottom type elements checked\n+ *          against an interface.\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ *\/\n+\n+\/*\n+ * @test id=Xbatch\n+ * @bug 8328702\n+ * @summary Check that SubTypeCheckNode is properly folded when having an array with bottom type elements checked\n+ *          against an interface.\n+ *\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ *\/\n+\n+\/*\n+ * @test id=stress\n+ * @bug 8328702\n+ * @summary Check that PartialSubtypeCheckNode is properly folded when having an array with bottom type elements checked\n+ *          either against an interface or an unrelated non-sub-class.\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+ExpandSubTypeCheckAtParseTime\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+StressReflectiveCode\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+ExpandSubTypeCheckAtParseTime\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+StressReflectiveCode\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ *\/\n+\n+package compiler.types;\n+\n+public class TestSubTypeCheckWithBottomArray {\n+    static byte[] bArr = new byte[10];\n+    static Object[] oArr = new Object[10];\n+    static boolean flag;\n+\n+    public static void main(String[] args) {\n+        A a = new A();\n+        B b = new B();\n+        Y y = new Y();\n+        Z z = new Z();\n+        for (int i = 0; i < 10000; i++) {\n+            \/\/ With -Xcomp: Immediatly crashes because of no profiling -> don't know anything.\n+            checkInterface(a); \/\/ Make sure that checkInterface() sometimes passes instanceof.\n+            checkInterface(b); \/\/ Use two sub classes such that checkcast is required.\n+            testInterface();\n+\n+            checkClass(y); \/\/ Make sure that checkClass() sometimes passes instanceof.\n+            checkClass(z); \/\/ Use two sub classes such that checkcast is required.\n+            testClass();\n+            flag = !flag;\n+        }\n+    }\n+\n+    static void testInterface() {\n+        checkInterface(flag ? bArr : oArr); \/\/ Inlined, never passes instanceof\n+    }\n+\n+    static void checkInterface(Object o) {\n+        if (o instanceof I i) {\n+            \/\/ Use of i: Needs CheckCastPP which is replaced by top because [bottom <: I cannot be true.\n+            \/\/ But: SubTypeCheckNode is not folded away -> broken graph (data dies, control not)\n+            i.getClass();\n+        }\n+    }\n+\n+    static void testClass() {\n+        checkClass(flag ? bArr : oArr); \/\/ Inlined, never passes instanceof\n+    }\n+\n+    static void checkClass(Object o) {\n+        if (o instanceof X x) {\n+            \/\/ Use of i: Needs CheckCastPP which is replaced by top because [bottom <: I cannot be true.\n+            \/\/ But: SubTypeCheckNode is not folded away -> broken graph (data dies, control not)\n+            x.getClass();\n+        }\n+    }\n+\n+}\n+\n+interface I {}\n+class A implements I {}\n+class B implements I {}\n+\n+class X {}\n+class Y extends X {}\n+class Z extends X {}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestSubTypeCheckWithBottomArray.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-        checkPattern(\".*GC\\\\(0\\\\) .*Age table with threshold.*\", stdout);\n+        checkPattern(\".*GC\\\\(0\\\\) .*Age table:.*\", stdout);\n","filename":"test\/hotspot\/jtreg\/gc\/TestAgeOutput.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- *   -XX:+VerifyRememberedSets -XX:+VerifyObjectStartArray\n+ *   -XX:+VerifyRememberedSets\n@@ -58,1 +58,1 @@\n- *   -XX:+VerifyRememberedSets -XX:+VerifyObjectStartArray\n+ *   -XX:+VerifyRememberedSets\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerificationInConcurrentCycle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/x\/TestGarbageCollectorMXBean.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestGarbageCollectorMXBean.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,5 +78,5 @@\n-      #1.3 develop & notproduct flag on debug VM:\n-                                      develop & !product_build        notproduct & !product_build\n-                                      -XX:+DeoptimizeALot             -XX:+VerifyCodeCache\n-      -IgnoreUnrecognizedVMOptions               OK                            OK\n-      +IgnoreUnrecognizedVMOptions               OK                            OK\n+      #1.3 develop flag on debug VM:\n+                                      develop & !product_build\n+                                      -XX:+DeoptimizeALot\n+      -IgnoreUnrecognizedVMOptions               OK\n+      +IgnoreUnrecognizedVMOptions               OK\n@@ -86,1 +86,0 @@\n-      runJavaAndCheckExitValue(true, \"-XX:-IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyCodeCache\", \"-version\");\n@@ -88,1 +87,0 @@\n-      runJavaAndCheckExitValue(true, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyCodeCache\", \"-version\");\n@@ -92,5 +90,5 @@\n-      #1.4 develop & notproduct flag on product VM:\n-                                    develop & !product_build           notproduct & product_build\n-                                    -XX:+DeoptimizeALot                -XX:+VerifyCodeCache\n-      -IgnoreUnrecognizedVMOptions               ERR                           ERR\n-      +IgnoreUnrecognizedVMOptions               OK                            OK\n+      #1.4 develop flag on product VM:\n+                                    develop & product_build\n+                                    -XX:+DeoptimizeALot\n+      -IgnoreUnrecognizedVMOptions               ERR\n+      +IgnoreUnrecognizedVMOptions               OK\n@@ -100,1 +98,0 @@\n-      runJavaAndCheckExitValue(false, \"-XX:-IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyCodeCache\", \"-version\");\n@@ -102,1 +99,0 @@\n-      runJavaAndCheckExitValue(true, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyCodeCache\", \"-version\");\n@@ -107,5 +103,5 @@\n-      #1.5 malformed develop & notproduct flag on debug VM:\n-                                  develop & !product_build             notproduct & !product_build\n-                                  -XX:DeoptimizeALot                   -XX:VerifyCodeCache\n-      -IgnoreUnrecognizedVMOptions               ERR                           ERR\n-      +IgnoreUnrecognizedVMOptions               ERR                           ERR\n+      #1.5 malformed develop flag on debug VM:\n+                                  develop & !product_build\n+                                  -XX:DeoptimizeALot\n+      -IgnoreUnrecognizedVMOptions               ERR\n+      +IgnoreUnrecognizedVMOptions               ERR\n@@ -115,1 +111,0 @@\n-      runJavaAndCheckExitValue(false, \"-XX:-IgnoreUnrecognizedVMOptions\", \"-XX:VerifyCodeCache\", \"-version\");\n@@ -117,1 +112,0 @@\n-      runJavaAndCheckExitValue(false, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:VerifyCodeCache\", \"-version\");\n@@ -121,5 +115,5 @@\n-      #1.6 malformed develop & notproduct flag on product VM:\n-                                    develop & !product_build           notproduct & product_build\n-                                    -XX:DeoptimizeALot                 -XX:VerifyCodeCache\n-      -IgnoreUnrecognizedVMOptions               ERR                           ERR\n-      +IgnoreUnrecognizedVMOptions               OK                            OK\n+      #1.6 malformed develop flag on product VM:\n+                                    develop & !product_build\n+                                    -XX:DeoptimizeALot\n+      -IgnoreUnrecognizedVMOptions               ERR\n+      +IgnoreUnrecognizedVMOptions               OK\n@@ -129,1 +123,0 @@\n-      runJavaAndCheckExitValue(false, \"-XX:-IgnoreUnrecognizedVMOptions\", \"-XX:VerifyCodeCache\", \"-version\");\n@@ -131,1 +124,0 @@\n-      runJavaAndCheckExitValue(true, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:VerifyCodeCache\", \"-version\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/IgnoreUnrecognizedVMOptions.java","additions":21,"deletions":29,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-        allOptionsAsMap = JVMOptionsUtils.getOptionsWithRangeAsMap(origin -> (!(origin.contains(\"develop\") || origin.contains(\"notproduct\"))));\n+        allOptionsAsMap = JVMOptionsUtils.getOptionsWithRangeAsMap(origin -> (!origin.contains(\"develop\")));\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Warn if diagnostic or experimental vm option is used and -XX:+UnlockDiagnosticVMOptions or -XX:+UnlockExperimentalVMOptions, respectively, isn't specified. Warn if develop or notproduct vm option is used with product version of VM.\n+ * @summary Warn if diagnostic or experimental vm option is used and -XX:+UnlockDiagnosticVMOptions or -XX:+UnlockExperimentalVMOptions, respectively, isn't specified. Warn if develop vm option is used with product version of VM.\n@@ -47,1 +47,1 @@\n-            System.out.println(\"Skip the rest of the tests on debug builds since diagnostic, develop, and notproduct options are available on debug builds.\");\n+            System.out.println(\"Skip the rest of the tests on debug builds since diagnostic, and develop options are available on debug builds.\");\n@@ -60,5 +60,0 @@\n-\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+CheckCompressedOops\", \"-version\");\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"Error: VM option 'CheckCompressedOops' is notproduct and is available only in debug version of VM.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMOptionWarning.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+            \"-Xshare:off\",\n@@ -45,2 +46,1 @@\n-        \/\/ We do not explicitly limit MaxMetaspaceSize to a lower minimum. User can get as low as he wants.\n-        \/\/ However, you most certainly will hit either one of\n+        \/\/ -Xshare:off --version loads hundreds of classes and will hit either one of\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/MaxMetaspaceSizeTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,87 @@\n+\n+    private static ProcessBuilder processCommand(String loggingLevel) {\n+        return ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \/\/ Test doesn't need much Java heap:\n+            \"-Xmx100M\",\n+            \/\/ AvgMonitorsPerThreadEstimate == 1 means we'll start with\n+            \/\/ an in_use_list_ceiling of <n-threads> plus a couple of\n+            \/\/ of monitors for threads that call Object.wait().\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:AvgMonitorsPerThreadEstimate=1\",\n+            \/\/ MonitorUsedDeflationThreshold == 10 means we'll request\n+            \/\/ deflations when 10% of monitors are used rather than the\n+            \/\/ default 90%. This should allow the test to tolerate a burst\n+            \/\/ of used monitors by threads not under this test's control.\n+            \"-XX:MonitorUsedDeflationThreshold=10\",\n+            \/\/ Enable monitorinflation logging so we can see that\n+            \/\/ MonitorUsedDeflationThreshold and\n+            \/\/ NoAsyncDeflationProgressMaxoption are working.\n+            \"-Xlog:monitorinflation=\" + loggingLevel,\n+            \/\/ Run the test with inflate_count == 33 since that\n+            \/\/ reproduced the bug with JDK13. With inflate_count == 33, an\n+            \/\/ initial ceiling == 12 and MonitorUsedDeflationThreshold == 10,\n+            \/\/ we should hit NoAsyncDeflationProgressMax at least 3 times.\n+            \"MonitorUsedDeflationThresholdTest\", \"33\");\n+    }\n+\n+    private static void testProcess1() throws Exception {\n+        ProcessBuilder pb = processCommand(\"info\");\n+\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+        output_detail.shouldHaveExitValue(0);\n+\n+        \/\/ This mesg means:\n+        \/\/ - AvgMonitorsPerThreadEstimate == 1 reduced in_use_list_ceiling\n+        \/\/   to a small number.\n+        \/\/ - and we crossed MonitorUsedDeflationThreshold:\n+        output_detail.shouldMatch(\"begin deflating: .*\");\n+        System.out.println(\"Found beginning of a deflation cycle.\");\n+\n+        \/\/ This mesg means we hit NoAsyncDeflationProgressMax and\n+        \/\/ had to adjust the in_use_list_ceiling:\n+        String too_many = output_detail.firstMatch(\"Too many deflations without progress; .*\", 0);\n+        if (too_many == null) {\n+            output_detail.reportDiagnosticSummary();\n+            throw new RuntimeException(\"Did not find too_many string in output.\\n\");\n+        }\n+        System.out.println(\"too_many='\" + too_many + \"'\");\n+        \/\/ Uncomment the following line for dumping test output in passing runs:\n+        \/\/ output_detail.reportDiagnosticSummary();\n+\n+        System.out.println(\"PASSED.\");\n+    }\n+\n+    private static void testProcess2() throws Exception {\n+        ProcessBuilder pb = processCommand(\"debug\");\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+        output_detail.shouldHaveExitValue(0);\n+\n+        \/\/ Test that logging reports in_use_list with each iteration of the deflation thread in debug mode.\n+        \/\/ but not monitor details with each report\n+        output_detail.shouldMatch(   \".debug..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldNotMatch(\".debug..monitorinflation. .*is_busy\");\n+\n+        \/\/ Reporting stats at exit is in Info mode, and contains monitor details\n+        output_detail.shouldMatch(\".info ..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldMatch(\".info ..monitorinflation. .*is_busy\");\n+\n+        System.out.println(\"PASSED.\");\n+    }\n+\n+    private static void testProcess3() throws Exception {\n+        ProcessBuilder pb = processCommand(\"trace\");\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+        output_detail.shouldHaveExitValue(0);\n+\n+        \/\/ Test that logging reports in_use_list with each iteration of the deflation thread in debug mode.\n+        \/\/ and monitor details with each report\n+        output_detail.shouldMatch(\".debug..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldMatch(\".trace..monitorinflation. .*is_busy\");\n+\n+        \/\/ Reporting stats at exit is in Info mode, and contains monitor details\n+        output_detail.shouldMatch(\".info ..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldMatch(\".info ..monitorinflation. .*is_busy\");\n+\n+        System.out.println(\"PASSED.\");\n+    }\n+\n@@ -75,49 +162,4 @@\n-            \/\/ Without args we invoke the test in a java sub-process:\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                \/\/ Test doesn't need much Java heap:\n-                \"-Xmx100M\",\n-                \/\/ AvgMonitorsPerThreadEstimate == 1 means we'll start with\n-                \/\/ an in_use_list_ceiling of <n-threads> plus a couple of\n-                \/\/ of monitors for threads that call Object.wait().\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:AvgMonitorsPerThreadEstimate=1\",\n-                \/\/ MonitorUsedDeflationThreshold == 10 means we'll request\n-                \/\/ deflations when 10% of monitors are used rather than the\n-                \/\/ default 90%. This should allow the test to tolerate a burst\n-                \/\/ of used monitors by threads not under this test's control.\n-                \"-XX:MonitorUsedDeflationThreshold=10\",\n-                \/\/ Enable monitorinflation logging so we can see that\n-                \/\/ MonitorUsedDeflationThreshold and\n-                \/\/ NoAsyncDeflationProgressMaxoption are working.\n-                \"-Xlog:monitorinflation=info\",\n-                \/\/ Enable some safepoint logging for diagnostic purposes.\n-                \"-Xlog:safepoint+cleanup=info\",\n-                \"-Xlog:safepoint+stats=debug\",\n-                \/\/ Run the test with inflate_count == 33 since that\n-                \/\/ reproduced the bug with JDK13. With inflate_count == 33, an\n-                \/\/ initial ceiling == 12 and MonitorUsedDeflationThreshold == 10,\n-                \/\/ we should hit NoAsyncDeflationProgressMax at least 3 times.\n-                \"MonitorUsedDeflationThresholdTest\", \"33\");\n-\n-            OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n-            output_detail.shouldHaveExitValue(0);\n-\n-            \/\/ This mesg means:\n-            \/\/ - AvgMonitorsPerThreadEstimate == 1 reduced in_use_list_ceiling\n-            \/\/   to a small number.\n-            \/\/ - and we crossed MonitorUsedDeflationThreshold:\n-            output_detail.shouldMatch(\"begin deflating: .*\");\n-            System.out.println(\"Found beginning of a deflation cycle.\");\n-\n-            \/\/ This mesg means we hit NoAsyncDeflationProgressMax and\n-            \/\/ had to adjust the in_use_list_ceiling:\n-            String too_many = output_detail.firstMatch(\"Too many deflations without progress; .*\", 0);\n-            if (too_many == null) {\n-                output_detail.reportDiagnosticSummary();\n-                throw new RuntimeException(\"Did not find too_many string in output.\\n\");\n-            }\n-            System.out.println(\"too_many='\" + too_many + \"'\");\n-            \/\/ Uncomment the following line for dumping test output in passing runs:\n-            \/\/ output_detail.reportDiagnosticSummary();\n-\n-            System.out.println(\"PASSED.\");\n+            \/\/ Without args we invoke the tests in a java sub-process.\n+            testProcess1();\n+            testProcess2();\n+            testProcess3();\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorUsedDeflationThresholdTest.java","additions":92,"deletions":50,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n@@ -40,0 +41,2 @@\n+    static Object[] oa;\n+\n@@ -45,1 +48,1 @@\n-                Object[] oa = new Object[Integer.MAX_VALUE];\n+                oa = new Object[Integer.MAX_VALUE];\n@@ -53,3 +56,3 @@\n-                                                                             \"-XX:-CreateCoredumpOnCrash\", \"-Xmx128m\",\n-                                                                             \"-Xshare:on\", TestCDSVMCrash.class.getName(),\n-                                                                             \"throwOOME\");\n+                                                                      \"-XX:-CreateCoredumpOnCrash\", \"-Xmx128m\",\n+                                                                      \"-Xshare:on\", TestCDSVMCrash.class.getName(),\n+                                                                      \"throwOOME\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/TestCDSVMCrash.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/FillerObjectLoadTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+        long start = System.currentTimeMillis();\n@@ -44,1 +45,1 @@\n-\n+        System.out.println(\"findAllClasses = \" + (System.currentTimeMillis() - start) + \"ms\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfClasses.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -681,2 +681,0 @@\n-    static Pattern pattern;\n-\n@@ -685,1 +683,1 @@\n-        pattern = Pattern.compile(\"\/modules\/[a-z.]*[a-z]+\/([^-]*)[.]class\");\n+        Pattern pattern = Pattern.compile(\"\/modules\/[a-z.]*[a-z]+\/([^-]*)[.]class\");\n@@ -688,1 +686,1 @@\n-        findAllClassesAtPath(base, list);\n+        findAllClassesAtPath(base, pattern, list);\n@@ -691,1 +689,1 @@\n-    private static void findAllClassesAtPath(Path p, ArrayList<String> list) throws Exception {\n+    private static void findAllClassesAtPath(Path p, Pattern pattern, ArrayList<String> list) throws Exception {\n@@ -694,4 +692,8 @@\n-                Matcher matcher = pattern.matcher(entry.toString());\n-                if (matcher.find()) {\n-                    String className = matcher.group(1);\n-                    list.add(className);\n+                if (Files.isDirectory(entry)) {\n+                    findAllClassesAtPath(entry, pattern, list);\n+                } else {\n+                    Matcher matcher = pattern.matcher(entry.toString());\n+                    if (matcher.find()) {\n+                        String className = matcher.group(1);\n+                        list.add(className);\n+                    }\n@@ -699,3 +701,0 @@\n-                try {\n-                    findAllClassesAtPath(entry, list);\n-                } catch (Exception ex) {}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestDumpClassListSource.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test locking on shared strings\n- * @requires vm.cds.write.archived.java.heap\n- * @requires vm.gc == null\n- * @library \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/lib\n- * @compile LockStringTest.java LockStringValueTest.java\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run driver LockSharedStrings\n- *\/\n-\n-public class LockSharedStrings {\n-    public static void main(String[] args) throws Exception {\n-        SharedStringsUtils.run(args, LockSharedStrings::test);\n-    }\n-\n-    public static void test(String[] args) throws Exception {\n-        SharedStringsUtils.buildJarAndWhiteBox(\"LockStringTest\", \"LockStringValueTest\");\n-\n-        SharedStringsUtils.dumpWithWhiteBox(\n-            TestCommon.list(\"LockStringTest\", \"LockStringValueTest\"),\n-            \"ExtraSharedInput.txt\", \"-Xlog:cds,cds+hashtables\");\n-\n-        String[] extraMatch = new String[] {\"LockStringTest: PASS\"};\n-        SharedStringsUtils.runWithArchiveAndWhiteBox(extraMatch, \"LockStringTest\");\n-\n-        extraMatch = new String[] {\"LockStringValueTest: PASS\"};\n-        SharedStringsUtils.runWithArchiveAndWhiteBox(extraMatch, \"LockStringValueTest\",\n-            \"--add-opens=java.base\/java.lang=ALL-UNNAMED\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/LockSharedStrings.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class LockStringTest extends Thread {\n-    static String lock;\n-    static boolean done;\n-    static WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        if (!wb.areSharedStringsMapped()) {\n-            System.out.println(\"The shared strings are not mapped\");\n-            System.out.println(\"LockStringTest: PASS\");\n-            return;\n-        }\n-\n-        if (!wb.isSharedClass(LockStringTest.class)) {\n-            throw new RuntimeException(\"Failed: LockStringTest class is not shared.\");\n-        }\n-\n-        \/\/ Note: This class is archived. All string literals (including the ones used in this class)\n-        \/\/ in all archived classes are interned into the CDS shared string table.\n-\n-        doTest(\"StringLock\", false);\n-        doTest(\"\", true);\n-\n-        \/\/ The following string has a 0 hashCode. Calling String.hashCode() could cause\n-        \/\/ the String.hash field to be written into, if so make sure we don't functionally\n-        \/\/ break.\n-        doTest(\"\\u0121\\u0151\\u00a2\\u0001\\u0001\\udbb2\", true);\n-    }\n-\n-    private static void doTest(String s, boolean hasZeroHashCode) throws Exception {\n-        lock = s;\n-        done = false;\n-\n-        if (!wb.isSharedInternedString(lock)) {\n-            throw new RuntimeException(\"Failed: String \\\"\" + lock + \"\\\" is not shared.\");\n-        }\n-\n-        if (hasZeroHashCode && lock.hashCode() != 0) {\n-            throw new RuntimeException(\"Shared string \\\"\" + lock + \"\\\" should have 0 hashCode, but is instead \" + lock.hashCode());\n-        }\n-\n-        String copy = new String(lock);\n-        if (lock.hashCode() != copy.hashCode()) {\n-            throw new RuntimeException(\"Shared string \\\"\" + lock + \"\\\" does not have the same hashCode as its non-shared copy\");\n-        }\n-\n-        new LockStringTest().start();\n-\n-        synchronized(lock) {\n-            while (!done) {\n-                lock.wait();\n-            }\n-        }\n-        System.gc();\n-        System.out.println(\"LockStringTest: PASS\");\n-    }\n-\n-    public void run() {\n-        String shared = \"LiveOak\";\n-        synchronized (lock) {\n-            for (int i = 0; i < 100; i++) {\n-                new String(shared);\n-                System.gc();\n-                try {\n-                    sleep(5);\n-                } catch (InterruptedException e) {}\n-            }\n-            done = true;\n-            lock.notify();\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/LockStringTest.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.lang.reflect.*;\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/*\n- * Lock the 'value' field of a known shared string, java.lang.Object\n- *\/\n-public class LockStringValueTest {\n-    public static void main(String args[]) {\n-        String s = \"LiveOak\";\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-        if (!wb.areSharedStringsMapped()) {\n-            System.out.println(\"The shared strings are not mapped\");\n-            System.out.println(\"LockStringValueTest: PASS\");\n-            return;\n-        }\n-\n-        if (!wb.isSharedInternedString(s)) {\n-            throw new RuntimeException(\"LockStringValueTest Failed: String is not shared.\");\n-        }\n-\n-        Class c = s.getClass();\n-        try {\n-            Field f = c.getDeclaredField(\"value\");\n-            f.setAccessible(true);\n-            Object v = f.get(s);\n-            lock(v);\n-        } catch (NoSuchFieldException nfe) {\n-        } catch (IllegalAccessException iae) {}\n-    }\n-\n-    public static void lock(Object o) {\n-        synchronized (o) {\n-            System.out.println(\"LockStringValueTest: PASS\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/LockStringValueTest.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/ResolvedReferencesNotNullTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -72,3 +71,8 @@\n-        String test_cases[][] = {\n-            \/\/ default heap size\n-            {},\n+        OutputAnalyzer dumpOutput = TestCommon.dump(appJar, TestCommon.list(\"HelloString\"),\n+            TestCommon.concat(vmOptionsPrefix,\n+                \"-XX:SharedArchiveConfigFile=\" + sharedArchiveConfigFile,\n+                \"-Xlog:gc+region+cds\",\n+                \"-Xlog:gc+region=trace\"));\n+        TestCommon.checkDump(dumpOutput);\n+        dumpOutput.shouldContain(\"string table array (primary)\");\n+        dumpOutput.shouldContain(\"string table array (secondary)\");\n@@ -76,28 +80,3 @@\n-            \/\/ Test for handling of heap fragmentation. With sharedArchiveConfigFile, we will dump about\n-            \/\/ 18MB of shared objects on 64 bit VM (smaller on 32-bit).\n-            \/\/\n-            \/\/ During dump time, an extra copy of these objects are allocated,\n-            \/\/ so we need about 36MB, plus a few MB for other system data. So 64MB total heap\n-            \/\/ should be enough.\n-            \/\/\n-            \/\/ The VM should executed a full GC to maximize contiguous free space and\n-            \/\/ avoid fragmentation.\n-            {\"-Xmx64m\"},\n-        };\n-\n-        for (String[] extra_opts: test_cases) {\n-            vmOptionsPrefix = TestCommon.concat(vmOptionsPrefix, extra_opts);\n-\n-            OutputAnalyzer dumpOutput = TestCommon.dump(appJar, TestCommon.list(\"HelloString\"),\n-                TestCommon.concat(vmOptionsPrefix,\n-                    \"-XX:SharedArchiveConfigFile=\" + sharedArchiveConfigFile,\n-                    \"-Xlog:gc+region+cds\",\n-                    \"-Xlog:gc+region=trace\"));\n-            TestCommon.checkDump(dumpOutput);\n-            dumpOutput.shouldContain(\"string table array (primary)\");\n-            dumpOutput.shouldContain(\"string table array (secondary)\");\n-\n-            OutputAnalyzer execOutput = TestCommon.exec(appJar,\n-                TestCommon.concat(vmOptionsPrefix, \"-Xlog:cds\", \"HelloString\"));\n-            TestCommon.checkExec(execOutput);\n-        }\n+        OutputAnalyzer execOutput = TestCommon.exec(appJar,\n+            TestCommon.concat(vmOptionsPrefix, \"-Xlog:cds\", \"HelloString\"));\n+        TestCommon.checkExec(execOutput);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsStress.java","additions":12,"deletions":33,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-    rml.wait(0);\n+    while (bp_sync_reached) { \/\/ guard against spurious wakeups\n+      rml.wait(0);\n+    }\n@@ -56,1 +58,1 @@\n-  if (do_pop_frame != 0) {\n+  if (do_pop_frame) {\n@@ -155,2 +157,0 @@\n-  bool need_stop = false;\n-\n@@ -158,4 +158,8 @@\n-  while (!need_stop) {\n-    RawMonitorLocker rml(jvmti, jni, monitor);\n-    need_stop = bp_sync_reached;\n-    sleep_ms(1); \/\/ 1 millisecond\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+  int attempts = 0;\n+  while (!bp_sync_reached) {\n+    if (++attempts > 100) {\n+      fatal(jni, \"Main: ensureAtBreakpoint: waited 20 sec\");\n+    }\n+    LOG(\"Main: ensureAtBreakpoint: waiting 200 millis\\n\");\n+    rml.wait(200); \/\/ 200 milliseconds\n@@ -169,0 +173,3 @@\n+  if (!bp_sync_reached) { \/\/ better diagnosability\n+    fatal(jni, \"Main: notifyAtBreakpoint: expected: bp_sync_reached==true\");\n+  }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/PopFrameTest\/libPopFrameTest.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-javax\/management\/remote\/mandatory\/subjectDelegation\/SubjectDelegation1Test.java 0000000 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -137,1 +137,0 @@\n-java\/awt\/Frame\/ExceptionOnSetExtendedStateTest\/ExceptionOnSetExtendedStateTest.java 8198237 macosx-all\n@@ -186,0 +185,1 @@\n+java\/awt\/FullScreen\/BufferStrategyExceptionTest\/BufferStrategyExceptionTest.java 8246558 windows-all\n@@ -536,2 +536,0 @@\n-javax\/management\/remote\/mandatory\/subjectDelegation\/SubjectDelegation1Test.java 8149084 linux-aarch64\n-\n@@ -642,0 +640,1 @@\n+javax\/sound\/sampled\/Clip\/ClipFlushCrash.java 8308395 linux-x64\n@@ -664,1 +663,1 @@\n-javax\/swing\/JFileChooser\/8194044\/FileSystemRootTest.java 8320944 windows-all\n+javax\/swing\/JFileChooser\/8194044\/FileSystemRootTest.java 8327236 windows-all\n@@ -801,0 +800,1 @@\n+java\/awt\/Frame\/SizeMinimizedTest.java 8305915 linux-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1288,1 +1288,1 @@\n-\/\/ (See CompiledMethod::is_at_poll_return())\n+\/\/ (See nmethod::is_at_poll_return())\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,3 @@\n+\n+    public static final int COUNTER_TIMEOUT_SECONDS = 60;\n+\n@@ -87,2 +90,2 @@\n-            if (!counter.await(30, TimeUnit.SECONDS)) {\n-                throw new InterruptedException();\n+            if (!counter.await(COUNTER_TIMEOUT_SECONDS, TimeUnit.SECONDS)) {\n+                throw new Error(\"Client: Counter await expired\");\n@@ -97,1 +100,1 @@\n-            throw new Error(\"notification thread interrupted unexpectedly\");\n+            throw new Error(\"notification thread interrupted unexpectedly\", e);\n","filename":"test\/jdk\/com\/sun\/jmx\/remote\/NotificationMarshalVersions\/Client\/Client.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import java.nio.file.Path;\n@@ -56,1 +57,1 @@\n-            File flagsFile = File.createTempFile(\"CheckOriginFlags\", null);\n+            File flagsFile = File.createTempFile(\"CheckOriginFlags\", null, Path.of(\".\").toFile());\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/CheckOrigin.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    static boolean error = false;\n+    static boolean handlerIsDaemon = true;\n@@ -45,9 +45,1 @@\n-    public static void read (InputStream i) throws IOException {\n-        while (i.read() != -1);\n-        i.close();\n-    }\n-\n-    \/**\n-     * @param args\n-     *\/\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws IOException {\n@@ -56,3 +48,4 @@\n-                InputStream is = t.getRequestBody();\n-                read(is);\n-                \/\/ .. read the request body\n+                try (InputStream is = t.getRequestBody();\n+                     OutputStream os = t.getResponseBody()) {\n+                    is.readAllBytes();\n+                    \/\/ .. read the request body\n@@ -60,5 +53,4 @@\n-                t.sendResponseHeaders(200, response.length());\n-                OutputStream os = t.getResponseBody();\n-                os.write(response.getBytes());\n-                os.close();\n-                error = Thread.currentThread().isDaemon();\n+                    handlerIsDaemon = Thread.currentThread().isDaemon();\n+                    t.sendResponseHeaders(200, response.length());\n+                    os.write(response.getBytes());\n+                }\n@@ -68,0 +60,5 @@\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer server = HttpServer.create(new InetSocketAddress(loopback, 0), 10);\n+        server.createContext(\"\/apps\", new MyHandler());\n+        server.setExecutor(null);\n+        server.start();\n@@ -69,1 +66,0 @@\n-        HttpServer server;\n@@ -71,7 +67,0 @@\n-            InetAddress loopback = InetAddress.getLoopbackAddress();\n-            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10);\n-\n-            server.createContext(\"\/apps\", new MyHandler());\n-            server.setExecutor(null);\n-            \/\/ creates a default executor\n-                server.start();\n@@ -79,1 +68,0 @@\n-            String s = \"http:\/\/localhost:\"+port+\"\/apps\/foo\";\n@@ -81,10 +69,7 @@\n-                      .scheme(\"http\")\n-                      .loopback()\n-                      .port(port)\n-                      .path(\"\/apps\/foo\")\n-                      .toURL();\n-            InputStream is = url.openConnection(Proxy.NO_PROXY).getInputStream();\n-            read (is);\n-            server.stop(0);\n-            if (error) {\n-                throw new RuntimeException (\"error in test\");\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(port)\n+                    .path(\"\/apps\/foo\")\n+                    .toURL();\n+            try (InputStream is = url.openConnection(Proxy.NO_PROXY).getInputStream()) {\n+                is.readAllBytes();\n@@ -92,3 +77,4 @@\n-\n-        }\n-        catch (Exception e) {\n+            if (handlerIsDaemon) {\n+                throw new RuntimeException(\"request was handled by a daemon thread\");\n+            }\n+        } catch (Exception e) {\n@@ -96,0 +82,2 @@\n+        } finally {\n+            server.stop(0);\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6431193.java","additions":29,"deletions":41,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Point;\n+\n+\/*\n+ * @test\n+ * @bug 4340727\n+ * @summary Tests that undecorated property is set correctly\n+ *          when Frames and Dialogs are mixed.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FrameDialogMixedTest\n+ *\/\n+\n+public class FrameDialogMixedTest {\n+    private static final int SIZE = 100;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            When the test starts, a RED UNDECORATED Frame is seen.\n+            Click on \"Create Dialog\" button, you should see a GREEN UNDECORATED Dialog.\n+            If both the frame and the dialog are undecorated press PASS otherwise FAIL.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                      .title(\"Undecorated Frame & Dialog Test Instructions\")\n+                      .instructions(INSTRUCTIONS)\n+                      .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                      .columns(40)\n+                      .testUI(FrameDialogMixedTest::createUI)\n+                      .build()\n+                      .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame frame = new Frame(\"Undecorated Frame\");\n+        frame.setSize(SIZE, SIZE);\n+        frame.setBackground(Color.RED);\n+        frame.setUndecorated(true);\n+        frame.setLayout(new FlowLayout(FlowLayout.CENTER));\n+\n+        Button button = new Button(\"Create Dialog\");\n+        button.addActionListener(e -> {\n+            Dialog dialog = new Dialog(frame);\n+            Point frameLoc = frame.getLocationOnScreen();\n+            dialog.setBounds(frameLoc.x + frame.getSize().width + 5,\n+                             frameLoc.y,\n+                             SIZE, SIZE);\n+            dialog.setBackground(Color.GREEN);\n+            dialog.setUndecorated(true);\n+            dialog.setVisible(true);\n+        });\n+\n+        frame.add(button);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameDialogMixedTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Label;\n+\n+\/*\n+ * @test\n+ * @bug 4106068\n+ * @summary Test to verify maximized window is not too big\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FrameMaximizedTest\n+ *\/\n+\n+public class FrameMaximizedTest {\n+    public static void main (String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Maximize the frame window. Check that the right and bottom edges of the\n+                window are not off the edge of the screen. If they are not, the test\n+                is successful and the bug is fixed.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows(4)\n+                .columns(40)\n+                .testUI(new TestFrame())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class TestFrame extends Frame {\n+    public TestFrame() {\n+        setTitle(\"FrameMaximizedTest\");\n+        setSize(500, 300);\n+        add(\"North\", new Label(\"Maximize me and check if my \" +\n+                \"bottom and right edge are on screen.\"));\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameMaximizedTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+\n+\/*\n+ * @test\n+ * @bug 4172782\n+ * @summary Test if non-resizable frame is minimizable\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FrameMinimizeTest\n+ *\/\n+\n+public class FrameMinimizeTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                When the blank FrameMinimizeTest frame is shown, verify that\n+                  1. It is not resizable;\n+                  2. It is minimizable.\n+                                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows(4)\n+                .columns(35)\n+                .testUI(FrameMinimizeTest::initialize)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame initialize() {\n+        Frame f = new Frame(\"FrameMinimizeTest\");\n+        f.setSize(200, 200);\n+        f.setResizable(false);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameMinimizeTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.stream.Stream;\n+import javax.imageio.ImageIO;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4862945\n+ * @summary Undecorated frames miss certain mwm functions in the mwm hints.\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException\n+ * @run main MaximizeUndecoratedTest\n+ *\/\n+\n+public class MaximizeUndecoratedTest {\n+    private static final int SIZE = 300;\n+    private static final int OFFSET = 2;\n+\n+    private static Frame frame;\n+    private static Robot robot;\n+\n+    private static volatile Dimension screenSize;\n+    private static volatile Rectangle maxBounds;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Toolkit.getDefaultToolkit()\n+                    .isFrameStateSupported(Frame.MAXIMIZED_BOTH)) {\n+            throw new SkippedException(\"Test is not applicable as\"\n+                    + \" the Window manager does not support MAXIMIZATION\");\n+        }\n+\n+        try {\n+            robot = new Robot();\n+\n+            EventQueue.invokeAndWait(MaximizeUndecoratedTest::createUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+                maxBounds = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                                               .getMaximumWindowBounds();\n+                System.out.println(\"Maximum Window Bounds: \" + maxBounds);\n+                frame.setExtendedState(Frame.MAXIMIZED_BOTH);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            \/\/ Colors sampled at top-left, top-right, bottom-right & bottom-left\n+            \/\/ corners of maximized frame.\n+            Point[] points = new Point[] {\n+                    new Point(maxBounds.x + OFFSET, maxBounds.y + OFFSET),\n+                    new Point(maxBounds.width - OFFSET, maxBounds.y + OFFSET),\n+                    new Point(maxBounds.width - OFFSET, maxBounds.height - OFFSET),\n+                    new Point(maxBounds.x + OFFSET, maxBounds.height - OFFSET)\n+            };\n+\n+            if (!Stream.of(points)\n+                       .map(p -> robot.getPixelColor(p.x, p.y))\n+                       .allMatch(c -> c.equals(Color.GREEN))) {\n+                saveScreenCapture();\n+                throw new RuntimeException(\"Test Failed !! Frame not maximized.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.setExtendedState(Frame.NORMAL);\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new Frame(\"Test Maximization of Frame\");\n+        frame.setSize(SIZE, SIZE);\n+        frame.setBackground(Color.GREEN);\n+        frame.setResizable(true);\n+        frame.setUndecorated(true);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void saveScreenCapture() {\n+        BufferedImage image = robot.createScreenCapture(new Rectangle(new Point(),\n+                                                                      screenSize));\n+        try {\n+            ImageIO.write(image, \"png\", new File(\"MaximizedFrame.png\"));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/MaximizeUndecoratedTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.Label;\n+import java.awt.MediaTracker;\n+import java.awt.Panel;\n+import java.awt.Toolkit;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.image.ImageProducer;\n+import java.net.URL;\n+\n+\/*\n+ * @test\n+ * @bug 4175560\n+ * @summary Test use of user-defined icons\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MegaIconTest\n+ *\/\n+\n+public class MegaIconTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Each of the buttons in the main window represents a test\n+                of certain icon functionality -  background transparency\/opacity\n+                of the icon, scaling etc.\n+                Clicking on each button brings up a window displaying the graphic\n+                that should appear in the corresponding icon.\n+                Click on each button, minimize the resulting window, and check that\n+                the icon is displayed as the test name indicates.\n+                On Win32, icons should also be displayed correctly in the title bar.\n+                If all the test pass, then this test passes, else fail.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows(10)\n+                .columns(35)\n+                .testUI(MegaIconTest::initialize)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame initialize() {\n+        \/\/Create the iconTestFrames and add to IconTestButtons\n+        IconTestButtons itb = new IconTestButtons(new IconTestFrame[]{\n+                new IconTestFrame(\"Opaque, Scaled Icon Test\",\n+                        \"duke_404.gif\"),\n+\n+                new IconTestFrame(\"Transparent Icon\",\n+                        \"dukeWave.gif\"),\n+\n+                new IconTestFrameBG(\"Transparent, Scaled Icon with bg\",\n+                        \"fight.gif\", Color.red),\n+\n+                new IconTestFrameDlg(\"Transparent icon w\/ Dialog\",\n+                        \"dukeWave.gif\")\n+        });\n+        itb.pack();\n+        return itb;\n+    }\n+}\n+\n+class IconTestButtons extends Frame {\n+    public IconTestButtons(IconTestFrame[] iconTests) {\n+        IconTestFrame tempTest;\n+        Button newBtn;\n+        Panel newPnl;\n+        DoneLabel newLbl;\n+\n+        setTitle(\"MegaIconTest\");\n+\n+        setLayout(new GridLayout(iconTests.length, 1));\n+\n+        \/\/For each icon test frame\n+        \/\/Get name, add button with name and action to\n+        \/\/display the window, and add label \"done\" after\n+\n+        for (int i = 0; i < iconTests.length; i++) {\n+            tempTest = iconTests[i];\n+            newBtn = new Button(tempTest.getTestName());\n+            newLbl = new DoneLabel();\n+            newBtn.addActionListener(new IconTestActionListener(tempTest,\n+                    newLbl));\n+            newPnl = new Panel();\n+            newPnl.add(newBtn);\n+            newPnl.add(newLbl);\n+            add(newPnl);\n+        }\n+    }\n+\n+    protected class DoneLabel extends Label {\n+        public DoneLabel() {\n+            super(\"Done\");\n+            setVisible(false);\n+        }\n+    }\n+\n+    protected class IconTestActionListener implements ActionListener {\n+        IconTestFrame f;\n+        DoneLabel l;\n+\n+        public IconTestActionListener(IconTestFrame frame, DoneLabel label) {\n+            this.f = frame;\n+            this.l = label;\n+        }\n+\n+        public void actionPerformed(ActionEvent e) {\n+            f.pack();\n+            f.setVisible(true);\n+            l.setVisible(true);\n+            IconTestButtons.this.pack();\n+        }\n+    }\n+}\n+\n+class IconTestFrame extends Frame {\n+    private String testName;\n+    int width, height;\n+    Image iconImage;\n+    MediaTracker tracker;\n+\n+    public IconTestFrame(String testName, String iconFileName) {\n+        super(testName);\n+        this.testName = testName;\n+        tracker = new MediaTracker(this);\n+\n+        \/\/Set icon image\n+        URL url = MegaIconTest.class.getResource(iconFileName);\n+        Toolkit tk = Toolkit.getDefaultToolkit();\n+        if (tk == null) {\n+            System.out.println(\"Toolkit is null!\");\n+        }\n+        if (url == null) {\n+            System.out.println(\"Can't load icon is null!\");\n+            return;\n+        }\n+        try {\n+            iconImage = tk.createImage((ImageProducer) url.getContent());\n+        } catch (java.io.IOException e) {\n+            System.out.println(\"Unable to load icon image from url: \" + url);\n+        }\n+        tracker.addImage(iconImage, 0);\n+        try {\n+            tracker.waitForAll();\n+        } catch (java.lang.InterruptedException e) {\n+            System.err.println(e);\n+        }\n+        width = iconImage.getWidth(this);\n+        height = iconImage.getHeight(this);\n+        setIconImage(iconImage);\n+\n+        addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent e) {\n+                setVisible(false);\n+            }\n+        });\n+\n+        setLayout(new BorderLayout());\n+        setBackground(Color.YELLOW);\n+\n+        \/\/Add the icon graphic and instructions to the Frame\n+        add(new IconCanvas(), \"Center\");\n+        pack();\n+    }\n+\n+    class IconCanvas extends Canvas {\n+        public void paint(Graphics g) {\n+            if (IconTestFrame.this.iconImage == null) {\n+                throw new NullPointerException();\n+            }\n+            g.drawImage(IconTestFrame.this.iconImage, 0, 0, this);\n+        }\n+\n+        public Dimension getPreferredSize() {\n+            return new Dimension(IconTestFrame.this.width,\n+                    IconTestFrame.this.height);\n+        }\n+\n+        public Dimension getMinimumSize() {\n+            return getPreferredSize();\n+        }\n+\n+        public Dimension getMaximumSize() {\n+            return getPreferredSize();\n+        }\n+    }\n+\n+    public String getTestName() {\n+        return testName;\n+    }\n+}\n+\n+class IconTestFrameBG extends IconTestFrame {\n+    public IconTestFrameBG(String testName, String iconFileName, Color bg) {\n+        super(testName, iconFileName);\n+        setBackground(bg);\n+        Panel p = new Panel();\n+        p.setLayout(new GridLayout(3, 1));\n+        p.add(new Label(\"The background of this window has been set.\"));\n+        p.add(new Label(\"Unless the default icon background is the same color,\"));\n+        p.add(new Label(\"the icon background should NOT be this color.\"));\n+        add(p, \"North\");\n+        pack();\n+    }\n+}\n+\n+class IconTestFrameDlg extends IconTestFrame implements ActionListener {\n+    Dialog dlg;\n+    Button dlgBtn;\n+\n+    public IconTestFrameDlg(String testName, String iconFilename) {\n+        super(testName, iconFilename);\n+        Panel p = new Panel();\n+        p.setLayout(new GridLayout(4, 1));\n+        p.add(new Label(\"Click on the button below to display a child dialog.\"));\n+        p.add(new Label(\"On Win32, the Dialog's titlebar icon should match\"));\n+        p.add(new Label(\"the titlebar icon of this window.\"));\n+        p.add(new Label(\"Minimizing this Frame should yield only one icon.\"));\n+        add(p, \"North\");\n+\n+        dlg = new Dialog(this);\n+        dlg.setSize(200, 200);\n+        dlg.add(new Label(\"Dialog stuff.\"));\n+        dlg.addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent e) {\n+                setVisible(false);\n+            }\n+        });\n+\n+        dlgBtn = new Button(\"Display Dialog\");\n+        dlgBtn.addActionListener(this);\n+        add(dlgBtn, \"South\");\n+    }\n+\n+    public void actionPerformed(ActionEvent e) {\n+        dlg.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/MegaIconTest\/MegaIconTest.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"filename":"test\/jdk\/java\/awt\/Frame\/MegaIconTest\/dukeWave.gif","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/Frame\/MegaIconTest\/duke_404.gif","binary":true,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/Frame\/MegaIconTest\/fight.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/demo\/share\/jfc\/J2Ddemo\/images\/fight.gif","status":"copied"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import javax.imageio.ImageIO;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 6251941\n+ * @summary Undecorated frames should be minimizable.\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException\n+ * @run main MinimizeUndecoratedTest\n+ *\/\n+\n+public class MinimizeUndecoratedTest {\n+    private static final int SIZE = 300;\n+    private static final CountDownLatch isMinimized = new CountDownLatch(1);\n+\n+    private static Frame frame;\n+    private static Robot robot;\n+\n+    private static volatile Point frameLoc;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Toolkit.getDefaultToolkit()\n+                    .isFrameStateSupported(Frame.ICONIFIED)) {\n+            throw new SkippedException(\"Test is not applicable as\"\n+                    + \" the Window manager does not support MINIMIZATION\");\n+        }\n+\n+        try {\n+            robot = new Robot();\n+            EventQueue.invokeAndWait(MinimizeUndecoratedTest::createUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> frameLoc = frame.getLocationOnScreen());\n+\n+            Color beforeColor = robot.getPixelColor(frameLoc.x + SIZE \/ 2,\n+                                                    frameLoc.y + SIZE \/ 2);\n+\n+            EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.ICONIFIED));\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            if (!isMinimized.await(8, TimeUnit.SECONDS)) {\n+                throw new RuntimeException(\"Window iconified event not received.\");\n+            }\n+\n+            EventQueue.invokeAndWait(() -> System.out.println(\"Frame state: \"\n+                                                              + frame.getExtendedState()));\n+            Color afterColor = robot.getPixelColor(frameLoc.x + SIZE \/ 2,\n+                                                   frameLoc.y + SIZE \/ 2);\n+\n+            if (beforeColor.equals(afterColor)) {\n+                saveScreenCapture();\n+                throw new RuntimeException(\"Color before & after minimization : \"\n+                                           + beforeColor + \" vs \" + afterColor + \"\\n\"\n+                                           + \"Test Failed !! Frame not minimized.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.setExtendedState(Frame.NORMAL);\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new Frame(\"Test Minimization of Frame\");\n+        frame.setSize(SIZE, SIZE);\n+        frame.setBackground(Color.GREEN);\n+        frame.setResizable(true);\n+        frame.setUndecorated(true);\n+        frame.addWindowStateListener(new WindowAdapter() {\n+            @Override\n+            public void windowStateChanged(WindowEvent e) {\n+                if (e.getNewState() == Frame.ICONIFIED) {\n+                    System.out.println(\"Window iconified event received.\");\n+                    isMinimized.countDown();\n+                }\n+            }\n+        });\n+\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void saveScreenCapture() {\n+        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+        BufferedImage image = robot.createScreenCapture(new Rectangle(new Point(),\n+                                                                      screenSize));\n+        try {\n+            ImageIO.write(image, \"png\", new File(\"MinimizedFrame.png\"));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/MinimizeUndecoratedTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4065534\n+ * @summary Frame.setSize() doesn't change size if window is in an iconified state\n+ * @run main SizeMinimizedTest\n+ *\/\n+\n+public class SizeMinimizedTest {\n+    private static Frame frame;\n+    private static final int INITIAL_SIZE = 100;\n+    private static final int INITIAL_X = 150;\n+    private static final int INITIAL_Y = 50;\n+    private static final int RESET_SIZE = 200;\n+    private static final int OFFSET = 10;\n+    private static int iterationCnt = 0;\n+    private static Dimension expectedSize;\n+    private static Dimension frameSize;\n+    private static Point expectedLoc;\n+    private static Point frameLoc;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                createUI();\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                frame.setState(Frame.ICONIFIED);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                frame.setSize(RESET_SIZE, RESET_SIZE);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            for (int i = 0; i < 5; i++) {\n+                EventQueue.invokeAndWait(() -> {\n+                    Point pt = frame.getLocation();\n+                    frame.setLocation(pt.x + OFFSET, pt.y);\n+                });\n+                iterationCnt++;\n+                robot.waitForIdle();\n+                robot.delay(100);\n+            }\n+            EventQueue.invokeAndWait(() -> {\n+                frame.setState(Frame.NORMAL);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            System.out.println(\"Test Passed!\");\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void createUI() {\n+        frame = new Frame(\"Frame size test\");\n+        frame.setSize(INITIAL_SIZE, INITIAL_SIZE);\n+        frame.setLocation(INITIAL_X, INITIAL_Y);\n+\n+        frame.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowOpened(WindowEvent e) {\n+                System.out.println(\"Initial Frame Size: \" + frame.getSize());\n+                System.out.println(\"Initial Frame Location: \" +\n+                        frame.getLocationOnScreen());\n+            }\n+        });\n+\n+        frame.addWindowStateListener(new WindowAdapter() {\n+            @Override\n+            public void windowStateChanged(WindowEvent e) {\n+                if (e.getNewState() == Frame.NORMAL) {\n+                    System.out.println(\"Frame Size: \" + frame.getSize());\n+                    System.out.println(\"Frame Location: \" +\n+                            frame.getLocationOnScreen());\n+                    expectedSize = new Dimension(RESET_SIZE, RESET_SIZE);\n+                    frameSize = frame.getSize();\n+\n+                    if (!expectedSize.equals(frameSize)) {\n+                        throw new RuntimeException(\"Test Failed due to size mismatch.\");\n+                    }\n+\n+                    expectedLoc = new Point(INITIAL_X + OFFSET * iterationCnt,\n+                            INITIAL_Y);\n+                    frameLoc = frame.getLocationOnScreen();\n+\n+                    if (!expectedLoc.equals(frameLoc)) {\n+                        throw new RuntimeException(\"Test Failed due to \" +\n+                                \"location mismatch.\");\n+                    }\n+                }\n+            }\n+        });\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/SizeMinimizedTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -1,328 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  test %W% %E%  %I%, %G%\n-  @bug 6315717\n-  @summary  manual control over the Robot\n-  @author Andrei Dmitriev : area=awt.robot\n-  @run applet\/manual=yesno ManualInstructions.html\n-*\/\n-\n-import java.applet.Applet;\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.util.Timer;\n-import java.util.TimerTask;\n-\n-public class ManualInstructions extends Applet\n-{\n-    final static long SEND_DELAY = 1000;\n-\n-    public static void main(String s[]){\n-        ManualInstructions mi = new ManualInstructions();\n-        mi.init();\n-        mi.start();\n-    }\n-\n-    static Robot robot;\n-    Point mouseLocation; \/\/where mouse should be pressed each time\n-    Panel target = new Panel();\n-    Button pressOn = new Button(\"press on ...\");\n-    Button releaseOn = new Button(\"release on ...\");\n-    Button clickOn = new Button(\"click on ...\");\n-    Choice buttonNumber = new Choice();\n-\n-    public void init()\n-    {\n-        try {\n-            robot = new Robot();\n-        } catch (AWTException ex) {\n-            ex.printStackTrace();\n-            throw new RuntimeException(ex);\n-        }\n-        this.setLayout (new BorderLayout ());\n-\n-        target.setBackground(Color.green);\n-        target.setName(\"GreenBox\");\/\/for the ease of debug\n-        target.setPreferredSize(new Dimension(100, 100));\n-        String toolkit = Toolkit.getDefaultToolkit().getClass().getName();\n-\n-        \/\/ on X systems two buttons are reserved for wheel though they are countable by MouseInfo.\n-        int buttonsNumber = toolkit.equals(\"sun.awt.windows.WToolkit\")?MouseInfo.getNumberOfButtons():MouseInfo.getNumberOfButtons()-2;\n-\n-        for (int i = 0; i < 8; i++){\n-            buttonNumber.add(\"BUTTON\"+(i+1)+\"_MASK\");\n-        }\n-\n-        pressOn.addActionListener(new ActionListener(){\n-                public void actionPerformed(ActionEvent e){\n-                    System.out.println(\"Now pressing : \" + (buttonNumber.getSelectedIndex()+1));\n-\n-                    Timer timer = new Timer();\n-                    TimerTask robotInteraction = new TimerTask(){\n-                            public void run(){\n-                                robot.mouseMove(updateTargetLocation().x, updateTargetLocation().y);\n-                                robot.mousePress(getMask(buttonNumber.getSelectedIndex()+1));\n-                            }\n-                        };\n-                    timer.schedule(robotInteraction, SEND_DELAY);\n-                }\n-            });\n-\n-        releaseOn.addActionListener(new ActionListener(){\n-            public void actionPerformed(ActionEvent e){\n-                System.out.println(\"Now releasing : \" + (buttonNumber.getSelectedIndex()+1));\n-                Timer timer = new Timer();\n-                TimerTask robotInteraction = new TimerTask(){\n-                        public void run(){\n-                            robot.mouseMove(updateTargetLocation().x, updateTargetLocation().y);\n-                            robot.mouseRelease(getMask(buttonNumber.getSelectedIndex()+1));\n-                        }\n-                    };\n-                timer.schedule(robotInteraction, SEND_DELAY);\n-            }\n-        });\n-\n-        clickOn.addActionListener(new ActionListener(){\n-            public void actionPerformed(ActionEvent e){\n-                System.out.println(\"Now clicking : \" + (buttonNumber.getSelectedIndex()+1));\n-                Timer timer = new Timer();\n-                TimerTask robotInteraction = new TimerTask(){\n-                        public void run(){\n-                            robot.mouseMove(updateTargetLocation().x, updateTargetLocation().y);\n-                            robot.mousePress(getMask(buttonNumber.getSelectedIndex()+1));\n-                            robot.mouseRelease(getMask(buttonNumber.getSelectedIndex()+1));\n-                        }\n-                    };\n-                timer.schedule(robotInteraction, SEND_DELAY);\n-            }\n-\n-        });\n-        target.addMouseListener(new MouseAdapter(){\n-           public void mousePressed(MouseEvent e){\n-                Sysout.println(\"\"+e);\n-           }\n-           public void mouseReleased(MouseEvent e){\n-                Sysout.println(\"\"+e);\n-           }\n-           public void mouseClicked(MouseEvent e){\n-                Sysout.println(\"\"+e);\n-           }\n-        });\n-\n-        String[] instructions =\n-        {\n-            \"Do provide an instruction to the robot by\",\n-            \"choosing the button number to act and \",\n-            \"pressing appropriate java.awt.Button on the left.\",\n-            \"Inspect an output in the TextArea below.\",\n-            \"Please don't generate non-natural sequences like Release-Release, etc.\",\n-            \"If you use keyboard be sure that you released the keyboard shortly.\",\n-            \"If events are generated well press Pass, otherwise Fail.\"\n-        };\n-        Sysout.createDialogWithInstructions( instructions );\n-\n-    }\/\/End  init()\n-\n-    private int getMask(int button){\n-        return InputEvent.getMaskForButton(button);\n-\n-        \/*\n-            \/\/this only works for standard buttons and for old JDK builds\n-        int mask = 0;\n-        switch (button){\n-        case 1: {\n-            mask = InputEvent.BUTTON1_MASK;\n-            break;\n-        }\n-        case 2: {\n-            mask = InputEvent.BUTTON2_MASK;\n-            break;\n-        }\n-        case 3: {\n-            mask = InputEvent.BUTTON3_MASK;\n-            break;\n-        }\n-        }\n-        return mask;\n-        *\/\n-    }\n-\n-    private Point updateTargetLocation() {\n-        return new Point(target.getLocationOnScreen().x + target.getWidth()\/2, target.getLocationOnScreen().y + target.getHeight()\/2);\n-    }\n-\n-    public void start ()\n-    {\n-        \/\/Get things going.  Request focus, set size, et cetera\n-        setSize (200,200);\n-        setVisible(true);\n-        validate();\n-        Frame f = new Frame (\"Set action for Robot here.\");\n-        f.setLayout(new FlowLayout());\n-        f.add(buttonNumber);\n-        f.add(pressOn);\n-        f.add(releaseOn);\n-        f.add(clickOn);\n-        f.add(target);\n-        f.pack();\n-        f.setVisible(true);\n-     }\/\/ start()\n-}\/\/ class\n-\n-\/* Place other classes related to the test after this line *\/\n-\n-\n-\/****************************************************\n- Standard Test Machinery\n- DO NOT modify anything below -- it's a standard\n-  chunk of code whose purpose is to make user\n-  interaction uniform, and thereby make it simpler\n-  to read and understand someone else's test.\n- ****************************************************\/\n-\n-\/**\n- This is part of the standard test machinery.\n- It creates a dialog (with the instructions), and is the interface\n-  for sending text messages to the user.\n- To print the instructions, send an array of strings to Sysout.createDialog\n-  WithInstructions method.  Put one line of instructions per array entry.\n- To display a message for the tester to see, simply call Sysout.println\n-  with the string to be displayed.\n- This mimics System.out.println but works within the test harness as well\n-  as standalone.\n- *\/\n-\n-class Sysout\n-{\n-    private static TestDialog dialog;\n-\n-    public static void createDialogWithInstructions( String[] instructions )\n-    {\n-        dialog = new TestDialog( new Frame(), \"Instructions\" );\n-        dialog.printInstructions( instructions );\n-        dialog.setVisible(true);\n-        println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-    public static void createDialog( )\n-    {\n-        dialog = new TestDialog( new Frame(), \"Instructions\" );\n-        String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-        dialog.printInstructions( defInstr );\n-        dialog.setVisible(true);\n-        println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-    public static void printInstructions( String[] instructions )\n-    {\n-        dialog.printInstructions( instructions );\n-    }\n-\n-\n-    public static void println( String messageIn )\n-    {\n-        dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog\n-{\n-\n-    TextArea instructionsText;\n-    TextArea messageText;\n-    int maxStringLength = 120;\n-\n-    \/\/DO NOT call this directly, go through Sysout\n-    public TestDialog( Frame frame, String name )\n-    {\n-        super( frame, name );\n-        int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-        instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-        add( \"North\", instructionsText );\n-\n-        messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-        add(\"Center\", messageText);\n-\n-        pack();\n-\n-        setVisible(true);\n-    }\/\/ TestDialog()\n-\n-    \/\/DO NOT call this directly, go through Sysout\n-    public void printInstructions( String[] instructions )\n-    {\n-        \/\/Clear out any current instructions\n-        instructionsText.setText( \"\" );\n-\n-        \/\/Go down array of instruction strings\n-\n-        String printStr, remainingStr;\n-        for( int i=0; i < instructions.length; i++ )\n-        {\n-            \/\/chop up each into pieces maxSringLength long\n-            remainingStr = instructions[ i ];\n-            while( remainingStr.length() > 0 )\n-            {\n-                \/\/if longer than max then chop off first max chars to print\n-                if( remainingStr.length() >= maxStringLength )\n-                {\n-                    \/\/Try to chop on a word boundary\n-                    int posOfSpace = remainingStr.\n-                        lastIndexOf( ' ', maxStringLength - 1 );\n-\n-                    if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-                    printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-                    remainingStr = remainingStr.substring( posOfSpace + 1 );\n-                }\n-                \/\/else just print\n-                else\n-                {\n-                    printStr = remainingStr;\n-                    remainingStr = \"\";\n-                }\n-\n-                instructionsText.append( printStr + \"\\n\" );\n-            }\/\/ while\n-        }\/\/ for\n-    }\/\/printInstructions()\n-\n-    \/\/DO NOT call this directly, go through Sysout\n-    public void displayMessage( String messageIn )\n-    {\n-        messageText.append( messageIn + \"\\n\" );\n-        System.out.println(messageIn);\n-    }\n-\n-}\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/Robot\/ManualInstructions\/ManualInstructions.java","additions":0,"deletions":328,"binary":false,"changes":328,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.Color;\n-import java.awt.Graphics2D;\n-import java.awt.event.ActionEvent;\n-import java.awt.print.PageFormat;\n-import java.awt.print.Paper;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterJob;\n-\n-import javax.swing.JButton;\n-\n-\/*\n- * @test\n- * @bug 5024549\n- * @key printer\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n- * @summary Pass if dialogs are modal.\n- * @run main\/manual PrintModalDialog\n- *\/\n-\n-public class PrintModalDialog {\n-    private static JButton jButton1;\n-    private static final String INSTRUCTIONS =\n-            \"\"\"\n-             Click the \"PRINT\" button in the test window. A new dialog\n-             should appear to print the page. Test if this print new dialog\n-             is actually modal.\n-\n-             Modal in this case means that it blocks the user from interacting\n-             with other windows in the same application. You may still be able\n-             to interact with unrelated applications on the desktop.\n-             One sure way to test this is to first show the print dialog and\n-             then press \"Fail\", because if you can click on \"Fail\" and have it\n-             respond, then the print dialog was not modal. If clicking on it\n-             does nothing then cancel the print dialog and do the same for the\n-             other print dialog. If all is well, then press Pass.\n-            \"\"\";\n-\n-    public static void main(String[] args) throws Exception {\n-        PassFailJFrame\n-                .builder()\n-                .title(\"PrintModalDialog Instructions\")\n-                .instructions(INSTRUCTIONS)\n-                .rows((int) INSTRUCTIONS.lines().count() + 1)\n-                .columns(40)\n-                .splitUIBottom(PrintModalDialog::createAndShowGUI)\n-                .build()\n-                .awaitAndCheck();\n-    }\n-\n-    public static JButton createAndShowGUI() {\n-        jButton1 = new JButton(\"PRINT\");\n-        jButton1.addActionListener(e -> jButton1_actionPerformed(e));\n-        return jButton1;\n-    }\n-\n-    static void jButton1_actionPerformed(ActionEvent e) {\n-        PrinterJob printJob = null;\n-        PageFormat pageFormat = null;\n-        Paper prtPaper = null;\n-        boolean bPrintFlg = true;\n-\n-        try {\n-            printJob = PrinterJob.getPrinterJob();\n-        }\n-        catch (SecurityException se) {\n-            bPrintFlg = false;\n-        }\n-\n-        if (bPrintFlg) {\n-            pageFormat = printJob.pageDialog(printJob.defaultPage());\n-            System.out.println(\"PrintModalDialog: pageFormat = \" +\n-                    pageFormat.getWidth() \/ 72.0 + \" x \" +\n-                    pageFormat.getHeight() \/ 72.0);\n-            if (pageFormat != null) {\n-                prtPaper = pageFormat.getPaper();\n-                pageFormat.setPaper(prtPaper);\n-                printJob.setPrintable((g, pf, page) -> {\n-                    System.out.println(\"Calling print\");\n-                    if (page == 0) {\n-                        Graphics2D g2 = (Graphics2D)g;\n-                        g2.translate(pf.getImageableX(), pf.getImageableY());\n-                        g2.setColor(Color.black);\n-                        g2.drawString(\"Hello World\", 20, 100);\n-\n-                        return Printable.PAGE_EXISTS;\n-                    }\n-                    return Printable.NO_SUCH_PAGE;\n-                }, pageFormat);\n-            }\n-\n-            if (printJob.printDialog()) {\n-                try {\n-                    printJob.print();\n-                }\n-                catch (java.awt.print.PrinterException ex) {\n-                    ex.printStackTrace();\n-                    String msg = \"PrinterException: \" + ex.getMessage();\n-                    PassFailJFrame.forceFail(msg);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/print\/Dialog\/PrintModalDialog.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,20 +24,1 @@\n-\/*\n-  @test\n-  @bug 4199506\n-  @summary  java.awt.print.PageFormat.setpaper(Paper paper)\n-                 assertion test fails by not throwing\n-                 NullPointerException when a null paper instance is\n-                 passed as argument and this is specified in the doc.\n-  @run main NullPaper\n-*\/\n-\n-\n-\/\/*** global search and replace NullPaper with name of the test ***\n-\n-\/**\n- * NullPaper.java\n- *\n- * summary: java.awt.print.PageFormat.setpaper(Paper paper)\n-                 assertion test fails by not throwing\n-                 NullPointerException when a null paper instance is\n-                 passed as argument and this is specified in the doc.\n+import java.awt.print.PageFormat;\n@@ -45,0 +26,6 @@\n+\/*\n+ * @test\n+ * @bug 4199506\n+ * @summary Verify PageFormat.setPaper(null) throws NullPointerException\n+ *          as specified\n+ * @run main NullPaper\n@@ -46,126 +33,13 @@\n-\n-import java.awt.print.*;\n-\n-\/\/ This test is a \"main\" test as applets would need Runtime permission\n-\/\/ \"queuePrintJob\".\n-\n-public class NullPaper {\n-\n-   private static void init()\n-    {\n-    boolean settingNullWorked = false;\n-\n-    try {\n-        \/* Setting the paper to null should throw an exception.\n-         * The bug was the exception was not being thrown.\n-         *\/\n-        new PageFormat().setPaper(null);\n-        settingNullWorked = true;\n-\n-    \/* If the test succeeds we'll end up here, so write\n-     * to standard out.\n-     *\/\n-    } catch (NullPointerException e) {\n-        pass();\n-\n-    \/* The test failed if we end up here because an exception\n-     * other than the one we were expecting was thrown.\n-     *\/\n-    } catch (Exception e) {\n-        fail(\"Instead of the expected NullPointerException, '\" + e + \"' was thrown.\");\n-    }\n-\n-    if (settingNullWorked) {\n-        fail(\"The expected NullPointerException was not thrown\");\n-    }\n-\n-    }\/\/End  init()\n-\n-\n-   \/*****************************************************\n-     Standard Test Machinery Section\n-      DO NOT modify anything in this section -- it's a\n-      standard chunk of code which has all of the\n-      synchronisation necessary for the test harness.\n-      By keeping it the same in all tests, it is easier\n-      to read and understand someone else's test, as\n-      well as insuring that all tests behave correctly\n-      with the test harness.\n-     There is a section following this for test-defined\n-      classes\n-   ******************************************************\/\n-   private static boolean theTestPassed = false;\n-   private static boolean testGeneratedInterrupt = false;\n-   private static String failureMessage = \"\";\n-\n-   private static Thread mainThread = null;\n-\n-   private static int sleepTime = 300000;\n-\n-   public static void main( String args[] ) throws InterruptedException\n-    {\n-      mainThread = Thread.currentThread();\n-      try\n-       {\n-         init();\n-       }\n-      catch( TestPassedException e )\n-       {\n-         \/\/The test passed, so just return from main and harness will\n-         \/\/ interepret this return as a pass\n-         return;\n-       }\n-      \/\/At this point, neither test passed nor test failed has been\n-      \/\/ called -- either would have thrown an exception and ended the\n-      \/\/ test, so we know we have multiple threads.\n-\n-      \/\/Test involves other threads, so sleep and wait for them to\n-      \/\/ called pass() or fail()\n-      try\n-       {\n-         Thread.sleep( sleepTime );\n-         \/\/Timed out, so fail the test\n-         throw new RuntimeException( \"Timed out after \" + sleepTime\/1000 + \" seconds\" );\n-       }\n-      catch (InterruptedException e)\n-       {\n-         if( ! testGeneratedInterrupt ) throw e;\n-\n-         \/\/reset flag in case hit this code more than once for some reason (just safety)\n-         testGeneratedInterrupt = false;\n-         if ( theTestPassed == false )\n-          {\n-            throw new RuntimeException( failureMessage );\n-          }\n-       }\n-\n-    }\/\/main\n-\n-   public static synchronized void setTimeoutTo( int seconds )\n-    {\n-      sleepTime = seconds * 1000;\n-    }\n-\n-   public static synchronized void pass()\n-    {\n-      System.out.println( \"The test passed.\" );\n-      \/\/first check if this is executing in main thread\n-      if ( mainThread == Thread.currentThread() )\n-       {\n-         \/\/Still in the main thread, so set the flag just for kicks,\n-         \/\/ and throw a test passed exception which will be caught\n-         \/\/ and end the test.\n-         theTestPassed = true;\n-         throw new TestPassedException();\n-       }\n-      \/\/pass was called from a different thread, so set the flag and interrupt\n-      \/\/ the main thead.\n-      theTestPassed = true;\n-      testGeneratedInterrupt = true;\n-      mainThread.interrupt();\n-    }\/\/pass()\n-\n-   public static synchronized void fail()\n-    {\n-      \/\/test writer didn't specify why test failed, so give generic\n-      fail( \"it just plain failed! :-)\" );\n+public final class NullPaper {\n+    public static void main(String[] args) {\n+        try {\n+            \/* Setting the paper to null should throw an exception.\n+             * The bug was the exception was not being thrown.\n+             *\/\n+            new PageFormat().setPaper(null);\n+\n+            throw new RuntimeException(\"NullPointerException is expected \"\n+                                       + \"but not thrown\");\n+        } catch (NullPointerException e) {\n+            System.out.println(\"NullPointerException caught - test passes\");\n+        }\n@@ -173,24 +47,1 @@\n-\n-   public static synchronized void fail( String whyFailed )\n-    {\n-      System.out.println( \"The test failed: \" + whyFailed );\n-      \/\/check if this called from main thread\n-      if ( mainThread == Thread.currentThread() )\n-       {\n-         \/\/If main thread, fail now 'cause not sleeping\n-         throw new RuntimeException( whyFailed );\n-       }\n-      theTestPassed = false;\n-      testGeneratedInterrupt = true;\n-      failureMessage = whyFailed;\n-      mainThread.interrupt();\n-    }\/\/fail()\n-\n- }\/\/ class NullPaper\n-\n-\/\/This exception is used to exit from any level of call nesting\n-\/\/ when it's determined that the test has passed, and immediately\n-\/\/ end the test.\n-class TestPassedException extends RuntimeException\n- {\n- }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PageFormat\/NullPaper.java","additions":22,"deletions":171,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,18 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridLayout;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Paper;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -26,5 +43,1 @@\n- * @bug 4197377\n- * @bug 4299145\n- * @bug 6358747\n- * @bug 6574633\n- * @summary Page setup dialog settings\n+ * @bug 4197377 4299145 6358747 6574633\n@@ -32,0 +45,3 @@\n+ * @summary Page setup dialog settings\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -34,5 +50,0 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-\n@@ -40,42 +51,67 @@\n-\n-  PrinterJob myPrinterJob;\n-  PageFormat myPageFormat;\n-  Label pw, ph, pglm, pgiw, pgrm, pgtm, pgih, pgbm;\n-  Label myWidthLabel;\n-  Label myHeightLabel;\n-  Label myImageableXLabel;\n-  Label myImageableYLabel;\n-  Label myImageableRightLabel;\n-  Label myImageableBottomLabel;\n-  Label myImageableWidthLabel;\n-  Label myImageableHeightLabel;\n-  Label myOrientationLabel;\n-  Checkbox reverseCB;\n-  boolean alpha = false;\n-  boolean reverse = false;\n-\n-  protected void displayPageFormatAttributes() {\n-\n-    myWidthLabel.setText(\"Format Width = \" + (float)myPageFormat.getWidth());\n-    myHeightLabel.setText(\"Format Height = \" + (float)myPageFormat.getHeight());\n-    myImageableXLabel.setText\n-        (\"Format Left Margin = \" + (float)myPageFormat.getImageableX());\n-    myImageableRightLabel.setText\n-        (\"Format Right Margin = \" + (float)(myPageFormat.getWidth() -\n-        (myPageFormat.getImageableX() + myPageFormat.getImageableWidth())));\n-    myImageableWidthLabel.setText\n-        (\"Format ImageableWidth = \" + (float)myPageFormat.getImageableWidth());\n-    myImageableYLabel.setText\n-        (\"Format Top Margin = \" + (float)myPageFormat.getImageableY());\n-    myImageableBottomLabel.setText\n-        (\"Format Bottom Margin = \" + (float)(myPageFormat.getHeight() -\n-        (myPageFormat.getImageableY() + myPageFormat.getImageableHeight())));\n-    myImageableHeightLabel.setText\n-        (\"Format ImageableHeight = \" + (float)myPageFormat.getImageableHeight());\n-    int o = myPageFormat.getOrientation();\n-    if (o == PageFormat.LANDSCAPE && reverse) {\n-        o = PageFormat.REVERSE_LANDSCAPE;\n-        myPageFormat.setOrientation(PageFormat.REVERSE_LANDSCAPE);\n-    } else if (o == PageFormat.REVERSE_LANDSCAPE && !reverse) {\n-        o = PageFormat.LANDSCAPE;\n-        myPageFormat.setOrientation(PageFormat.LANDSCAPE);\n+    PrinterJob myPrinterJob;\n+    PageFormat myPageFormat;\n+    Label pw, ph, pglm, pgiw, pgrm, pgtm, pgih, pgbm;\n+    Label myWidthLabel;\n+    Label myHeightLabel;\n+    Label myImageableXLabel;\n+    Label myImageableYLabel;\n+    Label myImageableRightLabel;\n+    Label myImageableBottomLabel;\n+    Label myImageableWidthLabel;\n+    Label myImageableHeightLabel;\n+    Label myOrientationLabel;\n+    Checkbox reverseCB;\n+    boolean alpha = false;\n+    boolean reverse = false;\n+\n+    private static final String INSTRUCTIONS =\n+            \" This test is very flexible and requires much interaction.\\n\" +\n+            \" If the platform print dialog supports it, adjust orientation\\n\" +\n+            \" and margins and print pages and compare the results with the request.\";\n+\n+    protected void displayPageFormatAttributes() {\n+        myWidthLabel.setText(\"Format Width = \" + myPageFormat.getWidth());\n+        myHeightLabel.setText(\"Format Height = \" + myPageFormat.getHeight());\n+        myImageableXLabel.setText(\"Format Left Margin = \"\n+                + myPageFormat.getImageableX());\n+        myImageableRightLabel.setText(\"Format Right Margin = \"\n+                + (myPageFormat.getWidth()\n+                        - (myPageFormat.getImageableX() + myPageFormat.getImageableWidth())));\n+        myImageableWidthLabel.setText(\"Format ImageableWidth = \"\n+                + myPageFormat.getImageableWidth());\n+        myImageableYLabel.setText(\"Format Top Margin = \"\n+                + myPageFormat.getImageableY());\n+        myImageableBottomLabel.setText(\"Format Bottom Margin = \"\n+                + (myPageFormat.getHeight()\n+                        - (myPageFormat.getImageableY() + myPageFormat.getImageableHeight())));\n+        myImageableHeightLabel.setText(\"Format ImageableHeight = \"\n+                + myPageFormat.getImageableHeight());\n+        int o = myPageFormat.getOrientation();\n+        if (o == PageFormat.LANDSCAPE && reverse) {\n+            o = PageFormat.REVERSE_LANDSCAPE;\n+            myPageFormat.setOrientation(PageFormat.REVERSE_LANDSCAPE);\n+        } else if (o == PageFormat.REVERSE_LANDSCAPE && !reverse) {\n+            o = PageFormat.LANDSCAPE;\n+            myPageFormat.setOrientation(PageFormat.LANDSCAPE);\n+        }\n+        myOrientationLabel.setText\n+                (\"Format Orientation = \" +\n+                        (switch (o) {\n+                            case PageFormat.PORTRAIT -> \"PORTRAIT\";\n+                            case PageFormat.LANDSCAPE -> \"LANDSCAPE\";\n+                            case PageFormat.REVERSE_LANDSCAPE -> \"REVERSE_LANDSCAPE\";\n+                            default -> \"<invalid>\";\n+                        }));\n+        Paper p = myPageFormat.getPaper();\n+        pw.setText(\"Paper Width = \" + p.getWidth());\n+        ph.setText(\"Paper Height = \" + p.getHeight());\n+        pglm.setText(\"Paper Left Margin = \" + p.getImageableX());\n+        pgiw.setText(\"Paper Imageable Width = \" + p.getImageableWidth());\n+        pgrm.setText(\"Paper Right Margin = \"\n+                + (p.getWidth()\n+                        - (p.getImageableX() + p.getImageableWidth())));\n+        pgtm.setText(\"Paper Top Margin = \" + p.getImageableY());\n+        pgih.setText(\"Paper Imageable Height = \" + p.getImageableHeight());\n+        pgbm.setText(\"Paper Bottom Margin = \"\n+                + (p.getHeight()\n+                        - (p.getImageableY() + p.getImageableHeight())));\n@@ -83,18 +119,0 @@\n-    myOrientationLabel.setText\n-        (\"Format Orientation = \" +\n-                (o == PageFormat.PORTRAIT ? \"PORTRAIT\" :\n-                 o == PageFormat.LANDSCAPE ? \"LANDSCAPE\" :\n-                 o == PageFormat.REVERSE_LANDSCAPE ? \"REVERSE_LANDSCAPE\" :\n-                 \"<invalid>\"));\n-    Paper p = myPageFormat.getPaper();\n-    pw.setText(\"Paper Width = \" + (float)p.getWidth());\n-    ph.setText(\"Paper Height = \" + (float)p.getHeight());\n-    pglm.setText(\"Paper Left Margin = \" + (float)p.getImageableX());\n-    pgiw.setText(\"Paper Imageable Width = \" + (float)p.getImageableWidth());\n-    pgrm.setText(\"Paper Right Margin = \" +\n-         (float)(p.getWidth() - (p.getImageableX()+p.getImageableWidth())));\n-    pgtm.setText(\"Paper Top Margin = \" + (float)p.getImageableY());\n-    pgih.setText(\"Paper Imageable Height = \" + (float)p.getImageableHeight());\n-    pgbm.setText(\"Paper Bottom Margin = \" +\n-       (float)(p.getHeight() - (p.getImageableY()+p.getImageableHeight())));\n-  }\n@@ -102,38 +120,37 @@\n-  public PageSetupDialog() {\n-    super (\"Page Dialog Test\");\n-    myPrinterJob = PrinterJob.getPrinterJob();\n-    myPageFormat = new PageFormat();\n-    Paper p = new Paper();\n-    double margin = 1.5*72;\n-    p.setImageableArea(margin, margin,\n-                       p.getWidth()-2*margin, p.getHeight()-2*margin);\n-    myPageFormat.setPaper(p);\n-    Panel c = new Panel();\n-    c.setLayout (new GridLayout (9, 2, 0, 0));\n-    c.add (reverseCB = new Checkbox(\"reverse if landscape\"));\n-    c.add (myOrientationLabel = new Label());\n-    c.add (myWidthLabel = new Label());\n-    c.add (pw = new Label());\n-    c.add (myImageableXLabel = new Label());\n-    c.add (pglm = new Label());\n-    c.add (myImageableRightLabel = new Label());\n-    c.add (pgrm = new Label());\n-    c.add (myImageableWidthLabel = new Label());\n-    c.add (pgiw = new Label());\n-    c.add (myHeightLabel = new Label());\n-    c.add (ph = new Label());\n-    c.add (myImageableYLabel = new Label());\n-    c.add (pgtm = new Label());\n-    c.add (myImageableHeightLabel = new Label());\n-    c.add (pgih = new Label());\n-    c.add (myImageableBottomLabel = new Label());\n-    c.add (pgbm = new Label());\n-\n-    reverseCB.addItemListener(new ItemListener() {\n-                public void itemStateChanged(ItemEvent e) {\n-                       reverse = e.getStateChange() == ItemEvent.SELECTED;\n-                       int o = myPageFormat.getOrientation();\n-                       if (o == PageFormat.LANDSCAPE ||\n-                           o == PageFormat.REVERSE_LANDSCAPE) {\n-                           displayPageFormatAttributes();\n-                       }\n+    public PageSetupDialog() {\n+        super(\"Page Dialog Test\");\n+        myPrinterJob = PrinterJob.getPrinterJob();\n+        myPageFormat = new PageFormat();\n+        Paper p = new Paper();\n+        double margin = 1.5 * 72;\n+        p.setImageableArea(margin, margin,\n+                p.getWidth() - 2 * margin, p.getHeight() - 2 * margin);\n+        myPageFormat.setPaper(p);\n+        Panel c = new Panel();\n+        c.setLayout(new GridLayout(9, 2, 0, 0));\n+        c.add(reverseCB = new Checkbox(\"reverse if landscape\"));\n+        c.add(myOrientationLabel = new Label());\n+        c.add(myWidthLabel = new Label());\n+        c.add(pw = new Label());\n+        c.add(myImageableXLabel = new Label());\n+        c.add(pglm = new Label());\n+        c.add(myImageableRightLabel = new Label());\n+        c.add(pgrm = new Label());\n+        c.add(myImageableWidthLabel = new Label());\n+        c.add(pgiw = new Label());\n+        c.add(myHeightLabel = new Label());\n+        c.add(ph = new Label());\n+        c.add(myImageableYLabel = new Label());\n+        c.add(pgtm = new Label());\n+        c.add(myImageableHeightLabel = new Label());\n+        c.add(pgih = new Label());\n+        c.add(myImageableBottomLabel = new Label());\n+        c.add(pgbm = new Label());\n+\n+        reverseCB.addItemListener(new ItemListener() {\n+            public void itemStateChanged(ItemEvent e) {\n+                reverse = e.getStateChange() == ItemEvent.SELECTED;\n+                int o = myPageFormat.getOrientation();\n+                if (o == PageFormat.LANDSCAPE ||\n+                        o == PageFormat.REVERSE_LANDSCAPE) {\n+                    displayPageFormatAttributes();\n@@ -141,10 +158,21 @@\n-    });\n-\n-    add(\"Center\", c);\n-    displayPageFormatAttributes();\n-    Panel panel = new Panel();\n-    Button pageButton = new Button (\"Page Setup...\");\n-    pageButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                        myPageFormat = myPrinterJob.pageDialog (myPageFormat);\n-                        displayPageFormatAttributes();\n+            }\n+        });\n+\n+        add(\"Center\", c);\n+        displayPageFormatAttributes();\n+        Panel panel = new Panel();\n+        Button pageButton = new Button(\"Page Setup...\");\n+        pageButton.addActionListener(e -> {\n+            myPageFormat = myPrinterJob.pageDialog(myPageFormat);\n+            displayPageFormatAttributes();\n+        });\n+        Button printButton = new Button(\"Print ...\");\n+        printButton.addActionListener(e -> {\n+            if (myPrinterJob.printDialog()) {\n+                myPrinterJob.setPrintable(PageSetupDialog.this, myPageFormat);\n+                alpha = false;\n+                try {\n+                    myPrinterJob.print();\n+                } catch (PrinterException pe) {\n+                    pe.printStackTrace();\n+                    PassFailJFrame.forceFail(\"Test failed because of PrinterException\");\n@@ -152,13 +180,12 @@\n-    });\n-    Button printButton = new Button (\"Print ...\");\n-    printButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                    try {\n-                         if (myPrinterJob.printDialog()) {\n-                             myPrinterJob.setPrintable(PageSetupDialog.this,\n-                                                       myPageFormat);\n-                             alpha = false;\n-                             myPrinterJob.print();\n-                    }\n-                    } catch (PrinterException pe ) {\n-                    }\n+            }\n+        });\n+        Button printAlphaButton = new Button(\"Print w\/Alpha...\");\n+        printAlphaButton.addActionListener(e -> {\n+            if (myPrinterJob.printDialog()) {\n+                myPrinterJob.setPrintable(PageSetupDialog.this, myPageFormat);\n+                alpha = true;\n+                try {\n+                    myPrinterJob.print();\n+                } catch (PrinterException pe) {\n+                    pe.printStackTrace();\n+                    PassFailJFrame.forceFail(\"Test failed because of PrinterException\");\n@@ -166,84 +193,7 @@\n-    });\n-    Button printAlphaButton = new Button (\"Print w\/Alpha...\");\n-    printAlphaButton.addActionListener(new ActionListener() {\n-           public void actionPerformed (ActionEvent e) {\n-                    try {\n-                         if (myPrinterJob.printDialog()) {\n-                             myPrinterJob.setPrintable(PageSetupDialog.this,\n-                                                       myPageFormat);\n-                             alpha = true;\n-                             myPrinterJob.print();\n-                    }\n-                    } catch (PrinterException pe ) {\n-                    }\n-           }\n-    });\n-    panel.add (pageButton);\n-    panel.add (printButton);\n-    panel.add (printAlphaButton);\n-    add(\"South\", panel);\n-    addWindowListener (new WindowAdapter() {\n-         public void windowClosing (WindowEvent e) {\n-            dispose();\n-            System.exit (0);\n-         }\n-\n-      });\n-      \/\/setSize (280, 550);\n-      pack();\n-      setVisible (true);\n-  }\n-\n-  public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n-\n-     if (pageIndex > 0) {\n-        return Printable.NO_SUCH_PAGE;\n-     }\n-\n-     Graphics2D g2d = (Graphics2D)graphics;\n-     g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n-     g2d.drawString(\"ORIGIN(\"+pageFormat.getImageableX()+\",\"+\n-                             pageFormat.getImageableY()+\")\", 20, 20);\n-     g2d.drawString(\"X THIS WAY\", 200, 50);\n-     g2d.drawString(\"Y THIS WAY\", 60 , 200);\n-     g2d.drawString(\"Graphics is \" + g2d.getClass().getName(), 100, 100);\n-     g2d.drawRect(0,0,(int)pageFormat.getImageableWidth(),\n-                      (int)pageFormat.getImageableHeight());\n-     if (alpha) {\n-       g2d.setColor(new Color(0,0,255,192));\n-     } else {\n-        g2d.setColor(Color.blue);\n-     }\n-     g2d.drawRect(1,1,(int)pageFormat.getImageableWidth()-2,\n-                      (int)pageFormat.getImageableHeight()-2);\n-\n-     return  Printable.PAGE_EXISTS;\n-  }\n-\n-  public static void main( String[] args) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test is very flexible and requires much interaction.\",\n-         \"If the platform print dialog supports it, adjust orientation\",\n-         \"and margins and print pages and compare the results with the\",\n-         \"request.\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-     new PageSetupDialog();\n-  }\n-\n-}\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+            }\n+        });\n+        panel.add(pageButton);\n+        panel.add(printButton);\n+        panel.add(printAlphaButton);\n+        add(\"South\", panel);\n+        pack();\n@@ -252,7 +202,26 @@\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    @Override\n+    public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n+        if (pageIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n+\n+        Graphics2D g2d = (Graphics2D) graphics;\n+        g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n+        g2d.drawString(\"ORIGIN(\" + pageFormat.getImageableX() + \",\" +\n+                pageFormat.getImageableY() + \")\", 20, 20);\n+        g2d.drawString(\"X THIS WAY\", 200, 50);\n+        g2d.drawString(\"Y THIS WAY\", 60, 200);\n+        g2d.drawString(\"Graphics is \" + g2d.getClass().getName(), 100, 100);\n+        g2d.drawRect(0, 0,\n+                (int) pageFormat.getImageableWidth(),\n+                (int) pageFormat.getImageableHeight());\n+        if (alpha) {\n+            g2d.setColor(new Color(0, 0, 255, 192));\n+        } else {\n+            g2d.setColor(Color.blue);\n+        }\n+        g2d.drawRect(1, 1,\n+                (int) pageFormat.getImageableWidth() - 2,\n+                (int) pageFormat.getImageableHeight() - 2);\n+\n+        return Printable.PAGE_EXISTS;\n@@ -261,4 +230,13 @@\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(10)\n+                .testUI(PageSetupDialog::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n@@ -266,88 +244,1 @@\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PageFormat\/PageSetupDialog.java","additions":207,"deletions":316,"binary":false,"changes":523,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,10 @@\n-\/**\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterAbortException;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -27,1 +36,0 @@\n- * @summary PrinterJob not cancelled when PrinterJob.cancel() is used\n@@ -29,0 +37,3 @@\n+ * @summary PrinterJob not cancelled when PrinterJob.cancel() is used\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,4 +42,0 @@\n-\n-import java.awt.* ;\n-import java.awt.print.* ;\n-\n@@ -36,55 +43,28 @@\n-\n-  PrinterJob pj ;\n-  boolean okayed;\n-\n-  public static void main ( String args[] ) {\n-\n-     String[] instructions =\n-        {\n-         \"Test that print job cancellation works.\",\n-         \"You must have a printer available to perform this test.\",\n-         \"This test silently starts a print job and while the job is\",\n-         \"still being printed, cancels the print job\",\n-         \"You should see a message on System.out that the job\",\n-         \"was properly cancelled.\",\n-         \"You will need to kill the application manually since regression\",\n-         \"tests apparently aren't supposed to call System.exit()\"\n-       };\n-\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-      PrinterJobCancel pjc = new PrinterJobCancel() ;\n-\n-      if (pjc.okayed) {\n-          pjc.start();\n-          try {\n-               Thread.sleep(5000);\n-               pjc.pj.cancel();\n-          } catch ( InterruptedException e ) {\n-          }\n-      }\n-  }\n-\n-  public PrinterJobCancel() {\n-\n-    pj = PrinterJob.getPrinterJob() ;\n-    pj.setPrintable(this);\n-    okayed = pj.printDialog();\n-  }\n-\n-  public void run() {\n-    boolean cancelWorked = false;\n-    try {\n-        pj.print() ;\n-    }\n-    catch ( PrinterAbortException paex ) {\n-      cancelWorked = true;\n-      System.out.println(\"Job was properly cancelled and we\");\n-      System.out.println(\"got the expected PrintAbortException\");\n-    }\n-    catch ( PrinterException prex ) {\n-      System.out.println(\"This is wrong .. we shouldn't be here\");\n-      System.out.println(\"Looks like a test failure\");\n-      prex.printStackTrace() ;\n-      \/\/throw prex;\n+    private final PrinterJob pj;\n+    private final boolean okayed;\n+    private static final String INSTRUCTIONS =\n+            \"Test that print job cancellation works.\\n\\n\" +\n+            \"This test starts after clicking OK \/ Print button.\\n\" +\n+            \"While the print job is in progress, the test automatically cancels it.\\n\" +\n+            \"The test will complete automatically.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+\n+        PrinterJobCancel pjc = new PrinterJobCancel();\n+        if (pjc.okayed) {\n+            pjc.start();\n+            Thread.sleep(5000);\n+            pjc.pj.cancel();\n+        } else {\n+            PassFailJFrame.forceFail(\"User cancelled printing\");\n+        }\n+        passFailJFrame.awaitAndCheck();\n@@ -92,33 +72,0 @@\n-    finally {\n-       System.out.println(\"DONE PRINTING\");\n-       if (!cancelWorked) {\n-           System.out.println(\"Looks like the test failed - we didn't get\");\n-           System.out.println(\"the expected PrintAbortException \");\n-       }\n-    }\n-    \/\/System.exit(0);\n-  }\n-\n-  public int print(Graphics g, PageFormat pagef, int pidx) {\n-\n-     if (pidx > 5) {\n-        return( Printable.NO_SUCH_PAGE ) ;\n-     }\n-\n-     Graphics2D g2d = (Graphics2D)g;\n-     g2d.translate(pagef.getImageableX(), pagef.getImageableY());\n-     g2d.setColor(Color.black);\n-\n-     g2d.drawString((\"This is page\"+(pidx+1)), 60 , 80);\n-     \/\/ Need to slow things down a bit .. important not to try this\n-     \/\/ on the event dispathching thread of course.\n-     try {\n-          Thread.sleep(2000);\n-     } catch (InterruptedException e) {\n-     }\n-\n-     return ( Printable.PAGE_EXISTS );\n-  }\n-\n-}\n-\n@@ -126,9 +73,4 @@\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    public PrinterJobCancel() {\n+        pj = PrinterJob.getPrinterJob();\n+        pj.setPrintable(this);\n+        okayed = pj.printDialog();\n@@ -137,7 +79,18 @@\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    public void run() {\n+        boolean cancelWorked = false;\n+        try {\n+            pj.print();\n+        } catch (PrinterAbortException paex) {\n+            cancelWorked = true;\n+            System.out.println(\"Job was properly cancelled and we\");\n+            System.out.println(\"got the expected PrintAbortException\");\n+            PassFailJFrame.forcePass();\n+        } catch (PrinterException prex) {\n+            prex.printStackTrace();\n+            PassFailJFrame.forceFail(\"Unexpected PrinterException caught:\" + prex.getMessage());\n+        } finally {\n+            System.out.println(\"DONE PRINTING\");\n+            if (!cancelWorked) {\n+                PassFailJFrame.forceFail(\"Didn't get the expected PrintAbortException\");\n+            }\n+        }\n@@ -146,4 +99,18 @@\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+    @Override\n+    public int print(Graphics g, PageFormat pagef, int pidx) {\n+        if (pidx > 5) {\n+            return (Printable.NO_SUCH_PAGE);\n+        }\n+\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pagef.getImageableX(), pagef.getImageableY());\n+        g2d.setColor(Color.black);\n+        g2d.drawString((\"This is page\" + (pidx + 1)), 60, 80);\n+        \/\/ Need to slow things down a bit .. important not to try this\n+        \/\/ on the event dispatching thread of course.\n+        try {\n+            Thread.sleep(2000);\n+        } catch (InterruptedException ignored) {\n+        }\n+\n+        return Printable.PAGE_EXISTS;\n@@ -151,88 +118,1 @@\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/Cancel\/PrinterJobCancel.java","additions":83,"deletions":203,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,25 @@\n-\/**\n+import java.awt.Graphics;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.io.InputStream;\n+import java.io.Reader;\n+\n+import javax.print.Doc;\n+import javax.print.DocFlavor;\n+import javax.print.DocPrintJob;\n+import javax.print.PrintException;\n+import javax.print.PrintService;\n+import javax.print.PrintServiceLookup;\n+import javax.print.attribute.DocAttributeSet;\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.standard.Copies;\n+import javax.print.attribute.standard.SheetCollate;\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +53,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,15 +57,2 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import javax.print.attribute.standard.*;\n-import javax.print.attribute.*;\n-import javax.print.*;\n-import java.io.*;\n-\n-public class Collate2DPrintingTest\n-    extends Frame implements Doc, Printable, ActionListener {\n-\n-        Button print2D = new Button(\"2D Print\");\n-        Button printMerlin = new Button(\"PrintService\");\n-        PrinterJob pj = PrinterJob.getPrinterJob();\n-        PrintService defService = null;\n+public class Collate2DPrintingTest implements Doc, Printable {\n+    private static JComponent createTestUI() {\n@@ -47,0 +60,3 @@\n+        PrintService defService = PrintServiceLookup.lookupDefaultPrintService();\n+        prSet.add(SheetCollate.COLLATED);\n+        prSet.add(new Copies(2));\n@@ -48,10 +64,14 @@\n-    public Collate2DPrintingTest() {\n-\n-        Panel butPanel = new Panel();\n-        butPanel.add(print2D);\n-        butPanel.add(printMerlin);\n-        print2D.addActionListener(this);\n-        printMerlin.addActionListener(this);\n-        addWindowListener (new WindowAdapter() {\n-            public void windowClosing (WindowEvent e) {\n-                dispose();\n+        JButton print2D = new JButton(\"2D Print\");\n+        print2D.addActionListener((ae) -> {\n+            try {\n+                PrinterJob pj = PrinterJob.getPrinterJob();\n+                pj.setPrintable(new Collate2DPrintingTest());\n+                if (pj.printDialog(prSet)) {\n+                    pj.print(prSet);\n+                }\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(print2D, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n@@ -60,1 +80,0 @@\n-        add(\"South\", butPanel);\n@@ -62,6 +81,11 @@\n-        defService = PrintServiceLookup.lookupDefaultPrintService();\n-        PrintService[] pservice;\n-        if (defService == null) {\n-            pservice = PrintServiceLookup.lookupPrintServices(null, null);\n-            if (pservice.length == 0) {\n-                throw new RuntimeException(\"No printer found.  TEST ABORTED\");\n+        JButton printMerlin = new JButton(\"PrintService\");\n+        printMerlin.addActionListener((ae) -> {\n+            try {\n+                DocPrintJob pj = defService.createPrintJob();\n+                pj.print(new Collate2DPrintingTest(), prSet);\n+            } catch (PrintException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrintException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(printMerlin, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n@@ -69,8 +93,1 @@\n-            defService = pservice[0];\n-        }\n-        prSet.add(SheetCollate.COLLATED);\n-        prSet.add(new Copies(2));\n-        pj.setPrintable(Collate2DPrintingTest.this);\n-        setSize(300, 200);\n-        setVisible(true);\n-    }\n+        });\n@@ -78,0 +95,9 @@\n+        Box main = Box.createVerticalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createVerticalGlue());\n+        main.add(print2D);\n+        main.add(Box.createVerticalStrut(4));\n+        main.add(printMerlin);\n+        main.add(Box.createVerticalGlue());\n+        return main;\n+    }\n@@ -79,0 +105,1 @@\n+    @Override\n@@ -80,1 +107,1 @@\n-          throws PrinterException {\n+            throws PrinterException {\n@@ -89,16 +116,1 @@\n-    public void actionPerformed (ActionEvent ae) {\n-        try {\n-            if (ae.getSource() == print2D) {\n-                if (pj.printDialog(prSet)) {\n-                    pj.print(prSet);\n-                }\n-            } else {\n-                DocPrintJob pj = defService.createPrintJob();\n-                pj.print(this, prSet);\n-            }\n-            System.out.println (\"DONE\");\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n+    @Override\n@@ -109,0 +121,1 @@\n+    @Override\n@@ -110,2 +123,1 @@\n-        DocFlavor flavor = DocFlavor.SERVICE_FORMATTED.PRINTABLE;\n-        return flavor;\n+        return DocFlavor.SERVICE_FORMATTED.PRINTABLE;\n@@ -114,0 +126,1 @@\n+    @Override\n@@ -118,0 +131,1 @@\n+    @Override\n@@ -122,0 +136,1 @@\n+    @Override\n@@ -126,120 +141,13 @@\n-  public static void main( String[] args) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"The print result should be collated.\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-     new Collate2DPrintingTest();\n-  }\n-}\n-\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.setVisible(true);\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.setVisible(true);\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      setVisible(true);\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n+    private static final String INSTRUCTIONS =\n+            \"Click on the '2D Print' button.\\n\" +\n+            \"Choose copies as '2' with 'Collated' checkbox and Print\\n\" +\n+            \"\\n\" +\n+            \"Click on the 'PrintService', should get a print from default printer\\n\" +\n+            \"\\n\" +\n+            \"If you get only one copy or non 'Collated' prints from any of the above cases, \" +\n+            \"test failed\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n@@ -247,4 +155,7 @@\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .splitUI(Collate2DPrintingTest::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n@@ -252,2 +163,1 @@\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/Collate2DPrintingTest.java","additions":97,"deletions":187,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,15 @@\n-\/**\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.RescaleOp;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -29,0 +43,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +47,2 @@\n+public class DrawImage {\n+    private static final int OBJECT_BORDER = 15;\n@@ -32,25 +50,4 @@\n-import java.util.*;\n-import java.text.*;\n-import java.io.*;\n-import java.net.*;\n-import java.awt.*;\n-import java.awt.font.*;\n-import java.awt.geom.*;\n-import java.awt.print.*;\n-import java.awt.event.*;\n-import java.awt.image.*;\n-import java.awt.image.renderable.*;\n-import javax.swing.*;\n-import javax.swing.text.*;\n-import javax.swing.border.*;\n-import javax.swing.event.*;\n-\n-public class DrawImage\n-{\n-    protected static final double _hwBorder = 72 \/ 4;       \/\/ 1\/4 inch\n-    protected static final double _border = 72 \/ 4;         \/\/ 1\/4 inch\n-    protected static final int _objectBorder = 15;\n-    protected static final int _verticalGap = 20;\n-    protected static final int _textIndent = 150;\n-\n-    protected BufferedImage _image;\n+    private static final String INSTRUCTIONS =\n+            \"This test will automatically initiate a print\\n\\n\" +\n+            \"Test passes if you get a printout of a gray rectangle\\n\" +\n+            \"with white text without any exception.\";\n@@ -58,1 +55,2 @@\n-    protected PageFormat  _pageFormat;\n+    private final BufferedImage image;\n+    private final PageFormat pageFormat;\n@@ -60,2 +58,2 @@\n-    public DrawImage(BufferedImage image) {\n-        _image = image;\n+    private DrawImage(BufferedImage image) {\n+        this.image = image;\n@@ -63,1 +61,2 @@\n-        _pageFormat = pj.defaultPage();\n+        pageFormat = pj.defaultPage();\n+    }\n@@ -65,1 +64,4 @@\n- }\n+    private int printImage(Graphics g, PageFormat pf, int pageIndex) {\n+        if (pageIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n@@ -67,0 +69,4 @@\n+        int paperW = (int) pageFormat.getImageableWidth();\n+        int paperH = (int) pageFormat.getImageableHeight();\n+        int x = (int) pageFormat.getImageableX();\n+        int y = (int) pageFormat.getImageableY();\n@@ -68,3 +74,3 @@\n-    protected int printImage(Graphics g, PageFormat pf, BufferedImage image) {\n-        Graphics2D g2D = (Graphics2D)g;\n-        g2D.transform(new AffineTransform(_pageFormat.getMatrix()));\n+        \/\/ Make the image slightly smaller (25) than max possible width\n+        float scaleFactor = ((float) ((paperW - 25) - OBJECT_BORDER - OBJECT_BORDER)\n+                                   \/ (float) (image.getWidth()));\n@@ -72,2 +78,1 @@\n-        int paperW = (int)pf.getImageableWidth(), paperH =\n-            (int)pf.getImageableHeight();\n+        BufferedImageOp scaleOp = new RescaleOp(scaleFactor, 0, null);\n@@ -75,1 +80,2 @@\n-        int x = (int)pf.getImageableX(), y = (int)pf.getImageableY();\n+        Graphics2D g2D = (Graphics2D) g;\n+        g2D.transform(new AffineTransform(pageFormat.getMatrix()));\n@@ -77,0 +83,1 @@\n+        g2D.drawImage(image, scaleOp, x + OBJECT_BORDER, y + OBJECT_BORDER);\n@@ -78,16 +85,1 @@\n-        \/\/ print images\n-        if (image != null ) {\n-            int imageH = image.getHeight(), imageW = image.getWidth();\n-            \/\/ make slightly smaller (25) than max possible width\n-            float scaleFactor = ((float)((paperW - 25) - _objectBorder -\n-                                         _objectBorder) \/ (float)(imageW));\n-            int scaledW = (int)(imageW * scaleFactor),\n-                scaledH = (int)(imageH *scaleFactor);\n-            BufferedImageOp scaleOp = new RescaleOp(scaleFactor, 0, null);\n-            g2D.drawImage(image, scaleOp, x + _objectBorder, y + _objectBorder);\n-            y += _objectBorder + scaledH + _objectBorder;\n-            return Printable.PAGE_EXISTS;\n-        }\n-        else {\n-            return Printable.NO_SUCH_PAGE;\n-        }\n+        return Printable.PAGE_EXISTS;\n@@ -96,23 +88,8 @@\n-    public void print() {\n-        try {\n-            final PrinterJob pj = PrinterJob.getPrinterJob();\n-            pj.setJobName(\"Print Image\");\n-            pj.setPrintable(new Printable() {\n-                public int print(Graphics g, PageFormat pf, int pageIndex) {\n-                    int result = NO_SUCH_PAGE;\n-                    if (pageIndex == 0) {\n-                        result = printImage(g, _pageFormat, _image);\n-                    }\n-                    return result;\n-                }\n-            });\n-            if (pj.printDialog()) {\n-                try { pj.print(); }\n-                catch (PrinterException e) {\n-                    System.out.println(e);\n-                }\n-            }\n-\n-        }\n-        catch (Exception e) {\n-            e.printStackTrace(System.out);\n+    private void print() throws PrinterException {\n+        final PrinterJob pj = PrinterJob.getPrinterJob();\n+        pj.setJobName(\"Print Image\");\n+        pj.setPrintable(this::printImage);\n+        if (pj.printDialog()) {\n+            pj.print();\n+        } else {\n+            PassFailJFrame.forceFail(\"User cancelled printing\");\n@@ -122,10 +99,4 @@\n-    public static void main(String[] args) {\n-                                String[] instructions =\n-           {\n-            \"You must have a printer available to perform this test.\",\n-            \"The test passes if you get a printout of a gray rectangle\",\n-                                                \"with white text without any exception.\"\n-          };\n-\n-         Sysout.createDialog( );\n-         Sysout.printInstructions( instructions );\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n@@ -134,0 +105,7 @@\n+\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+\n@@ -136,1 +114,1 @@\n-        \/\/      System.exit(0);\n+        passFailJFrame.awaitAndCheck();\n@@ -139,3 +117,1 @@\n-\n-\n-    public static BufferedImage prepareFrontImage() {\n+    private static BufferedImage prepareFrontImage() {\n@@ -144,1 +120,3 @@\n-                                                 BufferedImage.TYPE_BYTE_GRAY);\n+                                   BufferedImage.TYPE_BYTE_GRAY);\n+        int w = result.getWidth();\n+        int h = result.getHeight();\n@@ -146,1 +124,1 @@\n-        Graphics2D g2D = (Graphics2D)result.getGraphics();\n+        Graphics2D g2D = (Graphics2D) result.getGraphics();\n@@ -149,2 +127,0 @@\n-        int w = result.getWidth(), h = result.getHeight();\n-\n@@ -153,1 +129,0 @@\n-\n@@ -156,3 +131,2 @@\n-        AffineTransform original = g2D.getTransform();\n-        AffineTransform originXform = AffineTransform.getTranslateInstance(w \/\n-5, h \/ 5);\n+        AffineTransform originXform = AffineTransform.getTranslateInstance(\n+                w \/ 5.0, h \/ 5.0);\n@@ -160,2 +134,0 @@\n-\n-\n@@ -163,0 +135,1 @@\n+        g2D.dispose();\n@@ -166,2 +139,0 @@\n-\n-\n@@ -169,114 +140,0 @@\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/DrawImage.java","additions":74,"deletions":217,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,13 @@\n-\/**\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.font.FontRenderContext;\n+import java.awt.print.Book;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterJob;\n+import java.text.AttributedCharacterIterator;\n+import java.text.AttributedString;\n+\n+\/*\n@@ -30,0 +42,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -32,6 +46,0 @@\n-\n-import java.awt.*;\n-import java.text.*;\n-import java.awt.font.*;\n-import java.awt.print.*;\n-\n@@ -39,0 +47,11 @@\n+    private static final String INSTRUCTIONS =\n+            \" This test will automatically initiate a print.\\n\" +\n+            \"\\n\" +\n+            \" Confirm that the following methods are printed:\\n\" +\n+            \" For Graphics: drawString, drawString, drawChars, drawBytes\\n\" +\n+            \" For Graphics2D: drawString, drawString, drawGlyphVector\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n@@ -40,9 +59,5 @@\n-    public static void main(String args[]) {\n-        String[] instructions =\n-        {\n-            \"Confirm that the methods are printed.\",\n-            \" For Graphics: drawString, drawString, drawChars, drawBytes\",\n-            \" For Graphics2D: drawString, drawString, drawGlyphVector\"\n-        };\n-        Sysout.createDialogWithInstructions( instructions );\n-\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n@@ -56,0 +71,1 @@\n+        pjob.print();\n@@ -57,5 +73,1 @@\n-        try {\n-            pjob.print();\n-        } catch (PrinterException e) {\n-            throw new RuntimeException(e.getMessage());\n-        }\n+        passFailJFrame.awaitAndCheck();\n@@ -64,1 +76,1 @@\n-    public static AttributedCharacterIterator getIterator(String s) {\n+    private static AttributedCharacterIterator getIterator(String s) {\n@@ -68,0 +80,1 @@\n+    @Override\n@@ -96,1 +109,1 @@\n-        byte data[] = new byte[s.length()];\n+        byte[] data = new byte[s.length()];\n@@ -119,1 +132,1 @@\n-                           \"float x, float y)\";\n+                \"float x, float y)\";\n@@ -136,116 +149,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog\n- {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"South\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-     \/\/chop up each into pieces maxSringLength long\n-     remainingStr = instructions[ i ];\n-     while( remainingStr.length() > 0 )\n-      {\n-        \/\/if longer than max then chop off first max chars to print\n-        if( remainingStr.length() >= maxStringLength )\n-         {\n-           \/\/Try to chop on a word boundary\n-           int posOfSpace = remainingStr.\n-          lastIndexOf( ' ', maxStringLength - 1 );\n-\n-           if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-           printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-           remainingStr = remainingStr.substring( posOfSpace + 1 );\n-         }\n-        \/\/else just print\n-        else\n-         {\n-           printStr = remainingStr;\n-           remainingStr = \"\";\n-         }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-      }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/DrawStringMethods.java","additions":38,"deletions":141,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,16 @@\n-\/**\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Paper;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +44,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,29 +48,13 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-\n-public class InvalidPage extends Frame implements Printable {\n-\n-  PrinterJob pJob;\n-  PageFormat pf;\n-\n-  public InvalidPage() {\n-    super (\"Validate Page Test\");\n-    pJob = PrinterJob.getPrinterJob();\n-    pf = pJob.defaultPage();\n-    Paper p = pf.getPaper();\n-    p.setImageableArea(0,0,p.getWidth(), p.getHeight());\n-    pf.setPaper(p);\n-    setLayout(new FlowLayout());\n-    Panel panel = new Panel();\n-    Button printButton = new Button (\"Print\");\n-    printButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                    try {\n-                         if (pJob.printDialog()) {\n-                             pJob.setPrintable(InvalidPage.this, pf);\n-                             pJob.print();\n-                    }\n-                    } catch (PrinterException pe ) {\n-                    }\n+public class InvalidPage implements Printable {\n+    private static JComponent createTestUI() {\n+        JButton b = new JButton(\"Print\");\n+        b.addActionListener((ae) -> {\n+            try {\n+                PrinterJob job = PrinterJob.getPrinterJob();\n+                PageFormat pf = job.defaultPage();\n+                Paper p = pf.getPaper();\n+                p.setImageableArea(0, 0, p.getWidth(), p.getHeight());\n+                pf.setPaper(p);\n+                job.setPrintable(new InvalidPage(), pf);\n+                if (job.printDialog()) {\n+                    job.print();\n@@ -61,79 +62,15 @@\n-    });\n-    panel.add (printButton);\n-    add(panel);\n-\n-    addWindowListener (new WindowAdapter() {\n-         public void windowClosing (WindowEvent e) {\n-            dispose();\n-            System.exit (0);\n-         }\n-\n-      });\n-      setSize (200, 200);\n-      setVisible (true);\n-  }\n-\n-  public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n-\n-     if (pageIndex > 1) {\n-        return Printable.NO_SUCH_PAGE;\n-     }\n-\n-     Graphics2D g2d = (Graphics2D)graphics;\n-\n-     g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n-     g2d.drawString(\"ORIGIN\", 30, 30);\n-     g2d.drawString(\"X THIS WAY\", 200, 50);\n-     g2d.drawString(\"Y THIS WAY\", 60 , 200);\n-     g2d.drawRect(0,0,(int)pageFormat.getImageableWidth(),\n-                      (int)pageFormat.getImageableHeight());\n-     if (pageIndex == 0) {\n-        g2d.setColor(Color.black);\n-     } else {\n-        g2d.setColor(new Color(0,0,0,128));\n-     }\n-     g2d.drawRect(1,1,(int)pageFormat.getImageableWidth()-2,\n-                      (int)pageFormat.getImageableHeight()-2);\n-\n-     g2d.drawLine(0,0,\n-                  (int)pageFormat.getImageableWidth(),\n-                  (int)pageFormat.getImageableHeight());\n-     g2d.drawLine((int)pageFormat.getImageableWidth(),0,\n-                   0,(int)pageFormat.getImageableHeight());\n-     return  Printable.PAGE_EXISTS;\n-  }\n-\n-  public static void main( String[] args) {\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"Press the print button, which brings up a print dialog and\",\n-         \"in the dialog select a printer and press the print button\",\n-         \"in the dialog. Repeat for as many printers as you have installed\",\n-         \"On solaris and linux just one printer is sufficient\",\n-         \"Collect the output and examine it, each print job has two pages\",\n-         \"of very similar output, except that the 2nd page of the job may\",\n-         \"appear in a different colour, and the output near the edge of\",\n-         \"the page may be clipped. This is OK. Hold up both pieces of paper\",\n-         \"to the light and confirm that the lines and text (where present)\",\n-         \"are positioned identically on both pages\",\n-         \"The test fails if the JRE crashes, or if the output from the two\",\n-         \"pages of a job is aligned differently\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-     new InvalidPage();\n-  }\n-\n-}\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n+            }\n+        });\n+\n+        Box main = Box.createHorizontalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createHorizontalGlue());\n+        main.add(b);\n+        main.add(Box.createHorizontalGlue());\n+        return main;\n@@ -142,7 +79,29 @@\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    @Override\n+    public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n+        if (pageIndex > 1) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n+\n+        Graphics2D g2d = (Graphics2D) graphics;\n+        g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n+        g2d.drawString(\"ORIGIN\", 30, 30);\n+        g2d.drawString(\"X THIS WAY\", 200, 50);\n+        g2d.drawString(\"Y THIS WAY\", 60, 200);\n+        g2d.drawRect(0, 0,\n+                (int) pageFormat.getImageableWidth(),\n+                (int) pageFormat.getImageableHeight());\n+        if (pageIndex == 0) {\n+            g2d.setColor(Color.black);\n+        } else {\n+            g2d.setColor(new Color(0, 0, 0, 128));\n+        }\n+        g2d.drawRect(1, 1,\n+                (int) pageFormat.getImageableWidth() - 2,\n+                (int) pageFormat.getImageableHeight() - 2);\n+        g2d.drawLine(0, 0,\n+                (int) pageFormat.getImageableWidth(),\n+                (int) pageFormat.getImageableHeight());\n+        g2d.drawLine((int) pageFormat.getImageableWidth(), 0,\n+                0, (int) pageFormat.getImageableHeight());\n+\n+        return Printable.PAGE_EXISTS;\n@@ -151,4 +110,27 @@\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+    private static final String INSTRUCTIONS =\n+            \" Press the print button, which brings up a print dialog.\\n\" +\n+            \" In the dialog select a printer and press the print button.\\n\\n\" +\n+            \" Repeat for all the printers as you have installed\\n\" +\n+            \" On Solaris and Linux just one printer is sufficient.\\n\\n\" +\n+            \" Collect the output and examine it, each print job has two pages\\n\" +\n+            \" of very similar output, except that the 2nd page of the job may\\n\" +\n+            \" appear in a different colour, and the output near the edge of\\n\" +\n+            \" the page may be clipped. This is OK. Hold up both pieces of paper\\n\" +\n+            \" to the light and confirm that the lines and text (where present)\\n\" +\n+            \" are positioned identically on both pages\\n\\n\" +\n+            \" The test fails if the output from the two\\n\" +\n+            \" pages of a job is aligned differently\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(10)\n+                .splitUI(InvalidPage::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n@@ -156,88 +138,1 @@\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/InvalidPage.java","additions":104,"deletions":209,"binary":false,"changes":313,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,7 @@\n-\/**\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -29,0 +35,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,4 +39,0 @@\n-\n-import java.awt.*;\n-import java.awt.print.*;\n-\n@@ -36,0 +40,23 @@\n+    private static final String THE_NAME = \"Testing the Job name setting\";\n+\n+    private static final String INSTRUCTIONS =\n+            \"This test prints a page with a banner\/job name of\\n\\n\" +\n+            THE_NAME;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        job.setJobName(THE_NAME);\n+        job.setPrintable(new PrinterJobName());\n+        job.print();\n+        passFailJFrame.awaitAndCheck();\n+    }\n@@ -37,28 +64,1 @@\n-\n-  static String theName = \"Testing the Jobname setting\";\n-\n-  public static void main(String[] args) {\n-\n-       String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test prints a page with a banner\/job name of\",\n-          theName\n-       };\n-\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-      PrinterJob job = PrinterJob.getPrinterJob();\n-      job.setJobName(theName);\n-      job.setPrintable(new PrinterJobName());\n-      try {\n-          job.print();\n-          System.out.println(\"PRINTING DONE.\");\n-      }\n-      catch (Exception exc) {\n-          System.out.println(\"Printer Exception\");\n-      }\n-  }\n-\n-\n+    @Override\n@@ -66,10 +66,8 @@\n-      if (pgIndex > 0 ) {\n-          return Printable.NO_SUCH_PAGE;\n-      }\n-\n-      double iw = pgFmt.getImageableWidth();\n-      double ih = pgFmt.getImageableHeight();\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-      g2d.drawString(\"Name is: \"+theName,20,20 );\n-      return Printable.PAGE_EXISTS;\n+        if (pgIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n+\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+        g2d.drawString(\"Name is: \" + THE_NAME, 20, 20);\n+        return Printable.PAGE_EXISTS;\n@@ -77,1 +75,0 @@\n-\n@@ -79,115 +76,0 @@\n-\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/JobName\/PrinterJobName.java","additions":42,"deletions":160,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,8 @@\n-\/**\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -29,0 +36,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,4 +40,0 @@\n-\n-import java.awt.*;\n-import java.awt.print.*;\n-\n@@ -36,19 +41,20 @@\n-\n-\n-  public static void main(String[] args) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a total of four pages which are two\",\n-         \" copies of each of two pages which consist of the text :-\",\n-         \"'This is page number N', where N is 0 and 1.\",\n-         \"The pages should be uncollated.\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrinterJob job = PrinterJob.getPrinterJob();\n-    job.setCopies(2);\n-    job.setPrintable(new NumCopies());\n-    try {\n+    private static final String INSTRUCTIONS =\n+            \"This test should print four pages, which are \\n\" +\n+            \"two copies of each page with the text :-\\n\" +\n+            \"'This is page number N', where N is 0 and 1.\\n\" +\n+            \"The pages should be uncollated.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        job.setCopies(2);\n+        job.setPrintable(new NumCopies());\n@@ -56,0 +62,1 @@\n+        passFailJFrame.awaitAndCheck();\n@@ -57,4 +64,0 @@\n-    catch (Exception exc) {\n-        System.out.println(\"Printer Exception\");\n-    }\n-  }\n@@ -62,5 +65,10 @@\n-  public int print(Graphics g, PageFormat pf, int pageIndex)\n-                   throws PrinterException {\n-\n-    if (pageIndex > 1) {\n-         return NO_SUCH_PAGE;\n+    @Override\n+    public int print(Graphics g, PageFormat pf, int pageIndex)\n+            throws PrinterException {\n+        if (pageIndex > 1) {\n+            return NO_SUCH_PAGE;\n+        }\n+        g.translate((int) pf.getImageableX(), (int) pf.getImageableY());\n+        g.setColor(Color.black);\n+        g.drawString(\"This is page number \" + pageIndex, 50, 50);\n+        return PAGE_EXISTS;\n@@ -68,6 +76,0 @@\n-    g.translate((int)pf.getImageableX(), (int)pf.getImageableY());\n-    g.setColor(Color.black);\n-    g.drawString(\"This is page number \" + Integer.toString(pageIndex), 50, 50);\n-    return PAGE_EXISTS ;\n-   }\n-\n@@ -75,115 +77,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/NumCopies.java","additions":42,"deletions":155,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,12 +24,0 @@\n-\/**\n- * @test\n- * @bug 4956397\n- * @key printer\n- * @run main\/manual PageDlgPrnButton\n- *\/\n-\n-import java.awt.print.PrinterJob;\n-import java.awt.print.PageFormat;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterException;\n-\n@@ -39,5 +27,4 @@\n-import java.awt.* ;\n-\n-public class PageDlgPrnButton implements Printable\n-{\n-    public static void main ( String args[] ) {\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n@@ -45,7 +32,1 @@\n-        String[] instructions =\n-           {\"For non-windows OS, this test PASSes.\",\n-            \"You must have at least 2 printers available to perform this test.\",\n-            \"This test brings up a native Windows page dialog.\",\n-            \"Click on the Printer... button and change the selected printer. \",\n-            \"Test passes if the printout comes from the new selected printer.\",\n-         };\n+import jtreg.SkippedException;\n@@ -53,2 +34,23 @@\n-         Sysout.createDialog( );\n-         Sysout.printInstructions( instructions );\n+\/*\n+ * @test\n+ * @bug 4956397\n+ * @key printer\n+ * @requires os.family==\"windows\"\n+ * @library \/test\/lib \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame jtreg.SkippedException\n+ * @run main\/manual PageDlgPrnButton\n+ *\/\n+public class PageDlgPrnButton implements Printable {\n+    private static final String INSTRUCTIONS =\n+            \"This test brings up a native Windows page dialog.\\n\" +\n+            \"Click on the Printer... button and change the selected printer. \\n\" +\n+            \"Test passes if the printout comes from the new selected printer.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        final int serviceCount = PrinterJob.lookupPrintServices().length;\n+        if (serviceCount == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+        if (serviceCount < 2) {\n+            throw new SkippedException(\"The test requires at least 2 printers.\");\n+        }\n@@ -56,2 +58,5 @@\n-        PageDlgPrnButton pdpb = new PageDlgPrnButton() ;\n-    }\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n@@ -59,8 +64,2 @@\n-    public PageDlgPrnButton()\n-    {\n-        try\n-        {\n-            pageDialogExample();\n-        }\n-        catch(Exception e)\n-        {e.printStackTrace(System.err);}\n+        pageDialogExample();\n+        passFailJFrame.awaitAndCheck();\n@@ -69,1 +68,0 @@\n-\n@@ -72,2 +70,1 @@\n-    public void pageDialogExample() throws PrinterException\n-    {\n+    public static void pageDialogExample() throws PrinterException {\n@@ -78,4 +75,4 @@\n-        if(originalPageFormat == pageFormat) return;\n-\n-        job.setPrintable(this,pageFormat);\n-        job.print();\n+        job.setPrintable(new PageDlgPrnButton(), pageFormat);\n+        if (job.printDialog()) {\n+            job.print();\n+        }\n@@ -84,4 +81,2 @@\n-\n-\n-    public int print(Graphics g, PageFormat pageFormat, int pageIndex)\n-    {\n+    @Override\n+    public int print(Graphics g, PageFormat pageFormat, int pageIndex) {\n@@ -90,1 +85,1 @@\n-        final Rectangle rect = new Rectangle(0,0,boxWidth,boxHeight);\n+        final Rectangle rect = new Rectangle(0, 0, boxWidth, boxHeight);\n@@ -93,0 +88,1 @@\n+        final Graphics2D g2d = (Graphics2D) g;\n@@ -94,3 +90,3 @@\n-        if (pageIndex > 0) return (NO_SUCH_PAGE);\n-\n-        final Graphics2D g2d = (Graphics2D)g;\n+        if (pageIndex > 0) {\n+            return NO_SUCH_PAGE;\n+        }\n@@ -102,1 +98,1 @@\n-        g2d.drawRect(0,0,(int)pageW,(int)pageH);\n+        g2d.drawRect(0, 0, (int) pageW, (int) pageH);\n@@ -106,1 +102,1 @@\n-        final double scale = Math.min( (pageW\/boxWidth), (pageH\/boxHeight) );\n+        final double scale = Math.min((pageW \/ boxWidth), (pageH \/ boxHeight));\n@@ -108,1 +104,3 @@\n-        if(scale < 1.0) g2d.scale(scale, scale);\n+        if (scale < 1.0) {\n+            g2d.scale(scale, scale);\n+        }\n@@ -113,1 +111,1 @@\n-        return(PAGE_EXISTS);\n+        return PAGE_EXISTS;\n@@ -116,114 +114,0 @@\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PageDlgPrnButton.java","additions":54,"deletions":170,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,10 @@\n-\/**\n- *\n- * test\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n+ * @test\n@@ -29,0 +36,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -32,5 +41,0 @@\n-\n-import java.awt.*;\n-import java.awt.print.*;\n-import java.awt.GraphicsEnvironment;\n-\n@@ -38,0 +42,2 @@\n+    private static final int LINE_HEIGHT = 18;\n+    private static final int FONT_SIZE = 14;\n@@ -39,6 +45,5 @@\n-    static Font[] allFonts;\n-    int fontNum = 0;\n-    int startNum = 0;\n-    int lineHeight = 18;\n-    boolean done = false;\n-    int thisPage = 0;\n+    private final Font[] allFonts =\n+            GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();\n+    private int fontNum = 0;\n+    private int startNum = 0;\n+    private int thisPage = 0;\n@@ -46,0 +51,5 @@\n+    private static final String INSTRUCTIONS =\n+            \"This bug is system dependent and is not always reproducible.\\n\" +\n+            \"Font names will be printed in two columns.\\n\" +\n+            \"First column non synthesised and second column with synthesised italic.\\n\" +\n+            \"A passing test will have all text printed with correct font style.\";\n@@ -48,0 +58,3 @@\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n@@ -49,14 +62,6 @@\n-        String[] instructions =\n-        {\n-            \"You must have a printer available to perform this test and should use Win 98.\",\n-            \"This bug is system dependent and is not always reproducible.\",\n-            \" \",\n-            \"A passing test will have all text printed with correct font style.\",\n-        };\n-\n-        Sysout.createDialog( );\n-        Sysout.printInstructions( instructions );\n-\n-        GraphicsEnvironment ge =\n-            GraphicsEnvironment.getLocalGraphicsEnvironment();\n-        allFonts = ge.getAllFonts();\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(10)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n@@ -67,1 +72,3 @@\n-           pj.print();\n+            pj.print();\n+        } else {\n+            PassFailJFrame.forceFail(\"User cancelled printing\");\n@@ -69,0 +76,1 @@\n+        passFailJFrame.awaitAndCheck();\n@@ -71,0 +79,1 @@\n+    @Override\n@@ -72,1 +81,0 @@\n-\n@@ -82,1 +90,0 @@\n-        g.setColor(Color.black);\n@@ -84,4 +91,3 @@\n-        int hgt = (int)pf.getImageableHeight();\n-        int fontsPerPage = hgt\/lineHeight;\n-        int x = (int)pf.getImageableX()+10;\n-        int y = (int)pf.getImageableY()+lineHeight;\n+        int fontsPerPage = (int) pf.getImageableHeight() \/ LINE_HEIGHT - 1;\n+        int x = (int) pf.getImageableX() + 10;\n+        int y = (int) pf.getImageableY() + LINE_HEIGHT;\n@@ -89,0 +95,1 @@\n+        g.setColor(Color.black);\n@@ -90,1 +97,2 @@\n-            Font f = allFonts[fontNum].deriveFont(Font.PLAIN, 16);\n+            Font f = allFonts[fontNum].deriveFont(Font.PLAIN, FONT_SIZE);\n+            Font fi = allFonts[fontNum].deriveFont(Font.ITALIC, FONT_SIZE);\n@@ -93,1 +101,3 @@\n-            y+= lineHeight;\n+            g.setFont(fi);\n+            g.drawString(f.getFontName(), (int) (x + pf.getImageableWidth() \/ 2), y);\n+            y += LINE_HEIGHT;\n@@ -102,114 +112,0 @@\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintAllFonts.java","additions":48,"deletions":152,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,14 @@\n-\/**\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +42,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +46,22 @@\n+public class PrintCompoundString implements Printable {\n+    private static final String STR = \"Test string compound printing \\u2203\\u2200\\u2211\";\n+\n+    private static final String INSTRUCTIONS =\n+            \"This test should print following text\\n\\n\" +\n+            STR +\"\\n\\n\" +\n+            \"If an exception is thrown, or the page doesn't print properly\\n\" +\n+            \"then the test fails\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .splitUI(PrintCompoundString::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -32,42 +69,15 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintCompoundString extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"text message as in the test window on the screen\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If an exception is thrown, or the page doesn't print properly\",\n-         \"then the test fails\",\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintCompoundString f = new PrintCompoundString();\n-    f.show();\n- }\n-\n- public PrintCompoundString() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n+    private static JComponent createTestUI() {\n+        JButton b = new JButton(\"Print\");\n+        b.addActionListener((ae) -> {\n+            try {\n+                PrinterJob job = PrinterJob.getPrinterJob();\n+                job.setPrintable(new PrintCompoundString());\n+                if (job.printDialog()) {\n+                    job.print();\n+                }\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n@@ -75,41 +85,8 @@\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    String nullStr = null;\n-    String emptyStr = new String();\n-    AttributedString nullAttStr = null;\n-    AttributedString emptyAttStr = new AttributedString(emptyStr);\n-    AttributedCharacterIterator nullIterator = null;\n-    AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n+        });\n+\n+        Box main = Box.createHorizontalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createHorizontalGlue());\n+        main.add(b);\n+        main.add(Box.createHorizontalGlue());\n+        return main;\n@@ -118,5 +95,5 @@\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-          String str = \"Test string compound printing \\u2203\\u2200\\u2211\";\n-          g.drawString(str, 20, 40);\n+    @Override\n+    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+        if (pgIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n@@ -124,1 +101,3 @@\n-    }\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+        g2d.drawString(STR, 20, 40);\n@@ -126,2 +105,1 @@\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n+        return Printable.PAGE_EXISTS;\n@@ -129,2 +107,0 @@\n- }\n-\n@@ -132,115 +108,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintCompoundString.java","additions":71,"deletions":210,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,18 @@\n-\/**\n- * @test %I %W\n+import java.awt.BorderLayout;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n+ * @test\n@@ -29,0 +45,3 @@\n+ * @requires os.family==\"windows\"\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,4 +50,0 @@\n-import java.awt.*;\n-import java.awt.print.*;\n-import java.awt.event.*;\n-\n@@ -36,48 +51,21 @@\n-\n-        private PrintImageCanvas                printImageCanvas;\n-\n-        private MenuItem        print1Menu = new MenuItem(\"PrintTest1\");\n-        private MenuItem        print2Menu = new MenuItem(\"PrintTest2\");\n-        private MenuItem        exitMenu = new MenuItem(\"Exit\");\n-\n-        public static void main(String[] argv) {\n-        String[] instructions =\n-           { \"You must have a printer available to perform this test,\",\n-             \"prefererably Canon LaserShot A309GII.\",\n-             \"Printing must be done in Win 98 Japanese 2nd Edition.\",\n-             \"\",\n-             \"Passing test : Output of text image for PrintTest1 and PrintTest2 should be same as that on the screen.\",\n-           };\n-\n-        Sysout.createDialog( );\n-         Sysout.printInstructions( instructions );\n-\n-                new PrintImage();\n-        }\n-\n-        public PrintImage() {\n-                super(\"PrintImage\");\n-                initPrintImage();\n-        }\n-\n-        public void initPrintImage() {\n-\n-                printImageCanvas = new PrintImageCanvas(this);\n-\n-                initMenu();\n-\n-                addWindowListener(new WindowAdapter() {\n-                        public void windowClosing(WindowEvent ev) {\n-                                dispose();\n-                        }\n-                        public void windowClosed(WindowEvent ev) {\n-                                System.exit(0);\n-                        }\n-                });\n-\n-                setLayout(new BorderLayout());\n-                add(printImageCanvas, BorderLayout.CENTER);\n-                pack();\n-\n-                setSize(500,500);\n-                setVisible(true);\n+    private final PrintImageCanvas printImageCanvas = new PrintImageCanvas();\n+    private final MenuItem print1Menu = new MenuItem(\"PrintTest1\");\n+    private final MenuItem print2Menu = new MenuItem(\"PrintTest2\");\n+    private static final String INSTRUCTIONS =\n+            \"Select PrintTest1 in the File menu.\\n\" +\n+            \"Print Dialog will appear.\\n\" +\n+            \"Click OK to start the first print job.\\n\" +\n+            \"\\n\" +\n+            \"Select PrintTest2 in the File menu.\\n\" +\n+            \"Page Setup Dialog will appear.\\n\" +\n+            \"Click OK.\\n\" +\n+            \"Print Dialog will appear.\\n\" +\n+            \"Click OK to start the second print job.\\n\" +\n+            \"\\n\" +\n+            \"The text in the printouts for PrintTest1 and PrintTest2 should be\\n\" +\n+            \"same as that on the screen.\\n\" +\n+            \"Press Pass if they are, otherwise press Fail.\";\n+\n+    public static void main(String[] argv) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n@@ -86,14 +74,8 @@\n-        private void initMenu() {\n-                MenuBar         mb = new MenuBar();\n-                Menu            me = new Menu(\"File\");\n-                me.add(print1Menu);\n-                me.add(print2Menu);\n-                me.add(\"-\");\n-                me.add(exitMenu);\n-                mb.add(me);\n-                this.setMenuBar(mb);\n-\n-                print1Menu.addActionListener(this);\n-                print2Menu.addActionListener(this);\n-                exitMenu.addActionListener(this);\n-        }\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(PrintImage::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -101,12 +83,4 @@\n-        public void actionPerformed(ActionEvent e) {\n-                Object target = e.getSource();\n-                if( target.equals(print1Menu) ) {\n-                        printMain1();\n-                }\n-                else if( target.equals(print2Menu) ) {\n-                        printMain2();\n-                }\n-                else if( target.equals(exitMenu) ) {\n-                        dispose();\n-                }\n-        }\n+    public PrintImage() {\n+        super(\"PrintImage\");\n+        initPrintImage();\n+    }\n@@ -114,1 +88,6 @@\n-        private void printMain1(){\n+    public void initPrintImage() {\n+        initMenu();\n+        setLayout(new BorderLayout());\n+        add(printImageCanvas, BorderLayout.CENTER);\n+        setSize(500, 300);\n+    }\n@@ -116,2 +95,7 @@\n-                PrinterJob printerJob = PrinterJob.getPrinterJob();\n-                PageFormat pageFormat = printerJob.defaultPage();\n+    private void initMenu() {\n+        MenuBar mb = new MenuBar();\n+        Menu me = new Menu(\"File\");\n+        me.add(print1Menu);\n+        me.add(print2Menu);\n+        mb.add(me);\n+        setMenuBar(mb);\n@@ -119,1 +103,3 @@\n-                printerJob.setPrintable((Printable)printImageCanvas, pageFormat);\n+        print1Menu.addActionListener(this);\n+        print2Menu.addActionListener(this);\n+    }\n@@ -121,9 +107,6 @@\n-                if(printerJob.printDialog()){\n-                        try {\n-                                printerJob.print();\n-                        }\n-                        catch(PrinterException p){\n-                        }\n-                }\n-                else\n-                        printerJob.cancel();\n+    public void actionPerformed(ActionEvent e) {\n+        Object target = e.getSource();\n+        if (target.equals(print1Menu)) {\n+            printMain1();\n+        } else if (target.equals(print2Menu)) {\n+            printMain2();\n@@ -131,0 +114,1 @@\n+    }\n@@ -132,16 +116,15 @@\n-        private void printMain2(){\n-\n-                PrinterJob printerJob = PrinterJob.getPrinterJob();\n-                PageFormat pageFormat = printerJob.pageDialog(printerJob.defaultPage());\n-\n-                printerJob.setPrintable((Printable)printImageCanvas, pageFormat);\n-\n-                if(printerJob.printDialog()){\n-                        try {\n-                                printerJob.print();\n-                        }\n-                        catch(PrinterException p){\n-                        }\n-                }\n-                else\n-                        printerJob.cancel();\n+    private void printMain1() {\n+        PrinterJob printerJob = PrinterJob.getPrinterJob();\n+        PageFormat pageFormat = printerJob.defaultPage();\n+\n+        printerJob.setPrintable(printImageCanvas, pageFormat);\n+\n+        if (printerJob.printDialog()) {\n+            try {\n+                printerJob.print();\n+            } catch (PrinterException e) {\n+                PassFailJFrame.forceFail(\"Print Failed\");\n+                e.printStackTrace();\n+            }\n+        } else {\n+            printerJob.cancel();\n@@ -149,0 +132,1 @@\n+    }\n@@ -150,8 +134,15 @@\n-}\n-\n-class PrintImageCanvas extends Canvas implements Printable {\n-\n-        private PrintImage pdsFrame;\n-\n-        public PrintImageCanvas(PrintImage pds) {\n-                pdsFrame = pds;\n+    private void printMain2() {\n+        PrinterJob printerJob = PrinterJob.getPrinterJob();\n+        PageFormat pageFormat = printerJob.pageDialog(printerJob.defaultPage());\n+\n+        printerJob.setPrintable(printImageCanvas, pageFormat);\n+\n+        if (printerJob.printDialog()) {\n+            try {\n+                printerJob.print();\n+            } catch (PrinterException e) {\n+                PassFailJFrame.forceFail(\"Print Failed\");\n+                e.printStackTrace();\n+            }\n+        } else {\n+            printerJob.cancel();\n@@ -159,0 +150,1 @@\n+    }\n@@ -160,0 +152,2 @@\n+    private static class PrintImageCanvas extends Canvas implements Printable {\n+        @Override\n@@ -161,3 +155,4 @@\n-                Font drawFont = new Font(\"MS Mincho\",Font.ITALIC,50);\n-                g.setFont(drawFont);\n-                g.drawString(\"PrintSample!\",100,150);\n+            Font drawFont = new Font(\"MS Mincho\", Font.ITALIC, 50);\n+            g.setFont(drawFont);\n+            g.setColor(new Color(0, 0, 0, 200));\n+            g.drawString(\"PrintSample!\", 100, 150);\n@@ -166,0 +161,1 @@\n+        @Override\n@@ -168,12 +164,5 @@\n-\n-                if(pi>=1)\n-                        return NO_SUCH_PAGE;\n-                else{\n-                        Graphics2D g2 = (Graphics2D)g;\n-                        g.setColor(new Color(0,0,0,200));\n-\n-                        Font drawFont = new Font(\"MS Mincho\",Font.ITALIC,50);\n-                        g.setFont(drawFont);\n-                        g.drawString(\"PrintSample!\",100,150);\n-                        return PAGE_EXISTS;\n-                }\n+            if (pi > 0) {\n+                return NO_SUCH_PAGE;\n+            }\n+            paint(g);\n+            return PAGE_EXISTS;\n@@ -181,113 +170,0 @@\n-}\n-\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n@@ -295,0 +171,1 @@\n+}\n@@ -296,1 +173,0 @@\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintImage.java","additions":123,"deletions":247,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,16 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.text.AttributedCharacterIterator;\n+import java.text.AttributedString;\n+\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +44,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,209 +48,23 @@\n-\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintNullString extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"text messages as in the test window on the screen\",\n-         \"The messages should contain only 'OK' and 'expected' messages\",\n-         \"There should be no FAILURE messages.\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If the page fails to print, but there were no exceptions\",\n-         \"then the problem is likely elsewhere (ie your printer)\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintNullString f = new PrintNullString();\n-    f.show();\n- }\n-\n- public PrintNullString() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n-            }\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    String nullStr = null;\n-    String emptyStr = new String();\n-    AttributedString nullAttStr = null;\n-    AttributedString emptyAttStr = new AttributedString(emptyStr);\n-    AttributedCharacterIterator nullIterator = null;\n-    AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n-    }\n-\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-        \/\/ API 1: null & empty drawString(String, int, int);\n-        try {\n-             g.drawString(nullStr, 20, 40);\n-             g.drawString(\"FAILURE: No NPE for null String, int\", 20, 40);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null String, int\", 20, 40);\n-        }\/* catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null String, int\",\n-                        20, 40);\n-        }*\/\n-\n-        \/\/try {\n-             g.drawString(emptyStr, 20, 60);\n-             g.drawString(\"OK for empty String, int\", 20, 60);\n-        \/*} catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty String, int\",\n-                        20, 60);\n-        }*\/\n-\n-\n-        \/\/ API 2: null & empty drawString(String, float, float);\n-        try {\n-             g.drawString(nullStr, 20.0f, 80.0f);\n-             g.drawString(\"FAILURE: No NPE for null String, float\", 20, 80);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null String, float\", 20, 80);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null String, float\",\n-                        20, 80);\n-        }*\/\n-        \/\/try {\n-             g.drawString(emptyStr, 20.0f, 100.0f);\n-             g.drawString(\"OK for empty String, float\", 20.0f, 100.f);\n-        \/* } catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty String, float\",\n-                        20, 100);\n-        }*\/\n-\n-        \/\/ API 3: null & empty drawString(Iterator, int, int);\n-        try {\n-             g.drawString(nullIterator, 20, 120);\n-             g.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 120);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null iterator, int\", 20, 120);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null iterator, int\",\n-                       20, 120);\n-        } *\/\n-        try {\n-             g.drawString(emptyIterator, 20, 140);\n-             g.drawString(\"FAILURE: No IAE for empty iterator, int\",\n-                           20, 140);\n-        } catch (IllegalArgumentException e) {\n-          g.drawString(\"caught expected IAE for empty iterator, int\",\n-                        20, 140);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty iterator, int\",\n-                       20, 140);\n-        } *\/\n-\n-\n-        \/\/ API 4: null & empty drawString(Iterator, float, int);\n-        try {\n-             g.drawString(nullIterator, 20.0f, 160.0f);\n-             g.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 160);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null iterator, float\", 20, 160);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null iterator, float\",\n-                        20, 160);\n-        } *\/\n-\n-        try {\n-             g.drawString(emptyIterator, 20, 180);\n-             g.drawString(\"FAILURE: No IAE for empty iterator, float\",\n-                           20, 180);\n-        } catch (IllegalArgumentException e) {\n-          g.drawString(\"caught expected IAE for empty iterator, float\",\n-                        20, 180);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty iterator, float\",\n-                       20, 180);\n-        } *\/\n-    }\n-\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n-    }\n- }\n-\n-}\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+public class PrintNullString extends Frame {\n+    private static final String INSTRUCTIONS =\n+            \"This test should print a page which contains the same\\n\" +\n+            \"text messages as in the test window on the screen.\\n\" +\n+            \"\\n\" +\n+            \"The messages should contain only 'OK' and 'expected' messages.\\n\" +\n+            \"Press Pass if it's the case; otherwise press Fail.\\n\" +\n+            \"\\n\" +\n+            \"If the page fails to print, but there were no exceptions\\n\" +\n+            \"then the problem is likely elsewhere (i.e. your printer)\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(PrintNullString::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n@@ -242,4 +73,24 @@\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n+    public PrintNullString() {\n+        super(\"PrintNullString\");\n+\n+        TextCanvas c = new TextCanvas();\n+        add(\"Center\", c);\n+\n+        Button b = new Button(\"Print\");\n+        add(\"South\", b);\n+        b.addActionListener(e -> {\n+            PrinterJob pj = PrinterJob.getPrinterJob();\n+            if (pj.printDialog()) {\n+                pj.setPrintable(c);\n+                try {\n+                    pj.print();\n+                } catch (PrinterException ex) {\n+                    ex.printStackTrace();\n+                    String msg = \"PrinterException: \" + ex.getMessage();\n+                    JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                            JOptionPane.ERROR_MESSAGE);\n+                    PassFailJFrame.forceFail(msg);\n+                }\n+            }\n+        });\n+        pack();\n@@ -248,28 +99,18 @@\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n+    private static class TextCanvas extends Panel implements Printable {\n+        private final String nullStr = null;\n+        private final String emptyStr = \"\";\n+        private final AttributedString emptyAttStr = new AttributedString(emptyStr);\n+        private final AttributedCharacterIterator nullIterator = null;\n+        private final AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n+\n+        @Override\n+        public void paint(Graphics g) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            paint(g2d);\n+        }\n+\n+        @Override\n+        public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+            if (pgIndex > 0) {\n+                return NO_SUCH_PAGE;\n+            }\n@@ -277,2 +118,3 @@\n-      show();\n-    }\/\/ TestDialog()\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+            paint(g2d);\n@@ -280,5 +122,2 @@\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n+            return PAGE_EXISTS;\n+        }\n@@ -286,1 +125,8 @@\n-      \/\/Go down array of instruction strings\n+        private void paint(Graphics2D g2d) {\n+            \/\/ API 1: null & empty drawString(String, int, int);\n+            try {\n+                g2d.drawString(nullStr, 20, 40);\n+                g2d.drawString(\"FAILURE: No NPE for null String, int\", 20, 40);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null String, int\", 20, 40);\n+            }\n@@ -288,13 +134,2 @@\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n+            g2d.drawString(emptyStr, 20, 60);\n+            g2d.drawString(\"OK for empty String, int\", 20, 60);\n@@ -302,1 +137,7 @@\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n+            \/\/ API 2: null & empty drawString(String, float, float);\n+            try {\n+                g2d.drawString(nullStr, 20.0f, 80.0f);\n+                g2d.drawString(\"FAILURE: No NPE for null String, float\", 20, 80);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null String, float\", 20, 80);\n+            }\n@@ -304,9 +145,2 @@\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n+            g2d.drawString(emptyStr, 20.0f, 100.0f);\n+            g2d.drawString(\"OK for empty String, float\", 20.0f, 100.f);\n@@ -314,1 +148,7 @@\n-            instructionsText.append( printStr + \"\\n\" );\n+            \/\/ API 3: null & empty drawString(Iterator, int, int);\n+            try {\n+                g2d.drawString(nullIterator, 20, 120);\n+                g2d.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 120);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null iterator, int\", 20, 120);\n+            }\n@@ -316,1 +156,6 @@\n-          }\/\/ while\n+            try {\n+                g2d.drawString(emptyIterator, 20, 140);\n+                g2d.drawString(\"FAILURE: No IAE for empty iterator, int\", 20, 140);\n+            } catch (IllegalArgumentException e) {\n+                g2d.drawString(\"caught expected IAE for empty iterator, int\", 20, 140);\n+            }\n@@ -318,1 +163,7 @@\n-       }\/\/ for\n+            \/\/ API 4: null & empty drawString(Iterator, float, int);\n+            try {\n+                g2d.drawString(nullIterator, 20.0f, 160.0f);\n+                g2d.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 160);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null iterator, float\", 20, 160);\n+            }\n@@ -320,1 +171,7 @@\n-    }\/\/printInstructions()\n+            try {\n+                g2d.drawString(emptyIterator, 20, 180);\n+                g2d.drawString(\"FAILURE: No IAE for empty iterator, float\", 20, 180);\n+            } catch (IllegalArgumentException e) {\n+                g2d.drawString(\"caught expected IAE for empty iterator, float\", 20, 180);\n+            }\n+        }\n@@ -322,4 +179,4 @@\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n+        @Override\n+        public Dimension getPreferredSize() {\n+            return new Dimension(450, 250);\n+        }\n@@ -327,2 +184,1 @@\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintNullString.java","additions":140,"deletions":284,"binary":false,"changes":424,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,14 @@\n-\/**\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +42,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +46,22 @@\n+public class PrintParenString implements Printable {\n+    private static final String STR = \"String containing unclosed parenthesis (.\";\n+\n+    private static final String INSTRUCTIONS =\n+            \"This test should print a page with following text\\n\\n\" +\n+            STR + \"\\n\\n\" +\n+            \"If an exception is thrown, or the page doesn't print properly\\n\" +\n+            \"then the test fails\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .splitUI(PrintParenString::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -32,42 +69,15 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintParenString extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"text message as in the test window on the screen\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If an exception is thrown, or the page doesn't print properly\",\n-         \"then the test fails\",\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintParenString f = new PrintParenString();\n-    f.show();\n- }\n-\n- public PrintParenString() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n+    private static JComponent createTestUI() {\n+        JButton b = new JButton(\"Print\");\n+        b.addActionListener((ae) -> {\n+            try {\n+                PrinterJob job = PrinterJob.getPrinterJob();\n+                job.setPrintable(new PrintParenString());\n+                if (job.printDialog()) {\n+                    job.print();\n+                }\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n@@ -75,41 +85,8 @@\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    String nullStr = null;\n-    String emptyStr = new String();\n-    AttributedString nullAttStr = null;\n-    AttributedString emptyAttStr = new AttributedString(emptyStr);\n-    AttributedCharacterIterator nullIterator = null;\n-    AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n+        });\n+\n+        Box main = Box.createHorizontalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createHorizontalGlue());\n+        main.add(b);\n+        main.add(Box.createHorizontalGlue());\n+        return main;\n@@ -118,5 +95,5 @@\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-          String str = \"String containing unclosed parenthesis (.\";\n-          g.drawString(str, 20, 40);\n+    @Override\n+    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+        if (pgIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n@@ -124,1 +101,3 @@\n-    }\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+        g2d.drawString(STR, 20, 40);\n@@ -126,2 +105,1 @@\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n+        return Printable.PAGE_EXISTS;\n@@ -129,2 +107,0 @@\n- }\n-\n@@ -132,115 +108,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintParenString.java","additions":71,"deletions":210,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,17 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.geom.AffineTransform;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -28,0 +44,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +49,21 @@\n+public class PrintTranslatedFont extends Frame {\n+    private static final String INSTRUCTIONS =\n+            \"This test should print a page which contains the same\\n\" +\n+            \"content as the test window on the screen, in particular the lines\\n\" +\n+            \"should be immediately under the text\\n\\n\" +\n+            \"If an exception is thrown, or the page doesn't print properly\\n\" +\n+            \"then the test fails\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(PrintTranslatedFont::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -32,44 +71,21 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.geom.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintTranslatedFont extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"content as the test window on the screen, in particular the lines\",\n-         \"should be immediately under the text\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If an exception is thrown, or the page doesn't print properly\",\n-         \"then the test fails\",\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintTranslatedFont f = new PrintTranslatedFont();\n-    f.show();\n- }\n-\n- public PrintTranslatedFont() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n+    public PrintTranslatedFont() {\n+        super(\"PrintTranslatedFont\");\n+\n+        TextCanvas c = new TextCanvas();\n+        add(\"Center\", c);\n+\n+        Button b = new Button(\"Print\");\n+        add(\"South\", b);\n+        b.addActionListener(e -> {\n+            PrinterJob pj = PrinterJob.getPrinterJob();\n+            if (pj.printDialog()) {\n+                pj.setPrintable(c);\n+                try {\n+                    pj.print();\n+                } catch (PrinterException ex) {\n+                    ex.printStackTrace();\n+                    String msg = \"PrinterException: \" + ex.getMessage();\n+                    JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                            JOptionPane.ERROR_MESSAGE);\n+                    PassFailJFrame.forceFail(msg);\n+                }\n@@ -77,6 +93,1 @@\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n+        });\n@@ -84,27 +95,1 @@\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n+        pack();\n@@ -113,23 +98,12 @@\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-          Font f = new Font(\"Dialog\", Font.PLAIN, 20);\n-          int tx = 20;\n-          int ty = 20;\n-          AffineTransform at = AffineTransform.getTranslateInstance(tx, ty);\n-          f = f.deriveFont(at);\n-          g.setFont(f);\n-\n-          FontMetrics fm = g.getFontMetrics();\n-          String str = \"Basic ascii string\";\n-          int sw = fm.stringWidth(str);\n-          int posx = 20, posy = 40;\n-          g.drawString(str, posx, posy);\n-          g.drawLine(posx+tx, posy+ty+2, posx+tx+sw, posy+ty+2);\n-\n-          posx = 20; posy = 70;\n-          str = \"Test string compound printing \\u2203\\u2200\";\n-          sw = fm.stringWidth(str);\n-          g.drawString(str, posx, posy);\n-          g.drawLine(posx+tx, posy+ty+2, posx+tx+sw, posy+ty+2);\n-    }\n+    private static class TextCanvas extends Panel implements Printable {\n+        @Override\n+        public void paint(Graphics g) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            paint(g2d);\n+        }\n+\n+        @Override\n+        public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+            if (pgIndex > 0) {\n+                return Printable.NO_SUCH_PAGE;\n+            }\n@@ -137,2 +111,34 @@\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+            paint(g2d);\n+            return Printable.PAGE_EXISTS;\n+        }\n+\n+        private void paint(Graphics2D g2d) {\n+            Font f = new Font(\"Dialog\", Font.PLAIN, 20);\n+            int tx = 20;\n+            int ty = 20;\n+            AffineTransform at = AffineTransform.getTranslateInstance(tx, ty);\n+            f = f.deriveFont(at);\n+            g2d.setFont(f);\n+\n+            FontMetrics fm = g2d.getFontMetrics();\n+            String str = \"Basic ascii string\";\n+            int sw = fm.stringWidth(str);\n+            int posx = 20;\n+            int posy = 40;\n+            g2d.drawString(str, posx, posy);\n+            g2d.drawLine(posx + tx, posy + ty + 2, posx + tx + sw, posy + ty + 2);\n+\n+            posx = 20;\n+            posy = 70;\n+            str = \"Test string compound printing \\u2203\\u2200\";\n+            sw = fm.stringWidth(str);\n+            g2d.drawString(str, posx, posy);\n+            g2d.drawLine(posx + tx, posy + ty + 2, posx + tx + sw, posy + ty + 2);\n+        }\n+\n+        @Override\n+        public Dimension getPreferredSize() {\n+            return new Dimension(450, 250);\n+        }\n@@ -140,2 +146,0 @@\n- }\n-\n@@ -143,115 +147,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintTranslatedFont.java","additions":110,"deletions":221,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @bug 4784285 4785920\n+ * @bug 4784285 4785920 5024549\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrinterDialogsModalityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,19 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridLayout;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Paper;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +47,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,5 +51,0 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-\n@@ -37,287 +52,21 @@\n-\n-PrinterJob myPrinterJob;\n-PageFormat myPageFormat;\n-Label pw, ph, pglm, pgrm, pgiw, pgih, pgtm, pgbm;\n-TextField tpw, tph, tpglm, tpgtm, tpgiw, tpgih;\n-Label myWidthLabel;\n-Label myHeightLabel;\n-Label myImageableXLabel;\n-Label myImageableYLabel;\n-Label myImageableRightLabel;\n-Label myImageableBottomLabel;\n-Label myImageableWidthLabel;\n-Label myImageableHeightLabel;\n-Label myOrientationLabel;\n-\n-  protected void displayPageFormatAttributes() {\n-    myWidthLabel.setText (\"Format Width = \" + drnd(myPageFormat.getWidth()));\n-    myHeightLabel.setText (\"Format Height = \" + drnd(myPageFormat.getHeight()));\n-    myImageableXLabel.setText\n-        (\"Format Left Margin = \" + drnd(myPageFormat.getImageableX()));\n-    myImageableRightLabel.setText\n-        (\"Format Right Margin = \" + drnd(myPageFormat.getWidth() -\n-        (myPageFormat.getImageableX() + myPageFormat.getImageableWidth())));\n-    myImageableWidthLabel.setText\n-        (\"Format ImageableWidth = \" + drnd(myPageFormat.getImageableWidth()));\n-    myImageableYLabel.setText\n-        (\"Format Top Margin = \" + drnd(myPageFormat.getImageableY()));\n-    myImageableBottomLabel.setText\n-        (\"Format Bottom Margin = \" + drnd(myPageFormat.getHeight() -\n-        (myPageFormat.getImageableY() + myPageFormat.getImageableHeight())));\n-    myImageableHeightLabel.setText\n-        (\"Format ImageableHeight = \" + drnd(myPageFormat.getImageableHeight()));\n-    int o = myPageFormat.getOrientation();\n-    myOrientationLabel.setText\n-        (\"Format Orientation = \" +\n-                (o == PageFormat.PORTRAIT ? \"PORTRAIT\" :\n-                 o == PageFormat.LANDSCAPE ? \"LANDSCAPE\" :\n-                 o == PageFormat.REVERSE_LANDSCAPE ? \"REVERSE_LANDSCAPE\" :\n-                 \"<invalid>\"));\n-    Paper p = myPageFormat.getPaper();\n-    pw.setText(\"Paper Width = \" + drnd(p.getWidth()));\n-    ph.setText(\"Paper Height = \" + drnd(p.getHeight()));\n-    pglm.setText(\"Paper Left Margin = \" + drnd(p.getImageableX()));\n-    pgiw.setText(\"Paper Imageable Width = \" + drnd(p.getImageableWidth()));\n-    pgih.setText(\"Paper Imageable Height = \" + drnd(p.getImageableHeight()));\n-\n-    pgrm.setText(\"Paper Right Margin = \" +\n-         drnd(p.getWidth() - (p.getImageableX()+p.getImageableWidth())));\n-    pgtm.setText(\"Paper Top Margin = \" + drnd(p.getImageableY()));\n-    pgbm.setText(\"Paper Bottom Margin = \" +\n-       drnd(p.getHeight() - (p.getImageableY()+p.getImageableHeight())));\n-  }\n-\n-  static String drnd(double d) {\n-      d = d * 10.0 + 0.5;\n-      d = Math.floor(d) \/10.0;\n-      String ds = Double.toString(d);\n-      int decimal_pos = ds.indexOf(\".\");\n-      int len = ds.length();\n-      if (len > decimal_pos+2) {\n-          return ds.substring(0, decimal_pos+2);\n-      } else {\n-          return ds;\n-      }\n-  }\n-\n-  public ValidatePage() {\n-    super (\"Validate Page Test\");\n-    myPrinterJob = PrinterJob.getPrinterJob();\n-    myPageFormat = new PageFormat();\n-    Paper p = new Paper();\n-    p.setSize(28*72, 21.5 * 72);\n-    myPageFormat.setPaper(p);\n-    setLayout(new FlowLayout());\n-    Panel pfp = new Panel();\n-    pfp.setLayout (new GridLayout (9, 1, 0, 0));\n-    pfp.add (myOrientationLabel = new Label());\n-    pfp.add (myWidthLabel = new Label());\n-    pfp.add (myImageableXLabel = new Label());\n-    pfp.add (myImageableRightLabel = new Label());\n-    pfp.add (myImageableWidthLabel = new Label());\n-    pfp.add (myHeightLabel = new Label());\n-    pfp.add (myImageableYLabel = new Label());\n-    pfp.add (myImageableBottomLabel = new Label());\n-    pfp.add (myImageableHeightLabel = new Label());\n-\n-    add(pfp);\n-\n-    Panel pp = new Panel();\n-    pp.setLayout (new GridLayout (8, 1, 0, 0));\n-    pp.add (pw = new Label());\n-    pp.add (pglm = new Label());\n-    pp.add (pgtm = new Label());\n-    pp.add (ph = new Label());\n-    pp.add (pgiw = new Label());\n-    pp.add (pgih = new Label());\n-    pp.add (pgrm = new Label());\n-    pp.add (pgbm = new Label());\n-\n-    add(pp);\n-\n-    Panel epp = new Panel();\n-    epp.setLayout (new GridLayout (6, 2, 0, 0));\n-\n-    epp.add(new Label(\"Page width:\"));\n-    epp.add (tpw = new TextField());\n-    epp.add(new Label(\"Page height:\"));\n-    epp.add (tph = new TextField());\n-    epp.add(new Label(\"Left Margin:\"));\n-    epp.add (tpglm = new TextField());\n-    epp.add(new Label(\"Top margin:\"));\n-    epp.add (tpgtm = new TextField());\n-    epp.add(new Label(\"Imageable Wid:\"));\n-    epp.add (tpgiw = new TextField());\n-    epp.add(new Label(\"Imageable Hgt:\"));\n-    epp.add (tpgih = new TextField());\n-\n-    add(epp);\n-       displayPageFormatAttributes();\n-\n-    Panel panel = new Panel();\n-    Button defButton = new Button (\"Default Page\");\n-    defButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                        myPageFormat = myPrinterJob.defaultPage();\n-                        displayPageFormatAttributes();\n-                }\n-    });\n-\n-    Button pageButton = new Button (\"Page Setup..\");\n-    pageButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                        myPageFormat = myPrinterJob.pageDialog (myPageFormat);\n-                        displayPageFormatAttributes();\n-                }\n-    });\n-    Button printButton = new Button (\"Print\");\n-    printButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                    try {\n-                         \/\/if (myPrinterJob.printDialog()) {\n-                             myPrinterJob.setPrintable(ValidatePage.this,\n-                                                       myPageFormat);\n-                             myPrinterJob.print();\n-                   \/\/ }\n-                    } catch (PrinterException pe ) {\n-                    }\n-                }\n-    });\n-\n-    Button chooseButton = new Button (\"Printer..\");\n-    chooseButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                            myPrinterJob.printDialog();\n-                }\n-    });\n-\n-    Button validateButton = new Button (\"Validate Page\");\n-    validateButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                        myPageFormat = myPrinterJob.validatePage(myPageFormat);\n-                        displayPageFormatAttributes();\n-                }\n-    });\n-    Button setButton = new Button (\"Set Paper\");\n-    setButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                  try {\n-                      Paper p = new Paper();\n-                      double pwid = Double.parseDouble(tpw.getText());\n-                      double phgt = Double.parseDouble(tph.getText());\n-                      double pimx = Double.parseDouble(tpglm.getText());\n-                      double pimy = Double.parseDouble(tpgtm.getText());\n-                      double pimwid = Double.parseDouble(tpgiw.getText());\n-                      double pimhgt = Double.parseDouble(tpgih.getText());\n-                      p.setSize(pwid, phgt);\n-                      p.setImageableArea(pimx, pimy, pimwid, pimhgt);\n-                      myPageFormat.setPaper(p);\n-                            displayPageFormatAttributes();\n-                  } catch (NumberFormatException nfe) {\n-                  }\n-                }\n-    });\n-    panel.add (setButton);\n-    panel.add (defButton);\n-    panel.add (pageButton);\n-    panel.add (chooseButton);\n-    panel.add (validateButton);\n-    panel.add (printButton);\n-    add(panel);\n-    TextArea ta = new TextArea(7, 60);\n-    String ls = System.getProperty(\"line.Separator\", \"\\n\");\n-    ta.setText(\n-        \"When validating a page, the process is 1st to find the closest matching \" + ls +\n-        \"paper size, next to make sure the requested imageable area fits within \" + ls +\n-        \"the printer's imageable area for that paper size. Finally the top and \" + ls +\n-        \"left margins will be shrunk if they are too great for the adjusted \" + ls +\n-        \"imageable area to fit at that position. They will shrink by the minimum\" + ls +\n-        \"needed to accomodate the imageable area.\"+ls+ls+\n-        \"To test 6229507, put the minimum margins (all 0s) in Page Setup dialog.\"+ls+\n-        \"Compare Imageable width, height, and margins of portrait against landscape.\");\n-    ta.setEditable(false);\n-    add(ta);\n-\n-    addWindowListener (new WindowAdapter() {\n-         public void windowClosing (WindowEvent e) {\n-            dispose();\n-            System.exit (0);\n-         }\n-\n-      });\n-      setSize (500, 630);\n-      setVisible (true);\n-  }\n-\n-  public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n-\n-     if (pageIndex > 0) {\n-        return Printable.NO_SUCH_PAGE;\n-     }\n-\n-     Graphics2D g2d = (Graphics2D)graphics;\n-\n-    int o = pageFormat.getOrientation();\n-\n-     System.out.println(\"Format Orientation = \" +\n-                (o == PageFormat.PORTRAIT ? \"PORTRAIT\" :\n-                 o == PageFormat.LANDSCAPE ? \"LANDSCAPE\" :\n-                 o == PageFormat.REVERSE_LANDSCAPE ? \"REVERSE_LANDSCAPE\" :\n-                 \"<invalid>\"));\n-     System.out.println(g2d.getTransform());\n-     System.out.println(\"ix=\"+pageFormat.getImageableX()+\n-                       \" iy=\"+pageFormat.getImageableY());\n-     g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n-     g2d.drawString(\"ORIGIN\", 20, 20);\n-     g2d.drawString(\"X THIS WAY\", 200, 50);\n-     g2d.drawString(\"Y THIS WAY\", 60 , 200);\n-     g2d.drawRect(0,0,(int)pageFormat.getImageableWidth(),\n-                      (int)pageFormat.getImageableHeight());\n-     g2d.setColor(Color.blue);\n-     g2d.drawRect(1,1,(int)pageFormat.getImageableWidth()-2,\n-                      (int)pageFormat.getImageableHeight()-2);\n-\n-     return  Printable.PAGE_EXISTS;\n-  }\n-\n-  public static void main( String[] args) {\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test is very flexible and requires much interaction.\",\n-         \"There are several buttons.\",\n-         \"Set Paper: if all fields are valid numbers it sets the Paper object.\",\n-         \"This is used to create arbitrary nonsensical paper sizes to help\",\n-         \"test validatePage.\",\n-         \"Default Page: sets a default page. This should always be valid.\",\n-         \"Page Setup: brings up the page dialog. You must OK this dialog\",\n-         \"for it to have any effect. You can use this to set different size,\",\n-         \"orientation and margins - which of course affect imageable area.\",\n-         \"Printer: Used to set the current printer. Useful because current\",\n-         \"printer affects the choice of paper sizes available.\",\n-         \"You must OK this dialog for it to have any effect.\",\n-         \"Validate Page:\",\n-         \"The most important button in the test. By setting nonsensical\",\n-         \"or valid papers with varying margins etc, this should always find\",\n-         \"the closest\",\n-         \"match within the limits of what is possible on the current printer.\",\n-         \"Print: to the current printer. Not vital for this test.\",\n-         \"request.\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-     new ValidatePage();\n-  }\n-\n-}\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    PrinterJob myPrinterJob;\n+    PageFormat myPageFormat;\n+    Label pw, ph, pglm, pgrm, pgiw, pgih, pgtm, pgbm;\n+    TextField tpw, tph, tpglm, tpgtm, tpgiw, tpgih;\n+    Label myWidthLabel;\n+    Label myHeightLabel;\n+    Label myImageableXLabel;\n+    Label myImageableYLabel;\n+    Label myImageableRightLabel;\n+    Label myImageableBottomLabel;\n+    Label myImageableWidthLabel;\n+    Label myImageableHeightLabel;\n+    Label myOrientationLabel;\n+\n+    private static String getOrientation(int o) {\n+        return switch (o) {\n+            case PageFormat.PORTRAIT -> \"PORTRAIT\";\n+            case PageFormat.LANDSCAPE -> \"LANDSCAPE\";\n+            case PageFormat.REVERSE_LANDSCAPE -> \"REVERSE_LANDSCAPE\";\n+            default -> \"<invalid>\";\n+        };\n@@ -326,7 +75,32 @@\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    private void displayPageFormatAttributes() {\n+        myWidthLabel.setText(\"Format Width = \" + drnd(myPageFormat.getWidth()));\n+        myHeightLabel.setText(\"Format Height = \" + drnd(myPageFormat.getHeight()));\n+        myImageableXLabel.setText(\"Format Left Margin = \" + drnd(myPageFormat.getImageableX()));\n+        myImageableRightLabel.setText(\"Format Right Margin = \"\n+                + drnd(myPageFormat.getWidth()\n+                        - (myPageFormat.getImageableX() + myPageFormat.getImageableWidth())));\n+        myImageableWidthLabel.setText(\"Format ImageableWidth = \"\n+                + drnd(myPageFormat.getImageableWidth()));\n+        myImageableYLabel.setText(\"Format Top Margin = \"\n+                + drnd(myPageFormat.getImageableY()));\n+        myImageableBottomLabel.setText(\"Format Bottom Margin = \"\n+                + drnd(myPageFormat.getHeight()\n+                        - (myPageFormat.getImageableY() + myPageFormat.getImageableHeight())));\n+        myImageableHeightLabel.setText(\"Format ImageableHeight = \"\n+                + drnd(myPageFormat.getImageableHeight()));\n+        myOrientationLabel.setText(\"Format Orientation = \"\n+                + getOrientation(myPageFormat.getOrientation()));\n+        Paper p = myPageFormat.getPaper();\n+        pw.setText(\"Paper Width = \" + drnd(p.getWidth()));\n+        ph.setText(\"Paper Height = \" + drnd(p.getHeight()));\n+        pglm.setText(\"Paper Left Margin = \" + drnd(p.getImageableX()));\n+        pgiw.setText(\"Paper Imageable Width = \" + drnd(p.getImageableWidth()));\n+        pgih.setText(\"Paper Imageable Height = \" + drnd(p.getImageableHeight()));\n+\n+        pgrm.setText(\"Paper Right Margin = \"\n+                + drnd(p.getWidth()\n+                        - (p.getImageableX() + p.getImageableWidth())));\n+        pgtm.setText(\"Paper Top Margin = \" + drnd(p.getImageableY()));\n+        pgbm.setText(\"Paper Bottom Margin = \"\n+                + drnd(p.getHeight()\n+                        - (p.getImageableY() + p.getImageableHeight())));\n@@ -335,4 +109,2 @@\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+    static String drnd(double d) {\n+        return String.format(\"%.2f\", d);\n@@ -341,4 +113,126 @@\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n+    public ValidatePage() {\n+        super(\"Validate Page Test\");\n+        myPrinterJob = PrinterJob.getPrinterJob();\n+        myPageFormat = new PageFormat();\n+        Paper p = new Paper();\n+        p.setSize(28 * 72, 21.5 * 72);\n+        myPageFormat.setPaper(p);\n+        setLayout(new FlowLayout());\n+        Panel pfp = new Panel();\n+        pfp.setLayout(new GridLayout(9, 1, 0, 0));\n+        pfp.add(myOrientationLabel = new Label());\n+        pfp.add(myWidthLabel = new Label());\n+        pfp.add(myImageableXLabel = new Label());\n+        pfp.add(myImageableRightLabel = new Label());\n+        pfp.add(myImageableWidthLabel = new Label());\n+        pfp.add(myHeightLabel = new Label());\n+        pfp.add(myImageableYLabel = new Label());\n+        pfp.add(myImageableBottomLabel = new Label());\n+        pfp.add(myImageableHeightLabel = new Label());\n+\n+        add(pfp);\n+\n+        Panel pp = new Panel();\n+        pp.setLayout(new GridLayout(8, 1, 0, 0));\n+        pp.add(pw = new Label());\n+        pp.add(pglm = new Label());\n+        pp.add(pgtm = new Label());\n+        pp.add(ph = new Label());\n+        pp.add(pgiw = new Label());\n+        pp.add(pgih = new Label());\n+        pp.add(pgrm = new Label());\n+        pp.add(pgbm = new Label());\n+\n+        add(pp);\n+\n+        Panel epp = new Panel();\n+        epp.setLayout(new GridLayout(6, 2, 0, 0));\n+\n+        epp.add(new Label(\"Page width:\"));\n+        epp.add(tpw = new TextField());\n+        epp.add(new Label(\"Page height:\"));\n+        epp.add(tph = new TextField());\n+        epp.add(new Label(\"Left Margin:\"));\n+        epp.add(tpglm = new TextField());\n+        epp.add(new Label(\"Top margin:\"));\n+        epp.add(tpgtm = new TextField());\n+        epp.add(new Label(\"Imageable Wid:\"));\n+        epp.add(tpgiw = new TextField());\n+        epp.add(new Label(\"Imageable Hgt:\"));\n+        epp.add(tpgih = new TextField());\n+\n+        add(epp);\n+        displayPageFormatAttributes();\n+\n+        Panel panel = new Panel();\n+        Button defButton = new Button(\"Default Page\");\n+        defButton.addActionListener(e -> {\n+            myPageFormat = myPrinterJob.defaultPage();\n+            displayPageFormatAttributes();\n+        });\n+\n+        Button pageButton = new Button(\"Page Setup...\");\n+        pageButton.addActionListener(e -> {\n+            myPageFormat = myPrinterJob.pageDialog(myPageFormat);\n+            displayPageFormatAttributes();\n+        });\n+        Button printButton = new Button(\"Print\");\n+        printButton.addActionListener(e -> {\n+            try {\n+                myPrinterJob.setPrintable(ValidatePage.this, myPageFormat);\n+                myPrinterJob.print();\n+            } catch (PrinterException pe) {\n+                pe.printStackTrace();\n+                PassFailJFrame.forceFail(\"Test failed because of PrinterException\");\n+            }\n+        });\n+\n+        Button chooseButton = new Button(\"Printer...\");\n+        chooseButton.addActionListener(e -> myPrinterJob.printDialog());\n+\n+        Button validateButton = new Button(\"Validate Page\");\n+        validateButton.addActionListener(e -> {\n+            myPageFormat = myPrinterJob.validatePage(myPageFormat);\n+            displayPageFormatAttributes();\n+        });\n+        Button setButton = new Button(\"Set Paper\");\n+        setButton.addActionListener(e -> {\n+            try {\n+                Paper p1 = new Paper();\n+                double pwid = Double.parseDouble(tpw.getText());\n+                double phgt = Double.parseDouble(tph.getText());\n+                double pimx = Double.parseDouble(tpglm.getText());\n+                double pimy = Double.parseDouble(tpgtm.getText());\n+                double pimwid = Double.parseDouble(tpgiw.getText());\n+                double pimhgt = Double.parseDouble(tpgih.getText());\n+                p1.setSize(pwid, phgt);\n+                p1.setImageableArea(pimx, pimy, pimwid, pimhgt);\n+                myPageFormat.setPaper(p1);\n+                displayPageFormatAttributes();\n+            } catch (NumberFormatException nfe) {\n+                JOptionPane.showMessageDialog(ValidatePage.this,\n+                        \"NumberFormatException occurred\", \"Error\",\n+                        JOptionPane.ERROR_MESSAGE);\n+            }\n+        });\n+        panel.add(setButton);\n+        panel.add(defButton);\n+        panel.add(pageButton);\n+        panel.add(chooseButton);\n+        panel.add(validateButton);\n+        panel.add(printButton);\n+        add(panel);\n+        TextArea ta = new TextArea(10, 45);\n+        ta.setText(\n+                \"When validating a page, the process is 1st to find the closest matching \\n\" +\n+                \"paper size, next to make sure the requested imageable area fits within \\n\" +\n+                \"the printer's imageable area for that paper size. Finally the top and \\n\" +\n+                \"left margins will be shrunk if they are too great for the adjusted \\n\" +\n+                \"imageable area to fit at that position. They will shrink by the minimum\\n\" +\n+                \"needed to accommodate the imageable area.\\n \\n \\n\" +\n+                \"To test 6229507, put the minimum margins (all 0s) in Page Setup dialog.\\n\" +\n+                \"Compare Imageable width, height, and margins of portrait against landscape.\");\n+\n+        ta.setEditable(false);\n+        add(ta);\n+        setSize(700, 500);\n@@ -347,78 +241,27 @@\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n+    @Override\n+    public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n+        if (pageIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n+\n+        System.out.println(\"Format Orientation = \"\n+                + getOrientation(pageFormat.getOrientation()));\n+\n+        Graphics2D g2d = (Graphics2D) graphics;\n+\n+        System.out.println(g2d.getTransform());\n+        System.out.println(\"ix=\" + pageFormat.getImageableX() +\n+                           \" iy=\" + pageFormat.getImageableY());\n+        g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n+        g2d.drawString(\"ORIGIN\", 20, 20);\n+        g2d.drawString(\"X THIS WAY\", 200, 50);\n+        g2d.drawString(\"Y THIS WAY\", 60, 200);\n+        g2d.drawRect(0, 0,\n+                    (int) pageFormat.getImageableWidth(),\n+                    (int) pageFormat.getImageableHeight());\n+        g2d.setColor(Color.blue);\n+        g2d.drawRect(1, 1,\n+                    (int) pageFormat.getImageableWidth() - 2,\n+                    (int) pageFormat.getImageableHeight() - 2);\n+\n+        return Printable.PAGE_EXISTS;\n@@ -427,1 +270,34 @@\n- }\/\/ TestDialog  class\n+    private static final String INSTRUCTIONS =\n+            \"This test is very flexible and requires much interaction.\\n\" +\n+            \"There are several buttons.\\n\\n\" +\n+            \"Set Paper: if all fields are valid numbers it sets the Paper object.\\n\" +\n+            \"This is used to create arbitrary nonsensical paper sizes to help\\n\" +\n+            \"test validatePage.\\n\\n\" +\n+            \"Default Page: sets a default page. This should always be valid.\\n\\n\" +\n+            \"Page Setup: brings up the page dialog. You must OK this dialog\\n\" +\n+            \"for it to have any effect. You can use this to set different size,\\n\" +\n+            \"orientation and margins - which of course affect imageable area.\\n\\n\" +\n+            \"Printer: Used to set the current printer. Useful because current\\n\" +\n+            \"printer affects the choice of paper sizes available.\\n\" +\n+            \"You must OK this dialog for it to have any effect.\\n\\n\" +\n+            \"Validate Page:The most important button in the test.\\n\" +\n+            \"By setting nonsensical or valid papers with varying margins etc,\\n\" +\n+            \"this should always find the closest match within the limits of\\n\" +\n+            \"what is possible on the current printer.\\n\\n\" +\n+            \"Print: to the current printer. Not vital for this test request.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(10)\n+                .testUI(ValidatePage::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/ValidatePage\/ValidatePage.java","additions":264,"deletions":388,"binary":false,"changes":652,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,17 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.image.BufferedImage;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -29,0 +45,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,8 +49,0 @@\n-import java.awt.*;\n-import java.awt.geom.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.awt.Toolkit;\n-import java.awt.image.BufferedImage;\n-\n-\n@@ -40,0 +50,23 @@\n+    private final RasterCanvas c;\n+    private static final String INSTRUCTIONS =\n+            \"This test uses rendering operations which force the implementation\\n\" +\n+            \"to print the page as a raster\\n\" +\n+            \"You should see two square images, the 1st containing overlapping\\n\" +\n+            \"composited squares, the lower image shows a gradient paint.\\n\" +\n+            \"The printed output should match the on-screen display, although\\n\" +\n+            \"only colour printers will be able to accurately reproduce the\\n\" +\n+            \"subtle color changes.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(RasterTest::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -41,22 +74,1 @@\n- private RasterCanvas c;\n-\n- public static void main(String args[]) {\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test uses rendering operations which force the implementation\",\n-         \"to print the page as a raster\",\n-         \"You should see two square images, the 1st containing overlapping\",\n-         \"composited squares, the lower image shows a gradient paint.\",\n-         \"The printed output should match the on-screen display, although\",\n-         \"only colour printers will be able to accurately reproduce the\",\n-         \"subtle color changes.\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    RasterTest f = new RasterTest();\n-    f.show();\n- }\n-\n- public RasterTest() {\n+    public RasterTest() {\n@@ -65,14 +77,2 @@\n-    c = new RasterCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n-            }\n-    });\n-\n-    pack();\n+        c = new RasterCanvas();\n+        add(\"Center\", c);\n@@ -80,0 +80,4 @@\n+        Button printButton = new Button(\"Print\");\n+        printButton.addActionListener(this);\n+        add(\"South\", printButton);\n+        pack();\n@@ -81,30 +85,0 @@\n-\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n-}\n-\n-\n- class RasterCanvas extends Canvas implements Printable {\n-\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-         Graphics2D g2d= (Graphics2D)g;\n-         g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-         doPaint(g2d);\n-      return Printable.PAGE_EXISTS;\n@@ -113,3 +87,2 @@\n-    public void paint(Graphics g) {\n-       doPaint(g);\n-    }\n+    public void actionPerformed(ActionEvent e) {\n+        PrinterJob pj = PrinterJob.getPrinterJob();\n@@ -117,2 +90,9 @@\n-    public void paintComponent(Graphics g) {\n-       doPaint(g);\n+        if (pj.printDialog()) {\n+            pj.setPrintable(c);\n+            try {\n+                pj.print();\n+            } catch (PrinterException pe) {\n+                pe.printStackTrace();\n+                PassFailJFrame.forceFail(\"Test failed because of PrinterException\");\n+            }\n+        }\n@@ -121,25 +101,6 @@\n-    public void doPaint(Graphics g) {\n-        Graphics2D g2 = (Graphics2D)g;\n-\n-        g2.setColor(Color.black);\n-\n-        BufferedImage bimg = new BufferedImage(200, 200,\n-                                                 BufferedImage.TYPE_INT_ARGB);\n-        Graphics ig = bimg.getGraphics();\n-        Color alphared = new Color(255, 0, 0, 128);\n-        Color alphagreen = new Color(0, 255, 0, 128);\n-        Color alphablue = new Color(0, 0, 255, 128);\n-        ig.setColor(alphared);\n-        ig.fillRect(0,0,200,200);\n-        ig.setColor(alphagreen);\n-        ig.fillRect(25,25,150,150);\n-        ig.setColor(alphablue);\n-        ig.fillRect(75,75,125,125);\n-        g.drawImage(bimg, 10, 25, this);\n-\n-        GradientPaint gp =\n-         new GradientPaint(10.0f, 10.0f, alphablue, 210.0f, 210.0f, alphared, true);\n-        g2.setPaint(gp);\n-        g2.fillRect(10, 240, 200, 200);\n-\n-     }\n+    private static class RasterCanvas extends Canvas implements Printable {\n+        @Override\n+        public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+            if (pgIndex > 0) {\n+                return Printable.NO_SUCH_PAGE;\n+            }\n@@ -147,2 +108,40 @@\n-    public Dimension getPreferredSize() {\n-        return new Dimension(500, 500);\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+            doPaint(g2d);\n+\n+            return Printable.PAGE_EXISTS;\n+        }\n+\n+        @Override\n+        public void paint(Graphics g) {\n+            doPaint(g);\n+        }\n+\n+        private void doPaint(Graphics g) {\n+            BufferedImage bimg = new BufferedImage(200, 200,\n+                    BufferedImage.TYPE_INT_ARGB);\n+            Graphics ig = bimg.getGraphics();\n+            Color alphared = new Color(255, 0, 0, 128);\n+            Color alphagreen = new Color(0, 255, 0, 128);\n+            Color alphablue = new Color(0, 0, 255, 128);\n+            ig.setColor(alphared);\n+            ig.fillRect(0, 0, 200, 200);\n+            ig.setColor(alphagreen);\n+            ig.fillRect(25, 25, 150, 150);\n+            ig.setColor(alphablue);\n+            ig.fillRect(75, 75, 125, 125);\n+            g.drawImage(bimg, 10, 25, this);\n+            ig.dispose();\n+\n+            GradientPaint gp =\n+                    new GradientPaint(10.0f, 10.0f, alphablue, 210.0f, 210.0f, alphared, true);\n+\n+            Graphics2D g2 = (Graphics2D) g;\n+            g2.setPaint(gp);\n+            g2.fillRect(10, 240, 200, 200);\n+        }\n+\n+        @Override\n+        public Dimension getPreferredSize() {\n+            return new Dimension(500, 500);\n+        }\n@@ -150,3 +149,0 @@\n-\n- }\n-\n@@ -154,115 +150,0 @@\n-\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/raster\/RasterTest.java","additions":107,"deletions":226,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -365,1 +365,1 @@\n-        File tmpFile = File.createTempFile(CHECK_PERMISSION_TEST, null);\n+        File tmpFile = File.createTempFile(CHECK_PERMISSION_TEST, null, new File(\".\"));\n@@ -371,1 +371,1 @@\n-        tmpFile = File.createTempFile(CHECK_PERMISSION_TEST, null, null);\n+        tmpFile = File.createTempFile(CHECK_PERMISSION_TEST, null, new File(\".\"));\n","filename":"test\/jdk\/java\/io\/File\/CheckPermission.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,4 +49,6 @@\n-        try (BufferedWriter writer =\n-            Files.newBufferedWriter(tmp, Charset.defaultCharset())) {\n-            for (int i = 0; i < SIZE; i++) {\n-                writer.write('1');\n+        try {\n+            try (BufferedWriter writer =\n+                         Files.newBufferedWriter(tmp, Charset.defaultCharset())) {\n+                for (int i = 0; i < SIZE; i++) {\n+                    writer.write('1');\n+                }\n@@ -54,1 +56,0 @@\n-        }\n@@ -56,5 +57,13 @@\n-        File tempFile = tmp.toFile();\n-        try (FileInputStream fis = new FileInputStream(tempFile)) {\n-            if (tempFile.length() != SIZE) {\n-                throw new RuntimeException(\"unexpected file size = \"\n-                                           + tempFile.length());\n+            File tempFile = tmp.toFile();\n+            try (FileInputStream fis = new FileInputStream(tempFile)) {\n+                if (tempFile.length() != SIZE) {\n+                    throw new RuntimeException(\"unexpected file size = \"\n+                            + tempFile.length());\n+                }\n+                long space = skipBytes(fis, SKIP, SIZE);\n+                space = skipBytes(fis, NEGATIVE_SKIP, space);\n+                space = skipBytes(fis, SKIP, space);\n+                space = skipBytes(fis, SKIP, space);\n+                space = skipBytes(fis, SKIP, space);\n+                space = skipBytes(fis, NEGATIVE_SKIP, space);\n+                space = skipBytes(fis, NEGATIVE_SKIP, space);\n@@ -62,7 +71,2 @@\n-            long space = skipBytes(fis, SKIP, SIZE);\n-            space = skipBytes(fis, NEGATIVE_SKIP, space);\n-            space = skipBytes(fis, SKIP, space);\n-            space = skipBytes(fis, SKIP, space);\n-            space = skipBytes(fis, SKIP, space);\n-            space = skipBytes(fis, NEGATIVE_SKIP, space);\n-            space = skipBytes(fis, NEGATIVE_SKIP, space);\n+        } finally {\n+            Files.deleteIfExists(tmp);\n@@ -70,1 +74,0 @@\n-        Files.deleteIfExists(tmp);\n","filename":"test\/jdk\/java\/io\/FileInputStream\/NegativeAvailable.java","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -196,0 +196,1 @@\n+        \"\\uD835\\uDFD9e\\uD835\\uDFD9\", \/\/ 1e1 in Mathematical Alphanumeric Symbols\n","filename":"test\/jdk\/java\/lang\/Double\/ParseDouble.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -204,1 +204,2 @@\n-        \"\\u0967e\\u0967\" \/\/ 1e1 in Devanagari digits\n+        \"\\u0967e\\u0967\", \/\/ 1e1 in Devanagari digits\n+        \"\\uD835\\uDFD9e\\uD835\\uDFD9\" \/\/ 1e1 in Mathematical Alphanumeric Symbols\n","filename":"test\/jdk\/java\/lang\/Float\/ParseFloat.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,29 @@\n+\n+    \/*\n+     * Test that UTF-8 of too large strings throws OOME, (not NegativeArraySizeException).\n+     *\/\n+    @Test\n+    public void testMaxUTF8_UTF16Encode() {\n+        String s = \"\\uFFFF\";\n+        final byte[] bytes1 = s.getBytes(StandardCharsets.UTF_8);\n+        assertEquals(3, bytes1.length, \"UTF_8 encoded length of 0xffff\");\n+\n+        int min = Integer.MAX_VALUE \/ bytes1.length - 1;\n+        int max = min + 3;\n+\n+        \/\/ String of size min can be UTF_8 encoded.\n+        System.out.println(\"testing size: \" + min);\n+        String s1 = s.repeat(min);\n+        byte[] bytes = s1.getBytes(StandardCharsets.UTF_8);\n+        int remaining = Integer.MAX_VALUE - bytes.length;\n+        assertTrue(remaining >= bytes1.length, \"remainder too large: \" + remaining);\n+\n+        \/\/ Strings of size min+1...min+2, throw OOME\n+        \/\/ The resulting byte array would exceed implementation limits\n+        for (int count = min + 1; count < max; count++) {\n+            System.out.println(\"testing size: \" + count);\n+            final String s2 = s.repeat(count);\n+            OutOfMemoryError ex = assertThrows(OutOfMemoryError.class, () -> s2.getBytes(StandardCharsets.UTF_8));\n+            ex.printStackTrace();\n+        };\n+    }\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/MaxSizeUTF16String.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8315575\n+ * @bug 8315575 8328137\n@@ -32,0 +32,1 @@\n+ * @run main\/othervm -javaagent:retransformAgent.jar -XX:+PreserveAllAnnotations -Xlog:redefine+class=trace RetransformRecordAnnotation\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformRecordAnnotation.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,0 +262,10 @@\n+        \/\/ verify that the default HEAD() method implementation in HttpRequest.Builder\n+        \/\/ interface works as expected\n+        HttpRequest defaultHeadReq = new NotOverriddenHEADImpl().HEAD().uri(TEST_URI).build();\n+        String actualMethod = defaultHeadReq.method();\n+        if (!actualMethod.equals(\"HEAD\")) {\n+            throw new AssertionError(\"failed: expected HEAD method but got method: \" + actualMethod);\n+        }\n+        if (defaultHeadReq.bodyPublisher().isEmpty()) {\n+            throw new AssertionError(\"failed: missing bodyPublisher on HEAD request\");\n+        }\n@@ -370,0 +380,75 @@\n+\n+    \/\/ doesn't override the default HEAD() method\n+    private static final class NotOverriddenHEADImpl implements HttpRequest.Builder {\n+        private final HttpRequest.Builder underlying = HttpRequest.newBuilder();\n+\n+        @Override\n+        public HttpRequest.Builder uri(URI uri) {\n+            return this.underlying.uri(uri);\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder expectContinue(boolean enable) {\n+            return this.underlying.expectContinue(enable);\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder version(HttpClient.Version version) {\n+            return this.underlying.version(version);\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder header(String name, String value) {\n+            return this.underlying.header(name, value);\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder headers(String... headers) {\n+            return this.underlying.headers(headers);\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder timeout(Duration duration) {\n+            return this.underlying.timeout(duration);\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder setHeader(String name, String value) {\n+            return this.underlying.setHeader(name, value);\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder GET() {\n+            return this.underlying.GET();\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder POST(HttpRequest.BodyPublisher bodyPublisher) {\n+            return this.underlying.POST(bodyPublisher);\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder PUT(HttpRequest.BodyPublisher bodyPublisher) {\n+            return this.underlying.PUT(bodyPublisher);\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder DELETE() {\n+            return this.underlying.DELETE();\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder method(String method, HttpRequest.BodyPublisher bodyPublisher) {\n+            return this.underlying.method(method, bodyPublisher);\n+        }\n+\n+        @Override\n+        public HttpRequest build() {\n+            return this.underlying.build();\n+        }\n+\n+        @Override\n+        public HttpRequest.Builder copy() {\n+            return this.underlying.copy();\n+        }\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBuilderTest.java","additions":86,"deletions":1,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,2 +162,1 @@\n-            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n-            UnixDomainSocketAddress usa =  UnixDomainSocketAddress.of(\"with space\"); \/\/ relative to CWD\n+            UnixDomainSocketAddress usa = UnixDomainSocketAddress.of(\"with space\");\n@@ -165,4 +164,9 @@\n-            server.bind(usa);\n-            client = SocketChannel.open(usa);\n-            Files.delete(usa.getPath());\n-            assertAddress(client.getRemoteAddress(), usa, \"address\");\n+            try {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                \/\/ relative to CWD\n+                server.bind(usa);\n+                client = SocketChannel.open(usa);\n+                assertAddress(client.getRemoteAddress(), usa, \"address\");\n+            } finally {\n+                Files.deleteIfExists(usa.getPath());\n+            }\n@@ -188,6 +192,13 @@\n-            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n-            server.bind(null);\n-            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)server.getLocalAddress();\n-            if (usa.getPath().toString().isEmpty())\n-                throw new RuntimeException(\"expected non zero address length\");\n-            System.out.println(\"Null server address: \" + server.getLocalAddress());\n+            UnixDomainSocketAddress usa = null;\n+            try {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.bind(null);\n+                usa = (UnixDomainSocketAddress) server.getLocalAddress();\n+                if (usa.getPath().toString().isEmpty())\n+                    throw new RuntimeException(\"expected non zero address length\");\n+                System.out.println(\"Null server address: \" + server.getLocalAddress());\n+            } finally {\n+                if (usa != null) {\n+                    Files.deleteIfExists(usa.getPath());\n+                }\n+            }\n@@ -310,6 +321,9 @@\n-            ServerSocketChannel server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n-            server.bind(address);\n-            SocketChannel client = SocketChannel.open(address);\n-            assertAddress(server.getLocalAddress(), address, \"server\");\n-            assertAddress(client.getRemoteAddress(), address, \"client\");\n-            Files.delete(address.getPath());\n+            try {\n+                ServerSocketChannel server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.bind(address);\n+                SocketChannel client = SocketChannel.open(address);\n+                assertAddress(server.getLocalAddress(), address, \"server\");\n+                assertAddress(client.getRemoteAddress(), address, \"client\");\n+            } finally {\n+                Files.deleteIfExists(address.getPath());\n+            }\n@@ -320,7 +334,13 @@\n-            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n-            server.bind(null);\n-            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)server.getLocalAddress();\n-            client = SocketChannel.open(usa);\n-            accept1 = server.accept();\n-            assertAddress(client.getRemoteAddress(), usa, \"server\");\n-            Files.delete(usa.getPath());\n+            UnixDomainSocketAddress usa = null;\n+            try {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.bind(null);\n+                usa = (UnixDomainSocketAddress) server.getLocalAddress();\n+                client = SocketChannel.open(usa);\n+                accept1 = server.accept();\n+                assertAddress(client.getRemoteAddress(), usa, \"server\");\n+            } finally {\n+                if (usa != null) {\n+                    Files.deleteIfExists(usa.getPath());\n+                }\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Bind.java","additions":46,"deletions":26,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -34,0 +35,2 @@\n+import java.nio.file.Files;\n+\n@@ -51,0 +54,1 @@\n+        UnixDomainSocketAddress addr = null;\n@@ -57,0 +61,1 @@\n+            addr = (UnixDomainSocketAddress) serverSocketChannel.getLocalAddress();\n@@ -62,0 +67,4 @@\n+        } finally {\n+            if (addr != null) {\n+                Files.deleteIfExists(addr.getPath());\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/NonBlockingAccept.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.file.FileStore;\n@@ -71,0 +72,2 @@\n+    private static final String TMP_DIR =\n+        System.getProperty(\"copymove.tmp.dir\", \".\");\n@@ -73,1 +76,1 @@\n-        Path currentDir = null;\n+        Path tempFile = null;\n@@ -75,1 +78,1 @@\n-            currentDir = Files.createTempFile(Path.of(\".\"), \"this\", \"that\");\n+            tempFile = Files.createTempFile(Path.of(TMP_DIR), \"this\", \"that\");\n@@ -77,1 +80,1 @@\n-                Files.getFileStore(currentDir).supportsFileAttributeView(\"posix\");\n+                Files.getFileStore(tempFile).supportsFileAttributeView(\"posix\");\n@@ -81,1 +84,1 @@\n-            if (currentDir != null) {\n+            if (tempFile != null) {\n@@ -83,1 +86,1 @@\n-                    Files.delete(currentDir);\n+                    Files.delete(tempFile);\n@@ -94,0 +97,7 @@\n+    private static boolean isSameFileStore(Path p1, Path p2)\n+        throws IOException {\n+        FileStore fs1 = p1.getFileSystem().provider().getFileStore(p1);\n+        FileStore fs2 = p2.getFileSystem().provider().getFileStore(p2);\n+        return fs1.equals(fs2);\n+    }\n+\n@@ -145,1 +155,1 @@\n-        Path currentDir = Path.of(\".\");\n+        Path tmpDir = Path.of(TMP_DIR);\n@@ -149,1 +159,1 @@\n-                    source = Files.createTempFile(currentDir, \"file\", \"dat\");\n+                    source = Files.createTempFile(tmpDir, \"file\", \"dat\");\n@@ -151,1 +161,1 @@\n-                    source = Files.createTempDirectory(currentDir, \"dir\");\n+                    source = Files.createTempDirectory(tmpDir, \"dir\");\n@@ -153,1 +163,1 @@\n-                    linkTarget = Files.createTempFile(currentDir, \"link\", \"target\");\n+                    linkTarget = Files.createTempFile(tmpDir, \"link\", \"target\");\n@@ -167,1 +177,1 @@\n-                target = Files.createTempFile(currentDir, \"file\", \"target\");\n+                target = Files.createTempFile(tmpDir, \"file\", \"target\");\n@@ -196,1 +206,5 @@\n-                    Files.move(source, target, options);\n+                    try {\n+                        Files.move(source, target, options);\n+                    } catch (AccessDeniedException ade) {\n+                        assertTrue(mode.charAt(0) != 'r');\n+                    }\n@@ -216,1 +230,14 @@\n-                        assertTrue(mode.charAt(1) != 'w');\n+                        Path other = target.getParent();\n+                        if (other == null)\n+                            other = Path.of(System.getProperty(\"user.dir\"));\n+                        if (isSameFileStore(source, other)) {\n+                            \/\/ directories on same store should be renamed\n+                            assertTrue(mode.charAt(1) != 'w');\n+                        } else {\n+                            \/\/ directories on different stores will likely be\n+                            \/\/ moved by a copy which requires read permission\n+                            if (mode.charAt(1) == 'w')\n+                                assertTrue(mode.charAt(0) != 'r');\n+                            else\n+                                assertTrue(mode.charAt(1) != 'w');\n+                        }\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyMoveVariations.java","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @run main\/othervm -Dcom.sun.security.ocsp.useget=foo GetAndPostTests\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/OCSP\/GetAndPostTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.PublicKey;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.CertPathValidatorException;\n+import java.security.cert.CertPathValidatorException.BasicReason;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.security.cert.X509CRL;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.CRLDistributionPointsExtension;\n+import sun.security.x509.CRLExtensions;\n+import sun.security.x509.CRLNumberExtension;\n+import sun.security.x509.DistributionPoint;\n+import sun.security.x509.Extension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.URIName;\n+import sun.security.x509.X500Name;\n+import sun.security.x509.X509CRLEntryImpl;\n+import sun.security.x509.X509CRLImpl;\n+import static sun.security.x509.X509CRLImpl.TBSCertList;\n+import sun.security.testlibrary.CertificateBuilder;\n+\n+\/*\n+ * @test\n+ * @bug 8200566\n+ * @summary Check that CRL validation continues to check other CRLs in\n+ *          CRLDP extension after CRL fetching errors and exhibits same\n+ *          behavior (fails because cert is revoked) whether CRL cache is\n+ *          fresh or stale.\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library ..\/..\/..\/..\/..\/java\/security\/testlibrary\n+ * @build CertificateBuilder CheckAllCRLs\n+ * @run main\/othervm -Dcom.sun.security.enableCRLDP=true CheckAllCRLs\n+ *\/\n+public class CheckAllCRLs {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        CertificateBuilder cb = new CertificateBuilder();\n+\n+        \/\/ Create CA cert\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPair rootKeyPair = kpg.genKeyPair();\n+        X509Certificate rootCert = createCert(cb, \"CN=Root CA\",\n+            rootKeyPair, rootKeyPair, null, \"SHA384withRSA\", true, false);\n+\n+        \/\/ Create EE cert. This EE cert will contain a CRL Distribution\n+        \/\/ Points extension with two DistributionPoints - one will be a HTTP\n+        \/\/ URL to a non-existant HTTP server, and the other will be a File\n+        \/\/ URL to a file containing the CRL.\n+        KeyPair eeKeyPair = kpg.genKeyPair();\n+        X509Certificate eeCert1 = createCert(cb, \"CN=End Entity\",\n+            rootKeyPair, eeKeyPair, rootCert, \"SHA384withRSA\", false, true);\n+\n+        \/\/ Create another EE cert. This EE cert is similar in that it contains\n+        \/\/ a CRL Distribution Points extension but with one DistributionPoint\n+        \/\/ containing 2 GeneralName URLs as above.\n+        X509Certificate eeCert2 = createCert(cb, \"CN=End Entity\",\n+            rootKeyPair, eeKeyPair, rootCert, \"SHA384withRSA\", false, false);\n+\n+        \/\/ Create a CRL with no revoked certificates and store it in a file\n+        X509CRL crl = createCRL(new X500Name(\"CN=Root CA\"), rootKeyPair,\n+            \"SHA384withRSA\");\n+        Files.write(Path.of(\"root.crl\"), crl.getEncoded());\n+\n+        \/\/ Validate path containing eeCert1\n+        System.out.println(\"Validating cert with CRLDP containing one \"\n+            + \"DistributionPoint with 2 entries, the first non-existent\");\n+        validatePath(eeCert1, rootCert);\n+\n+        \/\/ Validate path containing eeCert2\n+        System.out.println(\"Validating cert with CRLDP containing two \"\n+            + \"DistributionPoints with 1 entry each, the first non-existent\");\n+        validatePath(eeCert2, rootCert);\n+    }\n+\n+    private static X509Certificate createCert(CertificateBuilder cb,\n+            String subjectDN, KeyPair issuerKeyPair, KeyPair subjectKeyPair,\n+            X509Certificate issuerCert, String sigAlg, boolean isCA,\n+            boolean twoDPs) throws Exception {\n+        cb.setSubjectName(subjectDN);\n+        cb.setPublicKey(subjectKeyPair.getPublic());\n+        cb.setSerialNumber(new BigInteger(\"1\"));\n+\n+        if (isCA) {\n+            \/\/ Make a 3 year validity starting from 60 days ago\n+            long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(60);\n+            long end = start + TimeUnit.DAYS.toMillis(1085);\n+            cb.setValidity(new Date(start), new Date(end));\n+            cb.addBasicConstraintsExt(true, true, -1);\n+            cb.addKeyUsageExt(new boolean[]\n+                {false, false, false, false, false, true, true, false, false});\n+        } else {\n+            \/\/ Make a 1 year validity starting from 7 days ago\n+            long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);\n+            long end = start + TimeUnit.DAYS.toMillis(365);\n+            cb.setValidity(new Date(start), new Date(end));\n+            cb.addAuthorityKeyIdExt(issuerKeyPair.getPublic());\n+            cb.addKeyUsageExt(new boolean[]\n+                {true, false, false, false, false, false, false, false, false});\n+            cb.addExtendedKeyUsageExt(List.of(\"1.3.6.1.5.5.7.3.1\"));\n+            GeneralName first = new GeneralName(new URIName(\n+                    \"http:\/\/127.0.0.1:48180\/crl\/will\/always\/fail\/root.crl\"));\n+            GeneralName second = new GeneralName(new URIName(\"file:.\/root.crl\"));\n+            if (twoDPs) {\n+                GeneralNames gn1 = new GeneralNames().add(first);\n+                DistributionPoint dp1 = new DistributionPoint(gn1, null, null);\n+                GeneralNames gn2 = new GeneralNames().add(second);\n+                DistributionPoint dp2 = new DistributionPoint(gn2, null, null);\n+                cb.addExtension(new CRLDistributionPointsExtension(List.of(dp1, dp2)));\n+            } else {\n+                GeneralNames gn = new GeneralNames().add(first).add(second);\n+                DistributionPoint dp = new DistributionPoint(gn, null, null);\n+                cb.addExtension(new CRLDistributionPointsExtension(List.of(dp)));\n+            }\n+        }\n+        cb.addSubjectKeyIdExt(subjectKeyPair.getPublic());\n+\n+        \/\/ return signed cert\n+        return cb.build(issuerCert, issuerKeyPair.getPrivate(), sigAlg);\n+    }\n+\n+    private static X509CRL createCRL(X500Name caIssuer, KeyPair caKeyPair,\n+            String sigAlg) throws Exception {\n+\n+        CRLExtensions crlExts = new CRLExtensions();\n+\n+        \/\/ add AuthorityKeyIdentifier extension\n+        KeyIdentifier kid = new KeyIdentifier(caKeyPair.getPublic());\n+        Extension ext = new AuthorityKeyIdentifierExtension(kid, null, null);\n+        crlExts.setExtension(ext.getId(),\n+            new AuthorityKeyIdentifierExtension(kid, null, null));\n+\n+        \/\/ add CRLNumber extension\n+        ext = new CRLNumberExtension(1);\n+        crlExts.setExtension(ext.getId(), ext);\n+\n+        \/\/ revoke cert\n+        X509CRLEntryImpl crlEntry =\n+            new X509CRLEntryImpl(new BigInteger(\"1\"), new Date());\n+\n+        \/\/ Create a 1 year validity CRL starting from 7 days ago\n+        long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);\n+        long end = start + TimeUnit.DAYS.toMillis(365);\n+        TBSCertList tcl = new TBSCertList(caIssuer, new Date(start),\n+            new Date(end), new X509CRLEntryImpl[]{ crlEntry }, crlExts);\n+\n+        \/\/ return signed CRL\n+        return X509CRLImpl.newSigned(tcl, caKeyPair.getPrivate(), sigAlg);\n+    }\n+\n+    private static void validatePath(X509Certificate eeCert,\n+            X509Certificate rootCert) throws Exception {\n+\n+        \/\/ Create certification path and set up PKIXParameters.\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        CertPath cp = cf.generateCertPath(List.of(eeCert));\n+        PKIXParameters pp =\n+            new PKIXParameters(Set.of(new TrustAnchor(rootCert, null)));\n+        pp.setRevocationEnabled(true);\n+\n+        CertPathValidator cpv = CertPathValidator.getInstance(\"PKIX\");\n+\n+        \/\/ Validate path twice in succession, making sure we get consistent\n+        \/\/ results the second time when the CRL cache is fresh.\n+        System.out.println(\"First time validating path\");\n+        validate(cpv, cp, pp);\n+        System.out.println(\"Second time validating path\");\n+        validate(cpv, cp, pp);\n+\n+        \/\/ CRL lookup cache time is 30s. Sleep for 35 seconds to ensure\n+        \/\/ cache is stale, and validate one more time to ensure we get\n+        \/\/ consistent results.\n+        System.out.println(\"Waiting for CRL cache to be cleared\");\n+        Thread.sleep(30500);\n+\n+        System.out.println(\"Third time validating path\");\n+        validate(cpv, cp, pp);\n+    }\n+\n+    private static void validate(CertPathValidator cpv, CertPath cp,\n+            PKIXParameters pp) throws Exception {\n+\n+        try {\n+            cpv.validate(cp, pp);\n+            throw new Exception(\"Validation passed unexpectedly\");\n+        } catch (CertPathValidatorException cpve) {\n+            if (cpve.getReason() != BasicReason.REVOKED) {\n+                throw new Exception(\"Validation failed with unexpected reason\", cpve);\n+            }\n+            System.out.println(\"Validation failed as expected: \" + cpve);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/crlDP\/CheckAllCRLs.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -705,0 +705,3 @@\n+        private final boolean USE_GET =\n+            !System.getProperty(\"com.sun.security.ocsp.useget\", \"\").equals(\"false\");\n+\n@@ -877,0 +880,6 @@\n+                if (USE_GET && length <= 255) {\n+                    \/\/ Received a small POST request. Check that our client code properly\n+                    \/\/ handled the relevant flag. We expect small GET requests, unless\n+                    \/\/ explicitly disabled.\n+                    throw new IOException(\"Should have received small GET, not POST.\");\n+                }\n","filename":"test\/jdk\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8318761\n+ * @bug 8318761 8329118\n@@ -43,0 +43,2 @@\n+\/\/ This test expects an US locale, as this locale provides distinct instances\n+\/\/ for different styles.\n@@ -49,1 +51,1 @@\n-                \"{0,number,compact_short}{1,number,compact_long}\");\n+                \"{0,number,compact_short}{1,number,compact_long}\", Locale.US);\n@@ -65,2 +67,3 @@\n-        assertEquals(new DecimalFormat(\"compact_regular\"),\n-                new MessageFormat(\"{0,number,compact_regular}\").getFormatsByArgumentIndex()[0]);\n+        DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);\n+        assertEquals(new DecimalFormat(\"compact_regular\", symbols),\n+                new MessageFormat(\"{0,number,compact_regular}\", Locale.US).getFormatsByArgumentIndex()[0]);\n@@ -72,1 +75,1 @@\n-        var mFmt = new MessageFormat(\"{0}{1}\");\n+        var mFmt = new MessageFormat(\"{0}{1}\", Locale.US);\n@@ -83,1 +86,1 @@\n-        var mFmt = new MessageFormat(\"{0}\");\n+        var mFmt = new MessageFormat(\"{0}\", Locale.US);\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/CompactSubFormats.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8318761\n+ * @bug 8318761 8329118\n@@ -36,0 +36,1 @@\n+import java.util.Locale;\n@@ -42,0 +43,2 @@\n+\/\/ This test expects an US locale, as this locale provides distinct instances\n+\/\/ for different styles.\n@@ -48,1 +51,1 @@\n-        var mFmt = new MessageFormat(\"{0,list}{1,list,or}{2,list,unit}\");\n+        var mFmt = new MessageFormat(\"{0,list}{1,list,or}{2,list,unit}\", Locale.US);\n@@ -66,1 +69,1 @@\n-                new MessageFormat(\"{0,list,standard}\"));\n+                new MessageFormat(\"{0,list,standard}\", Locale.US));\n@@ -71,1 +74,1 @@\n-                new MessageFormat(\"{0,listt,or}\"));\n+                new MessageFormat(\"{0,listt,or}\", Locale.US));\n@@ -80,1 +83,1 @@\n-        var mFmt = new MessageFormat(\"{0}{1}{2}\");\n+        var mFmt = new MessageFormat(\"{0}{1}{2}\", Locale.US);\n@@ -93,1 +96,1 @@\n-        var mFmt = new MessageFormat(\"{0}\");\n+        var mFmt = new MessageFormat(\"{0}\", Locale.US);\n@@ -95,1 +98,2 @@\n-                ListFormat.getInstance(mFmt.getLocale(), ListFormat.Type.UNIT, ListFormat.Style.NARROW));\n+                ListFormat.getInstance(mFmt.getLocale(),\n+                        ListFormat.Type.UNIT, ListFormat.Style.NARROW));\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/ListSubFormats.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -249,0 +249,1 @@\n+            testImmutableListMutatorsAlwaysThrow(list);\n@@ -567,0 +568,6 @@\n+    private static void testImmutableListMutatorsAlwaysThrow(List<Integer> c) {\n+        THROWS(UnsupportedOperationException.class,\n+                c::removeFirst,\n+                c::removeLast);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,3 @@\n+ * @comment The test launches several processes and in the presence of -Xcomp it's too slow\n+ *          and thus causes timeouts\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/jdk\/java\/util\/Properties\/StoreReproducibilityTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,0 +82,3 @@\n+            ClassLoader preexistingContextClassLoader =\n+                    currentThread.getContextClassLoader();\n+\n@@ -98,0 +101,5 @@\n+            else {\n+                currentThread.setContextClassLoader(classLoaderDistinctFromSystemClassLoader);\n+                assertSame(currentThread.getContextClassLoader(), classLoaderDistinctFromSystemClassLoader);\n+                currentThread.setContextClassLoader(preexistingContextClassLoader);\n+            }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool9Test.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -48,0 +50,1 @@\n+ * @library \/test\/lib\n@@ -53,13 +56,13 @@\n-        Path path = Files.createTempFile(\"bad\", \".zip\");\n-        try (OutputStream os = Files.newOutputStream(path);\n-                ZipOutputStream zos = new ZipOutputStream(os)) {\n-            ZipEntry e = new ZipEntry(\"x\");\n-            zos.putNextEntry(e);\n-            zos.write((int) 'x');\n-        }\n-        int len = (int) Files.size(path);\n-        byte[] data = new byte[len];\n-        try (InputStream is = Files.newInputStream(path)) {\n-            is.read(data);\n-        }\n-        Files.delete(path);\n+        Path path = Utils.createTempFile(\"bad\", \".zip\");\n+        try {\n+            try (OutputStream os = Files.newOutputStream(path);\n+                 ZipOutputStream zos = new ZipOutputStream(os)) {\n+                ZipEntry e = new ZipEntry(\"x\");\n+                zos.putNextEntry(e);\n+                zos.write((int) 'x');\n+            }\n+            int len = (int) Files.size(path);\n+            byte[] data = new byte[len];\n+            try (InputStream is = Files.newInputStream(path)) {\n+                is.read(data);\n+            }\n@@ -67,11 +70,14 @@\n-        \/\/ year, month, day are zero\n-        testDate(data.clone(), 0, LocalDate.of(1979, 11, 30).atStartOfDay());\n-        \/\/ only year is zero\n-        testDate(data.clone(), 0 << 25 | 4 << 21 | 5 << 16, LocalDate.of(1980, 4, 5).atStartOfDay());\n-        \/\/ month is greater than 12\n-        testDate(data.clone(), 0 << 25 | 13 << 21 | 1 << 16, LocalDate.of(1981, 1, 1).atStartOfDay());\n-        \/\/ 30th of February\n-        testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16, LocalDate.of(1980, 3, 1).atStartOfDay());\n-        \/\/ 30th of February, 24:60:60\n-        testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16 | 24 << 11 | 60 << 5 | 60 >> 1,\n-                LocalDateTime.of(1980, 3, 2, 1, 1, 0));\n+            \/\/ year, month, day are zero\n+            testDate(data.clone(), 0, LocalDate.of(1979, 11, 30).atStartOfDay());\n+            \/\/ only year is zero\n+            testDate(data.clone(), 0 << 25 | 4 << 21 | 5 << 16, LocalDate.of(1980, 4, 5).atStartOfDay());\n+            \/\/ month is greater than 12\n+            testDate(data.clone(), 0 << 25 | 13 << 21 | 1 << 16, LocalDate.of(1981, 1, 1).atStartOfDay());\n+            \/\/ 30th of February\n+            testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16, LocalDate.of(1980, 3, 1).atStartOfDay());\n+            \/\/ 30th of February, 24:60:60\n+            testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16 | 24 << 11 | 60 << 5 | 60 >> 1,\n+                    LocalDateTime.of(1980, 3, 2, 1, 1, 0));\n+        } finally {\n+            Files.delete(path);\n+        }\n@@ -89,1 +95,1 @@\n-        Path path = Files.createTempFile(\"out\", \".zip\");\n+        Path path = Utils.createTempFile(\"out\", \".zip\");\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZeroDate.java","additions":32,"deletions":26,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8326666\n+ * @summary Test that Subject Delegation is removed.\n+ * @modules java.management.rmi\n+ *          java.management\/com.sun.jmx.remote.security\n+ * @run main\/othervm RemovedSubjectDelegation\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.rmi.RemoteException;\n+import java.rmi.registry.LocateRegistry;\n+import java.rmi.registry.Registry;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.management.MBeanServer;\n+import javax.management.MBeanServerConnection;\n+import javax.management.remote.JMXConnector;\n+import javax.management.remote.JMXConnectorFactory;\n+import javax.management.remote.JMXConnectorServer;\n+import javax.management.remote.JMXConnectorServerFactory;\n+import javax.management.remote.JMXPrincipal;\n+import javax.management.remote.JMXServiceURL;\n+import javax.security.auth.Subject;\n+\n+public class RemovedSubjectDelegation {\n+\n+    public static void main(String[] args) throws Exception {\n+        JMXConnectorServer jmxcs = null;\n+        JMXConnector jmxc = null;\n+        try {\n+            \/\/ Create an RMI registry\n+            \/\/\n+            System.out.println(\"Start RMI registry...\");\n+            Registry reg = null;\n+            int port = 5900;\n+            while (port++ < 5920) {\n+                try {\n+                    reg = LocateRegistry.createRegistry(port);\n+                    System.out.println(\"RMI registry running on port \" + port);\n+                    break;\n+                } catch (RemoteException e) {\n+                    \/\/ Failed to create RMI registry...\n+                    System.out.println(\"Failed to create RMI registry \" +\n+                                       \"on port \" + port);\n+                }\n+            }\n+            if (reg == null) {\n+                throw new RuntimeException(\"Failed to create RMI registry.\");\n+            }\n+            \/\/ Instantiate the MBean server\n+            \/\/\n+            System.out.println(\"Create the MBean server\");\n+            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n+            \/\/ Create an RMI connector server\n+            \/\/\n+            System.out.println(\"Create an RMI connector server\");\n+            JMXServiceURL url = new JMXServiceURL(\"rmi\", null, 0);\n+            HashMap env = new HashMap();\n+            jmxcs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);\n+            jmxcs.start();\n+            \/\/ Create an RMI connector client\n+            \/\/\n+            System.out.println(\"Create an RMI connector client\");\n+            \/\/ Not setting env with \"jmx.remote.credentials\", should not get as far as verifying:\n+            jmxc = JMXConnectorFactory.connect(jmxcs.getAddress());\n+            Subject delegationSubject =\n+                new Subject(true,\n+                            Collections.singleton(new JMXPrincipal(\"delegate\")),\n+                            Collections.EMPTY_SET,\n+                            Collections.EMPTY_SET);\n+\n+            MBeanServerConnection mbsc = null;\n+            try {\n+                mbsc = jmxc.getMBeanServerConnection(delegationSubject);\n+                throw new RuntimeException(\"FAIL: delegationSubject was accepted. mbsc=\" + mbsc);\n+            } catch (UnsupportedOperationException e) {\n+                System.out.println(\"PASS: \" + e);\n+            }\n+        } catch (Exception e) {\n+            System.out.println(\"Unexpected exception caught = \" + e);\n+            e.printStackTrace();\n+            throw e;\n+        } finally {\n+            if (jmxc != null)\n+                jmxc.close();\n+            if (jmxcs != null)\n+                jmxcs.stop();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/RemovedSubjectDelegation.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,1 +174,1 @@\n-                    \/\/ Error: Exception thrown by the agent : java.rmi.server.ExportException: Port already in use: 46481; nested exception is:\n+                    \/\/ Error: Exception thrown by the agent: java.rmi.server.ExportException: Port already in use: 46481; nested exception is:\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/connection\/DefaultAgentFilterTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.management.ManagementFactory;\n-import java.lang.ref.WeakReference;\n-import java.lang.reflect.Field;\n-import java.util.Collections;\n-import java.util.Map;\n-import javax.management.MBeanServer;\n-import javax.management.MBeanServerConnection;\n-import javax.management.remote.JMXConnector;\n-import javax.management.remote.JMXConnectorFactory;\n-import javax.management.remote.JMXConnectorServer;\n-import javax.management.remote.JMXConnectorServerFactory;\n-import javax.management.remote.JMXPrincipal;\n-import javax.management.remote.JMXServiceURL;\n-import javax.management.remote.rmi.RMIConnector;\n-import javax.security.auth.Subject;\n-\n-\/*\n- * @test\n- * @bug 6566891\n- * @summary Check no memory leak on RMIConnector's rmbscMap\n- * @author Shanliang JIANG\n- * @modules java.management.rmi\/javax.management.remote.rmi:open\n- * @run clean RMIConnectorInternalMapTest\n- * @run build RMIConnectorInternalMapTest\n- * @run main RMIConnectorInternalMapTest\n- *\/\n-\n-public class RMIConnectorInternalMapTest {\n-    public static void main(String[] args) throws Exception {\n-        System.out.println(\"---RMIConnectorInternalMapTest starting...\");\n-\n-        JMXConnectorServer connectorServer = null;\n-        JMXConnector connectorClient = null;\n-\n-        try {\n-            MBeanServer mserver = ManagementFactory.getPlatformMBeanServer();\n-            JMXServiceURL serverURL = new JMXServiceURL(\"rmi\", \"localhost\", 0);\n-            connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(serverURL, null, mserver);\n-            connectorServer.start();\n-\n-            JMXServiceURL serverAddr = connectorServer.getAddress();\n-            connectorClient = JMXConnectorFactory.connect(serverAddr, null);\n-            connectorClient.connect();\n-\n-            Field rmbscMapField = RMIConnector.class.getDeclaredField(\"rmbscMap\");\n-            rmbscMapField.setAccessible(true);\n-            Map<Subject, WeakReference<MBeanServerConnection>> map =\n-                    (Map<Subject, WeakReference<MBeanServerConnection>>) rmbscMapField.get(connectorClient);\n-            if (map != null && !map.isEmpty()) { \/\/ failed\n-                throw new RuntimeException(\"RMIConnector's rmbscMap must be empty at the initial time.\");\n-            }\n-\n-            Subject delegationSubject =\n-                    new Subject(true,\n-                    Collections.singleton(new JMXPrincipal(\"delegate\")),\n-                    Collections.EMPTY_SET,\n-                    Collections.EMPTY_SET);\n-            MBeanServerConnection mbsc1 =\n-                    connectorClient.getMBeanServerConnection(delegationSubject);\n-            MBeanServerConnection mbsc2 =\n-                    connectorClient.getMBeanServerConnection(delegationSubject);\n-\n-            if (mbsc1 == null) {\n-                throw new RuntimeException(\"Got null connection.\");\n-            }\n-            if (mbsc1 != mbsc2) {\n-                throw new RuntimeException(\"Not got same connection with a same subject.\");\n-            }\n-\n-            map = (Map<Subject, WeakReference<MBeanServerConnection>>) rmbscMapField.get(connectorClient);\n-            if (map == null || map.isEmpty()) { \/\/ failed\n-                throw new RuntimeException(\"RMIConnector's rmbscMap has wrong size \"\n-                        + \"after creating a delegated connection.\");\n-            }\n-\n-            delegationSubject = null;\n-            mbsc1 = null;\n-            mbsc2 = null;\n-\n-            int i = 0;\n-            while (!map.isEmpty() && i++ < 60) {\n-                System.gc();\n-                Thread.sleep(100);\n-            }\n-            System.out.println(\"---GC times: \" + i);\n-\n-            if (!map.isEmpty()) {\n-                throw new RuntimeException(\"Failed to clean RMIConnector's rmbscMap\");\n-            } else {\n-                System.out.println(\"---RMIConnectorInternalMapTest: PASSED!\");\n-            }\n-        } finally {\n-            try {\n-                connectorClient.close();\n-                connectorServer.stop();\n-            } catch (Exception e) {\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/connection\/RMIConnectorInternalMapTest.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-        assertTrue(\"No connections in new connector server\", rmiServer.connections.isEmpty());\n+        assertTrue(\"Expected no connections in new connector server\", rmiServer.connections.isEmpty());\n@@ -82,1 +82,1 @@\n-        assertTrue(\"One connection on server after client connect\", rmiServer.connections.size() == 1);\n+        assertTrue(\"Expected one connection on server after client connect\", rmiServer.connections.size() == 1);\n@@ -91,1 +91,1 @@\n-        assertTrue(\"Server listenerMap initially empty\", mapWithoutKey(listenerMap, delegateName).isEmpty());\n+        assertTrue(\"Expected server listenerMap initially empty\", mapWithoutKey(listenerMap, delegateName).isEmpty());\n@@ -107,1 +107,1 @@\n-        assertTrue(\"One entry in listenerMap for two listeners on same MBean\", mapWithoutKey(listenerMap, delegateName).size() == 1);\n+        assertTrue(\"Expected one entry in listenerMap for two listeners on same MBean\", mapWithoutKey(listenerMap, delegateName).size() == 1);\n@@ -109,1 +109,1 @@\n-        assertTrue(\"Set in listenerMap for MBean has two elements\", set != null && set.size() == 2);\n+        assertTrue(\"Expected Set in listenerMap for MBean to have two elements\", set != null && set.size() == 2);\n@@ -111,2 +111,2 @@\n-        assertTrue(\"Initial value of count1 == 0\", count1Val.get() == 0);\n-        assertTrue(\"Initial value of count2 == 0\", count2Val.get() == 0);\n+        assertTrue(\"Initial value of count1 should be 0\", count1Val.get() == 0);\n+        assertTrue(\"Initial value of count2 should be 0\", count2Val.get() == 0);\n@@ -122,2 +122,2 @@\n-        assertTrue(\"New value of count1 == 1\", count1Val.get() == 1);\n-        assertTrue(\"Initial value of count2 == 1\", count2Val.get() == 1);\n+        assertTrue(\"Value of count1 expected 1, got \" + count1Val.get(), count1Val.get() == 1);\n+        assertTrue(\"Value of count2 expected 1, got \" + count2Val.get(), count2Val.get() == 1);\n@@ -149,2 +149,2 @@\n-        assertTrue(\"New value of count1 == 1\", count1Val.get() == 1);\n-        assertTrue(\"Initial value of count2 == 1\", count2Val.get() == 1);\n+        assertTrue(\"Value of count1 expected 1, got \" + count1Val.get(), count1Val.get() == 1);\n+        assertTrue(\"Value of count2 expected 1, got \" + count2Val.get(), count2Val.get() == 1);\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/notif\/DeadListenerTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Simple definition of a standard MBean, named \"SimpleStandard\".\n- *\n- * The \"SimpleStandard\" standard MBean shows how to expose attributes and\n- * operations for management by implementing its corresponding\n- * \"SimpleStandardMBean\" management interface.\n- *\n- * This MBean has two attributes and one operation exposed\n- * for management by a JMX agent:\n- *      - the read\/write \"State\" attribute,\n- *      - the read only \"NbChanges\" attribute,\n- *      - the \"reset()\" operation.\n- *\n- * This object also has one property and one method not exposed\n- * for management by a JMX agent:\n- *      - the \"NbResets\" property,\n- *      - the \"getNbResets()\" method.\n- *\/\n-\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.Principal;\n-import java.util.Set;\n-import javax.management.AttributeChangeNotification;\n-import javax.management.NotificationBroadcasterSupport;\n-import javax.management.remote.JMXPrincipal;\n-import javax.security.auth.Subject;\n-\n-public class SimpleStandard\n-    extends NotificationBroadcasterSupport\n-    implements SimpleStandardMBean {\n-\n-    \/*\n-     * -----------------------------------------------------\n-     * CONSTRUCTORS\n-     * -----------------------------------------------------\n-     *\/\n-\n-    public SimpleStandard(String principalName) {\n-        this.principalName = principalName;\n-    }\n-\n-    \/*\n-     * -----------------------------------------------------\n-     * IMPLEMENTATION OF THE SimpleStandardMBean INTERFACE\n-     * -----------------------------------------------------\n-     *\/\n-\n-    \/**\n-     * Getter: get the \"State\" attribute of the \"SimpleStandard\" standard MBean.\n-     *\n-     * @return the current value of the \"State\" attribute.\n-     *\/\n-    public String getState() {\n-        checkSubject(\"getState\");\n-        return state;\n-    }\n-\n-    \/**\n-     * Setter: set the \"State\" attribute of the \"SimpleStandard\" standard MBean.\n-     *\n-     * @param <VAR>s<\/VAR> the new value of the \"State\" attribute.\n-     *\/\n-    public void setState(String s) {\n-        checkSubject(\"setState\");\n-        state = s;\n-        nbChanges++;\n-    }\n-\n-    \/**\n-     * Getter: get the \"NbChanges\" attribute of the \"SimpleStandard\" standard\n-     * MBean.\n-     *\n-     * @return the current value of the \"NbChanges\" attribute.\n-     *\/\n-    public int getNbChanges() {\n-        checkSubject(\"getNbChanges\");\n-        return nbChanges;\n-    }\n-\n-    \/**\n-     * Operation: reset to their initial values the \"State\" and \"NbChanges\"\n-     * attributes of the \"SimpleStandard\" standard MBean.\n-     *\/\n-    public void reset() {\n-        checkSubject(\"reset\");\n-        AttributeChangeNotification acn =\n-            new AttributeChangeNotification(this,\n-                                            0,\n-                                            0,\n-                                            \"NbChanges reset\",\n-                                            \"NbChanges\",\n-                                            \"Integer\",\n-                                            new Integer(nbChanges),\n-                                            new Integer(0));\n-        state = \"initial state\";\n-        nbChanges = 0;\n-        nbResets++;\n-        sendNotification(acn);\n-    }\n-\n-    \/*\n-     * -----------------------------------------------------\n-     * METHOD NOT EXPOSED FOR MANAGEMENT BY A JMX AGENT\n-     * -----------------------------------------------------\n-     *\/\n-\n-    \/**\n-     * Return the \"NbResets\" property.\n-     * This method is not a Getter in the JMX sense because\n-     * it is not exposed in the \"SimpleStandardMBean\" interface.\n-     *\n-     * @return the current value of the \"NbResets\" property.\n-     *\/\n-    public int getNbResets() {\n-        return nbResets;\n-    }\n-\n-    \/*\n-     * ---------------\n-     * PRIVATE METHODS\n-     * ---------------\n-     *\/\n-\n-    \/**\n-     * Check that the principal contained in the Subject is of\n-     * type JMXPrincipal and refers to the principalName identity.\n-     *\/\n-    private void checkSubject(String op) {\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n-        Set principals = subject.getPrincipals();\n-        Principal principal = (Principal) principals.iterator().next();\n-        if (!(principal instanceof JMXPrincipal))\n-            throw new SecurityException(op+\": Authenticated subject contains \" +\n-                                        \"invalid principal type = \" +\n-                                        principal.getClass().getName());\n-        String identity = principal.getName();\n-        if (!identity.equals(principalName))\n-            throw new SecurityException(op+\": Authenticated subject contains \" +\n-                                        \"invalid principal name = \" + identity);\n-    }\n-\n-    \/*\n-     * -----------------------------------------------------\n-     * ATTRIBUTES ACCESSIBLE FOR MANAGEMENT BY A JMX AGENT\n-     * -----------------------------------------------------\n-     *\/\n-\n-    private String state = \"initial state\";\n-    private int nbChanges = 0;\n-\n-    \/*\n-     * -----------------------------------------------------\n-     * PROPERTY NOT ACCESSIBLE FOR MANAGEMENT BY A JMX AGENT\n-     * -----------------------------------------------------\n-     *\/\n-\n-    private int nbResets = 0;\n-    private String principalName;\n-}\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/SimpleStandard.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This is the management interface explicitly defined for the\n- * \"SimpleStandard\" standard MBean.\n- * The \"SimpleStandard\" standard MBean implements this interface\n- * in order to be manageable through a JMX agent.\n- *\n- * The \"SimpleStandardMBean\" interface shows how to expose for management:\n- * - a read\/write attribute (named \"State\") through its getter and setter\n- *   methods,\n- * - a read-only attribute (named \"NbChanges\") through its getter method,\n- * - an operation (named \"reset\").\n- *\/\n-public interface SimpleStandardMBean {\n-\n-    \/**\n-     * Getter: set the \"State\" attribute of the \"SimpleStandard\" standard\n-     * MBean.\n-     *\n-     * @return the current value of the \"State\" attribute.\n-     *\/\n-    public String getState();\n-\n-    \/**\n-     * Setter: set the \"State\" attribute of the \"SimpleStandard\" standard\n-     * MBean.\n-     *\n-     * @param <VAR>s<\/VAR> the new value of the \"State\" attribute.\n-     *\/\n-    public void setState(String s);\n-\n-    \/**\n-     * Getter: get the \"NbChanges\" attribute of the \"SimpleStandard\" standard\n-     * MBean.\n-     *\n-     * @return the current value of the \"NbChanges\" attribute.\n-     *\/\n-    public int getNbChanges();\n-\n-    \/**\n-     * Operation: reset to their initial values the \"State\" and \"NbChanges\"\n-     * attributes of the \"SimpleStandard\" standard MBean.\n-     *\/\n-    public void reset();\n-}\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/SimpleStandardMBean.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6261831\n- * @summary Tests the use of the subject delegation feature in the\n- *          RMI connector\n- * @author Luis-Miguel Alventosa\n- * @modules java.management.rmi\n- *          java.management\/com.sun.jmx.remote.security\n- * @run clean SubjectDelegation1Test SimpleStandard SimpleStandardMBean\n- * @run build SubjectDelegation1Test SimpleStandard SimpleStandardMBean\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy11 ok\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy12 ko\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy13 ko\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy14 ko\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy15 ok\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy16 ko\n- *\/\n-\n-import com.sun.jmx.remote.security.JMXPluggableAuthenticator;\n-import java.io.File;\n-import java.lang.management.ManagementFactory;\n-import java.rmi.RemoteException;\n-import java.rmi.registry.LocateRegistry;\n-import java.rmi.registry.Registry;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Properties;\n-import javax.management.Attribute;\n-import javax.management.MBeanServer;\n-import javax.management.MBeanServerConnection;\n-import javax.management.Notification;\n-import javax.management.NotificationListener;\n-import javax.management.ObjectName;\n-import javax.management.remote.JMXConnector;\n-import javax.management.remote.JMXConnectorFactory;\n-import javax.management.remote.JMXConnectorServer;\n-import javax.management.remote.JMXConnectorServerFactory;\n-import javax.management.remote.JMXPrincipal;\n-import javax.management.remote.JMXServiceURL;\n-import javax.security.auth.Subject;\n-\n-public class SubjectDelegation1Test {\n-\n-    public static void main(String[] args) throws Exception {\n-        String policyFile = args[0];\n-        String testResult = args[1];\n-        System.out.println(\"Policy file = \" + policyFile);\n-        System.out.println(\"Expected test result = \" + testResult);\n-        JMXConnectorServer jmxcs = null;\n-        JMXConnector jmxc = null;\n-        try {\n-            \/\/ Create an RMI registry\n-            \/\/\n-            System.out.println(\"Start RMI registry...\");\n-            Registry reg = null;\n-            int port = 5860;\n-            while (port++ < 5880) {\n-                try {\n-                    reg = LocateRegistry.createRegistry(port);\n-                    System.out.println(\"RMI registry running on port \" + port);\n-                    break;\n-                } catch (RemoteException e) {\n-                    \/\/ Failed to create RMI registry...\n-                    System.out.println(\"Failed to create RMI registry \" +\n-                                       \"on port \" + port);\n-                }\n-            }\n-            if (reg == null) {\n-                System.exit(1);\n-            }\n-            \/\/ Set the default password file\n-            \/\/\n-            final String passwordFile = System.getProperty(\"test.src\") +\n-                File.separator + \"jmxremote.password\";\n-            System.out.println(\"Password file = \" + passwordFile);\n-            \/\/ Set policy file\n-            \/\/\n-            final String policy = System.getProperty(\"test.src\") +\n-                File.separator + policyFile;\n-            System.out.println(\"PolicyFile = \" + policy);\n-            System.setProperty(\"java.security.policy\", policy);\n-            \/\/ Instantiate the MBean server\n-            \/\/\n-            System.out.println(\"Create the MBean server\");\n-            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n-            \/\/ Register the SimpleStandardMBean\n-            \/\/\n-            System.out.println(\"Create SimpleStandard MBean\");\n-            SimpleStandard s = new SimpleStandard(\"delegate\");\n-            mbs.registerMBean(s, new ObjectName(\"MBeans:type=SimpleStandard\"));\n-            \/\/ Create Properties containing the username\/password entries\n-            \/\/\n-            Properties props = new Properties();\n-            props.setProperty(\"jmx.remote.x.password.file\", passwordFile);\n-            \/\/ Initialize environment map to be passed to the connector server\n-            \/\/\n-            System.out.println(\"Initialize environment map\");\n-            HashMap env = new HashMap();\n-            env.put(\"jmx.remote.authenticator\",\n-                    new JMXPluggableAuthenticator(props));\n-            \/\/ Create an RMI connector server\n-            \/\/\n-            System.out.println(\"Create an RMI connector server\");\n-            JMXServiceURL url =\n-                new JMXServiceURL(\"rmi\", null, 0,\n-                                  \"\/jndi\/rmi:\/\/:\" + port + \"\/server\" + port);\n-            jmxcs =\n-                JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);\n-            jmxcs.start();\n-            \/\/ Create an RMI connector client\n-            \/\/\n-            System.out.println(\"Create an RMI connector client\");\n-            HashMap cli_env = new HashMap();\n-            \/\/ These credentials must match those in the default password file\n-            \/\/\n-            String[] credentials = new String[] { \"monitorRole\" , \"QED\" };\n-            cli_env.put(\"jmx.remote.credentials\", credentials);\n-            jmxc = JMXConnectorFactory.connect(url, cli_env);\n-            Subject delegationSubject =\n-                new Subject(true,\n-                            Collections.singleton(new JMXPrincipal(\"delegate\")),\n-                            Collections.EMPTY_SET,\n-                            Collections.EMPTY_SET);\n-            MBeanServerConnection mbsc =\n-                jmxc.getMBeanServerConnection(delegationSubject);\n-            \/\/ Get domains from MBeanServer\n-            \/\/\n-            System.out.println(\"Domains:\");\n-            String domains[] = mbsc.getDomains();\n-            for (int i = 0; i < domains.length; i++) {\n-                System.out.println(\"\\tDomain[\" + i + \"] = \" + domains[i]);\n-            }\n-            \/\/ Get MBean count\n-            \/\/\n-            System.out.println(\"MBean count = \" + mbsc.getMBeanCount());\n-            \/\/ Get State attribute\n-            \/\/\n-            String oldState =\n-                (String) mbsc.getAttribute(\n-                              new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                              \"State\");\n-            System.out.println(\"Old State = \\\"\" + oldState + \"\\\"\");\n-            \/\/ Set State attribute\n-            \/\/\n-            System.out.println(\"Set State to \\\"changed state\\\"\");\n-            mbsc.setAttribute(new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                              new Attribute(\"State\", \"changed state\"));\n-            \/\/ Get State attribute\n-            \/\/\n-            String newState =\n-                (String) mbsc.getAttribute(\n-                              new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                              \"State\");\n-            System.out.println(\"New State = \\\"\" + newState + \"\\\"\");\n-            if (!newState.equals(\"changed state\")) {\n-                System.out.println(\"Invalid State = \\\"\" + newState + \"\\\"\");\n-                System.exit(1);\n-            }\n-            \/\/ Add notification listener on SimpleStandard MBean\n-            \/\/\n-            System.out.println(\"Add notification listener...\");\n-            mbsc.addNotificationListener(\n-                 new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                 new NotificationListener() {\n-                     public void handleNotification(Notification notification,\n-                                                    Object handback) {\n-                         System.out.println(\"Received notification: \" +\n-                                            notification);\n-                     }\n-                 },\n-                 null,\n-                 null);\n-            \/\/ Unregister SimpleStandard MBean\n-            \/\/\n-            System.out.println(\"Unregister SimpleStandard MBean...\");\n-            mbsc.unregisterMBean(new ObjectName(\"MBeans:type=SimpleStandard\"));\n-        } catch (SecurityException e) {\n-            if (testResult.equals(\"ko\")) {\n-                System.out.println(\"Got expected security exception = \" + e);\n-            } else {\n-                System.out.println(\"Got unexpected security exception = \" + e);\n-                e.printStackTrace();\n-                throw e;\n-            }\n-        } catch (Exception e) {\n-            System.out.println(\"Unexpected exception caught = \" + e);\n-            e.printStackTrace();\n-            throw e;\n-        } finally {\n-            \/\/ Close connector client\n-            \/\/\n-            if (jmxc != null)\n-                jmxc.close();\n-            \/\/ Stop connector server\n-            \/\/\n-            if (jmxcs != null)\n-                jmxcs.stop();\n-            \/\/ Say goodbye\n-            \/\/\n-            System.out.println(\"Bye! Bye!\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/SubjectDelegation1Test.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"},{"patch":"@@ -1,218 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6261831\n- * @summary Tests the use of the subject delegation feature on the authenticated\n- *          principals within the RMI connector server's creator codebase.\n- * @author Luis-Miguel Alventosa\n- * @modules java.management.rmi\n- *          java.management\/com.sun.jmx.remote.security\n- * @run clean SubjectDelegation2Test SimpleStandard SimpleStandardMBean\n- * @run build SubjectDelegation2Test SimpleStandard SimpleStandardMBean\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation2Test policy21 ok\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation2Test policy22 ko\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation2Test policy23 ko\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation2Test policy24 ok\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation2Test policy25 ko\n- *\/\n-\n-import com.sun.jmx.remote.security.JMXPluggableAuthenticator;\n-import java.io.File;\n-import java.lang.management.ManagementFactory;\n-import java.rmi.RemoteException;\n-import java.rmi.registry.LocateRegistry;\n-import java.rmi.registry.Registry;\n-import java.util.HashMap;\n-import java.util.Properties;\n-import javax.management.Attribute;\n-import javax.management.MBeanServer;\n-import javax.management.MBeanServerConnection;\n-import javax.management.Notification;\n-import javax.management.NotificationListener;\n-import javax.management.ObjectName;\n-import javax.management.remote.JMXConnector;\n-import javax.management.remote.JMXConnectorFactory;\n-import javax.management.remote.JMXConnectorServer;\n-import javax.management.remote.JMXConnectorServerFactory;\n-import javax.management.remote.JMXServiceURL;\n-\n-public class SubjectDelegation2Test {\n-\n-    public static void main(String[] args) throws Exception {\n-        String policyFile = args[0];\n-        String testResult = args[1];\n-        System.out.println(\"Policy file = \" + policyFile);\n-        System.out.println(\"Expected test result = \" + testResult);\n-        JMXConnectorServer jmxcs = null;\n-        JMXConnector jmxc = null;\n-        try {\n-            \/\/ Create an RMI registry\n-            \/\/\n-            System.out.println(\"Start RMI registry...\");\n-            Registry reg = null;\n-            int port = 5880;\n-            while (port++ < 5900) {\n-                try {\n-                    reg = LocateRegistry.createRegistry(port);\n-                    System.out.println(\"RMI registry running on port \" + port);\n-                    break;\n-                } catch (RemoteException e) {\n-                    \/\/ Failed to create RMI registry...\n-                    System.out.println(\"Failed to create RMI registry \" +\n-                                       \"on port \" + port);\n-                }\n-            }\n-            if (reg == null) {\n-                System.exit(1);\n-            }\n-            \/\/ Set the default password file\n-            \/\/\n-            final String passwordFile = System.getProperty(\"test.src\") +\n-                File.separator + \"jmxremote.password\";\n-            System.out.println(\"Password file = \" + passwordFile);\n-            \/\/ Set policy file\n-            \/\/\n-            final String policy = System.getProperty(\"test.src\") +\n-                File.separator + policyFile;\n-            System.out.println(\"PolicyFile = \" + policy);\n-            System.setProperty(\"java.security.policy\", policy);\n-            \/\/ Instantiate the MBean server\n-            \/\/\n-            System.out.println(\"Create the MBean server\");\n-            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n-            \/\/ Register the SimpleStandardMBean\n-            \/\/\n-            System.out.println(\"Create SimpleStandard MBean\");\n-            SimpleStandard s = new SimpleStandard(\"monitorRole\");\n-            mbs.registerMBean(s, new ObjectName(\"MBeans:type=SimpleStandard\"));\n-            \/\/ Create Properties containing the username\/password entries\n-            \/\/\n-            Properties props = new Properties();\n-            props.setProperty(\"jmx.remote.x.password.file\", passwordFile);\n-            \/\/ Initialize environment map to be passed to the connector server\n-            \/\/\n-            System.out.println(\"Initialize environment map\");\n-            HashMap env = new HashMap();\n-            env.put(\"jmx.remote.authenticator\",\n-                    new JMXPluggableAuthenticator(props));\n-            \/\/ Set Security Manager\n-            \/\/\n-            System.setSecurityManager(new SecurityManager());\n-            \/\/ Create an RMI connector server\n-            \/\/\n-            System.out.println(\"Create an RMI connector server\");\n-            JMXServiceURL url = new JMXServiceURL(\"rmi\", null, 0);\n-\n-            jmxcs =\n-                JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);\n-            jmxcs.start();\n-            \/\/ Create an RMI connector client\n-            \/\/\n-            System.out.println(\"Create an RMI connector client\");\n-            HashMap cli_env = new HashMap();\n-            \/\/ These credentials must match those in the default password file\n-            \/\/\n-            String[] credentials = new String[] { \"monitorRole\" , \"QED\" };\n-            cli_env.put(\"jmx.remote.credentials\", credentials);\n-            jmxc = JMXConnectorFactory.connect(jmxcs.getAddress(), cli_env);\n-            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n-            \/\/ Get domains from MBeanServer\n-            \/\/\n-            System.out.println(\"Domains:\");\n-            String domains[] = mbsc.getDomains();\n-            for (int i = 0; i < domains.length; i++) {\n-                System.out.println(\"\\tDomain[\" + i + \"] = \" + domains[i]);\n-            }\n-            \/\/ Get MBean count\n-            \/\/\n-            System.out.println(\"MBean count = \" + mbsc.getMBeanCount());\n-            \/\/ Get State attribute\n-            \/\/\n-            String oldState =\n-                (String) mbsc.getAttribute(\n-                              new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                              \"State\");\n-            System.out.println(\"Old State = \\\"\" + oldState + \"\\\"\");\n-            \/\/ Set State attribute\n-            \/\/\n-            System.out.println(\"Set State to \\\"changed state\\\"\");\n-            mbsc.setAttribute(new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                              new Attribute(\"State\", \"changed state\"));\n-            \/\/ Get State attribute\n-            \/\/\n-            String newState =\n-                (String) mbsc.getAttribute(\n-                              new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                              \"State\");\n-            System.out.println(\"New State = \\\"\" + newState + \"\\\"\");\n-            if (!newState.equals(\"changed state\")) {\n-                System.out.println(\"Invalid State = \\\"\" + newState + \"\\\"\");\n-                System.exit(1);\n-            }\n-            \/\/ Add notification listener on SimpleStandard MBean\n-            \/\/\n-            System.out.println(\"Add notification listener...\");\n-            mbsc.addNotificationListener(\n-                 new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                 new NotificationListener() {\n-                     public void handleNotification(Notification notification,\n-                                                    Object handback) {\n-                         System.out.println(\"Received notification: \" +\n-                                            notification);\n-                     }\n-                 },\n-                 null,\n-                 null);\n-            \/\/ Unregister SimpleStandard MBean\n-            \/\/\n-            System.out.println(\"Unregister SimpleStandard MBean...\");\n-            mbsc.unregisterMBean(new ObjectName(\"MBeans:type=SimpleStandard\"));\n-        } catch (SecurityException e) {\n-            if (testResult.equals(\"ko\")) {\n-                System.out.println(\"Got expected security exception = \" + e);\n-            } else {\n-                System.out.println(\"Got unexpected security exception = \" + e);\n-                e.printStackTrace();\n-                throw e;\n-            }\n-        } catch (Exception e) {\n-            System.out.println(\"Unexpected exception caught = \" + e);\n-            e.printStackTrace();\n-            throw e;\n-        } finally {\n-            \/\/ Close connector client\n-            \/\/\n-            if (jmxc != null)\n-                jmxc.close();\n-            \/\/ Stop connector server\n-            \/\/\n-            if (jmxcs != null)\n-                jmxcs.stop();\n-            \/\/ Say goodbye\n-            \/\/\n-            System.out.println(\"Bye! Bye!\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/SubjectDelegation2Test.java","additions":0,"deletions":218,"binary":false,"changes":218,"status":"deleted"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6261831\n- * @summary Tests the use of the subject delegation feature on the authenticated\n- *          principals within the RMI connector server's creator codebase with\n- *          subject delegation.\n- * @author Luis-Miguel Alventosa\n- * @modules java.management.rmi\n- *          java.management\/com.sun.jmx.remote.security\n- * @run clean SubjectDelegation3Test SimpleStandard SimpleStandardMBean\n- * @run build SubjectDelegation3Test SimpleStandard SimpleStandardMBean\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation3Test policy31 ok\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation3Test policy32 ko\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation3Test policy33 ko\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation3Test policy34 ok\n- * @run main\/othervm -Djava.security.manager=allow SubjectDelegation3Test policy35 ko\n- *\/\n-\n-import com.sun.jmx.remote.security.JMXPluggableAuthenticator;\n-import java.io.File;\n-import java.lang.management.ManagementFactory;\n-import java.rmi.RemoteException;\n-import java.rmi.registry.LocateRegistry;\n-import java.rmi.registry.Registry;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Properties;\n-import javax.management.Attribute;\n-import javax.management.MBeanServer;\n-import javax.management.MBeanServerConnection;\n-import javax.management.Notification;\n-import javax.management.NotificationListener;\n-import javax.management.ObjectName;\n-import javax.management.remote.JMXConnector;\n-import javax.management.remote.JMXConnectorFactory;\n-import javax.management.remote.JMXConnectorServer;\n-import javax.management.remote.JMXConnectorServerFactory;\n-import javax.management.remote.JMXPrincipal;\n-import javax.management.remote.JMXServiceURL;\n-import javax.security.auth.Subject;\n-\n-public class SubjectDelegation3Test {\n-\n-    public static void main(String[] args) throws Exception {\n-        String policyFile = args[0];\n-        String testResult = args[1];\n-        System.out.println(\"Policy file = \" + policyFile);\n-        System.out.println(\"Expected test result = \" + testResult);\n-        JMXConnectorServer jmxcs = null;\n-        JMXConnector jmxc = null;\n-        try {\n-            \/\/ Create an RMI registry\n-            \/\/\n-            System.out.println(\"Start RMI registry...\");\n-            Registry reg = null;\n-            int port = 5900;\n-            while (port++ < 5920) {\n-                try {\n-                    reg = LocateRegistry.createRegistry(port);\n-                    System.out.println(\"RMI registry running on port \" + port);\n-                    break;\n-                } catch (RemoteException e) {\n-                    \/\/ Failed to create RMI registry...\n-                    System.out.println(\"Failed to create RMI registry \" +\n-                                       \"on port \" + port);\n-                }\n-            }\n-            if (reg == null) {\n-                System.exit(1);\n-            }\n-            \/\/ Set the default password file\n-            \/\/\n-            final String passwordFile = System.getProperty(\"test.src\") +\n-                File.separator + \"jmxremote.password\";\n-            System.out.println(\"Password file = \" + passwordFile);\n-            \/\/ Set policy file\n-            \/\/\n-            final String policy = System.getProperty(\"test.src\") +\n-                File.separator + policyFile;\n-            System.out.println(\"PolicyFile = \" + policy);\n-            System.setProperty(\"java.security.policy\", policy);\n-            \/\/ Instantiate the MBean server\n-            \/\/\n-            System.out.println(\"Create the MBean server\");\n-            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n-            \/\/ Register the SimpleStandardMBean\n-            \/\/\n-            System.out.println(\"Create SimpleStandard MBean\");\n-            SimpleStandard s = new SimpleStandard(\"delegate\");\n-            mbs.registerMBean(s, new ObjectName(\"MBeans:type=SimpleStandard\"));\n-            \/\/ Create Properties containing the username\/password entries\n-            \/\/\n-            Properties props = new Properties();\n-            props.setProperty(\"jmx.remote.x.password.file\", passwordFile);\n-            \/\/ Initialize environment map to be passed to the connector server\n-            \/\/\n-            System.out.println(\"Initialize environment map\");\n-            HashMap env = new HashMap();\n-            env.put(\"jmx.remote.authenticator\",\n-                    new JMXPluggableAuthenticator(props));\n-            \/\/ Set Security Manager\n-            \/\/\n-            System.setSecurityManager(new SecurityManager());\n-            \/\/ Create an RMI connector server\n-            \/\/\n-            System.out.println(\"Create an RMI connector server\");\n-            JMXServiceURL url =\n-                new JMXServiceURL(\"rmi\", null, 0);\n-            jmxcs =\n-                JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);\n-            jmxcs.start();\n-            \/\/ Create an RMI connector client\n-            \/\/\n-            System.out.println(\"Create an RMI connector client\");\n-            HashMap cli_env = new HashMap();\n-            \/\/ These credentials must match those in the default password file\n-            \/\/\n-            String[] credentials = new String[] { \"monitorRole\" , \"QED\" };\n-            cli_env.put(\"jmx.remote.credentials\", credentials);\n-            jmxc = JMXConnectorFactory.connect(jmxcs.getAddress(), cli_env);\n-            Subject delegationSubject =\n-                new Subject(true,\n-                            Collections.singleton(new JMXPrincipal(\"delegate\")),\n-                            Collections.EMPTY_SET,\n-                            Collections.EMPTY_SET);\n-            MBeanServerConnection mbsc =\n-                jmxc.getMBeanServerConnection(delegationSubject);\n-            \/\/ Get domains from MBeanServer\n-            \/\/\n-            System.out.println(\"Domains:\");\n-            String domains[] = mbsc.getDomains();\n-            for (int i = 0; i < domains.length; i++) {\n-                System.out.println(\"\\tDomain[\" + i + \"] = \" + domains[i]);\n-            }\n-            \/\/ Get MBean count\n-            \/\/\n-            System.out.println(\"MBean count = \" + mbsc.getMBeanCount());\n-            \/\/ Get State attribute\n-            \/\/\n-            String oldState =\n-                (String) mbsc.getAttribute(\n-                              new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                              \"State\");\n-            System.out.println(\"Old State = \\\"\" + oldState + \"\\\"\");\n-            \/\/ Set State attribute\n-            \/\/\n-            System.out.println(\"Set State to \\\"changed state\\\"\");\n-            mbsc.setAttribute(new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                              new Attribute(\"State\", \"changed state\"));\n-            \/\/ Get State attribute\n-            \/\/\n-            String newState =\n-                (String) mbsc.getAttribute(\n-                              new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                              \"State\");\n-            System.out.println(\"New State = \\\"\" + newState + \"\\\"\");\n-            if (!newState.equals(\"changed state\")) {\n-                System.out.println(\"Invalid State = \\\"\" + newState + \"\\\"\");\n-                System.exit(1);\n-            }\n-            \/\/ Add notification listener on SimpleStandard MBean\n-            \/\/\n-            System.out.println(\"Add notification listener...\");\n-            mbsc.addNotificationListener(\n-                 new ObjectName(\"MBeans:type=SimpleStandard\"),\n-                 new NotificationListener() {\n-                     public void handleNotification(Notification notification,\n-                                                    Object handback) {\n-                         System.out.println(\"Received notification: \" +\n-                                            notification);\n-                     }\n-                 },\n-                 null,\n-                 null);\n-            \/\/ Unregister SimpleStandard MBean\n-            \/\/\n-            System.out.println(\"Unregister SimpleStandard MBean...\");\n-            mbsc.unregisterMBean(new ObjectName(\"MBeans:type=SimpleStandard\"));\n-        } catch (SecurityException e) {\n-            if (testResult.equals(\"ko\")) {\n-                System.out.println(\"Got expected security exception = \" + e);\n-            } else {\n-                System.out.println(\"Got unexpected security exception = \" + e);\n-                e.printStackTrace();\n-                throw e;\n-            }\n-        } catch (Exception e) {\n-            System.out.println(\"Unexpected exception caught = \" + e);\n-            e.printStackTrace();\n-            throw e;\n-        } finally {\n-            \/\/ Close connector client\n-            \/\/\n-            if (jmxc != null)\n-                jmxc.close();\n-            \/\/ Stop connector server\n-            \/\/\n-            if (jmxcs != null)\n-                jmxcs.stop();\n-            \/\/ Say goodbye\n-            \/\/\n-            System.out.println(\"Bye! Bye!\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/SubjectDelegation3Test.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n-monitorRole QED\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/jmxremote.password","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-grant {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy11","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-grant {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy12","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-grant {\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy13","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-grant {\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy14","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-grant {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.monitorRole\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy15","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-grant {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.monitorRole\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy16","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,25 +0,0 @@\n-grant {\n-    permission javax.security.auth.AuthPermission \"createLoginContext.JMXPluggableAuthenticator\";\n-    permission java.net.SocketPermission \"*:*\", \"accept,connect,listen,resolve\";\n-    permission java.security.SecurityPermission \"createAccessControlContext\";\n-    permission java.lang.RuntimePermission \"*\";\n-    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy21","additions":0,"deletions":25,"binary":false,"changes":25,"status":"deleted"},{"patch":"@@ -1,25 +0,0 @@\n-grant {\n-    permission javax.security.auth.AuthPermission \"createLoginContext.JMXPluggableAuthenticator\";\n-    permission java.net.SocketPermission \"*:*\", \"accept,connect,listen,resolve\";\n-    permission java.lang.RuntimePermission \"*\";\n-    permission java.security.SecurityPermission \"createAccessControlContext\";\n-\/\/    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy22","additions":0,"deletions":25,"binary":false,"changes":25,"status":"deleted"},{"patch":"@@ -1,25 +0,0 @@\n-grant {\n-    permission javax.security.auth.AuthPermission \"createLoginContext.JMXPluggableAuthenticator\";\n-    permission java.net.SocketPermission \"*:*\", \"accept,connect,listen,resolve\";\n-    permission java.lang.RuntimePermission \"*\";\n-    permission java.security.SecurityPermission \"createAccessControlContext\";\n-    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-\/\/    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy23","additions":0,"deletions":25,"binary":false,"changes":25,"status":"deleted"},{"patch":"@@ -1,18 +0,0 @@\n-grant {\n-    permission javax.security.auth.AuthPermission \"createLoginContext.JMXPluggableAuthenticator\";\n-    permission java.lang.RuntimePermission \"*\";\n-    permission java.net.SocketPermission \"*:*\", \"accept,connect,listen,resolve\";\n-    permission java.security.SecurityPermission \"createAccessControlContext\";\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.monitorRole\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy24","additions":0,"deletions":18,"binary":false,"changes":18,"status":"deleted"},{"patch":"@@ -1,18 +0,0 @@\n-grant {\n-    permission javax.security.auth.AuthPermission \"createLoginContext.JMXPluggableAuthenticator\";\n-    permission java.lang.RuntimePermission \"*\";\n-    permission java.net.SocketPermission \"*:*\", \"accept,connect,listen,resolve\";\n-    permission java.security.SecurityPermission \"createAccessControlContext\";\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.monitorRole\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-\/\/    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy25","additions":0,"deletions":18,"binary":false,"changes":18,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-grant {\n-    permission javax.security.auth.AuthPermission \"createLoginContext.JMXPluggableAuthenticator\";\n-    permission java.net.SocketPermission \"*:*\", \"accept,connect,listen,resolve\";\n-    permission java.lang.RuntimePermission \"*\";\n-    permission java.security.SecurityPermission \"createAccessControlContext\";\n-    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"delegate\" {\n-    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy31","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-grant {\n-    permission javax.security.auth.AuthPermission \"createLoginContext.JMXPluggableAuthenticator\";\n-    permission java.net.SocketPermission \"*:*\", \"accept,connect,listen,resolve\";\n-    permission java.lang.RuntimePermission \"*\";\n-    permission java.security.SecurityPermission \"createAccessControlContext\";\n-\/\/    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"delegate\" {\n-    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy32","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-grant {\n-    permission javax.security.auth.AuthPermission \"createLoginContext.JMXPluggableAuthenticator\";\n-    permission java.net.SocketPermission \"*:*\", \"accept,connect,listen,resolve\";\n-    permission java.lang.RuntimePermission \"*\";\n-    permission java.security.SecurityPermission \"createAccessControlContext\";\n-    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"delegate\" {\n-\/\/    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy33","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-grant {\n-    permission javax.security.auth.AuthPermission \"createLoginContext.JMXPluggableAuthenticator\";\n-    permission java.lang.RuntimePermission \"*\";\n-    permission java.net.SocketPermission \"*:*\", \"accept,connect,listen,resolve\";\n-    permission java.security.SecurityPermission \"createAccessControlContext\";\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.monitorRole\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"delegate\" {\n-    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy34","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-grant {\n-    permission javax.security.auth.AuthPermission \"createLoginContext.JMXPluggableAuthenticator\";\n-    permission java.lang.RuntimePermission \"*\";\n-    permission java.net.SocketPermission \"*:*\", \"accept,connect,listen,resolve\";\n-    permission java.security.SecurityPermission \"createAccessControlContext\";\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.monitorRole\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"monitorRole\" {\n-    permission javax.management.remote.SubjectDelegationPermission \"javax.management.remote.JMXPrincipal.delegate\";\n-};\n-\n-grant principal javax.management.remote.JMXPrincipal \"delegate\" {\n-\/\/    permission javax.management.MBeanPermission \"*\", \"getDomains\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"getAttribute\";\n-    permission javax.security.auth.AuthPermission \"getSubject\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#State[MBeans:type=SimpleStandard]\", \"setAttribute\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"addNotificationListener\";\n-    permission javax.management.MBeanPermission \"javax.management.MBeanServerDelegate#-[JMImplementation:type=MBeanServerDelegate]\", \"removeNotificationListener\";\n-    permission javax.management.MBeanPermission \"SimpleStandard#-[MBeans:type=SimpleStandard]\", \"unregisterMBean\";\n-};\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/policy35","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-<!--\n- Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- This code is free software; you can redistribute it and\/or modify it\n- under the terms of the GNU General Public License version 2 only, as\n- published by the Free Software Foundation.\n-\n- This code is distributed in the hope that it will be useful, but WITHOUT\n- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- version 2 for more details (a copy is included in the LICENSE file that\n- accompanied this code).\n-\n- You should have received a copy of the GNU General Public License version\n- 2 along with this work; if not, write to the Free Software Foundation,\n- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n- Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- or visit www.oracle.com if you need additional information or have any\n- questions.\n--->\n-\n-<html>\n-<body>\n-If you don't see the preview panel, then test failed, otherwise it passed.\n-\n-<applet width=\"500\" height=\"400\" code=\"Test6977726.class\">\n-<\/applet>\n-<\/body>\n-<\/html>\n","filename":"test\/jdk\/javax\/swing\/JColorChooser\/Test6977726.html","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,4 @@\n+import java.awt.Color;\n+import javax.swing.JColorChooser;\n+import javax.swing.JLabel;\n+\n@@ -27,3 +31,5 @@\n- * @summary Checks if JColorChooser.setPreviewPanel removes the old one\n- * @author Sergey Malenkov\n- * @run applet\/manual=yesno Test6977726.html\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Checks if JColorChooser.setPreviewPanel(JLabel) doesn't remove the preview panel but\n+ *          removes the content of the default preview panel\n+ * @run main\/manual Test6977726\n@@ -32,3 +38,18 @@\n-import javax.swing.JApplet;\n-import javax.swing.JColorChooser;\n-import javax.swing.JLabel;\n+public class Test6977726 {\n+\n+    public static void main(String[] args) throws Exception {\n+        String instructions = \"\"\"\n+                Check that there is a panel with \"Text Preview Panel\" text\n+                and with title \"Preview\" in the JColorChooser.\n+                Test passes if the panel is as described, test fails otherwise.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test6977726\")\n+                .instructions(instructions)\n+                .rows(5)\n+                .columns(40)\n+                .testTimeOut(2)\n+                .testUI(Test6977726::createColorChooser)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -36,3 +57,2 @@\n-public class Test6977726 extends JApplet {\n-    public void init() {\n-        JColorChooser chooser = new JColorChooser();\n+    private static JColorChooser createColorChooser() {\n+        JColorChooser chooser = new JColorChooser(Color.BLUE);\n@@ -40,1 +60,1 @@\n-        getContentPane().add(chooser);\n+        return chooser;\n","filename":"test\/jdk\/javax\/swing\/JColorChooser\/Test6977726.java","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+\n+import javax.swing.JEditorPane;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.Document;\n+import javax.swing.text.Element;\n+\n+\/*\n+ * @test\n+ * @bug 8328953\n+ * @summary Verifies JEditorPane.read doesn't throw ChangedCharSetException\n+            but handles it and reads HTML in the specified encoding\n+ * @run main EditorPaneCharset\n+ *\/\n+\n+public final class EditorPaneCharset {\n+    private static final String CYRILLIC_TEXT =\n+            \"\\u041F\\u0440\\u0438\\u0432\\u0435\\u0442, \\u043C\\u0438\\u0440!\";\n+    private static final String HTML_CYRILLIC =\n+            \"<html lang=\\\"ru\\\">\\n\" +\n+            \"<head>\\n\" +\n+            \"    <meta http-equiv=\\\"Content-Type\\\" \" +\n+            \"          content=\\\"text\/html; charset=windows-1251\\\">\\n\" +\n+            \"<\/head><body>\\n\" +\n+            \"<p>\" + CYRILLIC_TEXT + \"<\/p>\\n\" +\n+            \"<\/body><\/html>\\n\";\n+\n+    public static void main(String[] args) throws IOException, BadLocationException {\n+        JEditorPane editorPane = new JEditorPane();\n+        editorPane.setContentType(\"text\/html\");\n+        Document document = editorPane.getDocument();\n+\n+        \/\/ Shouldn't throw ChangedCharSetException\n+        editorPane.read(\n+                new ByteArrayInputStream(\n+                        HTML_CYRILLIC.getBytes(\n+                                Charset.forName(\"windows-1251\"))),\n+                document);\n+\n+        Element root = document.getDefaultRootElement();\n+        Element body = root.getElement(1);\n+        Element p = body.getElement(0);\n+        String pText = document.getText(p.getStartOffset(),\n+                                        p.getEndOffset() - p.getStartOffset() - 1);\n+        if (!CYRILLIC_TEXT.equals(pText)) {\n+            throw new RuntimeException(\"Text doesn't match\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JEditorPane\/EditorPaneCharset.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -1,43 +0,0 @@\n-<html>\n-<!--\n- Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- This code is free software; you can redistribute it and\/or modify it\n- under the terms of the GNU General Public License version 2 only, as\n- published by the Free Software Foundation.\n-\n- This code is distributed in the hope that it will be useful, but WITHOUT\n- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- version 2 for more details (a copy is included in the LICENSE file that\n- accompanied this code).\n-\n- You should have received a copy of the GNU General Public License version\n- 2 along with this work; if not, write to the Free Software Foundation,\n- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n- Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- or visit www.oracle.com if you need additional information or have any\n- questions.\n--->\n-\n-<!--\n- @test\n- @bug 4150029 8006087\n- @summary BackSpace keyboard button does not lead to parent directory\n- @author Oleg Mokhovikov\n- @library \/test\/lib\n- @build jdk.test.lib.Platform\n- @run applet\/manual=done bug4150029.html\n--->\n-\n-<body>\n-<applet  code=\"bug4150029.class\" width=200 height=200><\/applet>\n-Follow the instructions below.\n-1.Go into 'subDir' folder.\n-2.Press BACKSPACE key.\n-3.Push OPEN button.\n-4.Push DONE button.\n-<\/body>\n-<\/html>\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/4150029\/bug4150029.html","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,10 @@\n-\/*\n-   bug 4150029 8006087\n-   summary BackSpace keyboard button does not lead to parent directory\n-   author Oleg Mokhovikov\n-*\/\n+import java.awt.BorderLayout;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.File;\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n@@ -32,3 +37,17 @@\n-import javax.swing.*;\n-import java.io.File;\n-import java.io.IOException;\n+\/*\n+ * @test\n+ * @bug 4150029 8006087\n+ * @key headful\n+ * @summary BackSpace keyboard button does not lead to parent directory\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main bug4150029\n+ *\/\n+\n+public class bug4150029 {\n+    private static JFrame frame;\n+    private static JFileChooser fileChooser;\n+    private static Robot robot;\n+    private static File prevDir;\n+    private static File crntDir;\n+    private static volatile Point p;\n@@ -36,2 +55,3 @@\n-public class bug4150029 extends JApplet {\n-    private boolean res;\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n@@ -39,6 +59,7 @@\n-    public void init() {\n-        if (Platform.isOSX()) {\n-            try {\n-                UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n+        try {\n+            if (Platform.isOSX()) {\n+                try {\n+                    UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n@@ -46,1 +67,0 @@\n-        }\n@@ -48,1 +68,1 @@\n-        String tmpDir = System.getProperty(\"java.io.tmpdir\");\n+            String tmpDir = System.getProperty(\"java.io.tmpdir\");\n@@ -50,2 +70,28 @@\n-        if (tmpDir.length() == 0) {\/\/'java.io.tmpdir' isn't guaranteed to be defined\n-            tmpDir = System.getProperty(\"user.home\");\n+            \/\/'java.io.tmpdir' isn't guaranteed to be defined\n+            if (tmpDir.length() == 0) {\n+                tmpDir = System.getProperty(\"user.home\");\n+            }\n+            System.out.println(\"Temp directory: \" + tmpDir);\n+\n+            File testDir = new File(tmpDir, \"testDir\");\n+            testDir.mkdir();\n+            testDir.deleteOnExit();\n+            System.out.println(\"Created directory: \" + testDir);\n+\n+            File subDir = new File(testDir, \"subDir\");\n+            subDir.mkdir();\n+            subDir.deleteOnExit();\n+            System.out.println(\"Created sub-directory: \" + subDir);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                createAndShowUI();\n+                fileChooser.setCurrentDirectory(subDir);\n+            });\n+\n+            doTesting();\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n@@ -53,0 +99,1 @@\n+    }\n@@ -54,14 +101,11 @@\n-        System.out.println(\"Temp directory: \" + tmpDir);\n-\n-        File testDir = new File(tmpDir, \"testDir\");\n-\n-        testDir.mkdir();\n-\n-        File subDir = new File(testDir, \"subDir\");\n-\n-        subDir.mkdir();\n-\n-        System.out.println(\"Created directory: \" + testDir);\n-        System.out.println(\"Created sub-directory: \" + subDir);\n-\n-        JFileChooser fileChooser = new JFileChooser(testDir);\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Backspace Shortcut for Directory Navigation Test\");\n+        frame.setLayout(new BorderLayout());\n+        fileChooser = new JFileChooser();\n+        fileChooser.setControlButtonsAreShown(false);\n+        frame.add(fileChooser, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n@@ -69,1 +113,7 @@\n-        fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);\n+    private static void doTesting() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            p = frame.getLocationOnScreen();\n+        });\n+        robot.mouseMove(p.x + 200, p.y + 200);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -71,5 +121,1 @@\n-        try {\n-            res = fileChooser.showOpenDialog(this) != JFileChooser.APPROVE_OPTION ||\n-                    testDir.getCanonicalPath().equals(fileChooser.getSelectedFile().getCanonicalPath());\n-        } catch (IOException e) {\n-            res = false;\n+        robot.waitForIdle();\n@@ -77,2 +123,2 @@\n-            e.printStackTrace();\n-        }\n+        \/\/ check backspace key at subDir level\n+        clickBackSpace();\n@@ -80,5 +126,2 @@\n-        try {\n-            subDir.delete();\n-            testDir.delete();\n-        } catch (SecurityException e) {\n-            e.printStackTrace();\n+        if (prevDir.equals(crntDir)) {\n+            throw new RuntimeException(\"BackSpace does not lead to parent directory\");\n@@ -88,4 +131,5 @@\n-    public void destroy() {\n-        if (!res) {\n-            throw new RuntimeException(\"BackSpace keyboard button does not lead to parent directory\");\n-        }\n+    private static void clickBackSpace() {\n+        prevDir = fileChooser.getCurrentDirectory();\n+        robot.keyPress(KeyEvent.VK_BACK_SPACE);\n+        robot.keyRelease(KeyEvent.VK_BACK_SPACE);\n+        crntDir = fileChooser.getCurrentDirectory();\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/4150029\/bug4150029.java","additions":96,"deletions":52,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 8305072\n+ * @requires (os.family == \"windows\")\n+ * @modules java.desktop\/sun.awt.shell\n+ * @summary Verifies consistency of Win32ShellFolder2.compareTo\n+ * @run main\/othervm --add-opens java.desktop\/sun.awt.shell=ALL-UNNAMED Win32FolderSort\n+ *\/\n+public class Win32FolderSort {\n+    public static void main(String[] args) throws Exception {\n+        Class<?> folderManager = Class.forName(\"sun.awt.shell.Win32ShellFolderManager2\");\n+        Class<?> folder = Class.forName(\"sun.awt.shell.Win32ShellFolder2\");\n+\n+        Method getDesktop = folderManager.getDeclaredMethod(\"getDesktop\");\n+        getDesktop.setAccessible(true);\n+        Method getPersonal = folderManager.getDeclaredMethod(\"getPersonal\");\n+        getPersonal.setAccessible(true);\n+\n+        Method createShellFolder = folderManager.getDeclaredMethod(\"createShellFolder\", folder, File.class);\n+        createShellFolder.setAccessible(true);\n+\n+        Method isFileSystem = folder.getMethod(\"isFileSystem\");\n+        isFileSystem.setAccessible(true);\n+        Method isSpecial = folder.getMethod(\"isSpecial\");\n+        isSpecial.setAccessible(true);\n+        Method getChildByPath = folder.getDeclaredMethod(\"getChildByPath\", String.class);\n+        getChildByPath.setAccessible(true);\n+\n+        File desktop = (File) getDesktop.invoke(null);\n+        File personal = (File) getPersonal.invoke(null);\n+        if (!((Boolean) isSpecial.invoke(personal))) {\n+            throw new RuntimeException(\"personal is not special\");\n+        }\n+        File fakePersonal = (File) getChildByPath.invoke(desktop, personal.getPath());\n+        if (fakePersonal == null) {\n+            fakePersonal = (File) createShellFolder.invoke(null, desktop,\n+                                                           new File(personal.getPath()));\n+        }\n+        if ((Boolean) isSpecial.invoke(fakePersonal)) {\n+            throw new RuntimeException(\"fakePersonal is special\");\n+        }\n+        File homeDir = (File) createShellFolder.invoke(null, desktop,\n+                                                       new File(System.getProperty(\"user.home\")));\n+\n+        File[] files = {fakePersonal, personal, homeDir};\n+        for (File f : files) {\n+            if (!((Boolean) isFileSystem.invoke(f))) {\n+                throw new RuntimeException(f + \" is not on file system\");\n+            }\n+        }\n+\n+        List<String> errors = new ArrayList<>(2);\n+        for (File f1 : files) {\n+            for (File f2 : files) {\n+                for (File f3 : files) {\n+                    String result = verifyCompareTo(f1, f2, f3);\n+                    if (result != null) {\n+                        String error = result + \"\\nwhere\"\n+                                       + \"\\n  a = \" + formatFile(f1, isSpecial)\n+                                       + \"\\n  b = \" + formatFile(f2, isSpecial)\n+                                       + \"\\n  c = \" + formatFile(f3, isSpecial);\n+                        errors.add(error);\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+        System.out.println(\"Unsorted:\");\n+        for (File f : files) {\n+            System.out.println(formatFile(f, isSpecial));\n+        }\n+        System.out.println();\n+\n+        Arrays.sort(files);\n+        System.out.println(\"Sorted:\");\n+        for (File f : files) {\n+            System.out.println(formatFile(f, isSpecial));\n+        }\n+\n+\n+        if (!errors.isEmpty()) {\n+            System.err.println(\"Implementation of Win32ShellFolder2.compareTo is inconsistent:\");\n+            errors.forEach(System.err::println);\n+            throw new RuntimeException(\"Inconsistencies found: \" + errors.size()\n+                                       + \" - \" + errors.get(0));\n+        }\n+    }\n+\n+    \/**\n+     * Verifies consistency of {@code Comparable} implementation.\n+     *\n+     * @param a the first object\n+     * @param b the second object\n+     * @param c the third object\n+     * @return error message if inconsistency is found,\n+     *         or {@code null } otherwise\n+     *\/\n+    private static String verifyCompareTo(File a, File b, File c) {\n+        \/\/ a < b & b < c => a < c\n+        if (a.compareTo(b) < 0 && b.compareTo(c) < 0) {\n+            if (a.compareTo(c) >= 0) {\n+                return \"a < b & b < c but a >= c\";\n+            }\n+        }\n+\n+        \/\/ a > b & b > c => a > c\n+        if (a.compareTo(b) > 0 && b.compareTo(c) > 0) {\n+            if (a.compareTo(c) <= 0) {\n+                return \"a > b & b > c but a <= c\";\n+            }\n+        }\n+\n+        \/\/ a = b & b = c => a = c\n+        if (a.compareTo(b) == 0 && b.compareTo(c) == 0) {\n+            if (a.compareTo(c) != 0) {\n+                return \"a = b & b = c but a != c\";\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private static String formatFile(File f, Method isSpecial)\n+            throws InvocationTargetException, IllegalAccessException {\n+        return f + \"(\" + isSpecial.invoke(f) + \")\";\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileSystemView\/Win32FolderSort.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+\n+import javax.swing.JFileChooser;\n+\n+\/*\n+ * @test\n+ * @bug 8323670 8307091 8240690\n+ * @requires os.family == \"mac\" | os.family == \"linux\"\n+ * @summary Verifies thread-safety of BasicDirectoryModel (JFileChooser)\n+ * @run main\/othervm -Djava.awt.headless=true ConcurrentModification\n+ *\/\n+public final class ConcurrentModification extends ThreadGroup {\n+    \/** Initial number of files. *\/\n+    private static final long NUMBER_OF_FILES = 50;\n+    \/** Maximum number of files created on a timer tick. *\/\n+    private static final long LIMIT_FILES = 10;\n+\n+    \/** Timer period (delay) for creating new files. *\/\n+    private static final long TIMER_PERIOD = 250;\n+\n+    \/**\n+     * Number of threads running {@code fileChooser.rescanCurrentDirectory()}.\n+     *\/\n+    private static final int NUMBER_OF_THREADS = 5;\n+    \/** Number of repeated calls to {@code rescanCurrentDirectory}. *\/\n+    private static final int NUMBER_OF_REPEATS = 2_000;\n+    \/** Maximum amount a thread waits before initiating rescan. *\/\n+    private static final long LIMIT_SLEEP = 100;\n+\n+\n+    \/** The barrier to start all the scanner threads simultaneously. *\/\n+    private static final CyclicBarrier start = new CyclicBarrier(NUMBER_OF_THREADS);\n+    \/** The barrier to wait for all the scanner threads to complete, plus main thread. *\/\n+    private static final CyclicBarrier end = new CyclicBarrier(NUMBER_OF_THREADS + 1);\n+\n+    \/** List of scanner threads. *\/\n+    private static final List<Thread> threads = new ArrayList<>(NUMBER_OF_THREADS);\n+\n+    \/**\n+     * Stores an exception caught by any of the threads.\n+     * If more exceptions are caught, they're added as suppressed exceptions.\n+     *\/\n+    private static final AtomicReference<Throwable> exception =\n+            new AtomicReference<>();\n+\n+    \/**\n+     * Stores an {@code IOException} thrown while removing the files.\n+     *\/\n+    private static final AtomicReference<IOException> ioException =\n+            new AtomicReference<>();\n+\n+\n+    public static void main(String[] args) throws Throwable {\n+        try {\n+            \/\/ Start the test in its own thread group to catch and handle\n+            \/\/ all thrown exceptions, in particular in\n+            \/\/ BasicDirectoryModel.FilesLoader which is created by Swing.\n+            ThreadGroup threadGroup = new ConcurrentModification();\n+            Thread runner = new Thread(threadGroup,\n+                                       ConcurrentModification::wrapper,\n+                                       \"Test Runner\");\n+            runner.start();\n+            runner.join();\n+        } catch (Throwable throwable) {\n+            handleException(throwable);\n+        }\n+\n+        if (ioException.get() != null) {\n+            System.err.println(\"An error occurred while removing files:\");\n+            ioException.get().printStackTrace();\n+        }\n+\n+        if (exception.get() != null) {\n+            throw exception.get();\n+        }\n+    }\n+\n+    private static void wrapper() {\n+        final long timeStart = System.currentTimeMillis();\n+        try {\n+            runTest(timeStart);\n+        } catch (Throwable throwable) {\n+            handleException(throwable);\n+        } finally {\n+            System.out.printf(\"Duration: %,d\\n\",\n+                              (System.currentTimeMillis() - timeStart));\n+        }\n+    }\n+\n+    private static void runTest(final long timeStart) throws Throwable {\n+        final Path temp = Files.createDirectory(Paths.get(\"fileChooser-concurrency-\" + timeStart));\n+\n+        final Timer timer = new Timer(\"File creator\");\n+\n+        try {\n+            createFiles(temp);\n+\n+            final JFileChooser fc = new JFileChooser(temp.toFile());\n+\n+            IntStream.range(0, NUMBER_OF_THREADS)\n+                     .forEach(i -> {\n+                         Thread thread = new Thread(new Scanner(fc));\n+                         threads.add(thread);\n+                         thread.start();\n+                     });\n+\n+            timer.scheduleAtFixedRate(new CreateFilesTimerTask(temp),\n+                                      0, TIMER_PERIOD);\n+\n+            end.await();\n+        } catch (Throwable e) {\n+            threads.forEach(Thread::interrupt);\n+            throw e;\n+        } finally {\n+            timer.cancel();\n+\n+            deleteFiles(temp);\n+            deleteFile(temp);\n+        }\n+    }\n+\n+\n+    private ConcurrentModification() {\n+        super(\"bdmConcurrency\");\n+    }\n+\n+    @Override\n+    public void uncaughtException(Thread t, Throwable e) {\n+        handleException(t, e);\n+    }\n+\n+    private static void handleException(Throwable throwable) {\n+        handleException(Thread.currentThread(), throwable);\n+    }\n+\n+    private static void handleException(final Thread thread,\n+                                        final Throwable throwable) {\n+        System.err.println(\"Exception in \" + thread.getName() + \": \"\n+                           + throwable.getClass()\n+                           + (throwable.getMessage() != null\n+                              ? \": \" + throwable.getMessage()\n+                              : \"\"));\n+        if (!exception.compareAndSet(null, throwable)) {\n+            exception.get().addSuppressed(throwable);\n+        }\n+        threads.stream()\n+               .filter(t -> t != thread)\n+               .forEach(Thread::interrupt);\n+    }\n+\n+\n+    private record Scanner(JFileChooser fileChooser)\n+            implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            try {\n+                start.await();\n+\n+                int counter = 0;\n+                try {\n+                    do {\n+                        fileChooser.rescanCurrentDirectory();\n+                        Thread.sleep((long) (Math.random() * LIMIT_SLEEP));\n+                    } while (++counter < NUMBER_OF_REPEATS\n+                             && !Thread.interrupted());\n+                } catch (InterruptedException e) {\n+                    \/\/ Just exit the loop\n+                }\n+            } catch (Throwable throwable) {\n+                handleException(throwable);\n+            } finally {\n+                try {\n+                    end.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    handleException(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void createFiles(final Path parent) {\n+        createFiles(parent, 0, NUMBER_OF_FILES);\n+    }\n+\n+    private static void createFiles(final Path parent,\n+                                    final long start,\n+                                    final long end) {\n+        LongStream.range(start, end)\n+                  .forEach(n -> createFile(parent.resolve(n + \".file\")));\n+    }\n+\n+    private static void createFile(final Path file) {\n+        try {\n+            Files.createFile(file);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void deleteFiles(final Path parent) throws IOException {\n+        try (var stream = Files.walk(parent)) {\n+            stream.filter(p -> p != parent)\n+                  .forEach(ConcurrentModification::deleteFile);\n+        }\n+    }\n+\n+    private static void deleteFile(final Path file) {\n+        try {\n+            Files.delete(file);\n+        } catch (IOException e) {\n+            if (!ioException.compareAndSet(null, e)) {\n+                ioException.get().addSuppressed(e);\n+            }\n+        }\n+    }\n+\n+    private static final class CreateFilesTimerTask extends TimerTask {\n+        private final Path temp;\n+        private long no;\n+\n+        public CreateFilesTimerTask(Path temp) {\n+            this.temp = temp;\n+            no = NUMBER_OF_FILES;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                long count = (long) (Math.random() * LIMIT_FILES);\n+                createFiles(temp, no, no + count);\n+                no += count;\n+            } catch (Throwable t) {\n+                handleException(t);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicDirectoryModel\/ConcurrentModification.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -38,0 +38,3 @@\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n@@ -101,0 +104,6 @@\n+                                tryb.invokedynamic(DynamicCallSiteDesc.of(\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, ClassDesc.of(\"Phoo\"), \"phee\", MethodTypeDesc.of(ClassDesc.of(\"Boo\"))),\n+                                        \"intfMethod\",\n+                                        MethodTypeDesc.of(ClassDesc.of(\"Boo\")),\n+                                        \"bootstrap argument 1\",\n+                                        \"bootstrap argument 2\"));\n@@ -124,1 +133,1 @@\n-                    attributes: [SourceFile, InnerClasses, EnclosingMethod, Synthetic, Signature, Deprecated, NestHost, NestMembers, Record, RuntimeInvisibleAnnotations, PermittedSubclasses]\n+                    attributes: [SourceFile, InnerClasses, EnclosingMethod, Synthetic, Signature, Deprecated, NestHost, NestMembers, Record, RuntimeInvisibleAnnotations, PermittedSubclasses, BootstrapMethods]\n@@ -136,62 +145,75 @@\n-                        11: {tag: Utf8, value: Phee}\n-                        12: {tag: Class, class name index: 11, class internal name: Phee}\n-                        13: {tag: Utf8, value: Phoo}\n-                        14: {tag: Class, class name index: 13, class internal name: Phoo}\n-                        15: {tag: Utf8, value: RuntimeVisibleAnnotations}\n-                        16: {tag: Utf8, value: flfl}\n-                        17: {tag: Float, value: 0.0}\n-                        18: {tag: Utf8, value: frfl}\n-                        19: {tag: Float, value: 1.0}\n-                        20: {tag: Utf8, value: AnnotationDefault}\n-                        21: {tag: Integer, value: 1}\n-                        22: {tag: Integer, value: 12}\n-                        23: {tag: Integer, value: 99}\n-                        24: {tag: Utf8, value: LPhee;}\n-                        25: {tag: Double, value: 1.3}\n-                        27: {tag: Utf8, value: LBoo;}\n-                        28: {tag: Utf8, value: BOO}\n-                        29: {tag: Float, value: 3.7}\n-                        30: {tag: Integer, value: 33}\n-                        31: {tag: Long, value: 3333}\n-                        33: {tag: Integer, value: 25}\n-                        34: {tag: Utf8, value: param}\n-                        35: {tag: Integer, value: 3}\n-                        36: {tag: Utf8, value: RuntimeVisibleParameterAnnotations}\n-                        37: {tag: Float, value: 22.0}\n-                        38: {tag: Float, value: 11.0}\n-                        39: {tag: Utf8, value: RuntimeInvisibleParameterAnnotations}\n-                        40: {tag: Float, value: '-22.0'}\n-                        41: {tag: Float, value: '-11.0'}\n-                        42: {tag: Utf8, value: Exceptions}\n-                        43: {tag: Utf8, value: Bee}\n-                        44: {tag: Class, class name index: 43, class internal name: Bee}\n-                        45: {tag: Utf8, value: Code}\n-                        46: {tag: Utf8, value: RuntimeInvisibleTypeAnnotations}\n-                        47: {tag: Utf8, value: RuntimeVisibleTypeAnnotations}\n-                        48: {tag: Utf8, value: LFee;}\n-                        49: {tag: Utf8, value: yes}\n-                        50: {tag: Integer, value: 0}\n-                        51: {tag: Utf8, value: LocalVariableTable}\n-                        52: {tag: Utf8, value: LocalVariableTypeTable}\n-                        53: {tag: Utf8, value: LineNumberTable}\n-                        54: {tag: Utf8, value: StackMapTable}\n-                        55: {tag: Utf8, value: SourceFile}\n-                        56: {tag: Utf8, value: Foo.java}\n-                        57: {tag: Utf8, value: InnerClasses}\n-                        58: {tag: Utf8, value: InnerName}\n-                        59: {tag: Utf8, value: EnclosingMethod}\n-                        60: {tag: Utf8, value: enclosingMethod}\n-                        61: {tag: Utf8, value: (Ljava\/util\/Collection;)Ljava\/lang\/Double;}\n-                        62: {tag: NameAndType, name index: 60, type index: 61, name: enclosingMethod, type: (Ljava\/util\/Collection;)Ljava\/lang\/Double;}\n-                        63: {tag: Utf8, value: Synthetic}\n-                        64: {tag: Utf8, value: Signature}\n-                        65: {tag: Utf8, value: LBoo;LPhee;LPhoo;}\n-                        66: {tag: Utf8, value: Deprecated}\n-                        67: {tag: Utf8, value: NestHost}\n-                        68: {tag: Utf8, value: NestMembers}\n-                        69: {tag: Utf8, value: Record}\n-                        70: {tag: Utf8, value: fee}\n-                        71: {tag: Utf8, value: RuntimeInvisibleAnnotations}\n-                        72: {tag: Float, value: 2.0}\n-                        73: {tag: Float, value: 3.0}\n-                        74: {tag: Utf8, value: PermittedSubclasses}\n+                        11: {tag: Utf8, value: Phoo}\n+                        12: {tag: Class, class name index: 11, class internal name: Phoo}\n+                        13: {tag: Utf8, value: phee}\n+                        14: {tag: Utf8, value: ()LBoo;}\n+                        15: {tag: NameAndType, name index: 13, type index: 14, name: phee, type: ()LBoo;}\n+                        16: {tag: Methodref, owner index: 12, name and type index: 15, owner: Phoo, name: phee, type: ()LBoo;}\n+                        17: {tag: MethodHandle, reference kind: STATIC, reference index: 16, owner: Phoo, name: phee, type: ()LBoo;}\n+                        18: {tag: Utf8, value: bootstrap argument 1}\n+                        19: {tag: String, value index: 18, value: bootstrap argument 1}\n+                        20: {tag: Utf8, value: bootstrap argument 2}\n+                        21: {tag: String, value index: 20, value: bootstrap argument 2}\n+                        22: {tag: Utf8, value: intfMethod}\n+                        23: {tag: NameAndType, name index: 22, type index: 14, name: intfMethod, type: ()LBoo;}\n+                        24: {tag: InvokeDynamic, bootstrap method handle index: 17, bootstrap method arguments indexes: [19, 21], name and type index: 23, name: intfMethod, type: ()LBoo;}\n+                        25: {tag: Utf8, value: Phee}\n+                        26: {tag: Class, class name index: 25, class internal name: Phee}\n+                        27: {tag: Utf8, value: RuntimeVisibleAnnotations}\n+                        28: {tag: Utf8, value: flfl}\n+                        29: {tag: Float, value: 0.0}\n+                        30: {tag: Utf8, value: frfl}\n+                        31: {tag: Float, value: 1.0}\n+                        32: {tag: Utf8, value: AnnotationDefault}\n+                        33: {tag: Integer, value: 1}\n+                        34: {tag: Integer, value: 12}\n+                        35: {tag: Integer, value: 99}\n+                        36: {tag: Utf8, value: LPhee;}\n+                        37: {tag: Double, value: 1.3}\n+                        39: {tag: Utf8, value: LBoo;}\n+                        40: {tag: Utf8, value: BOO}\n+                        41: {tag: Float, value: 3.7}\n+                        42: {tag: Integer, value: 33}\n+                        43: {tag: Long, value: 3333}\n+                        45: {tag: Integer, value: 25}\n+                        46: {tag: Utf8, value: param}\n+                        47: {tag: Integer, value: 3}\n+                        48: {tag: Utf8, value: RuntimeVisibleParameterAnnotations}\n+                        49: {tag: Float, value: 22.0}\n+                        50: {tag: Float, value: 11.0}\n+                        51: {tag: Utf8, value: RuntimeInvisibleParameterAnnotations}\n+                        52: {tag: Float, value: '-22.0'}\n+                        53: {tag: Float, value: '-11.0'}\n+                        54: {tag: Utf8, value: Exceptions}\n+                        55: {tag: Utf8, value: Bee}\n+                        56: {tag: Class, class name index: 55, class internal name: Bee}\n+                        57: {tag: Utf8, value: Code}\n+                        58: {tag: Utf8, value: RuntimeInvisibleTypeAnnotations}\n+                        59: {tag: Utf8, value: RuntimeVisibleTypeAnnotations}\n+                        60: {tag: Utf8, value: LFee;}\n+                        61: {tag: Utf8, value: yes}\n+                        62: {tag: Integer, value: 0}\n+                        63: {tag: Utf8, value: LocalVariableTable}\n+                        64: {tag: Utf8, value: LocalVariableTypeTable}\n+                        65: {tag: Utf8, value: LineNumberTable}\n+                        66: {tag: Utf8, value: StackMapTable}\n+                        67: {tag: Utf8, value: SourceFile}\n+                        68: {tag: Utf8, value: Foo.java}\n+                        69: {tag: Utf8, value: InnerClasses}\n+                        70: {tag: Utf8, value: InnerName}\n+                        71: {tag: Utf8, value: EnclosingMethod}\n+                        72: {tag: Utf8, value: enclosingMethod}\n+                        73: {tag: Utf8, value: (Ljava\/util\/Collection;)Ljava\/lang\/Double;}\n+                        74: {tag: NameAndType, name index: 72, type index: 73, name: enclosingMethod, type: (Ljava\/util\/Collection;)Ljava\/lang\/Double;}\n+                        75: {tag: Utf8, value: Synthetic}\n+                        76: {tag: Utf8, value: Signature}\n+                        77: {tag: Utf8, value: LBoo;LPhee;LPhoo;}\n+                        78: {tag: Utf8, value: Deprecated}\n+                        79: {tag: Utf8, value: NestHost}\n+                        80: {tag: Utf8, value: NestMembers}\n+                        81: {tag: Utf8, value: Record}\n+                        82: {tag: Utf8, value: fee}\n+                        83: {tag: Utf8, value: RuntimeInvisibleAnnotations}\n+                        84: {tag: Float, value: 2.0}\n+                        85: {tag: Float, value: 3.0}\n+                        86: {tag: Utf8, value: PermittedSubclasses}\n+                        87: {tag: Utf8, value: BootstrapMethods}\n@@ -216,0 +238,2 @@\n+                    bootstrap methods:\n+                      - {index: 0, kind: STATIC, owner: Phoo, name: phee, args: [bootstrap argument 1, bootstrap argument 2]}\n@@ -239,1 +263,1 @@\n-                              - {start: 0, end: 7, slot: 2, name: variable, type: LPhoo;}\n+                              - {start: 0, end: 12, slot: 2, name: variable, type: LPhoo;}\n@@ -241,1 +265,1 @@\n-                              - {start: 0, end: 7, slot: 2, name: variable, signature: LPhoo;}\n+                              - {start: 0, end: 12, slot: 2, name: variable, signature: LPhoo;}\n@@ -246,1 +270,1 @@\n-                              - {start: 7, line number: 4}\n+                              - {start: 12, line number: 4}\n@@ -249,1 +273,1 @@\n-                                7: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n+                                12: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n@@ -255,1 +279,1 @@\n-                            \/\/try block 1 start: {start: 0, end: 7, handler: 7, catch type: Phee}\n+                            \/\/try block 1 start: {start: 0, end: 12, handler: 12, catch type: Phee}\n@@ -261,5 +285,6 @@\n-                            6: {opcode: RETURN}\n-                            \/\/stack map frame @7: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n-                            \/\/try block 1 end: {start: 0, end: 7, handler: 7, catch type: Phee}\n-                            \/\/exception handler 1 start: {start: 0, end: 7, handler: 7, catch type: Phee}\n-                            7: {opcode: ATHROW}\n+                            6: {opcode: INVOKEDYNAMIC, name: intfMethod, descriptor: ()LBoo;, bootstrap method: STATIC Phoo::phee, arguments: [bootstrap argument 1, bootstrap argument 2]}\n+                            11: {opcode: RETURN}\n+                            \/\/stack map frame @12: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n+                            \/\/try block 1 end: {start: 0, end: 12, handler: 12, catch type: Phee}\n+                            \/\/exception handler 1 start: {start: 0, end: 12, handler: 12, catch type: Phee}\n+                            12: {opcode: ATHROW}\n@@ -267,1 +292,1 @@\n-                                handler 1: {start: 0, end: 7, handler: 7, type: Phee}\n+                                handler 1: {start: 0, end: 12, handler: 12, type: Phee}\n@@ -282,1 +307,1 @@\n-                    attributes: [SourceFile, InnerClasses, EnclosingMethod, Synthetic, Signature, Deprecated, NestHost, NestMembers, Record, RuntimeInvisibleAnnotations, PermittedSubclasses]\n+                    attributes: [SourceFile, InnerClasses, EnclosingMethod, Synthetic, Signature, Deprecated, NestHost, NestMembers, Record, RuntimeInvisibleAnnotations, PermittedSubclasses, BootstrapMethods]\n@@ -286,0 +311,2 @@\n+                    bootstrap methods:\n+                      - {index: 0, kind: STATIC, owner: Phoo, name: phee, args: [bootstrap argument 1, bootstrap argument 2]}\n@@ -302,1 +329,1 @@\n-                                7: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n+                                12: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n@@ -304,1 +331,1 @@\n-                            \/\/try block 1 start: {start: 0, end: 7, handler: 7, catch type: Phee}\n+                            \/\/try block 1 start: {start: 0, end: 12, handler: 12, catch type: Phee}\n@@ -310,5 +337,6 @@\n-                            6: {opcode: RETURN}\n-                            \/\/stack map frame @7: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n-                            \/\/try block 1 end: {start: 0, end: 7, handler: 7, catch type: Phee}\n-                            \/\/exception handler 1 start: {start: 0, end: 7, handler: 7, catch type: Phee}\n-                            7: {opcode: ATHROW}\n+                            6: {opcode: INVOKEDYNAMIC, name: intfMethod, descriptor: ()LBoo;, bootstrap method: STATIC Phoo::phee, arguments: [bootstrap argument 1, bootstrap argument 2]}\n+                            11: {opcode: RETURN}\n+                            \/\/stack map frame @12: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n+                            \/\/try block 1 end: {start: 0, end: 12, handler: 12, catch type: Phee}\n+                            \/\/exception handler 1 start: {start: 0, end: 12, handler: 12, catch type: Phee}\n+                            12: {opcode: ATHROW}\n@@ -316,1 +344,1 @@\n-                                handler 1: {start: 0, end: 7, handler: 7, type: Phee}\n+                                handler 1: {start: 0, end: 12, handler: 12, type: Phee}\n@@ -331,1 +359,1 @@\n-                    attributes: [SourceFile, InnerClasses, EnclosingMethod, Synthetic, Signature, Deprecated, NestHost, NestMembers, Record, RuntimeInvisibleAnnotations, PermittedSubclasses]\n+                    attributes: [SourceFile, InnerClasses, EnclosingMethod, Synthetic, Signature, Deprecated, NestHost, NestMembers, Record, RuntimeInvisibleAnnotations, PermittedSubclasses, BootstrapMethods]\n@@ -356,1 +384,1 @@\n-                    \"attributes\": [\"SourceFile\", \"InnerClasses\", \"EnclosingMethod\", \"Synthetic\", \"Signature\", \"Deprecated\", \"NestHost\", \"NestMembers\", \"Record\", \"RuntimeInvisibleAnnotations\", \"PermittedSubclasses\"],\n+                    \"attributes\": [\"SourceFile\", \"InnerClasses\", \"EnclosingMethod\", \"Synthetic\", \"Signature\", \"Deprecated\", \"NestHost\", \"NestMembers\", \"Record\", \"RuntimeInvisibleAnnotations\", \"PermittedSubclasses\", \"BootstrapMethods\"],\n@@ -368,62 +396,75 @@\n-                        \"11\": {\"tag\": \"Utf8\", \"value\": \"Phee\"},\n-                        \"12\": {\"tag\": \"Class\", \"class name index\": 11, \"class internal name\": \"Phee\"},\n-                        \"13\": {\"tag\": \"Utf8\", \"value\": \"Phoo\"},\n-                        \"14\": {\"tag\": \"Class\", \"class name index\": 13, \"class internal name\": \"Phoo\"},\n-                        \"15\": {\"tag\": \"Utf8\", \"value\": \"RuntimeVisibleAnnotations\"},\n-                        \"16\": {\"tag\": \"Utf8\", \"value\": \"flfl\"},\n-                        \"17\": {\"tag\": \"Float\", \"value\": \"0.0\"},\n-                        \"18\": {\"tag\": \"Utf8\", \"value\": \"frfl\"},\n-                        \"19\": {\"tag\": \"Float\", \"value\": \"1.0\"},\n-                        \"20\": {\"tag\": \"Utf8\", \"value\": \"AnnotationDefault\"},\n-                        \"21\": {\"tag\": \"Integer\", \"value\": \"1\"},\n-                        \"22\": {\"tag\": \"Integer\", \"value\": \"12\"},\n-                        \"23\": {\"tag\": \"Integer\", \"value\": \"99\"},\n-                        \"24\": {\"tag\": \"Utf8\", \"value\": \"LPhee;\"},\n-                        \"25\": {\"tag\": \"Double\", \"value\": \"1.3\"},\n-                        \"27\": {\"tag\": \"Utf8\", \"value\": \"LBoo;\"},\n-                        \"28\": {\"tag\": \"Utf8\", \"value\": \"BOO\"},\n-                        \"29\": {\"tag\": \"Float\", \"value\": \"3.7\"},\n-                        \"30\": {\"tag\": \"Integer\", \"value\": \"33\"},\n-                        \"31\": {\"tag\": \"Long\", \"value\": \"3333\"},\n-                        \"33\": {\"tag\": \"Integer\", \"value\": \"25\"},\n-                        \"34\": {\"tag\": \"Utf8\", \"value\": \"param\"},\n-                        \"35\": {\"tag\": \"Integer\", \"value\": \"3\"},\n-                        \"36\": {\"tag\": \"Utf8\", \"value\": \"RuntimeVisibleParameterAnnotations\"},\n-                        \"37\": {\"tag\": \"Float\", \"value\": \"22.0\"},\n-                        \"38\": {\"tag\": \"Float\", \"value\": \"11.0\"},\n-                        \"39\": {\"tag\": \"Utf8\", \"value\": \"RuntimeInvisibleParameterAnnotations\"},\n-                        \"40\": {\"tag\": \"Float\", \"value\": \"-22.0\"},\n-                        \"41\": {\"tag\": \"Float\", \"value\": \"-11.0\"},\n-                        \"42\": {\"tag\": \"Utf8\", \"value\": \"Exceptions\"},\n-                        \"43\": {\"tag\": \"Utf8\", \"value\": \"Bee\"},\n-                        \"44\": {\"tag\": \"Class\", \"class name index\": 43, \"class internal name\": \"Bee\"},\n-                        \"45\": {\"tag\": \"Utf8\", \"value\": \"Code\"},\n-                        \"46\": {\"tag\": \"Utf8\", \"value\": \"RuntimeInvisibleTypeAnnotations\"},\n-                        \"47\": {\"tag\": \"Utf8\", \"value\": \"RuntimeVisibleTypeAnnotations\"},\n-                        \"48\": {\"tag\": \"Utf8\", \"value\": \"LFee;\"},\n-                        \"49\": {\"tag\": \"Utf8\", \"value\": \"yes\"},\n-                        \"50\": {\"tag\": \"Integer\", \"value\": \"0\"},\n-                        \"51\": {\"tag\": \"Utf8\", \"value\": \"LocalVariableTable\"},\n-                        \"52\": {\"tag\": \"Utf8\", \"value\": \"LocalVariableTypeTable\"},\n-                        \"53\": {\"tag\": \"Utf8\", \"value\": \"LineNumberTable\"},\n-                        \"54\": {\"tag\": \"Utf8\", \"value\": \"StackMapTable\"},\n-                        \"55\": {\"tag\": \"Utf8\", \"value\": \"SourceFile\"},\n-                        \"56\": {\"tag\": \"Utf8\", \"value\": \"Foo.java\"},\n-                        \"57\": {\"tag\": \"Utf8\", \"value\": \"InnerClasses\"},\n-                        \"58\": {\"tag\": \"Utf8\", \"value\": \"InnerName\"},\n-                        \"59\": {\"tag\": \"Utf8\", \"value\": \"EnclosingMethod\"},\n-                        \"60\": {\"tag\": \"Utf8\", \"value\": \"enclosingMethod\"},\n-                        \"61\": {\"tag\": \"Utf8\", \"value\": \"(Ljava\/util\/Collection;)Ljava\/lang\/Double;\"},\n-                        \"62\": {\"tag\": \"NameAndType\", \"name index\": 60, \"type index\": 61, \"name\": \"enclosingMethod\", \"type\": \"(Ljava\/util\/Collection;)Ljava\/lang\/Double;\"},\n-                        \"63\": {\"tag\": \"Utf8\", \"value\": \"Synthetic\"},\n-                        \"64\": {\"tag\": \"Utf8\", \"value\": \"Signature\"},\n-                        \"65\": {\"tag\": \"Utf8\", \"value\": \"LBoo;LPhee;LPhoo;\"},\n-                        \"66\": {\"tag\": \"Utf8\", \"value\": \"Deprecated\"},\n-                        \"67\": {\"tag\": \"Utf8\", \"value\": \"NestHost\"},\n-                        \"68\": {\"tag\": \"Utf8\", \"value\": \"NestMembers\"},\n-                        \"69\": {\"tag\": \"Utf8\", \"value\": \"Record\"},\n-                        \"70\": {\"tag\": \"Utf8\", \"value\": \"fee\"},\n-                        \"71\": {\"tag\": \"Utf8\", \"value\": \"RuntimeInvisibleAnnotations\"},\n-                        \"72\": {\"tag\": \"Float\", \"value\": \"2.0\"},\n-                        \"73\": {\"tag\": \"Float\", \"value\": \"3.0\"},\n-                        \"74\": {\"tag\": \"Utf8\", \"value\": \"PermittedSubclasses\"}},\n+                        \"11\": {\"tag\": \"Utf8\", \"value\": \"Phoo\"},\n+                        \"12\": {\"tag\": \"Class\", \"class name index\": 11, \"class internal name\": \"Phoo\"},\n+                        \"13\": {\"tag\": \"Utf8\", \"value\": \"phee\"},\n+                        \"14\": {\"tag\": \"Utf8\", \"value\": \"()LBoo;\"},\n+                        \"15\": {\"tag\": \"NameAndType\", \"name index\": 13, \"type index\": 14, \"name\": \"phee\", \"type\": \"()LBoo;\"},\n+                        \"16\": {\"tag\": \"Methodref\", \"owner index\": 12, \"name and type index\": 15, \"owner\": \"Phoo\", \"name\": \"phee\", \"type\": \"()LBoo;\"},\n+                        \"17\": {\"tag\": \"MethodHandle\", \"reference kind\": \"STATIC\", \"reference index\": 16, \"owner\": \"Phoo\", \"name\": \"phee\", \"type\": \"()LBoo;\"},\n+                        \"18\": {\"tag\": \"Utf8\", \"value\": \"bootstrap argument 1\"},\n+                        \"19\": {\"tag\": \"String\", \"value index\": 18, \"value\": \"bootstrap argument 1\"},\n+                        \"20\": {\"tag\": \"Utf8\", \"value\": \"bootstrap argument 2\"},\n+                        \"21\": {\"tag\": \"String\", \"value index\": 20, \"value\": \"bootstrap argument 2\"},\n+                        \"22\": {\"tag\": \"Utf8\", \"value\": \"intfMethod\"},\n+                        \"23\": {\"tag\": \"NameAndType\", \"name index\": 22, \"type index\": 14, \"name\": \"intfMethod\", \"type\": \"()LBoo;\"},\n+                        \"24\": {\"tag\": \"InvokeDynamic\", \"bootstrap method handle index\": 17, \"bootstrap method arguments indexes\": [19, 21], \"name and type index\": 23, \"name\": \"intfMethod\", \"type\": \"()LBoo;\"},\n+                        \"25\": {\"tag\": \"Utf8\", \"value\": \"Phee\"},\n+                        \"26\": {\"tag\": \"Class\", \"class name index\": 25, \"class internal name\": \"Phee\"},\n+                        \"27\": {\"tag\": \"Utf8\", \"value\": \"RuntimeVisibleAnnotations\"},\n+                        \"28\": {\"tag\": \"Utf8\", \"value\": \"flfl\"},\n+                        \"29\": {\"tag\": \"Float\", \"value\": \"0.0\"},\n+                        \"30\": {\"tag\": \"Utf8\", \"value\": \"frfl\"},\n+                        \"31\": {\"tag\": \"Float\", \"value\": \"1.0\"},\n+                        \"32\": {\"tag\": \"Utf8\", \"value\": \"AnnotationDefault\"},\n+                        \"33\": {\"tag\": \"Integer\", \"value\": \"1\"},\n+                        \"34\": {\"tag\": \"Integer\", \"value\": \"12\"},\n+                        \"35\": {\"tag\": \"Integer\", \"value\": \"99\"},\n+                        \"36\": {\"tag\": \"Utf8\", \"value\": \"LPhee;\"},\n+                        \"37\": {\"tag\": \"Double\", \"value\": \"1.3\"},\n+                        \"39\": {\"tag\": \"Utf8\", \"value\": \"LBoo;\"},\n+                        \"40\": {\"tag\": \"Utf8\", \"value\": \"BOO\"},\n+                        \"41\": {\"tag\": \"Float\", \"value\": \"3.7\"},\n+                        \"42\": {\"tag\": \"Integer\", \"value\": \"33\"},\n+                        \"43\": {\"tag\": \"Long\", \"value\": \"3333\"},\n+                        \"45\": {\"tag\": \"Integer\", \"value\": \"25\"},\n+                        \"46\": {\"tag\": \"Utf8\", \"value\": \"param\"},\n+                        \"47\": {\"tag\": \"Integer\", \"value\": \"3\"},\n+                        \"48\": {\"tag\": \"Utf8\", \"value\": \"RuntimeVisibleParameterAnnotations\"},\n+                        \"49\": {\"tag\": \"Float\", \"value\": \"22.0\"},\n+                        \"50\": {\"tag\": \"Float\", \"value\": \"11.0\"},\n+                        \"51\": {\"tag\": \"Utf8\", \"value\": \"RuntimeInvisibleParameterAnnotations\"},\n+                        \"52\": {\"tag\": \"Float\", \"value\": \"-22.0\"},\n+                        \"53\": {\"tag\": \"Float\", \"value\": \"-11.0\"},\n+                        \"54\": {\"tag\": \"Utf8\", \"value\": \"Exceptions\"},\n+                        \"55\": {\"tag\": \"Utf8\", \"value\": \"Bee\"},\n+                        \"56\": {\"tag\": \"Class\", \"class name index\": 55, \"class internal name\": \"Bee\"},\n+                        \"57\": {\"tag\": \"Utf8\", \"value\": \"Code\"},\n+                        \"58\": {\"tag\": \"Utf8\", \"value\": \"RuntimeInvisibleTypeAnnotations\"},\n+                        \"59\": {\"tag\": \"Utf8\", \"value\": \"RuntimeVisibleTypeAnnotations\"},\n+                        \"60\": {\"tag\": \"Utf8\", \"value\": \"LFee;\"},\n+                        \"61\": {\"tag\": \"Utf8\", \"value\": \"yes\"},\n+                        \"62\": {\"tag\": \"Integer\", \"value\": \"0\"},\n+                        \"63\": {\"tag\": \"Utf8\", \"value\": \"LocalVariableTable\"},\n+                        \"64\": {\"tag\": \"Utf8\", \"value\": \"LocalVariableTypeTable\"},\n+                        \"65\": {\"tag\": \"Utf8\", \"value\": \"LineNumberTable\"},\n+                        \"66\": {\"tag\": \"Utf8\", \"value\": \"StackMapTable\"},\n+                        \"67\": {\"tag\": \"Utf8\", \"value\": \"SourceFile\"},\n+                        \"68\": {\"tag\": \"Utf8\", \"value\": \"Foo.java\"},\n+                        \"69\": {\"tag\": \"Utf8\", \"value\": \"InnerClasses\"},\n+                        \"70\": {\"tag\": \"Utf8\", \"value\": \"InnerName\"},\n+                        \"71\": {\"tag\": \"Utf8\", \"value\": \"EnclosingMethod\"},\n+                        \"72\": {\"tag\": \"Utf8\", \"value\": \"enclosingMethod\"},\n+                        \"73\": {\"tag\": \"Utf8\", \"value\": \"(Ljava\/util\/Collection;)Ljava\/lang\/Double;\"},\n+                        \"74\": {\"tag\": \"NameAndType\", \"name index\": 72, \"type index\": 73, \"name\": \"enclosingMethod\", \"type\": \"(Ljava\/util\/Collection;)Ljava\/lang\/Double;\"},\n+                        \"75\": {\"tag\": \"Utf8\", \"value\": \"Synthetic\"},\n+                        \"76\": {\"tag\": \"Utf8\", \"value\": \"Signature\"},\n+                        \"77\": {\"tag\": \"Utf8\", \"value\": \"LBoo;LPhee;LPhoo;\"},\n+                        \"78\": {\"tag\": \"Utf8\", \"value\": \"Deprecated\"},\n+                        \"79\": {\"tag\": \"Utf8\", \"value\": \"NestHost\"},\n+                        \"80\": {\"tag\": \"Utf8\", \"value\": \"NestMembers\"},\n+                        \"81\": {\"tag\": \"Utf8\", \"value\": \"Record\"},\n+                        \"82\": {\"tag\": \"Utf8\", \"value\": \"fee\"},\n+                        \"83\": {\"tag\": \"Utf8\", \"value\": \"RuntimeInvisibleAnnotations\"},\n+                        \"84\": {\"tag\": \"Float\", \"value\": \"2.0\"},\n+                        \"85\": {\"tag\": \"Float\", \"value\": \"3.0\"},\n+                        \"86\": {\"tag\": \"Utf8\", \"value\": \"PermittedSubclasses\"},\n+                        \"87\": {\"tag\": \"Utf8\", \"value\": \"BootstrapMethods\"}},\n@@ -448,0 +489,2 @@\n+                    \"bootstrap methods\": [\n+                        {\"index\": 0, \"kind\": \"STATIC\", \"owner\": \"Phoo\", \"name\": \"phee\", \"args\": [\"bootstrap argument 1\", \"bootstrap argument 2\"]}],\n@@ -471,1 +514,1 @@\n-                                    {\"start\": 0, \"end\": 7, \"slot\": 2, \"name\": \"variable\", \"type\": \"LPhoo;\"}],\n+                                    {\"start\": 0, \"end\": 12, \"slot\": 2, \"name\": \"variable\", \"type\": \"LPhoo;\"}],\n@@ -473,1 +516,1 @@\n-                                    {\"start\": 0, \"end\": 7, \"slot\": 2, \"name\": \"variable\", \"signature\": \"LPhoo;\"}],\n+                                    {\"start\": 0, \"end\": 12, \"slot\": 2, \"name\": \"variable\", \"signature\": \"LPhoo;\"}],\n@@ -478,1 +521,1 @@\n-                                    {\"start\": 7, \"line number\": 4}],\n+                                    {\"start\": 12, \"line number\": 4}],\n@@ -481,1 +524,1 @@\n-                                    \"7\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]}},\n+                                    \"12\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]}},\n@@ -487,1 +530,1 @@\n-                                \"\/\/try block 1 start\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n+                                \"\/\/try block 1 start\": {\"start\": 0, \"end\": 12, \"handler\": 12, \"catch type\": \"Phee\"},\n@@ -493,5 +536,6 @@\n-                                \"6\": {\"opcode\": \"RETURN\"},\n-                                \"\/\/stack map frame @7\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]},\n-                                \"\/\/try block 1 end\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n-                                \"\/\/exception handler 1 start\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n-                                \"7\": {\"opcode\": \"ATHROW\"},\n+                                \"6\": {\"opcode\": \"INVOKEDYNAMIC\", \"name\": \"intfMethod\", \"descriptor\": \"()LBoo;\", \"bootstrap method\": \"STATIC Phoo::phee\", \"arguments\": [\"bootstrap argument 1\", \"bootstrap argument 2\"]},\n+                                \"11\": {\"opcode\": \"RETURN\"},\n+                                \"\/\/stack map frame @12\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]},\n+                                \"\/\/try block 1 end\": {\"start\": 0, \"end\": 12, \"handler\": 12, \"catch type\": \"Phee\"},\n+                                \"\/\/exception handler 1 start\": {\"start\": 0, \"end\": 12, \"handler\": 12, \"catch type\": \"Phee\"},\n+                                \"12\": {\"opcode\": \"ATHROW\"},\n@@ -499,1 +543,1 @@\n-                                    \"handler 1\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"type\": \"Phee\"}}}}]}\n+                                    \"handler 1\": {\"start\": 0, \"end\": 12, \"handler\": 12, \"type\": \"Phee\"}}}}]}\n@@ -514,1 +558,1 @@\n-                    \"attributes\": [\"SourceFile\", \"InnerClasses\", \"EnclosingMethod\", \"Synthetic\", \"Signature\", \"Deprecated\", \"NestHost\", \"NestMembers\", \"Record\", \"RuntimeInvisibleAnnotations\", \"PermittedSubclasses\"],\n+                    \"attributes\": [\"SourceFile\", \"InnerClasses\", \"EnclosingMethod\", \"Synthetic\", \"Signature\", \"Deprecated\", \"NestHost\", \"NestMembers\", \"Record\", \"RuntimeInvisibleAnnotations\", \"PermittedSubclasses\", \"BootstrapMethods\"],\n@@ -518,0 +562,2 @@\n+                    \"bootstrap methods\": [\n+                        {\"index\": 0, \"kind\": \"STATIC\", \"owner\": \"Phoo\", \"name\": \"phee\", \"args\": [\"bootstrap argument 1\", \"bootstrap argument 2\"]}],\n@@ -534,1 +580,1 @@\n-                                    \"7\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]}},\n+                                    \"12\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]}},\n@@ -536,1 +582,1 @@\n-                                \"\/\/try block 1 start\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n+                                \"\/\/try block 1 start\": {\"start\": 0, \"end\": 12, \"handler\": 12, \"catch type\": \"Phee\"},\n@@ -542,5 +588,6 @@\n-                                \"6\": {\"opcode\": \"RETURN\"},\n-                                \"\/\/stack map frame @7\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]},\n-                                \"\/\/try block 1 end\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n-                                \"\/\/exception handler 1 start\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n-                                \"7\": {\"opcode\": \"ATHROW\"},\n+                                \"6\": {\"opcode\": \"INVOKEDYNAMIC\", \"name\": \"intfMethod\", \"descriptor\": \"()LBoo;\", \"bootstrap method\": \"STATIC Phoo::phee\", \"arguments\": [\"bootstrap argument 1\", \"bootstrap argument 2\"]},\n+                                \"11\": {\"opcode\": \"RETURN\"},\n+                                \"\/\/stack map frame @12\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]},\n+                                \"\/\/try block 1 end\": {\"start\": 0, \"end\": 12, \"handler\": 12, \"catch type\": \"Phee\"},\n+                                \"\/\/exception handler 1 start\": {\"start\": 0, \"end\": 12, \"handler\": 12, \"catch type\": \"Phee\"},\n+                                \"12\": {\"opcode\": \"ATHROW\"},\n@@ -548,1 +595,1 @@\n-                                    \"handler 1\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"type\": \"Phee\"}}}}]}\n+                                    \"handler 1\": {\"start\": 0, \"end\": 12, \"handler\": 12, \"type\": \"Phee\"}}}}]}\n@@ -563,1 +610,1 @@\n-                    \"attributes\": [\"SourceFile\", \"InnerClasses\", \"EnclosingMethod\", \"Synthetic\", \"Signature\", \"Deprecated\", \"NestHost\", \"NestMembers\", \"Record\", \"RuntimeInvisibleAnnotations\", \"PermittedSubclasses\"],\n+                    \"attributes\": [\"SourceFile\", \"InnerClasses\", \"EnclosingMethod\", \"Synthetic\", \"Signature\", \"Deprecated\", \"NestHost\", \"NestMembers\", \"Record\", \"RuntimeInvisibleAnnotations\", \"PermittedSubclasses\", \"BootstrapMethods\"],\n@@ -590,1 +637,1 @@\n-                    <attributes><attribute>SourceFile<\/attribute><attribute>InnerClasses<\/attribute><attribute>EnclosingMethod<\/attribute><attribute>Synthetic<\/attribute><attribute>Signature<\/attribute><attribute>Deprecated<\/attribute><attribute>NestHost<\/attribute><attribute>NestMembers<\/attribute><attribute>Record<\/attribute><attribute>RuntimeInvisibleAnnotations<\/attribute><attribute>PermittedSubclasses<\/attribute><\/attributes>\n+                    <attributes><attribute>SourceFile<\/attribute><attribute>InnerClasses<\/attribute><attribute>EnclosingMethod<\/attribute><attribute>Synthetic<\/attribute><attribute>Signature<\/attribute><attribute>Deprecated<\/attribute><attribute>NestHost<\/attribute><attribute>NestMembers<\/attribute><attribute>Record<\/attribute><attribute>RuntimeInvisibleAnnotations<\/attribute><attribute>PermittedSubclasses<\/attribute><attribute>BootstrapMethods<\/attribute><\/attributes>\n@@ -602,62 +649,75 @@\n-                        <_11><tag>Utf8<\/tag><value>Phee<\/value><\/_11>\n-                        <_12><tag>Class<\/tag><class_name_index>11<\/class_name_index><class_internal_name>Phee<\/class_internal_name><\/_12>\n-                        <_13><tag>Utf8<\/tag><value>Phoo<\/value><\/_13>\n-                        <_14><tag>Class<\/tag><class_name_index>13<\/class_name_index><class_internal_name>Phoo<\/class_internal_name><\/_14>\n-                        <_15><tag>Utf8<\/tag><value>RuntimeVisibleAnnotations<\/value><\/_15>\n-                        <_16><tag>Utf8<\/tag><value>flfl<\/value><\/_16>\n-                        <_17><tag>Float<\/tag><value>0.0<\/value><\/_17>\n-                        <_18><tag>Utf8<\/tag><value>frfl<\/value><\/_18>\n-                        <_19><tag>Float<\/tag><value>1.0<\/value><\/_19>\n-                        <_20><tag>Utf8<\/tag><value>AnnotationDefault<\/value><\/_20>\n-                        <_21><tag>Integer<\/tag><value>1<\/value><\/_21>\n-                        <_22><tag>Integer<\/tag><value>12<\/value><\/_22>\n-                        <_23><tag>Integer<\/tag><value>99<\/value><\/_23>\n-                        <_24><tag>Utf8<\/tag><value>LPhee;<\/value><\/_24>\n-                        <_25><tag>Double<\/tag><value>1.3<\/value><\/_25>\n-                        <_27><tag>Utf8<\/tag><value>LBoo;<\/value><\/_27>\n-                        <_28><tag>Utf8<\/tag><value>BOO<\/value><\/_28>\n-                        <_29><tag>Float<\/tag><value>3.7<\/value><\/_29>\n-                        <_30><tag>Integer<\/tag><value>33<\/value><\/_30>\n-                        <_31><tag>Long<\/tag><value>3333<\/value><\/_31>\n-                        <_33><tag>Integer<\/tag><value>25<\/value><\/_33>\n-                        <_34><tag>Utf8<\/tag><value>param<\/value><\/_34>\n-                        <_35><tag>Integer<\/tag><value>3<\/value><\/_35>\n-                        <_36><tag>Utf8<\/tag><value>RuntimeVisibleParameterAnnotations<\/value><\/_36>\n-                        <_37><tag>Float<\/tag><value>22.0<\/value><\/_37>\n-                        <_38><tag>Float<\/tag><value>11.0<\/value><\/_38>\n-                        <_39><tag>Utf8<\/tag><value>RuntimeInvisibleParameterAnnotations<\/value><\/_39>\n-                        <_40><tag>Float<\/tag><value>-22.0<\/value><\/_40>\n-                        <_41><tag>Float<\/tag><value>-11.0<\/value><\/_41>\n-                        <_42><tag>Utf8<\/tag><value>Exceptions<\/value><\/_42>\n-                        <_43><tag>Utf8<\/tag><value>Bee<\/value><\/_43>\n-                        <_44><tag>Class<\/tag><class_name_index>43<\/class_name_index><class_internal_name>Bee<\/class_internal_name><\/_44>\n-                        <_45><tag>Utf8<\/tag><value>Code<\/value><\/_45>\n-                        <_46><tag>Utf8<\/tag><value>RuntimeInvisibleTypeAnnotations<\/value><\/_46>\n-                        <_47><tag>Utf8<\/tag><value>RuntimeVisibleTypeAnnotations<\/value><\/_47>\n-                        <_48><tag>Utf8<\/tag><value>LFee;<\/value><\/_48>\n-                        <_49><tag>Utf8<\/tag><value>yes<\/value><\/_49>\n-                        <_50><tag>Integer<\/tag><value>0<\/value><\/_50>\n-                        <_51><tag>Utf8<\/tag><value>LocalVariableTable<\/value><\/_51>\n-                        <_52><tag>Utf8<\/tag><value>LocalVariableTypeTable<\/value><\/_52>\n-                        <_53><tag>Utf8<\/tag><value>LineNumberTable<\/value><\/_53>\n-                        <_54><tag>Utf8<\/tag><value>StackMapTable<\/value><\/_54>\n-                        <_55><tag>Utf8<\/tag><value>SourceFile<\/value><\/_55>\n-                        <_56><tag>Utf8<\/tag><value>Foo.java<\/value><\/_56>\n-                        <_57><tag>Utf8<\/tag><value>InnerClasses<\/value><\/_57>\n-                        <_58><tag>Utf8<\/tag><value>InnerName<\/value><\/_58>\n-                        <_59><tag>Utf8<\/tag><value>EnclosingMethod<\/value><\/_59>\n-                        <_60><tag>Utf8<\/tag><value>enclosingMethod<\/value><\/_60>\n-                        <_61><tag>Utf8<\/tag><value>(Ljava\/util\/Collection;)Ljava\/lang\/Double;<\/value><\/_61>\n-                        <_62><tag>NameAndType<\/tag><name_index>60<\/name_index><type_index>61<\/type_index><name>enclosingMethod<\/name><type>(Ljava\/util\/Collection;)Ljava\/lang\/Double;<\/type><\/_62>\n-                        <_63><tag>Utf8<\/tag><value>Synthetic<\/value><\/_63>\n-                        <_64><tag>Utf8<\/tag><value>Signature<\/value><\/_64>\n-                        <_65><tag>Utf8<\/tag><value>LBoo;LPhee;LPhoo;<\/value><\/_65>\n-                        <_66><tag>Utf8<\/tag><value>Deprecated<\/value><\/_66>\n-                        <_67><tag>Utf8<\/tag><value>NestHost<\/value><\/_67>\n-                        <_68><tag>Utf8<\/tag><value>NestMembers<\/value><\/_68>\n-                        <_69><tag>Utf8<\/tag><value>Record<\/value><\/_69>\n-                        <_70><tag>Utf8<\/tag><value>fee<\/value><\/_70>\n-                        <_71><tag>Utf8<\/tag><value>RuntimeInvisibleAnnotations<\/value><\/_71>\n-                        <_72><tag>Float<\/tag><value>2.0<\/value><\/_72>\n-                        <_73><tag>Float<\/tag><value>3.0<\/value><\/_73>\n-                        <_74><tag>Utf8<\/tag><value>PermittedSubclasses<\/value><\/_74><\/constant_pool>\n+                        <_11><tag>Utf8<\/tag><value>Phoo<\/value><\/_11>\n+                        <_12><tag>Class<\/tag><class_name_index>11<\/class_name_index><class_internal_name>Phoo<\/class_internal_name><\/_12>\n+                        <_13><tag>Utf8<\/tag><value>phee<\/value><\/_13>\n+                        <_14><tag>Utf8<\/tag><value>()LBoo;<\/value><\/_14>\n+                        <_15><tag>NameAndType<\/tag><name_index>13<\/name_index><type_index>14<\/type_index><name>phee<\/name><type>()LBoo;<\/type><\/_15>\n+                        <_16><tag>Methodref<\/tag><owner_index>12<\/owner_index><name_and_type_index>15<\/name_and_type_index><owner>Phoo<\/owner><name>phee<\/name><type>()LBoo;<\/type><\/_16>\n+                        <_17><tag>MethodHandle<\/tag><reference_kind>STATIC<\/reference_kind><reference_index>16<\/reference_index><owner>Phoo<\/owner><name>phee<\/name><type>()LBoo;<\/type><\/_17>\n+                        <_18><tag>Utf8<\/tag><value>bootstrap argument 1<\/value><\/_18>\n+                        <_19><tag>String<\/tag><value_index>18<\/value_index><value>bootstrap argument 1<\/value><\/_19>\n+                        <_20><tag>Utf8<\/tag><value>bootstrap argument 2<\/value><\/_20>\n+                        <_21><tag>String<\/tag><value_index>20<\/value_index><value>bootstrap argument 2<\/value><\/_21>\n+                        <_22><tag>Utf8<\/tag><value>intfMethod<\/value><\/_22>\n+                        <_23><tag>NameAndType<\/tag><name_index>22<\/name_index><type_index>14<\/type_index><name>intfMethod<\/name><type>()LBoo;<\/type><\/_23>\n+                        <_24><tag>InvokeDynamic<\/tag><bootstrap_method_handle_index>17<\/bootstrap_method_handle_index><bootstrap_method_arguments_indexes><index>19<\/index><index>21<\/index><\/bootstrap_method_arguments_indexes><name_and_type_index>23<\/name_and_type_index><name>intfMethod<\/name><type>()LBoo;<\/type><\/_24>\n+                        <_25><tag>Utf8<\/tag><value>Phee<\/value><\/_25>\n+                        <_26><tag>Class<\/tag><class_name_index>25<\/class_name_index><class_internal_name>Phee<\/class_internal_name><\/_26>\n+                        <_27><tag>Utf8<\/tag><value>RuntimeVisibleAnnotations<\/value><\/_27>\n+                        <_28><tag>Utf8<\/tag><value>flfl<\/value><\/_28>\n+                        <_29><tag>Float<\/tag><value>0.0<\/value><\/_29>\n+                        <_30><tag>Utf8<\/tag><value>frfl<\/value><\/_30>\n+                        <_31><tag>Float<\/tag><value>1.0<\/value><\/_31>\n+                        <_32><tag>Utf8<\/tag><value>AnnotationDefault<\/value><\/_32>\n+                        <_33><tag>Integer<\/tag><value>1<\/value><\/_33>\n+                        <_34><tag>Integer<\/tag><value>12<\/value><\/_34>\n+                        <_35><tag>Integer<\/tag><value>99<\/value><\/_35>\n+                        <_36><tag>Utf8<\/tag><value>LPhee;<\/value><\/_36>\n+                        <_37><tag>Double<\/tag><value>1.3<\/value><\/_37>\n+                        <_39><tag>Utf8<\/tag><value>LBoo;<\/value><\/_39>\n+                        <_40><tag>Utf8<\/tag><value>BOO<\/value><\/_40>\n+                        <_41><tag>Float<\/tag><value>3.7<\/value><\/_41>\n+                        <_42><tag>Integer<\/tag><value>33<\/value><\/_42>\n+                        <_43><tag>Long<\/tag><value>3333<\/value><\/_43>\n+                        <_45><tag>Integer<\/tag><value>25<\/value><\/_45>\n+                        <_46><tag>Utf8<\/tag><value>param<\/value><\/_46>\n+                        <_47><tag>Integer<\/tag><value>3<\/value><\/_47>\n+                        <_48><tag>Utf8<\/tag><value>RuntimeVisibleParameterAnnotations<\/value><\/_48>\n+                        <_49><tag>Float<\/tag><value>22.0<\/value><\/_49>\n+                        <_50><tag>Float<\/tag><value>11.0<\/value><\/_50>\n+                        <_51><tag>Utf8<\/tag><value>RuntimeInvisibleParameterAnnotations<\/value><\/_51>\n+                        <_52><tag>Float<\/tag><value>-22.0<\/value><\/_52>\n+                        <_53><tag>Float<\/tag><value>-11.0<\/value><\/_53>\n+                        <_54><tag>Utf8<\/tag><value>Exceptions<\/value><\/_54>\n+                        <_55><tag>Utf8<\/tag><value>Bee<\/value><\/_55>\n+                        <_56><tag>Class<\/tag><class_name_index>55<\/class_name_index><class_internal_name>Bee<\/class_internal_name><\/_56>\n+                        <_57><tag>Utf8<\/tag><value>Code<\/value><\/_57>\n+                        <_58><tag>Utf8<\/tag><value>RuntimeInvisibleTypeAnnotations<\/value><\/_58>\n+                        <_59><tag>Utf8<\/tag><value>RuntimeVisibleTypeAnnotations<\/value><\/_59>\n+                        <_60><tag>Utf8<\/tag><value>LFee;<\/value><\/_60>\n+                        <_61><tag>Utf8<\/tag><value>yes<\/value><\/_61>\n+                        <_62><tag>Integer<\/tag><value>0<\/value><\/_62>\n+                        <_63><tag>Utf8<\/tag><value>LocalVariableTable<\/value><\/_63>\n+                        <_64><tag>Utf8<\/tag><value>LocalVariableTypeTable<\/value><\/_64>\n+                        <_65><tag>Utf8<\/tag><value>LineNumberTable<\/value><\/_65>\n+                        <_66><tag>Utf8<\/tag><value>StackMapTable<\/value><\/_66>\n+                        <_67><tag>Utf8<\/tag><value>SourceFile<\/value><\/_67>\n+                        <_68><tag>Utf8<\/tag><value>Foo.java<\/value><\/_68>\n+                        <_69><tag>Utf8<\/tag><value>InnerClasses<\/value><\/_69>\n+                        <_70><tag>Utf8<\/tag><value>InnerName<\/value><\/_70>\n+                        <_71><tag>Utf8<\/tag><value>EnclosingMethod<\/value><\/_71>\n+                        <_72><tag>Utf8<\/tag><value>enclosingMethod<\/value><\/_72>\n+                        <_73><tag>Utf8<\/tag><value>(Ljava\/util\/Collection;)Ljava\/lang\/Double;<\/value><\/_73>\n+                        <_74><tag>NameAndType<\/tag><name_index>72<\/name_index><type_index>73<\/type_index><name>enclosingMethod<\/name><type>(Ljava\/util\/Collection;)Ljava\/lang\/Double;<\/type><\/_74>\n+                        <_75><tag>Utf8<\/tag><value>Synthetic<\/value><\/_75>\n+                        <_76><tag>Utf8<\/tag><value>Signature<\/value><\/_76>\n+                        <_77><tag>Utf8<\/tag><value>LBoo;LPhee;LPhoo;<\/value><\/_77>\n+                        <_78><tag>Utf8<\/tag><value>Deprecated<\/value><\/_78>\n+                        <_79><tag>Utf8<\/tag><value>NestHost<\/value><\/_79>\n+                        <_80><tag>Utf8<\/tag><value>NestMembers<\/value><\/_80>\n+                        <_81><tag>Utf8<\/tag><value>Record<\/value><\/_81>\n+                        <_82><tag>Utf8<\/tag><value>fee<\/value><\/_82>\n+                        <_83><tag>Utf8<\/tag><value>RuntimeInvisibleAnnotations<\/value><\/_83>\n+                        <_84><tag>Float<\/tag><value>2.0<\/value><\/_84>\n+                        <_85><tag>Float<\/tag><value>3.0<\/value><\/_85>\n+                        <_86><tag>Utf8<\/tag><value>PermittedSubclasses<\/value><\/_86>\n+                        <_87><tag>Utf8<\/tag><value>BootstrapMethods<\/value><\/_87><\/constant_pool>\n@@ -683,0 +743,2 @@\n+                    <bootstrap_methods>\n+                        <bm><index>0<\/index><kind>STATIC<\/kind><owner>Phoo<\/owner><name>phee<\/name><args><arg>bootstrap argument 1<\/arg><arg>bootstrap argument 2<\/arg><\/args><\/bm><\/bootstrap_methods>\n@@ -708,1 +770,1 @@\n-                                    <_1><start>0<\/start><end>7<\/end><slot>2<\/slot><name>variable<\/name><type>LPhoo;<\/type><\/_1><\/local_variables>\n+                                    <_1><start>0<\/start><end>12<\/end><slot>2<\/slot><name>variable<\/name><type>LPhoo;<\/type><\/_1><\/local_variables>\n@@ -710,1 +772,1 @@\n-                                    <_1><start>0<\/start><end>7<\/end><slot>2<\/slot><name>variable<\/name><signature>LPhoo;<\/signature><\/_1><\/local_variable_types>\n+                                    <_1><start>0<\/start><end>12<\/end><slot>2<\/slot><name>variable<\/name><signature>LPhoo;<\/signature><\/_1><\/local_variable_types>\n@@ -715,1 +777,1 @@\n-                                    <_4><start>7<\/start><line_number>4<\/line_number><\/_4><\/line_numbers>\n+                                    <_4><start>12<\/start><line_number>4<\/line_number><\/_4><\/line_numbers>\n@@ -718,1 +780,1 @@\n-                                    <_7><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/_7><\/stack_map_frames>\n+                                    <_12><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/_12><\/stack_map_frames>\n@@ -724,1 +786,1 @@\n-                                <__try_block_1_start><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_start>\n+                                <__try_block_1_start><start>0<\/start><end>12<\/end><handler>12<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_start>\n@@ -730,5 +792,6 @@\n-                                <_6><opcode>RETURN<\/opcode><\/_6>\n-                                <__stack_map_frame__7><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/__stack_map_frame__7>\n-                                <__try_block_1_end><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_end>\n-                                <__exception_handler_1_start><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__exception_handler_1_start>\n-                                <_7><opcode>ATHROW<\/opcode><\/_7>\n+                                <_6><opcode>INVOKEDYNAMIC<\/opcode><name>intfMethod<\/name><descriptor>()LBoo;<\/descriptor><bootstrap_method>STATIC Phoo::phee<\/bootstrap_method><arguments><arg>bootstrap argument 1<\/arg><arg>bootstrap argument 2<\/arg><\/arguments><\/_6>\n+                                <_11><opcode>RETURN<\/opcode><\/_11>\n+                                <__stack_map_frame__12><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/__stack_map_frame__12>\n+                                <__try_block_1_end><start>0<\/start><end>12<\/end><handler>12<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_end>\n+                                <__exception_handler_1_start><start>0<\/start><end>12<\/end><handler>12<\/handler><catch_type>Phee<\/catch_type><\/__exception_handler_1_start>\n+                                <_12><opcode>ATHROW<\/opcode><\/_12>\n@@ -736,1 +799,1 @@\n-                                    <handler_1><start>0<\/start><end>7<\/end><handler>7<\/handler><type>Phee<\/type><\/handler_1><\/exception_handlers><\/code><\/method><\/methods><\/class>\n+                                    <handler_1><start>0<\/start><end>12<\/end><handler>12<\/handler><type>Phee<\/type><\/handler_1><\/exception_handlers><\/code><\/method><\/methods><\/class>\n@@ -753,1 +816,1 @@\n-                    <attributes><attribute>SourceFile<\/attribute><attribute>InnerClasses<\/attribute><attribute>EnclosingMethod<\/attribute><attribute>Synthetic<\/attribute><attribute>Signature<\/attribute><attribute>Deprecated<\/attribute><attribute>NestHost<\/attribute><attribute>NestMembers<\/attribute><attribute>Record<\/attribute><attribute>RuntimeInvisibleAnnotations<\/attribute><attribute>PermittedSubclasses<\/attribute><\/attributes>\n+                    <attributes><attribute>SourceFile<\/attribute><attribute>InnerClasses<\/attribute><attribute>EnclosingMethod<\/attribute><attribute>Synthetic<\/attribute><attribute>Signature<\/attribute><attribute>Deprecated<\/attribute><attribute>NestHost<\/attribute><attribute>NestMembers<\/attribute><attribute>Record<\/attribute><attribute>RuntimeInvisibleAnnotations<\/attribute><attribute>PermittedSubclasses<\/attribute><attribute>BootstrapMethods<\/attribute><\/attributes>\n@@ -757,0 +820,2 @@\n+                    <bootstrap_methods>\n+                        <bm><index>0<\/index><kind>STATIC<\/kind><owner>Phoo<\/owner><name>phee<\/name><args><arg>bootstrap argument 1<\/arg><arg>bootstrap argument 2<\/arg><\/args><\/bm><\/bootstrap_methods>\n@@ -775,1 +840,1 @@\n-                                    <_7><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/_7><\/stack_map_frames>\n+                                    <_12><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/_12><\/stack_map_frames>\n@@ -777,1 +842,1 @@\n-                                <__try_block_1_start><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_start>\n+                                <__try_block_1_start><start>0<\/start><end>12<\/end><handler>12<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_start>\n@@ -783,5 +848,6 @@\n-                                <_6><opcode>RETURN<\/opcode><\/_6>\n-                                <__stack_map_frame__7><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/__stack_map_frame__7>\n-                                <__try_block_1_end><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_end>\n-                                <__exception_handler_1_start><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__exception_handler_1_start>\n-                                <_7><opcode>ATHROW<\/opcode><\/_7>\n+                                <_6><opcode>INVOKEDYNAMIC<\/opcode><name>intfMethod<\/name><descriptor>()LBoo;<\/descriptor><bootstrap_method>STATIC Phoo::phee<\/bootstrap_method><arguments><arg>bootstrap argument 1<\/arg><arg>bootstrap argument 2<\/arg><\/arguments><\/_6>\n+                                <_11><opcode>RETURN<\/opcode><\/_11>\n+                                <__stack_map_frame__12><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/__stack_map_frame__12>\n+                                <__try_block_1_end><start>0<\/start><end>12<\/end><handler>12<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_end>\n+                                <__exception_handler_1_start><start>0<\/start><end>12<\/end><handler>12<\/handler><catch_type>Phee<\/catch_type><\/__exception_handler_1_start>\n+                                <_12><opcode>ATHROW<\/opcode><\/_12>\n@@ -789,1 +855,1 @@\n-                                    <handler_1><start>0<\/start><end>7<\/end><handler>7<\/handler><type>Phee<\/type><\/handler_1><\/exception_handlers><\/code><\/method><\/methods><\/class>\n+                                    <handler_1><start>0<\/start><end>12<\/end><handler>12<\/handler><type>Phee<\/type><\/handler_1><\/exception_handlers><\/code><\/method><\/methods><\/class>\n@@ -806,1 +872,1 @@\n-                    <attributes><attribute>SourceFile<\/attribute><attribute>InnerClasses<\/attribute><attribute>EnclosingMethod<\/attribute><attribute>Synthetic<\/attribute><attribute>Signature<\/attribute><attribute>Deprecated<\/attribute><attribute>NestHost<\/attribute><attribute>NestMembers<\/attribute><attribute>Record<\/attribute><attribute>RuntimeInvisibleAnnotations<\/attribute><attribute>PermittedSubclasses<\/attribute><\/attributes>\n+                    <attributes><attribute>SourceFile<\/attribute><attribute>InnerClasses<\/attribute><attribute>EnclosingMethod<\/attribute><attribute>Synthetic<\/attribute><attribute>Signature<\/attribute><attribute>Deprecated<\/attribute><attribute>NestHost<\/attribute><attribute>NestMembers<\/attribute><attribute>Record<\/attribute><attribute>RuntimeInvisibleAnnotations<\/attribute><attribute>PermittedSubclasses<\/attribute><attribute>BootstrapMethods<\/attribute><\/attributes>\n@@ -825,1 +891,1 @@\n-        assertEquals(node.walk().count(), 509);\n+        assertEquals(node.walk().count(), 588);\n@@ -831,1 +897,1 @@\n-        assertEquals(node.walk().count(), 128);\n+        assertEquals(node.walk().count(), 146);\n@@ -837,1 +903,1 @@\n-        assertEquals(node.walk().count(), 41);\n+        assertEquals(node.walk().count(), 42);\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":321,"deletions":255,"binary":false,"changes":576,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8325485\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -488,1 +488,1 @@\n-            for (int i = from; i < length; i++) {\n+            for (int i = from; i < from + length; i++) {\n@@ -560,1 +560,1 @@\n-                            yield code.hash(p[0] + 1, ins.sizeInBytes());\n+                            yield code.hash(p[0] + 1, ins.sizeInBytes() - 1);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,388 +72,9 @@\n-                                    case CodeModel com -> mb.withCode(cb -> cb.transforming(CodeStackTracker.of(), cob -> {\n-                                        var labels = new HashMap<Label, Label>();\n-                                        for (var coe : com) {\n-                                            switch (coe) {\n-                                                case ArrayLoadInstruction i -> {\n-                                                    switch (i.typeKind()) {\n-                                                        case ByteType -> cob.baload();\n-                                                        case ShortType -> cob.saload();\n-                                                        case IntType -> cob.iaload();\n-                                                        case FloatType -> cob.faload();\n-                                                        case LongType -> cob.laload();\n-                                                        case DoubleType -> cob.daload();\n-                                                        case ReferenceType -> cob.aaload();\n-                                                        case CharType -> cob.caload();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case ArrayStoreInstruction i -> {\n-                                                    switch (i.typeKind()) {\n-                                                        case ByteType -> cob.bastore();\n-                                                        case ShortType -> cob.sastore();\n-                                                        case IntType -> cob.iastore();\n-                                                        case FloatType -> cob.fastore();\n-                                                        case LongType -> cob.lastore();\n-                                                        case DoubleType -> cob.dastore();\n-                                                        case ReferenceType -> cob.aastore();\n-                                                        case CharType -> cob.castore();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case BranchInstruction i -> {\n-                                                    var target = labels.computeIfAbsent(i.target(), l -> cob.newLabel());\n-                                                    switch (i.opcode()) {\n-                                                        case GOTO -> cob.goto_(target);\n-                                                        case GOTO_W -> cob.goto_w(target);\n-                                                        case IF_ACMPEQ -> cob.if_acmpeq(target);\n-                                                        case IF_ACMPNE -> cob.if_acmpne(target);\n-                                                        case IF_ICMPEQ -> cob.if_icmpeq(target);\n-                                                        case IF_ICMPGE -> cob.if_icmpge(target);\n-                                                        case IF_ICMPGT -> cob.if_icmpgt(target);\n-                                                        case IF_ICMPLE -> cob.if_icmple(target);\n-                                                        case IF_ICMPLT -> cob.if_icmplt(target);\n-                                                        case IF_ICMPNE -> cob.if_icmpne(target);\n-                                                        case IFNONNULL -> cob.if_nonnull(target);\n-                                                        case IFNULL -> cob.if_null(target);\n-                                                        case IFEQ -> cob.ifeq(target);\n-                                                        case IFGE -> cob.ifge(target);\n-                                                        case IFGT -> cob.ifgt(target);\n-                                                        case IFLE -> cob.ifle(target);\n-                                                        case IFLT -> cob.iflt(target);\n-                                                        case IFNE -> cob.ifne(target);\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case ConstantInstruction i -> {\n-                                                    if (i.constantValue() == null)\n-                                                        if (pathSwitch.nextBoolean()) cob.aconst_null();\n-                                                        else cob.constantInstruction(null);\n-                                                    else switch (i.constantValue()) {\n-                                                        case Integer iVal -> {\n-                                                            if (iVal == 1 && pathSwitch.nextBoolean()) cob.iconst_1();\n-                                                            else if (iVal == 2 && pathSwitch.nextBoolean()) cob.iconst_2();\n-                                                            else if (iVal == 3 && pathSwitch.nextBoolean()) cob.iconst_3();\n-                                                            else if (iVal == 4 && pathSwitch.nextBoolean()) cob.iconst_4();\n-                                                            else if (iVal == 5 && pathSwitch.nextBoolean()) cob.iconst_5();\n-                                                            else if (iVal == -1 && pathSwitch.nextBoolean()) cob.iconst_m1();\n-                                                            else if (iVal >= -128 && iVal <= 127 && pathSwitch.nextBoolean()) cob.bipush(iVal);\n-                                                            else if (iVal >= -32768 && iVal <= 32767 && pathSwitch.nextBoolean()) cob.sipush(iVal);\n-                                                            else cob.constantInstruction(iVal);\n-                                                        }\n-                                                        case Long lVal -> {\n-                                                            if (lVal == 0 && pathSwitch.nextBoolean()) cob.lconst_0();\n-                                                            else if (lVal == 1 && pathSwitch.nextBoolean()) cob.lconst_1();\n-                                                            else cob.constantInstruction(lVal);\n-                                                        }\n-                                                        case Float fVal -> {\n-                                                            if (fVal == 0.0 && pathSwitch.nextBoolean()) cob.fconst_0();\n-                                                            else if (fVal == 1.0 && pathSwitch.nextBoolean()) cob.fconst_1();\n-                                                            else if (fVal == 2.0 && pathSwitch.nextBoolean()) cob.fconst_2();\n-                                                            else cob.constantInstruction(fVal);\n-                                                        }\n-                                                        case Double dVal -> {\n-                                                            if (dVal == 0.0d && pathSwitch.nextBoolean()) cob.dconst_0();\n-                                                            else if (dVal == 1.0d && pathSwitch.nextBoolean()) cob.dconst_1();\n-                                                            else cob.constantInstruction(dVal);\n-                                                        }\n-                                                        default -> cob.constantInstruction(i.constantValue());\n-                                                    }\n-                                                }\n-                                                case ConvertInstruction i -> {\n-                                                    switch (i.fromType()) {\n-                                                        case DoubleType -> {\n-                                                            switch (i.toType()) {\n-                                                                case FloatType -> cob.d2f();\n-                                                                case IntType -> cob.d2i();\n-                                                                case LongType -> cob.d2l();\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        }\n-                                                        case FloatType -> {\n-                                                            switch (i.toType()) {\n-                                                                case DoubleType -> cob.f2d();\n-                                                                case IntType -> cob.f2i();\n-                                                                case LongType -> cob.f2l();\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        }\n-                                                        case IntType -> {\n-                                                            switch (i.toType()) {\n-                                                                case ByteType -> cob.i2b();\n-                                                                case CharType -> cob.i2c();\n-                                                                case DoubleType -> cob.i2d();\n-                                                                case FloatType -> cob.i2f();\n-                                                                case LongType -> cob.i2l();\n-                                                                case ShortType -> cob.i2s();\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        }\n-                                                        case LongType -> {\n-                                                            switch (i.toType()) {\n-                                                                case DoubleType -> cob.l2d();\n-                                                                case FloatType -> cob.l2f();\n-                                                                case IntType -> cob.l2i();\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        }\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case DiscontinuedInstruction.JsrInstruction i ->\n-                                                    cob.with(DiscontinuedInstruction.JsrInstruction.of(i.opcode(), labels.computeIfAbsent(i.target(), l -> cob.newLabel())));\n-                                                case DiscontinuedInstruction.RetInstruction i ->\n-                                                    cob.with(DiscontinuedInstruction.RetInstruction.of(i.opcode(), i.slot()));\n-                                                case FieldInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        switch (i.opcode()) {\n-                                                            case GETFIELD -> cob.getfield(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                            case GETSTATIC -> cob.getstatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                            case PUTFIELD -> cob.putfield(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                            case PUTSTATIC -> cob.putstatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                            default -> throw new AssertionError(\"Should not reach here\");\n-                                                        }\n-                                                    } else {\n-                                                        switch (i.opcode()) {\n-                                                            case GETFIELD -> cob.getfield(i.field());\n-                                                            case GETSTATIC -> cob.getstatic(i.field());\n-                                                            case PUTFIELD -> cob.putfield(i.field());\n-                                                            case PUTSTATIC -> cob.putstatic(i.field());\n-                                                            default -> throw new AssertionError(\"Should not reach here\");\n-                                                        }\n-                                                    }\n-                                                }\n-                                                case InvokeDynamicInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) cob.invokedynamic(i.invokedynamic().asSymbol());\n-                                                    else cob.invokedynamic(i.invokedynamic());\n-                                                }\n-                                                case InvokeInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        if (i.isInterface()) {\n-                                                            switch (i.opcode()) {\n-                                                                case INVOKEINTERFACE -> cob.invokeinterface(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                                case INVOKESPECIAL -> cob.invokespecial(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), true);\n-                                                                case INVOKESTATIC -> cob.invokestatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), true);\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        } else {\n-                                                            switch (i.opcode()) {\n-                                                                case INVOKESPECIAL -> cob.invokespecial(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                                case INVOKESTATIC -> cob.invokestatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                                case INVOKEVIRTUAL -> cob.invokevirtual(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        }\n-                                                    } else {\n-                                                        switch (i.method()) {\n-                                                            case InterfaceMethodRefEntry en -> {\n-                                                                switch (i.opcode()) {\n-                                                                        case INVOKEINTERFACE -> cob.invokeinterface(en);\n-                                                                        case INVOKESPECIAL -> cob.invokespecial(en);\n-                                                                        case INVOKESTATIC -> cob.invokestatic(en);\n-                                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                                }\n-                                                            }\n-                                                            case MethodRefEntry en -> {\n-                                                                switch (i.opcode()) {\n-                                                                        case INVOKESPECIAL -> cob.invokespecial(en);\n-                                                                        case INVOKESTATIC -> cob.invokestatic(en);\n-                                                                        case INVOKEVIRTUAL -> cob.invokevirtual(en);\n-                                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                                }\n-                                                            }\n-                                                            default -> throw new AssertionError(\"Should not reach here\");\n-                                                        }\n-                                                    }\n-                                                }\n-                                                case LoadInstruction i -> {\n-                                                    switch (i.typeKind()) {\n-                                                        case IntType -> cob.iload(i.slot());\n-                                                        case FloatType -> cob.fload(i.slot());\n-                                                        case LongType -> cob.lload(i.slot());\n-                                                        case DoubleType -> cob.dload(i.slot());\n-                                                        case ReferenceType -> cob.aload(i.slot());\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case StoreInstruction i -> {\n-                                                    switch (i.typeKind()) {\n-                                                        case IntType -> cob.istore(i.slot());\n-                                                        case FloatType -> cob.fstore(i.slot());\n-                                                        case LongType -> cob.lstore(i.slot());\n-                                                        case DoubleType -> cob.dstore(i.slot());\n-                                                        case ReferenceType -> cob.astore(i.slot());\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case IncrementInstruction i ->\n-                                                    cob.iinc(i.slot(), i.constant());\n-                                                case LookupSwitchInstruction i ->\n-                                                    cob.lookupswitch(labels.computeIfAbsent(i.defaultTarget(), l -> cob.newLabel()),\n-                                                                     i.cases().stream().map(sc ->\n-                                                                             SwitchCase.of(sc.caseValue(), labels.computeIfAbsent(sc.target(), l -> cob.newLabel()))).toList());\n-                                                case MonitorInstruction i -> {\n-                                                    switch (i.opcode()) {\n-                                                        case MONITORENTER ->  cob.monitorenter();\n-                                                        case MONITOREXIT ->  cob.monitorexit();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case NewMultiArrayInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        cob.multianewarray(i.arrayType().asSymbol(), i.dimensions());\n-                                                    } else {\n-                                                        cob.multianewarray(i.arrayType(), i.dimensions());\n-                                                    }\n-                                                }\n-                                                case NewObjectInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        cob.new_(i.className().asSymbol());\n-                                                    } else {\n-                                                        cob.new_(i.className());\n-                                                    }\n-                                                }\n-                                                case NewPrimitiveArrayInstruction i ->\n-                                                    cob.newarray(i.typeKind());\n-                                                case NewReferenceArrayInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        cob.anewarray(i.componentType().asSymbol());\n-                                                    } else {\n-                                                        cob.anewarray(i.componentType());\n-                                                    }\n-                                                }\n-                                                case NopInstruction i ->\n-                                                    cob.nop();\n-                                                case OperatorInstruction i -> {\n-                                                    switch (i.opcode()) {\n-                                                        case IADD -> cob.iadd();\n-                                                        case LADD -> cob.ladd();\n-                                                        case FADD -> cob.fadd();\n-                                                        case DADD -> cob.dadd();\n-                                                        case ISUB -> cob.isub();\n-                                                        case LSUB -> cob.lsub();\n-                                                        case FSUB -> cob.fsub();\n-                                                        case DSUB -> cob.dsub();\n-                                                        case IMUL -> cob.imul();\n-                                                        case LMUL -> cob.lmul();\n-                                                        case FMUL -> cob.fmul();\n-                                                        case DMUL -> cob.dmul();\n-                                                        case IDIV -> cob.idiv();\n-                                                        case LDIV -> cob.ldiv();\n-                                                        case FDIV -> cob.fdiv();\n-                                                        case DDIV -> cob.ddiv();\n-                                                        case IREM -> cob.irem();\n-                                                        case LREM -> cob.lrem();\n-                                                        case FREM -> cob.frem();\n-                                                        case DREM -> cob.drem();\n-                                                        case INEG -> cob.ineg();\n-                                                        case LNEG -> cob.lneg();\n-                                                        case FNEG -> cob.fneg();\n-                                                        case DNEG -> cob.dneg();\n-                                                        case ISHL -> cob.ishl();\n-                                                        case LSHL -> cob.lshl();\n-                                                        case ISHR -> cob.ishr();\n-                                                        case LSHR -> cob.lshr();\n-                                                        case IUSHR -> cob.iushr();\n-                                                        case LUSHR -> cob.lushr();\n-                                                        case IAND -> cob.iand();\n-                                                        case LAND -> cob.land();\n-                                                        case IOR -> cob.ior();\n-                                                        case LOR -> cob.lor();\n-                                                        case IXOR -> cob.ixor();\n-                                                        case LXOR -> cob.lxor();\n-                                                        case LCMP -> cob.lcmp();\n-                                                        case FCMPL -> cob.fcmpl();\n-                                                        case FCMPG -> cob.fcmpg();\n-                                                        case DCMPL -> cob.dcmpl();\n-                                                        case DCMPG -> cob.dcmpg();\n-                                                        case ARRAYLENGTH -> cob.arraylength();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case ReturnInstruction i -> {\n-                                                    switch (i.typeKind()) {\n-                                                        case IntType -> cob.ireturn();\n-                                                        case FloatType -> cob.freturn();\n-                                                        case LongType -> cob.lreturn();\n-                                                        case DoubleType -> cob.dreturn();\n-                                                        case ReferenceType -> cob.areturn();\n-                                                        case VoidType -> cob.return_();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case StackInstruction i -> {\n-                                                    switch (i.opcode()) {\n-                                                        case POP -> cob.pop();\n-                                                        case POP2 -> cob.pop2();\n-                                                        case DUP -> cob.dup();\n-                                                        case DUP_X1 -> cob.dup_x1();\n-                                                        case DUP_X2 -> cob.dup_x2();\n-                                                        case DUP2 -> cob.dup2();\n-                                                        case DUP2_X1 -> cob.dup2_x1();\n-                                                        case DUP2_X2 -> cob.dup2_x2();\n-                                                        case SWAP -> cob.swap();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case TableSwitchInstruction i ->\n-                                                    cob.tableswitch(i.lowValue(), i.highValue(),\n-                                                                    labels.computeIfAbsent(i.defaultTarget(), l -> cob.newLabel()),\n-                                                                    i.cases().stream().map(sc ->\n-                                                                            SwitchCase.of(sc.caseValue(), labels.computeIfAbsent(sc.target(), l -> cob.newLabel()))).toList());\n-                                                case ThrowInstruction i -> cob.athrow();\n-                                                case TypeCheckInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        switch (i.opcode()) {\n-                                                            case CHECKCAST -> cob.checkcast(i.type().asSymbol());\n-                                                            case INSTANCEOF -> cob.instanceof_(i.type().asSymbol());\n-                                                            default -> throw new AssertionError(\"Should not reach here\");\n-                                                        }\n-                                                    } else {\n-                                                        switch (i.opcode()) {\n-                                                            case CHECKCAST -> cob.checkcast(i.type());\n-                                                            case INSTANCEOF -> cob.instanceof_(i.type());\n-                                                            default -> throw new AssertionError(\"Should not reach here\");\n-                                                        }\n-                                                    }\n-                                                }\n-                                                case CharacterRange pi ->\n-                                                    cob.characterRange(labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n-                                                                       labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()),\n-                                                                       pi.characterRangeStart(), pi.characterRangeEnd(), pi.flags());\n-                                                case ExceptionCatch pi ->\n-                                                    pi.catchType().ifPresentOrElse(\n-                                                            catchType -> cob.exceptionCatch(labels.computeIfAbsent(pi.tryStart(), l -> cob.newLabel()),\n-                                                                                            labels.computeIfAbsent(pi.tryEnd(), l -> cob.newLabel()),\n-                                                                                            labels.computeIfAbsent(pi.handler(), l -> cob.newLabel()),\n-                                                                                            catchType.asSymbol()),\n-                                                            () -> cob.exceptionCatchAll(labels.computeIfAbsent(pi.tryStart(), l -> cob.newLabel()),\n-                                                                                        labels.computeIfAbsent(pi.tryEnd(), l -> cob.newLabel()),\n-                                                                                        labels.computeIfAbsent(pi.handler(), l -> cob.newLabel())));\n-                                                case LabelTarget pi ->\n-                                                    cob.labelBinding(labels.computeIfAbsent(pi.label(), l -> cob.newLabel()));\n-                                                case LineNumber pi ->\n-                                                    cob.lineNumber(pi.line());\n-                                                case LocalVariable pi ->\n-                                                    cob.localVariable(pi.slot(), pi.name().stringValue(), pi.typeSymbol(),\n-                                                                      labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n-                                                                       labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()));\n-                                                case LocalVariableType pi ->\n-                                                    cob.localVariableType(pi.slot(), pi.name().stringValue(),\n-                                                                          Signature.parseFrom(pi.signatureSymbol().signatureString()),\n-                                                                          labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n-                                                                          labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()));\n-                                                case RuntimeInvisibleTypeAnnotationsAttribute a ->\n-                                                    cob.with(RuntimeInvisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), cob, labels)));\n-                                                case RuntimeVisibleTypeAnnotationsAttribute a ->\n-                                                    cob.with(RuntimeVisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), cob, labels)));\n-                                                case StackMapTableAttribute a ->\n-                                                    throw new AssertionError(\"Unexpected StackMapTableAttribute here\");\n-                                                case CustomAttribute a ->\n-                                                    throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n-                                            }\n-                                        }\n-                                        com.findAttribute(Attributes.STACK_MAP_TABLE).ifPresent(smta ->\n-                                                    cob.with(StackMapTableAttribute.of(smta.entries().stream().map(fr ->\n-                                                            StackMapFrameInfo.of(labels.computeIfAbsent(fr.target(), l -> cob.newLabel()),\n-                                                                    transformFrameTypeInfos(fr.locals(), cob, labels),\n-                                                                    transformFrameTypeInfos(fr.stack(), cob, labels))).toList())));\n-                                    }));\n+                                    case CodeModel com -> mb.withCode(cob1 ->\n+                                            cob1.transforming(CodeStackTracker.of(), cob2 ->\n+                                            \/\/ second pass transforms unbound to unbound instructions\n+                                            cob2.transforming(new CodeRebuildingTransform(), cob3 ->\n+                                            \/\/ first pass transforms bound to unbound instructions\n+                                            cob3.transforming(new CodeRebuildingTransform(), cob4 -> {\n+                                                com.forEachElement(cob4::with);\n+                                                com.findAttribute(Attributes.STACK_MAP_TABLE).ifPresent(cob4::with);\n+                                            }))));\n@@ -592,0 +213,390 @@\n+\n+    static class CodeRebuildingTransform implements CodeTransform {\n+\n+        final HashMap<Label, Label> labels = new HashMap<>();\n+\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            switch (coe) {\n+                case ArrayLoadInstruction i -> {\n+                    switch (i.typeKind()) {\n+                        case ByteType -> cob.baload();\n+                        case ShortType -> cob.saload();\n+                        case IntType -> cob.iaload();\n+                        case FloatType -> cob.faload();\n+                        case LongType -> cob.laload();\n+                        case DoubleType -> cob.daload();\n+                        case ReferenceType -> cob.aaload();\n+                        case CharType -> cob.caload();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case ArrayStoreInstruction i -> {\n+                    switch (i.typeKind()) {\n+                        case ByteType -> cob.bastore();\n+                        case ShortType -> cob.sastore();\n+                        case IntType -> cob.iastore();\n+                        case FloatType -> cob.fastore();\n+                        case LongType -> cob.lastore();\n+                        case DoubleType -> cob.dastore();\n+                        case ReferenceType -> cob.aastore();\n+                        case CharType -> cob.castore();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case BranchInstruction i -> {\n+                    var target = labels.computeIfAbsent(i.target(), l -> cob.newLabel());\n+                    switch (i.opcode()) {\n+                        case GOTO -> cob.goto_(target);\n+                        case GOTO_W -> cob.goto_w(target);\n+                        case IF_ACMPEQ -> cob.if_acmpeq(target);\n+                        case IF_ACMPNE -> cob.if_acmpne(target);\n+                        case IF_ICMPEQ -> cob.if_icmpeq(target);\n+                        case IF_ICMPGE -> cob.if_icmpge(target);\n+                        case IF_ICMPGT -> cob.if_icmpgt(target);\n+                        case IF_ICMPLE -> cob.if_icmple(target);\n+                        case IF_ICMPLT -> cob.if_icmplt(target);\n+                        case IF_ICMPNE -> cob.if_icmpne(target);\n+                        case IFNONNULL -> cob.if_nonnull(target);\n+                        case IFNULL -> cob.if_null(target);\n+                        case IFEQ -> cob.ifeq(target);\n+                        case IFGE -> cob.ifge(target);\n+                        case IFGT -> cob.ifgt(target);\n+                        case IFLE -> cob.ifle(target);\n+                        case IFLT -> cob.iflt(target);\n+                        case IFNE -> cob.ifne(target);\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case ConstantInstruction i -> {\n+                    if (i.constantValue() == null)\n+                        if (pathSwitch.nextBoolean()) cob.aconst_null();\n+                        else cob.constantInstruction(null);\n+                    else switch (i.constantValue()) {\n+                        case Integer iVal -> {\n+                            if (iVal == 1 && pathSwitch.nextBoolean()) cob.iconst_1();\n+                            else if (iVal == 2 && pathSwitch.nextBoolean()) cob.iconst_2();\n+                            else if (iVal == 3 && pathSwitch.nextBoolean()) cob.iconst_3();\n+                            else if (iVal == 4 && pathSwitch.nextBoolean()) cob.iconst_4();\n+                            else if (iVal == 5 && pathSwitch.nextBoolean()) cob.iconst_5();\n+                            else if (iVal == -1 && pathSwitch.nextBoolean()) cob.iconst_m1();\n+                            else if (iVal >= -128 && iVal <= 127 && pathSwitch.nextBoolean()) cob.bipush(iVal);\n+                            else if (iVal >= -32768 && iVal <= 32767 && pathSwitch.nextBoolean()) cob.sipush(iVal);\n+                            else cob.constantInstruction(iVal);\n+                        }\n+                        case Long lVal -> {\n+                            if (lVal == 0 && pathSwitch.nextBoolean()) cob.lconst_0();\n+                            else if (lVal == 1 && pathSwitch.nextBoolean()) cob.lconst_1();\n+                            else cob.constantInstruction(lVal);\n+                        }\n+                        case Float fVal -> {\n+                            if (fVal == 0.0 && pathSwitch.nextBoolean()) cob.fconst_0();\n+                            else if (fVal == 1.0 && pathSwitch.nextBoolean()) cob.fconst_1();\n+                            else if (fVal == 2.0 && pathSwitch.nextBoolean()) cob.fconst_2();\n+                            else cob.constantInstruction(fVal);\n+                        }\n+                        case Double dVal -> {\n+                            if (dVal == 0.0d && pathSwitch.nextBoolean()) cob.dconst_0();\n+                            else if (dVal == 1.0d && pathSwitch.nextBoolean()) cob.dconst_1();\n+                            else cob.constantInstruction(dVal);\n+                        }\n+                        default -> cob.constantInstruction(i.constantValue());\n+                    }\n+                }\n+                case ConvertInstruction i -> {\n+                    switch (i.fromType()) {\n+                        case DoubleType -> {\n+                            switch (i.toType()) {\n+                                case FloatType -> cob.d2f();\n+                                case IntType -> cob.d2i();\n+                                case LongType -> cob.d2l();\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        }\n+                        case FloatType -> {\n+                            switch (i.toType()) {\n+                                case DoubleType -> cob.f2d();\n+                                case IntType -> cob.f2i();\n+                                case LongType -> cob.f2l();\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        }\n+                        case IntType -> {\n+                            switch (i.toType()) {\n+                                case ByteType -> cob.i2b();\n+                                case CharType -> cob.i2c();\n+                                case DoubleType -> cob.i2d();\n+                                case FloatType -> cob.i2f();\n+                                case LongType -> cob.i2l();\n+                                case ShortType -> cob.i2s();\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        }\n+                        case LongType -> {\n+                            switch (i.toType()) {\n+                                case DoubleType -> cob.l2d();\n+                                case FloatType -> cob.l2f();\n+                                case IntType -> cob.l2i();\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        }\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case DiscontinuedInstruction.JsrInstruction i ->\n+                    cob.with(DiscontinuedInstruction.JsrInstruction.of(i.opcode(), labels.computeIfAbsent(i.target(), l -> cob.newLabel())));\n+                case DiscontinuedInstruction.RetInstruction i ->\n+                    cob.with(DiscontinuedInstruction.RetInstruction.of(i.opcode(), i.slot()));\n+                case FieldInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        switch (i.opcode()) {\n+                            case GETFIELD -> cob.getfield(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                            case GETSTATIC -> cob.getstatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                            case PUTFIELD -> cob.putfield(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                            case PUTSTATIC -> cob.putstatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    } else {\n+                        switch (i.opcode()) {\n+                            case GETFIELD -> cob.getfield(i.field());\n+                            case GETSTATIC -> cob.getstatic(i.field());\n+                            case PUTFIELD -> cob.putfield(i.field());\n+                            case PUTSTATIC -> cob.putstatic(i.field());\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    }\n+                }\n+                case InvokeDynamicInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) cob.invokedynamic(i.invokedynamic().asSymbol());\n+                    else cob.invokedynamic(i.invokedynamic());\n+                }\n+                case InvokeInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        if (i.isInterface()) {\n+                            switch (i.opcode()) {\n+                                case INVOKEINTERFACE -> cob.invokeinterface(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                case INVOKESPECIAL -> cob.invokespecial(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), true);\n+                                case INVOKESTATIC -> cob.invokestatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), true);\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        } else {\n+                            switch (i.opcode()) {\n+                                case INVOKESPECIAL -> cob.invokespecial(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                case INVOKESTATIC -> cob.invokestatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                case INVOKEVIRTUAL -> cob.invokevirtual(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        }\n+                    } else {\n+                        switch (i.method()) {\n+                            case InterfaceMethodRefEntry en -> {\n+                                switch (i.opcode()) {\n+                                        case INVOKEINTERFACE -> cob.invokeinterface(en);\n+                                        case INVOKESPECIAL -> cob.invokespecial(en);\n+                                        case INVOKESTATIC -> cob.invokestatic(en);\n+                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                }\n+                            }\n+                            case MethodRefEntry en -> {\n+                                switch (i.opcode()) {\n+                                        case INVOKESPECIAL -> cob.invokespecial(en);\n+                                        case INVOKESTATIC -> cob.invokestatic(en);\n+                                        case INVOKEVIRTUAL -> cob.invokevirtual(en);\n+                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                }\n+                            }\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    }\n+                }\n+                case LoadInstruction i -> {\n+                    switch (i.typeKind()) {\n+                        case IntType -> cob.iload(i.slot());\n+                        case FloatType -> cob.fload(i.slot());\n+                        case LongType -> cob.lload(i.slot());\n+                        case DoubleType -> cob.dload(i.slot());\n+                        case ReferenceType -> cob.aload(i.slot());\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case StoreInstruction i -> {\n+                    switch (i.typeKind()) {\n+                        case IntType -> cob.istore(i.slot());\n+                        case FloatType -> cob.fstore(i.slot());\n+                        case LongType -> cob.lstore(i.slot());\n+                        case DoubleType -> cob.dstore(i.slot());\n+                        case ReferenceType -> cob.astore(i.slot());\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case IncrementInstruction i ->\n+                    cob.iinc(i.slot(), i.constant());\n+                case LookupSwitchInstruction i ->\n+                    cob.lookupswitch(labels.computeIfAbsent(i.defaultTarget(), l -> cob.newLabel()),\n+                                     i.cases().stream().map(sc ->\n+                                             SwitchCase.of(sc.caseValue(), labels.computeIfAbsent(sc.target(), l -> cob.newLabel()))).toList());\n+                case MonitorInstruction i -> {\n+                    switch (i.opcode()) {\n+                        case MONITORENTER -> cob.monitorenter();\n+                        case MONITOREXIT -> cob.monitorexit();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case NewMultiArrayInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        cob.multianewarray(i.arrayType().asSymbol(), i.dimensions());\n+                    } else {\n+                        cob.multianewarray(i.arrayType(), i.dimensions());\n+                    }\n+                }\n+                case NewObjectInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        cob.new_(i.className().asSymbol());\n+                    } else {\n+                        cob.new_(i.className());\n+                    }\n+                }\n+                case NewPrimitiveArrayInstruction i ->\n+                    cob.newarray(i.typeKind());\n+                case NewReferenceArrayInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        cob.anewarray(i.componentType().asSymbol());\n+                    } else {\n+                        cob.anewarray(i.componentType());\n+                    }\n+                }\n+                case NopInstruction i ->\n+                    cob.nop();\n+                case OperatorInstruction i -> {\n+                    switch (i.opcode()) {\n+                        case IADD -> cob.iadd();\n+                        case LADD -> cob.ladd();\n+                        case FADD -> cob.fadd();\n+                        case DADD -> cob.dadd();\n+                        case ISUB -> cob.isub();\n+                        case LSUB -> cob.lsub();\n+                        case FSUB -> cob.fsub();\n+                        case DSUB -> cob.dsub();\n+                        case IMUL -> cob.imul();\n+                        case LMUL -> cob.lmul();\n+                        case FMUL -> cob.fmul();\n+                        case DMUL -> cob.dmul();\n+                        case IDIV -> cob.idiv();\n+                        case LDIV -> cob.ldiv();\n+                        case FDIV -> cob.fdiv();\n+                        case DDIV -> cob.ddiv();\n+                        case IREM -> cob.irem();\n+                        case LREM -> cob.lrem();\n+                        case FREM -> cob.frem();\n+                        case DREM -> cob.drem();\n+                        case INEG -> cob.ineg();\n+                        case LNEG -> cob.lneg();\n+                        case FNEG -> cob.fneg();\n+                        case DNEG -> cob.dneg();\n+                        case ISHL -> cob.ishl();\n+                        case LSHL -> cob.lshl();\n+                        case ISHR -> cob.ishr();\n+                        case LSHR -> cob.lshr();\n+                        case IUSHR -> cob.iushr();\n+                        case LUSHR -> cob.lushr();\n+                        case IAND -> cob.iand();\n+                        case LAND -> cob.land();\n+                        case IOR -> cob.ior();\n+                        case LOR -> cob.lor();\n+                        case IXOR -> cob.ixor();\n+                        case LXOR -> cob.lxor();\n+                        case LCMP -> cob.lcmp();\n+                        case FCMPL -> cob.fcmpl();\n+                        case FCMPG -> cob.fcmpg();\n+                        case DCMPL -> cob.dcmpl();\n+                        case DCMPG -> cob.dcmpg();\n+                        case ARRAYLENGTH -> cob.arraylength();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case ReturnInstruction i -> {\n+                    switch (i.typeKind()) {\n+                        case IntType -> cob.ireturn();\n+                        case FloatType -> cob.freturn();\n+                        case LongType -> cob.lreturn();\n+                        case DoubleType -> cob.dreturn();\n+                        case ReferenceType -> cob.areturn();\n+                        case VoidType -> cob.return_();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case StackInstruction i -> {\n+                    switch (i.opcode()) {\n+                        case POP -> cob.pop();\n+                        case POP2 -> cob.pop2();\n+                        case DUP -> cob.dup();\n+                        case DUP_X1 -> cob.dup_x1();\n+                        case DUP_X2 -> cob.dup_x2();\n+                        case DUP2 -> cob.dup2();\n+                        case DUP2_X1 -> cob.dup2_x1();\n+                        case DUP2_X2 -> cob.dup2_x2();\n+                        case SWAP -> cob.swap();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case TableSwitchInstruction i ->\n+                    cob.tableswitch(i.lowValue(), i.highValue(),\n+                                    labels.computeIfAbsent(i.defaultTarget(), l -> cob.newLabel()),\n+                                    i.cases().stream().map(sc ->\n+                                            SwitchCase.of(sc.caseValue(), labels.computeIfAbsent(sc.target(), l -> cob.newLabel()))).toList());\n+                case ThrowInstruction i -> cob.athrow();\n+                case TypeCheckInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        switch (i.opcode()) {\n+                            case CHECKCAST -> cob.checkcast(i.type().asSymbol());\n+                            case INSTANCEOF -> cob.instanceof_(i.type().asSymbol());\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    } else {\n+                        switch (i.opcode()) {\n+                            case CHECKCAST -> cob.checkcast(i.type());\n+                            case INSTANCEOF -> cob.instanceof_(i.type());\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    }\n+                }\n+                case CharacterRange pi ->\n+                    cob.characterRange(labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n+                                       labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()),\n+                                       pi.characterRangeStart(), pi.characterRangeEnd(), pi.flags());\n+                case ExceptionCatch pi ->\n+                    pi.catchType().ifPresentOrElse(\n+                            catchType -> cob.exceptionCatch(labels.computeIfAbsent(pi.tryStart(), l -> cob.newLabel()),\n+                                                            labels.computeIfAbsent(pi.tryEnd(), l -> cob.newLabel()),\n+                                                            labels.computeIfAbsent(pi.handler(), l -> cob.newLabel()),\n+                                                            catchType.asSymbol()),\n+                            () -> cob.exceptionCatchAll(labels.computeIfAbsent(pi.tryStart(), l -> cob.newLabel()),\n+                                                        labels.computeIfAbsent(pi.tryEnd(), l -> cob.newLabel()),\n+                                                        labels.computeIfAbsent(pi.handler(), l -> cob.newLabel())));\n+                case LabelTarget pi ->\n+                    cob.labelBinding(labels.computeIfAbsent(pi.label(), l -> cob.newLabel()));\n+                case LineNumber pi ->\n+                    cob.lineNumber(pi.line());\n+                case LocalVariable pi ->\n+                    cob.localVariable(pi.slot(), pi.name().stringValue(), pi.typeSymbol(),\n+                                      labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n+                                       labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()));\n+                case LocalVariableType pi ->\n+                    cob.localVariableType(pi.slot(), pi.name().stringValue(),\n+                                          Signature.parseFrom(pi.signatureSymbol().signatureString()),\n+                                          labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n+                                          labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()));\n+                case RuntimeInvisibleTypeAnnotationsAttribute a ->\n+                    cob.with(RuntimeInvisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), cob, labels)));\n+                case RuntimeVisibleTypeAnnotationsAttribute a ->\n+                    cob.with(RuntimeVisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), cob, labels)));\n+                case StackMapTableAttribute a ->\n+                    cob.with(StackMapTableAttribute.of(a.entries().stream().map(fr ->\n+                            StackMapFrameInfo.of(labels.computeIfAbsent(fr.target(), l -> cob.newLabel()),\n+                                    transformFrameTypeInfos(fr.locals(), cob, labels),\n+                                    transformFrameTypeInfos(fr.stack(), cob, labels))).toList()));\n+                case CustomAttribute a ->\n+                    throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":400,"deletions":389,"binary":false,"changes":789,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -42,1 +44,1 @@\n-    static final Random RAND = new Random(Integer.getInteger(\"jdk.incubator.vector.test.random-seed\", 1337));\n+    static final Random RAND = Utils.getRandomInstance();\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4744,1 +4747,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4773,1 +4776,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4807,1 +4810,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4836,1 +4839,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4874,2 +4877,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4931,2 +4934,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4744,1 +4747,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4773,1 +4776,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4807,1 +4810,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4836,1 +4839,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4874,2 +4877,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4931,2 +4934,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4744,1 +4747,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4773,1 +4776,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4807,1 +4810,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4836,1 +4839,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4874,2 +4877,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4931,2 +4934,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4744,1 +4747,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4773,1 +4776,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4807,1 +4810,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4836,1 +4839,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4874,2 +4877,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4931,2 +4934,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4749,1 +4752,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4778,1 +4781,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4812,1 +4815,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4841,1 +4844,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4879,2 +4882,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4936,2 +4939,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -3550,1 +3553,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3579,1 +3582,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3613,1 +3616,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3642,1 +3645,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3680,2 +3683,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -3737,2 +3740,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -3550,1 +3553,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3579,1 +3582,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3613,1 +3616,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3642,1 +3645,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3680,2 +3683,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -3737,2 +3740,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -3550,1 +3553,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3579,1 +3582,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3613,1 +3616,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3642,1 +3645,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3680,2 +3683,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -3737,2 +3740,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -3550,1 +3553,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3579,1 +3582,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3613,1 +3616,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3642,1 +3645,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3680,2 +3683,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -3737,2 +3740,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -3555,1 +3558,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3584,1 +3587,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3618,1 +3621,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3647,1 +3650,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3685,2 +3688,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -3742,2 +3745,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -3561,1 +3564,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3590,1 +3593,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3624,1 +3627,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3653,1 +3656,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3691,2 +3694,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -3748,2 +3751,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -3561,1 +3564,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3590,1 +3593,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3624,1 +3627,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3653,1 +3656,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3691,2 +3694,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -3748,2 +3751,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -3561,1 +3564,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3590,1 +3593,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3624,1 +3627,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3653,1 +3656,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3691,2 +3694,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -3748,2 +3751,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -3561,1 +3564,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3590,1 +3593,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3624,1 +3627,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3653,1 +3656,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3691,2 +3694,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -3748,2 +3751,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -3566,1 +3569,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3595,1 +3598,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3629,1 +3632,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3658,1 +3661,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -3696,2 +3699,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -3753,2 +3756,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4788,1 +4791,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4817,1 +4820,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4851,1 +4854,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4880,1 +4883,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4918,2 +4921,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4975,2 +4978,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4788,1 +4791,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4817,1 +4820,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4851,1 +4854,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4880,1 +4883,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4918,2 +4921,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4975,2 +4978,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4788,1 +4791,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4817,1 +4820,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4851,1 +4854,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4880,1 +4883,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4918,2 +4921,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4975,2 +4978,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4788,1 +4791,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4817,1 +4820,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4851,1 +4854,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4880,1 +4883,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4918,2 +4921,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4975,2 +4978,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4793,1 +4796,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4822,1 +4825,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4856,1 +4859,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4885,1 +4888,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4923,2 +4926,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4980,2 +4983,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4740,1 +4743,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4769,1 +4772,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4803,1 +4806,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4832,1 +4835,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4870,2 +4873,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4927,2 +4930,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4740,1 +4743,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4769,1 +4772,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4803,1 +4806,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4832,1 +4835,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4870,2 +4873,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4927,2 +4930,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4740,1 +4743,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4769,1 +4772,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4803,1 +4806,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4832,1 +4835,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4870,2 +4873,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4927,2 +4930,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4740,1 +4743,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4769,1 +4772,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4803,1 +4806,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4832,1 +4835,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4870,2 +4873,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4927,2 +4930,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4745,1 +4748,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4774,1 +4777,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4808,1 +4811,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4837,1 +4840,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4875,2 +4878,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4932,2 +4935,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4735,1 +4738,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4764,1 +4767,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4798,1 +4801,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4827,1 +4830,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4865,2 +4868,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4922,2 +4925,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4735,1 +4738,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4764,1 +4767,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4798,1 +4801,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4827,1 +4830,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4865,2 +4868,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4922,2 +4925,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4735,1 +4738,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4764,1 +4767,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4798,1 +4801,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4827,1 +4830,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4865,2 +4868,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4922,2 +4925,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4735,1 +4738,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4764,1 +4767,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4798,1 +4801,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4827,1 +4830,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4865,2 +4868,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4922,2 +4925,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n@@ -4740,1 +4743,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4769,1 +4772,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4803,1 +4806,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4832,1 +4835,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n@@ -4870,2 +4873,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n@@ -4927,2 +4930,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Slice-Masked-bop.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Slice-bop.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Slice-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,2 +6,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Unslice-Masked-bop.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,2 +4,2 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n-        int part = (new java.util.Random()).nextInt(2);\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Unslice-bop.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int origin = RAND.nextInt(SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Unslice-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            VMSupport.decodeAndThrowThrowable(0, 0L, true);\n+            VMSupport.decodeAndThrowThrowable(0, 0L, true, false);\n@@ -72,1 +72,1 @@\n-            VMSupport.decodeAndThrowThrowable(1, 0L, true);\n+            VMSupport.decodeAndThrowThrowable(1, 0L, true, false);\n@@ -83,1 +83,1 @@\n-            VMSupport.decodeAndThrowThrowable(2, 0L, true);\n+            VMSupport.decodeAndThrowThrowable(2, 0L, true, false);\n@@ -92,1 +92,1 @@\n-            VMSupport.decodeAndThrowThrowable(3, 0L, true);\n+            VMSupport.decodeAndThrowThrowable(3, 0L, true, false);\n@@ -101,1 +101,1 @@\n-            VMSupport.decodeAndThrowThrowable(4, 0L, true);\n+            VMSupport.decodeAndThrowThrowable(4, 0L, true, false);\n@@ -115,1 +115,1 @@\n-            VMSupport.decodeAndThrowThrowable(3, buffer, true);\n+            VMSupport.decodeAndThrowThrowable(3, buffer, true, false);\n@@ -142,1 +142,1 @@\n-                        VMSupport.decodeAndThrowThrowable(format, buffer, true);\n+                        VMSupport.decodeAndThrowThrowable(format, buffer, true, false);\n","filename":"test\/jdk\/jdk\/internal\/vm\/TestTranslatedException.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.nio.file.Files;\n@@ -38,0 +37,1 @@\n+import jdk.test.lib.Utils;\n@@ -151,1 +151,1 @@\n-            Path p = Files.createTempFile(\"recording\", \".jfr\");\n+            Path p = Utils.createTempFile(\"recording\", \".jfr\");\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/filestream\/TestOrdered.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.test.lib.Utils;\n@@ -121,1 +122,1 @@\n-            Path p = Files.createTempFile(\"recording\", \".jfr\");\n+            Path p = Utils.createTempFile(\"recording\", \".jfr\");\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/filestream\/TestReuse.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.test.lib.Utils;\n@@ -81,1 +82,1 @@\n-            Path p = Files.createTempFile(\"test\", \".jfr\");\n+            Path p = Utils.createTempFile(\"test\", \".jfr\");\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestManyVirtualThreads.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -53,0 +55,1 @@\n+ * @library \/test\/lib\n@@ -58,13 +61,13 @@\n-        Path path = Files.createTempFile(\"bad\", \".zip\");\n-        try (OutputStream os = Files.newOutputStream(path);\n-                ZipOutputStream zos = new ZipOutputStream(os)) {\n-            ZipEntry e = new ZipEntry(\"x\");\n-            zos.putNextEntry(e);\n-            zos.write((int) 'x');\n-        }\n-        int len = (int) Files.size(path);\n-        byte[] data = new byte[len];\n-        try (InputStream is = Files.newInputStream(path)) {\n-            is.read(data);\n-        }\n-        Files.delete(path);\n+        Path path = Utils.createTempFile(\"bad\", \".zip\");\n+        try {\n+            try (OutputStream os = Files.newOutputStream(path);\n+                 ZipOutputStream zos = new ZipOutputStream(os)) {\n+                ZipEntry e = new ZipEntry(\"x\");\n+                zos.putNextEntry(e);\n+                zos.write((int) 'x');\n+            }\n+            int len = (int) Files.size(path);\n+            byte[] data = new byte[len];\n+            try (InputStream is = Files.newInputStream(path)) {\n+                is.read(data);\n+            }\n@@ -72,11 +75,14 @@\n-        \/\/ year, month, day are zero\n-        testDate(data.clone(), 0, LocalDate.of(1979, 11, 30).atStartOfDay());\n-        \/\/ only year is zero\n-        testDate(data.clone(), 0 << 25 | 4 << 21 | 5 << 16, LocalDate.of(1980, 4, 5).atStartOfDay());\n-        \/\/ month is greater than 12\n-        testDate(data.clone(), 0 << 25 | 13 << 21 | 1 << 16, LocalDate.of(1981, 1, 1).atStartOfDay());\n-        \/\/ 30th of February\n-        testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16, LocalDate.of(1980, 3, 1).atStartOfDay());\n-        \/\/ 30th of February, 24:60:60\n-        testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16 | 24 << 11 | 60 << 5 | 60 >> 1,\n-                LocalDateTime.of(1980, 3, 2, 1, 1, 0));\n+            \/\/ year, month, day are zero\n+            testDate(data.clone(), 0, LocalDate.of(1979, 11, 30).atStartOfDay());\n+            \/\/ only year is zero\n+            testDate(data.clone(), 0 << 25 | 4 << 21 | 5 << 16, LocalDate.of(1980, 4, 5).atStartOfDay());\n+            \/\/ month is greater than 12\n+            testDate(data.clone(), 0 << 25 | 13 << 21 | 1 << 16, LocalDate.of(1981, 1, 1).atStartOfDay());\n+            \/\/ 30th of February\n+            testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16, LocalDate.of(1980, 3, 1).atStartOfDay());\n+            \/\/ 30th of February, 24:60:60\n+            testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16 | 24 << 11 | 60 << 5 | 60 >> 1,\n+                    LocalDateTime.of(1980, 3, 2, 1, 1, 0));\n+        } finally {\n+            Files.delete(path);\n+        }\n@@ -94,1 +100,1 @@\n-        Path path = Files.createTempFile(\"out\", \".zip\");\n+        Path path = Utils.createTempFile(\"out\", \".zip\");\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/ZeroDate.java","additions":32,"deletions":26,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.logging.*;\n+\n+import jdk.internal.event.EventHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8329013\n+ * @summary StackOverflowError when starting Apache Tomcat with signed jar\n+ * @modules java.base\/jdk.internal.event:+open\n+ * @run main\/othervm -Xmx32m -Djava.util.logging.manager=RecursiveEventHelper RecursiveEventHelper\n+ *\/\n+public class RecursiveEventHelper extends LogManager {\n+    \/\/ an extra check to ensure the custom manager is in use\n+    static volatile boolean customMethodCalled;\n+\n+    public static void main(String[] args) throws Exception {\n+        String classname = System.getProperty(\"java.util.logging.manager\");\n+        if (!classname.equals(\"RecursiveEventHelper\")) {\n+            throw new RuntimeException(\"java.util.logging.manager not set\");\n+        }\n+\n+        \/\/ this call will trigger initialization of logging framework\n+        \/\/ which will call into our custom LogManager and use the\n+        \/\/ custom getProperty method below. EventHelper.isLoggingSecurity()\n+        \/\/ is also on the code path of original report and triggers\n+        \/\/ similar recursion.\n+        System.getLogger(\"testLogger\");\n+        if (!customMethodCalled) {\n+            throw new RuntimeException(\"Method not called\");\n+        }\n+    }\n+\n+    @Override\n+    public String getProperty(String p) {\n+        \/\/ this call mimics issue reported in initial bug report where\n+        \/\/ opening of a signed jar during System logger initialization triggered\n+        \/\/ a recursive call (via EventHelper.isLoggingSecurity) back into\n+        \/\/ logger API\n+        EventHelper.isLoggingSecurity();\n+        customMethodCalled = true;\n+        return super.getProperty(p);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/security\/logging\/RecursiveEventHelper.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n- * Change file permission for out-of-the-box management an do test used by\n- * PasswordFilePermissionTest and SSLConfigFilePermissionTest tests\n+ * Change file permission for out-of-the-box management, and test.\n+ * Used by PasswordFilePermissionTest and SSLConfigFilePermissionTest tests.\n@@ -143,1 +143,3 @@\n-        if (doTest() != 0) {\n+        int e = doTest();\n+        if (e != 0) {\n+            System.out.println(\"FAILURE: expected exit code 0, got: \" + e);\n@@ -149,1 +151,1 @@\n-     * Test 1 - SSL config file is secure - VM should start\n+     * Test 2 - SSL config file is NOT secure - VM should not start\n@@ -157,1 +159,3 @@\n-        if (doTest() == 0) {\n+        int e = doTest();\n+        if (e == 0) {\n+            System.out.println(\"FAILURE: expected exit code non-zero, got: \" + e);\n@@ -175,1 +179,0 @@\n-\n@@ -184,4 +187,5 @@\n-            if ((output.getExitValue() == 0)  ||\n-                !output.getOutput().contains(\"Exception thrown by the agent : \" +\n-                        \"java.rmi.server.ExportException: Port already in use\")) {\n-                return output.getExitValue();\n+            if (output.getOutput().contains(\"Exception thrown by the agent: java.rmi.server.ExportException: Port already in use\")) {\n+                if (i < MAX_GET_FREE_PORT_TRIES - 1) {\n+                    System.out.println(\"Retrying...\");\n+                    continue;\n+                }\n@@ -189,0 +193,2 @@\n+            \/\/ Fail on too many port failures, and all other startup failures.\n+            return output.getExitValue();\n@@ -190,1 +196,0 @@\n-\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/AbstractFilePermissionTest.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-            if (!output.getOutput().contains(\"Exception thrown by the agent : \" +\n+            if (!output.getOutput().contains(\"Exception thrown by the agent: \" +\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/RmiRegistrySslTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8327818\n+ * @bug 8327818 8051959\n@@ -29,0 +29,1 @@\n+ * @run junit LoginModuleDebug\n@@ -31,0 +32,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -32,0 +34,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -34,0 +39,1 @@\n+import java.util.stream.Stream;\n@@ -37,20 +43,35 @@\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            \/\/ debug option set to true\n-            ProcessTools.executeTestJava(\"LoginModuleDebug\",\n-                            \"debug\", \"true\")\n-                    .stdoutShouldBeEmpty()\n-                    .stderrShouldContain(\"krb5loginmodule:\");\n-            \/\/ debug option set to false\n-            ProcessTools.executeTestJava(\"LoginModuleDebug\",\n-                            \"debug\", \"false\")\n-                    .stdoutShouldBeEmpty()\n-                    .stderrShouldNotContain(\"krb5loginmodule:\");\n-            \/\/ no debug option\n-            ProcessTools.executeTestJava(\"LoginModuleDebug\",\n-                            \"foo\", \"bar\")\n-                    .stdoutShouldBeEmpty()\n-                    .stderrShouldNotContain(\"krb5loginmodule:\");\n-        } else {\n-            test(args[0], args[1]);\n-        }\n+    static final String DATE_REGEX = \"\\\\d{4}-\\\\d{2}-\\\\d{2}\";\n+\n+    private static Stream<Arguments> patternMatches() {\n+        return Stream.of(\n+                \/\/ debug option set to true - no extra info\n+                Arguments.of(\"debug\",\n+                        \"true\",\n+                        \"krb5loginmodule:\",\n+                        \"krb5loginmodule\\\\[\"),\n+                \/\/ debug option set to false\n+                Arguments.of(\"debug\",\n+                        \"false\",\n+                        \"\",\n+                        \"krb5loginmodule\"),\n+                \/\/ no debug option\n+                Arguments.of(\"foo\",\n+                        \"bar\",\n+                        \"\",\n+                        \"krb5loginmodule\"),\n+                \/\/ thread info only\n+                Arguments.of(\"debug\",\n+                        \"true+thread\",\n+                        \"krb5loginmodule\\\\[.*\\\\|main|\\\\.*java.*]:\",\n+                        \"\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ timestamp info only\n+                Arguments.of(\"debug\",\n+                        \"true+timestamp\",\n+                        \"krb5loginmodule\\\\[\" + DATE_REGEX + \".*\\\\]\",\n+                        \"\\\\|main\\\\]:\"),\n+                \/\/ both thread and timestamp\n+                Arguments.of(\"debug\",\n+                        \"true+timestamp+thread\",\n+                        \"krb5loginmodule\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"krb5loginmodule:\")\n+        );\n@@ -59,4 +80,26 @@\n-    static void test(String key, String prop)\n-            throws Exception {\n-        new Krb5LoginModule().initialize(\n-                new Subject(), null, Map.of(), Map.of(key, prop));\n+    @ParameterizedTest\n+    @MethodSource(\"patternMatches\")\n+    public void shouldContain(String value, String key, String expected, String notExpected) throws Exception {\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                \"LoginModuleDebug\",\n+                value, key);\n+        outputAnalyzer.shouldHaveExitValue(0)\n+                .shouldMatch(expected)\n+                .shouldNotMatch(notExpected);\n+        \/\/ let's also run with java debug property enabled\n+        outputAnalyzer = ProcessTools.executeTestJava(\n+                \"-Djava.security.debug=all\",\n+                \"LoginModuleDebug\",\n+                value, key);\n+        outputAnalyzer.shouldHaveExitValue(0)\n+                .shouldMatch(expected)\n+                .shouldNotMatch(notExpected);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.err.println(args.length);\n+        if (args.length == 2) {\n+            \/\/ something to trigger \"krb5\" debug output\n+            new Krb5LoginModule().initialize(\n+                    new Subject(), null, Map.of(), Map.of(args[0], args[1]));\n+        }\n@@ -64,1 +107,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/LoginModuleDebug.java","additions":69,"deletions":26,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,3 +57,1 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -264,2 +262,3 @@\n-        String nssLibDir = fetchNssLib(osid);\n-        if (nssLibDir == null) {\n+        Path libraryName = Path.of(System.mapLibraryName(library));\n+        Path nssLibPath = fetchNssLib(osid, libraryName);\n+        if (nssLibPath == null) {\n@@ -269,8 +268,1 @@\n-\n-        String libraryName = System.mapLibraryName(library);\n-        Path libPath = Paths.get(nssLibDir).resolve(libraryName);\n-        if (!Files.exists(libPath)) {\n-            throw new SkippedException(\"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + nssLibDir);\n-        }\n-\n-        return libPath;\n+        return nssLibPath;\n@@ -738,1 +730,1 @@\n-    private static String fetchNssLib(String osId) {\n+    private static Path fetchNssLib(String osId, Path libraryName) {\n@@ -741,1 +733,1 @@\n-                return fetchNssLib(WINDOWS_X64.class);\n+                return fetchNssLib(WINDOWS_X64.class, libraryName);\n@@ -744,1 +736,1 @@\n-                return fetchNssLib(MACOSX_X64.class);\n+                return fetchNssLib(MACOSX_X64.class, libraryName);\n@@ -747,1 +739,1 @@\n-                return fetchNssLib(MACOSX_AARCH64.class);\n+                return fetchNssLib(MACOSX_AARCH64.class, libraryName);\n@@ -753,1 +745,1 @@\n-                    return fetchNssLib(LINUX_X64.class);\n+                    return fetchNssLib(LINUX_X64.class, libraryName);\n@@ -760,1 +752,1 @@\n-                    return fetchNssLib(LINUX_AARCH64.class);\n+                    return fetchNssLib(LINUX_AARCH64.class, libraryName);\n@@ -767,2 +759,2 @@\n-    private static String fetchNssLib(Class<?> clazz) {\n-        String path = null;\n+    private static Path fetchNssLib(Class<?> clazz, Path libraryName) {\n+        Path path = null;\n@@ -770,4 +762,4 @@\n-            path = ArtifactResolver.resolve(clazz).entrySet().stream()\n-                    .findAny().get().getValue() + File.separator + \"nss\"\n-                    + File.separator + \"lib\" + File.separator;\n-        } catch (ArtifactResolverException e) {\n+            Path p = ArtifactResolver.resolve(clazz).entrySet().stream()\n+                    .findAny().get().getValue();\n+            path = findNSSLibrary(p, libraryName);\n+        } catch (ArtifactResolverException | IOException e) {\n@@ -787,0 +779,10 @@\n+    private static Path findNSSLibrary(Path path, Path libraryName) throws IOException {\n+        try(Stream<Path> files = Files.find(path, 10,\n+                (tp, attr) -> tp.getFileName().equals(libraryName))) {\n+\n+            return files.findAny()\n+                        .orElseThrow(() -> new SkippedException(\n+                        \"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n+        }\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":28,"deletions":26,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.nio.file.Files;\n@@ -69,4 +70,0 @@\n-        try (FileOutputStream fos = new FileOutputStream(ksFile)) {\n-            ks.store(fos, pw);\n-            fos.flush();\n-        }\n@@ -74,12 +71,19 @@\n-        \/\/ now see if we can get it back\n-        try (FileInputStream fis = new FileInputStream(ksFile)) {\n-            KeyStore ks2 = KeyStore.getInstance(keystoreType);\n-            ks2.load(fis, pw);\n-            KeyStore.Entry entry = ks2.getEntry(ALIAS, kspp);\n-            SecretKey keyIn = ((KeyStore.SecretKeyEntry)entry).getSecretKey();\n-            if (Arrays.equals(key.getEncoded(), keyIn.getEncoded())) {\n-                System.err.println(\"OK: worked just fine with \" + keystoreType +\n-                                   \" keystore\");\n-            } else {\n-                System.err.println(\"ERROR: keys are NOT equal after storing in \"\n-                                   + keystoreType + \" keystore\");\n+        try {\n+            try (FileOutputStream fos = new FileOutputStream(ksFile)) {\n+                ks.store(fos, pw);\n+                fos.flush();\n+            }\n+\n+            \/\/ now see if we can get it back\n+            try (FileInputStream fis = new FileInputStream(ksFile)) {\n+                KeyStore ks2 = KeyStore.getInstance(keystoreType);\n+                ks2.load(fis, pw);\n+                KeyStore.Entry entry = ks2.getEntry(ALIAS, kspp);\n+                SecretKey keyIn = ((KeyStore.SecretKeyEntry) entry).getSecretKey();\n+                if (Arrays.equals(key.getEncoded(), keyIn.getEncoded())) {\n+                    System.err.println(\"OK: worked just fine with \" + keystoreType +\n+                            \" keystore\");\n+                } else {\n+                    System.err.println(\"ERROR: keys are NOT equal after storing in \"\n+                            + keystoreType + \" keystore\");\n+                }\n@@ -87,0 +91,2 @@\n+        } finally {\n+            Files.deleteIfExists(ksFile.toPath());\n","filename":"test\/jdk\/sun\/security\/pkcs12\/P12SecretKey.java","additions":23,"deletions":17,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8051959\n+ * @summary Option to print extra information in java.security.debug output\n+ * @library \/test\/lib\n+ * @run junit DebugOptions\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.security.KeyStore;\n+import java.security.Security;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class DebugOptions {\n+\n+    static final String DATE_REGEX = \"\\\\d{4}-\\\\d{2}-\\\\d{2}\";\n+\n+    private static Stream<Arguments> patternMatches() {\n+        return Stream.of(\n+                \/\/ no extra info present\n+                Arguments.of(\"properties\",\n+                        \"properties: Initial\",\n+                        \"properties\\\\[\"),\n+                \/\/ thread info only\n+                Arguments.of(\"properties+thread\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*java.*]:\",\n+                        \"properties\\\\[\" + DATE_REGEX),\n+                \/\/ timestamp info only\n+                Arguments.of(\"properties+timestamp\",\n+                        \"properties\\\\[\" + DATE_REGEX + \".*\\\\]\",\n+                        \"\\\\|main\\\\]:\"),\n+                \/\/ both thread and timestamp\n+                Arguments.of(\"properties+timestamp+thread\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ flip the arguments of previous test\n+                Arguments.of(\"properties+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ comma not valid separator, ignore extra info printing request\n+                Arguments.of(\"properties,thread,timestamp\",\n+                        \"properties:\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ no extra info for keystore debug prints\n+                Arguments.of(\"properties+thread+timestamp,keystore\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"keystore\\\\[\"),\n+                \/\/ flip arguments around in last test - same outcome expected\n+                Arguments.of(\"keystore,properties+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"keystore\\\\[\"),\n+                \/\/ turn on thread info for both keystore and properties components\n+                Arguments.of(\"keystore+thread,properties+thread\",\n+                        \"properties\\\\[.*\\\\|main|.*\\\\Rkeystore\\\\[.*\\\\|main|.*\\\\]:\",\n+                        \"\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ same as above with erroneous comma at end of string. same output expected\n+                Arguments.of(\"keystore+thread,properties+thread,\",\n+                        \"properties\\\\[.*\\\\|main|.*\\\\Rkeystore\\\\[.*\\\\|main|.*\\\\]:\",\n+                        \"\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ turn on thread info for properties and timestamp for keystore\n+                Arguments.of(\"keystore+timestamp,properties+thread\",\n+                        \"properties\\\\[.*\\\\|main|.*\\\\Rkeystore\\\\[\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties\\\\[.*\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ turn on thread info for all components\n+                Arguments.of(\"all+thread\",\n+                        \"properties\\\\[.*\\\\|main.*((.*\\\\R)*)keystore\\\\[.*\\\\|main.*java.*\\\\]:\",\n+                        \"properties\\\\[\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ turn on thread info and timestamp for all components\n+                Arguments.of(\"all+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX +\n+                                \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ all decorator option should override other component options\n+                Arguments.of(\"all+thread+timestamp,properties\",\n+                        \"properties\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX +\n+                                \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ thread details should only be printed for properties option\n+                Arguments.of(\"properties+thread,all\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*\\\\]:\",\n+                        \"keystore\\\\[.*\\\\|main\\\\|.*\\\\]:\"),\n+                \/\/ thread details should be printed for all statements\n+                Arguments.of(\"properties,all+thread\",\n+                        \"properties\\\\[.*\\\\|main.*java\" +\n+                                \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*java.*\\\\]:\",\n+                        \"properties:\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"patternMatches\")\n+    public void shouldContain(String params, String expected, String notExpected) throws Exception {\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                \"-Djava.security.debug=\" + params,\n+                \"DebugOptions\"\n+        );\n+        outputAnalyzer.shouldHaveExitValue(0)\n+                .shouldMatch(expected)\n+                .shouldNotMatch(notExpected);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ something to trigger \"properties\" debug output\n+        Security.getProperty(\"test\");\n+        \/\/ trigger \"keystore\" debug output\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/Debug\/DebugOptions.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,381 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297879\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestErasure\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestErasure extends JavadocTester {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    public static void main(String... args) throws Exception {\n+        new TestErasure().runTests();\n+    }\n+\n+    \/*\n+     * Create confusion between:\n+     *   - a constructor\/method type parameter and a like-named class\n+     *   - similarly named but differently bounded constructor type parameters\n+     *   - similarly named but differently bounded type parameter in methods\n+     *\/\n+    @Test\n+    public void test1(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        \/\/ - put public class first so that writeJavaFiles is not confused\n+        \/\/   on the name of the file it should create\n+        \/\/\n+        \/\/ - an _abstract_ class is used only for convenience: like an interface,\n+        \/\/   it allows to keep the test minimal, but unlike an interface, it\n+        \/\/   allows to test constructors\n+        tb.writeJavaFiles(src, \"\"\"\n+                public abstract class Foo {\n+                    public Foo(T arg) { }\n+                    public <T extends X> Foo(T arg) { }\n+                    public <T extends Y> Foo(T arg) { }\n+                    public abstract T m(T arg);\n+                    public abstract <T extends X> T m(T arg);\n+                    public abstract <T extends Y> T m(T arg);\n+                }\n+                class T { }\n+                class X { }\n+                class Y { }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                src.resolve(\"Foo.java\").toString());\n+\n+        checkExit(Exit.OK);\n+        \/\/ constructors\n+        checkOutput(\"Foo.html\", true, \"\"\"\n+                <section class=\"constructor-summary\" id=\"constructor-summary\">\n+                <h2>Constructor Summary<\/h2>\n+                <div class=\"caption\"><span>Constructors<\/span><\/div>\n+                <div class=\"summary-table two-column-summary\">\n+                <div class=\"table-header col-first\">Constructor<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-constructor-name even-row-color\"><code>\\\n+                <a href=\"#%3Cinit%3E(T)\" class=\"member-name-link\">Foo<\/a><wbr>(T&nbsp;arg)<\/code><\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                <div class=\"col-constructor-name odd-row-color\"><code>\\\n+                <a href=\"#%3Cinit%3E(X)\" class=\"member-name-link\">Foo<\/a><wbr>(T&nbsp;arg)<\/code><\/div>\n+                <div class=\"col-last odd-row-color\">&nbsp;<\/div>\n+                <div class=\"col-constructor-name even-row-color\"><code>\\\n+                <a href=\"#%3Cinit%3E(Y)\" class=\"member-name-link\">Foo<\/a><wbr>(T&nbsp;arg)<\/code><\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                <\/div>\n+                <\/section>\"\"\");\n+        checkOutput(\"Foo.html\", true, \"\"\"\n+                <li><a href=\"#constructor-detail\" tabindex=\"0\">Constructor Details<\/a>\n+                <ol class=\"toc-list\">\n+                <li><a href=\"#%3Cinit%3E(T)\" tabindex=\"0\">Foo(T)<\/a><\/li>\n+                <li><a href=\"#%3Cinit%3E(X)\" tabindex=\"0\">Foo(T)<\/a><\/li>\n+                <li><a href=\"#%3Cinit%3E(Y)\" tabindex=\"0\">Foo(T)<\/a><\/li>\n+                <\/ol>\n+                <\/li>\"\"\");\n+        checkOutput(\"index-all.html\", true, \"\"\"\n+                <dt><a href=\"Foo.html#%3Cinit%3E(T)\" class=\"member-name-link\">Foo(T)<\/a>\\\n+                 - Constructor for class <a href=\"Foo.html\" title=\"class in Unnamed Package\">Foo<\/a><\/dt>\n+                <dd>&nbsp;<\/dd>\n+                <dt><a href=\"Foo.html#%3Cinit%3E(X)\" class=\"member-name-link\">Foo(T)<\/a>\\\n+                 - Constructor for class <a href=\"Foo.html\" title=\"class in Unnamed Package\">Foo<\/a><\/dt>\n+                <dd>&nbsp;<\/dd>\n+                <dt><a href=\"Foo.html#%3Cinit%3E(Y)\" class=\"member-name-link\">Foo(T)<\/a>\\\n+                 - Constructor for class <a href=\"Foo.html\" title=\"class in Unnamed Package\">Foo<\/a><\/dt>\n+                <dd>&nbsp;<\/dd>\"\"\");\n+        checkOutput(\"member-search-index.js\", true, \"\"\"\n+                {\"p\":\"<Unnamed>\",\"c\":\"Foo\",\"l\":\"Foo(T)\",\"u\":\"%3Cinit%3E(T)\"},\\\n+                {\"p\":\"<Unnamed>\",\"c\":\"Foo\",\"l\":\"Foo(T)\",\"u\":\"%3Cinit%3E(X)\"},\\\n+                {\"p\":\"<Unnamed>\",\"c\":\"Foo\",\"l\":\"Foo(T)\",\"u\":\"%3Cinit%3E(Y)\"}\"\"\");\n+        \/\/ methods\n+        checkOutput(\"Foo.html\", true, \"\"\"\n+                <div class=\"col-first even-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\"><code>abstract T<\/code><\/div>\n+                <div class=\"col-second even-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\"><code><a href=\"#m(T)\" class=\"member-name-link\">m<\/a><wbr>(T&nbsp;arg)<\/code><\/div>\n+                <div class=\"col-last even-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\">&nbsp;<\/div>\n+                <div class=\"col-first odd-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\"><code>abstract &lt;T extends X&gt;<br>T<\/code><\/div>\n+                <div class=\"col-second odd-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\"><code><a href=\"#m(X)\" class=\"member-name-link\">m<\/a><wbr>(T&nbsp;arg)<\/code><\/div>\n+                <div class=\"col-last odd-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\">&nbsp;<\/div>\n+                <div class=\"col-first even-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\"><code>abstract &lt;T extends Y&gt;<br>T<\/code><\/div>\n+                <div class=\"col-second even-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\"><code><a href=\"#m(Y)\" class=\"member-name-link\">m<\/a><wbr>(T&nbsp;arg)<\/code><\/div>\n+                <div class=\"col-last even-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\">&nbsp;<\/div>\"\"\");\n+        checkOutput(\"Foo.html\", true, \"\"\"\n+                <li><a href=\"#method-detail\" tabindex=\"0\">Method Details<\/a>\n+                <ol class=\"toc-list\">\n+                <li><a href=\"#m(T)\" tabindex=\"0\">m(T)<\/a><\/li>\n+                <li><a href=\"#m(X)\" tabindex=\"0\">m(T)<\/a><\/li>\n+                <li><a href=\"#m(Y)\" tabindex=\"0\">m(T)<\/a><\/li>\n+                <\/ol>\n+                <\/li>\"\"\");\n+        checkOutput(\"index-all.html\", true, \"\"\"\n+                <dt><a href=\"Foo.html#m(T)\" class=\"member-name-link\">m(T)<\/a>\\\n+                 - Method in class <a href=\"Foo.html\" title=\"class in Unnamed Package\">Foo<\/a><\/dt>\n+                <dd>&nbsp;<\/dd>\n+                <dt><a href=\"Foo.html#m(X)\" class=\"member-name-link\">m(T)<\/a>\\\n+                 - Method in class <a href=\"Foo.html\" title=\"class in Unnamed Package\">Foo<\/a><\/dt>\n+                <dd>&nbsp;<\/dd>\n+                <dt><a href=\"Foo.html#m(Y)\" class=\"member-name-link\">m(T)<\/a>\\\n+                 - Method in class <a href=\"Foo.html\" title=\"class in Unnamed Package\">Foo<\/a><\/dt>\n+                <dd>&nbsp;<\/dd>\"\"\");\n+        checkOutput(\"member-search-index.js\", true, \"\"\"\n+                {\"p\":\"<Unnamed>\",\"c\":\"Foo\",\"l\":\"m(T)\"},\\\n+                {\"p\":\"<Unnamed>\",\"c\":\"Foo\",\"l\":\"m(T)\",\"u\":\"m(X)\"},\\\n+                {\"p\":\"<Unnamed>\",\"c\":\"Foo\",\"l\":\"m(T)\",\"u\":\"m(Y)\"}\"\"\");\n+    }\n+\n+    \/*\n+     * Create confusion between the class type parameter\n+     * and a like-named constructor\/method type parameter.\n+     *\/\n+    @Test\n+    public void test2(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                public abstract class Foo<T> {\n+                    public Foo(T arg) { }\n+                    public <T extends X> Foo(T arg) { }\n+                    public abstract T m(T arg);\n+                    public abstract <T extends X> T m(T arg);\n+                }\n+                class X { }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                src.resolve(\"Foo.java\").toString());\n+\n+        checkExit(Exit.OK);\n+        \/\/ constructors\n+        checkOutput(\"Foo.html\", true, \"\"\"\n+                <section class=\"constructor-summary\" id=\"constructor-summary\">\n+                <h2>Constructor Summary<\/h2>\n+                <div class=\"caption\"><span>Constructors<\/span><\/div>\n+                <div class=\"summary-table two-column-summary\">\n+                <div class=\"table-header col-first\">Constructor<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-constructor-name even-row-color\"><code>\\\n+                <a href=\"#%3Cinit%3E(T)\" class=\"member-name-link\">Foo<\/a>\\\n+                <wbr>(<a href=\"Foo.html\" title=\"type parameter in Foo\">T<\/a>&nbsp;arg)<\/code><\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                <div class=\"col-constructor-name odd-row-color\"><code>\\\n+                <a href=\"#%3Cinit%3E(X)\" class=\"member-name-link\">Foo<\/a><wbr>(T&nbsp;arg)<\/code><\/div>\n+                <div class=\"col-last odd-row-color\">&nbsp;<\/div>\n+                <\/div>\n+                <\/section>\"\"\");\n+        checkOutput(\"Foo.html\", true, \"\"\"\n+                <li><a href=\"#constructor-detail\" tabindex=\"0\">Constructor Details<\/a>\n+                <ol class=\"toc-list\">\n+                <li><a href=\"#%3Cinit%3E(T)\" tabindex=\"0\">Foo(T)<\/a><\/li>\n+                <li><a href=\"#%3Cinit%3E(X)\" tabindex=\"0\">Foo(T)<\/a><\/li>\n+                <\/ol>\n+                <\/li>\"\"\");\n+        checkOutput(\"index-all.html\", true, \"\"\"\n+                <dt><a href=\"Foo.html#%3Cinit%3E(T)\" class=\"member-name-link\">Foo(T)<\/a>\\\n+                 - Constructor for class <a href=\"Foo.html\" title=\"class in Unnamed Package\">Foo<\/a><\/dt>\n+                <dd>&nbsp;<\/dd>\n+                <dt><a href=\"Foo.html#%3Cinit%3E(X)\" class=\"member-name-link\">Foo(T)<\/a>\\\n+                 - Constructor for class <a href=\"Foo.html\" title=\"class in Unnamed Package\">Foo<\/a><\/dt>\n+                <dd>&nbsp;<\/dd>\"\"\");\n+        checkOutput(\"member-search-index.js\", true, \"\"\"\n+                {\"p\":\"<Unnamed>\",\"c\":\"Foo\",\"l\":\"Foo(T)\",\"u\":\"%3Cinit%3E(T)\"},\\\n+                {\"p\":\"<Unnamed>\",\"c\":\"Foo\",\"l\":\"Foo(T)\",\"u\":\"%3Cinit%3E(X)\"}\"\"\");\n+        \/\/ methods\n+        checkOutput(\"Foo.html\", true, \"\"\"\n+                <div class=\"col-first even-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\"><code>abstract <a href=\"Foo.html\" title=\"type parameter in Foo\">T<\/a><\/code><\/div>\n+                <div class=\"col-second even-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\"><code><a href=\"#m(T)\" class=\"member-name-link\">m<\/a>\\\n+                <wbr>(<a href=\"Foo.html\" title=\"type parameter in Foo\">T<\/a>&nbsp;arg)<\/code><\/div>\n+                <div class=\"col-last even-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\">&nbsp;<\/div>\n+                <div class=\"col-first odd-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\"><code>abstract &lt;T extends X&gt;<br>T<\/code><\/div>\n+                <div class=\"col-second odd-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\"><code><a href=\"#m(X)\" class=\"member-name-link\">m<\/a><wbr>(T&nbsp;arg)<\/code><\/div>\n+                <div class=\"col-last odd-row-color method-summary-table method-summary-table-tab2 \\\n+                method-summary-table-tab3\">&nbsp;<\/div>\"\"\");\n+        checkOutput(\"Foo.html\", true, \"\"\"\n+                <li><a href=\"#method-detail\" tabindex=\"0\">Method Details<\/a>\n+                <ol class=\"toc-list\">\n+                <li><a href=\"#m(T)\" tabindex=\"0\">m(T)<\/a><\/li>\n+                <li><a href=\"#m(X)\" tabindex=\"0\">m(T)<\/a><\/li>\n+                <\/ol>\n+                <\/li>\"\"\");\n+        checkOutput(\"index-all.html\", true, \"\"\"\n+                <dt><a href=\"Foo.html#m(T)\" class=\"member-name-link\">m(T)<\/a>\\\n+                 - Method in class <a href=\"Foo.html\" title=\"class in Unnamed Package\">Foo<\/a><\/dt>\n+                <dd>&nbsp;<\/dd>\n+                <dt><a href=\"Foo.html#m(X)\" class=\"member-name-link\">m(T)<\/a>\\\n+                 - Method in class <a href=\"Foo.html\" title=\"class in Unnamed Package\">Foo<\/a><\/dt>\n+                <dd>&nbsp;<\/dd>\"\"\");\n+        checkOutput(\"member-search-index.js\", true, \"\"\"\n+                {\"p\":\"<Unnamed>\",\"c\":\"Foo\",\"l\":\"m(T)\"},\\\n+                {\"p\":\"<Unnamed>\",\"c\":\"Foo\",\"l\":\"m(T)\",\"u\":\"m(X)\"}\"\"\");\n+    }\n+\n+    @Test\n+    public void testNewAndDeprecated(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                public abstract class Foo {\n+                    \/** @since today *\/\n+                    @Deprecated(since=\"tomorrow\")\n+                    public Foo(T arg) { }\n+                    \/** @since today *\/\n+                    @Deprecated(since=\"tomorrow\")\n+                    public <T extends X> Foo(T arg) { }\n+                    \/** @since today *\/\n+                    @Deprecated(since=\"tomorrow\")\n+                    public <T extends Y> Foo(T arg) { }\n+                    \/** @since today *\/\n+                    @Deprecated(since=\"tomorrow\")\n+                    public abstract T m(T arg);\n+                    \/** @since today *\/\n+                    @Deprecated(since=\"tomorrow\")\n+                    public abstract <T extends X> T m(T arg);\n+                    \/** @since today *\/\n+                    @Deprecated(since=\"tomorrow\")\n+                    public abstract <T extends Y> T m(T arg);\n+                }\n+                class T { }\n+                class X { }\n+                class Y { }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--since\", \"today\",\n+                src.resolve(\"Foo.java\").toString());\n+\n+        checkExit(Exit.OK);\n+        checkOutput(\"new-list.html\", true, \"\"\"\n+                <div class=\"col-summary-item-name even-row-color\"><a href=\"Foo.html#m(T)\">Foo.m<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second even-row-color\">today<\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                <div class=\"col-summary-item-name odd-row-color\"><a href=\"Foo.html#m(X)\">Foo.m<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second odd-row-color\">today<\/div>\n+                <div class=\"col-last odd-row-color\">&nbsp;<\/div>\n+                <div class=\"col-summary-item-name even-row-color\"><a href=\"Foo.html#m(Y)\">Foo.m<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second even-row-color\">today<\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\"\"\");\n+        checkOutput(\"new-list.html\", true, \"\"\"\n+                <div class=\"col-summary-item-name even-row-color\"><a href=\"Foo.html#%3Cinit%3E(T)\">Foo<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second even-row-color\">today<\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                <div class=\"col-summary-item-name odd-row-color\"><a href=\"Foo.html#%3Cinit%3E(X)\">Foo<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second odd-row-color\">today<\/div>\n+                <div class=\"col-last odd-row-color\">&nbsp;<\/div>\n+                <div class=\"col-summary-item-name even-row-color\"><a href=\"Foo.html#%3Cinit%3E(Y)\">Foo<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second even-row-color\">today<\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\"\"\");\n+        checkOutput(\"deprecated-list.html\", true, \"\"\"\n+                <div class=\"col-summary-item-name even-row-color\"><a href=\"Foo.html#m(T)\">Foo.m<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second even-row-color\">tomorrow<\/div>\n+                <div class=\"col-last even-row-color\"><\/div>\n+                <div class=\"col-summary-item-name odd-row-color\"><a href=\"Foo.html#m(X)\">Foo.m<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second odd-row-color\">tomorrow<\/div>\n+                <div class=\"col-last odd-row-color\"><\/div>\n+                <div class=\"col-summary-item-name even-row-color\"><a href=\"Foo.html#m(Y)\">Foo.m<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second even-row-color\">tomorrow<\/div>\n+                <div class=\"col-last even-row-color\"><\/div>\"\"\");\n+        checkOutput(\"deprecated-list.html\", true, \"\"\"\n+                <div class=\"col-summary-item-name even-row-color\"><a href=\"Foo.html#%3Cinit%3E(T)\">Foo<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second even-row-color\">tomorrow<\/div>\n+                <div class=\"col-last even-row-color\"><\/div>\n+                <div class=\"col-summary-item-name odd-row-color\"><a href=\"Foo.html#%3Cinit%3E(X)\">Foo<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second odd-row-color\">tomorrow<\/div>\n+                <div class=\"col-last odd-row-color\"><\/div>\n+                <div class=\"col-summary-item-name even-row-color\"><a href=\"Foo.html#%3Cinit%3E(Y)\">Foo<wbr>(T)<\/a><\/div>\n+                <div class=\"col-second even-row-color\">tomorrow<\/div>\n+                <div class=\"col-last even-row-color\"><\/div>\"\"\");\n+    }\n+\n+    @Test\n+    public void testPreview(Path base) throws IOException {\n+        \/\/ unlike that for other tests, here we cannot simulate ambiguity between\n+        \/\/ a type parameter and a like-named class, because for that the class\n+        \/\/ needs to be in the unnamed package, otherwise its FQN won't be T\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                import jdk.internal.javac.PreviewFeature;\n+                public abstract class Foo {\n+                    @PreviewFeature(feature=PreviewFeature.Feature.TEST)\n+                    public <T extends X> Foo(T arg) { }\n+                    @PreviewFeature(feature=PreviewFeature.Feature.TEST)\n+                    public <T extends Y> Foo(T arg) { }\n+                    @PreviewFeature(feature=PreviewFeature.Feature.TEST)\n+                    public abstract <T extends X> T m(T arg);\n+                    @PreviewFeature(feature=PreviewFeature.Feature.TEST)\n+                    public abstract <T extends Y> T m(T arg);\n+                }\n+                class X { }\n+                class Y { }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--patch-module\", \"java.base=\" + src.toAbsolutePath().toString(),\n+                src.resolve(\"p\").resolve(\"Foo.java\").toString());\n+\n+        checkExit(Exit.OK);\n+        checkOutput(\"preview-list.html\", true, \"\"\"\n+                <div class=\"col-summary-item-name even-row-color method method-tab1\">\\\n+                <a href=\"java.base\/p\/Foo.html#m(T)\">p.Foo.m<wbr>(T)<\/a><sup>\\\n+                <a href=\"java.base\/p\/Foo.html#preview-m(T)\">PREVIEW<\/a><\/sup><\/div>\n+                <div class=\"col-second even-row-color method method-tab1\">Test Feature<\/div>\n+                <div class=\"col-last even-row-color method method-tab1\"><\/div>\n+                <div class=\"col-summary-item-name odd-row-color method method-tab1\">\\\n+                <a href=\"java.base\/p\/Foo.html#m(p.Y)\">p.Foo.m<wbr>(T)<\/a><sup>\\\n+                <a href=\"java.base\/p\/Foo.html#preview-m(p.Y)\">PREVIEW<\/a><\/sup><\/div>\n+                <div class=\"col-second odd-row-color method method-tab1\">Test Feature<\/div>\n+                <div class=\"col-last odd-row-color method method-tab1\"><\/div>\"\"\");\n+        checkOutput(\"preview-list.html\", true, \"\"\"\n+                <div class=\"col-summary-item-name even-row-color constructor constructor-tab1\">\\\n+                <a href=\"java.base\/p\/Foo.html#%3Cinit%3E(T)\">p.Foo<wbr>(T)<\/a><sup>\\\n+                <a href=\"java.base\/p\/Foo.html#preview-%3Cinit%3E(T)\">PREVIEW<\/a><\/sup><\/div>\n+                <div class=\"col-second even-row-color constructor constructor-tab1\">Test Feature<\/div>\n+                <div class=\"col-last even-row-color constructor constructor-tab1\"><\/div>\n+                <div class=\"col-summary-item-name odd-row-color constructor constructor-tab1\">\\\n+                <a href=\"java.base\/p\/Foo.html#%3Cinit%3E(p.Y)\">p.Foo<wbr>(T)<\/a><sup>\\\n+                <a href=\"java.base\/p\/Foo.html#preview-%3Cinit%3E(p.Y)\">PREVIEW<\/a><\/sup><\/div>\n+                <div class=\"col-second odd-row-color constructor constructor-tab1\">Test Feature<\/div>\n+                <div class=\"col-last odd-row-color constructor constructor-tab1\"><\/div>\"\"\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testErasure\/TestErasure.java","additions":381,"deletions":0,"binary":false,"changes":381,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8316972\n+ * @bug 8316972 8325217\n@@ -110,3 +110,2 @@\n-                <div class=\"member-signature\"><span class=\"modifiers\">sealed<\/span>&nbsp;<span clas\\\n-                s=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">restrictedMethod<\/span>\\\n-                ()<\/div>\n+                <div class=\"member-signature\"><span class=\"return-type\">void<\/span>&nbsp;<span \\\n+                class=\"element-name\">restrictedMethod<\/span>()<\/div>\n@@ -124,3 +123,2 @@\n-                <div class=\"member-signature\"><span class=\"modifiers\">sealed<\/span>&nbsp;<span clas\\\n-                s=\"return-type\">int<\/span>&nbsp;<span class=\"element-name\">restrictedPreviewMethod<\\\n-                \/span>()<\/div>\n+                <div class=\"member-signature\"><span class=\"return-type\">int<\/span>&nbsp;<span class=\\\n+                \"element-name\">restrictedPreviewMethod<\/span>()<\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRestricted\/TestRestricted.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * @test  \/nodynamiccopyright\/\n+ * @bug 8328649\n+ * @summary Verify local classes in constructor prologues don't have enclosing instances\n+ * @compile\/fail\/ref=LocalClassCtorPrologue.out -XDrawDiagnostics LocalClassCtorPrologue.java\n+ * @enablePreview\n+ *\/\n+\n+class LocalClassCtorPrologue {\n+\n+    int x;\n+\n+    LocalClassCtorPrologue() {\n+        class Local {\n+            {\n+                x++;                \/\/ this should fail\n+            }\n+        }\n+        super();\n+    }\n+\n+    public class Inner {\n+        public Inner() {\n+            class Local {\n+                {\n+                    x++;            \/\/ this should work\n+                }\n+            };\n+            super();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/LocalClassCtorPrologue.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+LocalClassCtorPrologue.java:16:17: compiler.err.no.encl.instance.of.type.in.scope: LocalClassCtorPrologue\n+- compiler.note.preview.filename: LocalClassCtorPrologue.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n","filename":"test\/langtools\/tools\/javac\/LocalClassCtorPrologue.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -410,26 +410,0 @@\n-    \/\/ local class declared before super(), but not used until after super()\n-    public static class Test20 {\n-        public Test20() {\n-            class Foo {\n-                Foo() {\n-                    Test20.this.hashCode();\n-                }\n-            }\n-            super();\n-            new Foo();\n-        }\n-    }\n-\n-    \/\/ local class inside super() parameter list\n-    public static class Test21 extends AtomicReference<Object> {\n-        private int x;\n-        public Test21() {\n-            super(switch (\"foo\".hashCode()) {\n-                default -> {\n-                    class Nested {{ System.out.println(x); }}       \/\/ class is NOT instantiated - OK\n-                    yield \"bar\";\n-                }\n-            });\n-        }\n-    }\n-\n@@ -477,2 +451,0 @@\n-        new Test20();\n-        new Test21();\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8328747\n+ * @summary WrongMethodTypeException with pattern matching on switch on sealed classes\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ * @build toolbox.ToolBox toolbox.JavapTask\n+ * @compile T8328747.java\n+ * @run main T8328747\n+ *\/\n+\n+import toolbox.*;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class T8328747 extends TestRunner  {\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new T8328747().runTests();\n+    }\n+\n+    T8328747() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void test(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package test;\n+                public class Test {\n+                   public static void main(String[] args) {\n+                     f(new P());\n+                     f(new O());\n+                   }\n+\n+                   private static void f(I info) {\n+                     switch (info) {\n+                       case P p -> System.err.println(p);\n+                       case O o -> System.err.println(o);\n+                     }\n+                   }\n+\n+                   static sealed interface I permits P, O {}\n+                   private abstract static class A {}\n+                   static final class P extends A implements I {}\n+                   static final class O extends A implements I {}\n+                }\n+                \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        {\/\/with --release:\n+            new JavacTask(tb)\n+                    .options(\"--release\", \"21\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll();\n+\n+            String javapOut = new JavapTask(tb)\n+                    .options(\"-v\")\n+                    .classpath(classes.toString())\n+                    .classes(\"test.Test\")\n+                    .run()\n+                    .getOutput(Task.OutputKind.DIRECT);\n+\n+            if (!javapOut.contains(\"#25 = InvokeDynamic      #0:#26         \/\/ #0:typeSwitch:(Ljava\/lang\/Object;I)I\"))\n+                throw new AssertionError(\"typeSwitch for a version less than 23 should accept a static type of java.lang.Object\");\n+        }\n+\n+        {\/\/without:\n+            new JavacTask(tb)\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll();\n+\n+            String javapOut = new JavapTask(tb)\n+                    .options(\"-v\")\n+                    .classpath(classes.toString())\n+                    .classes(\"test.Test\")\n+                    .run()\n+                    .getOutput(Task.OutputKind.DIRECT);\n+\n+            if (!javapOut.contains(\"#25 = InvokeDynamic      #0:#26         \/\/ #0:typeSwitch:(Ltest\/Test$I;I)I\"))\n+                throw new AssertionError(\"typeSwitch from version 23 and beyond should accept a precise selector type\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8328747.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -117,1 +117,2 @@\n-    public static abstract class AbstractAnnotationValueVisitor<R, P> extends AbstractAnnotationValueVisitor14<R, P> {\n+    @SuppressWarnings(\"preview\")\n+    public static abstract class AbstractAnnotationValueVisitor<R, P> extends AbstractAnnotationValueVisitorPreview<R, P> {\n@@ -128,1 +129,2 @@\n-    public static abstract class AbstractElementVisitor<R, P> extends AbstractElementVisitor14<R, P> {\n+    @SuppressWarnings(\"preview\")\n+    public static abstract class AbstractElementVisitor<R, P> extends AbstractElementVisitorPreview<R, P> {\n@@ -138,1 +140,2 @@\n-    public static abstract class AbstractTypeVisitor<R, P> extends AbstractTypeVisitor14<R, P> {\n+    @SuppressWarnings(\"preview\")\n+    public static abstract class AbstractTypeVisitor<R, P> extends AbstractTypeVisitorPreview<R, P> {\n@@ -148,1 +151,2 @@\n-    public static class ElementKindVisitor<R, P> extends ElementKindVisitor14<R, P> {\n+    @SuppressWarnings(\"preview\")\n+    public static class ElementKindVisitor<R, P> extends ElementKindVisitorPreview<R, P> {\n@@ -169,1 +173,2 @@\n-    public static class ElementScanner<R, P> extends ElementScanner14<R, P> {\n+    @SuppressWarnings(\"preview\")\n+    public static class ElementScanner<R, P> extends ElementScannerPreview<R, P> {\n@@ -188,1 +193,2 @@\n-    public static class SimpleAnnotationValueVisitor<R, P> extends SimpleAnnotationValueVisitor14<R, P> {\n+    @SuppressWarnings(\"preview\")\n+    public static class SimpleAnnotationValueVisitor<R, P> extends SimpleAnnotationValueVisitorPreview<R, P> {\n@@ -209,1 +215,2 @@\n-    public static class SimpleElementVisitor<R, P> extends SimpleElementVisitor14<R, P> {\n+    @SuppressWarnings(\"preview\")\n+    public static class SimpleElementVisitor<R, P> extends SimpleElementVisitorPreview<R, P> {\n@@ -230,1 +237,2 @@\n-    public static class SimpleTypeVisitor<R, P> extends SimpleTypeVisitor14<R, P> {\n+    @SuppressWarnings(\"preview\")\n+    public static class SimpleTypeVisitor<R, P> extends SimpleTypeVisitorPreview<R, P> {\n@@ -251,1 +259,2 @@\n-    public static class TypeKindVisitor<R, P> extends TypeKindVisitor14<R, P> {\n+    @SuppressWarnings(\"preview\")\n+    public static class TypeKindVisitor<R, P> extends TypeKindVisitorPreview<R, P> {\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,1379 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public abstract class AllocationMerges {\n+    private static final int SIZE        = 1000000;\n+    private static final boolean cond1[] = new boolean[SIZE];\n+    private static final boolean cond2[] = new boolean[SIZE];\n+    private static final int ws[]        = new int[SIZE];\n+    private static final int xs[]        = new int[SIZE];\n+    private static final int ys[]        = new int[SIZE];\n+    private static final int zs[]        = new int[SIZE];\n+    private static Load global_escape   = new Load(2022, 2023);\n+    private RandomGenerator rng          = RandomGeneratorFactory.getDefault().create();\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @Setup\n+    public void setup() {\n+        for (int i = 0; i < SIZE; i++) {\n+            cond1[i] = i % 2 == 0;\n+            cond2[i] = i % 2 == 1;\n+\n+            ws[i] = rng.nextInt();\n+            xs[i] = rng.nextInt();\n+            ys[i] = rng.nextInt();\n+            zs[i] = rng.nextInt();\n+        }\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testGlobalEscape(int x, int y) {\n+        Load p = new Load(x, y);\n+\n+        AllocationMerges.global_escape = p;\n+\n+        return p.x * p.y;\n+    }\n+\n+    @Benchmark\n+    public void testGlobalEscape_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testGlobalEscape(xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testArgEscape(int x, int y) {\n+        Load p = new Load(x, y);\n+\n+        int val = dummy(p);\n+\n+        return val + p.x + p.y;\n+    }\n+\n+    @Benchmark\n+    public void testArgEscape_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testArgEscape(xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testEscapeInCallAfterMerge(boolean cond, boolean cond2, int x, int y) {\n+        Load p = new Load(x, x);\n+\n+        if (cond) {\n+            p = new Load(y, y);\n+        }\n+\n+        if (cond2) {\n+            dummy(p);\n+        }\n+\n+        return p.x * p.y;\n+    }\n+\n+    @Benchmark\n+    public void testEscapeInCallAfterMerge_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testEscapeInCallAfterMerge(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testNoEscapeWithWriteInLoop(boolean cond, boolean cond2, int x, int y) {\n+        Load p = new Load(x, y);\n+        int res = 0;\n+\n+        if (cond) {\n+            p = new Load(y, x);\n+        }\n+\n+        for (int i=0; i<100; i++) {\n+            p.x += p.y + i;\n+            p.y += p.x + i;\n+        }\n+\n+        return res + p.x + p.y;\n+    }\n+\n+    @Benchmark\n+    public void testNoEscapeWithWriteInLoop_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testNoEscapeWithWriteInLoop(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testPollutedWithWrite(boolean cond, int l) {\n+        Shape obj1 = new Square(l);\n+        Shape obj2 = new Square(l);\n+        Shape obj = null;\n+\n+        if (cond) {\n+            obj = obj1;\n+        } else {\n+            obj = obj2;\n+        }\n+\n+        for (int i=1; i<132; i++) {\n+            obj.x++;\n+        }\n+\n+        return obj1.x + obj2.y;\n+    }\n+\n+    @Benchmark\n+    public void testPollutedWithWrite_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testPollutedWithWrite(cond1[i], xs[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testPollutedPolymorphic(boolean cond, int l) {\n+        Shape obj1 = new Square(l);\n+        Shape obj2 = new Circle(l);\n+        Shape obj = (cond ? obj1 : obj2);\n+        int res = 0;\n+\n+        for (int i=1; i<232; i++) {\n+            res += obj.x;\n+        }\n+\n+        return res + obj1.x + obj2.y;\n+    }\n+\n+    @Benchmark\n+    public void testPollutedPolymorphic_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testPollutedPolymorphic(cond1[i], xs[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testMergedLoadAfterDirectStore(boolean cond, int x, int y) {\n+        Load p0 = new Load(x, x);\n+        Load p1 = new Load(y, y);\n+        Load p = null;\n+\n+        if (cond) {\n+            p = p0;\n+        } else {\n+            p = p1;\n+        }\n+\n+        p0.x = x * y;\n+\n+        return p.x;\n+    }\n+\n+    @Benchmark\n+    public void testMergedLoadAfterDirectStore_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testMergedLoadAfterDirectStore(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testMergedAccessAfterCallWithWrite(boolean cond, int x, int y) {\n+        Load p2 = new Load(x, x);\n+        Load p = new Load(y, y);\n+\n+        p.x = p.x * y;\n+\n+        if (cond) {\n+            p = new Load(x, x);\n+        }\n+\n+        dummy(p2);\n+\n+        for (int i=3; i<324; i++) {\n+            p.x += i * x;\n+        }\n+\n+        return p.x;\n+    }\n+\n+    @Benchmark\n+    public void testMergedAccessAfterCallWithWrite_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testMergedAccessAfterCallWithWrite(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testLoadAfterTrap(boolean cond, int x, int y) {\n+        Load p = null;\n+\n+        if (cond) {\n+            p = new Load(x, x);\n+        } else {\n+            p = new Load(y, y);\n+        }\n+\n+        dummy(x+y);\n+\n+        return p.x + p.y;\n+    }\n+\n+    @Benchmark\n+    public void testLoadAfterTrap_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testLoadAfterTrap(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testCondAfterMergeWithNull(boolean cond1, boolean cond2, int x, int y) {\n+        Load p = null;\n+\n+        if (cond1) {\n+            p = new Load(y, x);\n+        }\n+\n+        if (cond2 && cond1) {\n+            return p.x;\n+        } else {\n+            return 321;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCondAfterMergeWithNull_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testCondAfterMergeWithNull(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testLoadAfterLoopAlias(boolean cond, int x, int y) {\n+        Load a = new Load(x, y);\n+        Load b = new Load(y, x);\n+        Load c = a;\n+\n+        for (int i=10; i<232; i++) {\n+            if (i == x) {\n+                c = b;\n+            }\n+        }\n+\n+        return cond ? c.x : c.y;\n+    }\n+\n+    @Benchmark\n+    public void testLoadAfterLoopAlias_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testLoadAfterLoopAlias(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testCallTwoSide(boolean cond1, int x, int y) {\n+        Load p = dummy(x, y);\n+\n+        if (cond1) {\n+            p = dummy(y, x);\n+        }\n+\n+        return (p != null) ? p.x : 0;\n+    }\n+\n+    @Benchmark\n+    public void testCallTwoSide_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testCallTwoSide(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testMergedAccessAfterCallNoWrite(boolean cond, int x, int y) {\n+        Load p2 = new Load(x, x);\n+        Load p = new Load(y, y);\n+        int res = 0;\n+\n+        p.x = p.x * y;\n+\n+        if (cond) {\n+            p = new Load(y, y);\n+        }\n+\n+        dummy(p2);\n+\n+        for (int i=3; i<324; i++) {\n+            res += p.x + i * x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public void testMergedAccessAfterCallNoWrite_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testMergedAccessAfterCallNoWrite(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testCmpMergeWithNull_Second(boolean cond, int x, int y) {\n+        Load p = null;\n+\n+        if (cond) {\n+            p = new Load(x*x, y*y);\n+        }\n+\n+        dummy(x);\n+\n+        if (p != null) {\n+            return p.x * p.y;\n+        } else {\n+            return 1984;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCmpMergeWithNull_Second_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testCmpMergeWithNull_Second(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testObjectIdentity(boolean cond, int x, int y) {\n+        Load o = new Load(x, y);\n+\n+        if (cond && x == 42) {\n+            o = global_escape;\n+        }\n+\n+        return o.x + o.y;\n+    }\n+\n+    @Benchmark\n+    public void testObjectIdentity_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testObjectIdentity(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testSubclassesTrapping(boolean c1, boolean c2, int x, int y, int w, int z) {\n+        new A();\n+        Root s = new Home(x, y);\n+        new B();\n+\n+        if (c1) {\n+            new C();\n+            s = new Etc(\"Hello\");\n+            new D();\n+        } else {\n+            new E();\n+            s = new Usr(y, x, z);\n+            new F();\n+        }\n+\n+        int res = s.a;\n+        dummy();\n+\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public void testSubclassesTrapping_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testSubclassesTrapping(cond1[i], cond2[i], xs[i], ys[i], ws[i], zs[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testCmpMergeWithNull(boolean cond, int x, int y) {\n+        Load p = null;\n+\n+        if (cond) {\n+            p = new Load(x*x, y*y);\n+        } else if (x > y) {\n+            p = new Load(x+y, x*y);\n+        }\n+\n+        if (p != null) {\n+            return p.x * p.y;\n+        } else {\n+            return 1984;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCmpMergeWithNull_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testCmpMergeWithNull(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testSubclasses(boolean c1, boolean c2, int x, int y, int w, int z) {\n+        new A();\n+        Root s = new Home(x, y);\n+        new B();\n+\n+        if (c1) {\n+            new C();\n+            s = new Etc(\"Hello\");\n+            new D();\n+        } else {\n+            new E();\n+            s = new Usr(y, x, z);\n+            new F();\n+        }\n+\n+        new G();\n+\n+        return s.a;\n+    }\n+\n+    @Benchmark\n+    public void testSubclasses_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testSubclasses(cond1[i], cond2[i], xs[i], ys[i], ws[i], zs[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ ------------------ Some Scalar Replacement Should Happen in The Tests Below ------------------- \/\/\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testPartialPhis(boolean cond, int l, int x, int y) {\n+        int k = l;\n+\n+        if (l == 0) {\n+            k = l + 1;\n+        } else if (l == 2) {\n+            k = l + 2;\n+        } else if (l == 3) {\n+            new Load(x, y);\n+        } else if (l == 4) {\n+            new Load(y, x);\n+        }\n+\n+        return k;\n+    }\n+\n+    @Benchmark\n+    public void testPartialPhis_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testPartialPhis(cond1[i], xs[i], ys[i], zs[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testPollutedNoWrite(boolean cond, int l) {\n+        Shape obj1 = new Square(l);\n+        Shape obj2 = new Square(l);\n+        Shape obj = null;\n+        int res = 0;\n+\n+        if (cond) {\n+            obj = obj1;\n+        } else {\n+            obj = obj2;\n+        }\n+\n+        for (int i=1; i<132; i++) {\n+            res += obj.x;\n+        }\n+\n+        return res + obj1.x + obj2.y;\n+    }\n+\n+    @Benchmark\n+    public void testPollutedNoWrite_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testPollutedNoWrite(cond1[i], xs[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testThreeWayAliasedAlloc(boolean cond, int x, int y) {\n+        Load p1 = new Load(x, y);\n+        Load p2 = new Load(x+1, y+1);\n+        Load p3 = new Load(x+2, y+2);\n+\n+        if (cond) {\n+            p3 = p1;\n+        } else {\n+            p3 = p2;\n+        }\n+\n+        return p3.x + p3.y;\n+    }\n+\n+    @Benchmark\n+    public void testThreeWayAliasedAlloc_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testThreeWayAliasedAlloc(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int TestTrapAfterMerge(boolean cond, int x, int y) {\n+        Load p = new Load(x, x);\n+\n+        if (cond) {\n+            p = new Load(y, y);\n+        }\n+\n+        for (int i=402; i<432; i+=x) {\n+            x++;\n+        }\n+\n+        return p.x + x;\n+    }\n+\n+    @Benchmark\n+    public void TestTrapAfterMerge_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += TestTrapAfterMerge(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    Load testNestedObjectsObject(boolean cond, int x, int y) {\n+        Picture p = new Picture(x, x, y);\n+\n+        if (cond) {\n+            p = new Picture(y, y, x);\n+        }\n+\n+        return p.position;\n+    }\n+\n+    @Benchmark\n+    public void testNestedObjectsObject_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testNestedObjectsObject(cond1[i], xs[i], ys[i]).x;\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testNestedObjectsNoEscapeObject(boolean cond, int x, int y) {\n+        Picture p = new Picture(x, x, y);\n+\n+        if (cond) {\n+            p = new Picture(y, y, x);\n+        }\n+\n+        return p.position.x;\n+    }\n+\n+    @Benchmark\n+    public void testNestedObjectsNoEscapeObject_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testNestedObjectsNoEscapeObject(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    Load[] testNestedObjectsArray(boolean cond, int x, int y) {\n+        PicturePositions p = new PicturePositions(x, y, x+y);\n+\n+        if (cond) {\n+            p = new PicturePositions(x+1, y+1, x+y+1);\n+        }\n+\n+        return p.positions;\n+    }\n+\n+    @Benchmark\n+    public void testNestedObjectsArray_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            Load[] partial = testNestedObjectsArray(cond1[i], xs[i], ys[i]);\n+            result += partial[0].x;\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testTrappingAfterMerge(boolean cond, int x, int y) {\n+        Load p = new Load(x, y);\n+        int res = 0;\n+\n+        if (cond) {\n+            p = new Load(y, y);\n+        }\n+\n+        for (int i=832; i<932; i++) {\n+            res += p.x;\n+        }\n+\n+        if (x > y) {\n+            res += new Load(p.x, p.y).x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public void testTrappingAfterMerge_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testTrappingAfterMerge(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testSimpleAliasedAlloc(boolean cond, int x, int y) {\n+        Load p1 = new Load(x, y);\n+        Load p2 = new Load(y, x);\n+        Load p = p1;\n+\n+        if (cond) {\n+            p = p2;\n+        }\n+\n+        return p.x * p.y;\n+    }\n+\n+    @Benchmark\n+    public void testSimpleAliasedAlloc_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testSimpleAliasedAlloc(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testSimpleDoubleMerge(boolean cond, int x, int y) {\n+        Load p1 = new Load(x, y);\n+        Load p2 = new Load(x+1, y+1);\n+\n+        if (cond) {\n+            p1 = new Load(y, x);\n+            p2 = new Load(y+1, x+1);\n+        }\n+\n+        return p1.x + p2.y;\n+    }\n+\n+    @Benchmark\n+    public void testSimpleDoubleMerge_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testSimpleDoubleMerge(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testConsecutiveSimpleMerge(boolean cond1, boolean cond2, int x, int y) {\n+        Load p0 = new Load(x, x);\n+        Load p1 = new Load(x, y);\n+        Load pA = null;\n+\n+        Load p2 = new Load(y, x);\n+        Load p3 = new Load(y, y);\n+        Load pB = null;\n+\n+        if (cond1) {\n+            pA = p0;\n+        } else {\n+            pA = p1;\n+        }\n+\n+        if (cond2) {\n+            pB = p2;\n+        } else {\n+            pB = p3;\n+        }\n+\n+        return pA.x * pA.y + pB.x * pB.y;\n+    }\n+\n+    @Benchmark\n+    public void testConsecutiveSimpleMerge_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testConsecutiveSimpleMerge(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testDoubleIfElseMerge(boolean cond, int x, int y) {\n+        Load p1 = new Load(x, y);\n+        Load p2 = new Load(x+1, y+1);\n+\n+        if (cond) {\n+            p1 = new Load(y, x);\n+            p2 = new Load(y, x);\n+        } else {\n+            p1 = new Load(x, y);\n+            p2 = new Load(x+1, y+1);\n+        }\n+\n+        return p1.x * p2.y;\n+    }\n+\n+    @Benchmark\n+    public void testDoubleIfElseMerge_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testDoubleIfElseMerge(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testNoEscapeWithLoadInLoop(boolean cond, int x, int y) {\n+        Load p = new Load(x, y);\n+        int res = 0;\n+\n+        if (cond) {\n+            p = new Load(y, x);\n+        }\n+\n+        for (int i=3342; i<4234; i++) {\n+            res += p.x + p.y + i;\n+        }\n+\n+        return res + p.x + p.y;\n+    }\n+\n+    @Benchmark\n+    public void testNoEscapeWithLoadInLoop_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testNoEscapeWithLoadInLoop(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testCmpAfterMerge(boolean cond, boolean cond2, int x, int y) {\n+        Load a = new Load(x, y);\n+        Load b = new Load(y, x);\n+        Load c = null;\n+\n+        if (x+2 >= y-5) {\n+            c = a;\n+        } else {\n+            c = b;\n+        }\n+\n+        return cond2 ? c.x : c.y;\n+    }\n+\n+    @Benchmark\n+    public void testCmpAfterMerge_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testCmpAfterMerge(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testCondAfterMergeWithAllocate(boolean cond1, boolean cond2, int x, int y) {\n+        Load p = new Load(x, y);\n+\n+        if (cond1) {\n+            p = new Load(y, x);\n+        }\n+\n+        if (cond2 && cond1) {\n+            return p.x;\n+        } else {\n+            return 321;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCondAfterMergeWithAllocate_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testCondAfterMergeWithAllocate(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testCondLoadAfterMerge(boolean cond1, boolean cond2, int x, int y) {\n+        Load p = new Load(x, y);\n+\n+        if (cond1) {\n+            p = new Load(y, x);\n+        }\n+\n+        if (cond1 == false && cond2 == false) {\n+            return p.x + 1;\n+        } else if (cond1 == false && cond2 == true) {\n+            return p.x + 30;\n+        } else if (cond1 == true && cond2 == false) {\n+            return p.x + 40;\n+        } else if (cond1 == true && cond2 == true) {\n+            return p.x + 50;\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCondLoadAfterMerge_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testCondLoadAfterMerge(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testIfElseInLoop(int x, int y, int w, int z) {\n+        int res = 0;\n+\n+        for (int i=x; i<y; i++) {\n+            Load obj = new Load(w, z);\n+\n+            if (i % 2 == 1) {\n+                obj = new Load(i, i+1);\n+            } else {\n+                obj = new Load(i-1, i);\n+            }\n+\n+            res += obj.x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public void testIfElseInLoop_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testIfElseInLoop(xs[i] % 100, ys[i] % 100, ws[i], zs[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testLoadInCondAfterMerge(boolean cond, int x, int y) {\n+        Load p = new Load(x, y);\n+\n+        if (cond) {\n+            p = new Load(y, x);\n+        }\n+\n+        if (p.x == 10) {\n+            if (p.y == 10) {\n+                return dummy(10);\n+            } else {\n+                return dummy(20);\n+            }\n+        } else if (p.x == 20) {\n+            if (p.y == 20) {\n+                return dummy(30);\n+            } else {\n+                return dummy(40);\n+            }\n+        }\n+\n+        return 1984;\n+    }\n+\n+    @Benchmark\n+    public void testLoadInCondAfterMerge_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testLoadInCondAfterMerge(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testLoadInLoop(boolean cond, int x, int y) {\n+        Load obj1 = new Load(x, y);\n+        Load obj2 = new Load(y, x);\n+        Load obj = null;\n+        int res = 0;\n+\n+        if (cond) {\n+            obj = obj1;\n+        } else {\n+            obj = obj2;\n+        }\n+\n+        for (int i = 0; i < 532; i++) {\n+            res += obj.x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public void testLoadInLoop_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testLoadInLoop(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testMergesAndMixedEscape(boolean cond, int x, int y) {\n+        Load p1 = new Load(x, y);\n+        Load p2 = new Load(x, y);\n+        int val = 0;\n+\n+        if (cond) {\n+            p1 = new Load(x+1, y+1);\n+            val = dummy(p2);\n+        }\n+\n+        return val + p1.x + p2.y;\n+    }\n+\n+    @Benchmark\n+    public void testMergesAndMixedEscape_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testMergesAndMixedEscape(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testSRAndNSR_NoTrap(boolean cond1, int x, int y) {\n+        Load p = new Load(x, y);\n+\n+        if (cond1) {\n+            p = new Load(x+1, y+1);\n+            global_escape = p;\n+        }\n+\n+        return p.y;\n+    }\n+\n+    @Benchmark\n+    public void testSRAndNSR_NoTrap_caller(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testSRAndNSR_NoTrap(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testSRAndNSR_Trap(boolean is_c2, boolean cond1, boolean cond2, int x, int y) {\n+        Load p = new Load(x, y);\n+\n+        if (cond1) {\n+            p = new Load(x+1, y+1);\n+            global_escape = p;\n+        }\n+\n+        int res = p.x;\n+        if (is_c2) {\n+            \/\/ This will show up to C2 as a trap.\n+            dummy_defaults();\n+        }\n+\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public void testSRAndNSR_Trap_caller(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testSRAndNSR_Trap(true, cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    char testString_one(boolean cond1) {\n+        String p = new String(\"Java\");\n+\n+        if (cond1) {\n+            p = new String(\"HotSpot\");\n+        }\n+\n+        return p.charAt(0);\n+    }\n+\n+    @Benchmark\n+    public void testString_one_caller(Blackhole bh) {\n+        char result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testString_two(cond1[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private char testString_two(boolean cond1) {\n+        String p = new String(\"HotSpot\");\n+\n+        if (cond1) {\n+            p = dummy(\"String\");\n+            if (p == null) return 'J';\n+        }\n+\n+        return p.charAt(0);\n+    }\n+\n+    @Benchmark\n+    public void testString_two_caller(Blackhole bh) {\n+        char result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testString_two(cond1[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ ------------------ Utility for Benchmarking ------------------- \/\/\n+\n+    @Fork(value = 3, jvmArgsPrepend = {\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:+UseTLAB\",\n+        \"-XX:-ReduceAllocationMerges\",\n+    })\n+    public static class NopRAM extends AllocationMerges {\n+    }\n+\n+    @Fork(value = 3, jvmArgsPrepend = {\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:+ReduceAllocationMerges\",\n+    })\n+    public static class YesRAM extends AllocationMerges {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static void dummy() {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static int dummy(Load p) {\n+        return p.x * p.y;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static int dummy(int x) {\n+        return x;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static Load dummy(int x, int y) {\n+        return new Load(x, y);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static String dummy(String str) {\n+        return str;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static ADefaults dummy_defaults() {\n+        return new ADefaults();\n+    }\n+\n+    static class Load {\n+        long id;\n+        String name;\n+        Integer[] values = new Integer[10];\n+        int x, y;\n+\n+        @CompilerControl(CompilerControl.Mode.INLINE)\n+        Load(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (!(o instanceof Load)) return false;\n+            Load p = (Load) o;\n+            return (p.x == x) && (p.y == y);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return x + y;\n+        }\n+    }\n+\n+    class Shape {\n+        int x, y, l;\n+        Shape(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    class Square extends Shape {\n+        Square(int l) {\n+            super(0, 0);\n+            this.l = l;\n+        }\n+    }\n+\n+    class Circle extends Shape {\n+        Circle(int l) {\n+            super(0, 0);\n+            this.l = l;\n+        }\n+    }\n+\n+    static class ADefaults {\n+        static int ble;\n+        int i;\n+        @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+        ADefaults(int i) { this.i = i; }\n+        @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+        ADefaults() { }\n+    }\n+\n+    static class Picture {\n+        public int id;\n+        public Load position;\n+\n+        public Picture(int id, int x, int y) {\n+            this.id = id;\n+            this.position = new Load(x, y);\n+        }\n+    }\n+\n+    static class PicturePositions {\n+        public int id;\n+        public Load[] positions;\n+\n+        @CompilerControl(CompilerControl.Mode.INLINE)\n+        public PicturePositions(int id, int x, int y) {\n+            this.id = id;\n+            this.positions = new Load[] { new Load(x, y), new Load(y, x) };\n+        }\n+    }\n+\n+    class Root {\n+        public int a;\n+        public int b;\n+        public int c;\n+        public int d;\n+        public int e;\n+\n+        public Root(int a, int b, int c, int d, int e) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+            this.d = d;\n+            this.e = e;\n+        }\n+    }\n+\n+    class Usr extends Root {\n+        public float flt;\n+\n+        public Usr(float a, float b, float c) {\n+            super((int)a, (int)b, (int)c, 0, 0);\n+            this.flt = a;\n+        }\n+    }\n+\n+    class Home extends Root {\n+        public double[] arr;\n+\n+        public Home(double a, double b) {\n+            super((int)a, (int)b, 0, 0, 0);\n+            this.arr = new double[] {a, b};\n+        }\n+\n+    }\n+\n+    class Tmp extends Root {\n+        public String s;\n+\n+        public Tmp(String s) {\n+            super((int)s.length(), 0, 0, 0, 0);\n+            this.s = s;\n+        }\n+    }\n+\n+    class Etc extends Root {\n+        public String a;\n+\n+        public Etc(String s) {\n+            super((int)s.length(), 0, 0, 0, 0);\n+            this.a = s;\n+        }\n+    }\n+\n+    class A { }\n+    class B { }\n+    class C { }\n+    class D { }\n+    class E { }\n+    class F { }\n+    class G { }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/AllocationMerges.java","additions":1379,"deletions":0,"binary":false,"changes":1379,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ package org.openjdk.bench.vm.compiler;\n+\n+ import org.openjdk.jmh.annotations.Benchmark;\n+ import org.openjdk.jmh.annotations.BenchmarkMode;\n+ import org.openjdk.jmh.annotations.Fork;\n+ import org.openjdk.jmh.annotations.Measurement;\n+ import org.openjdk.jmh.annotations.Mode;\n+ import org.openjdk.jmh.annotations.OutputTimeUnit;\n+ import org.openjdk.jmh.annotations.Scope;\n+ import org.openjdk.jmh.annotations.Setup;\n+ import org.openjdk.jmh.annotations.State;\n+ import org.openjdk.jmh.annotations.Warmup;\n+\n+ import java.util.concurrent.TimeUnit;\n+\n+ @State(Scope.Thread)\n+ @BenchmarkMode(Mode.AverageTime)\n+ @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+ @Warmup(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+ @Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+ @Fork(value = 3)\n+ public class ComputePI {\n+\n+   @Benchmark\n+   public double compute_pi_int_dbl() {\n+     double pi = 4.0;\n+     boolean sign = false;\n+\n+     for (int i = 3; i < 1000; i += 2) {\n+       if (sign) {\n+         pi += 4.0 \/ i;\n+       } else {\n+         pi -= 4.0 \/ i;\n+       }\n+       sign = !sign;\n+     }\n+     return pi;\n+   }\n+\n+   @Benchmark\n+   public double compute_pi_int_flt() {\n+     float pi = 4.0f;\n+     boolean sign = false;\n+\n+     for (int i = 3; i < 1000; i += 2) {\n+       if (sign) {\n+         pi += 4.0f \/ i;\n+       } else {\n+         pi -= 4.0f \/ i;\n+       }\n+       sign = !sign;\n+     }\n+     return pi;\n+   }\n+\n+   @Benchmark\n+   public double compute_pi_long_dbl() {\n+     double pi = 4.0;\n+     boolean sign = false;\n+\n+     for (long i = 3; i < 1000; i += 2) {\n+       if (sign) {\n+         pi += 4.0 \/ i;\n+       } else {\n+         pi -= 4.0 \/ i;\n+       }\n+       sign = !sign;\n+     }\n+     return pi;\n+   }\n+\n+   @Benchmark\n+   public double compute_pi_long_flt() {\n+     float pi = 4.0f;\n+     boolean sign = false;\n+\n+     for (long i = 3; i < 1000; i += 2) {\n+       if (sign) {\n+         pi += 4.0f \/ i;\n+       } else {\n+         pi -= 4.0f \/ i;\n+       }\n+       sign = !sign;\n+     }\n+     return pi;\n+   }\n+\n+   @Benchmark\n+   public double compute_pi_flt_dbl() {\n+     double pi = 4.0;\n+     boolean sign = false;\n+\n+     for (float i = 3.0f; i < 1000.0f; i += 2.0f) {\n+       if (sign) {\n+         pi += 4.0 \/ i;\n+       } else {\n+         pi -= 4.0 \/ i;\n+       }\n+       sign = !sign;\n+     }\n+     return pi;\n+   }\n+\n+   @Benchmark\n+   public double compute_pi_dbl_flt() {\n+     float pi = 4.0f;\n+     boolean sign = false;\n+\n+     for (float i = 3.0f; i < 1000.0f; i += 2.0f) {\n+       if (sign) {\n+         pi += 4.0f \/ i;\n+       } else {\n+         pi -= 4.0f \/ i;\n+       }\n+       sign = !sign;\n+     }\n+     return pi;\n+   }\n+ }\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/ComputePI.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"}]}