{"files":[{"patch":"@@ -57,1 +57,3 @@\n-  \/\/ No barriers are required to run.\n+  \/\/ Passive mode does not instantiate the machinery to support the card table.\n+  \/\/ Exit if the flag has been explicitly set.\n+  SHENANDOAH_CHECK_FLAG_UNSET(ShenandoahCardBarrier);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,0 +97,8 @@\n+ *\/\n+\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can withstand allocation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n@@ -104,5 +112,0 @@\n- *      -XX:+ShenandoahVerify\n- *      TestAllocIntArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocIntArrays.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -117,0 +117,2 @@\n+ *      -XX:+ShenandoahOOMDuringEvacALot\n+ *      -XX:+ShenandoahVerify\n@@ -121,1 +123,1 @@\n- *      -XX:+ShenandoahOOMDuringEvacALot\n+ *      -XX:+ShenandoahAllocFailureALot\n@@ -127,2 +129,0 @@\n- *      -XX:+ShenandoahAllocFailureALot\n- *      -XX:+ShenandoahVerify\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjectArrays.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,0 +67,5 @@\n+ *      -XX:+UseShenandoahGC\n+ *      -XX:-UseTLAB -XX:+ShenandoahVerify\n+ *      TestHeapUncommit\n+ *\n+ * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n@@ -81,5 +86,0 @@\n- *\n- * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n- *      -XX:+UseShenandoahGC\n- *      -XX:-UseTLAB -XX:+ShenandoahVerify\n- *      TestHeapUncommit\n@@ -102,0 +102,1 @@\n+ *      -XX:-UseTLAB -XX:+ShenandoahVerify\n@@ -106,1 +107,0 @@\n- *      -XX:-UseTLAB -XX:+ShenandoahVerify\n@@ -124,0 +124,1 @@\n+ *      -XX:-UseTLAB -XX:+ShenandoahVerify\n@@ -128,1 +129,0 @@\n- *      -XX:-UseTLAB -XX:+ShenandoahVerify\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHeapUncommit.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @test default\n+ * @test id=default\n@@ -41,1 +41,1 @@\n- * @test generational\n+ * @test id=generational\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestLargeObjectAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-        if (periodic && !output.getOutput().contains(\"Trigger (GLOBAL): Time since last GC\")) {\n-            throw new AssertionError(msg + \": Should have periodic GC in logs\");\n+        if (periodic) {\n+            output.shouldContain(\"Trigger (GLOBAL): Time since last GC\");\n@@ -52,2 +52,2 @@\n-        if (!periodic && output.getOutput().contains(\"Trigger (GLOBAL): Time since last GC\")) {\n-            throw new AssertionError(msg + \": Should not have periodic GC in logs\");\n+        if (!periodic) {\n+            output.shouldNotContain(\"Trigger (GLOBAL): Time since last GC\");\n@@ -66,6 +66,2 @@\n-            if (!output.getOutput().contains(\"Trigger (YOUNG): Time since last GC\")) {\n-                throw new AssertionError(\"Generational mode: Should have periodic young GC in logs\");\n-            }\n-            if (!output.getOutput().contains(\"Trigger (OLD): Time since last GC\")) {\n-                throw new AssertionError(\"Generational mode: Should have periodic old GC in logs\");\n-            }\n+            output.shouldContain(\"Trigger (YOUNG): Time since last GC\");\n+            output.shouldContain(\"Trigger (OLD): Time since last GC\");\n@@ -73,6 +69,2 @@\n-            if (output.getOutput().contains(\"Trigger (YOUNG): Time since last GC\")) {\n-                throw new AssertionError(\"Generational mode: Should not have periodic young GC in logs\");\n-            }\n-            if (output.getOutput().contains(\"Trigger (OLD): Time since last GC\")) {\n-                throw new AssertionError(\"Generational mode: Should not have periodic old GC in logs\");\n-            }\n+            output.shouldNotContain(\"Trigger (YOUNG): Time since last GC\");\n+            output.shouldNotContain(\"Trigger (OLD): Time since last GC\");\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestPeriodicGC.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+ *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify\n@@ -103,1 +104,1 @@\n- *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify\n+ *      -XX:+ShenandoahAllocFailureALot -XX:+ShenandoahVerify\n@@ -108,1 +109,0 @@\n- *      -XX:+ShenandoahAllocFailureALot -XX:+ShenandoahVerify\n@@ -137,1 +137,1 @@\n- * @run main\/othervm\/timeout=300 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRetainObjects.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @test default\n+ * @test id=default\n@@ -39,1 +39,1 @@\n- * @test generational\n+ * @test id=generational\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSmallHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @test default\n+ * @test id=default\n@@ -38,1 +38,1 @@\n- * @test generational\n+ * @test id=generational\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestVerifyLevels.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.shenandoah.generational;\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/*\n- * @test TestCLIModeGenerational\n- * @requires vm.gc.Shenandoah\n- * @summary Test argument processing for -XX:+ShenandoahGCMode=generational.\n- * @library \/testlibrary \/test\/lib \/\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *      -XX:+IgnoreUnrecognizedVMOptions\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n- *      gc.shenandoah.generational.TestCLIModeGenerational\n- *\/\n-\n-public class TestCLIModeGenerational {\n-\n-  private static WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-  public static void main(String args[]) throws Exception {\n-    Boolean using_shenandoah = wb.getBooleanVMFlag(\"UseShenandoahGC\");\n-    String gc_mode = wb.getStringVMFlag(\"ShenandoahGCMode\");\n-    if (!using_shenandoah || !gc_mode.equals(\"generational\"))\n-      throw new IllegalStateException(\"Command-line options not honored!\");\n-  }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestCLIModeGenerational.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -38,1 +38,1 @@\n- * @test TestConcurrentEvac\n+ * @test id=generational\n@@ -56,46 +56,44 @@\n-  private static WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-  static private final int SeedForRandom = 46;\n-  \/\/ Sequence of random numbers should end with same value\n-\n-  \/\/ Smaller table will cause creation of more old-gen garbage\n-  \/\/ as previous entries in table are overwritten with new values.\n-  static private final int TableSize = 53;\n-  static private final int MaxStringLength = 47;\n-  static private final int SentenceLength = 5;\n-\n-  static private Random random = new Random(SeedForRandom);\n-\n-  public static class Node {\n-    static private final int NeighborCount = 48;\n-    static private final int ChildOverwriteCount = 32;\n-    static private final int IntArraySize = 128;\n-\n-    private String name;\n-\n-    \/\/ Each Node instance holds an array containing all substrings of\n-    \/\/ its name\n-\n-    \/\/ This array has entries from 0 .. (name.length() - 1).\n-    \/\/ num_substrings[i] represents the number of substrings that\n-    \/\/ correspond to a name of length i+1.\n-    private static int [] num_substrings;\n-\n-    static {\n-      \/\/ Initialize num_substrings.\n-      \/\/ For a name of length N, there are\n-      \/\/  N substrings of length 1\n-      \/\/  N-1 substrings of length 2\n-      \/\/  N-2 substrings of length 3\n-      \/\/  ...\n-      \/\/  1 substring of length N\n-      \/\/ Note that:\n-      \/\/   num_substrings[0] = 1\n-      \/\/   num_substrings[1] = 3\n-      \/\/   num_substrings[i] = (i+1)+num_substrings[i-1]\n-\n-      num_substrings = new int[MaxStringLength];\n-      num_substrings[0] = 1;\n-      for (int i = 1; i < MaxStringLength; i++)\n-        num_substrings[i] = (i+1)+num_substrings[i-1];\n-    }\n+    private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    private static final int RANDOM_SEED = 46;\n+\n+    \/\/ Smaller table will cause creation of more old-gen garbage\n+    \/\/ as previous entries in table are overwritten with new values.\n+    private static final int TABLE_SIZE = 53;\n+    private static final int MAX_STRING_LENGTH = 47;\n+    private static final int SENTENCE_LENGTH = 5;\n+\n+    private static Random random = new Random(RANDOM_SEED);\n+\n+    public static class Node {\n+\n+        private String name;\n+\n+        \/\/ Each Node instance holds an array containing all substrings of its name\n+\n+        \/\/ This array has entries from 0 .. (name.length() - 1).\n+        \/\/ numSubstrings[i] represents the number of substrings that\n+        \/\/ correspond to a name of length i+1.\n+        private static int [] numSubstrings;\n+\n+        static {\n+            \/\/ Initialize numSubstrings.\n+            \/\/ For a name of length N, there are\n+            \/\/  N substrings of length 1\n+            \/\/  N-1 substrings of length 2\n+            \/\/  N-2 substrings of length 3\n+            \/\/  ...\n+            \/\/  1 substring of length N\n+            \/\/ Note that:\n+            \/\/   numSubstrings[0] = 1\n+            \/\/   numSubstrings[1] = 3\n+            \/\/   numSubstrings[i] = (i + 1) + numSubstrings[i - 1]\n+            numSubstrings = new int[MAX_STRING_LENGTH];\n+            numSubstrings[0] = 1;\n+            for (int i = 1; i < MAX_STRING_LENGTH; i++) {\n+                numSubstrings[i] = (i + 1) + numSubstrings[i - 1];\n+            }\n+        }\n+\n+        private String [] substrings;\n+        private Node [] neighbors;\n@@ -103,2 +101,3 @@\n-    private String [] substrings;\n-    private Node [] neighbors;\n+        public Node(String name) {\n+            this.name = name;\n+            this.substrings = new String[numSubstrings[name.length() - 1]];\n@@ -106,3 +105,11 @@\n-    public Node(String name) {\n-      this.name = name;\n-      this.substrings = new String[num_substrings[name.length() - 1]];\n+            int index = 0;\n+            for (int substringLength = 1; substringLength <= name.length(); substringLength++) {\n+                for (int offset = 0; offset + substringLength <= name.length(); offset++) {\n+                    this.substrings[index++] = name.substring(offset, offset + substringLength);\n+                }\n+            }\n+        }\n+\n+        public String value() {\n+            return name;\n+        }\n@@ -110,7 +117,3 @@\n-      int index = 0;\n-      for (int substring_length = 1;\n-           substring_length <= name.length(); substring_length++) {\n-        for (int offset = 0;\n-             offset + substring_length <= name.length(); offset++) {\n-          this.substrings[index++] = name.substring(offset,\n-                                                    offset + substring_length);\n+        public String arbitrarySubstring() {\n+            int index = TestConcurrentEvac.randomUnsignedInt(substrings.length);\n+            return substrings[index];\n@@ -118,1 +121,0 @@\n-      }\n@@ -121,2 +123,4 @@\n-    public String value() {\n-      return name;\n+\n+    \/\/ Return random int between 1 and MAX_STRING_LENGTH inclusive\n+    static int randomStringLength() {\n+        return randomUnsignedInt(MAX_STRING_LENGTH - 1) + 1;\n@@ -125,3 +129,3 @@\n-    public String arbitrary_substring() {\n-      int index = TestConcurrentEvac.randomUnsignedInt() % substrings.length;\n-      return substrings[index];\n+    static String randomCharacter() {\n+        int index = randomUnsignedInt(52);\n+        return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".substring(index, index + 1);\n@@ -129,49 +133,8 @@\n-  }\n-\n-\n-  \/\/ Return random int between 1 and MaxStringLength inclusive\n-  static int randomStringLength() {\n-    int length = randomUnsignedInt();\n-    length %= (MaxStringLength - 1);\n-    length += 1;\n-    return length;\n-  }\n-\n-  static String randomCharacter() {\n-    int index = randomUnsignedInt() % 52;\n-    return (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n-            substring(index, index+1));\n-  }\n-\n-  static String randomString() {\n-    int length = randomStringLength();\n-    String result = new String(); \/\/ make the compiler work for this garbage...\n-    for (int i = 0; i < length; i++)\n-      result += randomCharacter();\n-    return result;\n-  }\n-\n-  static int randomUnsignedInt() {\n-    int result = random.nextInt();\n-    if (result < 0) result = -result;\n-    if (result < 0) result = 0;\n-    return result;\n-  }\n-\n-  static int randomIndex() {\n-    int index = randomUnsignedInt();\n-    index %= TableSize;\n-    return index;\n-  }\n-\n-  public static void main(String args[]) throws Exception {\n-    HashMap<Integer, Node> table = new HashMap<Integer, Node>(TableSize);\n-\n-    if (!wb.getBooleanVMFlag(\"UseShenandoahGC\") ||\n-        !wb.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\"))\n-      throw new IllegalStateException(\"Command-line options not honored!\");\n-\n-    for (int count = java.lang.Integer.MAX_VALUE\/1024; count >= 0; count--) {\n-      int index = randomIndex();\n-      String name = randomString();\n-      table.put(index, new Node(name));\n+\n+    static String randomString() {\n+        int length = randomStringLength();\n+        String result = new String(); \/\/ make the compiler work for this garbage...\n+        for (int i = 0; i < length; i++) {\n+            result += randomCharacter();\n+        }\n+        return result;\n@@ -180,11 +143,2 @@\n-    String conclusion = \"\";\n-\n-    for (int i = 0; i < SentenceLength; i++) {\n-      Node a_node = table.get(randomIndex());\n-      if (a_node == null)\n-        i--;\n-      else {\n-        String a_string = a_node.arbitrary_substring();\n-        conclusion += a_string;\n-        conclusion += \" \";\n-      }\n+    static int randomUnsignedInt(int max) {\n+        return random.nextInt(max);\n@@ -192,1 +146,0 @@\n-    conclusion = conclusion.substring(0, conclusion.length() - 1);\n@@ -194,1 +147,3 @@\n-    System.out.println(\"Conclusion is [\" + conclusion + \"]\");\n+    static int randomIndex() {\n+        return randomUnsignedInt(TABLE_SIZE);\n+    }\n@@ -196,2 +151,2 @@\n-    if (!conclusion.equals(\"cTy cTykJ kAkKAOWYEHbxFCmRIlyk xjYMdNmtAQXNGdIc sqHKsWnJIP\"))\n-      throw new IllegalStateException(\"Random sequence of words did not end well!\");\n+    public static void main(String args[]) throws Exception {\n+        HashMap<Integer, Node> table = new HashMap<Integer, Node>(TABLE_SIZE);\n@@ -199,2 +154,22 @@\n-  }\n-}\n+        if (!wb.getBooleanVMFlag(\"UseShenandoahGC\") || !wb.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\")) {\n+            throw new IllegalStateException(\"Command-line options not honored!\");\n+        }\n+\n+        for (int count = java.lang.Integer.MAX_VALUE\/1024; count >= 0; count--) {\n+            int index = randomIndex();\n+            String name = randomString();\n+            table.put(index, new Node(name));\n+        }\n+\n+        String conclusion = \"\";\n+\n+        for (int i = 0; i < SENTENCE_LENGTH; i++) {\n+            Node node = table.get(randomIndex());\n+            if (node == null) {\n+                i--;\n+            } else {\n+                String s = node.arbitrarySubstring();\n+                conclusion += s;\n+                conclusion += \" \";\n+            }\n+        }\n@@ -202,0 +177,9 @@\n+        conclusion = conclusion.substring(0, conclusion.length() - 1);\n+\n+        System.out.println(\"Conclusion is [\" + conclusion + \"]\");\n+\n+        if (!conclusion.equals(\"HN TInkzoLSDFVJYM mQAirHXbbgCJmUWozx DeispxWF MYFKBh\")) {\n+            throw new IllegalStateException(\"Random sequence of words did not end well!\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestConcurrentEvac.java","additions":115,"deletions":131,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test\n+ * @test id=generational\n@@ -42,2 +42,2 @@\n-  public static void makeOldAllocations() {\n-    \/\/ Expect most of the BigInteger entries placed into array to be promoted, and most will eventually become garbage within old\n+    public static void makeOldAllocations() {\n+        \/\/ Expect most of the BigInteger entries placed into array to be promoted, and most will eventually become garbage within old\n@@ -45,5 +45,5 @@\n-    final int ArraySize = 512 * 1024;   \/\/ 512K entries\n-    final int BitsInBigInteger = 128;\n-    final int RefillIterations = 64;\n-    BigInteger array[] = new BigInteger[ArraySize];\n-    Random r = new Random(46);\n+        final int ArraySize = 512 * 1024;   \/\/ 512K entries\n+        final int BitsInBigInteger = 128;\n+        final int RefillIterations = 64;\n+        BigInteger array[] = new BigInteger[ArraySize];\n+        Random r = new Random(46);\n@@ -51,27 +51,2 @@\n-    for (int i = 0; i < ArraySize; i++) {\n-      array[i] = new BigInteger(BitsInBigInteger, r);\n-    }\n-\n-    for (int refill_count = 0; refill_count < RefillIterations; refill_count++) {\n-      \/\/ Each refill repopulates ArraySize randomly selected elements within array\n-      for (int i = 0; i < ArraySize; i++) {\n-        int replace_index = r.nextInt(ArraySize);\n-        int derive_index = r.nextInt(ArraySize);\n-        switch (i & 0x3) {\n-          case 0:\n-            \/\/ 50% chance of creating garbage\n-            array[replace_index] = array[replace_index].max(array[derive_index]);\n-            break;\n-          case 1:\n-            \/\/ 50% chance of creating garbage\n-            array[replace_index] = array[replace_index].min(array[derive_index]);\n-            break;\n-          case 2:\n-            \/\/ creates new old BigInteger, releases old BigInteger,\n-            \/\/ may create ephemeral data while computing gcd\n-            array[replace_index] = array[replace_index].gcd(array[derive_index]);\n-            break;\n-          case 3:\n-            \/\/ creates new old BigInteger, releases old BigInteger\n-            array[replace_index] = array[replace_index].multiply(array[derive_index]);\n-            break;\n+        for (int i = 0; i < ArraySize; i++) {\n+            array[i] = new BigInteger(BitsInBigInteger, r);\n@@ -79,2 +54,26 @@\n-        if ((i & 0x3) == 0x3) {\n-        } else {\n+\n+        for (int refillCount = 0; refillCount < RefillIterations; refillCount++) {\n+            \/\/ Each refill repopulates ArraySize randomly selected elements within array\n+            for (int i = 0; i < ArraySize; i++) {\n+                int replaceIndex = r.nextInt(ArraySize);\n+                int deriveIndex = r.nextInt(ArraySize);\n+                switch (i & 0x3) {\n+                    case 0:\n+                        \/\/ 50% chance of creating garbage\n+                        array[replaceIndex] = array[replaceIndex].max(array[deriveIndex]);\n+                        break;\n+                    case 1:\n+                        \/\/ 50% chance of creating garbage\n+                        array[replaceIndex] = array[replaceIndex].min(array[deriveIndex]);\n+                        break;\n+                    case 2:\n+                        \/\/ creates new old BigInteger, releases old BigInteger,\n+                        \/\/ may create ephemeral data while computing gcd\n+                        array[replaceIndex] = array[replaceIndex].gcd(array[deriveIndex]);\n+                        break;\n+                    case 3:\n+                        \/\/ creates new old BigInteger, releases old BigInteger\n+                        array[replaceIndex] = array[replaceIndex].multiply(array[deriveIndex]);\n+                        break;\n+                }\n+            }\n@@ -82,1 +81,0 @@\n-      }\n@@ -84,1 +82,0 @@\n-  }\n@@ -86,9 +83,8 @@\n-  public static void testOld(String... args) throws Exception {\n-    String[] cmds = Arrays.copyOf(args, args.length + 2);\n-    cmds[args.length] = TestOldGrowthTriggers.class.getName();\n-    cmds[args.length + 1] = \"test\";\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(cmds);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-    output.shouldHaveExitValue(0);\n-    if (!output.getOutput().contains(\"Trigger (OLD): Old has overgrown\")) {\n-      throw new AssertionError(\"Generational mode: Should experience OLD triggers due to growth\");\n+    public static void testOld(String... args) throws Exception {\n+        String[] cmds = Arrays.copyOf(args, args.length + 2);\n+        cmds[args.length] = TestOldGrowthTriggers.class.getName();\n+        cmds[args.length + 1] = \"test\";\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(cmds);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(\"Trigger (OLD): Old has overgrown\");\n@@ -96,1 +92,0 @@\n-  }\n@@ -98,5 +93,5 @@\n-  public static void main(String[] args) throws Exception {\n-    if (args.length > 0 && args[0].equals(\"test\")) {\n-      makeOldAllocations();\n-      return;\n-    }\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0 && args[0].equals(\"test\")) {\n+            makeOldAllocations();\n+            return;\n+        }\n@@ -104,11 +99,11 @@\n-    testOld(\"-Xlog:gc\",\n-            \"-Xms96m\",\n-            \"-Xmx96m\",\n-            \"-XX:+UnlockDiagnosticVMOptions\",\n-            \"-XX:+UnlockExperimentalVMOptions\",\n-            \"-XX:+UseShenandoahGC\",\n-            \"-XX:ShenandoahGCMode=generational\",\n-            \"-XX:ShenandoahGuaranteedYoungGCInterval=0\",\n-            \"-XX:ShenandoahGuaranteedOldGCInterval=0\"\n-            );\n-  }\n+        testOld(\"-Xlog:gc\",\n+                \"-Xms96m\",\n+                \"-Xmx96m\",\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \"-XX:+UseShenandoahGC\",\n+                \"-XX:ShenandoahGCMode=generational\",\n+                \"-XX:ShenandoahGuaranteedYoungGCInterval=0\",\n+                \"-XX:ShenandoahGuaranteedOldGCInterval=0\"\n+        );\n+    }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestOldGrowthTriggers.java","additions":60,"deletions":65,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @test TestSimpleGenerational\n+ * @test id=generational\n@@ -45,35 +45,57 @@\n-  private static WhiteBox wb = WhiteBox.getWhiteBox();\n-  static private final int SeedForRandom = 46;\n-  \/\/ Sequence of random numbers should end with same value\n-  private static int ExpectedLastRandom = 272454100;\n-\n-\n-  public static class Node {\n-    static private final int NeighborCount = 5;\n-    static private final int IntArraySize = 8;\n-    static private Random random = new Random(SeedForRandom);\n-\n-    private int val;\n-    private Object field_o;\n-\n-    \/\/ Each Node instance holds references to two \"private\" arrays.\n-    \/\/ One array holds raw seething bits (primitive integers) and the\n-    \/\/ holds references.\n-\n-    private int[] field_ints;\n-    private Node [] neighbors;\n-\n-    public Node(int val) {\n-      this.val = val;\n-      this.field_o = new Object();\n-      this.field_ints = new int[IntArraySize];\n-      this.field_ints[0] = 0xca;\n-      this.field_ints[1] = 0xfe;\n-      this.field_ints[2] = 0xba;\n-      this.field_ints[3] = 0xbe;\n-      this.field_ints[4] = 0xba;\n-      this.field_ints[5] = 0xad;\n-      this.field_ints[6] = 0xba;\n-      this.field_ints[7] = 0xbe;\n-\n-      this.neighbors = new Node[NeighborCount];\n+    private static WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static final int RANDOM_SEED = 46;\n+    \/\/ Sequence of random numbers should end with same value\n+    private static final int EXPECTED_LAST_RANDOM = 136227050;\n+\n+\n+    public static class Node {\n+        private static final int NEIGHBOR_COUNT = 5;\n+        private static final int INT_ARRAY_SIZE = 8;\n+        private static final Random RANDOM = new Random(RANDOM_SEED);\n+\n+        private int val;\n+        private Object objectField;\n+\n+        \/\/ Each Node instance holds references to two \"private\" arrays.\n+        \/\/ One array holds raw seething bits (primitive integers) and the other\n+        \/\/ holds references.\n+\n+        private int[] intsField;\n+        private Node [] neighbors;\n+\n+        public Node(int val) {\n+            this.val = val;\n+            this.objectField = new Object();\n+            this.intsField = new int[INT_ARRAY_SIZE];\n+            this.intsField[0] = 0xca;\n+            this.intsField[1] = 0xfe;\n+            this.intsField[2] = 0xba;\n+            this.intsField[3] = 0xbe;\n+            this.intsField[4] = 0xba;\n+            this.intsField[5] = 0xad;\n+            this.intsField[6] = 0xba;\n+            this.intsField[7] = 0xbe;\n+\n+            this.neighbors = new Node[NEIGHBOR_COUNT];\n+        }\n+\n+        public int value() {\n+            return val;\n+        }\n+\n+        \/\/ Copy each neighbor of n into a new node's neighbor array.\n+        \/\/ Then overwrite arbitrarily selected neighbor with newly allocated\n+        \/\/ leaf node.\n+        public static Node upheaval(Node n) {\n+            int firstValue = RANDOM.nextInt(Integer.MAX_VALUE);\n+            Node result = new Node(firstValue);\n+            if (n != null) {\n+                for (int i = 0; i < NEIGHBOR_COUNT; i++) {\n+                    result.neighbors[i] = n.neighbors[i];\n+                }\n+            }\n+            int secondValue = RANDOM.nextInt(Integer.MAX_VALUE);\n+            int overwriteIndex = firstValue % NEIGHBOR_COUNT;\n+            result.neighbors[overwriteIndex] = new Node(secondValue);\n+            return result;\n+        }\n@@ -82,25 +104,2 @@\n-    public int value() {\n-      return val;\n-    }\n-\n-    \/\/ Copy each neighbor of n into a new node's neighbor array.\n-    \/\/ Then overwrite arbitrarily selected neighbor with newly allocated\n-    \/\/ leaf node.\n-    public static Node upheaval(Node n) {\n-      int first_val = random.nextInt();\n-      if (first_val < 0) first_val = -first_val;\n-      if (first_val < 0) first_val = 0;\n-      Node result = new Node(first_val);\n-      if (n != null) {\n-        for (int i = 0; i < NeighborCount; i++)\n-          result.neighbors[i] = n.neighbors[i];\n-      }\n-      int second_val = random.nextInt();\n-      if (second_val < 0) second_val = -second_val;\n-      if (second_val < 0) second_val = 0;\n-\n-      int overwrite_index = first_val % NeighborCount;\n-      result.neighbors[overwrite_index] = new Node(second_val);\n-      return result;\n-    }\n-  }\n+    public static void main(String args[]) throws Exception {\n+        Node n = null;\n@@ -108,2 +107,3 @@\n-  public static void main(String args[]) throws Exception {\n-    Node n = null;\n+        if (!WB.getBooleanVMFlag(\"UseShenandoahGC\") || !WB.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\")) {\n+            throw new IllegalStateException(\"Command-line options not honored!\");\n+        }\n@@ -111,3 +111,3 @@\n-    if (!wb.getBooleanVMFlag(\"UseShenandoahGC\") ||\n-        !wb.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\"))\n-      throw new IllegalStateException(\"Command-line options not honored!\");\n+        for (int count = 10000; count > 0; count--) {\n+            n = Node.upheaval(n);\n+        }\n@@ -115,2 +115,4 @@\n-    for (int count = 10000; count > 0; count--) {\n-      n = Node.upheaval(n);\n+        System.out.println(\"Expected Last Random: [\" + n.value() + \"]\");\n+        if (n.value() != EXPECTED_LAST_RANDOM) {\n+            throw new IllegalStateException(\"Random number sequence ended badly!\");\n+        }\n@@ -118,6 +120,0 @@\n-\n-    if (n.value() != ExpectedLastRandom)\n-      throw new IllegalStateException(\"Random number sequence ended badly!\");\n-\n-  }\n-\n@@ -125,1 +121,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestSimpleGenerational.java","additions":70,"deletions":75,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+ *      -XX:+ShenandoahVerify\n@@ -77,1 +78,0 @@\n- *      -XX:+ShenandoahVerify\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestPinnedGarbage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+        String[] generational = {\n+                \"ShenandoahCardBarrier\"\n+        };\n+\n@@ -53,0 +57,3 @@\n+        shouldPassAll(\"-XX:ShenandoahGCMode=passive\",          generational);\n+        shouldPassAll(\"-XX:ShenandoahGCMode=satb\",             generational);\n+        shouldFailAll(\"-XX:ShenandoahGCMode=generational\",     generational);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestWrongBarrierDisable.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,3 +40,4 @@\n-        String[] concurrent = {\n-                \"ShenandoahSATBBarrier\",\n-        };\n+        String[] concurrent = { \"ShenandoahSATBBarrier\" };\n+        String[] generational = { \"ShenandoahCardBarrier\" };\n+        String[] all = { \"ShenandoahSATBBarrier\", \"ShenandoahCardBarrier\" };\n+\n@@ -48,0 +49,3 @@\n+        shouldPassAll(\"-XX:ShenandoahGCMode=generational\",     all);\n+        shouldFailAll(\"-XX:ShenandoahGCMode=satb\",             generational);\n+        shouldFailAll(\"-XX:ShenandoahGCMode=passive\",          generational);\n@@ -81,1 +85,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestWrongBarrierEnable.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @requires vm.gc == \"Shenandoah\"\n+ * @requires vm.gc.Shenandoah\n@@ -41,1 +41,1 @@\n-  * @requires vm.gc == \"Shenandoah\"\n+  * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/jfr\/TestStressBigAllocationGCEventsWithShenandoah.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}