{"files":[{"patch":"@@ -1129,21 +1129,21 @@\n-    \/\/ TODO: Is this only necessary for 'shared' allocations?\n-    \/\/\n-    \/\/ Register the newly allocated object while we're holding the global lock since there's no synchronization\n-    \/\/ built in to the implementation of register_object().  There are potential races when multiple independent\n-    \/\/ threads are allocating objects, some of which might span the same card region.  For example, consider\n-    \/\/ a card table's memory region within which three objects are being allocated by three different threads:\n-    \/\/\n-    \/\/ objects being \"concurrently\" allocated:\n-    \/\/    [-----a------][-----b-----][--------------c------------------]\n-    \/\/            [---- card table memory range --------------]\n-    \/\/\n-    \/\/ Before any objects are allocated, this card's memory range holds no objects.  Note that allocation of object a\n-    \/\/ wants to set the starts-object, first-start, and last-start attributes of the preceding card region.\n-    \/\/ Allocation of object b wants to set the starts-object, first-start, and last-start attributes of this card region.\n-    \/\/ Allocation of object c also wants to set the starts-object, first-start, and last-start attributes of this\n-    \/\/ card region.\n-    \/\/\n-    \/\/ The thread allocating b and the thread allocating c can \"race\" in various ways, resulting in confusion, such as\n-    \/\/ last-start representing object b while first-start represents object c.  This is why we need to require all\n-    \/\/ register_object() invocations to be \"mutually exclusive\" with respect to each card's memory range.\n-    card_scan()->register_object(result);\n+    if (req.type() == ShenandoahAllocRequest::_alloc_shared_gc) {\n+      \/\/ Register the newly allocated object while we're holding the global lock since there's no synchronization\n+      \/\/ built in to the implementation of register_object().  There are potential races when multiple independent\n+      \/\/ threads are allocating objects, some of which might span the same card region.  For example, consider\n+      \/\/ a card table's memory region within which three objects are being allocated by three different threads:\n+      \/\/\n+      \/\/ objects being \"concurrently\" allocated:\n+      \/\/    [-----a------][-----b-----][--------------c------------------]\n+      \/\/            [---- card table memory range --------------]\n+      \/\/\n+      \/\/ Before any objects are allocated, this card's memory range holds no objects.  Note that allocation of object a\n+      \/\/ wants to set the starts-object, first-start, and last-start attributes of the preceding card region.\n+      \/\/ Allocation of object b wants to set the starts-object, first-start, and last-start attributes of this card region.\n+      \/\/ Allocation of object c also wants to set the starts-object, first-start, and last-start attributes of this\n+      \/\/ card region.\n+      \/\/\n+      \/\/ The thread allocating b and the thread allocating c can \"race\" in various ways, resulting in confusion, such as\n+      \/\/ last-start representing object b while first-start represents object c.  This is why we need to require all\n+      \/\/ register_object() invocations to be \"mutually exclusive\" with respect to each card's memory range.\n+      card_scan()->register_object(result);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+  \/\/ If there is room to promote, there is also room to evacuate.\n@@ -230,0 +231,1 @@\n+    assert(get_evacuation_reserve() > 0, \"Promotion reserve greater than evacuation reserve\");\n@@ -237,2 +239,2 @@\n-    \/\/ The promotion reserve is exhausted. Check if we still have room for evacuations.\n-    \/\/ Note that we cannot really know how much of the plab will be used for evacuations,\n+    \/\/ The promotion reserve cannot accommodate this plab request. Check if we still have room for\n+    \/\/ evacuations. Note that we cannot really know how much of the plab will be used for evacuations,\n@@ -243,3 +245,2 @@\n-  \/\/ This is a shared allocation promotion request. However, we do not have room for any\n-  \/\/ promotions. This allocation into old will fail, so we will just evacuate the object\n-  \/\/ somewhere in the young generation.\n+  \/\/ If this is a shared allocation promotion request, we do not have room for any it.\n+  \/\/ This promotion into old will fail, so we will just evacuate the object in the young generation.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -125,1 +125,2 @@\n-  \/\/ Test if there is enough memory available in the old generation to allocate a new PLAB.\n+  \/\/ Test if there is enough memory available in the old generation to accommodate this request.\n+  \/\/ The request will be subject to constraints on promotion and evacuation reserves.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -180,1 +182,1 @@\n-  EXPECT_EQ(expended_before, expended_after) << \"Not a promotion, should not expende promotion reserve\";\n+  EXPECT_EQ(expended_before, expended_after) << \"Not a promotion, should not expend promotion reserve\";\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldGeneration.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}