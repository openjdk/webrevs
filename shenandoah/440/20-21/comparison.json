{"files":[{"patch":"@@ -1355,19 +1355,2 @@\n-        if (region->is_old()) {\n-          _partitions.raw_assign_membership(idx, ShenandoahFreeSetPartitionId::OldCollector);\n-          if (idx < old_collector_leftmost) {\n-            old_collector_leftmost = idx;\n-          }\n-          if (idx > old_collector_rightmost) {\n-            old_collector_rightmost = idx;\n-          }\n-          if (ac == region_size_bytes) {\n-            if (idx < old_collector_leftmost_empty) {\n-              old_collector_leftmost_empty = idx;\n-            }\n-            if (idx > old_collector_rightmost_empty) {\n-              old_collector_rightmost_empty = idx;\n-            }\n-          }\n-          old_collector_regions++;\n-          old_collector_used += (region_size_bytes - ac);\n-        } else {\n+        if (region->is_trash() || !region->is_old()) {\n+          \/\/ Both young and old collected regions (trashed) are placed into the Mutator set\n@@ -1391,0 +1374,19 @@\n+        } else {\n+          \/\/ !region->is_trash() && region is_old()\n+          _partitions.raw_assign_membership(idx, ShenandoahFreeSetPartitionId::OldCollector);\n+          if (idx < old_collector_leftmost) {\n+            old_collector_leftmost = idx;\n+          }\n+          if (idx > old_collector_rightmost) {\n+            old_collector_rightmost = idx;\n+          }\n+          if (ac == region_size_bytes) {\n+            if (idx < old_collector_leftmost_empty) {\n+              old_collector_leftmost_empty = idx;\n+            }\n+            if (idx > old_collector_rightmost_empty) {\n+              old_collector_rightmost_empty = idx;\n+            }\n+          }\n+          old_collector_regions++;\n+          old_collector_used += (region_size_bytes - ac);\n@@ -1521,1 +1523,1 @@\n-  \/\/ mutator set otherwise.\n+  \/\/ mutator set otherwise.  All trashed (cset) regions are affiliated young and placed in mutator set.\n@@ -1603,2 +1605,2 @@\n-  size_t young_region_count = _heap->num_regions() - (old_region_count + old_cset_regions);\n-  establish_generation_sizes(young_region_count, old_region_count + old_cset_regions);\n+  size_t young_region_count = _heap->num_regions() - old_region_count;\n+  establish_generation_sizes(young_region_count, old_region_count);\n@@ -1608,1 +1610,0 @@\n-\n@@ -1634,1 +1635,0 @@\n-  old_available += old_cset_regions * region_size_bytes;\n@@ -1640,0 +1640,1 @@\n+#ifdef ASSERT\n@@ -1646,0 +1647,1 @@\n+#endif\n@@ -1686,1 +1688,1 @@\n-  if (old_reserve_result > young_unaffiliated_regions * region_size_bytes) {\n+  if (young_reserve_result > young_unaffiliated_regions * region_size_bytes) {\n@@ -1717,0 +1719,3 @@\n+      \/\/ We give priority to OldCollector partition because we desire to pack OldCollector regions into higher\n+      \/\/ addresses than Collector regions.  Presumably, OldCollector regions are more \"stable\" and less likely to\n+      \/\/ be collected in the near future.\n@@ -1719,1 +1724,4 @@\n-#ifdef KELVIN_DEBUG\n+#ifdef KELVIN_DEPRECATE\n+        \/\/ I was puzzling over this code here.  My confusion arose because I overlooked that this loop exits early\n+        \/\/ (continues) if idx is not in the Mutator partition.\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":34,"deletions":26,"binary":false,"changes":60,"status":"modified"}]}