{"files":[{"patch":"@@ -729,3 +729,3 @@\n-  \/\/ Allocations are biased: new application allocs go to beginning of the heap, and GC allocs\n-  \/\/ go to the end. This makes application allocation faster, because we would clear lots\n-  \/\/ of regions from the beginning most of the time.\n+  \/\/ Allocations are biased: GC allocations are taken from the high end of the heap.  Regular (and TLAB)\n+  \/\/ mutator allocations are taken from the middle of heap, below the memory reserved for Collector.\n+  \/\/ Humongous mutator allocations are taken from the bottom of the heap.\n@@ -733,2 +733,2 @@\n-  \/\/ Free set maintains mutator and collector views, and normally they allocate in their views only,\n-  \/\/ unless we special cases for stealing and mixed allocations.\n+  \/\/ Free set maintains mutator and collector partitions.  Normally, each allocates only from its partition,\n+  \/\/ except in special cases when the collector steals regions from the mutator partition.\n@@ -994,0 +994,1 @@\n+\n@@ -1115,0 +1116,1 @@\n+  assert(req.is_mutator_alloc(), \"All humongous allocations are performed by mutator\");\n@@ -1118,1 +1120,1 @@\n-  size_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);\n+  idx_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);\n@@ -1127,0 +1129,4 @@\n+  idx_t start_range = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n+  idx_t end_range = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator) + 1;\n+  idx_t last_possible_start = end_range - num;\n+    \n@@ -1179,1 +1185,1 @@\n-  for (size_t i = beg; i <= end; i++) {\n+  for (idx_t i = beg; i <= end; i++) {\n@@ -1829,1 +1835,1 @@\n-      size_t last_idx = 0;\n+      idx_t last_idx = 0;\n@@ -2052,1 +2058,1 @@\n-  size_t last_idx = 0;\n+  idx_t last_idx = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -309,0 +309,6 @@\n+\n+  \/\/ While holding the heap lock, allocate memory for a humongous object which spans one or more regions that\n+  \/\/ were previously empty.  Regions that represent humongous objects are entirely dedicated to the humongous\n+  \/\/ object.  No other objects are packed into these regions.\n+  \/\/\n+  \/\/ Precondition: req.size() > ShenandoahHeapRegion::humongous_threshold_words().\n@@ -368,0 +374,11 @@\n+  \/\/ Move up to cset_regions number of regions from being available to the collector to being available to the mutator.\n+  \/\/\n+  \/\/ Typical usage: At the end of evacuation, when the collector no longer needs the regions that had been reserved\n+  \/\/ for evacuation, invoke this to make regions available for mutator allocations.\n+  \/\/\n+  \/\/ Note that we plan to replenish the Collector reserve at the end of update refs, at which time all\n+  \/\/ of the regions recycled from the collection set will be available.  In the very unlikely event that there\n+  \/\/ are fewer regions in the collection set than remain in the collector's free set, we limit the transfer in order\n+  \/\/ to assure that the replenished Collector reserves can be sufficiently large.\n+  void move_regions_from_collector_to_mutator(size_t cset_regions);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2365,1 +2365,1 @@\n-      _heap->free_set()->move_collector_sets_to_mutator(cset_regions);\n+      _heap->free_set()->move_regions_from_collector_to_mutator(cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,6 +44,0 @@\n-    static int thread_count = 0;\n-\n-    static synchronized final int get_thread_id() {\n-      return ++thread_count;\n-    }\n-\n@@ -54,9 +48,2 @@\n-            int my_thread_id = get_thread_id();\n-            String msg = \"NastyThread \" + my_thread_id + \" is shutting down\";\n-            try {\n-              while (true) {\n-                root.add(new Object[SIZE]);\n-              }\n-            } catch (Exception x) {\n-              \/\/ This is probably a java.lang.OutOfMemoryError exception\n-              System.out.println(msg);\n+            while (true) {\n+              root.add(new Object[SIZE]);\n@@ -91,1 +78,0 @@\n-                    \"-Xlog:gc*=info\",\n@@ -109,1 +95,0 @@\n-                    \"-Xlog:gc*=info\",\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestThreadFailure.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"}]}