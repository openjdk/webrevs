{"files":[{"patch":"@@ -1425,1 +1425,4 @@\n-void ShenandoahFreeSet::move_regions_from_collector_to_mutator(size_t max_xfer_regions) {\n+\/\/ Returns number of regions transferred, adds transferred bytes to var argument bytes_transferred\n+size_t ShenandoahFreeSet::transfer_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId which_collector,\n+                                                                                   size_t max_xfer_regions,\n+                                                                                   size_t& bytes_transferred) {\n@@ -1427,3 +1430,39 @@\n-  size_t collector_empty_xfer = 0;\n-  size_t collector_not_empty_xfer = 0;\n-  size_t old_collector_empty_xfer = 0;\n+  size_t transferred_regions = 0;\n+  ShenandoahHeapLocker locker(_heap->lock());\n+  idx_t rightmost = _partitions.rightmost_empty(which_collector);\n+  for (idx_t idx = _partitions.leftmost_empty(which_collector); (transferred_regions < max_xfer_regions) && (idx <= rightmost); ) {\n+    assert(_partitions.in_free_set(which_collector, idx), \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n+    \/\/ Note: can_allocate_from() denotes that region is entirely empty\n+    if (can_allocate_from(idx)) {\n+      _partitions.move_from_partition_to_partition(idx, which_collector, ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n+      transferred_regions++;\n+      bytes_transferred += region_size_bytes;\n+    }\n+    idx = _partitions.find_index_of_next_available_region(which_collector, idx + 1);\n+  }\n+  return transferred_regions;\n+}\n+\n+\/\/ Returns number of regions transferred, adds transferred bytes to var argument bytes_transferred\n+size_t ShenandoahFreeSet::transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId collector_id,\n+                                                                                       size_t max_xfer_regions,\n+                                                                                       size_t& bytes_transferred) {\n+  size_t transferred_regions = 0;\n+  ShenandoahHeapLocker locker(_heap->lock());\n+  idx_t rightmost = _partitions.rightmost(collector_id);\n+  for (idx_t idx = _partitions.leftmost(collector_id); (transferred_regions < max_xfer_regions) && (idx <= rightmost); ) {\n+    assert(_partitions.in_free_set(collector_id, idx), \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n+    size_t ac = alloc_capacity(idx);\n+    if (ac > 0) {\n+      _partitions.move_from_partition_to_partition(idx, collector_id, ShenandoahFreeSetPartitionId::Mutator, ac);\n+      transferred_regions++;\n+      bytes_transferred += ac;\n+    }\n+    idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n+  }\n+  return transferred_regions;\n+}\n+\n+void ShenandoahFreeSet::move_regions_from_collector_to_mutator(size_t max_xfer_regions) {\n+  size_t collector_xfer = 0;\n+  size_t old_collector_xfer = 0;\n@@ -1435,15 +1474,3 @@\n-    ShenandoahHeapLocker locker(_heap->lock());\n-    idx_t rightmost = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Collector);\n-    for (idx_t idx = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Collector);\n-         (max_xfer_regions > 0) && (idx <= rightmost); ) {\n-      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx),\n-             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n-      \/\/ Note: can_allocate_from() denotes that region is entirely empty\n-      if (can_allocate_from(idx)) {\n-        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Collector,\n-                                                     ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n-        max_xfer_regions--;\n-        collector_empty_xfer += region_size_bytes;\n-      }\n-      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n-    }\n+    max_xfer_regions -=\n+      transfer_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId::Collector, max_xfer_regions,\n+                                                               collector_xfer);\n@@ -1456,17 +1483,4 @@\n-    ShenandoahHeapLocker locker(_heap->lock());\n-    size_t old_collector_regions = 0;\n-    idx_t rightmost = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::OldCollector);\n-    for (idx_t idx = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::OldCollector);\n-         (max_xfer_regions > 0) && (idx <= rightmost); ) {\n-      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, idx),\n-             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n-      \/\/ Note: can_allocate_from() denotes that region is entirely empty\n-      if (can_allocate_from(idx)) {\n-        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::OldCollector,\n-                                                     ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n-        max_xfer_regions--;\n-        old_collector_regions++;\n-        old_collector_empty_xfer += region_size_bytes;\n-      }\n-      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::OldCollector, idx + 1);\n-    }\n+    size_t old_collector_regions =\n+      transfer_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId::OldCollector, max_xfer_regions,\n+                                                               old_collector_xfer);\n+    max_xfer_regions -= old_collector_regions;\n@@ -1481,15 +1495,3 @@\n-    ShenandoahHeapLocker locker(_heap->lock());\n-    idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n-    for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n-         (max_xfer_regions > 0) && (idx <= rightmost); ) {\n-      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx),\n-             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n-      size_t ac = alloc_capacity(idx);\n-      if (ac > 0) {\n-        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Collector,\n-                                                     ShenandoahFreeSetPartitionId::Mutator, ac);\n-        max_xfer_regions--;\n-        collector_not_empty_xfer += ac;\n-      }\n-      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n-    }\n+    max_xfer_regions -=\n+      transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId::Collector, max_xfer_regions,\n+                                                                   collector_xfer);\n@@ -1498,2 +1500,1 @@\n-  size_t collector_xfer = collector_empty_xfer + collector_not_empty_xfer;\n-  size_t total_xfer = collector_xfer + old_collector_empty_xfer;\n+  size_t total_xfer = collector_xfer + old_collector_xfer;\n@@ -1504,1 +1505,1 @@\n-                     byte_size_in_proper_unit(old_collector_empty_xfer), proper_unit_for_byte_size(old_collector_empty_xfer));\n+                     byte_size_in_proper_unit(old_collector_xfer), proper_unit_for_byte_size(old_collector_xfer));\n@@ -1529,2 +1530,2 @@\n-    old_gen->establish_capacity(old_region_count * region_size_bytes);\n-    young_gen->establish_capacity(young_region_count * region_size_bytes);\n+    old_gen->set_capacity(old_region_count * region_size_bytes);\n+    young_gen->set_capacity(young_region_count * region_size_bytes);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":57,"deletions":56,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -342,0 +342,8 @@\n+  size_t transfer_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId which_collector,\n+                                                                  size_t max_xfer_regions,\n+                                                                  size_t& bytes_transferred);\n+  size_t transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId collector_id,\n+                                                                      size_t max_xfer_regions,\n+                                                                      size_t& bytes_transferred);\n+\n+\n@@ -357,0 +365,8 @@\n+\n+  \/\/ Examine the existing free set representation, capturing the current state into var arguments:\n+  \/\/\n+  \/\/ young_cset_regions is the number of regions currently in the young cset if we are starting to evacuate, or zero\n+  \/\/   old_cset_regions is the number of regions currently in the old cset if we are starting a mixed evacuation, or zero\n+  \/\/   first_old_region is the index of the first region that is part of the OldCollector set\n+  \/\/    last_old_region is the index of the last region that is part of the OldCollector set\n+  \/\/   old_region_count is the number of regions in the OldCollector set that have memory available to be allocated\n@@ -361,8 +377,9 @@\n-  \/\/ hold the results of evacuating to young-gen and to old-gen.  These quantities, stored in reserves for their,\n-  \/\/ respective generations, are consulted prior to rebuilding the free set (ShenandoahFreeSet) in preparation for\n-  \/\/ evacuation.  When the free set is rebuilt, we make sure to reserve sufficient memory in the collector and\n-  \/\/ old_collector sets to hold evacuations, if have_evacuation_reserves is true.  The other time we rebuild the free\n-  \/\/ set is at the end of GC, as we prepare to idle GC until the next trigger.  In this case, have_evacuation_reserves\n-  \/\/ is false because we don't yet know how much memory will need to be evacuated in the next GC cycle.  When\n-  \/\/ have_evacuation_reserves is false, the free set rebuild operation reserves for the collector and old_collector sets\n-  \/\/ based on alternative mechanisms, such as ShenandoahEvacReserve, ShenandoahOldEvacReserve, and\n+  \/\/ hold the results of evacuating to young-gen and to old-gen, and have_evacuation_reserves should be true.\n+  \/\/ These quantities, stored as reserves for their respective generations, are consulted prior to rebuilding\n+  \/\/ the free set (ShenandoahFreeSet) in preparation for evacuation.  When the free set is rebuilt, we make sure\n+  \/\/ to reserve sufficient memory in the collector and old_collector sets to hold evacuations.\n+  \/\/\n+  \/\/ We also rebuild the free set at the end of GC, as we prepare to idle GC until the next trigger.  In this case, \n+  \/\/ have_evacuation_reserves is false because we don't yet know how much memory will need to be evacuated in the\n+  \/\/ next GC cycle.  When have_evacuation_reserves is false, the free set rebuild operation reserves for the collector\n+  \/\/ and old_collector sets based on alternative mechanisms, such as ShenandoahEvacReserve, ShenandoahOldEvacReserve, and\n@@ -372,0 +389,7 @@\n+  \/\/\n+  \/\/ young_cset_regions is the number of regions currently in the young cset if we are starting to evacuate, or zero\n+  \/\/   old_cset_regions is the number of regions currently in the old cset if we are starting a mixed evacuation, or zero\n+  \/\/    num_old_regions is the number of old-gen regions that have available memory for further allocations (excluding old cset)\n+  \/\/ have_evacuation_reserves is true iff the desired values of young-gen and old-gen evacuation reserves and old-gen\n+  \/\/                    promotion reserve have been precomputed (and can be obtained by invoking\n+  \/\/                    <generation>->get_evacuation_reserve() or old_gen->get_promoted_reserve()\n@@ -383,5 +407,0 @@\n-  \/\/\n-  \/\/ Note that we plan to replenish the Collector reserve at the end of update refs, at which time all\n-  \/\/ of the regions recycled from the collection set will be available.  In the very unlikely event that there\n-  \/\/ are fewer regions in the collection set than remain in the collector's free set, we limit the transfer in order\n-  \/\/ to assure that the replenished Collector reserves can be sufficiently large.\n@@ -449,0 +468,8 @@\n+  \/\/\n+  \/\/ Examine the existing free set representation, capturing the current state into var arguments:\n+  \/\/\n+  \/\/ young_cset_regions is the number of regions currently in the young cset if we are starting to evacuate, or zero\n+  \/\/   old_cset_regions is the number of regions currently in the old cset if we are starting a mixed evacuation, or zero\n+  \/\/   first_old_region is the index of the first region that is part of the OldCollector set\n+  \/\/    last_old_region is the index of the last region that is part of the OldCollector set\n+  \/\/   old_region_count is the number of regions in the OldCollector set that have memory available to be allocated\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -987,1 +987,1 @@\n-size_t ShenandoahGeneration::establish_capacity(size_t byte_size) {\n+size_t ShenandoahGeneration::set_capacity(size_t byte_size) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -150,2 +150,2 @@\n-  \/\/ These methods change the capacity of the region by adding or subtracting the given number of bytes from the current\n-  \/\/ capacity.\n+  \/\/ These methods change the capacity of the generation by adding or subtracting the given number of bytes from the current\n+  \/\/ capacity, returning the capacity of the generation following the change.\n@@ -155,1 +155,2 @@\n-  size_t establish_capacity(size_t byte_size);\n+  \/\/ Set the capacity of the generation, returning the value set\n+  size_t set_capacity(size_t byte_size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -785,2 +785,5 @@\n-      \/\/ We cannot transfer any more regions than will be reclaimed when the existing collection set is recycled, because\n-      \/\/ we need the reclaimed collection set regions to replenish the collector reserves\n+\n+      \/\/ Now that evacuation is done, we can reassign any regions that had been reserved to hold the results of evacuation\n+      \/\/ to the mutator free set.  At the end of GC, we will have cset_regions newly evacuated fully empty regions from\n+      \/\/ which we will be able to replenish the Collector free set and the OldCollector free set in preparation for the\n+      \/\/ next GC cycle.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2346,2 +2346,5 @@\n-      \/\/ We cannot transfer any more regions than will be reclaimed when the existing collection set is recycled because\n-      \/\/ we need the reclaimed collection set regions to replenish the collector reserves\n+\n+      \/\/ Now that evacuation is done, we can reassign any regions that had been reserved to hold the results of evacuation\n+      \/\/ to the mutator free set.  At the end of GC, we will have cset_regions newly evacuated fully empty regions from\n+      \/\/ which we will be able to replenish the Collector free set and the OldCollector free set in preparation for the\n+      \/\/ next GC cycle.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -429,2 +429,2 @@\n-              \"%s: generation (%s) size spanned by regions (\" SIZE_FORMAT \") * region size: \" PROPERFMT\n-              \" must not exceed current capacity (\" PROPERFMT \")\",\n+              \"%s: generation (%s) size spanned by regions (\" SIZE_FORMAT \") * region size (\" PROPERFMT\n+              \") must not exceed current capacity (\" PROPERFMT \")\",\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}