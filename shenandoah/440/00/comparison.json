{"files":[{"patch":"@@ -44,0 +44,2 @@\n+  #elif defined(ARM32)\n+  #define SYS_membarrier 389\n","filename":"src\/hotspot\/os\/linux\/systemMemoryBarrier_linux.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                (parse_mode == _parse_lambda_forms_invokers_only) ? \" (lambda form invokers only)\" : \"\");\n+                parse_lambda_forms_invokers_only() ? \" (lambda form invokers only)\" : \"\");\n@@ -105,3 +105,1 @@\n-int ClassListParser::parse(TRAPS) {\n-  int class_count = 0;\n-\n+void ClassListParser::parse(TRAPS) {\n@@ -110,15 +108,14 @@\n-    if (*_line == '#') { \/\/ comment\n-      continue;\n-    }\n-    if (!parse_one_line()) {\n-      break;\n-    }\n-\n-    if (lambda_form_line()) {\n-      \/\/ The current line is \"@lambda-form-invoker ...\". It has been recorded in LambdaFormInvokers,\n-      \/\/ and will be processed later.\n-      continue;\n-    }\n-\n-    if (_parse_mode == _parse_lambda_forms_invokers_only) {\n-      continue;\n+    clean_up_input_line();\n+\n+    \/\/ Each line in the classlist can be one of three forms:\n+    if (_line[0] == '#') {\n+      \/\/ A comment; ignore it\n+    } else if (_line[0] == '@') {\n+      \/\/ @xxx - a tag like @lambda-proxy, to be parsed by parse_at_tags()\n+      parse_at_tags(CHECK);\n+    } else {\n+      \/\/ A class name, followed by optional attributes. E.g.\n+      \/\/   java\/lang\/String\n+      \/\/   java\/lang\/Object id: 1\n+      \/\/   my\/pkg\/TestClass id: 5 super: 1 interfaces: 3 4 source: foo.jar\n+      parse_class_name_and_attributes(CHECK);\n@@ -126,0 +123,2 @@\n+  }\n+}\n@@ -127,8 +126,2 @@\n-    check_class_name(_class_name);\n-    TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);\n-    if (_indy_items->length() > 0) {\n-      \/\/ The current line is \"@lambda-proxy class_name\". Load the proxy class.\n-      resolve_indy(THREAD, class_name_symbol);\n-      class_count++;\n-      continue;\n-    }\n+void ClassListParser::parse_class_name_and_attributes(TRAPS) {\n+  read_class_name_and_attributes();\n@@ -136,7 +129,3 @@\n-    Klass* klass = load_current_class(class_name_symbol, THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      if (PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())) {\n-        \/\/ If we have run out of memory, don't try to load the rest of the classes in\n-        \/\/ the classlist. Throw an exception, which will terminate the dumping process.\n-        return 0; \/\/ THROW\n-      }\n+  if (parse_lambda_forms_invokers_only()) {\n+    return;\n+  }\n@@ -144,12 +133,8 @@\n-      ResourceMark rm(THREAD);\n-      char* ex_msg = (char*)\"\";\n-      oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n-      if (message != nullptr) {\n-        ex_msg = java_lang_String::as_utf8_string(message);\n-      }\n-      log_warning(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n-      \/\/ We might have an invalid class name or an bad class. Warn about it\n-      \/\/ and keep going to the next line.\n-      CLEAR_PENDING_EXCEPTION;\n-      log_warning(cds)(\"Preload Warning: Cannot find %s\", _class_name);\n-      continue;\n+  check_class_name(_class_name);\n+  TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);\n+  Klass* klass = load_current_class(class_name_symbol, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    if (PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())) {\n+      \/\/ If we have run out of memory, don't try to load the rest of the classes in\n+      \/\/ the classlist. Throw an exception, which will terminate the dumping process.\n+      return; \/\/ THROW\n@@ -158,4 +143,5 @@\n-    assert(klass != nullptr, \"sanity\");\n-    if (log_is_enabled(Trace, cds)) {\n-      ResourceMark rm(THREAD);\n-      log_trace(cds)(\"Shared spaces preloaded: %s\", klass->external_name());\n+    ResourceMark rm(THREAD);\n+    char* ex_msg = (char*)\"\";\n+    oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n+    if (message != nullptr) {\n+      ex_msg = java_lang_String::as_utf8_string(message);\n@@ -163,0 +149,7 @@\n+    log_warning(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n+    \/\/ We might have an invalid class name or an bad class. Warn about it\n+    \/\/ and keep going to the next line.\n+    CLEAR_PENDING_EXCEPTION;\n+    log_warning(cds)(\"Preload Warning: Cannot find %s\", _class_name);\n+    return;\n+  }\n@@ -164,2 +157,5 @@\n-    if (klass->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(klass);\n+  assert(klass != nullptr, \"sanity\");\n+  if (log_is_enabled(Trace, cds)) {\n+    ResourceMark rm(THREAD);\n+    log_trace(cds)(\"Shared spaces preloaded: %s\", klass->external_name());\n+  }\n@@ -167,6 +163,2 @@\n-      \/\/ Link the class to cause the bytecodes to be rewritten and the\n-      \/\/ cpcache to be created. The linking is done as soon as classes\n-      \/\/ are loaded in order that the related data structures (klass and\n-      \/\/ cpCache) are located together.\n-      MetaspaceShared::try_link_class(THREAD, ik);\n-    }\n+  if (klass->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n@@ -174,1 +166,5 @@\n-    class_count++;\n+    \/\/ Link the class to cause the bytecodes to be rewritten and the\n+    \/\/ cpcache to be created. The linking is done as soon as classes\n+    \/\/ are loaded in order that the related data structures (klass and\n+    \/\/ cpCache) are located together.\n+    MetaspaceShared::try_link_class(THREAD, ik);\n@@ -176,2 +172,0 @@\n-\n-  return class_count;\n@@ -180,9 +174,7 @@\n-bool ClassListParser::parse_one_line() {\n-  {\n-    int len = (int)strlen(_line);\n-    int i;\n-    \/\/ Replace \\t\\r\\n\\f with ' '\n-    for (i=0; i<len; i++) {\n-      if (_line[i] == '\\t' || _line[i] == '\\r' || _line[i] == '\\n' || _line[i] == '\\f') {\n-        _line[i] = ' ';\n-      }\n+void ClassListParser::clean_up_input_line() {\n+  int len = (int)strlen(_line);\n+  int i;\n+  \/\/ Replace \\t\\r\\n\\f with ' '\n+  for (i=0; i<len; i++) {\n+    if (_line[i] == '\\t' || _line[i] == '\\r' || _line[i] == '\\n' || _line[i] == '\\f') {\n+      _line[i] = ' ';\n@@ -190,0 +182,1 @@\n+  }\n@@ -191,8 +184,7 @@\n-    \/\/ Remove trailing newline\/space\n-    while (len > 0) {\n-      if (_line[len-1] == ' ') {\n-        _line[len-1] = '\\0';\n-        len --;\n-      } else {\n-        break;\n-      }\n+  \/\/ Remove trailing newline\/space\n+  while (len > 0) {\n+    if (_line[len-1] == ' ') {\n+      _line[len-1] = '\\0';\n+      len --;\n+    } else {\n+      break;\n@@ -200,1 +192,0 @@\n-    _line_len = len;\n@@ -202,0 +193,2 @@\n+  _line_len = len;\n+}\n@@ -203,0 +196,1 @@\n+void ClassListParser::read_class_name_and_attributes() {\n@@ -209,6 +203,0 @@\n-  _indy_items->clear();\n-  _lambda_form_line = false;\n-\n-  if (_line[0] == '@') {\n-    return parse_at_tags();\n-  }\n@@ -217,2 +205,2 @@\n-    \/\/ No optional arguments are specified.\n-    return true;\n+    \/\/ No optional attributes are specified.\n+    return;\n@@ -260,1 +248,0 @@\n-  return true;\n@@ -263,1 +250,1 @@\n-void ClassListParser::split_tokens_by_whitespace(int offset) {\n+void ClassListParser::split_tokens_by_whitespace(int offset, GrowableArray<const char*>* items) {\n@@ -276,1 +263,1 @@\n-    _indy_items->append(_line + start);\n+    items->append(_line + start);\n@@ -293,1 +280,1 @@\n-bool ClassListParser::parse_at_tags() {\n+void ClassListParser::parse_at_tags(TRAPS) {\n@@ -295,4 +282,2 @@\n-  int offset;\n-  if ((offset = split_at_tag_from_line()) == 0) {\n-    return false;\n-  }\n+  int offset = split_at_tag_from_line();\n+  assert(offset > 0, \"would have exited VM\");\n@@ -301,1 +286,2 @@\n-    split_tokens_by_whitespace(offset);\n+    _indy_items->clear();\n+    split_tokens_by_whitespace(offset, _indy_items);\n@@ -304,1 +290,0 @@\n-      return false;\n@@ -306,3 +291,9 @@\n-    \/\/ set the class name\n-    _class_name = _indy_items->at(0);\n-    return true;\n+    if (!parse_lambda_forms_invokers_only()) {\n+      _class_name = _indy_items->at(0);\n+      check_class_name(_class_name);\n+      TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);\n+      if (_indy_items->length() > 0) {\n+        \/\/ The current line is \"@lambda-proxy class_name\". Load the proxy class.\n+        resolve_indy(THREAD, class_name_symbol);\n+      }\n+    }\n@@ -311,2 +302,0 @@\n-    _lambda_form_line = true;\n-    return true;\n@@ -315,1 +304,0 @@\n-    return false;\n@@ -444,0 +432,1 @@\n+  va_end(ap);\n@@ -446,1 +435,0 @@\n-  va_end(ap);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":92,"deletions":104,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-  bool                _lambda_form_line;\n@@ -123,1 +122,3 @@\n-  bool parse_one_line();\n+  void clean_up_input_line();\n+  void read_class_name_and_attributes();\n+  void parse_class_name_and_attributes(TRAPS);\n@@ -132,1 +133,1 @@\n-  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n+  static void parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n@@ -134,1 +135,1 @@\n-    return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n+    parser.parse(THREAD);\n@@ -144,2 +145,2 @@\n-  int parse(TRAPS);\n-  void split_tokens_by_whitespace(int offset);\n+  void parse(TRAPS);\n+  void split_tokens_by_whitespace(int offset, GrowableArray<const char*>* items);\n@@ -147,1 +148,1 @@\n-  bool parse_at_tags();\n+  void parse_at_tags(TRAPS);\n@@ -157,0 +158,3 @@\n+  bool parse_lambda_forms_invokers_only() {\n+    return _parse_mode == _parse_lambda_forms_invokers_only;\n+  }\n@@ -187,2 +191,0 @@\n-  bool lambda_form_line() { return _lambda_form_line; }\n-\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -228,0 +228,8 @@\n+  if (UseCompressedClassPointers) {\n+    aligned_base = align_up(specified_base, Metaspace::reserve_alignment());\n+  }\n+\n+  if (aligned_base != specified_base) {\n+    log_info(cds)(\"SharedBaseAddress (\" INTPTR_FORMAT \") aligned up to \" INTPTR_FORMAT,\n+                   p2i(specified_base), p2i(aligned_base));\n+  }\n@@ -740,2 +748,2 @@\n-  int class_count = ClassListParser::parse_classlist(classlist_path,\n-                                                     ClassListParser::_parse_all, CHECK);\n+  ClassListParser::parse_classlist(classlist_path,\n+                                   ClassListParser::_parse_all, CHECK);\n@@ -743,2 +751,2 @@\n-    class_count += ClassListParser::parse_classlist(ExtraSharedClassListFile,\n-                                                    ClassListParser::_parse_all, CHECK);\n+    ClassListParser::parse_classlist(ExtraSharedClassListFile,\n+                                     ClassListParser::_parse_all, CHECK);\n@@ -750,2 +758,2 @@\n-      class_count += ClassListParser::parse_classlist(default_classlist,\n-                                                      ClassListParser::_parse_lambda_forms_invokers_only, CHECK);\n+      ClassListParser::parse_classlist(default_classlist,\n+                                       ClassListParser::_parse_lambda_forms_invokers_only, CHECK);\n@@ -761,1 +769,0 @@\n-  log_info(cds)(\"Shared spaces: preloaded %d classes\", class_count);\n@@ -1263,6 +1270,0 @@\n-  \/\/ If a base address is given, it must have valid alignment and be suitable as encoding base.\n-  if (base_address != nullptr) {\n-    assert(is_aligned(base_address, archive_space_alignment),\n-           \"Archive base address invalid: \" PTR_FORMAT \".\", p2i(base_address));\n-  }\n-\n@@ -1272,0 +1273,6 @@\n+\n+    \/\/ When running without class space, requested archive base should be aligned to cds core alignment.\n+    assert(is_aligned(base_address, archive_space_alignment),\n+             \"Archive base address unaligned: \" PTR_FORMAT \", needs alignment: %zu.\",\n+             p2i(base_address), archive_space_alignment);\n+\n@@ -1292,6 +1299,6 @@\n-  \/\/ To simplify matters, lets assume that metaspace alignment will always be\n-  \/\/  equal or a multiple of archive alignment.\n-  assert(is_power_of_2(class_space_alignment) &&\n-                       is_power_of_2(archive_space_alignment) &&\n-                       class_space_alignment >= archive_space_alignment,\n-                       \"Sanity\");\n+  \/\/ When running with class space, requested archive base must satisfy both cds core alignment\n+  \/\/ and class space alignment.\n+  const size_t base_address_alignment = MAX2(class_space_alignment, archive_space_alignment);\n+  assert(is_aligned(base_address, base_address_alignment),\n+           \"Archive base address unaligned: \" PTR_FORMAT \", needs alignment: %zu.\",\n+           p2i(base_address), base_address_alignment);\n@@ -1305,2 +1312,1 @@\n-  const size_t ccs_begin_offset = align_up(base_address + archive_space_size,\n-                                           class_space_alignment) - base_address;\n+  const size_t ccs_begin_offset = align_up(archive_space_size, class_space_alignment);\n@@ -1310,1 +1316,1 @@\n-      align_up(archive_space_size + gap_size + class_space_size, core_region_alignment());\n+      archive_space_size + gap_size + class_space_size;\n@@ -1335,1 +1341,1 @@\n-      total_space_rs = ReservedSpace(total_range_size, archive_space_alignment,\n+      total_space_rs = ReservedSpace(total_range_size, base_address_alignment,\n@@ -1353,1 +1359,1 @@\n-    assert(is_aligned(total_space_rs.base(), archive_space_alignment), \"Sanity\");\n+    assert(is_aligned(total_space_rs.base(), base_address_alignment), \"Sanity\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":30,"deletions":24,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -1142,9 +1142,11 @@\n-        \/\/ If there is an old version we're done with it\n-        nmethod* old = method->code();\n-        if (TraceMethodReplacement && old != nullptr) {\n-          ResourceMark rm;\n-          char *method_name = method->name_and_sig_as_C_string();\n-          tty->print_cr(\"Replacing method %s\", method_name);\n-        }\n-        if (old != nullptr) {\n-          old->make_not_used();\n+        if (TieredCompilation) {\n+          \/\/ If there is an old version we're done with it\n+          nmethod* old = method->code();\n+          if (TraceMethodReplacement && old != nullptr) {\n+            ResourceMark rm;\n+            char *method_name = method->name_and_sig_as_C_string();\n+            tty->print_cr(\"Replacing method %s\", method_name);\n+          }\n+          if (old != nullptr) {\n+            old->make_not_used();\n+          }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"compiler\/compilerDirectives.hpp\"\n@@ -1333,61 +1332,0 @@\n-void CodeCache::mark_directives_matches(bool top_only) {\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  Thread *thread = Thread::current();\n-  HandleMark hm(thread);\n-\n-  NMethodIterator iter(NMethodIterator::not_unloading);\n-  while(iter.next()) {\n-    nmethod* nm = iter.method();\n-    methodHandle mh(thread, nm->method());\n-    if (DirectivesStack::hasMatchingDirectives(mh, top_only)) {\n-      ResourceMark rm;\n-      log_trace(codecache)(\"Mark because of matching directives %s\", mh->external_name());\n-      mh->set_has_matching_directives();\n-    }\n-  }\n-}\n-\n-void CodeCache::recompile_marked_directives_matches() {\n-  Thread *thread = Thread::current();\n-  HandleMark hm(thread);\n-\n-  \/\/ Try the max level and let the directives be applied during the compilation.\n-  int comp_level = CompilationPolicy::highest_compile_level();\n-  RelaxedNMethodIterator iter(RelaxedNMethodIterator::not_unloading);\n-  while(iter.next()) {\n-    nmethod* nm = iter.method();\n-    methodHandle mh(thread, nm->method());\n-    if (mh->has_matching_directives()) {\n-      ResourceMark rm;\n-      mh->clear_directive_flags();\n-      bool deopt = false;\n-\n-      if (!nm->is_osr_method()) {\n-        log_trace(codecache)(\"Recompile to level %d because of matching directives %s\",\n-                             comp_level, mh->external_name());\n-        nmethod * comp_nm = CompileBroker::compile_method(mh, InvocationEntryBci, comp_level,\n-                                                          methodHandle(), 0,\n-                                                          CompileTask::Reason_DirectivesChanged,\n-                                                          (JavaThread*)thread);\n-        if (comp_nm == nullptr) {\n-          log_trace(codecache)(\"Recompilation to level %d failed, deoptimize %s\",\n-                               comp_level, mh->external_name());\n-          deopt = true;\n-        }\n-      } else {\n-        log_trace(codecache)(\"Deoptimize OSR %s\", mh->external_name());\n-        deopt = true;\n-      }\n-      \/\/ For some reason the method cannot be compiled by C2, e.g. the new directives forbid it.\n-      \/\/ Deoptimize the method and let the usual hotspot logic do the rest.\n-      if (deopt) {\n-        if (!nm->has_been_deoptimized() && nm->can_be_deoptimized()) {\n-          nm->make_not_entrant();\n-          nm->make_deoptimized();\n-        }\n-      }\n-      gc_on_allocation(); \/\/ Flush unused methods from CodeCache if required.\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -298,3 +298,0 @@\n-  static void mark_directives_matches(bool top_only = false);\n-  static void recompile_marked_directives_matches();\n-\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1175,7 +1175,5 @@\n-  if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n-    \/\/ A request has been made for compilation.  Before we do any\n-    \/\/ real work, check to see if the method has been compiled\n-    \/\/ in the meantime with a definitive result.\n-    if (compilation_is_complete(method, osr_bci, comp_level)) {\n-      return;\n-    }\n+  \/\/ A request has been made for compilation.  Before we do any\n+  \/\/ real work, check to see if the method has been compiled\n+  \/\/ in the meantime with a definitive result.\n+  if (compilation_is_complete(method, osr_bci, comp_level)) {\n+    return;\n@@ -1226,7 +1224,5 @@\n-    if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n-      \/\/ We need to check again to see if the compilation has\n-      \/\/ completed.  A previous compilation may have registered\n-      \/\/ some result.\n-      if (compilation_is_complete(method, osr_bci, comp_level)) {\n-        return;\n-      }\n+    \/\/ We need to check again to see if the compilation has\n+    \/\/ completed.  A previous compilation may have registered\n+    \/\/ some result.\n+    if (compilation_is_complete(method, osr_bci, comp_level)) {\n+      return;\n@@ -1381,1 +1377,1 @@\n-    if (method_code != nullptr && (compile_reason != CompileTask::Reason_DirectivesChanged)) {\n+    if (method_code != nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-      Reason_DirectivesChanged, \/\/ Changed CompilerDirectivesStack\n@@ -78,2 +77,1 @@\n-      \"bootstrap\",\n-      \"directives_changed\"\n+      \"bootstrap\"\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -750,19 +750,0 @@\n-bool DirectivesStack::hasMatchingDirectives(const methodHandle& method, bool top_only) {\n-  assert(_depth > 0, \"Must never be empty\");\n-  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n-\n-  CompilerDirectives* dir = _top;\n-  assert(dir != nullptr, \"Must be initialized\");\n-\n-  while (dir != nullptr) {\n-    if (!dir->is_default_directive() && dir->match(method)) {\n-      return true;\n-    }\n-    if (top_only) {\n-      break;\n-    }\n-    dir = dir->next();\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-  static bool hasMatchingDirectives(const methodHandle& method, bool top_only = false);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,8 +128,4 @@\n-    if (thread != nullptr) {\n-      _outer = thread->is_in_internal_oome_mark();\n-      thread->set_is_in_internal_oome_mark(true);\n-      _thread = thread;\n-    } else {\n-      _outer = false;\n-      _thread = nullptr;\n-    }\n+    assert(thread != nullptr, \"nullptr is not supported\");\n+    _outer = thread->is_in_internal_oome_mark();\n+    thread->set_is_in_internal_oome_mark(true);\n+    _thread = thread;\n@@ -139,6 +135,4 @@\n-    if (_thread != nullptr) {\n-      \/\/ Check that only InternalOOMEMark sets\n-      \/\/ JavaThread::_is_in_internal_oome_mark\n-      assert(_thread->is_in_internal_oome_mark(), \"must be\");\n-      _thread->set_is_in_internal_oome_mark(_outer);\n-    }\n+    \/\/ Check that only InternalOOMEMark sets\n+    \/\/ JavaThread::_is_in_internal_oome_mark\n+    assert(_thread->is_in_internal_oome_mark(), \"must be\");\n+    _thread->set_is_in_internal_oome_mark(_outer);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp\"\n@@ -41,1 +43,62 @@\n-ShenandoahSetsOfFree::ShenandoahSetsOfFree(size_t max_regions, ShenandoahFreeSet* free_set) :\n+static const char* partition_name(ShenandoahFreeSetPartitionId t) {\n+  switch (t) {\n+    case ShenandoahFreeSetPartitionId::NotFree: return \"NotFree\";\n+    case ShenandoahFreeSetPartitionId::Mutator: return \"Mutator\";\n+    case ShenandoahFreeSetPartitionId::Collector: return \"Collector\";\n+    case ShenandoahFreeSetPartitionId::OldCollector: return \"OldCollector\";\n+    default:\n+      ShouldNotReachHere();\n+      return \"Unrecognized\";\n+  }\n+}\n+\n+#ifndef PRODUCT\n+void ShenandoahRegionPartitions::dump_bitmap() const {\n+  log_info(gc)(\"Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n+               \"], Old Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _leftmosts[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _rightmosts[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _leftmosts[int(ShenandoahFreeSetPartitionId::OldCollector)],\n+               _rightmosts[int(ShenandoahFreeSetPartitionId::OldCollector)]);\n+  log_info(gc)(\"Empty Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n+               \"], Empty Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n+               \"], Empty Old Collecto range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)],\n+               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)]);\n+\n+  log_info(gc)(\"%6s: %18s %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"Old Collector Bits\", \"NotFree Bits\");\n+  dump_bitmap_range(0, _max-1);\n+}\n+\n+void ShenandoahRegionPartitions::dump_bitmap_range(idx_t start_region_idx, idx_t end_region_idx) const {\n+  assert((start_region_idx >= 0) && (start_region_idx < (idx_t) _max), \"precondition\");\n+  assert((end_region_idx >= 0) && (end_region_idx < (idx_t) _max), \"precondition\");\n+  idx_t aligned_start = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(start_region_idx);\n+  idx_t aligned_end = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(end_region_idx);\n+  idx_t alignment = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].alignment();\n+  while (aligned_start <= aligned_end) {\n+    dump_bitmap_row(aligned_start);\n+    aligned_start += alignment;\n+  }\n+}\n+\n+void ShenandoahRegionPartitions::dump_bitmap_row(idx_t region_idx) const {\n+  assert((region_idx >= 0) && (region_idx < (idx_t) _max), \"precondition\");\n+  idx_t aligned_idx = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(region_idx);\n+  uintx mutator_bits = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].bits_at(aligned_idx);\n+  uintx collector_bits = _membership[int(ShenandoahFreeSetPartitionId::Collector)].bits_at(aligned_idx);\n+  uintx old_collector_bits = _membership[int(ShenandoahFreeSetPartitionId::OldCollector)].bits_at(aligned_idx);\n+  uintx free_bits = mutator_bits | collector_bits | old_collector_bits;\n+  uintx notfree_bits =  ~free_bits;\n+  log_info(gc)(SSIZE_FORMAT_W(6) \": \" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0,\n+               aligned_idx, mutator_bits, collector_bits, old_collector_bits, notfree_bits);\n+}\n+#endif\n+\n+ShenandoahRegionPartitions::ShenandoahRegionPartitions(size_t max_regions, ShenandoahFreeSet* free_set) :\n@@ -43,0 +106,1 @@\n+    _region_size_bytes(ShenandoahHeapRegion::region_size_bytes()),\n@@ -44,1 +108,1 @@\n-    _region_size_bytes(ShenandoahHeapRegion::region_size_bytes())\n+    _membership{ ShenandoahSimpleBitMap(max_regions), ShenandoahSimpleBitMap(max_regions) , ShenandoahSimpleBitMap(max_regions) }\n@@ -46,2 +110,1 @@\n-  _membership = NEW_C_HEAP_ARRAY(ShenandoahFreeMemoryType, max_regions, mtGC);\n-  clear_internal();\n+  make_all_regions_unavailable();\n@@ -50,2 +113,2 @@\n-ShenandoahSetsOfFree::~ShenandoahSetsOfFree() {\n-  FREE_C_HEAP_ARRAY(ShenandoahFreeMemoryType, _membership);\n+inline bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) const {\n+  return r->is_empty() || (r->is_trash() && !_heap->is_concurrent_weak_root_in_progress());\n@@ -54,0 +117,4 @@\n+inline bool ShenandoahFreeSet::can_allocate_from(size_t idx) const {\n+  ShenandoahHeapRegion* r = _heap->get_region(idx);\n+  return can_allocate_from(r);\n+}\n@@ -55,3 +122,6 @@\n-void ShenandoahSetsOfFree::clear_internal() {\n-  for (size_t idx = 0; idx < _max; idx++) {\n-    _membership[idx] = NotFree;\n+inline size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) const {\n+  if (r->is_trash()) {\n+    \/\/ This would be recycled on allocation path\n+    return ShenandoahHeapRegion::region_size_bytes();\n+  } else {\n+    return r->free();\n@@ -59,0 +129,6 @@\n+}\n+\n+inline size_t ShenandoahFreeSet::alloc_capacity(size_t idx) const {\n+  ShenandoahHeapRegion* r = _heap->get_region(idx);\n+  return alloc_capacity(r);\n+}\n@@ -60,7 +136,14 @@\n-  for (size_t idx = 0; idx < NumFreeSets; idx++) {\n-    _leftmosts[idx] = _max;\n-    _rightmosts[idx] = 0;\n-    _leftmosts_empty[idx] = _max;\n-    _rightmosts_empty[idx] = 0;\n-    _capacity_of[idx] = 0;\n-    _used_by[idx] = 0;\n+inline bool ShenandoahFreeSet::has_alloc_capacity(ShenandoahHeapRegion *r) const {\n+  return alloc_capacity(r) > 0;\n+}\n+\n+inline idx_t ShenandoahRegionPartitions::leftmost(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  idx_t idx = _leftmosts[int(which_partition)];\n+  if (idx >= _max) {\n+    return _max;\n+  } else {\n+    \/\/ Cannot assert that membership[which_partition.is_set(idx) because this helper method may be used\n+    \/\/ to query the original value of leftmost when leftmost must be adjusted because the interval representing\n+    \/\/ which_partition is shrinking after the region that used to be leftmost is retired.\n+    return idx;\n@@ -68,0 +151,10 @@\n+}\n+\n+inline idx_t ShenandoahRegionPartitions::rightmost(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  idx_t idx = _rightmosts[int(which_partition)];\n+  \/\/ Cannot assert that membership[which_partition.is_set(idx) because this helper method may be used\n+  \/\/ to query the original value of leftmost when leftmost must be adjusted because the interval representing\n+  \/\/ which_partition is shrinking after the region that used to be leftmost is retired.\n+  return idx;\n+}\n@@ -69,3 +162,12 @@\n-  _left_to_right_bias[Mutator] = true;\n-  _left_to_right_bias[Collector] = false;\n-  _left_to_right_bias[OldCollector] = false;\n+void ShenandoahRegionPartitions::make_all_regions_unavailable() {\n+  for (size_t partition_id = 0; partition_id < IntNumPartitions; partition_id++) {\n+    _membership[partition_id].clear_all();\n+    _leftmosts[partition_id] = _max;\n+    _rightmosts[partition_id] = -1;\n+    _leftmosts_empty[partition_id] = _max;\n+    _rightmosts_empty[partition_id] = -1;;\n+    _capacity[partition_id] = 0;\n+    _used[partition_id] = 0;\n+  }\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = _region_counts[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n+}\n@@ -73,4 +175,21 @@\n-  _region_counts[Mutator] = 0;\n-  _region_counts[Collector] = 0;\n-  _region_counts[OldCollector] = 0;\n-  _region_counts[NotFree] = _max;\n+void ShenandoahRegionPartitions::establish_mutator_intervals(idx_t mutator_leftmost, idx_t mutator_rightmost,\n+                                                             idx_t mutator_leftmost_empty, idx_t mutator_rightmost_empty,\n+                                                             size_t mutator_region_count, size_t mutator_used) {\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count;\n+  _leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_leftmost;\n+  _rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_rightmost;\n+  _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_leftmost_empty;\n+  _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_rightmost_empty;\n+\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count;\n+  _used[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_used;\n+  _capacity[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count * _region_size_bytes;\n+\n+  _leftmosts[int(ShenandoahFreeSetPartitionId::Collector)] = _max;\n+  _rightmosts[int(ShenandoahFreeSetPartitionId::Collector)] = -1;\n+  _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)] = _max;\n+  _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)] = -1;\n+\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n+  _used[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n+  _capacity[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n@@ -79,2 +198,13 @@\n-void ShenandoahSetsOfFree::clear_all() {\n-  clear_internal();\n+void ShenandoahRegionPartitions::establish_old_collector_intervals(idx_t old_collector_leftmost, idx_t old_collector_rightmost,\n+                                                                   idx_t old_collector_leftmost_empty,\n+                                                                   idx_t old_collector_rightmost_empty,\n+                                                                   size_t old_collector_region_count, size_t old_collector_used) {\n+  _region_counts[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_region_count;\n+  _leftmosts[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_leftmost;\n+  _rightmosts[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_rightmost;\n+  _leftmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_leftmost_empty;\n+  _rightmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_rightmost_empty;\n+\n+  _region_counts[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_region_count;\n+  _used[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_used;\n+  _capacity[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_region_count * _region_size_bytes;\n@@ -83,4 +213,4 @@\n-void ShenandoahSetsOfFree::increase_used(ShenandoahFreeMemoryType which_set, size_t bytes) {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"Set must correspond to a valid freeset\");\n-  _used_by[which_set] += bytes;\n-  assert (_used_by[which_set] <= _capacity_of[which_set],\n+void ShenandoahRegionPartitions::increase_used(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n+  _used[int(which_partition)] += bytes;\n+  assert (_used[int(which_partition)] <= _capacity[int(which_partition)],\n@@ -88,1 +218,1 @@\n-          _used_by[which_set], _capacity_of[which_set], bytes);\n+          _used[int(which_partition)], _capacity[int(which_partition)], bytes);\n@@ -91,4 +221,9 @@\n-inline void ShenandoahSetsOfFree::shrink_bounds_if_touched(ShenandoahFreeMemoryType set, size_t idx) {\n-  if (idx == _leftmosts[set]) {\n-    while ((_leftmosts[set] < _max) && !in_free_set(_leftmosts[set], set)) {\n-      _leftmosts[set]++;\n+inline void ShenandoahRegionPartitions::shrink_interval_if_range_modifies_either_boundary(\n+  ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx) {\n+  assert((low_idx <= high_idx) && (low_idx >= 0) && (high_idx < _max), \"Range must span legal index values\");\n+  if (low_idx == leftmost(partition)) {\n+    assert (!_membership[int(partition)].is_set(low_idx), \"Do not shrink interval if region not removed\");\n+    if (high_idx + 1 == _max) {\n+      _leftmosts[int(partition)] = _max;\n+    } else {\n+      _leftmosts[int(partition)] = find_index_of_next_available_region(partition, high_idx + 1);\n@@ -96,1 +231,1 @@\n-    if (_leftmosts_empty[set] < _leftmosts[set]) {\n+    if (_leftmosts_empty[int(partition)] < _leftmosts[int(partition)]) {\n@@ -98,1 +233,1 @@\n-      _leftmosts_empty[set] = _leftmosts[set];\n+      _leftmosts_empty[int(partition)] = _leftmosts[int(partition)];\n@@ -101,3 +236,6 @@\n-  if (idx == _rightmosts[set]) {\n-    while (_rightmosts[set] > 0 && !in_free_set(_rightmosts[set], set)) {\n-      _rightmosts[set]--;\n+  if (high_idx == _rightmosts[int(partition)]) {\n+    assert (!_membership[int(partition)].is_set(high_idx), \"Do not shrink interval if region not removed\");\n+    if (low_idx == 0) {\n+      _rightmosts[int(partition)] = -1;\n+    } else {\n+      _rightmosts[int(partition)] = find_index_of_previous_available_region(partition, low_idx - 1);\n@@ -105,1 +243,1 @@\n-    if (_rightmosts_empty[set] > _rightmosts[set]) {\n+    if (_rightmosts_empty[int(partition)] > _rightmosts[int(partition)]) {\n@@ -107,1 +245,1 @@\n-      _rightmosts_empty[set] = _rightmosts[set];\n+      _rightmosts_empty[int(partition)] = _rightmosts[int(partition)];\n@@ -110,0 +248,10 @@\n+  if (_leftmosts[int(partition)] > _rightmosts[int(partition)]) {\n+    _leftmosts[int(partition)] = _max;\n+    _rightmosts[int(partition)] = -1;\n+    _leftmosts_empty[int(partition)] = _max;\n+    _rightmosts_empty[int(partition)] = -1;\n+  }\n+}\n+\n+inline void ShenandoahRegionPartitions::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, idx_t idx) {\n+  shrink_interval_if_range_modifies_either_boundary(partition, idx, idx);\n@@ -112,4 +260,11 @@\n-inline void ShenandoahSetsOfFree::expand_bounds_maybe(ShenandoahFreeMemoryType set, size_t idx, size_t region_capacity) {\n-  if (region_capacity == _region_size_bytes) {\n-    if (_leftmosts_empty[set] > idx) {\n-      _leftmosts_empty[set] = idx;\n+inline void ShenandoahRegionPartitions::expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition,\n+                                                                             idx_t idx, size_t region_available) {\n+  if (_leftmosts[int(partition)] > idx) {\n+    _leftmosts[int(partition)] = idx;\n+  }\n+  if (_rightmosts[int(partition)] < idx) {\n+    _rightmosts[int(partition)] = idx;\n+  }\n+  if (region_available == _region_size_bytes) {\n+    if (_leftmosts_empty[int(partition)] > idx) {\n+      _leftmosts_empty[int(partition)] = idx;\n@@ -117,2 +272,2 @@\n-    if (_rightmosts_empty[set] < idx) {\n-      _rightmosts_empty[set] = idx;\n+    if (_rightmosts_empty[int(partition)] < idx) {\n+      _rightmosts_empty[int(partition)] = idx;\n@@ -121,5 +276,13 @@\n-  if (_leftmosts[set] > idx) {\n-    _leftmosts[set] = idx;\n-  }\n-  if (_rightmosts[set] < idx) {\n-    _rightmosts[set] = idx;\n+}\n+\n+void ShenandoahRegionPartitions::retire_range_from_partition(\n+  ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx) {\n+\n+  \/\/ Note: we may remove from free partition even if region is not entirely full, such as when available < PLAB::min_size()\n+  assert ((low_idx < _max) && (high_idx < _max), \"Both indices are sane: \" SIZE_FORMAT \" and \" SIZE_FORMAT \" < \" SIZE_FORMAT,\n+          low_idx, high_idx, _max);\n+  assert (partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n+\n+  for (idx_t idx = low_idx; idx <= high_idx; idx++) {\n+    assert (in_free_set(partition, idx), \"Must be in partition to remove from partition\");\n+    _membership[int(partition)].clear_bit(idx);\n@@ -127,0 +290,2 @@\n+  _region_counts[int(partition)] -= high_idx + 1 - low_idx;\n+  shrink_interval_if_range_modifies_either_boundary(partition, low_idx, high_idx);\n@@ -129,1 +294,3 @@\n-void ShenandoahSetsOfFree::remove_from_free_sets(size_t idx) {\n+void ShenandoahRegionPartitions::retire_from_partition(ShenandoahFreeSetPartitionId partition, idx_t idx, size_t used_bytes) {\n+\n+  \/\/ Note: we may remove from free partition even if region is not entirely full, such as when available < PLAB::min_size()\n@@ -131,4 +298,2 @@\n-  ShenandoahFreeMemoryType orig_set = membership(idx);\n-  assert (orig_set > NotFree && orig_set < NumFreeSets, \"Cannot remove from free sets if not already free\");\n-  _membership[idx] = NotFree;\n-  shrink_bounds_if_touched(orig_set, idx);\n+  assert (partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n+  assert (in_free_set(partition, idx), \"Must be in partition to remove from partition\");\n@@ -136,2 +301,7 @@\n-  _region_counts[orig_set]--;\n-  _region_counts[NotFree]++;\n+  if (used_bytes < _region_size_bytes) {\n+    \/\/ Count the alignment pad remnant of memory as used when we retire this region\n+    increase_used(partition, _region_size_bytes - used_bytes);\n+  }\n+  _membership[int(partition)].clear_bit(idx);\n+  shrink_interval_if_boundary_modified(partition, idx);\n+  _region_counts[int(partition)]--;\n@@ -140,2 +310,1 @@\n-\n-void ShenandoahSetsOfFree::make_free(size_t idx, ShenandoahFreeMemoryType which_set, size_t region_capacity) {\n+void ShenandoahRegionPartitions::make_free(idx_t idx, ShenandoahFreeSetPartitionId which_partition, size_t available) {\n@@ -143,8 +312,9 @@\n-  assert (_membership[idx] == NotFree, \"Cannot make free if already free\");\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  _membership[idx] = which_set;\n-  _capacity_of[which_set] += region_capacity;\n-  expand_bounds_maybe(which_set, idx, region_capacity);\n-\n-  _region_counts[NotFree]--;\n-  _region_counts[which_set]++;\n+  assert (membership(idx) == ShenandoahFreeSetPartitionId::NotFree, \"Cannot make free if already free\");\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  assert (available <= _region_size_bytes, \"Available cannot exceed region size\");\n+\n+  _membership[int(which_partition)].set_bit(idx);\n+  _capacity[int(which_partition)] += _region_size_bytes;\n+  _used[int(which_partition)] += _region_size_bytes - available;\n+  expand_interval_if_boundary_modified(which_partition, idx, available);\n+  _region_counts[int(which_partition)]++;\n@@ -153,1 +323,3 @@\n-void ShenandoahSetsOfFree::move_to_set(size_t idx, ShenandoahFreeMemoryType new_set, size_t region_capacity) {\n+void ShenandoahRegionPartitions::move_from_partition_to_partition(idx_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+                                                                  ShenandoahFreeSetPartitionId new_partition, size_t available) {\n+  ShenandoahHeapRegion* r;\n@@ -155,3 +327,10 @@\n-  assert ((new_set > NotFree) && (new_set < NumFreeSets), \"New set must be valid\");\n-  ShenandoahFreeMemoryType orig_set = _membership[idx];\n-  assert ((orig_set > NotFree) && (orig_set < NumFreeSets), \"Cannot move free unless already free\");\n+  assert (orig_partition < NumPartitions, \"Original partition must be valid\");\n+  assert (new_partition < NumPartitions, \"New partition must be valid\");\n+  assert (available <= _region_size_bytes, \"Available cannot exceed region size\");\n+  assert (_membership[int(orig_partition)].is_set(idx), \"Cannot move from partition unless in partition\");\n+  assert ((r = ShenandoahHeap::heap()->get_region(idx)) &&\n+          ((r->is_trash() && (available == _region_size_bytes)) ||\n+           (r->used() + available == _region_size_bytes)),\n+          \"Used: \" SIZE_FORMAT \" + available: \" SIZE_FORMAT \" should equal region size: \" SIZE_FORMAT,\n+          ShenandoahHeap::heap()->get_region(idx)->used(), available, _region_size_bytes);\n+\n@@ -159,21 +338,41 @@\n-  \/\/  During rebuild: Mutator => Collector\n-  \/\/                  Mutator empty => Collector\n-  \/\/  During flip_to_gc:\n-  \/\/                  Mutator empty => Collector\n-  \/\/                  Mutator empty => Old Collector\n-  \/\/ At start of update refs:\n-  \/\/                  Collector => Mutator\n-  \/\/                  OldCollector Empty => Mutator\n-  assert((region_capacity <= _region_size_bytes && ((orig_set == Mutator && new_set == Collector) || (orig_set == Collector && new_set == Mutator)))\n-      || (region_capacity == _region_size_bytes && ((orig_set == Mutator && new_set == Collector) || (orig_set == OldCollector && new_set == Mutator) || new_set == OldCollector)),\n-      \"Unexpected movement between sets\");\n-\n-  _membership[idx] = new_set;\n-  _capacity_of[orig_set] -= region_capacity;\n-  shrink_bounds_if_touched(orig_set, idx);\n-\n-  _capacity_of[new_set] += region_capacity;\n-  expand_bounds_maybe(new_set, idx, region_capacity);\n-\n-  _region_counts[orig_set]--;\n-  _region_counts[new_set]++;\n+  \/\/  During rebuild:         Mutator => Collector\n+  \/\/                          Mutator empty => Collector\n+  \/\/                          Mutator empty => OldCollector\n+  \/\/  During flip_to_gc:      Mutator empty => Collector\n+  \/\/                          Mutator empty => OldCollector\n+  \/\/ At start of update refs: Collector => Mutator\n+  \/\/                          OldCollector Empty => Mutator\n+  assert (((available <= _region_size_bytes) &&\n+           ((((orig_partition == ShenandoahFreeSetPartitionId::Mutator)\n+              && (new_partition == ShenandoahFreeSetPartitionId::Collector)) ||\n+             ((orig_partition == ShenandoahFreeSetPartitionId::Collector)\n+              && (new_partition == ShenandoahFreeSetPartitionId::Mutator))))) ||\n+          ((available == _region_size_bytes) &&\n+           (((orig_partition == ShenandoahFreeSetPartitionId::Mutator)\n+             && (new_partition == ShenandoahFreeSetPartitionId::Collector)) ||\n+            ((orig_partition == ShenandoahFreeSetPartitionId::Mutator)\n+             && (new_partition == ShenandoahFreeSetPartitionId::OldCollector)) ||\n+            ((orig_partition == ShenandoahFreeSetPartitionId::OldCollector)\n+             && (new_partition == ShenandoahFreeSetPartitionId::Mutator)))),\n+          \"Unexpected movement between partitions, available: \" SIZE_FORMAT \", _region_size_bytes: \" SIZE_FORMAT\n+          \", orig_partition: %s, new_partition: %s\",\n+          available, _region_size_bytes, partition_name(orig_partition), partition_name(new_partition));\n+\n+  size_t used = _region_size_bytes - available;\n+  assert (_used[int(orig_partition)] >= used,\n+          \"Orig partition used: \" SIZE_FORMAT \" must exceed moved used: \" SIZE_FORMAT \" within region \" SSIZE_FORMAT,\n+          _used[int(orig_partition)], used, idx);\n+\n+  _membership[int(orig_partition)].clear_bit(idx);\n+  _membership[int(new_partition)].set_bit(idx);\n+\n+  _capacity[int(orig_partition)] -= _region_size_bytes;\n+  _used[int(orig_partition)] -= used;\n+  shrink_interval_if_boundary_modified(orig_partition, idx);\n+\n+  _capacity[int(new_partition)] += _region_size_bytes;;\n+  _used[int(new_partition)] += used;\n+  expand_interval_if_boundary_modified(new_partition, idx, available);\n+\n+  _region_counts[int(orig_partition)]--;\n+  _region_counts[int(new_partition)]++;\n@@ -182,3 +381,2 @@\n-inline ShenandoahFreeMemoryType ShenandoahSetsOfFree::membership(size_t idx) const {\n-  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n-  return _membership[idx];\n+const char* ShenandoahRegionPartitions::partition_membership_name(idx_t idx) const {\n+  return partition_name(membership(idx));\n@@ -187,3 +385,1 @@\n-  \/\/ Returns true iff region idx is in the test_set free_set.  Before returning true, asserts that the free\n-  \/\/ set is not empty.  Requires that test_set != NotFree or NumFreeSets.\n-inline bool ShenandoahSetsOfFree::in_free_set(size_t idx, ShenandoahFreeMemoryType test_set) const {\n+inline ShenandoahFreeSetPartitionId ShenandoahRegionPartitions::membership(idx_t idx) const {\n@@ -191,5 +387,6 @@\n-  if (_membership[idx] == test_set) {\n-    assert (test_set == NotFree || _free_set->alloc_capacity(idx) > 0, \"Free regions must have alloc capacity\");\n-    return true;\n-  } else {\n-    return false;\n+  ShenandoahFreeSetPartitionId result = ShenandoahFreeSetPartitionId::NotFree;\n+  for (uint partition_id = 0; partition_id < UIntNumPartitions; partition_id++) {\n+    if (_membership[partition_id].is_set(idx)) {\n+      assert(result == ShenandoahFreeSetPartitionId::NotFree, \"Region should reside in only one partition\");\n+      result = (ShenandoahFreeSetPartitionId) partition_id;\n+    }\n@@ -197,0 +394,1 @@\n+  return result;\n@@ -199,10 +397,4 @@\n-inline size_t ShenandoahSetsOfFree::leftmost(ShenandoahFreeMemoryType which_set) const {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  size_t idx = _leftmosts[which_set];\n-  if (idx >= _max) {\n-    return _max;\n-  } else {\n-    assert (in_free_set(idx, which_set), \"left-most region must be free\");\n-    return idx;\n-  }\n-}\n+#ifdef ASSERT\n+inline bool ShenandoahRegionPartitions::partition_id_matches(idx_t idx, ShenandoahFreeSetPartitionId test_partition) const {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  assert (test_partition < ShenandoahFreeSetPartitionId::NotFree, \"must be a valid partition\");\n@@ -210,5 +402,1 @@\n-inline size_t ShenandoahSetsOfFree::rightmost(ShenandoahFreeMemoryType which_set) const {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  size_t idx = _rightmosts[which_set];\n-  assert ((_leftmosts[which_set] == _max) || in_free_set(idx, which_set), \"right-most region must be free\");\n-  return idx;\n+  return membership(idx) == test_partition;\n@@ -216,0 +404,1 @@\n+#endif\n@@ -217,3 +406,3 @@\n-inline bool ShenandoahSetsOfFree::is_empty(ShenandoahFreeMemoryType which_set) const {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  return (leftmost(which_set) > rightmost(which_set));\n+inline bool ShenandoahRegionPartitions::is_empty(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  return (leftmost(which_partition) > rightmost(which_partition));\n@@ -222,7 +411,7 @@\n-size_t ShenandoahSetsOfFree::leftmost_empty(ShenandoahFreeMemoryType which_set) {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  for (size_t idx = _leftmosts_empty[which_set]; idx < _max; idx++) {\n-    if ((membership(idx) == which_set) && (_free_set->alloc_capacity(idx) == _region_size_bytes)) {\n-      _leftmosts_empty[which_set] = idx;\n-      return idx;\n-    }\n+inline idx_t ShenandoahRegionPartitions::find_index_of_next_available_region(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t start_index) const {\n+  idx_t rightmost_idx = rightmost(which_partition);\n+  idx_t leftmost_idx = leftmost(which_partition);\n+  if ((rightmost_idx < leftmost_idx) || (start_index > rightmost_idx)) return _max;\n+  if (start_index < leftmost_idx) {\n+    start_index = leftmost_idx;\n@@ -230,3 +419,6 @@\n-  _leftmosts_empty[which_set] = _max;\n-  _rightmosts_empty[which_set] = 0;\n-  return _max;\n+  idx_t result = _membership[int(which_partition)].find_first_set_bit(start_index, rightmost_idx + 1);\n+  if (result > rightmost_idx) {\n+    result = _max;\n+  }\n+  assert (result >= start_index, \"Requires progress\");\n+  return result;\n@@ -235,7 +427,12 @@\n-inline size_t ShenandoahSetsOfFree::rightmost_empty(ShenandoahFreeMemoryType which_set) {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  for (intptr_t idx = _rightmosts_empty[which_set]; idx >= 0; idx--) {\n-    if ((membership(idx) == which_set) && (_free_set->alloc_capacity(idx) == _region_size_bytes)) {\n-      _rightmosts_empty[which_set] = idx;\n-      return idx;\n-    }\n+inline idx_t ShenandoahRegionPartitions::find_index_of_previous_available_region(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t last_index) const {\n+  idx_t rightmost_idx = rightmost(which_partition);\n+  idx_t leftmost_idx = leftmost(which_partition);\n+  \/\/ if (leftmost_idx == max) then (last_index < leftmost_idx)\n+  if (last_index < leftmost_idx) return -1;\n+  if (last_index > rightmost_idx) {\n+    last_index = rightmost_idx;\n+  }\n+  idx_t result = _membership[int(which_partition)].find_last_set_bit(-1, last_index);\n+  if (result < leftmost_idx) {\n+    result = -1;\n@@ -243,3 +440,2 @@\n-  _leftmosts_empty[which_set] = _max;\n-  _rightmosts_empty[which_set] = 0;\n-  return 0;\n+  assert (result <= last_index, \"Requires progress\");\n+  return result;\n@@ -248,3 +444,11 @@\n-inline bool ShenandoahSetsOfFree::alloc_from_left_bias(ShenandoahFreeMemoryType which_set) {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  return _left_to_right_bias[which_set];\n+inline idx_t ShenandoahRegionPartitions::find_index_of_next_available_cluster_of_regions(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t start_index, size_t cluster_size) const {\n+  idx_t rightmost_idx = rightmost(which_partition);\n+  idx_t leftmost_idx = leftmost(which_partition);\n+  if ((rightmost_idx < leftmost_idx) || (start_index > rightmost_idx)) return _max;\n+  idx_t result = _membership[int(which_partition)].find_first_consecutive_set_bits(start_index, rightmost_idx + 1, cluster_size);\n+  if (result > rightmost_idx) {\n+    result = _max;\n+  }\n+  assert (result >= start_index, \"Requires progress\");\n+  return result;\n@@ -253,8 +457,12 @@\n-void ShenandoahSetsOfFree::establish_alloc_bias(ShenandoahFreeMemoryType which_set) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  shenandoah_assert_heaplocked();\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-\n-  size_t middle = (_leftmosts[which_set] + _rightmosts[which_set]) \/ 2;\n-  size_t available_in_first_half = 0;\n-  size_t available_in_second_half = 0;\n+inline idx_t ShenandoahRegionPartitions::find_index_of_previous_available_cluster_of_regions(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t last_index, size_t cluster_size) const {\n+  idx_t leftmost_idx = leftmost(which_partition);\n+  \/\/ if (leftmost_idx == max) then (last_index < leftmost_idx)\n+  if (last_index < leftmost_idx) return -1;\n+  idx_t result = _membership[int(which_partition)].find_last_consecutive_set_bits(leftmost_idx - 1, last_index, cluster_size);\n+  if (result <= leftmost_idx) {\n+    result = -1;\n+  }\n+  assert (result <= last_index, \"Requires progress\");\n+  return result;\n+}\n@@ -262,5 +470,5 @@\n-  for (size_t index = _leftmosts[which_set]; index < middle; index++) {\n-    if (in_free_set(index, which_set)) {\n-      ShenandoahHeapRegion* r = heap->get_region(index);\n-      available_in_first_half += r->free();\n-    }\n+idx_t ShenandoahRegionPartitions::leftmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  idx_t max_regions = _max;\n+  if (_leftmosts_empty[int(which_partition)] == _max) {\n+    return _max;\n@@ -268,4 +476,6 @@\n-  for (size_t index = middle; index <= _rightmosts[which_set]; index++) {\n-    if (in_free_set(index, which_set)) {\n-      ShenandoahHeapRegion* r = heap->get_region(index);\n-      available_in_second_half += r->free();\n+  for (idx_t idx = find_index_of_next_available_region(which_partition, _leftmosts_empty[int(which_partition)]);\n+       idx < max_regions; ) {\n+    assert(in_free_set(which_partition, idx), \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n+    if (_free_set->alloc_capacity(idx) == _region_size_bytes) {\n+      _leftmosts_empty[int(which_partition)] = idx;\n+      return idx;\n@@ -273,0 +483,1 @@\n+    idx = find_index_of_next_available_region(which_partition, idx + 1);\n@@ -274,0 +485,4 @@\n+  _leftmosts_empty[int(which_partition)] = _max;\n+  _rightmosts_empty[int(which_partition)] = -1;\n+  return _max;\n+}\n@@ -275,8 +490,17 @@\n-  \/\/ We desire to first consume the sparsely distributed regions in order that the remaining regions are densely packed.\n-  \/\/ Densely packing regions reduces the effort to search for a region that has sufficient memory to satisfy a new allocation\n-  \/\/ request.  Regions become sparsely distributed following a Full GC, which tends to slide all regions to the front of the\n-  \/\/ heap rather than allowing survivor regions to remain at the high end of the heap where we intend for them to congregate.\n-\n-  \/\/ TODO: In the future, we may modify Full GC so that it slides old objects to the end of the heap and young objects to the\n-  \/\/ front of the heap. If this is done, we can always search survivor Collector and OldCollector regions right to left.\n-  _left_to_right_bias[which_set] = (available_in_second_half > available_in_first_half);\n+idx_t ShenandoahRegionPartitions::rightmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  if (_rightmosts_empty[int(which_partition)] < 0) {\n+    return -1;\n+  }\n+  for (idx_t idx = find_index_of_previous_available_region(which_partition, _rightmosts_empty[int(which_partition)]);\n+       idx >= 0; ) {\n+    assert(in_free_set(which_partition, idx), \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n+    if (_free_set->alloc_capacity(idx) == _region_size_bytes) {\n+      _rightmosts_empty[int(which_partition)] = idx;\n+      return idx;\n+    }\n+    idx = find_index_of_previous_available_region(which_partition, idx - 1);\n+  }\n+  _leftmosts_empty[int(which_partition)] = _max;\n+  _rightmosts_empty[int(which_partition)] = -1;\n+  return -1;\n@@ -285,0 +509,1 @@\n+\n@@ -286,1 +511,1 @@\n-void ShenandoahSetsOfFree::assert_bounds() {\n+void ShenandoahRegionPartitions::assert_bounds() {\n@@ -288,4 +513,4 @@\n-  size_t leftmosts[NumFreeSets];\n-  size_t rightmosts[NumFreeSets];\n-  size_t empty_leftmosts[NumFreeSets];\n-  size_t empty_rightmosts[NumFreeSets];\n+  idx_t leftmosts[UIntNumPartitions];\n+  idx_t rightmosts[UIntNumPartitions];\n+  idx_t empty_leftmosts[UIntNumPartitions];\n+  idx_t empty_rightmosts[UIntNumPartitions];\n@@ -293,1 +518,1 @@\n-  for (int i = 0; i < NumFreeSets; i++) {\n+  for (uint i = 0; i < UIntNumPartitions; i++) {\n@@ -296,2 +521,2 @@\n-    rightmosts[i] = 0;\n-    empty_rightmosts[i] = 0;\n+    rightmosts[i] = -1;\n+    empty_rightmosts[i] = -1;\n@@ -300,4 +525,4 @@\n-  for (size_t i = 0; i < _max; i++) {\n-    ShenandoahFreeMemoryType set = membership(i);\n-    switch (set) {\n-      case NotFree:\n+  for (idx_t i = 0; i < _max; i++) {\n+    ShenandoahFreeSetPartitionId partition = membership(i);\n+    switch (partition) {\n+      case ShenandoahFreeSetPartitionId::NotFree:\n@@ -306,3 +531,3 @@\n-      case Mutator:\n-      case Collector:\n-      case OldCollector:\n+      case ShenandoahFreeSetPartitionId::Mutator:\n+      case ShenandoahFreeSetPartitionId::Collector:\n+      case ShenandoahFreeSetPartitionId::OldCollector:\n@@ -313,2 +538,2 @@\n-        if (i < leftmosts[set]) {\n-          leftmosts[set] = i;\n+        if (i < leftmosts[int(partition)]) {\n+          leftmosts[int(partition)] = i;\n@@ -316,2 +541,2 @@\n-        if (is_empty && (i < empty_leftmosts[set])) {\n-          empty_leftmosts[set] = i;\n+        if (is_empty && (i < empty_leftmosts[int(partition)])) {\n+          empty_leftmosts[int(partition)] = i;\n@@ -319,2 +544,2 @@\n-        if (i > rightmosts[set]) {\n-          rightmosts[set] = i;\n+        if (i > rightmosts[int(partition)]) {\n+          rightmosts[int(partition)] = i;\n@@ -322,2 +547,2 @@\n-        if (is_empty && (i > empty_rightmosts[set])) {\n-          empty_rightmosts[set] = i;\n+        if (is_empty && (i > empty_rightmosts[int(partition)])) {\n+          empty_rightmosts[int(partition)] = i;\n@@ -328,1 +553,0 @@\n-      case NumFreeSets:\n@@ -334,71 +558,101 @@\n-  \/\/ Performance invariants. Failing these would not break the free set, but performance would suffer.\n-  assert (leftmost(Mutator) <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, leftmost(Mutator),  _max);\n-  assert (rightmost(Mutator) < _max, \"rightmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, rightmost(Mutator),  _max);\n-\n-  assert (leftmost(Mutator) == _max || in_free_set(leftmost(Mutator), Mutator),\n-          \"leftmost region should be free: \" SIZE_FORMAT,  leftmost(Mutator));\n-  assert (leftmost(Mutator) == _max || in_free_set(rightmost(Mutator), Mutator),\n-          \"rightmost region should be free: \" SIZE_FORMAT, rightmost(Mutator));\n-\n-  \/\/ If Mutator set is empty, leftmosts will both equal max, rightmosts will both equal zero.  Likewise for empty region sets.\n-  size_t beg_off = leftmosts[Mutator];\n-  size_t end_off = rightmosts[Mutator];\n-  assert (beg_off >= leftmost(Mutator),\n-          \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost(Mutator));\n-  assert (end_off <= rightmost(Mutator),\n-          \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost(Mutator));\n-\n-  beg_off = empty_leftmosts[Mutator];\n-  end_off = empty_rightmosts[Mutator];\n-  assert (beg_off >= leftmost_empty(Mutator),\n-          \"free empty regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost_empty(Mutator));\n-  assert (end_off <= rightmost_empty(Mutator),\n-          \"free empty regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost_empty(Mutator));\n-\n-  \/\/ Performance invariants. Failing these would not break the free set, but performance would suffer.\n-  assert (leftmost(Collector) <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, leftmost(Collector),  _max);\n-  assert (rightmost(Collector) < _max, \"rightmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, rightmost(Collector),  _max);\n-\n-  assert (leftmost(Collector) == _max || in_free_set(leftmost(Collector), Collector),\n-          \"leftmost region should be free: \" SIZE_FORMAT,  leftmost(Collector));\n-  assert (leftmost(Collector) == _max || in_free_set(rightmost(Collector), Collector),\n-          \"rightmost region should be free: \" SIZE_FORMAT, rightmost(Collector));\n-\n-  \/\/ If Collector set is empty, leftmosts will both equal max, rightmosts will both equal zero.  Likewise for empty region sets.\n-  beg_off = leftmosts[Collector];\n-  end_off = rightmosts[Collector];\n-  assert (beg_off >= leftmost(Collector),\n-          \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost(Collector));\n-  assert (end_off <= rightmost(Collector),\n-          \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost(Collector));\n-\n-  beg_off = empty_leftmosts[Collector];\n-  end_off = empty_rightmosts[Collector];\n-  assert (beg_off >= leftmost_empty(Collector),\n-          \"free empty regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost_empty(Collector));\n-  assert (end_off <= rightmost_empty(Collector),\n-          \"free empty regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost_empty(Collector));\n-\n-  \/\/ Performance invariants. Failing these would not break the free set, but performance would suffer.\n-  assert (leftmost(OldCollector) <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, leftmost(OldCollector),  _max);\n-  assert (rightmost(OldCollector) < _max, \"rightmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, rightmost(OldCollector),  _max);\n-\n-  assert (leftmost(OldCollector) == _max || in_free_set(leftmost(OldCollector), OldCollector),\n-          \"leftmost region should be free: \" SIZE_FORMAT,  leftmost(OldCollector));\n-  assert (leftmost(OldCollector) == _max || in_free_set(rightmost(OldCollector), OldCollector),\n-          \"rightmost region should be free: \" SIZE_FORMAT, rightmost(OldCollector));\n-\n-  \/\/ If OldCollector set is empty, leftmosts will both equal max, rightmosts will both equal zero.  Likewise for empty region sets.\n-  beg_off = leftmosts[OldCollector];\n-  end_off = rightmosts[OldCollector];\n-  assert (beg_off >= leftmost(OldCollector),\n-          \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost(OldCollector));\n-  assert (end_off <= rightmost(OldCollector),\n-          \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost(OldCollector));\n-\n-  beg_off = empty_leftmosts[OldCollector];\n-  end_off = empty_rightmosts[OldCollector];\n-  assert (beg_off >= leftmost_empty(OldCollector),\n-          \"free empty regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost_empty(OldCollector));\n-  assert (end_off <= rightmost_empty(OldCollector),\n-          \"free empty regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost_empty(OldCollector));\n+  \/\/ Performance invariants. Failing these would not break the free partition, but performance would suffer.\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Mutator) <= _max,\n+          \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, leftmost(ShenandoahFreeSetPartitionId::Mutator),  _max);\n+  assert (rightmost(ShenandoahFreeSetPartitionId::Mutator) < _max,\n+          \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::Mutator),  _max);\n+\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Mutator) == _max\n+          || partition_id_matches(leftmost(ShenandoahFreeSetPartitionId::Mutator), ShenandoahFreeSetPartitionId::Mutator),\n+          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(ShenandoahFreeSetPartitionId::Mutator));\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Mutator) == _max\n+          || partition_id_matches(rightmost(ShenandoahFreeSetPartitionId::Mutator), ShenandoahFreeSetPartitionId::Mutator),\n+          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::Mutator));\n+\n+  \/\/ If Mutator partition is empty, leftmosts will both equal max, rightmosts will both equal zero.\n+  \/\/ Likewise for empty region partitions.\n+  idx_t beg_off = leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  idx_t end_off = rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  assert (beg_off >= leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost(ShenandoahFreeSetPartitionId::Mutator));\n+  assert (end_off <= rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost(ShenandoahFreeSetPartitionId::Mutator));\n+\n+  beg_off = empty_leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  end_off = empty_rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  assert (beg_off >= leftmost_empty(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost_empty(ShenandoahFreeSetPartitionId::Mutator));\n+  assert (end_off <= rightmost_empty(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost_empty(ShenandoahFreeSetPartitionId::Mutator));\n+\n+  \/\/ Performance invariants. Failing these would not break the free partition, but performance would suffer.\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Collector) <= _max, \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT,\n+          leftmost(ShenandoahFreeSetPartitionId::Collector),  _max);\n+  assert (rightmost(ShenandoahFreeSetPartitionId::Collector) < _max, \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT,\n+          rightmost(ShenandoahFreeSetPartitionId::Collector),  _max);\n+\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Collector) == _max\n+          || partition_id_matches(leftmost(ShenandoahFreeSetPartitionId::Collector), ShenandoahFreeSetPartitionId::Collector),\n+          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(ShenandoahFreeSetPartitionId::Collector));\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Collector) == _max\n+          || partition_id_matches(rightmost(ShenandoahFreeSetPartitionId::Collector), ShenandoahFreeSetPartitionId::Collector),\n+          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::Collector));\n+\n+  \/\/ If Collector partition is empty, leftmosts will both equal max, rightmosts will both equal zero.\n+  \/\/ Likewise for empty region partitions.\n+  beg_off = leftmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  end_off = rightmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  assert (beg_off >= leftmost(ShenandoahFreeSetPartitionId::Collector),\n+          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost(ShenandoahFreeSetPartitionId::Collector));\n+  assert (end_off <= rightmost(ShenandoahFreeSetPartitionId::Collector),\n+          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost(ShenandoahFreeSetPartitionId::Collector));\n+\n+  beg_off = empty_leftmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  end_off = empty_rightmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  assert (beg_off >= _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost_empty(ShenandoahFreeSetPartitionId::Collector));\n+  assert (end_off <= _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost_empty(ShenandoahFreeSetPartitionId::Collector));\n+\n+\n+  \/\/ Performance invariants. Failing these would not break the free partition, but performance would suffer.\n+  assert (leftmost(ShenandoahFreeSetPartitionId::OldCollector) <= _max, \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT,\n+          leftmost(ShenandoahFreeSetPartitionId::OldCollector),  _max);\n+  assert (rightmost(ShenandoahFreeSetPartitionId::OldCollector) < _max, \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT,\n+          rightmost(ShenandoahFreeSetPartitionId::OldCollector),  _max);\n+\n+  assert (leftmost(ShenandoahFreeSetPartitionId::OldCollector) == _max\n+          || partition_id_matches(leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                                  ShenandoahFreeSetPartitionId::OldCollector),\n+          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(ShenandoahFreeSetPartitionId::OldCollector));\n+  assert (leftmost(ShenandoahFreeSetPartitionId::OldCollector) == _max\n+          || partition_id_matches(rightmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                                  ShenandoahFreeSetPartitionId::OldCollector),\n+          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n+\n+  \/\/ If OldCollector partition is empty, leftmosts will both equal max, rightmosts will both equal zero.\n+  \/\/ Likewise for empty region partitions.\n+  beg_off = leftmosts[int(ShenandoahFreeSetPartitionId::OldCollector)];\n+  end_off = rightmosts[int(ShenandoahFreeSetPartitionId::OldCollector)];\n+  assert (beg_off >= leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost(ShenandoahFreeSetPartitionId::OldCollector));\n+  assert (end_off <= rightmost(ShenandoahFreeSetPartitionId::OldCollector),\n+          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n+\n+  beg_off = empty_leftmosts[int(ShenandoahFreeSetPartitionId::OldCollector)];\n+  end_off = empty_rightmosts[int(ShenandoahFreeSetPartitionId::OldCollector)];\n+  assert (beg_off >= _leftmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)],\n+          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost_empty(ShenandoahFreeSetPartitionId::OldCollector));\n+  assert (end_off <= _rightmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)],\n+          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost_empty(ShenandoahFreeSetPartitionId::OldCollector));\n@@ -410,1 +664,2 @@\n-  _free_sets(max_regions, this)\n+  _partitions(max_regions, this),\n+  _alloc_bias_weight(0)\n@@ -415,46 +670,1 @@\n-\/\/ This allocates from a region within the old_collector_set.  If affiliation equals OLD, the allocation must be taken\n-\/\/ from a region that is_old().  Otherwise, affiliation should be FREE, in which case this will put a previously unaffiliated\n-\/\/ region into service.\n-HeapWord* ShenandoahFreeSet::allocate_old_with_affiliation(ShenandoahAffiliation affiliation,\n-                                                           ShenandoahAllocRequest& req, bool& in_new_region) {\n-  shenandoah_assert_heaplocked();\n-\n-  size_t rightmost =\n-    (affiliation == ShenandoahAffiliation::FREE)? _free_sets.rightmost_empty(OldCollector): _free_sets.rightmost(OldCollector);\n-  size_t leftmost =\n-    (affiliation == ShenandoahAffiliation::FREE)? _free_sets.leftmost_empty(OldCollector): _free_sets.leftmost(OldCollector);\n-  if (_free_sets.alloc_from_left_bias(OldCollector)) {\n-    \/\/ This mode picks up stragglers left by a full GC\n-    for (size_t idx = leftmost; idx <= rightmost; idx++) {\n-      if (_free_sets.in_free_set(idx, OldCollector)) {\n-        ShenandoahHeapRegion* r = _heap->get_region(idx);\n-        assert(r->is_trash() || !r->is_affiliated() || r->is_old(), \"old_collector_set region has bad affiliation\");\n-        if (r->affiliation() == affiliation) {\n-          HeapWord* result = try_allocate_in(r, req, in_new_region);\n-          if (result != nullptr) {\n-            return result;\n-          }\n-        }\n-      }\n-    }\n-  } else {\n-    \/\/ This mode picks up stragglers left by a previous concurrent GC\n-    for (size_t count = rightmost + 1; count > leftmost; count--) {\n-      \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n-      size_t idx = count - 1;\n-      if (_free_sets.in_free_set(idx, OldCollector)) {\n-        ShenandoahHeapRegion* r = _heap->get_region(idx);\n-        assert(r->is_trash() || !r->is_affiliated() || r->is_old(), \"old_collector_set region has bad affiliation\");\n-        if (r->affiliation() == affiliation) {\n-          HeapWord* result = try_allocate_in(r, req, in_new_region);\n-          if (result != nullptr) {\n-            return result;\n-          }\n-        }\n-      }\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-void ShenandoahFreeSet::add_old_collector_free_region(ShenandoahHeapRegion* region) {\n+void ShenandoahFreeSet::add_promoted_in_place_region_to_old_collector(ShenandoahHeapRegion* region) {\n@@ -465,1 +675,2 @@\n-  assert(_free_sets.membership(idx) == NotFree, \"Regions promoted in place should not be in any free set\");\n+  assert(_partitions.membership(idx) == ShenandoahFreeSetPartitionId::NotFree,\n+         \"Regions promoted in place should have been excluded from Mutator partition\");\n@@ -467,1 +678,1 @@\n-    _free_sets.make_free(idx, OldCollector, capacity);\n+    _partitions.make_free(idx, ShenandoahFreeSetPartitionId::OldCollector, capacity);\n@@ -472,2 +683,3 @@\n-HeapWord* ShenandoahFreeSet::allocate_with_affiliation(ShenandoahAffiliation affiliation,\n-                                                       ShenandoahAllocRequest& req, bool& in_new_region) {\n+HeapWord* ShenandoahFreeSet::allocate_from_partition_with_affiliation(ShenandoahFreeSetPartitionId which_partition,\n+                                                                      ShenandoahAffiliation affiliation,\n+                                                                      ShenandoahAllocRequest& req, bool& in_new_region) {\n@@ -475,8 +687,7 @@\n-  size_t rightmost =\n-    (affiliation == ShenandoahAffiliation::FREE)? _free_sets.rightmost_empty(Collector): _free_sets.rightmost(Collector);\n-  size_t leftmost =\n-    (affiliation == ShenandoahAffiliation::FREE)? _free_sets.leftmost_empty(Collector): _free_sets.leftmost(Collector);\n-  for (size_t c = rightmost + 1; c > leftmost; c--) {\n-    \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n-    size_t idx = c - 1;\n-    if (_free_sets.in_free_set(idx, Collector)) {\n+  idx_t rightmost_collector = ((affiliation == ShenandoahAffiliation::FREE)?\n+                               _partitions.rightmost_empty(which_partition): _partitions.rightmost(which_partition));\n+  idx_t leftmost_collector = ((affiliation == ShenandoahAffiliation::FREE)?\n+                              _partitions.leftmost_empty(which_partition): _partitions.leftmost(which_partition));\n+  if (_partitions.alloc_from_left_bias(which_partition)) {\n+    for (idx_t idx = leftmost_collector; idx <= rightmost_collector; ) {\n+      assert(_partitions.in_free_set(which_partition, idx), \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n@@ -490,0 +701,14 @@\n+      idx = _partitions.find_index_of_next_available_region(which_partition, idx + 1);\n+    }\n+  } else {\n+    for (idx_t idx = rightmost_collector; idx >= leftmost_collector; ) {\n+      assert(_partitions.in_free_set(which_partition, idx),\n+             \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n+      ShenandoahHeapRegion* r = _heap->get_region(idx);\n+      if (r->affiliation() == affiliation) {\n+        HeapWord* result = try_allocate_in(r, req, in_new_region);\n+        if (result != nullptr) {\n+          return result;\n+        }\n+      }\n+      idx = _partitions.find_index_of_previous_available_region(which_partition, idx - 1);\n@@ -502,2 +727,1 @@\n-  \/\/ Leftmost and rightmost bounds provide enough caching to walk bitmap efficiently. Normally,\n-  \/\/ we would find the region to allocate at right away.\n+  \/\/ Leftmost and rightmost bounds provide enough caching to quickly find a region from which to allocate.\n@@ -505,3 +729,3 @@\n-  \/\/ Allocations are biased: new application allocs go to beginning of the heap, and GC allocs\n-  \/\/ go to the end. This makes application allocation faster, because we would clear lots\n-  \/\/ of regions from the beginning most of the time.\n+  \/\/ Allocations are biased: GC allocations are taken from the high end of the heap.  Regular (and TLAB)\n+  \/\/ mutator allocations are taken from the middle of heap, below the memory reserved for Collector.\n+  \/\/ Humongous mutator allocations are taken from the bottom of the heap.\n@@ -509,2 +733,3 @@\n-  \/\/ Free set maintains mutator and collector views, and normally they allocate in their views only,\n-  \/\/ unless we special cases for stealing and mixed allocations.\n+  \/\/ Free set maintains mutator and collector partitions.  Mutator can only allocate from the\n+  \/\/ Mutator partition.  Collector prefers to allocate from the Collector partition, but may steal\n+  \/\/ regions from the Mutator partition if the Collector partition has been depleted.\n@@ -543,7 +768,52 @@\n-      \/\/ Allocate within mutator free from high memory to low so as to preserve low memory for humongous allocations\n-      if (!_free_sets.is_empty(Mutator)) {\n-        \/\/ Use signed idx.  Otherwise, loop will never terminate.\n-        int leftmost = (int) _free_sets.leftmost(Mutator);\n-        for (int idx = (int) _free_sets.rightmost(Mutator); idx >= leftmost; idx--) {\n-          ShenandoahHeapRegion* r = _heap->get_region(idx);\n-          if (_free_sets.in_free_set(idx, Mutator) && (allow_new_region || r->is_affiliated())) {\n+      if (_alloc_bias_weight-- <= 0) {\n+        \/\/ We have observed that regions not collected in previous GC cycle tend to congregate at one end or the other\n+        \/\/ of the heap.  Typically, these are the more recently engaged regions and the objects in these regions have not\n+        \/\/ yet had a chance to die (and\/or are treated as floating garbage).  If we use the same allocation bias on each\n+        \/\/ GC pass, these \"most recently\" engaged regions for GC pass N will also be the \"most recently\" engaged regions\n+        \/\/ for GC pass N+1, and the relatively large amount of live data and\/or floating garbage introduced\n+        \/\/ during the most recent GC pass may once again prevent the region from being collected.  We have found that\n+        \/\/ alternating the allocation behavior between GC passes improves evacuation performance by 3-7% on certain\n+        \/\/ benchmarks.  In the best case, this has the effect of consuming these partially consumed regions before\n+        \/\/ the start of the next mark cycle so all of their garbage can be efficiently reclaimed.\n+        \/\/\n+        \/\/ First, finish consuming regions that are already partially consumed so as to more tightly limit ranges of\n+        \/\/ available regions.  Other potential benefits:\n+        \/\/  1. Eventual collection set has fewer regions because we have packed newly allocated objects into fewer regions\n+        \/\/  2. We preserve the \"empty\" regions longer into the GC cycle, reducing likelihood of allocation failures\n+        \/\/     late in the GC cycle.\n+        idx_t non_empty_on_left = (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator)\n+                                     - _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator));\n+        idx_t non_empty_on_right = (_partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator)\n+                                      - _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator));\n+        _partitions.set_bias_from_left_to_right(ShenandoahFreeSetPartitionId::Mutator, (non_empty_on_right < non_empty_on_left));\n+        _alloc_bias_weight = _InitialAllocBiasWeight;\n+      }\n+      if (!_partitions.alloc_from_left_bias(ShenandoahFreeSetPartitionId::Mutator)) {\n+        \/\/ Allocate within mutator free from high memory to low so as to preserve low memory for humongous allocations\n+        if (!_partitions.is_empty(ShenandoahFreeSetPartitionId::Mutator)) {\n+          \/\/ Use signed idx.  Otherwise, loop will never terminate.\n+          idx_t leftmost = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n+          for (idx_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost; ) {\n+            assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n+                   \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n+            ShenandoahHeapRegion* r = _heap->get_region(idx);\n+            \/\/ try_allocate_in() increases used if the allocation is successful.\n+            HeapWord* result;\n+            size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n+            if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n+              return result;\n+            }\n+            idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Mutator, idx - 1);\n+          }\n+        }\n+      } else {\n+        \/\/ Allocate from low to high memory.  This keeps the range of fully empty regions more tightly packed.\n+        \/\/ Note that the most recently allocated regions tend not to be evacuated in a given GC cycle.  So this\n+        \/\/ tends to accumulate \"fragmented\" uncollected regions in high memory.\n+        if (!_partitions.is_empty(ShenandoahFreeSetPartitionId::Mutator)) {\n+          \/\/ Use signed idx.  Otherwise, loop will never terminate.\n+          idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+          for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); idx <= rightmost; ) {\n+            assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n+                   \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n+            ShenandoahHeapRegion* r = _heap->get_region(idx);\n@@ -556,0 +826,1 @@\n+            idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, idx + 1);\n@@ -563,2 +834,1 @@\n-      \/\/ GCLABs are for evacuation so we must be in evacuation phase.  If this allocation is successful, increment\n-      \/\/ the relevant evac_expended rather than used value.\n+      \/\/ GCLABs are for evacuation so we must be in evacuation phase.\n@@ -566,2 +836,3 @@\n-    case ShenandoahAllocRequest::_alloc_plab:\n-      \/\/ PLABs always reside in old-gen and are only allocated during evacuation phase.\n+    case ShenandoahAllocRequest::_alloc_plab: {\n+      \/\/ PLABs always reside in old-gen and are only allocated during\n+      \/\/ evacuation phase.\n@@ -570,20 +841,12 @@\n-      if (!_heap->mode()->is_generational()) {\n-        \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n-        \/\/ Fast-path: try to allocate in the collector view first\n-        for (size_t c = _free_sets.rightmost(Collector) + 1; c > _free_sets.leftmost(Collector); c--) {\n-          size_t idx = c - 1;\n-          if (_free_sets.in_free_set(idx, Collector)) {\n-            HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n-            if (result != nullptr) {\n-              return result;\n-            }\n-          }\n-        }\n-      } else {\n-        \/\/ First try to fit into a region that is already in use in the same generation.\n-        HeapWord* result;\n-        if (req.is_old()) {\n-          result = allocate_old_with_affiliation(req.affiliation(), req, in_new_region);\n-        } else {\n-          result = allocate_with_affiliation(req.affiliation(), req, in_new_region);\n-        }\n+      \/\/ Fast-path: try to allocate in the collector view first\n+      HeapWord* result;\n+      result = allocate_from_partition_with_affiliation(req.is_old()? ShenandoahFreeSetPartitionId::OldCollector:\n+                                                        ShenandoahFreeSetPartitionId::Collector,\n+                                                        req.affiliation(), req, in_new_region);\n+      if (result != nullptr) {\n+        return result;\n+      } else if (allow_new_region) {\n+        \/\/ Try a free region that is dedicated to GC allocations.\n+        result = allocate_from_partition_with_affiliation(req.is_old()? ShenandoahFreeSetPartitionId::OldCollector:\n+                                                          ShenandoahFreeSetPartitionId::Collector,\n+                                                          ShenandoahAffiliation::FREE, req, in_new_region);\n@@ -593,11 +856,0 @@\n-        if (allow_new_region) {\n-          \/\/ Then try a free region that is dedicated to GC allocations.\n-          if (req.is_old()) {\n-            result = allocate_old_with_affiliation(FREE, req, in_new_region);\n-          } else {\n-            result = allocate_with_affiliation(FREE, req, in_new_region);\n-          }\n-          if (result != nullptr) {\n-            return result;\n-          }\n-        }\n@@ -605,0 +857,1 @@\n+\n@@ -609,1 +862,0 @@\n-\n@@ -621,1 +873,1 @@\n-      \/\/ Also TODO:\n+      \/\/ TODO:\n@@ -630,15 +882,11 @@\n-        for (size_t c = _free_sets.rightmost_empty(Mutator) + 1; c > _free_sets.leftmost_empty(Mutator); c--) {\n-          size_t idx = c - 1;\n-          if (_free_sets.in_free_set(idx, Mutator)) {\n-            ShenandoahHeapRegion* r = _heap->get_region(idx);\n-            if (can_allocate_from(r)) {\n-              if (req.is_old()) {\n-                flip_to_old_gc(r);\n-              } else {\n-                flip_to_gc(r);\n-              }\n-              HeapWord *result = try_allocate_in(r, req, in_new_region);\n-              if (result != nullptr) {\n-                log_debug(gc, free)(\"Flipped region \" SIZE_FORMAT \" to gc for request: \" PTR_FORMAT, idx, p2i(&req));\n-                return result;\n-              }\n+        idx_t rightmost_mutator = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n+        idx_t leftmost_mutator =  _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n+        for (idx_t idx = rightmost_mutator; idx >= leftmost_mutator; ) {\n+          assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n+                 \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n+          ShenandoahHeapRegion* r = _heap->get_region(idx);\n+          if (can_allocate_from(r)) {\n+            if (req.is_old()) {\n+              flip_to_old_gc(r);\n+            } else {\n+              flip_to_gc(r);\n@@ -646,0 +894,4 @@\n+            \/\/ Region r is entirely empty.  If try_allocat_in fails on region r, something else is really wrong.\n+            \/\/ Don't bother to retry with other regions.\n+            log_debug(gc, free)(\"Flipped region \" SIZE_FORMAT \" to gc for request: \" PTR_FORMAT, idx, p2i(&req));\n+            return try_allocate_in(r, req, in_new_region);\n@@ -647,0 +899,1 @@\n+          idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Mutator, idx - 1);\n@@ -649,4 +902,2 @@\n-\n-      \/\/ No dice. Do not try to mix mutator and GC allocations, because\n-      \/\/ URWM moves due to GC allocations would expose unparsable mutator\n-      \/\/ allocations.\n+      \/\/ No dice. Do not try to mix mutator and GC allocations, because adjusting region UWM\n+      \/\/ due to GC allocations would expose unparsable mutator allocations.\n@@ -655,0 +906,1 @@\n+    }\n@@ -673,1 +925,1 @@\n-size_t get_usable_free_words(size_t free_bytes) {\n+size_t ShenandoahFreeSet::get_usable_free_words(size_t free_bytes) const {\n@@ -707,1 +959,0 @@\n-  assert(req.actual_size() == size, \"Should not have needed to adjust size for PLAB.\");\n@@ -709,1 +960,0 @@\n-\n@@ -718,0 +968,4 @@\n+  HeapWord* result = nullptr;\n+  bool is_generational = _heap->mode()->is_generational();\n+  try_recycle_trashed(r, is_generational);\n+  in_new_region = r->is_empty();\n@@ -719,3 +973,4 @@\n-  try_recycle_trashed(r);\n-  if (!r->is_affiliated()) {\n-    ShenandoahMarkingContext* const ctx = _heap->complete_marking_context();\n+  if (in_new_region) {\n+    log_debug(gc)(\"Using new region (\" SIZE_FORMAT \") for %s (\" PTR_FORMAT \").\",\n+                       r->index(), ShenandoahAllocRequest::alloc_type_to_string(req.type()), p2i(&req));\n+    assert(!r->is_affiliated(), \"New region \" SIZE_FORMAT \" should be unaffiliated\", r->index());\n@@ -723,0 +978,1 @@\n+    ShenandoahMarkingContext* const ctx = _heap->complete_marking_context();\n@@ -731,0 +987,1 @@\n+\n@@ -736,1 +993,0 @@\n-\n@@ -739,8 +995,0 @@\n-  } else if (r->affiliation() != req.affiliation()) {\n-    assert(_heap->mode()->is_generational(), \"Request for %s from %s region should only happen in generational mode.\",\n-           req.affiliation_name(), r->affiliation_name());\n-    return nullptr;\n-  }\n-\n-  in_new_region = r->is_empty();\n-  HeapWord* result = nullptr;\n@@ -748,2 +996,1 @@\n-  if (in_new_region) {\n-    log_debug(gc, free)(\"Using new region (\" SIZE_FORMAT \") for %s (\" PTR_FORMAT \").\",\n+    log_debug(gc)(\"Using new region (\" SIZE_FORMAT \") for %s (\" PTR_FORMAT \").\",\n@@ -751,0 +998,7 @@\n+  } else {\n+    assert(r->is_affiliated(), \"Region \" SIZE_FORMAT \" that is not new should be affiliated\", r->index());\n+    if (r->affiliation() != req.affiliation()) {\n+      assert(is_generational, \"Request for %s from %s region should only happen in generational mode.\",\n+             req.affiliation_name(), r->affiliation_name());\n+      return nullptr;\n+    }\n@@ -755,0 +1009,2 @@\n+    size_t adjusted_size = req.size();\n+    size_t free = r->free();    \/\/ free represents bytes available within region r\n@@ -756,9 +1012,8 @@\n-      assert(_heap->mode()->is_generational(), \"PLABs are only for generational mode\");\n-      assert(_free_sets.in_free_set(r->index(), OldCollector), \"PLABS must be allocated in old_collector_free regions\");\n-      \/\/ Need to assure that plabs are aligned on multiple of card region.\n-      \/\/ Since we have Elastic TLABs, align sizes up. They may be decreased to fit in the usable\n-      \/\/ memory remaining in the region (which will also be aligned to cards).\n-      size_t adjusted_size = align_up(req.size(), CardTable::card_size_in_words());\n-      size_t adjusted_min_size = align_up(req.min_size(), CardTable::card_size_in_words());\n-      size_t usable_free = get_usable_free_words(r->free());\n-\n+      \/\/ This is a PLAB allocation\n+      assert(is_generational, \"PLABs are only for generational mode\");\n+      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, r->index()),\n+             \"PLABS must be allocated in old_collector_free regions\");\n+\n+      \/\/ Need to assure that plabs are aligned on multiple of card region\n+      \/\/ Convert free from unaligned bytes to aligned number of words\n+      size_t usable_free = get_usable_free_words(free);\n@@ -768,2 +1023,2 @@\n-\n-      if (adjusted_size >= adjusted_min_size) {\n+      adjusted_size = align_down(adjusted_size, CardTable::card_size_in_words());\n+      if (adjusted_size >= req.min_size()) {\n@@ -771,0 +1026,6 @@\n+        assert(result != nullptr, \"allocate must succeed\");\n+        req.set_actual_size(adjusted_size);\n+      } else {\n+        \/\/ Otherwise, leave result == nullptr because the adjusted size is smaller than min size.\n+        log_trace(gc, free)(\"Failed to shrink PLAB request (\" SIZE_FORMAT \") in region \" SIZE_FORMAT \" to \" SIZE_FORMAT\n+                            \" because min_size() is \" SIZE_FORMAT, req.size(), r->index(), adjusted_size, req.min_size());\n@@ -772,1 +1033,0 @@\n-      \/\/ Otherwise, leave result == nullptr because the adjusted size is smaller than min size.\n@@ -775,2 +1035,2 @@\n-      size_t adjusted_size = req.size();\n-      size_t free = align_down(r->free() >> LogHeapWordSize, MinObjAlignment);\n+      \/\/ Convert free from unaligned bytes to aligned number of words\n+      free = align_down(free >> LogHeapWordSize, MinObjAlignment);\n@@ -786,1 +1046,1 @@\n-                           \" because min_size() is \" SIZE_FORMAT, req.size(), r->index(), adjusted_size, req.min_size());\n+                            \" because min_size() is \" SIZE_FORMAT, req.size(), r->index(), adjusted_size, req.min_size());\n@@ -798,1 +1058,0 @@\n-  ShenandoahGeneration* generation = _heap->generation_for(req.affiliation());\n@@ -803,1 +1062,1 @@\n-      _free_sets.increase_used(Mutator, req.actual_size() * HeapWordSize);\n+      _partitions.increase_used(ShenandoahFreeSetPartitionId::Mutator, req.actual_size() * HeapWordSize);\n@@ -816,0 +1075,1 @@\n+        _partitions.increase_used(ShenandoahFreeSetPartitionId::OldCollector, req.actual_size() * HeapWordSize);\n@@ -818,0 +1078,2 @@\n+      } else {\n+        _partitions.increase_used(ShenandoahFreeSetPartitionId::Collector, req.actual_size() * HeapWordSize);\n@@ -822,6 +1084,9 @@\n-  if (result == nullptr || alloc_capacity(r) < PLAB::min_size() * HeapWordSize) {\n-    \/\/ Region cannot afford this and is likely to not afford future allocations. Retire it.\n-    \/\/\n-    \/\/ While this seems a bit harsh, especially in the case when this large allocation does not\n-    \/\/ fit but the next small one would, we are risking to inflate scan times when lots of\n-    \/\/ almost-full regions precede the fully-empty region where we want to allocate the entire TLAB.\n+  static const size_t min_capacity = (size_t) (ShenandoahHeapRegion::region_size_bytes() * (1.0 - 1.0 \/ ShenandoahEvacWaste));\n+  size_t ac = alloc_capacity(r);\n+\n+  if (((result == nullptr) && (ac < min_capacity)) || (alloc_capacity(r) < PLAB::min_size() * HeapWordSize)) {\n+    \/\/ Regardless of whether this allocation succeeded, if the remaining memory is less than PLAB:min_size(), retire this region.\n+    \/\/ Note that retire_from_partition() increases used to account for waste.\n+\n+    \/\/ Also, if this allocation request failed and the consumed within this region * ShenandoahEvacWaste > region size,\n+    \/\/ then retire the region so that subsequent searches can find available memory more quickly.\n@@ -829,1 +1094,0 @@\n-    \/\/ Record the remainder as allocation waste\n@@ -831,0 +1095,1 @@\n+    ShenandoahFreeSetPartitionId orig_partition;\n@@ -832,7 +1097,5 @@\n-      size_t waste = r->free();\n-      if (waste > 0) {\n-        _free_sets.increase_used(Mutator, waste);\n-        \/\/ This one request could cause several regions to be \"retired\", so we must accumulate the waste\n-        req.set_waste((waste >> LogHeapWordSize) + req.waste());\n-      }\n-      assert(_free_sets.membership(idx) == Mutator, \"Must be mutator free: \" SIZE_FORMAT, idx);\n+      orig_partition = ShenandoahFreeSetPartitionId::Mutator;\n+    } else if (req.type() == ShenandoahAllocRequest::_alloc_gclab) {\n+      orig_partition = ShenandoahFreeSetPartitionId::Collector;\n+    } else if (req.type() == ShenandoahAllocRequest::_alloc_plab) {\n+      orig_partition = ShenandoahFreeSetPartitionId::OldCollector;\n@@ -840,2 +1103,6 @@\n-      assert(_free_sets.membership(idx) == Collector || _free_sets.membership(idx) == OldCollector,\n-             \"Must be collector or old-collector free: \" SIZE_FORMAT, idx);\n+      assert(req.type() == ShenandoahAllocRequest::_alloc_shared_gc, \"Unexpected allocation type\");\n+      if (req.is_old()) {\n+        orig_partition = ShenandoahFreeSetPartitionId::OldCollector;\n+      } else {\n+        orig_partition = ShenandoahFreeSetPartitionId::Collector;\n+      }\n@@ -843,3 +1110,2 @@\n-    \/\/ This region is no longer considered free (in any set)\n-    _free_sets.remove_from_free_sets(idx);\n-    _free_sets.assert_bounds();\n+    _partitions.retire_from_partition(orig_partition, idx, r->used());\n+    _partitions.assert_bounds();\n@@ -851,0 +1117,1 @@\n+  assert(req.is_mutator_alloc(), \"All humongous allocations are performed by mutator\");\n@@ -854,1 +1121,1 @@\n-  size_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);\n+  idx_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);\n@@ -857,1 +1124,0 @@\n-  ShenandoahGeneration* generation = _heap->generation_for(req.affiliation());\n@@ -860,9 +1126,2 @@\n-  if (_heap->mode()->is_generational()) {\n-    size_t avail_young_regions = generation->free_unaffiliated_regions();\n-    if (num > _free_sets.count(Mutator) || (num > avail_young_regions)) {\n-      return nullptr;\n-    }\n-  } else {\n-    if (num > _free_sets.count(Mutator)) {\n-      return nullptr;\n-    }\n+  if (num > (idx_t) _partitions.count(ShenandoahFreeSetPartitionId::Mutator)) {\n+    return nullptr;\n@@ -871,0 +1130,4 @@\n+  idx_t start_range = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n+  idx_t end_range = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator) + 1;\n+  idx_t last_possible_start = end_range - num;\n+\n@@ -873,3 +1136,7 @@\n-\n-  size_t beg = _free_sets.leftmost(Mutator);\n-  size_t end = beg;\n+  idx_t beg = _partitions.find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId::Mutator,\n+                                                                          start_range, num);\n+  if (beg > last_possible_start) {\n+    \/\/ Hit the end, goodbye\n+    return nullptr;\n+  }\n+  idx_t end = beg;\n@@ -878,11 +1145,26 @@\n-    if (end >= _free_sets.max()) {\n-      \/\/ Hit the end, goodbye\n-      return nullptr;\n-    }\n-\n-    \/\/ If regions are not adjacent, then current [beg; end] is useless, and we may fast-forward.\n-    \/\/ If region is not completely free, the current [beg; end] is useless, and we may fast-forward.\n-    if (!_free_sets.in_free_set(end, Mutator) || !can_allocate_from(_heap->get_region(end))) {\n-      end++;\n-      beg = end;\n-      continue;\n+    \/\/ We've confirmed num contiguous regions belonging to Mutator partition, so no need to confirm membership.\n+    \/\/ If region is not completely free, the current [beg; end] is useless, and we may fast-forward.  If we can extend\n+    \/\/ the existing range, we can exploit that certain regions are already known to be in the Mutator free set.\n+    while (!can_allocate_from(_heap->get_region(end))) {\n+      \/\/ region[end] is not empty, so we restart our search after region[end]\n+      idx_t slide_delta = end + 1 - beg;\n+      if (beg + slide_delta > last_possible_start) {\n+        \/\/ no room to slide\n+        return nullptr;\n+      }\n+      for (idx_t span_end = beg + num; slide_delta > 0; slide_delta--) {\n+        if (!_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, span_end)) {\n+          beg = _partitions.find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId::Mutator,\n+                                                                            span_end + 1, num);\n+          break;\n+        } else {\n+          beg++;\n+          span_end++;\n+        }\n+      }\n+      \/\/ Here, either beg identifies a range of num regions all of which are in the Mutator free set, or beg > last_possible_start\n+      if (beg > last_possible_start) {\n+        \/\/ Hit the end, goodbye\n+        return nullptr;\n+      }\n+      end = beg;\n@@ -902,0 +1184,1 @@\n+  bool is_generational = _heap->mode()->is_generational();\n@@ -903,1 +1186,1 @@\n-  for (size_t i = beg; i <= end; i++) {\n+  for (idx_t i = beg; i <= end; i++) {\n@@ -905,1 +1188,1 @@\n-    try_recycle_trashed(r);\n+    try_recycle_trashed(r, is_generational);\n@@ -927,3 +1210,0 @@\n-\n-    \/\/ While individual regions report their true use, all humongous regions are marked used in the free set.\n-    _free_sets.remove_from_free_sets(r->index());\n@@ -932,0 +1212,7 @@\n+  if (remainder != 0) {\n+    \/\/ Record this remainder as allocation waste\n+    _heap->notify_mutator_alloc_words(ShenandoahHeapRegion::region_size_words() - remainder, true);\n+  }\n+\n+  \/\/ retire_range_from_partition() will adjust bounds on Mutator free set if appropriate\n+  _partitions.retire_range_from_partition(ShenandoahFreeSetPartitionId::Mutator, beg, end);\n@@ -934,2 +1221,2 @@\n-  _free_sets.increase_used(Mutator, total_humongous_size);\n-  _free_sets.assert_bounds();\n+  _partitions.increase_used(ShenandoahFreeSetPartitionId::Mutator, total_humongous_size);\n+  _partitions.assert_bounds();\n@@ -943,31 +1230,1 @@\n-\/\/ Returns true iff this region is entirely available, either because it is empty() or because it has been found to represent\n-\/\/ immediate trash and we'll be able to immediately recycle it.  Note that we cannot recycle immediate trash if\n-\/\/ concurrent weak root processing is in progress.\n-bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) const {\n-  return r->is_empty() || (r->is_trash() && !_heap->is_concurrent_weak_root_in_progress());\n-}\n-\n-bool ShenandoahFreeSet::can_allocate_from(size_t idx) const {\n-  ShenandoahHeapRegion* r = _heap->get_region(idx);\n-  return can_allocate_from(r);\n-}\n-\n-size_t ShenandoahFreeSet::alloc_capacity(size_t idx) const {\n-  ShenandoahHeapRegion* r = _heap->get_region(idx);\n-  return alloc_capacity(r);\n-}\n-\n-size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) const {\n-  if (r->is_trash()) {\n-    \/\/ This would be recycled on allocation path\n-    return ShenandoahHeapRegion::region_size_bytes();\n-  } else {\n-    return r->free();\n-  }\n-}\n-\n-bool ShenandoahFreeSet::has_alloc_capacity(ShenandoahHeapRegion *r) const {\n-  return alloc_capacity(r) > 0;\n-}\n-\n-void ShenandoahFreeSet::try_recycle_trashed(ShenandoahHeapRegion *r) {\n+void ShenandoahFreeSet::try_recycle_trashed(ShenandoahHeapRegion *r, bool is_generational) {\n@@ -982,1 +1239,1 @@\n-\n+  bool is_generational = _heap->mode()->is_generational();\n@@ -987,1 +1244,1 @@\n-      try_recycle_trashed(r);\n+      try_recycle_trashed(r, is_generational);\n@@ -996,2 +1253,1 @@\n-  assert(_free_sets.in_free_set(idx, Mutator), \"Should be in mutator view\");\n-  \/\/ Note: can_allocate_from(r) means r is entirely empty\n+  assert(_partitions.partition_id_matches(idx, ShenandoahFreeSetPartitionId::Mutator), \"Should be in mutator view\");\n@@ -1000,4 +1256,5 @@\n-  size_t region_capacity = alloc_capacity(r);\n-  _free_sets.move_to_set(idx, OldCollector, region_capacity);\n-  _free_sets.assert_bounds();\n-  _heap->old_generation()->augment_evacuation_reserve(region_capacity);\n+  size_t ac = alloc_capacity(r);\n+  _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                               ShenandoahFreeSetPartitionId::OldCollector, ac);\n+  _partitions.assert_bounds();\n+  _heap->old_generation()->augment_evacuation_reserve(ac);\n@@ -1016,1 +1273,1 @@\n-  assert(_free_sets.in_free_set(idx, Mutator), \"Should be in mutator view\");\n+  assert(_partitions.partition_id_matches(idx, ShenandoahFreeSetPartitionId::Mutator), \"Should be in mutator view\");\n@@ -1019,3 +1276,4 @@\n-  size_t region_capacity = alloc_capacity(r);\n-  _free_sets.move_to_set(idx, Collector, region_capacity);\n-  _free_sets.assert_bounds();\n+  size_t ac = alloc_capacity(r);\n+  _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                               ShenandoahFreeSetPartitionId::Collector, ac);\n+  _partitions.assert_bounds();\n@@ -1033,1 +1291,6 @@\n-  _free_sets.clear_all();\n+  _partitions.make_all_regions_unavailable();\n+\n+  _alloc_bias_weight = 0;\n+  _partitions.set_bias_from_left_to_right(ShenandoahFreeSetPartitionId::Mutator, true);\n+  _partitions.set_bias_from_left_to_right(ShenandoahFreeSetPartitionId::Collector, false);\n+  _partitions.set_bias_from_left_to_right(ShenandoahFreeSetPartitionId::OldCollector, false);\n@@ -1036,5 +1299,0 @@\n-\/\/ This function places all is_old() regions that have allocation capacity into the old_collector set.  It places\n-\/\/ all other regions (not is_old()) that have allocation capacity into the mutator_set.  Subsequently, we will\n-\/\/ move some of the mutator regions into the collector set or old_collector set with the intent of packing\n-\/\/ old_collector memory into the highest (rightmost) addresses of the heap and the collector memory into the\n-\/\/ next highest addresses of the heap, with mutator memory consuming the lowest addresses of the heap.\n@@ -1044,0 +1302,2 @@\n+  clear_internal();\n+\n@@ -1049,0 +1309,18 @@\n+\n+  size_t region_size_bytes = _partitions.region_size_bytes();\n+  size_t max_regions = _partitions.max_regions();\n+\n+  size_t mutator_leftmost = max_regions;\n+  size_t mutator_rightmost = 0;\n+  size_t mutator_leftmost_empty = max_regions;\n+  size_t mutator_rightmost_empty = 0;\n+  size_t mutator_regions = 0;\n+  size_t mutator_used = 0;\n+\n+  size_t old_collector_leftmost = max_regions;\n+  size_t old_collector_rightmost = 0;\n+  size_t old_collector_leftmost_empty = max_regions;\n+  size_t old_collector_rightmost_empty = 0;\n+  size_t old_collector_regions = 0;\n+  size_t old_collector_used = 0;\n+\n@@ -1052,1 +1330,2 @@\n-      \/\/ Trashed regions represent regions that had been in the collection set but have not yet been \"cleaned up\".\n+      \/\/ Trashed regions represent regions that had been in the collection partition but have not yet been \"cleaned up\".\n+      \/\/ The cset regions are not \"trashed\" until we have finished update refs.\n@@ -1059,1 +1338,2 @@\n-    } else if (region->is_old() && region->is_regular()) {\n+    } else if (region->is_old()) {\n+      \/\/ count both humongous and regular regions, but don't count trash (cset) regions.\n@@ -1068,1 +1348,0 @@\n-      assert(_free_sets.in_free_set(idx, NotFree), \"We are about to make region free; it should not be free already\");\n@@ -1070,15 +1349,40 @@\n-      \/\/ Do not add regions that would almost surely fail allocation.  Note that PLAB::min_size() is typically less than ShenandoahGenerationalHeap::plab_min_size()\n-      if (alloc_capacity(region) < PLAB::min_size() * HeapWordSize) continue;\n-\n-      if (region->is_old()) {\n-        _free_sets.make_free(idx, OldCollector, alloc_capacity(region));\n-        log_debug(gc, free)(\n-          \"  Adding Region \" SIZE_FORMAT  \" (Free: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s) to old collector set\",\n-          idx, byte_size_in_proper_unit(region->free()), proper_unit_for_byte_size(region->free()),\n-          byte_size_in_proper_unit(region->used()), proper_unit_for_byte_size(region->used()));\n-      } else {\n-        _free_sets.make_free(idx, Mutator, alloc_capacity(region));\n-        log_debug(gc, free)(\n-          \"  Adding Region \" SIZE_FORMAT \" (Free: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s) to mutator set\",\n-          idx, byte_size_in_proper_unit(region->free()), proper_unit_for_byte_size(region->free()),\n-          byte_size_in_proper_unit(region->used()), proper_unit_for_byte_size(region->used()));\n+      \/\/ Do not add regions that would almost surely fail allocation\n+      size_t ac = alloc_capacity(region);\n+      if (ac > PLAB::min_size() * HeapWordSize) {\n+        if (region->is_old()) {\n+          _partitions.raw_assign_membership(idx, ShenandoahFreeSetPartitionId::OldCollector);\n+          if (idx < old_collector_leftmost) {\n+            old_collector_leftmost = idx;\n+          }\n+          if (idx > old_collector_rightmost) {\n+            old_collector_rightmost = idx;\n+          }\n+          if (ac == region_size_bytes) {\n+            if (idx < old_collector_leftmost_empty) {\n+              old_collector_leftmost_empty = idx;\n+            }\n+            if (idx > old_collector_rightmost_empty) {\n+              old_collector_rightmost_empty = idx;\n+            }\n+          }\n+          old_collector_regions++;\n+          old_collector_used += (region_size_bytes - ac);\n+        } else {\n+          _partitions.raw_assign_membership(idx, ShenandoahFreeSetPartitionId::Mutator);\n+          if (idx < mutator_leftmost) {\n+            mutator_leftmost = idx;\n+          }\n+          if (idx > mutator_rightmost) {\n+            mutator_rightmost = idx;\n+          }\n+          if (ac == region_size_bytes) {\n+            if (idx < mutator_leftmost_empty) {\n+              mutator_leftmost_empty = idx;\n+            }\n+            if (idx > mutator_rightmost_empty) {\n+              mutator_rightmost_empty = idx;\n+            }\n+          }\n+          mutator_regions++;\n+          mutator_used += (region_size_bytes - ac);\n+        }\n@@ -1088,0 +1392,28 @@\n+  log_debug(gc)(\"  At end of prep_to_rebuild, mutator_leftmost: \" SIZE_FORMAT\n+                \", mutator_rightmost: \" SIZE_FORMAT\n+                \", mutator_leftmost_empty: \" SIZE_FORMAT\n+                \", mutator_rightmost_empty: \" SIZE_FORMAT\n+                \", mutator_regions: \" SIZE_FORMAT\n+                \", mutator_used: \" SIZE_FORMAT,\n+                mutator_leftmost, mutator_rightmost, mutator_leftmost_empty, mutator_rightmost_empty,\n+                mutator_regions, mutator_used);\n+\n+  log_debug(gc)(\"  old_collector_leftmost: \" SIZE_FORMAT\n+                \", old_collector_rightmost: \" SIZE_FORMAT\n+                \", old_collector_leftmost_empty: \" SIZE_FORMAT\n+                \", old_collector_rightmost_empty: \" SIZE_FORMAT\n+                \", old_collector_regions: \" SIZE_FORMAT\n+                \", old_collector_used: \" SIZE_FORMAT,\n+                old_collector_leftmost, old_collector_rightmost, old_collector_leftmost_empty, old_collector_rightmost_empty,\n+                old_collector_regions, old_collector_used);\n+\n+  _partitions.establish_mutator_intervals(mutator_leftmost, mutator_rightmost, mutator_leftmost_empty, mutator_rightmost_empty,\n+                                          mutator_regions, mutator_used);\n+  _partitions.establish_old_collector_intervals(old_collector_leftmost, old_collector_rightmost, old_collector_leftmost_empty,\n+                                                old_collector_rightmost_empty, old_collector_regions, old_collector_used);\n+  log_debug(gc)(\"  After find_regions_with_alloc_capacity(), Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"],\"\n+                \"  Old Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+                _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+                _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+                _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n@@ -1090,3 +1422,1 @@\n-\/\/ Move no more than cset_regions from the existing Collector and OldCollector free sets to the Mutator free set.\n-\/\/ This is called from outside the heap lock.\n-void ShenandoahFreeSet::move_collector_sets_to_mutator(size_t max_xfer_regions) {\n+void ShenandoahFreeSet::move_regions_from_collector_to_mutator(size_t max_xfer_regions) {\n@@ -1098,2 +1428,4 @@\n-  \/\/ Process empty regions within the Collector free set\n-  if ((max_xfer_regions > 0) && (_free_sets.leftmost_empty(Collector) <= _free_sets.rightmost_empty(Collector))) {\n+  \/\/ Process empty regions within the Collector free partition\n+  if ((max_xfer_regions > 0) &&\n+      (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Collector)\n+       <= _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Collector))) {\n@@ -1101,4 +1433,9 @@\n-    for (size_t idx = _free_sets.leftmost_empty(Collector);\n-         (max_xfer_regions > 0) && (idx <= _free_sets.rightmost_empty(Collector)); idx++) {\n-      if (_free_sets.in_free_set(idx, Collector) && can_allocate_from(idx)) {\n-        _free_sets.move_to_set(idx, Mutator, region_size_bytes);\n+    idx_t rightmost = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Collector);\n+    for (idx_t idx = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Collector);\n+         (max_xfer_regions > 0) && (idx <= rightmost); ) {\n+      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx),\n+             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n+      \/\/ Note: can_allocate_from() denotes that region is entirely empty\n+      if (can_allocate_from(idx)) {\n+        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Collector,\n+                                                     ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n@@ -1108,0 +1445,1 @@\n+      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n@@ -1111,3 +1449,4 @@\n-  \/\/ Process empty regions within the OldCollector free set\n-  size_t old_collector_regions = 0;\n-  if ((max_xfer_regions > 0) && (_free_sets.leftmost_empty(OldCollector) <= _free_sets.rightmost_empty(OldCollector))) {\n+  \/\/ Process empty regions within the OldCollector free partition\n+  if ((max_xfer_regions > 0) &&\n+      (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::OldCollector)\n+       <= _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::OldCollector))) {\n@@ -1115,4 +1454,10 @@\n-    for (size_t idx = _free_sets.leftmost_empty(OldCollector);\n-         (max_xfer_regions > 0) && (idx <= _free_sets.rightmost_empty(OldCollector)); idx++) {\n-      if (_free_sets.in_free_set(idx, OldCollector) && can_allocate_from(idx)) {\n-        _free_sets.move_to_set(idx, Mutator, region_size_bytes);\n+    size_t old_collector_regions = 0;\n+    idx_t rightmost = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::OldCollector);\n+    for (idx_t idx = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::OldCollector);\n+         (max_xfer_regions > 0) && (idx <= rightmost); ) {\n+      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, idx),\n+             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n+      \/\/ Note: can_allocate_from() denotes that region is entirely empty\n+      if (can_allocate_from(idx)) {\n+        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::OldCollector,\n+                                                     ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n@@ -1120,1 +1465,0 @@\n-        old_collector_empty_xfer += region_size_bytes;\n@@ -1122,0 +1466,1 @@\n+        old_collector_empty_xfer += region_size_bytes;\n@@ -1123,0 +1468,1 @@\n+      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::OldCollector, idx + 1);\n@@ -1129,2 +1475,3 @@\n-  \/\/ If there are any non-empty regions within Collector set, we can also move them to the Mutator free set\n-  if ((max_xfer_regions > 0) && (_free_sets.leftmost(Collector) <= _free_sets.rightmost(Collector))) {\n+  \/\/ If there are any non-empty regions within Collector partition, we can also move them to the Mutator free partition\n+  if ((max_xfer_regions > 0) && (_partitions.leftmost(ShenandoahFreeSetPartitionId::Collector)\n+                                 <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector))) {\n@@ -1132,4 +1479,9 @@\n-    for (size_t idx = _free_sets.leftmost(Collector); (max_xfer_regions > 0) && (idx <= _free_sets.rightmost(Collector)); idx++) {\n-      size_t alloc_capacity = this->alloc_capacity(idx);\n-      if (_free_sets.in_free_set(idx, Collector) && (alloc_capacity > 0)) {\n-        _free_sets.move_to_set(idx, Mutator, alloc_capacity);\n+    idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n+    for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n+         (max_xfer_regions > 0) && (idx <= rightmost); ) {\n+      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx),\n+             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n+      size_t ac = alloc_capacity(idx);\n+      if (ac > 0) {\n+        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Collector,\n+                                                     ShenandoahFreeSetPartitionId::Mutator, ac);\n@@ -1137,1 +1489,1 @@\n-        collector_not_empty_xfer += alloc_capacity;\n+        collector_not_empty_xfer += ac;\n@@ -1139,0 +1491,1 @@\n+      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n@@ -1165,1 +1518,15 @@\n-void ShenandoahFreeSet::rebuild(size_t young_cset_regions, size_t old_cset_regions, bool have_evacuation_reserves) {\n+void ShenandoahFreeSet::establish_generation_sizes(size_t young_region_count, size_t old_region_count) {\n+  assert(young_region_count + old_region_count == ShenandoahHeap::heap()->num_regions(), \"Sanity\");\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+    ShenandoahOldGeneration* old_gen = heap->old_generation();\n+    ShenandoahYoungGeneration* young_gen = heap->young_generation();\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+    old_gen->establish_capacity(old_region_count * region_size_bytes);\n+    young_gen->establish_capacity(young_region_count * region_size_bytes);\n+  }\n+}\n+\n+void ShenandoahFreeSet::finish_rebuild(size_t young_cset_regions, size_t old_cset_regions, size_t old_region_count,\n+                                       bool have_evacuation_reserves) {\n@@ -1169,4 +1536,1 @@\n-  if (!_heap->mode()->is_generational()) {\n-    young_reserve = (_heap->max_capacity() \/ 100) * ShenandoahEvacReserve;\n-    old_reserve = 0;\n-  } else {\n+  if (_heap->mode()->is_generational()) {\n@@ -1175,1 +1539,3 @@\n-\n+  } else {\n+    young_reserve = (_heap->max_capacity() \/ 100) * ShenandoahEvacReserve;\n+    old_reserve = 0;\n@@ -1178,3 +1544,5 @@\n-  reserve_regions(young_reserve, old_reserve);\n-  _free_sets.establish_alloc_bias(OldCollector);\n-  _free_sets.assert_bounds();\n+  reserve_regions(young_reserve, old_reserve, old_region_count);\n+  size_t young_region_count = _heap->num_regions() - (old_region_count + old_cset_regions);\n+  establish_generation_sizes(young_region_count, old_region_count + old_cset_regions);\n+  establish_old_collector_alloc_bias();\n+  _partitions.assert_bounds();\n@@ -1184,1 +1552,2 @@\n-void ShenandoahFreeSet::compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions, bool have_evacuation_reserves,\n+void ShenandoahFreeSet::compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions,\n+                                                       bool have_evacuation_reserves,\n@@ -1243,2 +1612,4 @@\n-  if (old_reserve_result > _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes) {\n-    old_reserve_result = _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes;\n+  if (old_reserve_result >\n+      _partitions.capacity_of(ShenandoahFreeSetPartitionId::OldCollector) + old_unaffiliated_regions * region_size_bytes) {\n+    old_reserve_result =\n+      _partitions.capacity_of(ShenandoahFreeSetPartitionId::OldCollector) + old_unaffiliated_regions * region_size_bytes;\n@@ -1255,1 +1626,1 @@\n-\/\/ the collector set is at least to_reserve, and the memory available for allocations within the old collector set\n+\/\/ the collector set is at least to_reserve and the memory available for allocations within the old collector set\n@@ -1257,1 +1628,1 @@\n-void ShenandoahFreeSet::reserve_regions(size_t to_reserve, size_t to_reserve_old) {\n+void ShenandoahFreeSet::reserve_regions(size_t to_reserve, size_t to_reserve_old, size_t &old_region_count) {\n@@ -1261,1 +1632,1 @@\n-    if (!_free_sets.in_free_set(idx, Mutator)) {\n+    if (!_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx)) {\n@@ -1269,2 +1640,2 @@\n-    bool move_to_old = _free_sets.capacity_of(OldCollector) < to_reserve_old;\n-    bool move_to_young = _free_sets.capacity_of(Collector) < to_reserve;\n+    bool move_to_old_collector = _partitions.capacity_of(ShenandoahFreeSetPartitionId::OldCollector) < to_reserve_old;\n+    bool move_to_collector = _partitions.capacity_of(ShenandoahFreeSetPartitionId::Collector) < to_reserve;\n@@ -1272,1 +1643,1 @@\n-    if (!move_to_old && !move_to_young) {\n+    if (!move_to_collector && !move_to_old_collector) {\n@@ -1277,1 +1648,1 @@\n-    if (move_to_old) {\n+    if (move_to_old_collector) {\n@@ -1280,2 +1651,10 @@\n-        _free_sets.move_to_set(idx, OldCollector, ac);\n-        log_debug(gc, free)(\"  Shifting region \" SIZE_FORMAT \" from mutator_free to old_collector_free\", idx);\n+        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                                     ShenandoahFreeSetPartitionId::OldCollector, ac);\n+        log_debug(gc)(\"  Shifting region \" SIZE_FORMAT \" from mutator_free to old_collector_free\", idx);\n+        log_debug(gc)(\"  Shifted Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"],\"\n+                      \"  Old Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+                      _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+                      _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+                      _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                      _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n+        old_region_count++;\n@@ -1286,1 +1665,1 @@\n-    if (move_to_young) {\n+    if (move_to_collector) {\n@@ -1288,4 +1667,9 @@\n-      \/\/ they were entirely empty.  I'm not sure I understand the rationale for that.  That alternative behavior would\n-      \/\/ tend to mix survivor objects with ephemeral objects, making it more difficult to reclaim the memory for the\n-      \/\/ ephemeral objects.  It also delays aging of regions, causing promotion in place to be delayed.\n-      _free_sets.move_to_set(idx, Collector, ac);\n+      \/\/ they were entirely empty.  This has the effect of causing new Mutator allocation to reside next to objects\n+      \/\/ that have already survived at least one GC, mixing ephemeral with longer-lived objects in the same region.\n+      \/\/ Any objects that have survived a GC are less likely to immediately become garbage, so a region that contains\n+      \/\/ survivor objects is less likely to be selected for the collection set.  This alternative implementation allows\n+      \/\/ survivor regions to continue accumulating other survivor objects, and makes it more likely that ephemeral objects\n+      \/\/ occupy regions comprised entirely of ephemeral objects.  These regions are highly likely to be included in the next\n+      \/\/ collection set, and they are easily evacuated because they have low density of live objects.\n+      _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                                   ShenandoahFreeSetPartitionId::Collector, ac);\n@@ -1293,0 +1677,6 @@\n+      log_debug(gc)(\"  Shifted Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"],\"\n+                    \"  Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+                    _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+                    _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+                    _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector),\n+                    _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector));\n@@ -1297,1 +1687,1 @@\n-    size_t old_reserve = _free_sets.capacity_of(OldCollector);\n+    size_t old_reserve = _partitions.capacity_of(ShenandoahFreeSetPartitionId::OldCollector);\n@@ -1302,4 +1692,28 @@\n-    size_t young_reserve = _free_sets.capacity_of(Collector);\n-    if (young_reserve < to_reserve) {\n-      log_info(gc, free)(\"Wanted \" PROPERFMT \" for young reserve, but only reserved: \" PROPERFMT,\n-                         PROPERFMTARGS(to_reserve), PROPERFMTARGS(young_reserve));\n+    size_t reserve = _partitions.capacity_of(ShenandoahFreeSetPartitionId::Collector);\n+    if (reserve < to_reserve) {\n+      log_debug(gc)(\"Wanted \" PROPERFMT \" for young reserve, but only reserved: \" PROPERFMT,\n+                    PROPERFMTARGS(to_reserve), PROPERFMTARGS(reserve));\n+    }\n+  }\n+}\n+\n+void ShenandoahFreeSet::establish_old_collector_alloc_bias() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  shenandoah_assert_heaplocked();\n+\n+  idx_t left_idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector);\n+  idx_t right_idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector);\n+  idx_t middle = (left_idx + right_idx) \/ 2;\n+  size_t available_in_first_half = 0;\n+  size_t available_in_second_half = 0;\n+\n+  for (idx_t index = left_idx; index < middle; index++) {\n+    if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, index)) {\n+      ShenandoahHeapRegion* r = heap->get_region((size_t) index);\n+      available_in_first_half += r->free();\n+    }\n+  }\n+  for (idx_t index = middle; index <= right_idx; index++) {\n+    if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, index)) {\n+      ShenandoahHeapRegion* r = heap->get_region(index);\n+      available_in_second_half += r->free();\n@@ -1308,0 +1722,10 @@\n+\n+  \/\/ We desire to first consume the sparsely distributed regions in order that the remaining regions are densely packed.\n+  \/\/ Densely packing regions reduces the effort to search for a region that has sufficient memory to satisfy a new allocation\n+  \/\/ request.  Regions become sparsely distributed following a Full GC, which tends to slide all regions to the front of the\n+  \/\/ heap rather than allowing survivor regions to remain at the high end of the heap where we intend for them to congregate.\n+\n+  \/\/ TODO: In the future, we may modify Full GC so that it slides old objects to the end of the heap and young objects to the\n+  \/\/ front of the heap. If this is done, we can always search survivor Collector and OldCollector regions right to left.\n+  _partitions.set_bias_from_left_to_right(ShenandoahFreeSetPartitionId::OldCollector,\n+                                          (available_in_second_half > available_in_first_half));\n@@ -1310,0 +1734,1 @@\n+\n@@ -1337,1 +1762,1 @@\n-    log_debug(gc, free)(\"FreeSet map legend:\"\n+    log_debug(gc)(\"FreeSet map legend:\"\n@@ -1340,7 +1765,11 @@\n-    log_debug(gc, free)(\" mutator free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"], \"\n-                       \" collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"], \"\n-                       \"old collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"] allocates from %s\",\n-                       _free_sets.leftmost(Mutator), _free_sets.rightmost(Mutator),\n-                       _free_sets.leftmost(Collector), _free_sets.rightmost(Collector),\n-                       _free_sets.leftmost(OldCollector), _free_sets.rightmost(OldCollector),\n-                       _free_sets.alloc_from_left_bias(OldCollector)? \"left to right\": \"right to left\");\n+    log_debug(gc)(\" mutator free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"] allocating from %s, \"\n+                  \" collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"], \"\n+                  \"old collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"] allocates from %s\",\n+                  _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+                  _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+                  _partitions.alloc_from_left_bias(ShenandoahFreeSetPartitionId::Mutator)? \"left to right\": \"right to left\",\n+                  _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector),\n+                  _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector),\n+                  _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                  _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                  _partitions.alloc_from_left_bias(ShenandoahFreeSetPartitionId::OldCollector)? \"left to right\": \"right to left\");\n@@ -1352,1 +1781,1 @@\n-        log_debug(gc, free)(\" %6u: %s\", i-64, buffer);\n+        log_debug(gc)(\" %6u: %s\", i-64, buffer);\n@@ -1354,2 +1783,1 @@\n-      if (_free_sets.in_free_set(i, Mutator)) {\n-        assert(!r->is_old(), \"Old regions should not be in mutator_free set\");\n+      if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, i)) {\n@@ -1357,0 +1785,1 @@\n+        assert(!r->is_old(), \"Old regions should not be in mutator_free set\");\n@@ -1360,2 +1789,1 @@\n-      } else if (_free_sets.in_free_set(i, Collector)) {\n-        assert(!r->is_old(), \"Old regions should not be in collector_free set\");\n+      } else if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, i)) {\n@@ -1363,0 +1791,1 @@\n+        assert(!r->is_old(), \"Old regions should not be in collector_free set\");\n@@ -1366,1 +1795,1 @@\n-      } else if (_free_sets.in_free_set(i, OldCollector)) {\n+      } else if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, i)) {\n@@ -1397,3 +1826,1 @@\n-    log_debug(gc, free)(\" %6u: %s\", (uint) (_heap->num_regions() - remnant), buffer);\n-    size_t total_young = retired_young + retired_young_humongous;\n-    size_t total_old = retired_old + retired_old_humongous;\n+    log_debug(gc)(\" %6u: %s\", (uint) (_heap->num_regions() - remnant), buffer);\n@@ -1409,1 +1836,1 @@\n-      size_t last_idx = 0;\n+      idx_t last_idx = 0;\n@@ -1418,2 +1845,3 @@\n-      for (size_t idx = _free_sets.leftmost(Mutator); idx <= _free_sets.rightmost(Mutator); idx++) {\n-        if (_free_sets.in_free_set(idx, Mutator)) {\n+      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n+           idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator); idx++) {\n+        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx)) {\n@@ -1443,4 +1871,4 @@\n-      assert(free == total_free, \"Sum of free within mutator regions (\" SIZE_FORMAT\n-             \") should match mutator capacity (\" SIZE_FORMAT \") minus mutator used (\" SIZE_FORMAT \")\",\n-             total_free, capacity(), used());\n-\n+      \/\/ Since certain regions that belonged to the Mutator free partition at the time of most recent rebuild may have been\n+      \/\/ retired, the sum of used and capacities within regions that are still in the Mutator free partition may not match\n+      \/\/ my internally tracked values of used() and free().\n+      assert(free == total_free, \"Free memory should match\");\n@@ -1448,1 +1876,1 @@\n-               byte_size_in_proper_unit(total_free),    proper_unit_for_byte_size(total_free),\n+               byte_size_in_proper_unit(free),          proper_unit_for_byte_size(free),\n@@ -1463,2 +1891,3 @@\n-      if (_free_sets.count(Mutator) > 0) {\n-        frag_int = (100 * (total_used \/ _free_sets.count(Mutator)) \/ ShenandoahHeapRegion::region_size_bytes());\n+      if (_partitions.count(ShenandoahFreeSetPartitionId::Mutator) > 0) {\n+        frag_int = (100 * (total_used \/ _partitions.count(ShenandoahFreeSetPartitionId::Mutator))\n+                    \/ ShenandoahHeapRegion::region_size_bytes());\n@@ -1470,1 +1899,2 @@\n-               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used), _free_sets.count(Mutator));\n+               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used),\n+               _partitions.count(ShenandoahFreeSetPartitionId::Mutator));\n@@ -1478,2 +1908,3 @@\n-      for (size_t idx = _free_sets.leftmost(Collector); idx <= _free_sets.rightmost(Collector); idx++) {\n-        if (_free_sets.in_free_set(idx, Collector)) {\n+      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n+           idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector); idx++) {\n+        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx)) {\n@@ -1498,2 +1929,3 @@\n-      for (size_t idx = _free_sets.leftmost(OldCollector); idx <= _free_sets.rightmost(OldCollector); idx++) {\n-        if (_free_sets.in_free_set(idx, OldCollector)) {\n+      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector);\n+           idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector); idx++) {\n+        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, idx)) {\n@@ -1517,2 +1949,0 @@\n-\n-  \/\/ Allocation request is known to satisfy all memory budgeting constraints.\n@@ -1541,16 +1971,0 @@\n-size_t ShenandoahFreeSet::unsafe_peek_free() const {\n-  \/\/ Deliberately not locked, this method is unsafe when free set is modified.\n-\n-  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n-    if (index < _free_sets.max() && _free_sets.in_free_set(index, Mutator)) {\n-      ShenandoahHeapRegion* r = _heap->get_region(index);\n-      if (r->free() >= MinTLABSize) {\n-        return r->free();\n-      }\n-    }\n-  }\n-\n-  \/\/ It appears that no regions left\n-  return 0;\n-}\n-\n@@ -1558,5 +1972,7 @@\n-  out->print_cr(\"Mutator Free Set: \" SIZE_FORMAT \"\", _free_sets.count(Mutator));\n-  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n-    if (_free_sets.in_free_set(index, Mutator)) {\n-      _heap->get_region(index)->print_on(out);\n-    }\n+  out->print_cr(\"Mutator Free Set: \" SIZE_FORMAT \"\", _partitions.count(ShenandoahFreeSetPartitionId::Mutator));\n+  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+    _heap->get_region(index)->print_on(out);\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -1564,5 +1980,7 @@\n-  out->print_cr(\"Collector Free Set: \" SIZE_FORMAT \"\", _free_sets.count(Collector));\n-  for (size_t index = _free_sets.leftmost(Collector); index <= _free_sets.rightmost(Collector); index++) {\n-    if (_free_sets.in_free_set(index, Collector)) {\n-      _heap->get_region(index)->print_on(out);\n-    }\n+  out->print_cr(\"Collector Free Set: \" SIZE_FORMAT \"\", _partitions.count(ShenandoahFreeSetPartitionId::Collector));\n+  rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, index),\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+    _heap->get_region(index)->print_on(out);\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, index + 1);\n@@ -1571,3 +1989,4 @@\n-    out->print_cr(\"Old Collector Free Set: \" SIZE_FORMAT \"\", _free_sets.count(OldCollector));\n-    for (size_t index = _free_sets.leftmost(OldCollector); index <= _free_sets.rightmost(OldCollector); index++) {\n-      if (_free_sets.in_free_set(index, OldCollector)) {\n+    out->print_cr(\"Old Collector Free Set: \" SIZE_FORMAT \"\", _partitions.count(ShenandoahFreeSetPartitionId::OldCollector));\n+    for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector);\n+         index <= _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector); index++) {\n+      if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, index)) {\n@@ -1580,21 +1999,0 @@\n-\/*\n- * Internal fragmentation metric: describes how fragmented the heap regions are.\n- *\n- * It is derived as:\n- *\n- *               sum(used[i]^2, i=0..k)\n- *   IF = 1 - ------------------------------\n- *              C * sum(used[i], i=0..k)\n- *\n- * ...where k is the number of regions in computation, C is the region capacity, and\n- * used[i] is the used space in the region.\n- *\n- * The non-linearity causes IF to be lower for the cases where the same total heap\n- * used is densely packed. For example:\n- *   a) Heap is completely full  => IF = 0\n- *   b) Heap is half full, first 50% regions are completely full => IF = 0\n- *   c) Heap is half full, each region is 50% full => IF = 1\/2\n- *   d) Heap is quarter full, first 50% regions are completely full => IF = 0\n- *   e) Heap is quarter full, each region is 25% full => IF = 3\/4\n- *   f) Heap has one small object per each region => IF =~ 1\n- *\/\n@@ -1606,8 +2004,10 @@\n-  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n-    if (_free_sets.in_free_set(index, Mutator)) {\n-      ShenandoahHeapRegion* r = _heap->get_region(index);\n-      size_t used = r->used();\n-      squared += used * used;\n-      linear += used;\n-      count++;\n-    }\n+  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+    ShenandoahHeapRegion* r = _heap->get_region(index);\n+    size_t used = r->used();\n+    squared += used * used;\n+    linear += used;\n+    count++;\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -1624,13 +2024,0 @@\n-\/*\n- * External fragmentation metric: describes how fragmented the heap is.\n- *\n- * It is derived as:\n- *\n- *   EF = 1 - largest_contiguous_free \/ total_free\n- *\n- * For example:\n- *   a) Heap is completely empty => EF = 0\n- *   b) Heap is completely full => EF = 0\n- *   c) Heap is first-half full => EF = 1\/2\n- *   d) Heap is half full, full and empty regions interleave => EF =~ 1\n- *\/\n@@ -1638,1 +2025,1 @@\n-  size_t last_idx = 0;\n+  idx_t last_idx = 0;\n@@ -1644,10 +2031,9 @@\n-  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n-    if (_free_sets.in_free_set(index, Mutator)) {\n-      ShenandoahHeapRegion* r = _heap->get_region(index);\n-      if (r->is_empty()) {\n-        free += ShenandoahHeapRegion::region_size_bytes();\n-        if (last_idx + 1 == index) {\n-          empty_contig++;\n-        } else {\n-          empty_contig = 1;\n-        }\n+  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+    ShenandoahHeapRegion* r = _heap->get_region(index);\n+    if (r->is_empty()) {\n+      free += ShenandoahHeapRegion::region_size_bytes();\n+      if (last_idx + 1 == index) {\n+        empty_contig++;\n@@ -1655,1 +2041,1 @@\n-        empty_contig = 0;\n+        empty_contig = 1;\n@@ -1657,3 +2043,2 @@\n-\n-      max_contig = MAX2(max_contig, empty_contig);\n-      last_idx = index;\n+    } else {\n+      empty_contig = 0;\n@@ -1661,0 +2046,3 @@\n+    max_contig = MAX2(max_contig, empty_contig);\n+    last_idx = index;\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1110,"deletions":722,"binary":false,"changes":1832,"status":"modified"},{"patch":"@@ -32,7 +32,9 @@\n-\n-enum ShenandoahFreeMemoryType : uint8_t {\n-  NotFree,\n-  Mutator,\n-  Collector,\n-  OldCollector,\n-  NumFreeSets\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+\n+\/\/ Each ShenandoahHeapRegion is associated with a ShenandoahFreeSetPartitionId.\n+enum class ShenandoahFreeSetPartitionId : uint8_t {\n+  Mutator,                      \/\/ Region is in the Mutator free set: available memory is available to mutators.\n+  Collector,                    \/\/ Region is in the Collector free set: available memory is reserved for evacuations.\n+  OldCollector,                 \/\/ Region is in the Old Collector free set:\n+                                \/\/    available memory is reserved for old evacuations and for promotions..\n+  NotFree                       \/\/ Region is in no free set: it has no available memory\n@@ -41,1 +43,5 @@\n-class ShenandoahSetsOfFree {\n+\/\/ We do not maintain counts, capacity, or used for regions that are not free.  Informally, if a region is NotFree, it is\n+\/\/ in no partition.  NumPartitions represents the size of an array that may be indexed by Mutator or Collector.\n+#define NumPartitions           (ShenandoahFreeSetPartitionId::NotFree)\n+#define IntNumPartitions     int(ShenandoahFreeSetPartitionId::NotFree)\n+#define UIntNumPartitions   uint(ShenandoahFreeSetPartitionId::NotFree)\n@@ -43,19 +49,5 @@\n-private:\n-  size_t _max;                  \/\/ The maximum number of heap regions\n-  ShenandoahFreeSet* _free_set;\n-  size_t _region_size_bytes;\n-  ShenandoahFreeMemoryType* _membership;\n-  size_t _leftmosts[NumFreeSets];\n-  size_t _rightmosts[NumFreeSets];\n-  size_t _leftmosts_empty[NumFreeSets];\n-  size_t _rightmosts_empty[NumFreeSets];\n-  size_t _capacity_of[NumFreeSets];\n-  size_t _used_by[NumFreeSets];\n-  bool _left_to_right_bias[NumFreeSets];\n-  size_t _region_counts[NumFreeSets];\n-\n-  inline void shrink_bounds_if_touched(ShenandoahFreeMemoryType set, size_t idx);\n-  inline void expand_bounds_maybe(ShenandoahFreeMemoryType set, size_t idx, size_t capacity);\n-\n-  \/\/ Restore all state variables to initial default state.\n-  void clear_internal();\n+\/\/ ShenandoahRegionPartitions provides an abstraction to help organize the implementation of ShenandoahFreeSet.  This\n+\/\/ class implements partitioning of regions into distinct sets.  Each ShenandoahHeapRegion is either in the Mutator free set,\n+\/\/ the Collector free set, or in neither free set (NotFree).  When we speak of a \"free partition\", we mean partitions that\n+\/\/ for which the ShenandoahFreeSetPartitionId is not equal to NotFree.\n+class ShenandoahRegionPartitions {\n@@ -63,0 +55,48 @@\n+private:\n+  const ssize_t _max;           \/\/ The maximum number of heap regions\n+  const size_t _region_size_bytes;\n+  const ShenandoahFreeSet* _free_set;\n+  \/\/ For each partition, we maintain a bitmap of which regions are affiliated with his partition.\n+  ShenandoahSimpleBitMap _membership[UIntNumPartitions];\n+\n+  \/\/ For each partition, we track an interval outside of which a region affiliated with that partition is guaranteed\n+  \/\/ not to be found. This makes searches for free space more efficient.  For each partition p, _leftmosts[p]\n+  \/\/ represents its least index, and its _rightmosts[p] its greatest index. Empty intervals are indicated by the\n+  \/\/ canonical [_max, -1].\n+  ssize_t _leftmosts[UIntNumPartitions];\n+  ssize_t _rightmosts[UIntNumPartitions];\n+\n+  \/\/ Allocation for humongous objects needs to find regions that are entirely empty.  For each partion p, _leftmosts_empty[p]\n+  \/\/ represents the first region belonging to this partition that is completely empty and _rightmosts_empty[p] represents the\n+  \/\/ last region that is completely empty.  If there is no completely empty region in this partition, this is represented\n+  \/\/ by the canonical [_max, -1].\n+  ssize_t _leftmosts_empty[UIntNumPartitions];\n+  ssize_t _rightmosts_empty[UIntNumPartitions];\n+\n+  \/\/ For each partition p, _capacity[p] represents the total amount of memory within the partition at the time\n+  \/\/ of the most recent rebuild, _used[p] represents the total amount of memory that has been allocated within this\n+  \/\/ partition (either already allocated as of the rebuild, or allocated since the rebuild).  _capacity[p] and _used[p]\n+  \/\/ are denoted in bytes.  Note that some regions that had been assigned to a particular partition at rebuild time\n+  \/\/ may have been retired following the rebuild.  The tallies for these regions are still reflected in _capacity[p]\n+  \/\/ and _used[p], even though the region may have been removed from the free set.\n+  size_t _capacity[UIntNumPartitions];\n+  size_t _used[UIntNumPartitions];\n+  size_t _region_counts[UIntNumPartitions];\n+\n+  \/\/ For each partition p, _left_to_right_bias is true iff allocations are normally made from lower indexed regions\n+  \/\/ before higher indexed regions.\n+  bool _left_to_right_bias[UIntNumPartitions];\n+\n+  \/\/ Shrink the intervals associated with partition when region idx is removed from this free set\n+  inline void shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, ssize_t idx);\n+\n+  \/\/ Shrink the intervals associated with partition when regions low_idx through high_idx inclusive are removed from this free set\n+  inline void shrink_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId partition,\n+                                                                ssize_t low_idx, ssize_t high_idx);\n+  inline void expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, ssize_t idx, size_t capacity);\n+\n+#ifndef PRODUCT\n+  void dump_bitmap_row(ssize_t region_idx) const;\n+  void dump_bitmap_range(ssize_t start_region_idx, ssize_t end_region_idx) const;\n+  void dump_bitmap() const;\n+#endif\n@@ -64,2 +104,34 @@\n-  ShenandoahSetsOfFree(size_t max_regions, ShenandoahFreeSet* free_set);\n-  ~ShenandoahSetsOfFree();\n+  ShenandoahRegionPartitions(size_t max_regions, ShenandoahFreeSet* free_set);\n+  ~ShenandoahRegionPartitions() {}\n+\n+  \/\/ Remove all regions from all partitions and reset all bounds\n+  void make_all_regions_unavailable();\n+\n+  \/\/ Set the partition id for a particular region without adjusting interval bounds or usage\/capacity tallies\n+  inline void raw_assign_membership(size_t idx, ShenandoahFreeSetPartitionId p) {\n+    _membership[int(p)].set_bit(idx);\n+  }\n+\n+  \/\/ Set the Mutator intervals, usage, and capacity according to arguments.  Reset the Collector intervals, used, capacity\n+  \/\/ to represent empty Collector free set.  We use this at the end of rebuild_free_set() to avoid the overhead of making\n+  \/\/ many redundant incremental adjustments to the mutator intervals as the free set is being rebuilt.\n+  void establish_mutator_intervals(ssize_t mutator_leftmost, ssize_t mutator_rightmost,\n+                                   ssize_t mutator_leftmost_empty, ssize_t mutator_rightmost_empty,\n+                                   size_t mutator_region_count, size_t mutator_used);\n+\n+  \/\/ Set the OldCollector intervals, usage, and capacity according to arguments.  We use this at the end of rebuild_free_set()\n+  \/\/ to avoid the overhead of making many redundant incremental adjustments to the mutator intervals as the free set is being\n+  \/\/ rebuilt.\n+  void establish_old_collector_intervals(ssize_t old_collector_leftmost, ssize_t old_collector_rightmost,\n+                                         ssize_t old_collector_leftmost_empty, ssize_t old_collector_rightmost_empty,\n+                                         size_t old_collector_region_count, size_t old_collector_used);\n+\n+  \/\/ Retire region idx from within partition, , leaving its capacity and used as part of the original free partition's totals.\n+  \/\/ Requires that region idx is in in the Mutator or Collector partitions.  Hereafter, identifies this region as NotFree.\n+  \/\/ Any remnant of available memory at the time of retirement is added to the original partition's total of used bytes.\n+  void retire_from_partition(ShenandoahFreeSetPartitionId p, ssize_t idx, size_t used_bytes);\n+\n+  \/\/ Retire all regions between low_idx and high_idx inclusive from within partition.  Requires that each region idx is\n+  \/\/ in the same Mutator or Collector partition.  Hereafter, identifies each region as NotFree.   Assumes that each region\n+  \/\/ is now considered fully used, since the region is presumably used to represent a humongous object.\n+  void retire_range_from_partition(ShenandoahFreeSetPartitionId partition, ssize_t low_idx, ssize_t high_idx);\n@@ -67,2 +139,2 @@\n-  \/\/ Make all regions NotFree and reset all bounds\n-  void clear_all();\n+  \/\/ Place region idx into free set which_partition.  Requires that idx is currently NotFree.\n+  void make_free(ssize_t idx, ShenandoahFreeSetPartitionId which_partition, size_t region_capacity);\n@@ -70,2 +142,4 @@\n-  \/\/ Remove or retire region idx from all free sets.  Requires that idx is in a free set.  This does not affect capacity.\n-  void remove_from_free_sets(size_t idx);\n+  \/\/ Place region idx into free partition new_partition, adjusting used and capacity totals for the original and new partition\n+  \/\/ given that available bytes can still be allocated within this region.  Requires that idx is currently not NotFree.\n+  void move_from_partition_to_partition(ssize_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+                                        ShenandoahFreeSetPartitionId new_partition, size_t available);\n@@ -73,2 +147,1 @@\n-  \/\/ Place region idx into free set which_set.  Requires that idx is currently NotFree.\n-  void make_free(size_t idx, ShenandoahFreeMemoryType which_set, size_t region_capacity);\n+  const char* partition_membership_name(ssize_t idx) const;\n@@ -76,2 +149,2 @@\n-  \/\/ Place region idx into free set new_set.  Requires that idx is currently not NotFree.\n-  void move_to_set(size_t idx, ShenandoahFreeMemoryType new_set, size_t region_capacity);\n+  \/\/ Return the index of the next available region >= start_index, or maximum_regions if not found.\n+  inline ssize_t find_index_of_next_available_region(ShenandoahFreeSetPartitionId which_partition, ssize_t start_index) const;\n@@ -79,3 +152,2 @@\n-  \/\/ Returns the ShenandoahFreeMemoryType affiliation of region idx, or NotFree if this region is not currently free.  This does\n-  \/\/ not enforce that free_set membership implies allocation capacity.\n-  inline ShenandoahFreeMemoryType membership(size_t idx) const;\n+  \/\/ Return the index of the previous available region <= last_index, or -1 if not found.\n+  inline ssize_t find_index_of_previous_available_region(ShenandoahFreeSetPartitionId which_partition, ssize_t last_index) const;\n@@ -83,3 +155,25 @@\n-  \/\/ Returns true iff region idx is in the test_set free_set.  Before returning true, asserts that the free\n-  \/\/ set is not empty.  Requires that test_set != NotFree or NumFreeSets.\n-  inline bool in_free_set(size_t idx, ShenandoahFreeMemoryType which_set) const;\n+  \/\/ Return the index of the next available cluster of cluster_size regions >= start_index, or maximum_regions if not found.\n+  inline ssize_t find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId which_partition,\n+                                                                 ssize_t start_index, size_t cluster_size) const;\n+\n+  \/\/ Return the index of the previous available cluster of cluster_size regions <= last_index, or -1 if not found.\n+  inline ssize_t find_index_of_previous_available_cluster_of_regions(ShenandoahFreeSetPartitionId which_partition,\n+                                                                     ssize_t last_index, size_t cluster_size) const;\n+\n+  inline bool in_free_set(ShenandoahFreeSetPartitionId which_partition, ssize_t idx) const {\n+    return _membership[int(which_partition)].is_set(idx);\n+  }\n+\n+  \/\/ Returns the ShenandoahFreeSetPartitionId affiliation of region idx, NotFree if this region is not currently in any partition.\n+  \/\/ This does not enforce that free_set membership implies allocation capacity.\n+  inline ShenandoahFreeSetPartitionId membership(ssize_t idx) const;\n+\n+#ifdef ASSERT\n+  \/\/ Returns true iff region idx's membership is which_partition.  If which_partition represents a free set, asserts\n+  \/\/ that the region has allocation capacity.\n+  inline bool partition_id_matches(ssize_t idx, ShenandoahFreeSetPartitionId which_partition) const;\n+#endif\n+\n+  inline size_t max_regions() const { return _max; }\n+\n+  inline size_t region_size_bytes() const { return _region_size_bytes; };\n@@ -89,4 +183,2 @@\n-  \/\/ regions, which are required for humongous allocations and desired for \"very large\" allocations.  A\n-  \/\/ return value of -1 from leftmost() or leftmost_empty() denotes that the corresponding set is empty.\n-  \/\/ In other words:\n-  \/\/   if the requested which_set is empty:\n+  \/\/ regions, which are required for humongous allocations and desired for \"very large\" allocations.\n+  \/\/   if the requested which_partition is empty:\n@@ -96,4 +188,6 @@\n-  inline size_t leftmost(ShenandoahFreeMemoryType which_set) const;\n-  inline size_t rightmost(ShenandoahFreeMemoryType which_set) const;\n-  size_t leftmost_empty(ShenandoahFreeMemoryType which_set);\n-  size_t rightmost_empty(ShenandoahFreeMemoryType which_set);\n+  inline ssize_t leftmost(ShenandoahFreeSetPartitionId which_partition) const;\n+  inline ssize_t rightmost(ShenandoahFreeSetPartitionId which_partition) const;\n+  ssize_t leftmost_empty(ShenandoahFreeSetPartitionId which_partition);\n+  ssize_t rightmost_empty(ShenandoahFreeSetPartitionId which_partition);\n+\n+  inline bool is_empty(ShenandoahFreeSetPartitionId which_partition) const;\n@@ -101,1 +195,1 @@\n-  inline bool is_empty(ShenandoahFreeMemoryType which_set) const;\n+  inline void increase_used(ShenandoahFreeSetPartitionId which_partition, size_t bytes);\n@@ -103,1 +197,9 @@\n-  inline void increase_used(ShenandoahFreeMemoryType which_set, size_t bytes);\n+  inline void set_bias_from_left_to_right(ShenandoahFreeSetPartitionId which_partition, bool value) {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    _left_to_right_bias[int(which_partition)] = value;\n+  }\n+\n+  inline bool alloc_from_left_bias(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _left_to_right_bias[int(which_partition)];\n+  }\n@@ -105,3 +207,3 @@\n-  inline size_t capacity_of(ShenandoahFreeMemoryType which_set) const {\n-    assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-    return _capacity_of[which_set];\n+  inline size_t capacity_of(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _capacity[int(which_partition)];\n@@ -110,3 +212,3 @@\n-  inline size_t used_by(ShenandoahFreeMemoryType which_set) const {\n-    assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-    return _used_by[which_set];\n+  inline size_t used_by(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _used[int(which_partition)];\n@@ -115,1 +217,4 @@\n-  inline size_t max() const { return _max; }\n+  inline size_t available_in(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _capacity[int(which_partition)] - _used[int(which_partition)];\n+  }\n@@ -117,1 +222,4 @@\n-  inline size_t count(ShenandoahFreeMemoryType which_set) const { return _region_counts[which_set]; }\n+  inline void set_capacity_of(ShenandoahFreeSetPartitionId which_partition, size_t value) {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    _capacity[int(which_partition)] = value;\n+  }\n@@ -119,3 +227,4 @@\n-  \/\/ Return true iff regions for allocation from this set should be peformed left to right.  Otherwise, allocate\n-  \/\/ from right to left.\n-  inline bool alloc_from_left_bias(ShenandoahFreeMemoryType which_set);\n+  inline void set_used_by(ShenandoahFreeSetPartitionId which_partition, size_t value) {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    _used[int(which_partition)] = value;\n+  }\n@@ -123,2 +232,1 @@\n-  \/\/ Determine whether we prefer to allocate from left to right or from right to left for this free-set.\n-  void establish_alloc_bias(ShenandoahFreeMemoryType which_set);\n+  inline size_t count(ShenandoahFreeSetPartitionId which_partition) const { return _region_counts[int(which_partition)]; }\n@@ -140,1 +248,1 @@\n-  \/\/     0 <= lefmost_empty < max and 0 <= rightmost_empty < max\n+  \/\/     0 <= leftmost_empty < max and 0 <= rightmost_empty < max\n@@ -149,0 +257,24 @@\n+\/\/ Publicly, ShenandoahFreeSet represents memory that is available to mutator threads.  The public capacity(), used(),\n+\/\/ and available() methods represent this public notion of memory that is under control of the mutator.  Separately,\n+\/\/ ShenandoahFreeSet also represents memory available to garbage collection activities for compaction purposes.\n+\/\/\n+\/\/ The Shenandoah garbage collector evacuates live objects out of specific regions that are identified as members of the\n+\/\/ collection set (cset).\n+\/\/\n+\/\/ The ShenandoahFreeSet endeavors to congregrate survivor objects (objects that have been evacuated at least once) at the\n+\/\/ high end of memory.  New mutator allocations are taken from the low end of memory.  Within the mutator's range of regions,\n+\/\/ humongous allocations are taken from the lowest addresses, and LAB (local allocation buffers) and regular shared allocations\n+\/\/ are taken from the higher address of the mutator's range of regions.  This approach allows longer lasting survivor regions\n+\/\/ to congregate at the top of the heap and longer lasting humongous regions to congregate at the bottom of the heap, with\n+\/\/ short-lived frequently evacuated regions occupying the middle of the heap.\n+\/\/\n+\/\/ Mutator and garbage collection activities tend to scramble the content of regions.  Twice, during each GC pass, we rebuild\n+\/\/ the free set in an effort to restore the efficient segregation of Collector and Mutator regions:\n+\/\/\n+\/\/  1. At the start of evacuation, we know exactly how much memory is going to be evacuated, and this guides our\n+\/\/     sizing of the Collector free set.\n+\/\/\n+\/\/  2. At the end of GC, we have reclaimed all of the memory that was spanned by the cset.  We rebuild here to make\n+\/\/     sure there is enough memory reserved at the high end of memory to hold the objects that might need to be evacuated\n+\/\/     during the next GC pass.\n+\n@@ -152,3 +284,2 @@\n-  ShenandoahSetsOfFree _free_sets;\n-\n-  HeapWord* try_allocate_in(ShenandoahHeapRegion* region, ShenandoahAllocRequest& req, bool& in_new_region);\n+  ShenandoahRegionPartitions _partitions;\n+  size_t _retired_old_regions;\n@@ -158,3 +289,5 @@\n-  \/\/ Satisfy young-generation or single-generation collector allocation request req by finding memory that matches\n-  \/\/ affiliation, which either equals req.affiliation or FREE.  We know req.is_young().\n-  HeapWord* allocate_with_affiliation(ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region);\n+  \/\/ Satisfy collector allocation request req by finding memory that matches affiliation from within the\n+  \/\/ free partition associated with which_partition.\n+  inline HeapWord* allocate_from_partition_with_affiliation(ShenandoahFreeSetPartitionId which_partition,\n+                                                            ShenandoahAffiliation affiliation,\n+                                                            ShenandoahAllocRequest& req, bool& in_new_region);\n@@ -162,3 +295,4 @@\n-  \/\/ Satisfy allocation request req by finding memory that matches affiliation, which either equals req.affiliation\n-  \/\/ or FREE. We know req.is_old().\n-  HeapWord* allocate_old_with_affiliation(ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region);\n+  \/\/ We re-evaluate the left-to-right allocation bias whenever _alloc_bias_weight is less than zero.  Each time\n+  \/\/ we allocate an object, we decrement the count of this value.  Each time we re-evaluate whether to allocate\n+  \/\/ from right-to-left or left-to-right, we reset the value of this counter to _InitialAllocBiasWeight.\n+  ssize_t _alloc_bias_weight;\n@@ -166,6 +300,8 @@\n-  \/\/ While holding the heap lock, allocate memory for a single object which is to be entirely contained\n-  \/\/ within a single HeapRegion as characterized by req.  The req.size() value is known to be less than or\n-  \/\/ equal to ShenandoahHeapRegion::humongous_threshold_words().  The caller of allocate_single is responsible\n-  \/\/ for registering the resulting object and setting the remembered set card values as appropriate.  The\n-  \/\/ most common case is that we are allocating a PLAB in which case object registering and card dirtying\n-  \/\/ is managed after the PLAB is divided into individual objects.\n+  const ssize_t _InitialAllocBiasWeight = 256;\n+\n+  HeapWord* try_allocate_in(ShenandoahHeapRegion* region, ShenandoahAllocRequest& req, bool& in_new_region);\n+\n+  \/\/ While holding the heap lock, allocate memory for a single object or LAB  which is to be entirely contained\n+  \/\/ within a single HeapRegion as characterized by req.\n+  \/\/\n+  \/\/ Precondition: req.size() <= ShenandoahHeapRegion::humongous_threshold_words().\n@@ -173,0 +309,6 @@\n+\n+  \/\/ While holding the heap lock, allocate memory for a humongous object which spans one or more regions that\n+  \/\/ were previously empty.  Regions that represent humongous objects are entirely dedicated to the humongous\n+  \/\/ object.  No other objects are packed into these regions.\n+  \/\/\n+  \/\/ Precondition: req.size() > ShenandoahHeapRegion::humongous_threshold_words().\n@@ -175,0 +317,6 @@\n+  \/\/ Change region r from the Mutator partition to the GC's Collector or OldCollector partition.  This requires that the\n+  \/\/ region is entirely empty.\n+  \/\/\n+  \/\/ Typical usage: During evacuation, the GC may find it needs more memory than had been reserved at the start of evacuation to\n+  \/\/ hold evacuated objects.  If this occurs and memory is still available in the Mutator's free set, we will flip a region from\n+  \/\/ the Mutator free set into the Collector or OldCollector free set.\n@@ -179,0 +327,7 @@\n+  void try_recycle_trashed(ShenandoahHeapRegion *r, bool is_generational);\n+\n+  \/\/ Returns true iff this region is entirely available, either because it is empty() or because it has been found to represent\n+  \/\/ immediate trash and we'll be able to immediately recycle it.  Note that we cannot recycle immediate trash if\n+  \/\/ concurrent weak root processing is in progress.\n+  inline bool can_allocate_from(ShenandoahHeapRegion *r) const;\n+  inline bool can_allocate_from(size_t idx) const;\n@@ -180,1 +335,1 @@\n-  void try_recycle_trashed(ShenandoahHeapRegion *r);\n+  inline bool has_alloc_capacity(ShenandoahHeapRegion *r) const;\n@@ -182,3 +337,7 @@\n-  bool can_allocate_from(ShenandoahHeapRegion *r) const;\n-  bool can_allocate_from(size_t idx) const;\n-  bool has_alloc_capacity(ShenandoahHeapRegion *r) const;\n+  \/\/ Determine whether we prefer to allocate from left to right or from right to left within the OldCollector free-set.\n+  void establish_old_collector_alloc_bias();\n+\n+  \/\/ Set max_capacity for young and old generations\n+  void establish_generation_sizes(size_t young_region_count, size_t old_region_count);\n+\n+  size_t get_usable_free_words(size_t free_bytes) const;\n@@ -189,2 +348,3 @@\n-  size_t alloc_capacity(ShenandoahHeapRegion *r) const;\n-  size_t alloc_capacity(size_t idx) const;\n+  \/\/ Public because ShenandoahRegionPartitions assertions require access.\n+  inline size_t alloc_capacity(ShenandoahHeapRegion *r) const;\n+  inline size_t alloc_capacity(size_t idx) const;\n@@ -208,5 +368,17 @@\n-  void rebuild(size_t young_cset_regions, size_t old_cset_regions, bool have_evacuation_reserves = false);\n-\n-  void move_collector_sets_to_mutator(size_t cset_regions);\n-\n-  void add_old_collector_free_region(ShenandoahHeapRegion* region);\n+  void finish_rebuild(size_t young_cset_regions, size_t old_cset_regions, size_t num_old_regions,\n+                      bool have_evacuation_reserves = false);\n+\n+  \/\/ When a region is promoted in place, we add the region's available memory if it is greater than plab_min_size()\n+  \/\/ into the old collector partition by invoking this method.\n+  void add_promoted_in_place_region_to_old_collector(ShenandoahHeapRegion* region);\n+\n+  \/\/ Move up to cset_regions number of regions from being available to the collector to being available to the mutator.\n+  \/\/\n+  \/\/ Typical usage: At the end of evacuation, when the collector no longer needs the regions that had been reserved\n+  \/\/ for evacuation, invoke this to make regions available for mutator allocations.\n+  \/\/\n+  \/\/ Note that we plan to replenish the Collector reserve at the end of update refs, at which time all\n+  \/\/ of the regions recycled from the collection set will be available.  If the very unlikely event that there\n+  \/\/ are fewer regions in the collection set than remain in the collector set, we limit the transfer in order\n+  \/\/ to assure that the replenished Collector reserve can be sufficiently large.\n+  void move_regions_from_collector_to_mutator(size_t cset_regions);\n@@ -215,1 +387,0 @@\n-\n@@ -218,2 +389,2 @@\n-  inline size_t capacity()  const { return _free_sets.capacity_of(Mutator); }\n-  inline size_t used()      const { return _free_sets.used_by(Mutator);     }\n+  inline size_t capacity()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator); }\n+  inline size_t used()      const { return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);     }\n@@ -228,0 +399,21 @@\n+  \/*\n+   * Internal fragmentation metric: describes how fragmented the heap regions are.\n+   *\n+   * It is derived as:\n+   *\n+   *               sum(used[i]^2, i=0..k)\n+   *   IF = 1 - ------------------------------\n+   *              C * sum(used[i], i=0..k)\n+   *\n+   * ...where k is the number of regions in computation, C is the region capacity, and\n+   * used[i] is the used space in the region.\n+   *\n+   * The non-linearity causes IF to be lower for the cases where the same total heap\n+   * used is densely packed. For example:\n+   *   a) Heap is completely full  => IF = 0\n+   *   b) Heap is half full, first 50% regions are completely full => IF = 0\n+   *   c) Heap is half full, each region is 50% full => IF = 1\/2\n+   *   d) Heap is quarter full, first 50% regions are completely full => IF = 0\n+   *   e) Heap is quarter full, each region is 25% full => IF = 3\/4\n+   *   f) Heap has one small object per each region => IF =~ 1\n+   *\/\n@@ -229,0 +421,14 @@\n+\n+  \/*\n+   * External fragmentation metric: describes how fragmented the heap is.\n+   *\n+   * It is derived as:\n+   *\n+   *   EF = 1 - largest_contiguous_free \/ total_free\n+   *\n+   * For example:\n+   *   a) Heap is completely empty => EF = 0\n+   *   b) Heap is completely full => EF = 0\n+   *   c) Heap is first-half full => EF = 1\/2\n+   *   d) Heap is half full, full and empty regions interleave => EF =~ 1\n+   *\/\n@@ -233,0 +439,5 @@\n+  \/\/ This function places all regions that have allocation capacity into the mutator partition, or if the region\n+  \/\/ is already affiliated with old, into the old collector partition, identifying regions that have no allocation\n+  \/\/ capacity as NotFree.  Subsequently, we will move some of the mutator regions into the collector and old collector\n+  \/\/ partitions with the intent of packing old collector memory into the highest (far rightmost) addresses of the heap,\n+  \/\/ young collector memory into higher address, and mutator memory consuming the lowest addresses of the heap.\n@@ -235,0 +446,12 @@\n+\n+\n+  \/\/ Having placed all regions that have allocation capacity into the mutator partition, move some of these regions from\n+  \/\/ the mutator partition into the collector partition in order to assure that the memory available for allocations within\n+  \/\/ the collector partition is at least to_reserve, and move others of these regions from the mutator partition into the\n+  \/\/ old collector partition to assure that old collector partition has at least old_reserve.  Update old_region_count\n+  \/\/ to represent the total number of regions in the old generation by adding the number of regions moved from the\n+  \/\/ mutator partition to the old collector partition.\n+  void reserve_regions(size_t to_reserve, size_t old_reserve, size_t &old_region_count);\n+\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":319,"deletions":96,"binary":false,"changes":415,"status":"modified"},{"patch":"@@ -1197,1 +1197,1 @@\n-    heap->free_set()->rebuild(young_cset_regions, old_cset_regions);\n+    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -755,1 +755,1 @@\n-    heap->free_set()->rebuild(young_cset_regions, old_cset_regions, true);\n+    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old, true);\n@@ -965,1 +965,1 @@\n-void ShenandoahGeneration::increase_capacity(size_t increment) {\n+size_t ShenandoahGeneration::increase_capacity(size_t increment) {\n@@ -982,0 +982,1 @@\n+  return _max_capacity;\n@@ -984,1 +985,7 @@\n-void ShenandoahGeneration::decrease_capacity(size_t decrement) {\n+size_t ShenandoahGeneration::establish_capacity(size_t byte_size) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  _max_capacity = byte_size;\n+  return _max_capacity;\n+}\n+\n+size_t ShenandoahGeneration::decrease_capacity(size_t decrement) {\n@@ -1007,0 +1014,1 @@\n+  return _max_capacity;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -152,2 +152,4 @@\n-  void increase_capacity(size_t increment);\n-  void decrease_capacity(size_t decrement);\n+  size_t increase_capacity(size_t increment);\n+  size_t decrease_capacity(size_t decrement);\n+\n+  size_t establish_capacity(size_t byte_size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-    _heap->free_set()->add_old_collector_free_region(region);\n+    _heap->free_set()->add_promoted_in_place_region_to_old_collector(region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -762,1 +762,1 @@\n-      _heap->free_set()->move_collector_sets_to_mutator(cset_regions);\n+      _heap->free_set()->move_regions_from_collector_to_mutator(cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -419,1 +419,1 @@\n-    _free_set->rebuild(young_cset_regions, old_cset_regions);\n+    _free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n@@ -1008,1 +1008,4 @@\n-    if (result == nullptr && !req.is_lab_alloc() && get_gc_no_progress_count() > ShenandoahNoProgressThreshold) {\n+    \/\/ gc_no_progress_count is incremented following each degen or full GC that fails to achieve is_good_progress().\n+    \/\/ Note that Generational Shenandoah may increment no_progress_count faster than traditional Shenandoah because young\n+    \/\/ GCs, which may degenerate, typically occur more frequently than single-generation Global GCs.\n+    if ((result == nullptr) && !req.is_lab_alloc() && (get_gc_no_progress_count() > ShenandoahNoProgressThreshold)) {\n@@ -1010,0 +1013,1 @@\n+      req.set_actual_size(0);\n@@ -1020,0 +1024,1 @@\n+\n@@ -1021,2 +1026,22 @@\n-    while (result == nullptr\n-        && (get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count())) {\n+\n+    \/\/ Stop retrying and return nullptr to cause OOMError exception if our allocation failed even after:\n+    \/\/   a) We experienced a GC that had good progress, or\n+    \/\/   b) We experienced at least one Full GC (whether or not it had good progress)\n+    \/\/\n+    \/\/ TODO: Rather than require a Full GC before throwing OOMError, it might be more appropriate for handle_alloc_failure()\n+    \/\/       to trigger a concurrent GLOBAL GC, and throw OOMError if we cannot allocate even after GLOBAL GC has finished.\n+    \/\/       There is no \"perfect\" solution here:\n+    \/\/\n+    \/\/        1. As currently implemented, there may be a race between multiple allocating threads, both attempting\n+    \/\/           to allocate very large objects.  The first thread to retry its allocation might succeed and the second\n+    \/\/           thread to retry its allocation might fail (because the first thread consumed the newly available memory).\n+    \/\/           So the second thread experiences OOMError even through another GC would have reclaimed the memory it wanted\n+    \/\/           to allocate.\n+    \/\/        2. A GLOBAL GC won't necessarily reclaim all garbage.  Following a concurrent Generational GLOBAL GC, we may\n+    \/\/           need to perform multiple concurrent mixed evacuations in order to reclaim all of the dead memory identified\n+    \/\/           by the GLOBAL GC mark.  However, the first evacuation performed by the GLOBAL GC will normally reclaim\n+    \/\/           a significant amount of garbage (as guided by garbage first heuristic).  If this is not enough memory\n+    \/\/           to satisfy the pending allocation request, we are in \"dire straits\", and a fail-fast OOMError is probably\n+    \/\/           the better remediation than repeated attempts to allocate following repeated GC cycles.\n+\n+    while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n@@ -1026,1 +1051,0 @@\n-\n@@ -2074,1 +2098,1 @@\n-  \/\/ Step 0. Notify policy to disable event recording.\n+  \/\/ Step 0. Notify policy to disable event recording and prevent visiting gc threads during shutdown\n@@ -2335,0 +2359,1 @@\n+    T cl;\n@@ -2339,1 +2364,1 @@\n-      \/\/ We cannot transfer any more regions than will be reclaimed when the existing collection set is recycled, because\n+      \/\/ We cannot transfer any more regions than will be reclaimed when the existing collection set is recycled because\n@@ -2341,1 +2366,1 @@\n-      _heap->free_set()->move_collector_sets_to_mutator(cset_regions);\n+      _heap->free_set()->move_regions_from_collector_to_mutator(cset_regions);\n@@ -2344,1 +2369,1 @@\n-    T cl;\n+\n@@ -2486,1 +2511,1 @@\n-  _free_set->rebuild(young_cset_regions, old_cset_regions);\n+  _free_set->finish_rebuild(young_cset_regions, old_cset_regions, old_region_count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":35,"deletions":10,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-\/\/ behavior previously performed as a side effect of make_regular_bypass().\n+\/\/ behavior previously performed as a side effect of make_regular_bypass().  This is used by Full GC\n@@ -133,0 +133,3 @@\n+         ShenandoahHeap::heap()->old_generation()->decrease_capacity(region_size_bytes());\n+       } else {\n+         assert(!is_affiliated(), \"Don't make young unless OLD or not already affiliated\");\n@@ -134,0 +137,1 @@\n+\n@@ -136,0 +140,1 @@\n+       ShenandoahHeap::heap()->young_generation()->increase_capacity(region_size_bytes());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-    req.set_actual_size(size);\n+    \/\/ We do not req.set_actual_size() here.  The caller sets it.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -479,1 +479,1 @@\n-    heap->free_set()->rebuild(cset_young_regions, cset_old_regions);\n+    heap->free_set()->finish_rebuild(cset_young_regions, cset_old_regions, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+\n+ShenandoahSimpleBitMap::ShenandoahSimpleBitMap(size_t num_bits) :\n+    _num_bits(num_bits),\n+    _num_words(align_up(num_bits, BitsPerWord) \/ BitsPerWord),\n+    _bitmap(NEW_C_HEAP_ARRAY(uintx, _num_words, mtGC))\n+{\n+  clear_all();\n+}\n+\n+ShenandoahSimpleBitMap::~ShenandoahSimpleBitMap() {\n+  if (_bitmap != nullptr) {\n+    FREE_C_HEAP_ARRAY(uintx, _bitmap);\n+  }\n+}\n+\n+size_t ShenandoahSimpleBitMap::count_leading_ones(idx_t start_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  size_t array_idx = start_idx >> LogBitsPerWord;\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  uintx mask = ~right_n_bits(bit_number);\n+  size_t counted_ones = 0;\n+  while ((element_bits & mask) == mask) {\n+    \/\/ All bits numbered >= bit_number are set\n+    size_t found_ones = BitsPerWord - bit_number;\n+    counted_ones += found_ones;\n+    \/\/ Dead code: do not need to compute: start_idx += found_ones;\n+    \/\/ Strength reduction:                array_idx = (start_idx >> LogBitsPerWord)\n+    array_idx++;\n+    element_bits = _bitmap[array_idx];\n+    \/\/ Constant folding:                  bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+    bit_number = 0;\n+    \/\/ Constant folding:                  mask = ~right_n_bits(bit_number);\n+    mask = ~0;\n+  }\n+\n+  \/\/ Add in number of consecutive ones starting with the_bit and including more significant bits and return result\n+  uintx aligned = element_bits >> bit_number;\n+  uintx complement = ~aligned;\n+  return counted_ones + count_trailing_zeros<uintx>(complement);\n+}\n+\n+size_t ShenandoahSimpleBitMap::count_trailing_ones(idx_t last_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  size_t array_idx = last_idx >> LogBitsPerWord;\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  \/\/ All ones from bit 0 to the_bit\n+  uintx mask = right_n_bits(bit_number + 1);\n+  size_t counted_ones = 0;\n+  while ((element_bits & mask) == mask) {\n+    \/\/ All bits numbered <= bit_number are set\n+    size_t found_ones = bit_number + 1;\n+    counted_ones += found_ones;\n+    \/\/ Dead code: do not need to compute: last_idx -= found_ones;\n+    array_idx--;\n+    element_bits = _bitmap[array_idx];\n+    \/\/ Constant folding:                  bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+    bit_number = BitsPerWord - 1;\n+    \/\/ Constant folding:                  mask = right_n_bits(bit_number + 1);\n+    mask = ~0;\n+  }\n+\n+  \/\/ Add in number of consecutive ones starting with the_bit and including less significant bits and return result\n+  uintx aligned = element_bits << (BitsPerWord - (bit_number + 1));\n+  uintx complement = ~aligned;\n+  return counted_ones + count_leading_zeros<uintx>(complement);\n+}\n+\n+bool ShenandoahSimpleBitMap::is_forward_consecutive_ones(idx_t start_idx, idx_t count) const {\n+  while (count > 0) {\n+    assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition: start_idx: \" SSIZE_FORMAT \", count: \" SSIZE_FORMAT,\n+           start_idx, count);\n+    assert(start_idx + count <= (idx_t) _num_bits, \"precondition\");\n+    size_t array_idx = start_idx >> LogBitsPerWord;\n+    uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+    uintx element_bits = _bitmap[array_idx];\n+    uintx bits_to_examine  = BitsPerWord - bit_number;\n+    element_bits >>= bit_number;\n+    uintx complement = ~element_bits;\n+    uintx trailing_ones;\n+    if (complement != 0) {\n+      trailing_ones = count_trailing_zeros<uintx>(complement);\n+    } else {\n+      trailing_ones = bits_to_examine;\n+    }\n+    if (trailing_ones >= (uintx) count) {\n+      return true;\n+    } else if (trailing_ones == bits_to_examine) {\n+      start_idx += bits_to_examine;\n+      count -= bits_to_examine;\n+      \/\/ Repeat search with smaller goal\n+    } else {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool ShenandoahSimpleBitMap::is_backward_consecutive_ones(idx_t last_idx, idx_t count) const {\n+  while (count > 0) {\n+    assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+    assert(last_idx - count >= -1, \"precondition\");\n+    size_t array_idx = last_idx >> LogBitsPerWord;\n+    uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+    uintx element_bits = _bitmap[array_idx];\n+    uintx bits_to_examine = bit_number + 1;\n+    element_bits <<= (BitsPerWord - bits_to_examine);\n+    uintx complement = ~element_bits;\n+    uintx leading_ones;\n+    if (complement != 0) {\n+      leading_ones = count_leading_zeros<uintx>(complement);\n+    } else {\n+      leading_ones = bits_to_examine;\n+    }\n+    if (leading_ones >= (uintx) count) {\n+      return true;\n+    } else if (leading_ones == bits_to_examine) {\n+      last_idx -= leading_ones;\n+      count -= leading_ones;\n+      \/\/ Repeat search with smaller goal\n+    } else {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+idx_t ShenandoahSimpleBitMap::find_first_consecutive_set_bits(idx_t beg, idx_t end, size_t num_bits) const {\n+  assert((beg >= 0) && (beg < _num_bits), \"precondition\");\n+\n+  \/\/ Stop looking if there are not num_bits remaining in probe space.\n+  idx_t start_boundary = end - num_bits;\n+  if (beg > start_boundary) {\n+    return end;\n+  }\n+  uintx array_idx = beg >> LogBitsPerWord;\n+  uintx bit_number = beg & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n+  if (bit_number > 0) {\n+    uintx mask_out = right_n_bits(bit_number);\n+    element_bits &= ~mask_out;\n+  }\n+\n+  \/\/ The following loop minimizes the number of spans probed in order to find num_bits consecutive bits.\n+  \/\/ For example, if bit_number = beg = 0, num_bits = 8, and element bits equals 00111111_11000000_00000000_10011000B,\n+  \/\/ we need only 3 probes to find the match at bit offset 22.\n+  \/\/\n+  \/\/ Let beg = 0\n+  \/\/ element_bits = 00111111_11000000_00000000_10011000B;\n+  \/\/                                           ________   (the searched span)\n+  \/\/                                           ^   ^  ^- bit_number = beg = 0\n+  \/\/                                           |   +-- next_start_candidate_1 (where next 1 is found)\n+  \/\/                                           +------ next_start_candidate_2 (start of the trailing 1s within span)\n+  \/\/ Let beg = 7\n+  \/\/ element_bits = 00111111_11000000_00000000_10011000B;\n+  \/\/                          ^       ^_________   (the searched span)\n+  \/\/                          |       |        ^- bit_number = beg = 7\n+  \/\/                          |       +---------- next_start_candidate_2 (there are no trailing 1s within span)\n+  \/\/                          +------------------ next_start_candidate_1 (where next 1 is found)\n+  \/\/ Let beg = 22\n+  \/\/ Let beg = 22\n+  \/\/ element_bits = 00111111_11000001_11111100_10011000B;\n+  \/\/                  _________   (the searched span)\n+  \/\/                          ^- bit_number = beg = 18\n+  \/\/ Here, is_forward_consecutive_ones(22, 8) succeeds and we report the match\n+\n+  while (true) {\n+    if (element_bits == 0) {\n+      \/\/ move to the next element\n+      beg += BitsPerWord - bit_number;\n+      if (beg > start_boundary) {\n+        \/\/ No match found.\n+        return end;\n+      }\n+      array_idx++;\n+      bit_number = 0;\n+      element_bits = _bitmap[array_idx];\n+    } else if (is_forward_consecutive_ones(beg, num_bits)) {\n+      return beg;\n+    } else {\n+      \/\/ There is at least one non-zero bit within the masked element_bits. Arrange to skip over bits that\n+      \/\/ cannot be part of a consecutive-ones match.\n+      uintx next_set_bit = count_trailing_zeros<uintx>(element_bits);\n+      uintx next_start_candidate_1 = (array_idx << LogBitsPerWord) + next_set_bit;\n+\n+      \/\/ There is at least one zero bit in this span. Align the next probe at the start of trailing ones for probed span,\n+      \/\/ or align at end of span if this span has no trailing ones.\n+      size_t trailing_ones = count_trailing_ones(beg + num_bits - 1);\n+      uintx next_start_candidate_2 = beg + num_bits - trailing_ones;\n+\n+      beg = MAX2(next_start_candidate_1, next_start_candidate_2);\n+      if (beg > start_boundary) {\n+        \/\/ No match found.\n+        return end;\n+      }\n+      array_idx = beg >> LogBitsPerWord;\n+      element_bits = _bitmap[array_idx];\n+      bit_number = beg & right_n_bits(LogBitsPerWord);\n+      if (bit_number > 0) {\n+        size_t mask_out = right_n_bits(bit_number);\n+        element_bits &= ~mask_out;\n+      }\n+    }\n+  }\n+}\n+\n+idx_t ShenandoahSimpleBitMap::find_last_consecutive_set_bits(const idx_t beg, idx_t end, const size_t num_bits) const {\n+\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+\n+  \/\/ Stop looking if there are not num_bits remaining in probe space.\n+  idx_t last_boundary = beg + num_bits;\n+  if (end < last_boundary) {\n+    return beg;\n+  }\n+\n+  size_t array_idx = end >> LogBitsPerWord;\n+  uintx bit_number = end & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n+  if (bit_number < BitsPerWord - 1) {\n+    uintx mask_in = right_n_bits(bit_number + 1);\n+    element_bits &= mask_in;\n+  }\n+\n+  \/\/ See comment in find_first_consecutive_set_bits to understand how this loop works.\n+  while (true) {\n+    if (element_bits == 0) {\n+      \/\/ move to the previous element\n+      end -= bit_number + 1;\n+      if (end < last_boundary) {\n+        \/\/ No match found.\n+        return beg;\n+      }\n+      array_idx--;\n+      bit_number = BitsPerWord - 1;\n+      element_bits = _bitmap[array_idx];\n+    } else if (is_backward_consecutive_ones(end, num_bits)) {\n+      return end + 1 - num_bits;\n+    } else {\n+      \/\/ There is at least one non-zero bit within the masked element_bits. Arrange to skip over bits that\n+      \/\/ cannot be part of a consecutive-ones match.\n+      uintx next_set_bit = BitsPerWord - (1 + count_leading_zeros<uintx>(element_bits));\n+      uintx next_last_candidate_1 = (array_idx << LogBitsPerWord) + next_set_bit;\n+\n+      \/\/ There is at least one zero bit in this span.  Align the next probe at the end of leading ones for probed span,\n+      \/\/ or align before start of span if this span has no leading ones.\n+      size_t leading_ones = count_leading_ones(end - (num_bits - 1));\n+      uintx next_last_candidate_2 = end - (num_bits - leading_ones);\n+\n+      end = MIN2(next_last_candidate_1, next_last_candidate_2);\n+      if (end < last_boundary) {\n+        \/\/ No match found.\n+        return beg;\n+      }\n+      array_idx = end >> LogBitsPerWord;\n+      bit_number = end & right_n_bits(LogBitsPerWord);\n+      element_bits = _bitmap[array_idx];\n+      if (bit_number < BitsPerWord - 1){\n+        size_t mask_in = right_n_bits(bit_number + 1);\n+        element_bits &= mask_in;\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.cpp","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_HPP\n+\n+#include <cstddef>\n+\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+\n+\/\/ TODO: Merge the enhanced capabilities of ShenandoahSimpleBitMap into src\/hotspot\/share\/utilities\/bitMap.hpp\n+\/\/       and deprecate ShenandoahSimpleBitMap.  The key enhanced capabilities to be integrated include:\n+\/\/\n+\/\/   1. Allow searches from high to low memory (when biasing allocations towards the top of the heap)\n+\/\/   2. Allow searches for clusters of contiguous set bits (to expedite allocation for humongous objects)\n+\/\/\n+\/\/ idx_t is defined here as ssize_t.  In src\/hotspot\/share\/utiliities\/bitMap.hpp, idx is defined as size_t.\n+\/\/ This is a significant incompatibility.\n+\/\/\n+\/\/ The API and internal implementation of ShenandoahSimpleBitMap and ShenandoahRegionPartitions use idx_t to\n+\/\/ represent index, even though index is \"inherently\" unsigned.  There are two reasons for this choice:\n+\/\/  1. We use -1 as a sentinel value to represent empty partitions.  This same value may be used to represent\n+\/\/     failure to find a previous set bit or previous range of set bits.\n+\/\/  2. Certain loops are written most naturally if the iterator, which may hold the sentinel -1 value, can be\n+\/\/     declared as signed and the terminating condition can be < 0.\n+\n+typedef ssize_t idx_t;\n+\n+\/\/ ShenandoahSimpleBitMap resembles CHeapBitMap but adds missing support for find_first_consecutive_set_bits() and\n+\/\/ find_last_consecutive_set_bits.  An alternative refactoring of code would subclass CHeapBitMap, but this might\n+\/\/ break abstraction rules, because efficient implementation requires assumptions about superclass internals that\n+\/\/ might be violatee through future software maintenance.\n+class ShenandoahSimpleBitMap {\n+  const idx_t _num_bits;\n+  const size_t _num_words;\n+  uintx* const _bitmap;\n+\n+public:\n+  ShenandoahSimpleBitMap(size_t num_bits);\n+\n+  ~ShenandoahSimpleBitMap();\n+\n+  void clear_all() {\n+    for (size_t i = 0; i < _num_words; i++) {\n+      _bitmap[i] = 0;\n+    }\n+  }\n+\n+private:\n+\n+  \/\/ Count consecutive ones in forward order, starting from start_idx.  Requires that there is at least one zero\n+  \/\/ between start_idx and index value (_num_bits - 1), inclusive.\n+  size_t count_leading_ones(idx_t start_idx) const;\n+\n+  \/\/ Count consecutive ones in reverse order, starting from last_idx.  Requires that there is at least one zero\n+  \/\/ between last_idx and index value zero, inclusive.\n+  size_t count_trailing_ones(idx_t last_idx) const;\n+\n+  bool is_forward_consecutive_ones(idx_t start_idx, idx_t count) const;\n+  bool is_backward_consecutive_ones(idx_t last_idx, idx_t count) const;\n+\n+public:\n+\n+  inline idx_t aligned_index(idx_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    idx_t array_idx = idx & ~right_n_bits(LogBitsPerWord);\n+    return array_idx;\n+  }\n+\n+  inline constexpr idx_t alignment() const {\n+    return BitsPerWord;\n+  }\n+\n+  \/\/ For testing\n+  inline idx_t size() const {\n+    return _num_bits;\n+  }\n+\n+  \/\/ Return the word that holds idx bit and its neighboring bits.\n+  inline uintx bits_at(idx_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    idx_t array_idx = idx >> LogBitsPerWord;\n+    return _bitmap[array_idx];\n+  }\n+\n+  inline void set_bit(idx_t idx) {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n+    _bitmap[array_idx] |= the_bit;\n+  }\n+\n+  inline void clear_bit(idx_t idx) {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    assert(idx >= 0, \"precondition\");\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n+    _bitmap[array_idx] &= ~the_bit;\n+  }\n+\n+  inline bool is_set(idx_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    assert(idx >= 0, \"precondition\");\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n+    return (_bitmap[array_idx] & the_bit)? true: false;\n+  }\n+\n+  \/\/ Return the index of the first set bit in the range [beg, size()), or size() if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_first_set_bit(idx_t beg) const;\n+\n+  \/\/ Return the index of the first set bit in the range [beg, end), or end if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_first_set_bit(idx_t beg, idx_t end) const;\n+\n+  \/\/ Return the index of the last set bit in the range (-1, end], or -1 if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_last_set_bit(idx_t end) const;\n+\n+  \/\/ Return the index of the last set bit in the range (beg, end], or beg if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_last_set_bit(idx_t beg, idx_t end) const;\n+\n+  \/\/ Return the start index of the first run of <num_bits> consecutive set bits for which the first set bit is within\n+  \/\/   the range [beg, size()), or size() if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: beg is within the valid range for the bitmap.\n+  inline idx_t find_first_consecutive_set_bits(idx_t beg, size_t num_bits) const;\n+\n+  \/\/ Return the start index of the first run of <num_bits> consecutive set bits for which the first set bit is within\n+  \/\/   the range [beg, end), or end if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  idx_t find_first_consecutive_set_bits(idx_t beg, idx_t end, size_t num_bits) const;\n+\n+  \/\/ Return the start index of the last run of <num_bits> consecutive set bits for which the entire run of set bits is within\n+  \/\/ the range (-1, end], or -1 if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: end is within the valid range for the bitmap.\n+  inline idx_t find_last_consecutive_set_bits(idx_t end, size_t num_bits) const;\n+\n+  \/\/ Return the start index of the first run of <num_bits> consecutive set bits for which the entire run of set bits is within\n+  \/\/ the range (beg, end], or beg if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  idx_t find_last_consecutive_set_bits(idx_t beg, idx_t end, size_t num_bits) const;\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.hpp","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_INLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_INLINE_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+\n+inline idx_t ShenandoahSimpleBitMap::find_first_set_bit(idx_t beg, idx_t end) const {\n+  assert((beg >= 0) && (beg < _num_bits), \"precondition\");\n+  assert((end > beg) && (end <= _num_bits), \"precondition\");\n+  do {\n+    size_t array_idx = beg >> LogBitsPerWord;\n+    uintx bit_number = beg & right_n_bits(LogBitsPerWord);\n+    uintx element_bits = _bitmap[array_idx];\n+    if (bit_number > 0) {\n+      uintx mask_out = right_n_bits(bit_number);\n+      element_bits &= ~mask_out;\n+    }\n+    if (element_bits) {\n+      \/\/ The next set bit is here.  Find first set bit >= bit_number;\n+      uintx aligned = element_bits >> bit_number;\n+      uintx first_set_bit = count_trailing_zeros<uintx>(aligned);\n+      idx_t candidate_result = (array_idx * BitsPerWord) + bit_number + first_set_bit;\n+      return (candidate_result < end)? candidate_result: end;\n+    } else {\n+      \/\/ Next bit is not here.  Try the next array element\n+      beg += BitsPerWord - bit_number;\n+    }\n+  } while (beg < end);\n+  return end;\n+}\n+\n+inline idx_t ShenandoahSimpleBitMap::find_first_set_bit(idx_t beg) const {\n+  assert((beg >= 0) && (beg < size()), \"precondition\");\n+  return find_first_set_bit(beg, size());\n+}\n+\n+inline idx_t ShenandoahSimpleBitMap::find_last_set_bit(idx_t beg, idx_t end) const {\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+  assert((beg >= -1) && (beg < end), \"precondition\");\n+  do {\n+    idx_t array_idx = end >> LogBitsPerWord;\n+    uintx bit_number = end & right_n_bits(LogBitsPerWord);\n+    uintx element_bits = _bitmap[array_idx];\n+    if (bit_number < BitsPerWord - 1){\n+      uintx mask_in = right_n_bits(bit_number + 1);\n+      element_bits &= mask_in;\n+    }\n+    if (element_bits) {\n+      \/\/ The prev set bit is here.  Find the first set bit <= bit_number\n+      uintx aligned = element_bits << (BitsPerWord - (bit_number + 1));\n+      uintx first_set_bit = count_leading_zeros<uintx>(aligned);\n+      idx_t candidate_result = array_idx * BitsPerWord + (bit_number - first_set_bit);\n+      return (candidate_result > beg)? candidate_result: beg;\n+    } else {\n+      \/\/ Next bit is not here.  Try the previous array element\n+      end -= (bit_number + 1);\n+    }\n+  } while (end > beg);\n+  return beg;\n+}\n+\n+inline idx_t ShenandoahSimpleBitMap::find_last_set_bit(idx_t end) const {\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+  return find_last_set_bit(-1, end);\n+}\n+\n+inline idx_t ShenandoahSimpleBitMap::find_first_consecutive_set_bits(idx_t beg, size_t num_bits) const {\n+  assert((beg >= 0) && (beg < _num_bits), \"precondition\");\n+  return find_first_consecutive_set_bits(beg, size(), num_bits);\n+}\n+\n+inline idx_t ShenandoahSimpleBitMap::find_last_consecutive_set_bits(idx_t end, size_t num_bits) const {\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+  return find_last_consecutive_set_bits((idx_t) -1, end, num_bits);\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -429,2 +429,4 @@\n-              \"%s: generation (%s) size spanned by regions (\" SIZE_FORMAT \") must not exceed current capacity (\" PROPERFMT \")\",\n-              label, generation->name(), stats.regions(), PROPERFMTARGS(generation_capacity));\n+              \"%s: generation (%s) size spanned by regions (\" SIZE_FORMAT \") * region size: \" PROPERFMT\n+              \" must not exceed current capacity (\" PROPERFMT \")\",\n+              label, generation->name(), stats.regions(), PROPERFMTARGS(ShenandoahHeapRegion::region_size_bytes()),\n+              PROPERFMTARGS(generation_capacity));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,13 +52,0 @@\n-  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n-\n-  \/\/ Clear leading 32 bits, if necessary.\n-  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n-  if (!is_aligned(base_offset, HeapWordSize)) {\n-    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n-    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n-    base_offset += BytesPerInt;\n-  }\n-  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n-\n-  const size_t header = heap_word_size(base_offset);\n-  const size_t payload_size = _word_size - header;\n@@ -66,1 +53,1 @@\n-  if (payload_size <= segment_max) {\n+  if (_word_size <= segment_max) {\n@@ -91,0 +78,16 @@\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(element_type);\n+  const size_t process_start_offset_in_bytes = align_up(base_offset_in_bytes, BytesPerWord);\n+\n+  if (process_start_offset_in_bytes != base_offset_in_bytes) {\n+    \/\/ initialize_memory can only fill word aligned memory,\n+    \/\/ fill the first 4 bytes here.\n+    assert(process_start_offset_in_bytes - base_offset_in_bytes == 4, \"Must be 4-byte aligned\");\n+    assert(!is_reference_type(element_type), \"Only TypeArrays can be 4-byte aligned\");\n+    *reinterpret_cast<int*>(reinterpret_cast<char*>(mem) + base_offset_in_bytes) = 0;\n+  }\n+\n+  \/\/ Note: initialize_memory may clear padding bytes at the end\n+  const size_t process_start_offset = ZUtils::bytes_to_words(process_start_offset_in_bytes);\n+  const size_t process_size = _word_size - process_start_offset;\n+\n@@ -103,1 +106,1 @@\n-    for (size_t processed = 0; processed < payload_size; processed += segment_max) {\n+    for (size_t processed = 0; processed < process_size; processed += segment_max) {\n@@ -105,2 +108,2 @@\n-      uintptr_t* const start = (uintptr_t*)(mem + header + processed);\n-      const size_t remaining = payload_size - processed;\n+      uintptr_t* const start = (uintptr_t*)(mem + process_start_offset + processed);\n+      const size_t remaining = process_size - processed;\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  RetryableAllocationMark(JavaThread* thread, bool activate) : _iom(activate ? thread : nullptr) {}\n+  RetryableAllocationMark(JavaThread* thread) : _iom(thread) {}\n@@ -120,1 +120,1 @@\n-JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* current, Klass* klass, bool null_on_fail))\n+JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_or_null(JavaThread* current, Klass* klass))\n@@ -126,1 +126,1 @@\n-    RetryableAllocationMark ram(current, null_on_fail);\n+    RetryableAllocationMark ram(current);\n@@ -128,10 +128,5 @@\n-    oop obj;\n-    if (null_on_fail) {\n-      if (!h->is_initialized()) {\n-        \/\/ Cannot re-execute class initialization without side effects\n-        \/\/ so return without attempting the initialization\n-        return;\n-      }\n-    } else {\n-      \/\/ make sure klass is initialized\n-      h->initialize(CHECK);\n+    if (!h->is_initialized()) {\n+      \/\/ Cannot re-execute class initialization without side effects\n+      \/\/ so return without attempting the initialization\n+      current->set_vm_result(nullptr);\n+      return;\n@@ -140,1 +135,1 @@\n-    obj = h->allocate_instance(CHECK);\n+    oop obj = h->allocate_instance(CHECK);\n@@ -147,1 +142,1 @@\n-JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* current, Klass* array_klass, jint length, bool null_on_fail))\n+JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_or_null(JavaThread* current, Klass* array_klass, jint length))\n@@ -156,1 +151,1 @@\n-    RetryableAllocationMark ram(current, null_on_fail);\n+    RetryableAllocationMark ram(current);\n@@ -161,1 +156,1 @@\n-    RetryableAllocationMark ram(current, null_on_fail);\n+    RetryableAllocationMark ram(current);\n@@ -168,1 +163,0 @@\n-    \/\/ Alternate between deoptimizing and raising an error (which will also cause a deopt)\n@@ -170,7 +164,2 @@\n-      if (null_on_fail) {\n-        \/\/ Drop the allocation\n-        obj = nullptr;\n-      } else {\n-        ResourceMark rm(current);\n-        THROW(vmSymbols::java_lang_OutOfMemoryError());\n-      }\n+      \/\/ Drop the allocation\n+      obj = nullptr;\n@@ -186,1 +175,1 @@\n-JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* current, Klass* klass, int rank, jint* dims, bool null_on_fail))\n+JRT_ENTRY(void, JVMCIRuntime::new_multi_array_or_null(JavaThread* current, Klass* klass, int rank, jint* dims))\n@@ -190,1 +179,1 @@\n-  RetryableAllocationMark ram(current, null_on_fail);\n+  RetryableAllocationMark ram(current);\n@@ -195,2 +184,2 @@\n-JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* current, oopDesc* element_mirror, jint length, bool null_on_fail))\n-  RetryableAllocationMark ram(current, null_on_fail);\n+JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_or_null(JavaThread* current, oopDesc* element_mirror, jint length))\n+  RetryableAllocationMark ram(current);\n@@ -201,1 +190,1 @@\n-JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* current, oopDesc* type_mirror, bool null_on_fail))\n+JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_or_null(JavaThread* current, oopDesc* type_mirror))\n@@ -208,1 +197,1 @@\n-  RetryableAllocationMark ram(current, null_on_fail);\n+  RetryableAllocationMark ram(current);\n@@ -213,9 +202,5 @@\n-  if (null_on_fail) {\n-    if (!klass->is_initialized()) {\n-      \/\/ Cannot re-execute class initialization without side effects\n-      \/\/ so return without attempting the initialization\n-      return;\n-    }\n-  } else {\n-    \/\/ Make sure klass gets initialized\n-    klass->initialize(CHECK);\n+  if (!klass->is_initialized()) {\n+    \/\/ Cannot re-execute class initialization without side effects\n+    \/\/ so return without attempting the initialization\n+    current->set_vm_result(nullptr);\n+    return;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":25,"deletions":40,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -507,6 +507,0 @@\n-  static void new_instance_common(JavaThread* current, Klass* klass, bool null_on_fail);\n-  static void new_array_common(JavaThread* current, Klass* klass, jint length, bool null_on_fail);\n-  static void new_multi_array_common(JavaThread* current, Klass* klass, int rank, jint* dims, bool null_on_fail);\n-  static void dynamic_new_array_common(JavaThread* current, oopDesc* element_mirror, jint length, bool null_on_fail);\n-  static void dynamic_new_instance_common(JavaThread* current, oopDesc* type_mirror, bool null_on_fail);\n-\n@@ -515,20 +509,8 @@\n-  \/\/ When allocation fails, these stubs:\n-  \/\/ 1. Exercise -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError handling and also\n-  \/\/    post a JVMTI_EVENT_RESOURCE_EXHAUSTED event if the failure is an OutOfMemroyError\n-  \/\/ 2. Return null with a pending exception.\n-  \/\/ Compiled code must ensure these stubs are not called twice for the same allocation\n-  \/\/ site due to the non-repeatable side effects in the case of OOME.\n-  static void new_instance(JavaThread* current, Klass* klass) { new_instance_common(current, klass, false); }\n-  static void new_array(JavaThread* current, Klass* klass, jint length) { new_array_common(current, klass, length, false); }\n-  static void new_multi_array(JavaThread* current, Klass* klass, int rank, jint* dims) { new_multi_array_common(current, klass, rank, dims, false); }\n-  static void dynamic_new_array(JavaThread* current, oopDesc* element_mirror, jint length) { dynamic_new_array_common(current, element_mirror, length, false); }\n-  static void dynamic_new_instance(JavaThread* current, oopDesc* type_mirror) { dynamic_new_instance_common(current, type_mirror, false); }\n-\n-  \/\/ When allocation fails, these stubs return null and have no pending exception. Compiled code\n-  \/\/ can use these stubs if a failed allocation will be retried (e.g., by deoptimizing and\n-  \/\/ re-executing in the interpreter).\n-  static void new_instance_or_null(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, true); }\n-  static void new_array_or_null(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, true); }\n-  static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, true); }\n-  static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, true); }\n-  static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, true); }\n+  \/\/ When allocation fails, these stubs return null and have no pending OutOfMemoryError exception.\n+  \/\/ Compiled code can use these stubs if a failed allocation will be retried (e.g., by deoptimizing\n+  \/\/ and re-executing in the interpreter).\n+  static void new_instance_or_null(JavaThread* thread, Klass* klass);\n+  static void new_array_or_null(JavaThread* thread, Klass* klass, jint length);\n+  static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims);\n+  static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length);\n+  static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -254,0 +254,2 @@\n+  nonstatic_field(Klass,                       _bitmap,                                       uintx)                                 \\\n+  nonstatic_field(Klass,                       _hash_slot,                                    uint8_t)                               \\\n@@ -384,0 +386,1 @@\n+  static_field(StubRoutines,                _lookup_secondary_supers_table_slow_path_stub,    address)                               \\\n@@ -803,33 +806,27 @@\n-  declare_function(JVMCIRuntime::new_instance) \\\n-  declare_function(JVMCIRuntime::new_array) \\\n-  declare_function(JVMCIRuntime::new_multi_array) \\\n-  declare_function(JVMCIRuntime::dynamic_new_array) \\\n-  declare_function(JVMCIRuntime::dynamic_new_instance) \\\n-  \\\n-  declare_function(JVMCIRuntime::new_instance_or_null) \\\n-  declare_function(JVMCIRuntime::new_array_or_null) \\\n-  declare_function(JVMCIRuntime::new_multi_array_or_null) \\\n-  declare_function(JVMCIRuntime::dynamic_new_array_or_null) \\\n-  declare_function(JVMCIRuntime::dynamic_new_instance_or_null) \\\n-  \\\n-  declare_function(JVMCIRuntime::invoke_static_method_one_arg) \\\n-  \\\n-  declare_function(JVMCIRuntime::vm_message) \\\n-  declare_function(JVMCIRuntime::identity_hash_code) \\\n-  declare_function(JVMCIRuntime::exception_handler_for_pc) \\\n-  declare_function(JVMCIRuntime::monitorenter) \\\n-  declare_function(JVMCIRuntime::monitorexit) \\\n-  declare_function(JVMCIRuntime::object_notify) \\\n-  declare_function(JVMCIRuntime::object_notifyAll) \\\n-  declare_function(JVMCIRuntime::throw_and_post_jvmti_exception) \\\n-  declare_function(JVMCIRuntime::throw_klass_external_name_exception) \\\n-  declare_function(JVMCIRuntime::throw_class_cast_exception) \\\n-  declare_function(JVMCIRuntime::log_primitive) \\\n-  declare_function(JVMCIRuntime::log_object) \\\n-  declare_function(JVMCIRuntime::log_printf) \\\n-  declare_function(JVMCIRuntime::vm_error) \\\n-  declare_function(JVMCIRuntime::load_and_clear_exception) \\\n-  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_pre)) \\\n-  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_post)) \\\n-  declare_function(JVMCIRuntime::validate_object) \\\n-  \\\n+  declare_function(JVMCIRuntime::new_instance_or_null)                    \\\n+  declare_function(JVMCIRuntime::new_array_or_null)                       \\\n+  declare_function(JVMCIRuntime::new_multi_array_or_null)                 \\\n+  declare_function(JVMCIRuntime::dynamic_new_array_or_null)               \\\n+  declare_function(JVMCIRuntime::dynamic_new_instance_or_null)            \\\n+                                                                          \\\n+  declare_function(JVMCIRuntime::invoke_static_method_one_arg)            \\\n+                                                                          \\\n+  declare_function(JVMCIRuntime::vm_message)                              \\\n+  declare_function(JVMCIRuntime::identity_hash_code)                      \\\n+  declare_function(JVMCIRuntime::exception_handler_for_pc)                \\\n+  declare_function(JVMCIRuntime::monitorenter)                            \\\n+  declare_function(JVMCIRuntime::monitorexit)                             \\\n+  declare_function(JVMCIRuntime::object_notify)                           \\\n+  declare_function(JVMCIRuntime::object_notifyAll)                        \\\n+  declare_function(JVMCIRuntime::throw_and_post_jvmti_exception)          \\\n+  declare_function(JVMCIRuntime::throw_klass_external_name_exception)     \\\n+  declare_function(JVMCIRuntime::throw_class_cast_exception)              \\\n+  declare_function(JVMCIRuntime::log_primitive)                           \\\n+  declare_function(JVMCIRuntime::log_object)                              \\\n+  declare_function(JVMCIRuntime::log_printf)                              \\\n+  declare_function(JVMCIRuntime::vm_error)                                \\\n+  declare_function(JVMCIRuntime::load_and_clear_exception)                \\\n+  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_pre))            \\\n+  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_post))           \\\n+  declare_function(JVMCIRuntime::validate_object)                         \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":30,"deletions":33,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -814,8 +814,0 @@\n-  \/\/ Clear the flags related to compiler directives that were set by the compilerBroker,\n-  \/\/ because the directives can be updated.\n-  void clear_directive_flags() {\n-    set_has_matching_directives(false);\n-    clear_is_not_c1_compilable();\n-    clear_is_not_c2_compilable();\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-   status(has_matching_directives     , 1 << 16) \/* Temporary mark, used only when methods are to be refreshed to reflect a compiler directives update *\/ \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -216,7 +216,1 @@\n-  \/\/ But here we have to pay extra attention:\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n-  if (!_range_check_dependency) {\n-    res = widen_type(phase, res, T_INT);\n-  }\n+  res = widen_type(phase, res, T_INT);\n@@ -242,1 +236,1 @@\n-  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n@@ -246,1 +240,1 @@\n-  if (!_range_check_dependency) {\n+  if (!_type->is_int()->empty()) {\n@@ -257,7 +251,0 @@\n-  if (_range_check_dependency) {\n-    if (phase->C->post_loop_opts_phase()) {\n-      return this->in(1);\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3467,0 +3467,4 @@\n+  case Op_CastII: {\n+    remove_range_check_cast(n->as_CastII());\n+  }\n+  break;\n@@ -3618,10 +3622,0 @@\n-#ifdef ASSERT\n-  case Op_CastII:\n-    \/\/ Verify that all range check dependent CastII nodes were removed.\n-    if (n->isa_CastII()->has_range_check()) {\n-      n->dump(3);\n-      assert(false, \"Range check dependent CastII node was not removed\");\n-    }\n-    break;\n-#endif\n-\n@@ -3636,0 +3630,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -3656,0 +3652,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -3676,0 +3674,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -3696,0 +3696,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -3897,0 +3899,28 @@\n+void Compile::remove_range_check_cast(CastIINode* cast) {\n+  if (cast->has_range_check()) {\n+    \/\/ Range check CastII nodes feed into an address computation subgraph. Remove them to let that subgraph float freely.\n+    \/\/ For memory access or integer divisions nodes that depend on the cast, record the dependency on the cast's control\n+    \/\/ as a precedence edge, so they can't float above the cast in case that cast's narrowed type helped eliminate a\n+    \/\/ range check or a null divisor check.\n+    assert(cast->in(0) != nullptr, \"All RangeCheck CastII must have a control dependency\");\n+    ResourceMark rm;\n+    Unique_Node_List wq;\n+    wq.push(cast);\n+    for (uint next = 0; next < wq.size(); ++next) {\n+      Node* m = wq.at(next);\n+      for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n+        Node* use = m->fast_out(i);\n+        if (use->is_Mem() || use->is_div_or_mod(T_INT) || use->is_div_or_mod(T_LONG)) {\n+          use->ensure_control_or_add_prec(cast->in(0));\n+        } else if (!use->is_CFG() && !use->is_Phi()) {\n+          wq.push(use);\n+        }\n+      }\n+    }\n+    cast->subsume_by(cast->in(1), this);\n+    if (cast->outcnt() == 0) {\n+      cast->disconnect_inputs(this);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+class CastIINode;\n@@ -1317,0 +1318,2 @@\n+\n+  void remove_range_check_cast(CastIINode* cast);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1471,0 +1471,3 @@\n+  if (!tst->is_Con()) {\n+    record_for_igvn(iff);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,2 +52,3 @@\n-  if (n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::LONG) {\n-    \/\/ ConvI2L may have type information on it which is unsafe to push up\n+  if ((n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::LONG) ||\n+      (n->Opcode() == Op_ConvL2I && n->bottom_type() != TypeInt::INT)) {\n+    \/\/ ConvI2L\/ConvL2I may have type information on it which is unsafe to push up\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2881,0 +2881,9 @@\n+void Node::add_prec_from(Node* n) {\n+  for (uint i = n->req(); i < n->len(); i++) {\n+    Node* prec = n->in(i);\n+    if (prec != nullptr) {\n+      add_prec(prec);\n+    }\n+  }\n+}\n+\n@@ -2904,0 +2913,3 @@\n+bool Node::is_div_or_mod(BasicType bt) const { return Opcode() == Op_Div(bt) || Opcode() == Op_Mod(bt) ||\n+                                                      Opcode() == Op_UDiv(bt) || Opcode() == Op_UMod(bt); }\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1146,0 +1146,1 @@\n+  void add_prec_from(Node* n);\n@@ -1257,0 +1258,2 @@\n+  bool is_div_or_mod(BasicType bt) const;\n+\n@@ -2026,0 +2029,4 @@\n+Op_IL(Div)\n+Op_IL(Mod)\n+Op_IL(UDiv)\n+Op_IL(UMod)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -545,1 +545,1 @@\n-          \"(also see FullGCHeapDumpLimit)\")                                 \\\n+          \"(also see FullGCHeapDumpLimit, HeapDumpPath, HeapDumpGzipLevel)\")\\\n@@ -549,1 +549,1 @@\n-          \"(also see FullGCHeapDumpLimit)\")                                 \\\n+          \"(also see FullGCHeapDumpLimit, HeapDumpPath, HeapDumpGzipLevel)\")\\\n@@ -558,1 +558,2 @@\n-          \"from JVM\")                                                       \\\n+          \"from JVM \"                                                       \\\n+          \"(also see HeapDumpPath, HeapDumpGzipLevel)\")                     \\\n@@ -561,1 +562,2 @@\n-          \"When HeapDumpOnOutOfMemoryError is on, the path (filename or \"   \\\n+          \"When HeapDumpOnOutOfMemoryError, HeapDumpBeforeFullGC \"          \\\n+          \"or HeapDumpAfterFullGC is on, the path (filename or \"            \\\n@@ -566,1 +568,2 @@\n-          \"When HeapDumpOnOutOfMemoryError is on, the gzip compression \"    \\\n+          \"When HeapDumpOnOutOfMemoryError, HeapDumpBeforeFullGC \"          \\\n+          \"or HeapDumpAfterFullGC is on, the gzip compression \"             \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+  MUTEX_DEFN(DirectivesStack_lock            , PaddedMutex  , nosafepoint);\n@@ -328,1 +329,0 @@\n-  MUTEX_DEFL(DirectivesStack_lock           , PaddedMutex  , CodeCache_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,0 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesReplaceDCmd>(full_export, true, false));\n@@ -927,3 +926,1 @@\n-  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n+  _filename(\"filename\",\"Name of the directives file\", \"STRING\",true) {\n@@ -931,1 +928,0 @@\n-  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -936,37 +932,0 @@\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches(true);\n-    CodeCache::recompile_marked_directives_matches();\n-  }\n-}\n-\n-CompilerDirectivesReplaceDCmd::CompilerDirectivesReplaceDCmd(outputStream* output, bool heap) :\n-                           DCmdWithParser(output, heap),\n-  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n-  _dcmdparser.add_dcmd_argument(&_filename);\n-  _dcmdparser.add_dcmd_option(&_refresh);\n-}\n-\n-void CompilerDirectivesReplaceDCmd::execute(DCmdSource source, TRAPS) {\n-  \/\/ Need to mark the methods twice, to account for the method that doesn't match\n-  \/\/ the directives anymore\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches();\n-\n-    DirectivesStack::clear();\n-    DirectivesParser::parse_from_file(_filename.value(), output(), true);\n-\n-    CodeCache::mark_directives_matches();\n-    CodeCache::recompile_marked_directives_matches();\n-  } else {\n-    DirectivesStack::clear();\n-    DirectivesParser::parse_from_file(_filename.value(), output(), true);\n-  }\n-}\n-\n-CompilerDirectivesRemoveDCmd::CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) :\n-                           DCmdWithParser(output, heap),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n-  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -976,14 +935,1 @@\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches(true);\n-    DirectivesStack::pop(1);\n-    CodeCache::recompile_marked_directives_matches();\n-  } else {\n-    DirectivesStack::pop(1);\n-  }\n-}\n-\n-CompilerDirectivesClearDCmd::CompilerDirectivesClearDCmd(outputStream* output, bool heap) :\n-                           DCmdWithParser(output, heap),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n-  _dcmdparser.add_dcmd_option(&_refresh);\n+  DirectivesStack::pop(1);\n@@ -993,7 +939,1 @@\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches();\n-    DirectivesStack::clear();\n-    CodeCache::recompile_marked_directives_matches();\n-  } else {\n-    DirectivesStack::clear();\n-  }\n+  DirectivesStack::clear();\n@@ -1001,1 +941,0 @@\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":64,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -691,3 +691,1 @@\n-class CompilerDirectivesRemoveDCmd : public DCmdWithParser {\n-protected:\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n+class CompilerDirectivesRemoveDCmd : public DCmd {\n@@ -695,2 +693,1 @@\n-  static int num_arguments() { return 1; }\n-  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap);\n+  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n@@ -717,1 +714,0 @@\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n@@ -719,1 +715,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 1; }\n@@ -738,27 +734,1 @@\n-class CompilerDirectivesReplaceDCmd : public DCmdWithParser {\n-protected:\n-  DCmdArgument<char*> _filename;\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n-public:\n-  static int num_arguments() { return 2; }\n-  CompilerDirectivesReplaceDCmd(outputStream* output, bool heap);\n-  static const char* name() {\n-    return \"Compiler.directives_replace\";\n-  }\n-  static const char* description() {\n-    return \"Clear directives stack, and load new compiler directives from file.\";\n-  }\n-  static const char* impact() {\n-    return \"Low\";\n-  }\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", NULL};\n-    return p;\n-  }\n-  virtual void execute(DCmdSource source, TRAPS);\n-};\n-\n-class CompilerDirectivesClearDCmd : public DCmdWithParser {\n-protected:\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n+class CompilerDirectivesClearDCmd : public DCmd {\n@@ -766,2 +736,1 @@\n-  static int num_arguments() { return 1; }\n-  CompilerDirectivesClearDCmd(outputStream* output, bool heap);\n+  CompilerDirectivesClearDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":5,"deletions":36,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -65,0 +65,5 @@\n+ * Operations that format strings are locale sensitive, using either the\n+ * specified {@code Locale}, or the\n+ * {@link Locale##default_locale default format Locale} to produce localized\n+ * formatted strings.\n+ * <p>\n@@ -150,1 +155,37 @@\n-     * the specified format string and arguments.\n+     * the specified format string and arguments with the\n+     * {@link Locale##default_locale default format locale}.\n+     *\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n+     *\n+     * @param  args\n+     *         Arguments referenced by the format specifiers in the format\n+     *         string.  If there are more arguments than format specifiers, the\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n+     *         limited by the maximum dimension of a Java array as defined by\n+     *         <cite>The Java Virtual Machine Specification<\/cite>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n+     *\n+     * @throws  IllegalFormatException\n+     *          If a format string contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          insufficient arguments given the format string, or other\n+     *          illegal conditions.  For specification of all possible\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section\n+     *          of the formatter class specification.\n+     *\n+     * @return  This console\n+     *\/\n+    public Console format(String format, Object ... args) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Writes a formatted string to this console's output stream using\n+     * the specified format string and arguments with the specified\n+     * {@code locale}.\n@@ -152,3 +193,7 @@\n-     * @param  fmt\n-     *         A format string as described in <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">Format string syntax<\/a>.\n+     * @param  locale The {@linkplain Locale locale} to apply during\n+     *         formatting.  If {@code locale} is {@code null} then no localization\n+     *         is applied.\n+     *\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n@@ -163,3 +208,3 @@\n-     *         The behaviour on a\n-     *         {@code null} argument depends on the <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">conversion<\/a>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n@@ -172,2 +217,2 @@\n-     *          formatting errors, see the <a\n-     *          href=\"..\/util\/Formatter.html#detail\">Details<\/a> section\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section\n@@ -177,0 +222,1 @@\n+     * @since   23\n@@ -178,1 +224,1 @@\n-    public Console format(String fmt, Object ...args) {\n+    public Console format(Locale locale, String format, Object ... args) {\n@@ -184,1 +230,2 @@\n-     * output stream using the specified format string and arguments.\n+     * output stream using the specified format string and arguments with\n+     * the {@link Locale##default_locale default format locale}.\n@@ -186,6 +233,1 @@\n-     * <p> An invocation of this method of the form\n-     * {@code con.printf(format, args)} behaves in exactly the same way\n-     * as the invocation of\n-     * {@snippet lang=java :\n-     *     con.format(format, args)\n-     * }\n+     * @implSpec This is the same as calling {@code format(format, args)}.\n@@ -194,2 +236,2 @@\n-     *         A format string as described in <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">Format string syntax<\/a>.\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n@@ -204,3 +246,3 @@\n-     *         The behaviour on a\n-     *         {@code null} argument depends on the <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">conversion<\/a>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n@@ -213,2 +255,2 @@\n-     *          formatting errors, see the <a\n-     *          href=\"..\/util\/Formatter.html#detail\">Details<\/a> section of the\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n@@ -224,2 +266,46 @@\n-     * Provides a formatted prompt, then reads a single line of text from the\n-     * console.\n+     * A convenience method to write a formatted string to this console's\n+     * output stream using the specified format string and arguments with\n+     * the specified {@code locale}.\n+     *\n+     * @implSpec This is the same as calling\n+     *         {@code format(locale, format, args)}.\n+     *\n+     * @param  locale The {@linkplain Locale locale} to apply during\n+     *         formatting.  If {@code locale} is {@code null} then no localization\n+     *         is applied.\n+     *\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n+     *\n+     * @param  args\n+     *         Arguments referenced by the format specifiers in the format\n+     *         string.  If there are more arguments than format specifiers, the\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n+     *         limited by the maximum dimension of a Java array as defined by\n+     *         <cite>The Java Virtual Machine Specification<\/cite>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n+     *\n+     * @throws  IllegalFormatException\n+     *          If a format string contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          insufficient arguments given the format string, or other\n+     *          illegal conditions.  For specification of all possible\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n+     *          formatter class specification.\n+     *\n+     * @return  This console\n+     * @since   23\n+     *\/\n+    public Console printf(Locale locale, String format, Object ... args) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Provides a formatted prompt using the\n+     * {@link Locale##default_locale default format locale}, then reads a\n+     * single line of text from the console.\n@@ -227,3 +313,3 @@\n-     * @param  fmt\n-     *         A format string as described in <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">Format string syntax<\/a>.\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n@@ -234,1 +320,2 @@\n-     *         extra arguments are ignored.  The maximum number of arguments is\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n@@ -237,0 +324,3 @@\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n@@ -243,3 +333,3 @@\n-     *          formatting errors, see the <a\n-     *          href=\"..\/util\/Formatter.html#detail\">Details<\/a> section\n-     *          of the formatter class specification.\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n+     *          formatter class specification.\n@@ -254,1 +344,45 @@\n-    public String readLine(String fmt, Object ... args) {\n+    public String readLine(String format, Object ... args) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Provides a formatted prompt using the specified {@code locale}, then\n+     * reads a single line of text from the console.\n+     *\n+     * @param  locale The {@linkplain Locale locale} to apply during\n+     *         formatting.  If {@code locale} is {@code null} then no localization\n+     *         is applied.\n+     *\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n+     *\n+     * @param  args\n+     *         Arguments referenced by the format specifiers in the format\n+     *         string.  If there are more arguments than format specifiers, the\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n+     *         limited by the maximum dimension of a Java array as defined by\n+     *         <cite>The Java Virtual Machine Specification<\/cite>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n+     *\n+     * @throws  IllegalFormatException\n+     *          If a format string contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          insufficient arguments given the format string, or other\n+     *          illegal conditions.  For specification of all possible\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n+     *          formatter class specification.\n+     *\n+     * @throws IOError\n+     *         If an I\/O error occurs.\n+     *\n+     * @return  A string containing the line read from the console, not\n+     *          including any line-termination characters, or {@code null}\n+     *          if an end of stream has been reached.\n+     * @since   23\n+     *\/\n+    public String readLine(Locale locale, String format, Object ... args) {\n@@ -273,2 +407,3 @@\n-     * Provides a formatted prompt, then reads a password or passphrase from\n-     * the console with echoing disabled.\n+     * Provides a formatted prompt using the\n+     * {@link Locale##default_locale default format locale}, then reads a\n+     * password or passphrase from the console with echoing disabled.\n@@ -276,3 +411,3 @@\n-     * @param  fmt\n-     *         A format string as described in <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">Format string syntax<\/a>\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}\n@@ -284,1 +419,2 @@\n-     *         extra arguments are ignored.  The maximum number of arguments is\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n@@ -287,0 +423,3 @@\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n@@ -293,3 +432,47 @@\n-     *          formatting errors, see the <a\n-     *          href=\"..\/util\/Formatter.html#detail\">Details<\/a>\n-     *          section of the formatter class specification.\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n+     *          formatter class specification.\n+     *\n+     * @throws IOError\n+     *         If an I\/O error occurs.\n+     *\n+     * @return  A character array containing the password or passphrase read\n+     *          from the console, not including any line-termination characters,\n+     *          or {@code null} if an end of stream has been reached.\n+     *\/\n+    public char[] readPassword(String format, Object ... args) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Provides a formatted prompt using the specified {@code locale}, then\n+     * reads a password or passphrase from the console with echoing disabled.\n+     *\n+     * @param  locale The {@linkplain Locale locale} to apply during\n+     *         formatting.  If {@code locale} is {@code null} then no localization\n+     *         is applied.\n+     *\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}\n+     *         for the prompt text.\n+     *\n+     * @param  args\n+     *         Arguments referenced by the format specifiers in the format\n+     *         string.  If there are more arguments than format specifiers, the\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n+     *         limited by the maximum dimension of a Java array as defined by\n+     *         <cite>The Java Virtual Machine Specification<\/cite>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n+     *\n+     * @throws  IllegalFormatException\n+     *          If a format string contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          insufficient arguments given the format string, or other\n+     *          illegal conditions.  For specification of all possible\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n+     *          formatter class specification.\n@@ -303,0 +486,1 @@\n+     * @since   23\n@@ -304,1 +488,1 @@\n-    public char[] readPassword(String fmt, Object ... args) {\n+    public char[] readPassword(Locale locale, String format, Object ... args) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/Console.java","additions":228,"deletions":44,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.Locale;\n+\n@@ -86,1 +88,9 @@\n-    public Console format(String fmt, Object ... args) {\n+    public Console format(String format, Object ... args) {\n+        return format(Locale.getDefault(Locale.Category.FORMAT), format, args);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Console format(Locale locale, String format, Object ... args) {\n@@ -88,1 +98,1 @@\n-            delegate.format(fmt, args);\n+            delegate.format(locale, format, args);\n@@ -98,0 +108,8 @@\n+        return printf(Locale.getDefault(Locale.Category.FORMAT), format, args);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Console printf(Locale locale, String format, Object ... args) {\n@@ -99,1 +117,1 @@\n-            delegate.printf(format, args);\n+            delegate.format(locale, format, args);\n@@ -108,1 +126,9 @@\n-    public String readLine(String fmt, Object ... args) {\n+    public String readLine(String format, Object ... args) {\n+        return readLine(Locale.getDefault(Locale.Category.FORMAT), format, args);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public String readLine(Locale locale, String format, Object ... args) {\n@@ -111,1 +137,1 @@\n-                return delegate.readLine(fmt, args);\n+                return delegate.readLine(locale, format, args);\n@@ -130,1 +156,9 @@\n-    public char[] readPassword(String fmt, Object ... args) {\n+    public char[] readPassword(String format, Object ... args) {\n+        return readPassword(Locale.getDefault(Locale.Category.FORMAT), format, args);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public char[] readPassword(Locale locale, String format, Object ... args) {\n@@ -133,1 +167,1 @@\n-                return delegate.readPassword(fmt, args);\n+                return delegate.readPassword(locale, format, args);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ProxyingConsole.java","additions":42,"deletions":8,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -574,0 +574,4 @@\n+     * <p>\n+     * For any given dynamic argument {@code x_i}, it must be that {@code 0 <= x_i < size_i},\n+     * where {@code size_i} is the size of the open path element associated with {@code x_i}.\n+     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}.\n@@ -612,1 +616,1 @@\n-     * O = this.offsetHandle(P).invokeExact(B, I1, I2, ... In);\n+     * O = this.byteOffsetHandle(P).invokeExact(B, I1, I2, ... In);\n@@ -630,0 +634,3 @@\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 <= I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n@@ -731,1 +738,1 @@\n-     * O = this.offsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);\n+     * O = this.byteOffsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);\n@@ -734,1 +741,1 @@\n-     * More formally, this method can be obtained from the {@link #varHandle(PathElement...)},\n+     * More formally, the method handle returned by this method is obtained from {@link #varHandle(PathElement...)},\n@@ -739,0 +746,29 @@\n+     * <p>\n+     * Accessing a memory segment using the var handle returned by this method is subject\n+     * to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be\n+     *     <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n+     *     {@linkplain #byteAlignment() alignment constraint} of the root layout\n+     *     (this layout), or an {@link IllegalArgumentException} is thrown. Note\n+     *     that the alignment constraint of the root layout can be more strict\n+     *     (but not less) than the alignment constraint of the selected value layout.<\/li>\n+     *     <li>The offset of the access operation (computed as above) must fall inside\n+     *     the spatial bounds of the accessed memory segment, or an\n+     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n+     *     {@code O + A <= S}, where {@code O} is the accessed offset (computed as above),\n+     *     {@code A} is the size of the selected layout and {@code S} is the size of the\n+     *     accessed memory segment.<\/li>\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 <= I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n+     *     <li>The accessed memory segment must be\n+     *     {@link MemorySegment#isAccessibleBy(Thread) accessible} from the thread\n+     *     performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n+     *     <li>For write operations, the accessed memory segment must not be\n+     *     {@link MemorySegment#isReadOnly() read only}, or an\n+     *     {@link IllegalArgumentException} is thrown.<\/li>\n+     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed\n+     *     segment must be {@linkplain MemorySegment.Scope#isAlive() alive}, or an\n+     *     {@link IllegalStateException} is thrown.<\/li>\n+     * <\/ul>\n@@ -795,0 +831,3 @@\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 <= I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n@@ -841,1 +880,2 @@\n-     * <a href=\"MemoryLayout.html#open-path-elements\">open path elements<\/a>.\n+     * <a href=\"MemoryLayout.html#open-path-elements\">open path elements<\/a>. The <em>size<\/em>\n+     * of an open path element determines the number of element layouts that can be selected by it.\n@@ -909,0 +949,1 @@\n+         * That is, the size of the returned open path element is {@code B}.\n@@ -927,1 +968,1 @@\n-         * {@code 0 <= I < C}.\n+         * {@code 0 <= I < C}. That is, {@code C} is the size of the returned open path element.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":46,"deletions":5,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1165,0 +1165,24 @@\n+    \/**\n+     * Calculates the {@code Duration} until another {@code Instant}.\n+     * <p>\n+     * The start and end points are {@code this} and the specified instant.\n+     * The result will be negative if the end is before the start. Calling\n+     * this method is equivalent to\n+     * {@link Duration#between(Temporal, Temporal) Duration.between(this,\n+     * endExclusive)}.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param endExclusive the end {@code Instant}, exclusive, not null\n+     * @return the {@code Duration} from this {@code Instant} until the\n+     *      specified {@code endExclusive} {@code Instant}\n+     * @see Duration#between(Temporal, Temporal)\n+     * @since 23\n+     *\/\n+    public Duration until(Instant endExclusive) {\n+        Objects.requireNonNull(endExclusive, \"endExclusive\");\n+        long secsDiff = Math.subtractExact(endExclusive.seconds, seconds);\n+        int nanosDiff = endExclusive.nanos - nanos;\n+        return Duration.ofSeconds(secsDiff, nanosDiff);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -63,0 +63,12 @@\n+\n+    \/**\n+     * Only intended for in-package usage.\n+     * Constructs a {@code CancellationException} with the specified detail\n+     * message and CancellationException cause.\n+     *\n+     * @param message the detail message\n+     * @param cause the underlying cancellation exception\n+     *\/\n+    CancellationException(String message, CancellationException cause) {\n+        super(message, cause);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CancellationException.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-    private static Object reportGet(Object r)\n+    private static Object reportGet(Object r, String details)\n@@ -392,1 +392,1 @@\n-                throw (CancellationException)x;\n+                throw new CancellationException(details, (CancellationException)x);\n@@ -404,1 +404,1 @@\n-    private static Object reportJoin(Object r) {\n+    private static Object reportJoin(Object r, String details) {\n@@ -410,1 +410,1 @@\n-                throw (CancellationException)x;\n+                throw new CancellationException(details, (CancellationException)x);\n@@ -2073,1 +2073,1 @@\n-        return (T) reportGet(r);\n+        return (T) reportGet(r, \"get\");\n@@ -2096,1 +2096,1 @@\n-        return (T) reportGet(r);\n+        return (T) reportGet(r, \"get\");\n@@ -2118,1 +2118,1 @@\n-        return (T) reportJoin(r);\n+        return (T) reportJoin(r, \"join\");\n@@ -2134,1 +2134,1 @@\n-        return ((r = result) == null) ? valueIfAbsent : (T) reportJoin(r);\n+        return ((r = result) == null) ? valueIfAbsent : (T) reportJoin(r, \"getNow\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,0 +240,4 @@\n+                    if (startPc > codeLength) {\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Line number start_pc out of range; start_pc=%d, codeLength=%d\", startPc, codeLength));\n+                    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -288,1 +288,0 @@\n-            e.printStackTrace();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Locale;\n@@ -40,3 +41,2 @@\n-    JdkConsole format(String fmt, Object ... args);\n-    JdkConsole printf(String format, Object ... args);\n-    String readLine(String fmt, Object ... args);\n+    JdkConsole format(Locale locale, String format, Object ... args);\n+    String readLine(Locale locale, String format, Object ... args);\n@@ -44,1 +44,1 @@\n-    char[] readPassword(String fmt, Object ... args);\n+    char[] readPassword(Locale locale, String format, Object ... args);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsole.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.Locale;\n@@ -60,2 +61,2 @@\n-    public JdkConsole format(String fmt, Object ... args) {\n-        formatter.format(fmt, args).flush();\n+    public JdkConsole format(Locale locale, String format, Object ... args) {\n+        formatter.format(locale, format, args).flush();\n@@ -66,6 +67,1 @@\n-    public JdkConsole printf(String format, Object ... args) {\n-        return format(format, args);\n-    }\n-\n-    @Override\n-    public String readLine(String fmt, Object ... args) {\n+    public String readLine(Locale locale, String format, Object ... args) {\n@@ -75,2 +71,2 @@\n-                if (!fmt.isEmpty())\n-                    pw.format(fmt, args);\n+                if (!format.isEmpty())\n+                    pw.format(locale, format, args);\n@@ -91,1 +87,1 @@\n-        return readLine(\"\");\n+        return readLine(Locale.getDefault(Locale.Category.FORMAT), \"\");\n@@ -95,1 +91,1 @@\n-    public char[] readPassword(String fmt, Object ... args) {\n+    public char[] readPassword(Locale locale, String format, Object ... args) {\n@@ -107,2 +103,2 @@\n-                    if (!fmt.isEmpty())\n-                        pw.format(fmt, args);\n+                    if (!format.isEmpty())\n+                        pw.format(locale, format, args);\n@@ -167,1 +163,1 @@\n-        return readPassword(\"\");\n+        return readPassword(Locale.getDefault(Locale.Category.FORMAT), \"\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleImpl.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+Owner: CN=GlobalSign Root E46, O=GlobalSign nv-sa, C=BE\n+Issuer: CN=GlobalSign Root E46, O=GlobalSign nv-sa, C=BE\n+Serial number: 11d2bbba336ed4bce62468c50d841d98e843\n+Valid from: Wed Mar 20 00:00:00 GMT 2019 until: Tue Mar 20 00:00:00 GMT 2046\n+Signature algorithm name: SHA384withECDSA\n+Subject Public Key Algorithm: 384-bit EC (secp384r1) key\n+Version: 3\n+-----BEGIN CERTIFICATE-----\r\n+MIICCzCCAZGgAwIBAgISEdK7ujNu1LzmJGjFDYQdmOhDMAoGCCqGSM49BAMDMEYx\r\n+CzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRwwGgYDVQQD\r\n+ExNHbG9iYWxTaWduIFJvb3QgRTQ2MB4XDTE5MDMyMDAwMDAwMFoXDTQ2MDMyMDAw\r\n+MDAwMFowRjELMAkGA1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2Ex\r\n+HDAaBgNVBAMTE0dsb2JhbFNpZ24gUm9vdCBFNDYwdjAQBgcqhkjOPQIBBgUrgQQA\r\n+IgNiAAScDrHPt+ieUnd1NPqlRqetMhkytAepJ8qUuwzSChDH2omwlwxwEwkBjtjq\r\n+R+q+soArzfwoDdusvKSGN+1wCAB16pMLey5SnCNoIwZD7JIvU4Tb+0cUB+hflGdd\r\n+yXqBPCCjQjBAMA4GA1UdDwEB\/wQEAwIBhjAPBgNVHRMBAf8EBTADAQH\/MB0GA1Ud\r\n+DgQWBBQxCpCPtsad0kRLgLWi5h+xEk8blTAKBggqhkjOPQQDAwNoADBlAjEA31SQ\r\n+7Zvvi5QCkxeCmb6zniz2C5GMn0oUsfZkvLtoURMMA\/cVi4RguYv\/Uo7njLwcAjA8\r\n++RHUjE7AwWHCFUyqqx0LMV87HOIAl0Qx5v5zli\/altP+CAezNIm8BZ\/3Hobui3A=\r\n+-----END CERTIFICATE-----\r\n","filename":"src\/java.base\/share\/data\/cacerts\/globalsigne46","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+Owner: CN=GlobalSign Root R46, O=GlobalSign nv-sa, C=BE\n+Issuer: CN=GlobalSign Root R46, O=GlobalSign nv-sa, C=BE\n+Serial number: 11d2bbb9d723189e405f0a9d2dd0df2567d1\n+Valid from: Wed Mar 20 00:00:00 GMT 2019 until: Tue Mar 20 00:00:00 GMT 2046\n+Signature algorithm name: SHA384withRSA\n+Subject Public Key Algorithm: 4096-bit RSA key\n+Version: 3\n+-----BEGIN CERTIFICATE-----\r\n+MIIFWjCCA0KgAwIBAgISEdK7udcjGJ5AXwqdLdDfJWfRMA0GCSqGSIb3DQEBDAUA\r\n+MEYxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRwwGgYD\r\n+VQQDExNHbG9iYWxTaWduIFJvb3QgUjQ2MB4XDTE5MDMyMDAwMDAwMFoXDTQ2MDMy\r\n+MDAwMDAwMFowRjELMAkGA1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYt\r\n+c2ExHDAaBgNVBAMTE0dsb2JhbFNpZ24gUm9vdCBSNDYwggIiMA0GCSqGSIb3DQEB\r\n+AQUAA4ICDwAwggIKAoICAQCsrHQy6LNl5brtQyYdpokNRbopiLKkHWPd08EsCVeJ\r\n+OaFV6Wc0dwxu5FUdUiXSE2te4R2pt32JMl8Nnp8semNgQB+msLZ4j5lUlghYruQG\r\n+vGIFAha\/r6gjA7aUD7xubMLL1aa7DOn2wQL7Id5m3RerdELv8HQvJfTqa1VbkNud\r\n+316HCkD7rRlr+\/fKYIje2sGP1q7Vf9Q8g+7XFkyDRTNrJ9CG0Bwta\/OrffGFqfUo\r\n+0q3v84RLHIf8E6M6cqJaESvWJ3En7YEtbWaBkoe0G1h6zD8K+kZPTXhc+CtI4wSE\r\n+y132tGqzZfxCnlEmIyDLPRT5ge1lFgBPGmSXZgjPjHvjK8Cd+RTyG\/FWaha\/LIWF\r\n+zXg4mutCagI0GIMXTpRW+LaCtfOW3T3zvn8gdz57GSNrLNRyc0NXfeD412lPFzYE\r\n++cCQYDdF3uYM2HSNrpyibXRdQr4G9dlkbgIQrImwTDsHTUB+JMWKmIJ5jqSngiCN\r\n+I\/onccnfxkF0oE32kRbcRoxfKWMxWXEM2G\/CtjJ9++ZdU6Z+Ffy7dXxd7Pj2Fxzs\r\n+x2sZy\/N78CsHpdlseVR2bJ0cpm4O6XkMqCNqo98bMDGfsVR7\/mrLZqrcZdCinkqa\r\n+ByFrgY\/bxFn63iLABJzjqls2k+g9vXqhnQt2sQvHnf3PmKgGwvgqo6GDoLclcqUC\r\n+4wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH\/BAUwAwEB\/zAdBgNV\r\n+HQ4EFgQUA1yrc4GHqMywptWU4jaWSf8FmSwwDQYJKoZIhvcNAQEMBQADggIBAHx4\r\n+7PYCLLtbfpIrXTncvtgdokIzTfnvpCo7RGkerNlFo048p9gkUbJUHJNOxO97k4Vg\r\n+JuoJSOD1u8fpaNK7ajFxzHmuEajwmf3lH7wvqMxX63bEIaZHU1VNaL8FpO7XJqti\r\n+2kM3S+LGteWygxk6x9PbTZ4IevPuzz5i+6zoYMzRx6Fcg0XERczzF2sUyQQCPtIk\r\n+pnnpHs6i58FZFZ8d4kuaPp92CC1r2LpXFNqD6v6MVenQTqnMdzGxRBF6XLE+0xRF\r\n+FRhiJBPSy03OXIPBNvIQtQ6IbbjhVp+J3pZmOUdkLG5NrmJ7v2B0GbhWrJKsFjLt\r\n+rWhV\/pi60zTe9Mlhww6G9kuEYO4Ne7UyWHmRVSyBQ7N0H3qqJZ4d16GLuc1CLgSk\r\n+ZoNNiTW2bKg2SnkheCLQQrzRQDGQob4Ez8pn7fXwgNNgyYMqIgXQBztSvwyeqiv5\r\n+u+YfjyW6hY0XHgL+XVAEV8\/+LbzvXMAaq7afJMbfc2hIkCwU9D9SGuTSyxTDYWnP\r\n+4vkYxboznxSjBF25cfe1lNj2M8FawTSLfJvdkzrnE6JwYZ+vj+vYxXX4M2bUdGc6\r\n+N3ec592kD3ZDZopD8p\/7DEJ4Y9HiD2971KE9dJeFt0g5QdYg\/NA6s\/rob8SKunE3\r\n+vouXsXgxT7PntgMTzlSdriVZzH81Xwj3QEUxeCp6\r\n+-----END CERTIFICATE-----\r\n","filename":"src\/java.base\/share\/data\/cacerts\/globalsignr46","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,2 @@\n+     *\n+     * @since 10\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/StandardOperation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Locale;\n@@ -87,2 +88,2 @@\n-        public JdkConsole format(String fmt, Object ... args) {\n-            writer().format(fmt, args).flush();\n+        public JdkConsole format(Locale locale, String format, Object ... args) {\n+            writer().format(locale, format, args).flush();\n@@ -93,6 +94,1 @@\n-        public JdkConsole printf(String format, Object ... args) {\n-            return format(format, args);\n-        }\n-\n-        @Override\n-        public String readLine(String fmt, Object ... args) {\n+        public String readLine(Locale locale, String format, Object ... args) {\n@@ -101,1 +97,1 @@\n-                return jline.readLine(fmt.formatted(args).replace(\"%\", \"%%\"));\n+                return jline.readLine(String.format(locale, format, args).replace(\"%\", \"%%\"));\n@@ -109,1 +105,1 @@\n-            return readLine(\"\");\n+            return readLine(Locale.getDefault(Locale.Category.FORMAT), \"\");\n@@ -113,1 +109,1 @@\n-        public char[] readPassword(String fmt, Object ... args) {\n+        public char[] readPassword(Locale locale, String format, Object ... args) {\n@@ -116,1 +112,1 @@\n-                return jline.readLine(fmt.formatted(args).replace(\"%\", \"%%\"), '\\0')\n+                return jline.readLine(String.format(locale, format, args).replace(\"%\", \"%%\"), '\\0')\n@@ -127,1 +123,1 @@\n-            return readPassword(\"\");\n+            return readPassword(Locale.getDefault(Locale.Category.FORMAT), \"\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -79,1 +79,3 @@\n-            columns = 1;\n+            \/\/ OpenJDK patch. Original code assigned 1 to columns, which ended up\n+            \/\/ appending \" \\b\" to the prompt in certain cases.\n+            columns = Integer.MAX_VALUE - 1;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Display.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+ *\n+ * @since 1.3\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/connect\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ *\n+ * @since 1.5\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/connect\/spi\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+ *\n+ * @since 1.3\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/event\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+ *\n+ * @since 1.3\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+ *\n+ * @since 1.3\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/request\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import java.util.Locale;\n+\n@@ -196,2 +198,2 @@\n-        public JdkConsole format(String fmt, Object... args) {\n-            writer().format(fmt, args).flush();\n+        public JdkConsole format(Locale locale, String format, Object... args) {\n+            writer().format(locale, format, args).flush();\n@@ -205,9 +207,1 @@\n-        public JdkConsole printf(String format, Object... args) {\n-            return format(format, args);\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         *\/\n-        @Override\n-        public String readLine(String fmt, Object... args) {\n+        public String readLine(Locale locale, String format, Object... args) {\n@@ -217,1 +211,1 @@\n-                    String prompt = fmt.formatted(args);\n+                    String prompt = String.format(locale, format, args);\n@@ -233,1 +227,1 @@\n-            return readLine(\"\");\n+            return readLine(Locale.getDefault(Locale.Category.FORMAT), \"\");\n@@ -240,1 +234,1 @@\n-        public char[] readPassword(String fmt, Object... args) {\n+        public char[] readPassword(Locale locale, String format, Object... args) {\n@@ -244,1 +238,1 @@\n-                    String prompt = fmt.formatted(args);\n+                    String prompt = String.format(locale, format, args);\n@@ -259,1 +253,1 @@\n-            return readPassword(\"\");\n+            return readPassword(Locale.getDefault(Locale.Category.FORMAT), \"\");\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/impl\/ConsoleImpl.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,451 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp\"\n+\n+#include <iostream>\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/vmassert_uninstall.hpp\"\n+#include \"utilities\/vmassert_reinstall.hpp\"\n+#include \"unittest.hpp\"\n+\n+static bool _success;\n+static size_t _assertion_failures;\n+\n+#define BitMapAssertEqual(a, b)  ASSERT_EQ((a), (b)); if ((a) != (b)) { _assertion_failures++; }\n+\n+class ShenandoahSimpleBitMapTest: public ::testing::Test {\n+protected:\n+\n+  static const ssize_t SMALL_BITMAP_SIZE =  512;\n+  static const ssize_t LARGE_BITMAP_SIZE = 4096;\n+\n+  \/\/ set_bits[] is an array of indexes holding bits that are supposed to be set, in increasing order.\n+  static void verifyBitMapState(ShenandoahSimpleBitMap& bm, ssize_t size, ssize_t set_bits[], ssize_t num_set_bits) {\n+    \/\/ Verify number of bits\n+    BitMapAssertEqual(bm.size(), size);\n+\n+    ssize_t set_bit_index = 0;\n+    \/\/ Check that is_set(idx) for every possible idx\n+    for (ssize_t i = 0; i < size; i++) {\n+      bool is_set = bm.is_set(i);\n+      bool intended_value = false;;\n+      if (set_bit_index < num_set_bits) {\n+        if (set_bits[set_bit_index] == i) {\n+          intended_value = true;\n+          set_bit_index++;\n+        }\n+      } else {\n+        \/\/ If we've exhausted set_bits array, there should be no more set_bits\n+        BitMapAssertEqual(is_set, false);\n+        BitMapAssertEqual(set_bit_index, num_set_bits);\n+      }\n+      BitMapAssertEqual(is_set, intended_value);\n+    }\n+    BitMapAssertEqual(set_bit_index, num_set_bits);\n+\n+    \/\/ Check that bits_at(array_idx) matches intended value for every valid array_idx value\n+    set_bit_index = 0;\n+    ssize_t alignment = bm.alignment();\n+    for (ssize_t i = 0; i < size; i += alignment) {\n+      size_t bits = bm.bits_at(i);\n+      for (ssize_t b = 0; b < alignment; b++) {\n+        ssize_t bit_value = i + b;\n+        bool intended_value = false;;\n+        if (set_bit_index < num_set_bits) {\n+          if (set_bits[set_bit_index] == bit_value) {\n+            intended_value = true;\n+            set_bit_index++;\n+          }\n+        }\n+        size_t bit_mask = ((size_t) 0x01) << b;\n+        bool is_set = (bits & bit_mask) != 0;\n+        BitMapAssertEqual(is_set, intended_value);\n+      }\n+    }\n+\n+    \/\/ Make sure find_first_set_bit() works correctly\n+    ssize_t probe_point = 0;\n+    for (ssize_t i = 0; i < num_set_bits; i++) {\n+      ssize_t next_expected_bit = set_bits[i];\n+      probe_point = bm.find_first_set_bit(probe_point);\n+      BitMapAssertEqual(probe_point, next_expected_bit);\n+      probe_point++;            \/\/ Prepare to look beyond the most recent bit.\n+    }\n+    if (probe_point < size) {\n+      probe_point = bm.find_first_set_bit(probe_point);\n+      BitMapAssertEqual(probe_point, size); \/\/ Verify that last failed search returns sentinel value: num bits in bit map\n+    }\n+\n+    \/\/ Confirm that find_first_set_bit() with a bounded search space works correctly\n+    \/\/ Limit this search to the first 3\/4 of the full bit map\n+    ssize_t boundary_idx = 3 * size \/ 4;\n+    probe_point = 0;\n+    for (ssize_t i = 0; i < num_set_bits; i++) {\n+      ssize_t next_expected_bit = set_bits[i];\n+      if (next_expected_bit >= boundary_idx) {\n+        break;\n+      } else {\n+        probe_point = bm.find_first_set_bit(probe_point, boundary_idx);\n+        BitMapAssertEqual(probe_point, next_expected_bit);\n+        probe_point++;            \/\/ Prepare to look beyond the most recent bit.\n+      }\n+    }\n+    if (probe_point < boundary_idx) {\n+      \/\/ In case there are no set bits in the last 1\/4 of bit map, confirm that last failed search returns sentinel: boundary_idx\n+      probe_point = bm.find_first_set_bit(probe_point, boundary_idx);\n+      BitMapAssertEqual(probe_point, boundary_idx);\n+    }\n+\n+    \/\/ Make sure find_last_set_bit() works correctly\n+    probe_point = size - 1;\n+    for (ssize_t i = num_set_bits - 1; i >= 0; i--) {\n+      ssize_t next_expected_bit = set_bits[i];\n+      probe_point = bm.find_last_set_bit(probe_point);\n+      BitMapAssertEqual(probe_point, next_expected_bit);\n+      probe_point--;            \/\/ Prepare to look before the most recent bit.\n+    }\n+    if (probe_point >= 0) {\n+      probe_point = bm.find_last_set_bit(probe_point);\n+      BitMapAssertEqual(probe_point, (ssize_t) -1); \/\/ Verify that last failed search returns sentinel value: -1\n+    }\n+\n+    \/\/ Confirm that find_last_set_bit() with a bounded search space works correctly\n+    \/\/ Limit this search to the last 3\/4 of the full bit map\n+    boundary_idx = size \/ 4;\n+    probe_point = size - 1;\n+    for (ssize_t i = num_set_bits - 1; i >= 0; i--) {\n+      ssize_t next_expected_bit = set_bits[i];\n+      if (next_expected_bit > boundary_idx) {\n+        probe_point = bm.find_last_set_bit(boundary_idx, probe_point);\n+        BitMapAssertEqual(probe_point, next_expected_bit);\n+        probe_point--;\n+      } else {\n+        break;\n+      }\n+    }\n+    if (probe_point > boundary_idx) {\n+      probe_point = bm.find_last_set_bit(boundary_idx, probe_point);\n+        \/\/ Verify that last failed search returns sentinel value: boundary_idx\n+      BitMapAssertEqual(probe_point, boundary_idx);\n+    }\n+\n+    \/\/ What's the longest cluster of consecutive bits\n+    ssize_t previous_value = -2;\n+    ssize_t longest_run = 0;\n+    ssize_t current_run = 0;\n+    for (ssize_t i = 0; i < num_set_bits; i++) {\n+      ssize_t next_expected_bit = set_bits[i];\n+      if (next_expected_bit == previous_value + 1) {\n+        current_run++;\n+      } else {\n+        previous_value = next_expected_bit;\n+        current_run = 1;\n+      }\n+      if (current_run > longest_run) {\n+        longest_run = current_run;\n+      }\n+      previous_value = next_expected_bit;\n+    }\n+\n+    \/\/ Confirm that find_first_consecutive_set_bits() works for each cluster size known to have at least one match\n+    for (ssize_t cluster_size = 1; cluster_size <= longest_run; cluster_size++) {\n+      \/\/ Verify that find_first_consecutive_set_bits() works\n+      ssize_t bit_idx = 0;\n+      ssize_t probe_point = 0;\n+      while ((probe_point <= size - cluster_size) && (bit_idx <= num_set_bits - cluster_size)) {\n+        bool cluster_found = false;\n+        while (!cluster_found && (bit_idx + cluster_size <= num_set_bits)) {\n+          cluster_found = true;\n+          for (ssize_t i = 1; i < cluster_size; i++) {\n+            if (set_bits[bit_idx] + i != set_bits[bit_idx + i]) {\n+              cluster_found = false;\n+              bit_idx++;\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster_found) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx];\n+          ssize_t orig_probe_point = probe_point;\n+          probe_point = bm.find_first_consecutive_set_bits(orig_probe_point, cluster_size);\n+          BitMapAssertEqual(next_expected_cluster, probe_point);\n+          probe_point++;\n+          bit_idx++;\n+        } else {\n+          bit_idx++;\n+          break;\n+        }\n+      }\n+      if (probe_point < size) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: num_bits\n+        probe_point = bm.find_first_consecutive_set_bits(probe_point, cluster_size);\n+        BitMapAssertEqual(probe_point, size);\n+      }\n+\n+      \/\/ Repeat the above experiment, using 3\/4 size as the search boundary_idx\n+      bit_idx = 0;\n+      probe_point = 0;\n+      boundary_idx = 4 * size \/ 4;\n+      while ((probe_point <= boundary_idx - cluster_size) && (bit_idx <= num_set_bits - cluster_size)) {\n+        bool cluster_found = false;\n+        while (!cluster_found && (bit_idx + cluster_size <= num_set_bits)) {\n+          cluster_found = true;\n+          for (int i = 1; i < cluster_size; i++) {\n+            if (set_bits[bit_idx] + i != set_bits[bit_idx + i]) {\n+              cluster_found = false;\n+              bit_idx++;\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster_found) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx];\n+          probe_point = bm.find_first_consecutive_set_bits(probe_point, boundary_idx, cluster_size);\n+          BitMapAssertEqual(next_expected_cluster, probe_point);\n+          probe_point++;\n+          bit_idx++;\n+        } else {\n+          bit_idx++;\n+        }\n+      }\n+      if (probe_point < boundary_idx) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+        probe_point = bm.find_first_consecutive_set_bits(probe_point, boundary_idx, cluster_size);\n+        BitMapAssertEqual(probe_point, boundary_idx);\n+      }\n+\n+      \/\/ Verify that find_last_consecutive_set_bits() works\n+      bit_idx = num_set_bits - 1;\n+      probe_point = size - 1;\n+      \/\/ Iterate over all set bits in reverse order\n+      while (bit_idx + 1 >= cluster_size) {\n+        bool cluster_found = true;\n+        for (int i = 1; i < cluster_size; i++) {\n+          if (set_bits[bit_idx] - i != set_bits[bit_idx - i]) {\n+            cluster_found = false;\n+            break;\n+          }\n+        }\n+        if (cluster_found) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx] + 1 - cluster_size;\n+          probe_point = bm.find_last_consecutive_set_bits(probe_point, cluster_size);\n+          BitMapAssertEqual(next_expected_cluster, probe_point);\n+          probe_point = probe_point + cluster_size - 2;\n+          bit_idx--;\n+        } else {\n+          bit_idx--;\n+        }\n+      }\n+      if (probe_point >= 0) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+        probe_point = bm.find_last_consecutive_set_bits(boundary_idx, probe_point, cluster_size);\n+        BitMapAssertEqual(probe_point, (ssize_t) boundary_idx);\n+      }\n+\n+      \/\/ Verify that find_last_consecutive_set_bits() works with the search range bounded at 1\/4 size\n+      bit_idx = num_set_bits - 1;\n+      probe_point = size - 1;\n+      boundary_idx = size \/ 4;\n+      while (bit_idx + 1 >= cluster_size) {\n+        bool cluster_found = true;\n+        for (int i = 1; i < cluster_size; i++) {\n+          if (set_bits[bit_idx] - i != set_bits[bit_idx - i]) {\n+            cluster_found = false;\n+            break;\n+          }\n+        }\n+        if (cluster_found && (set_bits[bit_idx] + 1 - cluster_size > boundary_idx)) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx] + 1 - cluster_size;\n+          probe_point = bm.find_last_consecutive_set_bits(boundary_idx, probe_point, cluster_size);\n+          BitMapAssertEqual(next_expected_cluster, probe_point);\n+          probe_point = probe_point + cluster_size - 2;\n+          bit_idx--;\n+        } else if (set_bits[bit_idx] + 1 - cluster_size <= boundary_idx) {\n+          break;\n+        } else {\n+          bit_idx--;\n+        }\n+      }\n+      if (probe_point > boundary_idx) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+        probe_point = bm.find_last_consecutive_set_bits(boundary_idx, probe_point, cluster_size);\n+        BitMapAssertEqual(probe_point, boundary_idx);\n+      }\n+    }\n+\n+    \/\/ Confirm that find_first_consecutive_set_bits() works for a cluster size known not to have any matches\n+    probe_point = bm.find_first_consecutive_set_bits(0, longest_run + 1);\n+    BitMapAssertEqual(probe_point, size);  \/\/ Confirm: failed search returns sentinel: size\n+\n+    probe_point = bm.find_last_consecutive_set_bits(size - 1, longest_run + 1);\n+    BitMapAssertEqual(probe_point, (ssize_t) -1);    \/\/ Confirm: failed search returns sentinel: -1\n+\n+    boundary_idx = 3 * size \/ 4;\n+    probe_point = bm.find_first_consecutive_set_bits(0, boundary_idx, longest_run + 1);\n+    BitMapAssertEqual(probe_point, boundary_idx); \/\/ Confirm: failed search returns sentinel: boundary_idx\n+\n+    boundary_idx = size \/ 4;\n+    probe_point = bm.find_last_consecutive_set_bits(boundary_idx, size - 1, longest_run + 1);\n+    BitMapAssertEqual(probe_point, boundary_idx);           \/\/ Confirm: failed search returns sentinel: boundary_idx\n+  }\n+\n+public:\n+\n+  static bool run_test() {\n+\n+    _success = false;\n+    _assertion_failures = 0;\n+\n+    ShenandoahSimpleBitMap bm_small(SMALL_BITMAP_SIZE);\n+    ShenandoahSimpleBitMap bm_large(LARGE_BITMAP_SIZE);\n+\n+    \/\/ Initial state of each bitmap is all bits are clear.  Confirm this:\n+    ssize_t set_bits_0[1] = { 0 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_0, 0);\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_0, 0);\n+\n+    bm_small.set_bit(5);\n+    bm_small.set_bit(63);\n+    bm_small.set_bit(128);\n+    ssize_t set_bits_1[3] = { 5, 63, 128 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_1, 3);\n+\n+    bm_large.set_bit(5);\n+    bm_large.set_bit(63);\n+    bm_large.set_bit(128);\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_1, 3);\n+\n+    \/\/ Test some consecutive bits\n+    bm_small.set_bit(140);\n+    bm_small.set_bit(141);\n+    bm_small.set_bit(142);\n+\n+    bm_small.set_bit(253);\n+    bm_small.set_bit(254);\n+    bm_small.set_bit(255);\n+\n+    bm_small.set_bit(271);\n+    bm_small.set_bit(272);\n+\n+    bm_small.set_bit(320);\n+    bm_small.set_bit(321);\n+    bm_small.set_bit(322);\n+\n+    bm_small.set_bit(361);\n+\n+    ssize_t set_bits_2[15] = { 5, 63, 128, 140, 141, 142, 253, 254, 255, 271, 272, 320, 321, 322, 361 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_2, 15);\n+\n+    bm_large.set_bit(140);\n+    bm_large.set_bit(141);\n+    bm_large.set_bit(142);\n+\n+    bm_large.set_bit(1021);\n+    bm_large.set_bit(1022);\n+    bm_large.set_bit(1023);\n+\n+    bm_large.set_bit(1051);\n+\n+    bm_large.set_bit(1280);\n+    bm_large.set_bit(1281);\n+    bm_large.set_bit(1282);\n+\n+    bm_large.set_bit(1300);\n+    bm_large.set_bit(1301);\n+    bm_large.set_bit(1302);\n+\n+    ssize_t set_bits_3[16] = { 5, 63, 128, 140, 141, 142, 1021, 1022, 1023, 1051, 1280, 1281, 1282, 1300, 1301, 1302 };\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_3, 16);\n+\n+    \/\/ Test clear_bit\n+    bm_small.clear_bit(141);\n+    bm_small.clear_bit(253);\n+    ssize_t set_bits_4[13] = { 5, 63, 128, 140, 142, 254, 255, 271, 272, 320, 321, 322, 361 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_4, 13);\n+\n+    bm_large.clear_bit(5);\n+    bm_large.clear_bit(63);\n+    bm_large.clear_bit(128);\n+    bm_large.clear_bit(141);\n+    ssize_t set_bits_5[12] = { 140, 142, 1021, 1022, 1023, 1051, 1280, 1281, 1282, 1300, 1301, 1302 };\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_5, 12);\n+\n+    \/\/ Look for large island of contiguous surrounded by smaller islands of contiguous\n+    bm_large.set_bit(1024);\n+    bm_large.set_bit(1025);  \/\/ size-5 island from 1021 to 1025\n+    bm_large.set_bit(1027);\n+    bm_large.set_bit(1028);\n+    bm_large.set_bit(1029);\n+    bm_large.set_bit(1030);\n+    bm_large.set_bit(1031);\n+    bm_large.set_bit(1032);  \/\/ size-6 island from 1027 to 1032\n+    bm_large.set_bit(1034);\n+    bm_large.set_bit(1035);\n+    bm_large.set_bit(1036);  \/\/ size-3 island from 1034 to 1036\n+    ssize_t set_bits_6[23] = {  140,  142, 1021, 1022, 1023, 1024, 1025, 1027, 1028, 1029, 1030,\n+                               1031, 1032, 1034, 1035, 1036, 1051, 1280, 1281, 1282, 1300, 1301, 1302 };\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_6, 23);\n+\n+    \/\/ Test that entire bitmap word (from 1024 to 1088) is 1's\n+    ssize_t set_bits_7[76];\n+    set_bits_7[0] = 140;\n+    set_bits_7[1] = 142;\n+    set_bits_7[2] = 1021;\n+    set_bits_7[3] = 1022;\n+    set_bits_7[4] = 1023;\n+    size_t bit_idx = 5;\n+    for (ssize_t i = 1024; i <= 1088; i++) {\n+      bm_large.set_bit(i);\n+      set_bits_7[bit_idx++] = i;\n+    }\n+    set_bits_7[bit_idx++] = 1280;\n+    set_bits_7[bit_idx++] = 1281;\n+    set_bits_7[bit_idx++] = 1282;\n+    set_bits_7[bit_idx++] = 1300;\n+    set_bits_7[bit_idx++] = 1301;\n+    set_bits_7[bit_idx++] = 1302;\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_7, bit_idx);\n+\n+    \/\/ Test clear_all()\n+    bm_small.clear_all();\n+    bm_large.clear_all();\n+\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_0, 0);\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_0, 0);\n+\n+    _success = true;\n+    return true;\n+  }\n+\n+};\n+\n+TEST(BasicShenandoahSimpleBitMapTest, minimum_test) {\n+\n+  bool result = ShenandoahSimpleBitMapTest::run_test();\n+  ASSERT_EQ(result, true);\n+  ASSERT_EQ(_success, true);\n+  ASSERT_EQ(_assertion_failures, (size_t) 0);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":451,"deletions":0,"binary":false,"changes":451,"status":"added"},{"patch":"@@ -81,0 +81,2 @@\n+compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java 8332369 generic-all\n+\n@@ -96,4 +98,0 @@\n-gc\/shenandoah\/TestHumongousThreshold.java#default 8327000 generic-all\n-gc\/shenandoah\/TestHumongousThreshold.java#16b 8327000 generic-all\n-gc\/shenandoah\/TestHumongousThreshold.java#generational 8327000 generic-all\n-gc\/shenandoah\/TestHumongousThreshold.java#generational-16b 8327000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332245\n+ * @summary C2: missing record_for_ign() call in GraphKit::must_be_not_null()\n+ *\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestBackToBackMustBeNotNull\n+ *\/\n+\n+package compiler.c2.irTests;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Field;\n+import compiler.lib.ir_framework.*;\n+\n+\n+public class TestBackToBackMustBeNotNull {\n+    static final jdk.internal.misc.Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static final long F_OFFSET;\n+    private static A fieldA = new A();\n+\n+    static {\n+        try {\n+            Field fField = A.class.getDeclaredField(\"f\");\n+            F_OFFSET = UNSAFE.objectFieldOffset(fField);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static public void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.ITER_GVN1 }, counts = { IRNode.IF, \"1\" })\n+    private static void test1() {\n+        final Object o1 = UNSAFE.getReference(fieldA, F_OFFSET);\n+        final Object o2 = UNSAFE.getReference(fieldA, F_OFFSET);\n+        notInlined(o1, o2);\n+    }\n+\n+    @DontInline\n+    private static void notInlined(Object o1, Object o2) {\n+\n+    }\n+\n+    static class A {\n+        Object f;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestBackToBackMustBeNotNull.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,810 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test id=byte-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray\n+ *\/\n+\n+\/*\n+ * @test id=char-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment CharArray\n+ *\/\n+\n+\/*\n+ * @test id=short-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ShortArray\n+ *\/\n+\n+\/*\n+ * @test id=int-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment IntArray\n+ *\/\n+\n+\/*\n+ * @test id=long-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment LongArray\n+ *\/\n+\n+\/*\n+ * @test id=float-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment FloatArray\n+ *\/\n+\n+\/*\n+ * @test id=double-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment DoubleArray\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteBuffer\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer-direct\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteBufferDirect\n+ *\/\n+\n+\/*\n+ * @test id=native\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native\n+ *\/\n+\n+\/\/ FAILS: mixed providers currently do not vectorize. Maybe there is some inlining issue.\n+\/\/ \/*\n+\/\/  * @test id=mixed-array\n+\/\/  * @bug 8329273\n+\/\/  * @summary Test vectorization of loops over MemorySegment\n+\/\/  * @library \/test\/lib \/\n+\/\/  * @run driver compiler.loopopts.superword.TestMemorySegment MixedArray\n+\/\/  *\/\n+\/\/\n+\/\/ \/*\n+\/\/  * @test id=MixedBuffer\n+\/\/  * @bug 8329273\n+\/\/  * @summary Test vectorization of loops over MemorySegment\n+\/\/  * @library \/test\/lib \/\n+\/\/  * @run driver compiler.loopopts.superword.TestMemorySegment MixedBuffer\n+\/\/  *\/\n+\/\/\n+\/\/ \/*\n+\/\/  * @test id=mixed\n+\/\/  * @bug 8329273\n+\/\/  * @summary Test vectorization of loops over MemorySegment\n+\/\/  * @library \/test\/lib \/\n+\/\/  * @run driver compiler.loopopts.superword.TestMemorySegment Mixed\n+\/\/  *\/\n+\n+public class TestMemorySegment {\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMemorySegmentImpl.class);\n+        framework.addFlags(\"-DmemorySegmentProviderNameForTestVM=\" + args[0]);\n+        framework.setDefaultWarmup(100);\n+        framework.start();\n+    }\n+}\n+\n+class TestMemorySegmentImpl {\n+    static final int BACKING_SIZE = 1024 * 8;\n+    static final Random RANDOM = Utils.getRandomInstance();\n+\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    interface MemorySegmentProvider {\n+        MemorySegment newMemorySegment();\n+    }\n+\n+    static MemorySegmentProvider provider;\n+\n+    static {\n+        String providerName = System.getProperty(\"memorySegmentProviderNameForTestVM\");\n+        provider = switch (providerName) {\n+            case \"ByteArray\"        -> TestMemorySegmentImpl::newMemorySegmentOfByteArray;\n+            case \"CharArray\"        -> TestMemorySegmentImpl::newMemorySegmentOfCharArray;\n+            case \"ShortArray\"       -> TestMemorySegmentImpl::newMemorySegmentOfShortArray;\n+            case \"IntArray\"         -> TestMemorySegmentImpl::newMemorySegmentOfIntArray;\n+            case \"LongArray\"        -> TestMemorySegmentImpl::newMemorySegmentOfLongArray;\n+            case \"FloatArray\"       -> TestMemorySegmentImpl::newMemorySegmentOfFloatArray;\n+            case \"DoubleArray\"      -> TestMemorySegmentImpl::newMemorySegmentOfDoubleArray;\n+            case \"ByteBuffer\"       -> TestMemorySegmentImpl::newMemorySegmentOfByteBuffer;\n+            case \"ByteBufferDirect\" -> TestMemorySegmentImpl::newMemorySegmentOfByteBufferDirect;\n+            case \"Native\"           -> TestMemorySegmentImpl::newMemorySegmentOfNative;\n+            case \"MixedArray\"       -> TestMemorySegmentImpl::newMemorySegmentOfMixedArray;\n+            case \"MixedBuffer\"      -> TestMemorySegmentImpl::newMemorySegmentOfMixedBuffer;\n+            case \"Mixed\"            -> TestMemorySegmentImpl::newMemorySegmentOfMixed;\n+            default -> throw new RuntimeException(\"Test argument not recognized: \" + providerName);\n+        };\n+    }\n+\n+    \/\/ List of tests\n+    Map<String, TestFunction> tests = new HashMap<>();\n+\n+    \/\/ List of gold, the results from the first run before compilation\n+    Map<String, Object[]> golds = new HashMap<>();\n+\n+    public TestMemorySegmentImpl () {\n+        \/\/ Generate two MemorySegments as inputs\n+        MemorySegment a = newMemorySegment();\n+        MemorySegment b = newMemorySegment();\n+        fillRandom(a);\n+        fillRandom(b);\n+\n+        \/\/ Add all tests to list\n+        tests.put(\"testMemorySegmentBadExitCheck\",                 () -> testMemorySegmentBadExitCheck(copy(a)));\n+        tests.put(\"testIntLoop_iv_byte\",                           () -> testIntLoop_iv_byte(copy(a)));\n+        tests.put(\"testIntLoop_longIndex_intInvar_sameAdr_byte\",   () -> testIntLoop_longIndex_intInvar_sameAdr_byte(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_longInvar_sameAdr_byte\",  () -> testIntLoop_longIndex_longInvar_sameAdr_byte(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_intInvar_byte\",           () -> testIntLoop_longIndex_intInvar_byte(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_longInvar_byte\",          () -> testIntLoop_longIndex_longInvar_byte(copy(a), 0));\n+        tests.put(\"testIntLoop_intIndex_intInvar_byte\",            () -> testIntLoop_intIndex_intInvar_byte(copy(a), 0));\n+        tests.put(\"testIntLoop_iv_int\",                            () -> testIntLoop_iv_int(copy(a)));\n+        tests.put(\"testIntLoop_longIndex_intInvar_sameAdr_int\",    () -> testIntLoop_longIndex_intInvar_sameAdr_int(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_longInvar_sameAdr_int\",   () -> testIntLoop_longIndex_longInvar_sameAdr_int(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_intInvar_int\",            () -> testIntLoop_longIndex_intInvar_int(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_longInvar_int\",           () -> testIntLoop_longIndex_longInvar_int(copy(a), 0));\n+        tests.put(\"testIntLoop_intIndex_intInvar_int\",             () -> testIntLoop_intIndex_intInvar_int(copy(a), 0));\n+        tests.put(\"testLongLoop_iv_byte\",                          () -> testLongLoop_iv_byte(copy(a)));\n+        tests.put(\"testLongLoop_longIndex_intInvar_sameAdr_byte\",  () -> testLongLoop_longIndex_intInvar_sameAdr_byte(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_longInvar_sameAdr_byte\", () -> testLongLoop_longIndex_longInvar_sameAdr_byte(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_intInvar_byte\",          () -> testLongLoop_longIndex_intInvar_byte(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_longInvar_byte\",         () -> testLongLoop_longIndex_longInvar_byte(copy(a), 0));\n+        tests.put(\"testLongLoop_intIndex_intInvar_byte\",           () -> testLongLoop_intIndex_intInvar_byte(copy(a), 0));\n+        tests.put(\"testLongLoop_iv_int\",                           () -> testLongLoop_iv_int(copy(a)));\n+        tests.put(\"testLongLoop_longIndex_intInvar_sameAdr_int\",   () -> testLongLoop_longIndex_intInvar_sameAdr_int(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_longInvar_sameAdr_int\",  () -> testLongLoop_longIndex_longInvar_sameAdr_int(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_intInvar_int\",           () -> testLongLoop_longIndex_intInvar_int(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_longInvar_int\",          () -> testLongLoop_longIndex_longInvar_int(copy(a), 0));\n+        tests.put(\"testLongLoop_intIndex_intInvar_int\",            () -> testLongLoop_intIndex_intInvar_int(copy(a), 0));\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            Object[] gold = test.run();\n+            golds.put(name, gold);\n+        }\n+    }\n+\n+    MemorySegment newMemorySegment() {\n+        return provider.newMemorySegment();\n+    }\n+\n+    MemorySegment copy(MemorySegment src) {\n+        MemorySegment dst = newMemorySegment();\n+        MemorySegment.copy(src, 0, dst, 0, src.byteSize());\n+        return dst;\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteArray() {\n+        return MemorySegment.ofArray(new byte[BACKING_SIZE]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfCharArray() {\n+        return MemorySegment.ofArray(new char[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfShortArray() {\n+        return MemorySegment.ofArray(new short[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfIntArray() {\n+        return MemorySegment.ofArray(new int[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfLongArray() {\n+        return MemorySegment.ofArray(new long[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfFloatArray() {\n+        return MemorySegment.ofArray(new float[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfDoubleArray() {\n+        return MemorySegment.ofArray(new double[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBuffer() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocate(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBufferDirect() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocateDirect(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfNative() {\n+        \/\/ Auto arena: GC decides when there is no reference to the MemorySegment,\n+        \/\/ and then it deallocates the backing memory.\n+        return Arena.ofAuto().allocate(BACKING_SIZE, 1);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedArray() {\n+        switch(RANDOM.nextInt(7)) {\n+            case 0  -> { return newMemorySegmentOfByteArray(); }\n+            case 1  -> { return newMemorySegmentOfCharArray(); }\n+            case 2  -> { return newMemorySegmentOfShortArray(); }\n+            case 3  -> { return newMemorySegmentOfIntArray(); }\n+            case 4  -> { return newMemorySegmentOfLongArray(); }\n+            case 5  -> { return newMemorySegmentOfFloatArray(); }\n+            default -> { return newMemorySegmentOfDoubleArray(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedBuffer() {\n+        switch (RANDOM.nextInt(2)) {\n+            case 0  -> { return newMemorySegmentOfByteBuffer(); }\n+            default -> { return newMemorySegmentOfByteBufferDirect(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixed() {\n+        switch (RANDOM.nextInt(3)) {\n+            case 0  -> { return newMemorySegmentOfMixedArray(); }\n+            case 1  -> { return newMemorySegmentOfMixedBuffer(); }\n+            default -> { return newMemorySegmentOfNative(); }\n+        }\n+    }\n+\n+    static void fillRandom(MemorySegment data) {\n+        for (int i = 0; i < (int)data.byteSize(); i += 8) {\n+            data.set(ValueLayout.JAVA_LONG_UNALIGNED, i, RANDOM.nextLong());\n+        }\n+    }\n+\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate objects (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+\n+            if (!(g instanceof MemorySegment && r instanceof MemorySegment)) {\n+                throw new RuntimeException(\"verify \" + name + \": only MemorySegment supported, i=\" + i);\n+            }\n+\n+            MemorySegment mg = (MemorySegment)g;\n+            MemorySegment mr = (MemorySegment)r;\n+\n+            if (mg.byteSize() != mr.byteSize()) {\n+                throw new RuntimeException(\"verify \" + name + \": MemorySegment must have same byteSize:\" +\n+                                       \" gold[\" + i + \"].byteSize = \" + mg.byteSize() +\n+                                       \" result[\" + i + \"].byteSize = \" + mr.byteSize());\n+            }\n+\n+            for (int j = 0; j < (int)mg.byteSize(); j++) {\n+                byte vg = mg.get(ValueLayout.JAVA_BYTE, j);\n+                byte vr = mr.get(ValueLayout.JAVA_BYTE, j);\n+                if (vg != vr) {\n+                    throw new RuntimeException(\"verify \" + name + \": MemorySegment must have same content:\" +\n+                                               \" gold[\" + i + \"][\" + j + \"] = \" + vg +\n+                                               \" result[\" + i + \"][\" + j + \"] = \" + vr);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Run(test = {\"testMemorySegmentBadExitCheck\",\n+                 \"testIntLoop_iv_byte\",\n+                 \"testIntLoop_longIndex_intInvar_sameAdr_byte\",\n+                 \"testIntLoop_longIndex_longInvar_sameAdr_byte\",\n+                 \"testIntLoop_longIndex_intInvar_byte\",\n+                 \"testIntLoop_longIndex_longInvar_byte\",\n+                 \"testIntLoop_intIndex_intInvar_byte\",\n+                 \"testIntLoop_iv_int\",\n+                 \"testIntLoop_longIndex_intInvar_sameAdr_int\",\n+                 \"testIntLoop_longIndex_longInvar_sameAdr_int\",\n+                 \"testIntLoop_longIndex_intInvar_int\",\n+                 \"testIntLoop_longIndex_longInvar_int\",\n+                 \"testIntLoop_intIndex_intInvar_int\",\n+                 \"testLongLoop_iv_byte\",\n+                 \"testLongLoop_longIndex_intInvar_sameAdr_byte\",\n+                 \"testLongLoop_longIndex_longInvar_sameAdr_byte\",\n+                 \"testLongLoop_longIndex_intInvar_byte\",\n+                 \"testLongLoop_longIndex_longInvar_byte\",\n+                 \"testLongLoop_intIndex_intInvar_byte\",\n+                 \"testLongLoop_iv_int\",\n+                 \"testLongLoop_longIndex_intInvar_sameAdr_int\",\n+                 \"testLongLoop_longIndex_longInvar_sameAdr_int\",\n+                 \"testLongLoop_longIndex_intInvar_int\",\n+                 \"testLongLoop_longIndex_longInvar_int\",\n+                 \"testLongLoop_intIndex_intInvar_int\"})\n+    void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object[] gold = golds.get(name);\n+            \/\/ Compute new result\n+            Object[] result = test.run();\n+            \/\/ Compare gold and new result\n+            verify(name, gold, result);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS\n+    \/\/ Exit check: iv < long_limit      ->     (long)iv < long_limit\n+    \/\/ Thus, we have an int-iv, but a long-exit-check.\n+    \/\/ Is not properly recognized by either CountedLoop or LongCountedLoop\n+    static Object[] testMemorySegmentBadExitCheck(MemorySegment a) {\n+        for (int i = 0; i < a.byteSize(); i++) {\n+            long adr = i;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_iv_byte(MemorySegment a) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr = i;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_intInvar_sameAdr_byte(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_longInvar_sameAdr_byte(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_longInvar_byte(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testIntLoop_intIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            int int_index = i + invar;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, int_index);\n+            a.set(ValueLayout.JAVA_BYTE, int_index, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_iv_int(MemorySegment a) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++ ) {\n+            long adr = 4L * i;\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_intInvar_sameAdr_int(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_longInvar_sameAdr_int(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_longInvar_int(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testIntLoop_intIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            int int_index = i + invar;\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_iv_byte(MemorySegment a) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr = i;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_longIndex_intInvar_sameAdr_byte(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_longIndex_longInvar_sameAdr_byte(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_longInvar_byte(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testLongLoop_intIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            int int_index = (int)(i + invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, int_index);\n+            a.set(ValueLayout.JAVA_BYTE, int_index, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_iv_int(MemorySegment a) {\n+        for (long i = 0; i < a.byteSize()\/4; i++ ) {\n+            long adr = 4L * i;\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/@IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+    \/\/              IRNode.ADD_VI,        \"> 0\",\n+    \/\/              IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/    applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/    applyIf = {\"AlignVector\", \"false\"},\n+    \/\/    applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: for native memory. I think it is because of invariants, but need investigation.\n+    \/\/        The long -> int loop conversion introduces extra invariants.\n+    static Object[] testLongLoop_longIndex_intInvar_sameAdr_int(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/@IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+    \/\/              IRNode.ADD_VI,        \"> 0\",\n+    \/\/              IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/    applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/    applyIf = {\"AlignVector\", \"false\"},\n+    \/\/    applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: for native memory. I think it is because of invariants, but need investigation.\n+    \/\/        The long -> int loop conversion introduces extra invariants.\n+    static Object[] testLongLoop_longIndex_longInvar_sameAdr_int(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_longInvar_int(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testLongLoop_intIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            int int_index = (int)(i + invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":810,"deletions":0,"binary":false,"changes":810,"status":"added"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8324517\n+ * @summary C2: out of bound array load because of dependency on removed range check CastIIs\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ *\n+ *\/\n+\n+public class TestArrayAccessAboveRCAfterRCCastIIEliminated {\n+    private static int intField;\n+    private static long longField;\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(9, 10, 1, true);\n+            test1(9, 10, 1, false);\n+            test2(9, 10, 1, true);\n+            test2(9, 10, 1, false);\n+            test3(9, 10, 1, true);\n+            test3(9, 10, 1, false);\n+            test4(9, 10, 1, true);\n+            test4(9, 10, 1, false);\n+            test5(9, 10, 1, true);\n+            test5(9, 10, 1, false);\n+            test6(9, 10, 1, true);\n+            test6(9, 10, 1, false);\n+            test7(9, 10, 1, true);\n+            test7(9, 10, 1, false);\n+            test8(9, 10, 1, true);\n+            test8(9, 10, 1, false);\n+            test9(9, 10, 1, true);\n+            test9(9, 10, 1, false);\n+            test10(9, 10, 1, true);\n+            test10(9, 10, 1, false);\n+            test11(9, 10, 1, true);\n+            test11(9, 10, 1, false);\n+            test12(9, 10, 1, true);\n+            test12(9, 10, 1, false);\n+            test13(9, 10, 1, true);\n+            test13(9, 10, 1, false);\n+        }\n+        try {\n+            test1(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test2(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test3(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test4(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test5(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test6(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test7(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test8(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test9(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test10(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test11(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test12(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test13(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static void test1(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test2(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test3(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test4(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test5(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test6(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test7(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+    private static void test8(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test9(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test10(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test11(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test12(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test13(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void notInlined(int[] array) {\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331575\n+ * @summary C2: crash when ConvL2I is split thru phi at LongCountedLoop\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-TieredCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:StressSeed=92643864 TestLongCountedLoopConvL2I\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-TieredCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestLongCountedLoopConvL2I\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestLongCountedLoopConvL2I\n+ *\/\n+\n+public class TestLongCountedLoopConvL2I {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            testHelper1(42);\n+            test1(0);\n+        }\n+    }\n+\n+    private static int test1(int res) {\n+        int k = 1;\n+        for (; k < 2; k *= 2) {\n+        }\n+        long i = testHelper1(k);\n+        for (; i > 0; i--) {\n+            res += 42 \/ ((int) i);\n+            for (int j = 1; j < 10; j *= 2) {\n+\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private static long testHelper1(int k) {\n+        if (k == 2) {\n+            return 100;\n+        } else {\n+            return 99;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestLongCountedLoopConvL2I.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331575\n+ * @summary C2: crash when ConvL2I is split thru phi at LongCountedLoop\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=TestLongCountedLoopConvL2I2.* TestLongCountedLoopConvL2I2\n+ *\/\n+\n+public class TestLongCountedLoopConvL2I2 {\n+    static int x = 34;\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 2; i++) {\n+            test();\n+        }\n+    }\n+\n+    static int test() {\n+        int a = 5, b = 6;\n+        long lArr[] = new long[2];\n+\n+        for (long i = 159; i > 1; i -= 3) {\n+            a += 3;\n+            for (int j = 1; j < 4; j++) {\n+                if (a == 9) {\n+                    if (x == 73) {\n+                        try {\n+                            b = 10 \/ (int) i;\n+                        } catch (ArithmeticException a_e) {\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return b;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestLongCountedLoopConvL2I2.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -44,0 +44,6 @@\n+    static int thread_count = 0;\n+\n+    static synchronized final int get_thread_id() {\n+      return ++thread_count;\n+    }\n+\n@@ -48,1 +54,4 @@\n-            while (true) {\n+            int my_thread_id = get_thread_id();\n+            String msg = \"NastyThread \" + my_thread_id + \" is shutting down\";\n+            try {\n+              while (true) {\n@@ -50,0 +59,4 @@\n+              }\n+            } catch (Exception x) {\n+              \/\/ This is probably a java.lang.OutOfMemoryError exception\n+              System.out.println(msg);\n@@ -57,0 +70,5 @@\n+                \/\/ If we experience OutOfMemoryError during our attempt to instantiate NastyThread, we'll abort\n+                \/\/ main and will not print \"All good\".  We'll also report a non-zero termination code.  In the\n+                \/\/ case that the previously instantiated NastyThread accumulated more than SheanndoahNoProgressThreshold\n+                \/\/ unproductive GC cycles before failing, the main thread may not try a Full GC before it experiences\n+                \/\/ OutOfMemoryError exception.\n@@ -60,0 +78,3 @@\n+                \/\/ Having joined thread, we know the memory consumed by thread is now garbage, and will eventually be\n+                \/\/ collected.  Some or all of that memory may have been promoted, so we may need to perform a Full GC\n+                \/\/ in order to reclaim it quickly.\n@@ -70,0 +91,1 @@\n+                    \"-Xlog:gc*=info\",\n@@ -79,0 +101,4 @@\n+            \/\/ Generational Shenandoah needs a higher value of ShenandaohNoProgressThreshold than traditional\n+            \/\/ Shenandoah.  This is because Generational Shenandoah may experience many failed young-generation\n+            \/\/ GC's which degenerate and increment the count of no-progress collections in the same time that a\n+            \/\/ global collection occurs in traditional Shenandoah.\n@@ -81,1 +107,1 @@\n-                    \"-XX:+UnlockExperimentalVMOptions\", \"-XX:ShenandoahNoProgressThreshold=12\",\n+                    \"-XX:+UnlockExperimentalVMOptions\", \"-XX:ShenandoahNoProgressThreshold=24\",\n@@ -83,0 +109,1 @@\n+                    \"-Xlog:gc*=info\",\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestThreadFailure.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,8 +95,0 @@\n-        if (count != 3) {\n-            Assert.fail(\"Expected three directives - found \" + count);\n-        }\n-\n-        \/\/ Test replacement with some directives from file\n-        output = executor.execute(\"Compiler.directives_replace \" + filename);\n-        output = executor.execute(\"Compiler.directives_print\");\n-        count = find(output, \"Directive:\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerDirectivesDCMDTest.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2023, BELLSOFT. All rights reserved.\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test DirectivesRefreshTest\n- * @summary Test of forced recompile after compiler directives changes by diagnostic command\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *                   -XX:-BackgroundCompilation\n- *                   serviceability.dcmd.compiler.DirectivesRefreshTest\n- *\/\n-\n-package serviceability.dcmd.compiler;\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.dcmd.CommandExecutor;\n-import jdk.test.lib.dcmd.JMXExecutor;\n-\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.lang.reflect.Method;\n-import java.util.Random;\n-\n-import static jdk.test.lib.Asserts.assertEQ;\n-\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_NONE;\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE;\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n-\n-public class DirectivesRefreshTest {\n-\n-    static Path cmdPath = Paths.get(System.getProperty(\"test.src\", \".\"), \"refresh_control.txt\");\n-    static WhiteBox wb = WhiteBox.getWhiteBox();\n-    static Random random = new Random();\n-\n-    static Method method;\n-    static CommandExecutor executor;\n-\n-    static int callable() {\n-        int result = 0;\n-        for (int i = 0; i < 100; i++) {\n-            result += random.nextInt(100);\n-        }\n-        return result;\n-    }\n-\n-    static void checkCompilationLevel(Method method, int level) {\n-        assertEQ(wb.getMethodCompilationLevel(method), level, \"Compilation level\");\n-    }\n-\n-    static void setup() throws Exception {\n-        method = DirectivesRefreshTest.class.getDeclaredMethod(\"callable\");\n-        executor = new JMXExecutor();\n-\n-        System.out.println(\"Compilation with C2\");\n-\n-        \/\/ Happens with fairly hot methods.\n-        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-    }\n-\n-    static void testDirectivesAddRefresh() {\n-        System.out.println(\"Force forbid C2 via directive, method deoptimized\");\n-\n-        var output = executor.execute(\"Compiler.directives_add -r \" + cmdPath.toString());\n-        output.stderrShouldBeEmpty().shouldContain(\"1 compiler directives added\");\n-        \/\/ Current handling of 'Exclude' for '-r' clears flags.\n-        checkCompilationLevel(method, COMP_LEVEL_NONE);\n-\n-        System.out.println(\"C2 is excluded, re-compilation with C1\");\n-\n-        \/\/ Sanity check for the directive.\n-        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-        checkCompilationLevel(method, COMP_LEVEL_NONE);\n-\n-        \/\/ Happens with fairly hot methods.\n-        wb.enqueueMethodForCompilation(method, COMP_LEVEL_SIMPLE);\n-        checkCompilationLevel(method, COMP_LEVEL_SIMPLE);\n-    }\n-\n-    static void testDirectivesClearRefresh() {\n-        System.out.println(\"Re-compilation with C2 due to removed restriction\");\n-\n-        var output = executor.execute(\"Compiler.directives_clear -r\");\n-        output.stderrShouldBeEmpty().stdoutShouldBeEmpty();\n-\n-        \/\/ No need to enqueue the method, \"immediate\" effect of '-r' without deoptimization.\n-        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-    }\n-\n-    static void testDirectivesAddRegular() {\n-        System.out.println(\"No changes if the restriction is not forced\");\n-\n-        \/\/ According to original JEP 165, the directive will be handled\n-        \/\/ \"when a method is submitted for a compilation\".\n-        var output = executor.execute(\"Compiler.directives_add \" + cmdPath.toString());\n-        output.stderrShouldBeEmpty().shouldContain(\"1 compiler directives added\");\n-\n-        \/\/ In this program the method is not called, and here it is not enqueued.\n-        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        setup();\n-        testDirectivesAddRefresh();\n-        testDirectivesClearRefresh();\n-        testDirectivesAddRegular();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/DirectivesRefreshTest.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-[\n-  {\n-    match: \"serviceability.dcmd.compiler.DirectivesRefreshTest::callable\",\n-    c2: {\n-      Exclude: true\n-    }\n-  }\n-]\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/refresh_control.txt","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/AttachConnector\/plugAttachConnect001\/plugAttachConnect001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/AttachConnector\/plugAttachConnect002\/plugAttachConnect002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/AttachConnector\/plugAttachConnect003\/plugAttachConnect003.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/LaunchConnector\/plugLaunchConnect001\/plugLaunchConnect001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/LaunchConnector\/plugLaunchConnect002\/plugLaunchConnect002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/LaunchConnector\/plugLaunchConnect003\/plugLaunchConnect003.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/ListenConnector\/plugListenConnect001\/plugListenConnect001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/ListenConnector\/plugListenConnect002\/plugListenConnect002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/ListenConnector\/plugListenConnect003\/plugListenConnect003.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,1 +179,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect001\/plugMultiConnect001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect002\/plugMultiConnect002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,1 +217,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect003\/plugMultiConnect003.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,1 +236,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect004\/plugMultiConnect004.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,1 +241,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect005\/plugMultiConnect005.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect006\/plugMultiConnect006.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/TransportService\/transportService001\/transportService001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/TransportService\/transportService002\/transportService002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,1 +139,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/TransportService\/transportService003\/transportService003.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -161,1 +161,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/genericSignature\/genericSignature001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/genericSignature\/genericSignature001a.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -143,1 +143,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/genericSignature\/genericSignature002.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/genericSignature\/genericSignature002a.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,1 +186,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/TypeComponent\/genericSignature\/genericSignature001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/TypeComponent\/genericSignature\/genericSignature001a.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -178,1 +178,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/TypeComponent\/genericSignature\/genericSignature002.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,1 +291,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/TypeComponent\/genericSignature\/genericSignature002a.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,3 +59,0 @@\n- * Additionally, in verbose mode a summary of all occured errors will be printed\n- * at the program exit, by automatically invoking method\n- * <code>printErrorsSummary()<\/code>.\n@@ -72,1 +69,1 @@\n-public class Log extends FinalizableObject {\n+public class Log {\n@@ -75,2 +72,0 @@\n-     *\n-     * @deprecated  Tests should not use this field directly.\n@@ -78,2 +73,1 @@\n-    @Deprecated\n-    protected PrintStream out = null;\n+    private PrintStream out = null;\n@@ -117,1 +111,1 @@\n-            if ( level == null )\n+           if ( level == null )\n@@ -138,10 +132,0 @@\n-    \/**\n-     * Is printing errors summary enabled? Default value is <code>true<\/code>;\n-     *\/\n-    private boolean errorsSummaryEnabled = true;\n-\n-    \/**\n-     * Is printing saved verbose messages on error enabled? Default value is <code>true<\/code>;\n-     *\/\n-    private boolean verboseOnErrorEnabled = true;\n-\n@@ -191,2 +175,0 @@\n-        \/\/ install finalizer to print errors summary at exit\n-        registerCleanup();\n@@ -237,28 +219,0 @@\n-    \/**\n-     * Return <i>true<\/i> if printing errors summary at exit is enabled.\n-     *\/\n-    public boolean isErrorsSummaryEnabled() {\n-        return errorsSummaryEnabled;\n-    }\n-\n-    \/**\n-     * Enable or disable printing errors summary at exit.\n-     *\/\n-    public void enableErrorsSummary(boolean enable) {\n-        errorsSummaryEnabled = enable;\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if printing saved verbose messages on error is enabled.\n-     *\/\n-    public boolean isVerboseOnErrorEnabled() {\n-        return errorsSummaryEnabled;\n-    }\n-\n-    \/**\n-     * Enable or disable printing saved verbose messages on error.\n-     *\/\n-    public void enableVerboseOnError(boolean enable) {\n-        verboseOnErrorEnabled = enable;\n-    }\n-\n@@ -318,1 +272,1 @@\n-        if (!verbose() && isVerboseOnErrorEnabled()) {\n+        if (!verbose()) {\n@@ -374,2 +328,0 @@\n-        } else if (isVerboseOnErrorEnabled()) {\n-            keepLog(composeLine(message.toString()));\n@@ -377,1 +329,1 @@\n-            \/\/ ignore\n+            keepLog(composeLine(message.toString()));\n@@ -387,1 +339,1 @@\n-        if (!verbose() && isVerboseOnErrorEnabled()) {\n+        if (!verbose()) {\n@@ -398,3 +350,0 @@\n-        if (isErrorsSummaryEnabled()) {\n-            keepError(msgStr);\n-        }\n@@ -472,1 +421,3 @@\n-        cleanup(); \/\/ flush older log stream\n+        if (out != null) {\n+            out.flush();\n+        }\n@@ -576,53 +527,0 @@\n-    \/**\n-     * Keep the given error <code>message<\/code> into <code>errorsBuffer<\/code>.\n-     *\/\n-    private synchronized void keepError(String message) {\n-        errorsBuffer.addElement(message);\n-    }\n-\n-    \/**\n-     * Print errors messages summary from errors buffer if any;\n-     * print a warning message first.\n-     *\/\n-    private synchronized void printErrorsSummary() {\n-        if (errorsBuffer.size() <= 0)\n-            return;\n-\n-        PrintStream stream = findOutStream();\n-        stream.println();\n-        stream.println();\n-        stream.println(\"#>  \");\n-        stream.println(\"#>  SUMMARY: Following errors occured\");\n-        stream.println(\"#>      during test execution:\");\n-        stream.println(\"#>  \");\n-        stream.flush();\n-\n-        for (Enumeration e = errorsBuffer.elements(); e.hasMoreElements(); ) {\n-            printError((String) e.nextElement());\n-        }\n-    }\n-\n-    \/**\n-     * Print errors summary if mode is verbose, flush and cancel output stream.\n-     *\n-     * This is replacement of the finalize() method and is called when this\n-     * Log instance becomes unreachable.\n-     *\n-     *\/\n-    @Override\n-    public void cleanup() {\n-        if (verbose() && isErrorsSummaryEnabled()) {\n-            printErrorsSummary();\n-        }\n-        if (out != null)\n-            out.flush();\n-        out = null;\n-    }\n-\n-    \/**\n-     * Perform finalization at the exit.\n-     *\/\n-    public void finalizeAtExit() {\n-        cleanup();\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/Log.java","additions":10,"deletions":112,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,2 +150,0 @@\n-        log.enableErrorsSummary(false);\n-        log.enableVerboseOnError(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/BindServer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,1 +238,0 @@\n-        Env.getLog().enableVerboseOnError(true);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/MlvmTestExecutor.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-com\/sun\/jdi\/cds\/CDSBreakpointTest.java 8307778 generic-all\n-com\/sun\/jdi\/cds\/CDSDeleteAllBkptsTest.java 8307778 generic-all\n-com\/sun\/jdi\/cds\/CDSFieldWatchpoints.java 8307778 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-            getPropOpt(\"test.classes\"),\n+            getPropOpt(\"test.class.path\"),\n","filename":"test\/jdk\/com\/sun\/jdi\/cds\/CDSJDITest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceAdapter;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionAdapter;\n+import java.awt.event.MouseMotionListener;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 4613903\n+ * @summary verifies that mouse events are not dispatched during drag\n+ * @key headful\n+ * @run main MouseEventAfterStartDragTest\n+ *\/\n+\n+public final class MouseEventAfterStartDragTest implements AWTEventListener {\n+    final Frame frame = new Frame();\n+    volatile Point srcPoint;\n+    volatile Dimension d;\n+    volatile MouseEvent lastMouseEvent = null;\n+    volatile boolean passed = true;\n+    final DragSource dragSource = DragSource.getDefaultDragSource();\n+    final Transferable transferable = new StringSelection(\"TEXT\");\n+\n+    final MouseMotionListener mouseMotionListener = new MouseMotionAdapter() {\n+        public void mouseDragged(MouseEvent e) {\n+            System.out.println(\"mouseDragged: \" + e\n+                    + \", hash:\" + e.hashCode());\n+            if (lastMouseEvent != null && !e.equals(lastMouseEvent)) {\n+                System.out.println(\"Unexpected: \" + e\n+                        + \", hash:\" + e.hashCode());\n+                passed = false;\n+            }\n+        }\n+    };\n+\n+    final DragSourceListener dragSourceListener = new DragSourceAdapter() {\n+        public void dragDropEnd(DragSourceDragEvent dsde) {\n+            System.out.println(\"dragDropEnd: \" + dsde);\n+            lastMouseEvent = null;\n+        }\n+    };\n+\n+    final DragGestureListener dragGestureListener = new DragGestureListener() {\n+        public void dragGestureRecognized(DragGestureEvent dge) {\n+            System.out.println(\"dragGestureRecognized: \" + dge);\n+            Object[] events = dge.toArray();\n+            Object lastEvent = events[events.length - 1];\n+            if (lastEvent instanceof MouseEvent) {\n+                lastMouseEvent = (MouseEvent) lastEvent;\n+            }\n+            System.out.println(\"The last mouse event: \" + lastMouseEvent\n+                    + \", hash:\" + lastMouseEvent.hashCode());\n+            dge.startDrag(null, transferable, dragSourceListener);\n+        }\n+    };\n+\n+    static final Object SYNC_LOCK = new Object();\n+    static final int MOUSE_RELEASE_TIMEOUT = 1000;\n+    volatile Component clickedComponent = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"awt.dnd.drag.threshold\", \"0\");\n+        MouseEventAfterStartDragTest app = new MouseEventAfterStartDragTest();\n+        try {\n+            app.createAndShowGUI();\n+            app.test();\n+        } finally {\n+            app.dispose();\n+        }\n+    }\n+\n+    public void createAndShowGUI() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            frame.setTitle(\"Test frame\");\n+            frame.setBounds(100, 100, 200, 200);\n+            frame.setLocationRelativeTo(null);\n+            frame.addMouseMotionListener(mouseMotionListener);\n+            dragSource.createDefaultDragGestureRecognizer(frame, DnDConstants.ACTION_COPY_OR_MOVE,\n+                    dragGestureListener);\n+\n+            frame.getToolkit().addAWTEventListener(this, AWTEvent.MOUSE_EVENT_MASK);\n+            frame.setVisible(true);\n+        });\n+    }\n+\n+    public static int sign(int n) {\n+        return n < 0 ? -1 : n == 0 ? 0 : 1;\n+    }\n+\n+    public void test() throws Exception {\n+        final Robot robot = new Robot();\n+        robot.setAutoDelay(45);\n+        robot.waitForIdle();\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            srcPoint = frame.getLocationOnScreen();\n+            d = frame.getSize();\n+        });\n+        srcPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!pointInComponent(robot, srcPoint, frame)) {\n+            System.err.println(\"WARNING: Couldn't locate source frame.\");\n+            return;\n+        }\n+\n+        final Point dstPoint = new Point(srcPoint);\n+        dstPoint.translate(d.width \/ 4, d.height \/ 4);\n+\n+        if (!pointInComponent(robot, dstPoint, frame)) {\n+            System.err.println(\"WARNING: Couldn't locate target frame.\");\n+            return;\n+        }\n+\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseMove(srcPoint.x, srcPoint.y);\n+        robot.delay(250);\n+        System.out.println(\"srcPoint = \" + srcPoint);\n+        for (; !srcPoint.equals(dstPoint);\n+                srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                sign(dstPoint.y - srcPoint.y))) {\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            System.out.println(\"srcPoint = \" + srcPoint);\n+        }\n+\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        System.out.println(\"done\");\n+        robot.waitForIdle();\n+        robot.delay(MOUSE_RELEASE_TIMEOUT);\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    public void dispose() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        });\n+    }\n+\n+    public void reset() {\n+        clickedComponent = null;\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n+            clickedComponent = (Component) e.getSource();\n+            synchronized (SYNC_LOCK) {\n+                SYNC_LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    boolean pointInComponent(Robot robot, Point p, Component comp)\n+            throws InterruptedException {\n+        robot.waitForIdle();\n+        reset();\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n+        }\n+\n+        Component c = clickedComponent;\n+\n+        while (c != null && c != comp) {\n+            c = c.getParent();\n+        }\n+\n+        return c == comp;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/MouseEventAfterStartDragTest\/MouseEventAfterStartDragTest.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.Arrays;\n@@ -41,0 +42,1 @@\n+import java.util.stream.Stream;\n@@ -314,0 +316,18 @@\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testOffsetHandleOOBIndex(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                 long expectedByteOffset) throws Throwable {\n+        int[] badIndices = { -1, 10 };\n+        MemoryLayout seqLayout = MemoryLayout.sequenceLayout(badIndices[1], layout);\n+        for (int badIndex : badIndices) {\n+            PathElement[] seqPathElements = new PathElement[pathElements.length + 1];\n+            long[] seqIndexes = new long[indexes.length + 1];\n+            System.arraycopy(pathElements, 0, seqPathElements, 1, pathElements.length);\n+            System.arraycopy(indexes, 0, seqIndexes, 1, indexes.length);\n+            seqPathElements[0] = PathElement.sequenceElement();\n+            seqIndexes[0] = badIndex;\n+            MethodHandle seqByteOffsetHandle = seqLayout.byteOffsetHandle(seqPathElements)\n+                    .asSpreader(long[].class, seqIndexes.length);\n+            assertThrows(IndexOutOfBoundsException.class, () -> seqByteOffsetHandle.invoke(0L, seqIndexes));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @bug 8330276\n+ * @summary Tests Console methods that have Locale as an argument\n+ * @library \/test\/lib\n+ * @modules jdk.internal.le jdk.localedata\n+ *\/\n+public class LocaleTest {\n+    private static Calendar TODAY  = new GregorianCalendar(2024, Calendar.APRIL, 22);\n+    private static String FORMAT = \"%1$tY-%1$tB-%1$te %1$tA\";\n+    \/\/ We want to limit the expected strings within US-ASCII charset, as\n+    \/\/ the native encoding is determined as such, which is used by\n+    \/\/ the `Process` class under jtreg environment.\n+    private static List<String> EXPECTED = List.of(\n+        String.format(Locale.UK, FORMAT, TODAY),\n+        String.format(Locale.FRANCE, FORMAT, TODAY),\n+        String.format(Locale.GERMANY, FORMAT, TODAY),\n+        String.format(Locale.of(\"es\"), FORMAT, TODAY),\n+        String.format((Locale)null, FORMAT, TODAY),\n+        String.format((Locale)null, FORMAT, TODAY),\n+        String.format((Locale)null, FORMAT, TODAY),\n+        String.format((Locale)null, FORMAT, TODAY)\n+    );\n+\n+    public static void main(String... args) throws Throwable {\n+        if (args.length == 0) {\n+            \/\/ no arg will launch the child process that actually perform tests\n+            var pb = ProcessTools.createTestJavaProcessBuilder(\n+                    \"LocaleTest\", \"dummy\");\n+            var input = new File(System.getProperty(\"test.src\", \".\"), \"input.txt\");\n+            pb.redirectInput(input);\n+            var oa = ProcessTools.executeProcess(pb);\n+            if (oa.getExitValue() == -1) {\n+                System.out.println(\"System.console() returns null. Ignoring the test.\");\n+            } else {\n+                var output = oa.asLines();\n+                var resultText =\n+                    \"\"\"\n+                    Actual output: %s\n+                    Expected output: %s\n+                    \"\"\".formatted(output, EXPECTED);\n+                if (!output.equals(EXPECTED)) {\n+                    throw new RuntimeException(\"Standard out had unexpected strings:\\n\" + resultText);\n+                } else {\n+                    oa.shouldHaveExitValue(0);\n+                    System.out.println(\"Formatting with explicit Locale succeeded.\\n\" + resultText);\n+                }\n+            }\n+        } else {\n+            var con = System.console();\n+            if (con != null) {\n+                \/\/ tests these additional methods that take a Locale\n+                con.format(Locale.UK, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.printf(Locale.FRANCE, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.readLine(Locale.GERMANY, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.readPassword(Locale.of(\"es\"), FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+\n+                \/\/ tests null locale\n+                con.format((Locale)null, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.printf((Locale)null, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.readLine((Locale)null, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.readPassword((Locale)null, FORMAT, TODAY);\n+            } else {\n+                \/\/ Exit with -1\n+                System.exit(-1);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/LocaleTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+import java.time.Duration;\n@@ -68,0 +69,1 @@\n+import static org.testng.Assert.assertThrows;\n@@ -71,1 +73,1 @@\n- * @bug 8273369\n+ * @bug 8273369 8331202\n@@ -123,0 +125,29 @@\n+\n+    @DataProvider\n+    private Object[][] provider_until_1arg() {\n+        Instant t1 = Instant.ofEpochSecond(0, 10);\n+        Instant t2 = Instant.ofEpochSecond(10, -20);\n+        return new Object[][] {\n+            {t1, t2},\n+            {t2, t1},\n+            {Instant.MIN, Instant.MAX},\n+            {Instant.MAX, Instant.MIN},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provider_until_1arg\")\n+    public void test_until_1arg(Instant start, Instant end) {\n+        Duration result = start.until(end);\n+        Duration expected = Duration.ofSeconds(end.getEpochSecond() - start.getEpochSecond(),\n+                end.getNano() - start.getNano());\n+        assertEquals(result, expected);\n+        expected = Duration.between(start, end);\n+        assertEquals(result, expected);\n+    }\n+\n+    @Test\n+    public void test_until_1arg_NPE() {\n+        assertThrows(NullPointerException.class, () -> {\n+            Instant.now().until(null);\n+        });\n+    }\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/TestInstant.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -202,0 +202,7 @@\n+    void checkCancellationException(CancellationException thrown, String message) {\n+        assertTrue(message.equals(thrown.getMessage()));\n+\n+        assertTrue(thrown.getCause() instanceof CancellationException);\n+        assertTrue(thrown.getCause().getCause() == null);\n+    }\n+\n@@ -208,0 +215,1 @@\n+            checkCancellationException(success, \"get\");\n@@ -214,1 +222,3 @@\n-        } catch (CancellationException success) {}\n+        } catch (CancellationException success) {\n+            checkCancellationException(success, \"join\");\n+        }\n@@ -218,1 +228,3 @@\n-        } catch (CancellationException success) {}\n+        } catch (CancellationException success) {\n+            checkCancellationException(success, \"getNow\");\n+        }\n@@ -223,0 +235,1 @@\n+            checkCancellationException(success, \"get\");\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/CompletableFutureTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8320360 8330684 8331320 8331655\n+ * @bug 8320360 8330684 8331320 8331655 8331940\n@@ -38,0 +38,2 @@\n+import java.lang.classfile.attribute.LineNumberInfo;\n+import java.lang.classfile.attribute.LineNumberTableAttribute;\n@@ -40,0 +42,2 @@\n+import java.util.List;\n+import jdk.internal.classfile.impl.DirectCodeBuilder;\n@@ -164,0 +168,10 @@\n+\n+    @Test\n+    void testLineNumberOutOfBounds() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                ClassFile.of().parse(ClassFile.of().build(ClassDesc.of(\"LineNumberClass\"), cb -> cb.withMethodBody(\n+                \"lineNumberMethod\", MethodTypeDesc.of(ConstantDescs.CD_void), 0, cob -> ((DirectCodeBuilder)cob\n+                        .return_())\n+                        .writeAttribute(LineNumberTableAttribute.of(List.of(LineNumberInfo.of(500, 0))))\n+                ))).methods().get(0).code().get().elementList());\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -514,0 +514,22 @@\n+\/*\n+ * @test id=globalsignr46\n+ * @bug 8316138\n+ * @summary Interoperability tests with GlobalSign Root R46\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsignr46 OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignr46 OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsignr46 CRL\n+ *\/\n+\n+\/*\n+ * @test id=globalsigne46\n+ * @bug 8316138\n+ * @summary Interoperability tests with GlobalSign Root E46\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsigne46 OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigne46 OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsigne46 CRL\n+ *\/\n+\n@@ -683,0 +705,7 @@\n+            case \"globalsignr46\" ->\n+                    new CATestURLs(\"https:\/\/valid.r46.roots.globalsign.com\",\n+                            \"https:\/\/revoked.r46.roots.globalsign.com\");\n+            case \"globalsigne46\" ->\n+                    new CATestURLs(\"https:\/\/valid.e46.roots.globalsign.com\",\n+                            \"https:\/\/revoked.e46.roots.globalsign.com\");\n+\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @summary Http keep-alive implementation is not efficient\n@@ -29,1 +30,0 @@\n- * @summary Http keep-alive implementation is not efficient\n@@ -45,0 +45,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -51,0 +52,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -52,1 +55,1 @@\n- * The http client makes a connection to a URL whos content contains a lot of\n+ * The http client makes a connection to a URL whose content contains a lot of\n@@ -66,5 +69,1 @@\n-\n-    public static void main(String[] args) {\n-        startHttpServer();\n-        clientHttpCalls();\n-    }\n+    static ExecutorService executor = Executors.newSingleThreadExecutor();\n@@ -74,3 +73,1 @@\n-            server = HttpServer.create(new InetSocketAddress(InetAddress.getLocalHost(), 0), 10, \"\/\", new SimpleHttpTransactionHandler());\n-            server.setExecutor(Executors.newSingleThreadExecutor());\n-            server.start();\n+            server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 10, \"\/\", new SimpleHttpTransactionHandler());\n@@ -78,1 +75,1 @@\n-            e.printStackTrace();\n+            throw new RuntimeException(e);\n@@ -80,0 +77,3 @@\n+        server.setExecutor(executor);\n+        server.start();\n+        System.out.println(\"http server listens on: \" + server.getAddress());\n@@ -82,1 +82,6 @@\n-    public static void clientHttpCalls() {\n+    public static void stopHttpServer() {\n+        server.stop(1);\n+        executor.shutdown();\n+    }\n+\n+    public static void clientHttpCalls() throws Exception {\n@@ -87,5 +92,0 @@\n-        try {\n-            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n-            String hostAddr =  InetAddress.getLocalHost().getHostAddress();\n-            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n-            String baseURLStr = \"http:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n@@ -93,2 +93,13 @@\n-            URL bigDataURL = new URL (baseURLStr + \"firstCall\");\n-            URL smallDataURL = new URL (baseURLStr + \"secondCall\");\n+        URL bigDataURL = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(\"\/firstCall\")\n+                .toURL();\n+\n+        URL smallDataURL = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(\"\/secondCall\")\n+                .toURL();\n@@ -96,1 +107,1 @@\n-            HttpURLConnection uc = (HttpURLConnection)bigDataURL.openConnection(Proxy.NO_PROXY);\n+        HttpURLConnection uc = (HttpURLConnection)bigDataURL.openConnection(Proxy.NO_PROXY);\n@@ -98,2 +109,2 @@\n-            \/\/Only read 1 byte of response data and close the stream\n-            InputStream is = uc.getInputStream();\n+        \/\/ Only read 1 byte of response data and close the stream\n+        try (InputStream is = uc.getInputStream()) {\n@@ -102,41 +113,45 @@\n-            is.close();\n-\n-            \/\/ Allow the KeepAliveStreamCleaner thread to read the data left behind and cache the connection.\n-            try { Thread.sleep(2000); } catch (Exception e) {}\n-\n-            uc = (HttpURLConnection)smallDataURL.openConnection(Proxy.NO_PROXY);\n-            uc.getResponseCode();\n-\n-            if (SimpleHttpTransactionHandler.failed)\n-                throw new RuntimeException(\"Failed: Initial Keep Alive Connection is not being reused\");\n-\n-            \/\/ Part 2\n-            URL part2Url = new URL (baseURLStr + \"part2\");\n-            uc = (HttpURLConnection)part2Url.openConnection(Proxy.NO_PROXY);\n-            is = uc.getInputStream();\n-            is.close();\n-\n-            \/\/ Allow the KeepAliveStreamCleaner thread to try and read the data left behind and cache the connection.\n-            try { Thread.sleep(2000); } catch (Exception e) {}\n-\n-            ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n-            if (threadMXBean.isThreadCpuTimeSupported()) {\n-                long[] threads = threadMXBean.getAllThreadIds();\n-                ThreadInfo[] threadInfo = threadMXBean.getThreadInfo(threads);\n-                for (int i=0; i<threadInfo.length; i++) {\n-                    if (threadInfo[i].getThreadName().equals(\"Keep-Alive-SocketCleaner\"))  {\n-                        System.out.println(\"Found Keep-Alive-SocketCleaner thread\");\n-                        long threadID = threadInfo[i].getThreadId();\n-                        long before = threadMXBean.getThreadCpuTime(threadID);\n-                        try { Thread.sleep(2000); } catch (Exception e) {}\n-                        long after = threadMXBean.getThreadCpuTime(threadID);\n-\n-                        if (before ==-1 || after == -1)\n-                            break;  \/\/ thread has died, OK\n-\n-                        \/\/ if Keep-Alive-SocketCleaner consumes more than 50% of cpu then we\n-                        \/\/ can assume a recursive loop.\n-                        long total = after - before;\n-                        if (total >= 1000000000)  \/\/ 1 second, or 1 billion nanoseconds\n-                            throw new RuntimeException(\"Failed: possible recursive loop in Keep-Alive-SocketCleaner\");\n-                    }\n+        }\n+\n+        \/\/ Allow the KeepAliveStreamCleaner thread to read the data left behind and cache the connection.\n+        try { Thread.sleep(2000); } catch (Exception e) {}\n+\n+        uc = (HttpURLConnection)smallDataURL.openConnection(Proxy.NO_PROXY);\n+        uc.getResponseCode();\n+\n+        if (SimpleHttpTransactionHandler.failed)\n+            throw new RuntimeException(\"Failed: Initial Keep Alive Connection is not being reused\");\n+\n+        \/\/ Part 2\n+        URL part2Url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(\"\/part2\")\n+                .toURL();\n+\n+        uc = (HttpURLConnection)part2Url.openConnection(Proxy.NO_PROXY);\n+        try (InputStream is = uc.getInputStream()) {}\n+\n+        \/\/ Allow the KeepAliveStreamCleaner thread to try and read the data left behind and cache the connection.\n+        try { Thread.sleep(2000); } catch (Exception e) {}\n+\n+        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n+        if (threadMXBean.isThreadCpuTimeSupported()) {\n+            long[] threads = threadMXBean.getAllThreadIds();\n+            ThreadInfo[] threadInfo = threadMXBean.getThreadInfo(threads);\n+            for (int i = 0; i < threadInfo.length; i++) {\n+                if (threadInfo[i].getThreadName().equals(\"Keep-Alive-SocketCleaner\")) {\n+                    System.out.println(\"Found Keep-Alive-SocketCleaner thread\");\n+                    long threadID = threadInfo[i].getThreadId();\n+                    long before = threadMXBean.getThreadCpuTime(threadID);\n+                    try { Thread.sleep(2000); } catch (Exception e) {}\n+                    long after = threadMXBean.getThreadCpuTime(threadID);\n+\n+                    if (before ==-1 || after == -1)\n+                        break;  \/\/ thread has died, OK\n+\n+                    \/\/ if Keep-Alive-SocketCleaner consumes more than 50% of cpu then we\n+                    \/\/ can assume a recursive loop.\n+                    long total = after - before;\n+                    if (total >= 1000000000)  \/\/ 1 second, or 1 billion nanoseconds\n+                        throw new RuntimeException(\"Failed: possible recursive loop in Keep-Alive-SocketCleaner\");\n@@ -145,5 +160,0 @@\n-\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        } finally {\n-            server.stop(1);\n@@ -155,1 +165,0 @@\n-}\n@@ -157,3 +166,2 @@\n-class SimpleHttpTransactionHandler implements HttpHandler\n-{\n-    static volatile boolean failed = false;\n+    static class SimpleHttpTransactionHandler implements HttpHandler {\n+        static volatile boolean failed = false;\n@@ -161,3 +169,3 @@\n-    \/\/ Need to have enough data here that is too large for the socket buffer to hold.\n-    \/\/ Also http.KeepAlive.remainingData must be greater than this value, default is 256K.\n-    static final int RESPONSE_DATA_LENGTH = 128 * 1024;\n+        \/\/ Need to have enough data here that is too large for the socket buffer to hold.\n+        \/\/ Also http.KeepAlive.remainingData must be greater than this value, default is 256K.\n+        static final int RESPONSE_DATA_LENGTH = 128 * 1024;\n@@ -165,1 +173,1 @@\n-    int port1;\n+        int port1;\n@@ -167,12 +175,36 @@\n-    public void handle(HttpExchange trans) {\n-        try {\n-            String path = trans.getRequestURI().getPath();\n-            if (path.equals(\"\/firstCall\")) {\n-                port1 = trans.getRemoteAddress().getPort();\n-                System.out.println(\"First connection on client port = \" + port1);\n-\n-                byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n-                for (int i=0; i<responseBody.length; i++)\n-                    responseBody[i] = 0x41;\n-                trans.sendResponseHeaders(200, responseBody.length);\n-                try (OutputStream os = trans.getResponseBody()) {\n+        public void handle(HttpExchange trans) {\n+            try {\n+                String path = trans.getRequestURI().getPath();\n+                if (path.equals(\"\/firstCall\")) {\n+                    port1 = trans.getRemoteAddress().getPort();\n+                    System.out.println(\"First connection on client port = \" + port1);\n+\n+                    byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n+                    for (int i=0; i<responseBody.length; i++)\n+                        responseBody[i] = 0x41;\n+                    trans.sendResponseHeaders(200, responseBody.length);\n+                    try (OutputStream os = trans.getResponseBody()) {\n+                        os.write(responseBody);\n+                    }\n+                } else if (path.equals(\"\/secondCall\")) {\n+                    int port2 = trans.getRemoteAddress().getPort();\n+                    System.out.println(\"Second connection on client port = \" + port2);\n+\n+                    if (port1 != port2)\n+                        failed = true;\n+\n+                     \/* Force the server to not respond for more that the timeout\n+                      * set by the keepalive cleaner (5000 millis). This ensures the\n+                      * timeout is correctly resets the default read timeout,\n+                      * infinity. See 6993490. *\/\n+                    System.out.println(\"server sleeping...\");\n+                    try {Thread.sleep(6000); } catch (InterruptedException e) {}\n+                    trans.sendResponseHeaders(200, -1);\n+                } else if (path.equals(\"\/part2\")) {\n+                    System.out.println(\"Call to \/part2\");\n+                    byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n+                    for (int i=0; i<responseBody.length; i++)\n+                        responseBody[i] = 0x41;\n+                    \/\/ override the Content-length header to be greater than the actual response body\n+                    trans.sendResponseHeaders(200, responseBody.length+1);\n+                    OutputStream os = trans.getResponseBody();\n@@ -180,0 +212,3 @@\n+                    \/\/ now close the socket\n+                    \/\/ closing the stream here would throw; close the exchange instead\n+                    trans.close();\n@@ -181,26 +216,3 @@\n-            } else if (path.equals(\"\/secondCall\")) {\n-                int port2 = trans.getRemoteAddress().getPort();\n-                System.out.println(\"Second connection on client port = \" + port2);\n-\n-                if (port1 != port2)\n-                    failed = true;\n-\n-                 \/* Force the server to not respond for more that the timeout\n-                  * set by the keepalive cleaner (5000 millis). This ensures the\n-                  * timeout is correctly resets the default read timeout,\n-                  * infinity. See 6993490. *\/\n-                System.out.println(\"server sleeping...\");\n-                try {Thread.sleep(6000); } catch (InterruptedException e) {}\n-                trans.sendResponseHeaders(200, -1);\n-            } else if(path.equals(\"\/part2\")) {\n-                System.out.println(\"Call to \/part2\");\n-                byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n-                for (int i=0; i<responseBody.length; i++)\n-                    responseBody[i] = 0x41;\n-                \/\/ override the Content-length header to be greater than the actual response body\n-                trans.sendResponseHeaders(200, responseBody.length+1);\n-                OutputStream os = trans.getResponseBody();\n-                os.write(responseBody);\n-                \/\/ now close the socket\n-                \/\/ closing the stream here would throw; close the exchange instead\n-                trans.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                failed = true;\n@@ -208,2 +220,9 @@\n-        } catch (Exception e) {\n-            e.printStackTrace();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        startHttpServer();\n+        try {\n+            clientHttpCalls();\n+        } finally {\n+            stopHttpServer();\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B5045306.java","additions":136,"deletions":117,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637 timeout\n- * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637 max\n+ * @library \/test\/lib\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637\n@@ -34,1 +34,4 @@\n-import java.net.*;\n+import java.net.HttpURLConnection;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n@@ -38,0 +41,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -41,3 +46,1 @@\n-    static class Server extends Thread {\n-        final ServerSocket serverSocket;\n-        final int port;\n+    static class Server extends Thread implements AutoCloseable {\n@@ -45,0 +48,2 @@\n+        final ServerSocket serverSocket = new ServerSocket(0);\n+        final int port;\n@@ -48,1 +53,1 @@\n-            serverSocket = new ServerSocket(0);\n+            this.param = param;\n@@ -51,1 +56,0 @@\n-            this.param = param;\n@@ -58,6 +62,4 @@\n-        public void close() {\n-            try {\n-                serverSocket.close();\n-                if (s != null)\n-                    s.close();\n-            } catch (IOException e) {}\n+        public void close() throws IOException {\n+            serverSocket.close();\n+            if (s != null)\n+                s.close();\n@@ -128,15 +130,13 @@\n-    public static void main(String[] args) throws Exception {\n-        Server server = new Server(args[0]);\n-        int port = server.getPort();\n-        server.start();\n-        URL url = new URL(\"http:\/\/127.0.0.1:\" + Integer.toString(port) + \"\/\");\n-        HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n-        InputStream i = urlc.getInputStream();\n-        int c,count=0;\n-        byte[] buf = new byte[256];\n-        while ((c=i.read(buf)) != -1) {\n-            count+=c;\n-        }\n-        i.close();\n-        System.out.println(\"Read \" + count );\n-        try {\n+    public static void runTest(String param) throws Exception {\n+        try (Server server = new Server(param)) {\n+            server.start();\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(server.getPort())\n+                    .path(\"\/\")\n+                    .toURL();\n+            HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n+            try (InputStream i = urlc.getInputStream()) {\n+                System.out.println(\"Read \" + i.readAllBytes().length);\n+            }\n@@ -148,2 +148,0 @@\n-        } finally {\n-            server.close();\n@@ -152,0 +150,5 @@\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(\"timeout\");\n+        runTest(\"max\");\n+    }\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B8291637.java","additions":35,"deletions":32,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @summary Http keep-alive thread should close sockets without holding a lock\n@@ -29,1 +30,0 @@\n- * @summary Http keep-alive thread should close sockets without holding a lock\n@@ -32,9 +32,0 @@\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-import javax.net.ssl.HandshakeCompletedListener;\n-import javax.net.ssl.HttpsURLConnection;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.SSLSocket;\n-import javax.net.ssl.SSLSocketFactory;\n@@ -56,0 +47,12 @@\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -76,4 +79,1 @@\n-            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n-            String hostAddr = InetAddress.getLoopbackAddress().getHostAddress();\n-            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n-            String baseURLStr = \"https:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n+            System.out.println(\"http server listens on: \" + server.getAddress().getPort());\n@@ -81,1 +81,5 @@\n-            URL testUrl = new URL (baseURLStr);\n+            URL testUrl = URIBuilder.newBuilder()\n+                    .scheme(\"https\")\n+                    .loopback()\n+                    .port(server.getAddress().getPort())\n+                    .toURL();\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B8293562.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/test\/lib\n@@ -28,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -33,4 +33,14 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.charset.*;\n-import java.util.logging.*;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n@@ -38,0 +48,1 @@\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveProperty.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/test\/lib\n@@ -29,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -33,2 +33,11 @@\n-import java.net.*;\n-import java.io.*;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+\n@@ -36,0 +45,1 @@\n+\n@@ -134,2 +144,0 @@\n-\n-        grp.destroy();\n@@ -137,1 +145,0 @@\n-\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveTimerThread.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- *      8321408\n+ *      8321408 8316138\n@@ -51,1 +51,1 @@\n-    private static final int COUNT = 108;\n+    private static final int COUNT = 110;\n@@ -56,1 +56,1 @@\n-            = \"C4:A2:41:9E:B6:4D:77:26:AA:21:02:83:51:C7:88:21:66:1E:D8:88:4A:AC:84:D5:B0:15:0C:7C:C6:45:85:AF\";\n+            = \"BD:80:65:81:68:E5:6C:51:64:ED:B9:08:53:9F:BB:2F:D9:6C:5D:D4:06:D4:16:59:39:10:8E:F8:24:81:8B:78\";\n@@ -281,0 +281,4 @@\n+            put(\"globalsignr46 [jdk]\",\n+                    \"4F:A3:12:6D:8D:3A:11:D1:C4:85:5A:4F:80:7C:BA:D6:CF:91:9D:3A:5A:88:B0:3B:EA:2C:63:72:D9:3C:40:C9\");\n+            put(\"globalsigne46 [jdk]\",\n+                    \"CB:B9:C4:4D:84:B8:04:3E:10:50:EA:31:A6:9F:51:49:55:D7:BF:D2:E2:C6:B4:93:01:01:9A:D6:1D:9F:50:58\");\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @key intermittent\n@@ -241,1 +240,1 @@\n-            t.join(1000L);\n+            t.join(4000L);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumptionUpdateBoundValues.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-#  Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+langtools_slow = \\\n+    jdk\/internal\/shellsupport\/doc\/FullJavadocHelperTest.java\n+\n@@ -81,1 +84,2 @@\n-    -:langtools_jshell_unstable\n+    -:langtools_jshell_unstable \\\n+    -:langtools_slow\n@@ -85,1 +89,2 @@\n-    :langtools_jshell_unstable\n+    :langtools_jshell_unstable \\\n+    :langtools_slow\n","filename":"test\/langtools\/TEST.groups","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8189778\n+ * @summary Test JavadocHelper\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/jdk.internal.shellsupport.doc\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @run testng\/timeout=900\/othervm -Xmx1024m FullJavadocHelperTest\n+ *\/\n+\n+import java.io.IOException;\n+\n+import org.testng.annotations.Test;\n+\n+@Test\n+public class FullJavadocHelperTest {\n+\n+    \/*\n+     * Long-running test to retrieve doc comments for enclosed elements of all JDK classes.\n+     *\/\n+    public void testAllDocs() throws IOException {\n+        new JavadocHelperTest().retrieveDocComments(Boolean.TRUE::booleanValue);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/internal\/shellsupport\/doc\/FullJavadocHelperTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n- * @run testng\/timeout=900\/othervm -Xmx1024m JavadocHelperTest\n+ * @run testng JavadocHelperTest\n+ * @key randomness\n@@ -49,0 +50,2 @@\n+import java.util.Random;\n+import java.util.function.BooleanSupplier;\n@@ -386,1 +389,29 @@\n-    public void testAllDocs() throws IOException {\n+    private static long getSeed() {\n+        long seed;\n+        try {\n+            \/\/ Throws NumberFormatException if the property is undefined\n+            seed = Long.parseLong(System.getProperty(\"seed\"));\n+        } catch (NumberFormatException e) {\n+            seed = new Random().nextLong();\n+        }\n+        System.out.println(\"Random Seed: \" + seed);\n+        return seed;\n+    }\n+\n+    \/*\n+     * Retrieves doc comments for a random subset of JDK classes.\n+     * Set the system property `seed` to a random seed to reproduce\n+     * a specific run of this test.\n+     *\/\n+    public void testRandomDocs() throws IOException {\n+        Random random = new Random(getSeed());\n+        \/\/ Run test on 2% of classes, which corresponds to ~ 140 classes\n+        retrieveDocComments(() -> random.nextInt(100) < 2);\n+    }\n+\n+    \/**\n+     * Retrieve documentation of enclosed elements for some or all JDK classes.\n+     *\n+     * @param shouldTest oracle function to decide whether a class should be tested\n+     *\/\n+    protected void retrieveDocComments(BooleanSupplier shouldTest) throws IOException {\n@@ -411,1 +442,1 @@\n-                        compiler.getStandardFileManager(null, null, null)) {\n+                             compiler.getStandardFileManager(null, null, null)) {\n@@ -423,2 +454,4 @@\n-                                    for (Element el : clazz.getEnclosedElements()) {\n-                                        helper.getResolvedDocComment(el);\n+                                    if (shouldTest.getAsBoolean()) {\n+                                        for (Element el : clazz.getEnclosedElements()) {\n+                                            helper.getResolvedDocComment(el);\n+                                        }\n","filename":"test\/langtools\/jdk\/internal\/shellsupport\/doc\/JavadocHelperTest.java","additions":39,"deletions":6,"binary":false,"changes":45,"status":"modified"}]}