{"files":[{"patch":"@@ -1538,0 +1538,46 @@\n+#define KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+static void validate_young_gen_size(ShenandoahHeap* heap, size_t young_cset_regions, size_t old_cset_regions,\n+                                    size_t young_region_count, size_t old_region_count, size_t original_old_region_count,\n+                                    size_t young_reserve, size_t old_reserve) {\n+  ShenandoahYoungGeneration* young_gen = heap->young_generation();\n+  ShenandoahOldGeneration* old_gen = heap->old_generation();\n+  size_t young_capacity = young_gen->max_capacity();\n+  size_t young_used = young_gen->used();\n+  size_t young_used_regions = young_gen->used_regions();\n+  size_t pad_for_promote_in_place = old_gen->get_pad_for_promote_in_place();\n+\n+  size_t free_count = 0;\n+  size_t old_count = 0;\n+  size_t young_count = 0;\n+\n+  for (size_t i = 0; i < heap->num_regions(); i++) {\n+    ShenandoahHeapRegion* r = heap->get_region(i);\n+    switch (r->affiliation()) {\n+      case FREE:\n+        free_count++;\n+        break;\n+      case YOUNG_GENERATION:\n+        young_count++;\n+        break;\n+      case OLD_GENERATION:\n+        old_count++;\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  }\n+  size_t num_regions = heap->num_regions();\n+  assert (young_count * ShenandoahHeapRegion::region_size_bytes() <= young_capacity,\n+          \"young_count (\" SIZE_FORMAT \") * region_size (\" SIZE_FORMAT \") must be <= young_capacity (\" SIZE_FORMAT\n+          \"): free_count (\" SIZE_FORMAT \"), old_count (\" SIZE_FORMAT \"), num_regions (\" SIZE_FORMAT\n+          \"), free_set->capacity (\" SIZE_FORMAT \"), free_set->used (\" SIZE_FORMAT \"), free_set->available (\" SIZE_FORMAT\n+          \"), young_cset_regions (\" SIZE_FORMAT \"), old_cset_regions (\" SIZE_FORMAT \"), young_region_count (\" SIZE_FORMAT\n+          \"), old_region_count (\" SIZE_FORMAT \"), original_old_region_count (\" SIZE_FORMAT \"), young_reserve (\" SIZE_FORMAT\n+          \"), old_reserve (\" SIZE_FORMAT \")\",\n+          young_count, ShenandoahHeapRegion::region_size_bytes(), young_capacity, free_count, old_count, num_regions,\n+          heap->free_set()->capacity(), heap->free_set()->used(), heap->free_set()->available(), young_cset_regions,\n+          old_cset_regions, young_region_count, old_region_count, original_old_region_count, young_reserve, old_reserve);\n+}\n+#endif\n+\n@@ -1551,0 +1597,3 @@\n+#ifdef KELVIN_DEBUG\n+  size_t original_old_region_count = old_region_count;\n+#endif\n@@ -1558,0 +1607,9 @@\n+\n+\n+#ifdef KELVIN_DEBUG\n+  if (_heap->mode()->is_generational()) {\n+    validate_young_gen_size(_heap, young_cset_regions, old_cset_regions, young_region_count, old_region_count,\n+                            original_old_region_count, young_reserve, old_reserve);\n+  }\n+#endif\n+\n@@ -1660,1 +1718,10 @@\n-        \/\/ OLD regions that have available memory are already in the old_collector free set\n+        \/\/ OLD regions that have available memory are already in the old_collector free set.\n+#ifdef KELVIN_DEBUG\n+        \/\/ OLD trashed (CSET) regions are also already in the old_collector free set.\n+        \/\/ It looks to me like we should test (r->is_trash() && r->is_young()) above.  The failure to do so\n+        \/\/ might possibly account for double-counting of certain regions within the old_region_count.  The problem\n+        \/\/ with this hypothesis is it does not explain why we did not experience an assertion failure in\n+        \/\/ _partitions.move_from_partition_to_partition() below.  But if this assertion fails, that is a good\n+        \/\/ clue of where the problem arises.\n+        assert(!r->is_old(), \"Expecting old is-trashed regions to already be in the OldCollector partition\");\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -650,1 +650,1 @@\n-#define KELVIN_DEBUG\n+#undef KELVIN_DEBUG\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}