{"files":[{"patch":"@@ -1027,3 +1027,8 @@\n-    while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n-      control_thread()->handle_alloc_failure(req, true);\n-      result = allocate_memory_under_lock(req, in_new_region);\n+    if (result == nullptr) {\n+      while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n+        control_thread()->handle_alloc_failure(req, true);\n+        result = allocate_memory_under_lock(req, in_new_region);\n+      }\n+      if ((result != nullptr) && mode()->is_generational()) {\n+        notify_gc_progress();\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -87,4 +87,0 @@\n-            \/\/ Generational Shenandoah needs a higher value of ShenandaohNoProgressThreshold than traditional\n-            \/\/ Shenandoah.  This is because Generational Shenandoah may experience many failed young-generation\n-            \/\/ GC's which degenerate and increment the count of no-progress collections in the same time that a\n-            \/\/ global collection occurs in traditional Shenandoah.\n@@ -93,1 +89,1 @@\n-                    \"-XX:+UnlockExperimentalVMOptions\", \"-XX:ShenandoahNoProgressThreshold=24\",\n+                    \"-XX:+UnlockExperimentalVMOptions\",\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestThreadFailure.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}