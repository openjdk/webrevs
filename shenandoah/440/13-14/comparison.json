{"files":[{"patch":"@@ -329,0 +329,1 @@\n+    heap->notify_gc_progress();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -307,0 +307,2 @@\n+#ifdef KELVIN_DEPRECATE\n+    \/\/ We should only increment no-progress count following a full GC failure\n@@ -308,0 +310,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -526,0 +526,1 @@\n+    heap->notify_gc_progress();\n@@ -602,0 +603,1 @@\n+    heap->notify_gc_progress();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -991,2 +991,0 @@\n-    \/\/ Note that Generational Shenandoah may increment no_progress_count faster than traditional Shenandoah because young\n-    \/\/ GCs, which may degenerate, typically occur more frequently than single-generation Global GCs.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}