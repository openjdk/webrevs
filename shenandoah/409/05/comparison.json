{"files":[{"patch":"@@ -546,1 +546,52 @@\n- }\n+}\n+\n+void ShenandoahOldHeuristics::trigger_collection_if_fragmented(ShenandoahGenerationalHeap* gen_heap, ShenandoahOldGeneration* old_gen,\n+                                                               size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions) {\n+  if (ShenandoahGenerationalHumongousReserve > 0) {\n+    size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n+    size_t allowed_old_gen_span = num_regions - (ShenandoahGenerationalHumongousReserve * num_regions) \/ 100;\n+\n+    \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n+    \/\/   if old_gen spans more than 100% and density < 75%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 87.5% and density < 62.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 75% and density < 50%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 62.5% and density < 37.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 50% and density < 25%, trigger old-defrag\n+    \/\/\n+    \/\/ A previous implementation was more aggressive in triggering, resulting in degraded throughput when\n+    \/\/ humongous allocation was not required.\n+\n+    size_t old_available = old_gen->available();\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    size_t old_unaffiliated_available = old_gen->free_unaffiliated_regions() * region_size_bytes;\n+    assert(old_available >= old_unaffiliated_available, \"sanity\");\n+    size_t old_fragmented_available = old_available - old_unaffiliated_available;\n+\n+    size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n+    size_t old_bytes_spanned = old_region_span * region_size_bytes;\n+    double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n+\n+    uint eighths = 8;\n+    for (uint i = 0; i < 5; i++) {\n+      size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n+      double density_threshold = (eighths - 2) \/ 8.0;\n+      if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n+        gen_heap->old_heuristics()->trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n+        return;\n+      }\n+      eighths--;\n+    }\n+  }\n+}\n+\n+void ShenandoahOldHeuristics::trigger_collection_if_overgrown(ShenandoahGenerationalHeap* gen_heap, ShenandoahOldGeneration* old_gen) {\n+  size_t old_used = old_gen->used() + old_gen->get_humongous_waste();\n+  size_t trigger_threshold = old_gen->usage_trigger_threshold();\n+  \/\/ Detects unsigned arithmetic underflow\n+  assert(old_used <= gen_heap->capacity(),\n+         \"Old used (\" SIZE_FORMAT \", \" SIZE_FORMAT\") must not be more than heap capacity (\" SIZE_FORMAT \")\",\n+         old_gen->used(), old_gen->get_humongous_waste(), gen_heap->capacity());\n+  if (old_used > trigger_threshold) {\n+    gen_heap->old_heuristics()->trigger_old_has_grown();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -178,0 +178,4 @@\n+  void trigger_collection_if_fragmented(ShenandoahGenerationalHeap* gen_heap, ShenandoahOldGeneration* old_gen,\n+                                        size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions);\n+  void trigger_collection_if_overgrown(ShenandoahGenerationalHeap* gen_heap, ShenandoahOldGeneration* old_gen);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3201,46 +3201,6 @@\n-  if (mode()->is_generational() && (ShenandoahGenerationalHumongousReserve > 0)) {\n-    size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n-    size_t allowed_old_gen_span = num_regions() - (ShenandoahGenerationalHumongousReserve * num_regions() \/ 100);\n-\n-    \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n-    \/\/   if old_gen spans more than 100% and density < 75%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 87.5% and density < 62.5%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 75% and density < 50%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 62.5% and density < 37.5%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 50% and density < 25%, trigger old-defrag\n-    \/\/\n-    \/\/ A previous implementation was more aggressive in triggering, resulting in degraded throughput when\n-    \/\/ humongous allocation was not required.\n-\n-    ShenandoahGeneration* old_gen = old_generation();\n-    size_t old_available = old_gen->available();\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-    size_t old_unaffiliated_available = old_gen->free_unaffiliated_regions() * region_size_bytes;\n-    assert(old_available >= old_unaffiliated_available, \"sanity\");\n-    size_t old_fragmented_available = old_available - old_unaffiliated_available;\n-\n-    size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n-    size_t old_bytes_spanned = old_region_span * region_size_bytes;\n-    double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n-\n-    uint eighths = 8;\n-    for (uint i = 0; i < 5; i++) {\n-      size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n-      double density_threshold = (eighths - 2) \/ 8.0;\n-      if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n-        old_heuristics()->trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n-        break;\n-      }\n-      eighths--;\n-    }\n-\n-    size_t old_used = old_generation()->used() + old_generation()->get_humongous_waste();\n-    size_t trigger_threshold = old_generation()->usage_trigger_threshold();\n-    \/\/ Detects unsigned arithmetic underflow\n-    assert(old_used <= capacity(),\n-           \"Old used (\" SIZE_FORMAT \", \" SIZE_FORMAT\") must not be more than heap capacity (\" SIZE_FORMAT \")\",\n-           old_generation()->used(), old_generation()->get_humongous_waste(), capacity());\n-\n-    if (old_used > trigger_threshold) {\n-      old_heuristics()->trigger_old_has_grown();\n-    }\n+  if (mode()->is_generational()) {\n+    ShenandoahGenerationalHeap* gen_heap = (ShenandoahGenerationalHeap*) this;\n+    ShenandoahOldGeneration* old_gen = old_generation();\n+    ShenandoahOldHeuristics* old_heuristics = (ShenandoahOldHeuristics*) old_gen->heuristics();\n+    old_heuristics->trigger_collection_if_fragmented(gen_heap, old_gen, first_old_region, last_old_region, old_region_count, num_regions());\n+    old_heuristics->trigger_collection_if_overgrown(gen_heap, old_gen);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":46,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -572,1 +572,2 @@\n-}\n\\ No newline at end of file\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test that growth of old-gen triggers old-gen marking\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @run driver TestOldGrowthTriggers\n+ *\/\n+\n+import java.util.*;\n+import java.math.BigInteger;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestOldGrowthTriggers {\n+\n+  public static void makeOldAllocations() {\n+    \/\/ Expect most of the BigInteger entries placed into array to be promoted, and most will eventually become garbage within old\n+\n+    final int array_size = 256 * 1024;   \/\/ 256K entries\n+    BigInteger array[] = new BigInteger[array_size];\n+    Random r = new Random(46);\n+\n+    for (int i = 0; i < array_size; i++) {\n+      array[i] = new BigInteger(128, r);\n+    }\n+\n+    for (int refill_count = 0; refill_count < 192; refill_count++) {\n+      \/\/ Each refill repopulates array_size randomly selected elements within array\n+      for (int i = 0; i < array_size; i++) {\n+        int replace_index = r.nextInt(array_size);\n+        int derive_index = r.nextInt(array_size);\n+        switch (i & 0x3) {\n+          case 0:\n+            \/\/ 50% chance of creating garbage\n+            array[replace_index] = array[replace_index].max(array[derive_index]);\n+            break;\n+          case 1:\n+            \/\/ 50% chance of creating garbage\n+            array[replace_index] = array[replace_index].min(array[derive_index]);\n+            break;\n+          case 2:\n+            \/\/ creates new old BigInteger, releases old BigInteger,\n+            \/\/ may create ephemeral data while computing gcd\n+            array[replace_index] = array[replace_index].gcd(array[derive_index]);\n+            break;\n+          case 3:\n+            \/\/ creates new old BigInteger, releases old BigInteger\n+            array[replace_index] = array[replace_index].multiply(array[derive_index]);\n+            break;\n+        }\n+        if ((i & 0x3) == 0x3) {\n+        } else {\n+        }\n+      }\n+    }\n+  }\n+\n+  public static void testOld(String... args) throws Exception {\n+    String[] cmds = Arrays.copyOf(args, args.length + 2);\n+    cmds[args.length] = TestOldGrowthTriggers.class.getName();\n+    cmds[args.length + 1] = \"test\";\n+    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(cmds);\n+    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    output.shouldHaveExitValue(0);\n+    if (!output.getOutput().contains(\"Trigger (OLD): Old has overgrown\")) {\n+      throw new AssertionError(\"Generational mode: Should experience OLD triggers due to growth\");\n+    }\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    if (args.length > 0 && args[0].equals(\"test\")) {\n+      makeOldAllocations();\n+      return;\n+    }\n+\n+    testOld(\"-Xlog:gc\",\n+            \"-Xms256m\",\n+            \"-Xmx256m\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+UseShenandoahGC\",\n+            \"-XX:ShenandoahGCMode=generational\",\n+            \"-XX:ShenandoahGuaranteedYoungGCInterval=0\",\n+            \"-XX:ShenandoahGuaranteedOldGCInterval=0\"\n+            );\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestOldGrowthTriggers.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}