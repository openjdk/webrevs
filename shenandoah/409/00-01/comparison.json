{"files":[{"patch":"@@ -3195,46 +3195,4 @@\n-    if (ShenandoahGenerationalHumongousReserve > 0) {\n-      size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n-      size_t allowed_old_gen_span = num_regions() - (ShenandoahGenerationalHumongousReserve * num_regions() \/ 100);\n-\n-      \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n-      \/\/   if old_gen spans more than 100% and density < 75%, trigger old-defrag\n-      \/\/   else if old_gen spans more than 87.5% and density < 62.5%, trigger old-defrag\n-      \/\/   else if old_gen spans more than 75% and density < 50%, trigger old-defrag\n-      \/\/   else if old_gen spans more than 62.5% and density < 37.5%, trigger old-defrag\n-      \/\/   else if old_gen spans more than 50% and density < 25%, trigger old-defrag\n-      \/\/\n-      \/\/ A previous implementation was more aggressive in triggering, resulting in degraded throughput when\n-      \/\/ humongous allocation was not required.\n-\n-      ShenandoahGeneration* old_gen = old_generation();\n-      size_t old_available = old_gen->available();\n-      size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-      size_t old_unaffiliated_available = old_gen->free_unaffiliated_regions() * region_size_bytes;\n-      assert(old_available >= old_unaffiliated_available, \"sanity\");\n-      size_t old_fragmented_available = old_available - old_unaffiliated_available;\n-\n-      size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n-      size_t old_bytes_spanned = old_region_span * region_size_bytes;\n-      double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n-\n-      uint eighths = 8;\n-      for (uint i = 0; i < 5; i++) {\n-        size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n-        double density_threshold = (eighths - 2) \/ 8.0;\n-        if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n-          old_heuristics()->trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n-          break;\n-        }\n-        eighths--;\n-      }\n-    }\n-    size_t old_used = old_generation()->used() + old_generation()->get_humongous_waste();\n-    size_t trigger_threshold = old_generation()->usage_trigger_threshold();\n-    \/\/ Detects unsigned arithmetic underflow\n-    assert(old_used <= capacity(),\n-           \"Old used (\" SIZE_FORMAT \", \" SIZE_FORMAT\") must not be more than heap capacity (\" SIZE_FORMAT \")\",\n-           old_generation()->used(), old_generation()->get_humongous_waste(), capacity());\n-\n-    if (old_used > trigger_threshold) {\n-      old_heuristics()->trigger_old_has_grown();\n-    }\n+    ShenandoahGenerationalHeap* gen_heap = (ShenandoahGenerationalHeap*) this;\n+    ShenandoahOldGeneration* old_gen = old_generation();\n+    old_gen->trigger_collection_if_fragmented(gen_heap, first_old_region, last_old_region, old_region_count, num_regions());\n+    old_gen->trigger_collection_if_overgrown(gen_heap);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":46,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -469,0 +469,52 @@\n+\n+void ShenandoahOldGeneration::trigger_collection_if_fragmented(ShenandoahGenerationalHeap* gen_heap, size_t first_old_region,\n+                                                               size_t last_old_region, size_t old_region_count,\n+                                                               size_t num_regions) {\n+  if (ShenandoahGenerationalHumongousReserve > 0) {\n+    size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n+    size_t allowed_old_gen_span = num_regions - (ShenandoahGenerationalHumongousReserve * num_regions) \/ 100;\n+\n+    \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n+    \/\/   if old_gen spans more than 100% and density < 75%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 87.5% and density < 62.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 75% and density < 50%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 62.5% and density < 37.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 50% and density < 25%, trigger old-defrag\n+    \/\/\n+    \/\/ A previous implementation was more aggressive in triggering, resulting in degraded throughput when\n+    \/\/ humongous allocation was not required.\n+\n+    size_t old_available = available();\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    size_t old_unaffiliated_available = free_unaffiliated_regions() * region_size_bytes;\n+    assert(old_available >= old_unaffiliated_available, \"sanity\");\n+    size_t old_fragmented_available = old_available - old_unaffiliated_available;\n+\n+    size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n+    size_t old_bytes_spanned = old_region_span * region_size_bytes;\n+    double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n+\n+    uint eighths = 8;\n+    for (uint i = 0; i < 5; i++) {\n+      size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n+      double density_threshold = (eighths - 2) \/ 8.0;\n+      if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n+        gen_heap->old_heuristics()->trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n+        return;\n+      }\n+      eighths--;\n+    }\n+  }\n+}\n+\n+void ShenandoahOldGeneration::trigger_collection_if_overgrown(ShenandoahGenerationalHeap* gen_heap) {\n+  size_t old_used = used() + get_humongous_waste();\n+  size_t trigger_threshold = usage_trigger_threshold();\n+  \/\/ Detects unsigned arithmetic underflow\n+  assert(old_used <= gen_heap->capacity(),\n+         \"Old used (\" SIZE_FORMAT \", \" SIZE_FORMAT\") must not be more than heap capacity (\" SIZE_FORMAT \")\",\n+         used(), get_humongous_waste(), heap->capacity());\n+  if (old_used > trigger_threshold) {\n+    gen_heap->old_heuristics()->trigger_old_has_grown();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -132,0 +133,4 @@\n+  void trigger_collection_if_fragmented(ShenandoahGenerationalHeap* gen_heap, size_t first_old_region, size_t last_old_region,\n+                                        size_t old_region_count, size_t num_regions);\n+  void trigger_collection_if_overgrown(ShenandoahGenerationalHeap* gen_heap);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  public static void do_old_allocations() {\n+  public static void makeOldAllocations() {\n@@ -45,1 +45,1 @@\n-    final int array_size = 128 * 1024;   \/\/ 128K entries\n+    final int array_size = 256 * 1024;   \/\/ 256K entries\n@@ -53,3 +53,1 @@\n-    for (int refill_count = 0; refill_count < 8; refill_count++) {\n-      System.out.print(\"Doing refill: \");\n-      System.out.println(Integer.toString(refill_count));\n+    for (int refill_count = 0; refill_count < 192; refill_count++) {\n@@ -64,0 +62,1 @@\n+            break;\n@@ -67,0 +66,1 @@\n+            break;\n@@ -71,0 +71,1 @@\n+            break;\n@@ -74,0 +75,1 @@\n+            break;\n@@ -96,1 +98,1 @@\n-      do_old_allocations();\n+      makeOldAllocations();\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestOldGrowthTriggers.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"}]}