{"files":[{"patch":"@@ -59,1 +59,1 @@\n-ShenandoahOldHeuristics::ShenandoahOldHeuristics(ShenandoahOldGeneration* generation) :\n+ShenandoahOldHeuristics::ShenandoahOldHeuristics(ShenandoahOldGeneration* generation, ShenandoahGenerationalHeap* gen_heap) :\n@@ -61,0 +61,2 @@\n+  _heap(gen_heap),\n+  _old_gen(generation),\n@@ -545,1 +547,57 @@\n- }\n+}\n+\n+void ShenandoahOldHeuristics::trigger_collection_if_fragmented(size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions) {\n+  if (ShenandoahGenerationalHumongousReserve > 0) {\n+    size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n+    size_t allowed_old_gen_span = num_regions - (ShenandoahGenerationalHumongousReserve * num_regions) \/ 100;\n+\n+    \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n+    \/\/   if old_gen spans more than 100% and density < 75%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 87.5% and density < 62.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 75% and density < 50%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 62.5% and density < 37.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 50% and density < 25%, trigger old-defrag\n+    \/\/\n+    \/\/ A previous implementation was more aggressive in triggering, resulting in degraded throughput when\n+    \/\/ humongous allocation was not required.\n+\n+    size_t old_available = _old_gen->available();\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    size_t old_unaffiliated_available = _old_gen->free_unaffiliated_regions() * region_size_bytes;\n+    assert(old_available >= old_unaffiliated_available, \"sanity\");\n+    size_t old_fragmented_available = old_available - old_unaffiliated_available;\n+\n+    size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n+    size_t old_bytes_spanned = old_region_span * region_size_bytes;\n+    double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n+\n+    uint eighths = 8;\n+    for (uint i = 0; i < 5; i++) {\n+      size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n+      double density_threshold = (eighths - 2) \/ 8.0;\n+      if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n+        trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n+        return;\n+      }\n+      eighths--;\n+    }\n+  }\n+}\n+\n+void ShenandoahOldHeuristics::trigger_collection_if_overgrown() {\n+  size_t old_used = _old_gen->used() + _old_gen->get_humongous_waste();\n+  size_t trigger_threshold = _old_gen->usage_trigger_threshold();\n+  \/\/ Detects unsigned arithmetic underflow\n+  assert(old_used <= _heap->capacity(),\n+         \"Old used (\" SIZE_FORMAT \", \" SIZE_FORMAT\") must not be more than heap capacity (\" SIZE_FORMAT \")\",\n+         _old_gen->used(), _old_gen->get_humongous_waste(), _heap->capacity());\n+  if (old_used > trigger_threshold) {\n+    trigger_old_has_grown();\n+  }\n+}\n+\n+void ShenandoahOldHeuristics::trigger_maybe(size_t first_old_region, size_t last_old_region,\n+                                            size_t old_region_count, size_t num_regions) {\n+  trigger_collection_if_fragmented(first_old_region, last_old_region, old_region_count, num_regions);\n+  trigger_collection_if_overgrown();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":60,"deletions":2,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -54,0 +54,3 @@\n+  ShenandoahGenerationalHeap* _heap;\n+  ShenandoahOldGeneration* _old_gen;\n+\n@@ -112,0 +115,11 @@\n+  inline void trigger_old_is_fragmented(double density, size_t first_old_index, size_t last_old_index) {\n+    _fragmentation_trigger = true;\n+    _fragmentation_density = density;\n+    _fragmentation_first_old_region = first_old_index;\n+    _fragmentation_last_old_region = last_old_index;\n+  }\n+  inline void trigger_old_has_grown() { _growth_trigger = true; }\n+\n+  void trigger_collection_if_fragmented(size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions);\n+  void trigger_collection_if_overgrown();\n+\n@@ -117,1 +131,1 @@\n-  ShenandoahOldHeuristics(ShenandoahOldGeneration* generation);\n+  ShenandoahOldHeuristics(ShenandoahOldGeneration* generation, ShenandoahGenerationalHeap* gen_heap);\n@@ -164,8 +178,0 @@\n-  inline void trigger_old_is_fragmented(double density, size_t first_old_index, size_t last_old_index) {\n-    _fragmentation_trigger = true;\n-    _fragmentation_density = density;\n-    _fragmentation_first_old_region = first_old_index;\n-    _fragmentation_last_old_region = last_old_index;\n-  }\n-  void trigger_old_has_grown() { _growth_trigger = true; }\n-\n@@ -180,0 +186,2 @@\n+  void trigger_maybe(size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2834,2 +2834,5 @@\n-  if (mode()->is_generational() && (ShenandoahGenerationalHumongousReserve > 0)) {\n-    old_generation()->maybe_trigger_collection(first_old_region, last_old_region, old_region_count);\n+  if (mode()->is_generational()) {\n+    ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+    ShenandoahOldGeneration* old_gen = gen_heap->old_generation();\n+    ShenandoahOldHeuristics* old_heuristics = (ShenandoahOldHeuristics*) old_gen->heuristics();\n+    old_heuristics->trigger_maybe(first_old_region, last_old_region, old_region_count, num_regions());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-  _old_heuristics = new ShenandoahOldHeuristics(this);\n+  _old_heuristics = new ShenandoahOldHeuristics(this, ShenandoahGenerationalHeap::heap());\n@@ -602,48 +602,0 @@\n-void ShenandoahOldGeneration::maybe_trigger_collection(size_t first_old_region, size_t last_old_region, size_t old_region_count) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  const size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n-  const size_t allowed_old_gen_span = heap->num_regions() - (ShenandoahGenerationalHumongousReserve * heap->num_regions() \/ 100);\n-\n-  \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n-  \/\/   if old_gen spans more than 100% and density < 75%, trigger old-defrag\n-  \/\/   else if old_gen spans more than 87.5% and density < 62.5%, trigger old-defrag\n-  \/\/   else if old_gen spans more than 75% and density < 50%, trigger old-defrag\n-  \/\/   else if old_gen spans more than 62.5% and density < 37.5%, trigger old-defrag\n-  \/\/   else if old_gen spans more than 50% and density < 25%, trigger old-defrag\n-  \/\/\n-  \/\/ A previous implementation was more aggressive in triggering, resulting in degraded throughput when\n-  \/\/ humongous allocation was not required.\n-\n-  const size_t old_available = available();\n-  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-  const size_t old_unaffiliated_available = free_unaffiliated_regions() * region_size_bytes;\n-  assert(old_available >= old_unaffiliated_available, \"sanity\");\n-  const size_t old_fragmented_available = old_available - old_unaffiliated_available;\n-\n-  const size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n-  const size_t old_bytes_spanned = old_region_span * region_size_bytes;\n-  const double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n-\n-  uint eighths = 8;\n-  for (uint i = 0; i < 5; i++) {\n-    size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n-    double density_threshold = (eighths - 2) \/ 8.0;\n-    if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n-      heuristics()->trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n-      break;\n-    }\n-    eighths--;\n-  }\n-\n-  const size_t old_used = used() + get_humongous_waste();\n-  const size_t trigger_threshold = usage_trigger_threshold();\n-  \/\/ Detects unsigned arithmetic underflow\n-  assert(old_used <= heap->free_set()->capacity(),\n-         \"Old used (\" SIZE_FORMAT \", \" SIZE_FORMAT\") must not be more than heap capacity (\" SIZE_FORMAT \")\",\n-         used(), get_humongous_waste(), heap->free_set()->capacity());\n-\n-  if (old_used > trigger_threshold) {\n-    heuristics()->trigger_old_has_grown();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":49,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -202,1 +203,0 @@\n-  void maybe_trigger_collection(size_t first_old_region, size_t last_old_region, size_t old_region_count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test that growth of old-gen triggers old-gen marking\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @run driver TestOldGrowthTriggers\n+ *\/\n+\n+import java.util.*;\n+import java.math.BigInteger;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestOldGrowthTriggers {\n+\n+  public static void makeOldAllocations() {\n+    \/\/ Expect most of the BigInteger entries placed into array to be promoted, and most will eventually become garbage within old\n+\n+    final int array_size = 256 * 1024;   \/\/ 256K entries\n+    BigInteger array[] = new BigInteger[array_size];\n+    Random r = new Random(46);\n+\n+    for (int i = 0; i < array_size; i++) {\n+      array[i] = new BigInteger(128, r);\n+    }\n+\n+    for (int refill_count = 0; refill_count < 192; refill_count++) {\n+      \/\/ Each refill repopulates array_size randomly selected elements within array\n+      for (int i = 0; i < array_size; i++) {\n+        int replace_index = r.nextInt(array_size);\n+        int derive_index = r.nextInt(array_size);\n+        switch (i & 0x3) {\n+          case 0:\n+            \/\/ 50% chance of creating garbage\n+            array[replace_index] = array[replace_index].max(array[derive_index]);\n+            break;\n+          case 1:\n+            \/\/ 50% chance of creating garbage\n+            array[replace_index] = array[replace_index].min(array[derive_index]);\n+            break;\n+          case 2:\n+            \/\/ creates new old BigInteger, releases old BigInteger,\n+            \/\/ may create ephemeral data while computing gcd\n+            array[replace_index] = array[replace_index].gcd(array[derive_index]);\n+            break;\n+          case 3:\n+            \/\/ creates new old BigInteger, releases old BigInteger\n+            array[replace_index] = array[replace_index].multiply(array[derive_index]);\n+            break;\n+        }\n+        if ((i & 0x3) == 0x3) {\n+        } else {\n+        }\n+      }\n+    }\n+  }\n+\n+  public static void testOld(String... args) throws Exception {\n+    String[] cmds = Arrays.copyOf(args, args.length + 2);\n+    cmds[args.length] = TestOldGrowthTriggers.class.getName();\n+    cmds[args.length + 1] = \"test\";\n+    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(cmds);\n+    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    output.shouldHaveExitValue(0);\n+    if (!output.getOutput().contains(\"Trigger (OLD): Old has overgrown\")) {\n+      throw new AssertionError(\"Generational mode: Should experience OLD triggers due to growth\");\n+    }\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    if (args.length > 0 && args[0].equals(\"test\")) {\n+      makeOldAllocations();\n+      return;\n+    }\n+\n+    testOld(\"-Xlog:gc\",\n+            \"-Xms256m\",\n+            \"-Xmx256m\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+UseShenandoahGC\",\n+            \"-XX:ShenandoahGCMode=generational\",\n+            \"-XX:ShenandoahGuaranteedYoungGCInterval=0\",\n+            \"-XX:ShenandoahGuaranteedOldGCInterval=0\"\n+            );\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestOldGrowthTriggers.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}