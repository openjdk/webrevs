{"files":[{"patch":"@@ -546,1 +546,52 @@\n- }\n+}\n+\n+void ShenandoahOldHeuristics::trigger_collection_if_fragmented(ShenandoahGenerationalHeap* gen_heap, ShenandoahOldGeneration* old_gen,\n+                                                               size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions) {\n+  if (ShenandoahGenerationalHumongousReserve > 0) {\n+    size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n+    size_t allowed_old_gen_span = num_regions - (ShenandoahGenerationalHumongousReserve * num_regions) \/ 100;\n+\n+    \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n+    \/\/   if old_gen spans more than 100% and density < 75%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 87.5% and density < 62.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 75% and density < 50%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 62.5% and density < 37.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 50% and density < 25%, trigger old-defrag\n+    \/\/\n+    \/\/ A previous implementation was more aggressive in triggering, resulting in degraded throughput when\n+    \/\/ humongous allocation was not required.\n+\n+    size_t old_available = old_gen->available();\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    size_t old_unaffiliated_available = old_gen->free_unaffiliated_regions() * region_size_bytes;\n+    assert(old_available >= old_unaffiliated_available, \"sanity\");\n+    size_t old_fragmented_available = old_available - old_unaffiliated_available;\n+\n+    size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n+    size_t old_bytes_spanned = old_region_span * region_size_bytes;\n+    double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n+\n+    uint eighths = 8;\n+    for (uint i = 0; i < 5; i++) {\n+      size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n+      double density_threshold = (eighths - 2) \/ 8.0;\n+      if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n+        gen_heap->old_heuristics()->trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n+        return;\n+      }\n+      eighths--;\n+    }\n+  }\n+}\n+\n+void ShenandoahOldHeuristics::trigger_collection_if_overgrown(ShenandoahGenerationalHeap* gen_heap, ShenandoahOldGeneration* old_gen) {\n+  size_t old_used = old_gen->used() + old_gen->get_humongous_waste();\n+  size_t trigger_threshold = old_gen->usage_trigger_threshold();\n+  \/\/ Detects unsigned arithmetic underflow\n+  assert(old_used <= gen_heap->capacity(),\n+         \"Old used (\" SIZE_FORMAT \", \" SIZE_FORMAT\") must not be more than heap capacity (\" SIZE_FORMAT \")\",\n+         old_gen->used(), old_gen->get_humongous_waste(), gen_heap->capacity());\n+  if (old_used > trigger_threshold) {\n+    gen_heap->old_heuristics()->trigger_old_has_grown();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -178,0 +178,4 @@\n+  void trigger_collection_if_fragmented(ShenandoahGenerationalHeap* gen_heap, ShenandoahOldGeneration* old_gen,\n+                                        size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions);\n+  void trigger_collection_if_overgrown(ShenandoahGenerationalHeap* gen_heap, ShenandoahOldGeneration* old_gen);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3204,2 +3204,3 @@\n-    old_gen->trigger_collection_if_fragmented(gen_heap, first_old_region, last_old_region, old_region_count, num_regions());\n-    old_gen->trigger_collection_if_overgrown(gen_heap);\n+    ShenandoahOldHeuristics* old_heuristics = (ShenandoahOldHeuristics*) old_gen->heuristics();\n+    old_heuristics->trigger_collection_if_fragmented(gen_heap, old_gen, first_old_region, last_old_region, old_region_count, num_regions());\n+    old_heuristics->trigger_collection_if_overgrown(gen_heap, old_gen);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -510,52 +510,0 @@\n-void ShenandoahOldGeneration::trigger_collection_if_fragmented(ShenandoahGenerationalHeap* gen_heap, size_t first_old_region,\n-                                                               size_t last_old_region, size_t old_region_count,\n-                                                               size_t num_regions) {\n-  if (ShenandoahGenerationalHumongousReserve > 0) {\n-    size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n-    size_t allowed_old_gen_span = num_regions - (ShenandoahGenerationalHumongousReserve * num_regions) \/ 100;\n-\n-    \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n-    \/\/   if old_gen spans more than 100% and density < 75%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 87.5% and density < 62.5%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 75% and density < 50%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 62.5% and density < 37.5%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 50% and density < 25%, trigger old-defrag\n-    \/\/\n-    \/\/ A previous implementation was more aggressive in triggering, resulting in degraded throughput when\n-    \/\/ humongous allocation was not required.\n-\n-    size_t old_available = available();\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-    size_t old_unaffiliated_available = free_unaffiliated_regions() * region_size_bytes;\n-    assert(old_available >= old_unaffiliated_available, \"sanity\");\n-    size_t old_fragmented_available = old_available - old_unaffiliated_available;\n-\n-    size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n-    size_t old_bytes_spanned = old_region_span * region_size_bytes;\n-    double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n-\n-    uint eighths = 8;\n-    for (uint i = 0; i < 5; i++) {\n-      size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n-      double density_threshold = (eighths - 2) \/ 8.0;\n-      if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n-        gen_heap->old_heuristics()->trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n-        return;\n-      }\n-      eighths--;\n-    }\n-  }\n-}\n-\n-void ShenandoahOldGeneration::trigger_collection_if_overgrown(ShenandoahGenerationalHeap* gen_heap) {\n-  size_t old_used = used() + get_humongous_waste();\n-  size_t trigger_threshold = usage_trigger_threshold();\n-  \/\/ Detects unsigned arithmetic underflow\n-  assert(old_used <= gen_heap->capacity(),\n-         \"Old used (\" SIZE_FORMAT \", \" SIZE_FORMAT\") must not be more than heap capacity (\" SIZE_FORMAT \")\",\n-         used(), get_humongous_waste(), gen_heap->capacity());\n-  if (old_used > trigger_threshold) {\n-    gen_heap->old_heuristics()->trigger_old_has_grown();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -228,4 +228,0 @@\n-  void trigger_collection_if_fragmented(ShenandoahGenerationalHeap* gen_heap, size_t first_old_region, size_t last_old_region,\n-                                        size_t old_region_count, size_t num_regions);\n-  void trigger_collection_if_overgrown(ShenandoahGenerationalHeap* gen_heap);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}