{"files":[{"patch":"@@ -155,6 +155,1 @@\n-  \/\/ Concurrent stack processing\n-  if (heap->is_evacuation_in_progress()) {\n-    entry_thread_roots();\n-  }\n-\n-  \/\/ Process weak roots that might still point to regions that would be broken by cleanup\n+  \/\/ Process weak roots that might still point to regions that would be broken by cleanup.  This must precede cleanup.\n@@ -166,3 +161,3 @@\n-  \/\/ Final mark might have reclaimed some immediate garbage, kick cleanup to reclaim\n-  \/\/ the space. This would be the last action if there is nothing to evacuate.  Note that\n-  \/\/ we will not age young-gen objects in the case that we skip evacuation.\n+  \/\/ Final mark might have reclaimed some immediate garbage, kick cleanup to reclaim the space.  We do this before\n+  \/\/ concurrent roots and concurrent class unloading so as to expedite recycling of immediate garbage.  Note that\n+  \/\/ we will not age young-gen objects in the case that we skip evacuation for abbreviated cycles.\n@@ -171,0 +166,4 @@\n+#ifdef KELVIN_DEPRECATE\n+  \/\/ We just dumped the free set after rebuilding free set in final_mark.   Let's not dump it again.\n+  \/\/ There may be some contention with mutator and GC worker threads who are trying to begin their evacuation\n+  \/\/ efforts, and would prefer not to grab the heap lock right here.\n@@ -172,0 +171,6 @@\n+#endif\n+\n+  \/\/ Concurrent stack processing\n+  if (heap->is_evacuation_in_progress()) {\n+    entry_thread_roots();\n+  }\n@@ -749,1 +754,1 @@\n-        \/\/ Iff objects will be evaluated, arm the nmethod barriers. These will be disarmed\n+        \/\/ Iff objects will be evacuated, arm the nmethod barriers. These will be disarmed\n@@ -1064,1 +1069,4 @@\n-  ShenandoahHeap::heap()->free_set()->recycle_trash();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->free_set()->recycle_trash()) {\n+    heap->control_thread()->notify_alloc_failure_waiters(false);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+void ShenandoahController::anticipate_immediate_garbage(size_t anticipated_immediate_garbage) {\n+  Atomic::store(&_anticipated_immediate_garbage, anticipated_immediate_garbage);\n+}\n+\n@@ -68,2 +72,4 @@\n-    \/\/ Now that alloc failure GC is scheduled, we can abort everything else\n-    heap->cancel_gc(GCCause::_allocation_failure);\n+    if (Atomic::load(&_anticipated_immediate_garbage) < req.size()) {\n+      \/\/ Now that alloc failure GC is scheduled, we can abort everything else\n+      heap->cancel_gc(GCCause::_allocation_failure);\n+    }\n@@ -72,1 +78,0 @@\n-\n@@ -95,3 +100,5 @@\n-void ShenandoahController::notify_alloc_failure_waiters() {\n-  _alloc_failure_gc.unset();\n-  _humongous_alloc_failure_gc.unset();\n+void ShenandoahController::notify_alloc_failure_waiters(bool clear_alloc_failure) {\n+  if (clear_alloc_failure) {\n+    _alloc_failure_gc.unset();\n+    _humongous_alloc_failure_gc.unset();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+  volatile size_t _anticipated_immediate_garbage;\n+  shenandoah_padding(3);\n@@ -74,0 +76,2 @@\n+  void anticipate_immediate_garbage(size_t anticipated_immediate_garbage_words);\n+\n@@ -82,1 +86,1 @@\n-  void notify_alloc_failure_waiters();\n+  void notify_alloc_failure_waiters(bool clear_alloc_failure = true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -114,0 +114,3 @@\n+  \/\/ This test for trash regions is conservative.  Strictly, we only need to assure that concurrent weak reference processing\n+  \/\/ is not under way.  That finishes long before concurrent weak root processing.  It is ok to be conservative.  At the\n+  \/\/ end of weak reference processing, we recycle trashed regions en masse.\n@@ -1233,1 +1236,2 @@\n-void ShenandoahFreeSet::try_recycle_trashed(ShenandoahHeapRegion* r) {\n+bool ShenandoahFreeSet::try_recycle_trashed(ShenandoahHeapRegion* r) {\n+  bool result = false;\n@@ -1236,0 +1240,1 @@\n+    result = true;\n@@ -1237,0 +1242,1 @@\n+  return true;\n@@ -1239,1 +1245,2 @@\n-void ShenandoahFreeSet::recycle_trash() {\n+bool ShenandoahFreeSet::recycle_trash() {\n+  bool result = false;\n@@ -1259,1 +1266,3 @@\n-      try_recycle_trashed(_trash_regions[idx++]);\n+      if (try_recycle_trashed(_trash_regions[idx++])) {\n+        result = true;\n+      }\n@@ -1262,0 +1271,2 @@\n+  _heap->control_thread()->anticipate_immediate_garbage((size_t) 0);\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -333,1 +333,3 @@\n-  void try_recycle_trashed(ShenandoahHeapRegion *r);\n+\n+  \/\/ If region r is a trash region, recycle it, returning true iff r was recycled.\n+  bool try_recycle_trashed(ShenandoahHeapRegion *r);\n@@ -413,1 +415,2 @@\n-  void recycle_trash();\n+  \/\/ Recycle any trash that is known to the freeset, returning true if any trash was recycled.\n+  bool recycle_trash();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -756,0 +756,3 @@\n+    size_t anticipated_immediate_garbage = (old_cset_regions + young_cset_regions) * ShenandoahHeapRegion::region_size_words();\n+    heap->control_thread()->anticipate_immediate_garbage(anticipated_immediate_garbage);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2439,1 +2439,1 @@\n-    final_update_refs_update_region_states();\n+   final_update_refs_update_region_states();\n@@ -2441,1 +2441,1 @@\n-    assert_pinned_region_status();\n+   assert_pinned_region_status();\n@@ -2465,0 +2465,3 @@\n+  size_t anticipated_immediate_garbage = (old_cset_regions + young_cset_regions) * ShenandoahHeapRegion::region_size_words();\n+  control_thread()->anticipate_immediate_garbage(anticipated_immediate_garbage);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -477,0 +477,3 @@\n+    size_t anticipated_immediate_garbage = (cset_young_regions + cset_old_regions) * ShenandoahHeapRegion::region_size_words();\n+    heap->control_thread()->anticipate_immediate_garbage(anticipated_immediate_garbage);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}