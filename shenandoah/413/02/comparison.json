{"files":[{"patch":"@@ -43,0 +43,1 @@\n+\n@@ -236,1 +237,5 @@\n-  parallel_heap_region_iterate(&cl);\n+  parallel_region_iterate_free(&cl);\n+}\n+\n+void ShenandoahGeneration::parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -182,0 +182,3 @@\n+  \/\/ Apply closure to all regions affiliated with this generation (include free regions);\n+  virtual void parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3409,26 +3409,0 @@\n-template<>\n-void ShenandoahGenerationRegionClosure<YOUNG>::heap_region_do(ShenandoahHeapRegion* region) {\n-  \/\/ Visit young regions\n-  if (region->is_young()) {\n-    _cl->heap_region_do(region);\n-  }\n-}\n-\n-template<>\n-void ShenandoahGenerationRegionClosure<OLD>::heap_region_do(ShenandoahHeapRegion* region) {\n-  \/\/ Visit old regions\n-  if (region->is_old()) {\n-    _cl->heap_region_do(region);\n-  }\n-}\n-\n-template<>\n-void ShenandoahGenerationRegionClosure<GLOBAL>::heap_region_do(ShenandoahHeapRegion* region) {\n-  _cl->heap_region_do(region);\n-}\n-\n-template<>\n-void ShenandoahGenerationRegionClosure<NON_GEN>::heap_region_do(ShenandoahHeapRegion* region) {\n-  _cl->heap_region_do(region);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -127,10 +127,0 @@\n-template<ShenandoahGenerationType GENERATION>\n-class ShenandoahGenerationRegionClosure : public ShenandoahHeapRegionClosure {\n- public:\n-  explicit ShenandoahGenerationRegionClosure(ShenandoahHeapRegionClosure* cl) : _cl(cl) {}\n-  void heap_region_do(ShenandoahHeapRegion* r);\n-  virtual bool is_thread_safe() { return _cl->is_thread_safe(); }\n- private:\n-  ShenandoahHeapRegionClosure* _cl;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -678,0 +678,1 @@\n+\n@@ -679,0 +680,1 @@\n+  generation->decrement_affiliated_region_count();\n@@ -689,1 +691,1 @@\n-  ShenandoahHeap::heap()->generation_for(affiliation())->decrement_affiliated_region_count();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SRC_SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n+#define SRC_SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n+\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+\n+\/\/ Applies the given closure to all regions with the given affiliation\n+template<ShenandoahAffiliation AFFILIATION>\n+class ShenandoahIncludeRegionClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahHeapRegionClosure* _closure;\n+\n+public:\n+  explicit ShenandoahIncludeRegionClosure(ShenandoahHeapRegionClosure* closure): _closure(closure) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (r->affiliation() == AFFILIATION) {\n+      _closure->heap_region_do(r);\n+    }\n+  }\n+\n+  bool is_thread_safe() override {\n+    return _closure->is_thread_safe();\n+  }\n+};\n+\n+\/\/ Applies the given closure to all regions without the given affiliation\n+template<ShenandoahAffiliation AFFILIATION>\n+class ShenandoahExcludeRegionClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahHeapRegionClosure* _closure;\n+\n+public:\n+  explicit ShenandoahExcludeRegionClosure(ShenandoahHeapRegionClosure* closure): _closure(closure) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (r->affiliation() != AFFILIATION) {\n+      _closure->heap_region_do(r);\n+    }\n+  }\n+\n+  bool is_thread_safe() override {\n+    return _closure->is_thread_safe();\n+  }\n+};\n+\n+#endif \/\/SRC_SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionClosures.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -83,6 +83,0 @@\n-  if (!r->is_affiliated()) {\n-    \/\/ Heap iterators include FREE regions, which don't need to be cleared.\n-    \/\/ TODO: would be better for certain iterators to not include FREE regions.\n-    return;\n-  }\n-\n@@ -100,3 +94,0 @@\n-  \/\/ TODO: Why is clear_live_data here?\n-  r->clear_live_data();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -100,8 +100,0 @@\n-  if ((old_tams == r->bottom()) && (new_tams > old_tams)) {\n-    log_debug(gc)(\"Clearing mark bitmap for %s Region \" SIZE_FORMAT \" while capturing TAMS\",\n-                  r->affiliation_name(), idx);\n-    \/\/ TODO: Do we really need to do bitmap clears here?\n-    \/\/ This could take a while, and we would instead like to clear bitmaps outside the pause.\n-    clear_bitmap(r);\n-  }\n-\n@@ -109,4 +101,1 @@\n-  if (new_tams > r->bottom()) {\n-    \/\/ In this case, new_tams is greater than old _top_bitmaps[idx]\n-    _top_bitmaps[idx] = new_tams;\n-  }\n+  _top_bitmaps[idx] = new_tams;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n@@ -248,2 +249,2 @@\n-  ShenandoahGenerationRegionClosure<OLD> old_regions(cl);\n-  ShenandoahHeap::heap()->parallel_heap_region_iterate(&old_regions);\n+  ShenandoahIncludeRegionClosure<OLD_GENERATION> old_regions_cl(cl);\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(&old_regions_cl);\n@@ -253,2 +254,2 @@\n-  ShenandoahGenerationRegionClosure<OLD> old_regions(cl);\n-  ShenandoahHeap::heap()->heap_region_iterate(&old_regions);\n+  ShenandoahIncludeRegionClosure<OLD_GENERATION> old_regions_cl(cl);\n+  ShenandoahHeap::heap()->heap_region_iterate(&old_regions_cl);\n@@ -275,1 +276,0 @@\n-\n@@ -571,1 +571,7 @@\n-}\n\\ No newline at end of file\n+}\n+\n+void ShenandoahOldGeneration::parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+  \/\/ Iterate over old and free regions (exclude young).\n+  ShenandoahExcludeRegionClosure<YOUNG_GENERATION> exclude_cl(cl);\n+  ShenandoahGeneration::parallel_region_iterate_free(&exclude_cl);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -143,0 +143,3 @@\n+\n+  void parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) override;\n+\n@@ -152,1 +155,1 @@\n-  virtual void prepare_gc() override;\n+  void prepare_gc() override;\n@@ -154,2 +157,2 @@\n-  virtual void record_success_concurrent(bool abbreviated) override;\n-  virtual void cancel_marking() override;\n+  void record_success_concurrent(bool abbreviated) override;\n+  void cancel_marking() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n@@ -59,2 +60,2 @@\n-  ShenandoahGenerationRegionClosure<YOUNG> young_regions(cl);\n-  ShenandoahHeap::heap()->parallel_heap_region_iterate(&young_regions);\n+  ShenandoahIncludeRegionClosure<YOUNG_GENERATION> young_regions_cl(cl);\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(&young_regions_cl);\n@@ -64,2 +65,2 @@\n-  ShenandoahGenerationRegionClosure<YOUNG> young_regions(cl);\n-  ShenandoahHeap::heap()->heap_region_iterate(&young_regions);\n+  ShenandoahIncludeRegionClosure<YOUNG_GENERATION> young_regions_cl(cl);\n+  ShenandoahHeap::heap()->heap_region_iterate(&young_regions_cl);\n@@ -101,0 +102,5 @@\n+\n+void ShenandoahYoungGeneration::parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahExcludeRegionClosure<OLD_GENERATION> exclude_cl(cl);\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(&exclude_cl);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+\n+  void parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}