{"files":[{"patch":"@@ -43,0 +43,1 @@\n+\n@@ -236,1 +237,5 @@\n-  parallel_heap_region_iterate(&cl);\n+  parallel_region_iterate_free(&cl);\n+}\n+\n+void ShenandoahGeneration::parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,39 @@\n+template<ShenandoahAffiliation AFFILIATION>\n+class ShenandoahIncludeRegionClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahHeapRegionClosure* _closure;\n+\n+public:\n+  explicit ShenandoahIncludeRegionClosure(ShenandoahHeapRegionClosure* closure): _closure(closure) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (r->affiliation() == AFFILIATION) {\n+      _closure->heap_region_do(r);\n+    }\n+  }\n+\n+  bool is_thread_safe() override {\n+    return _closure->is_thread_safe();\n+  }\n+};\n+\n+template<ShenandoahAffiliation AFFILIATION>\n+class ShenandoahExcludeRegionClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahHeapRegionClosure* _closure;\n+\n+public:\n+  explicit ShenandoahExcludeRegionClosure(ShenandoahHeapRegionClosure* closure): _closure(closure) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (r->affiliation() != AFFILIATION) {\n+      _closure->heap_region_do(r);\n+    }\n+  }\n+\n+  bool is_thread_safe() override {\n+    return _closure->is_thread_safe();\n+  }\n+};\n+\n+\n@@ -182,0 +221,3 @@\n+  \/\/ Apply closure to all regions affiliated with this generation (include free regions);\n+  virtual void parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3409,26 +3409,0 @@\n-template<>\n-void ShenandoahGenerationRegionClosure<YOUNG>::heap_region_do(ShenandoahHeapRegion* region) {\n-  \/\/ Visit young regions\n-  if (region->is_young()) {\n-    _cl->heap_region_do(region);\n-  }\n-}\n-\n-template<>\n-void ShenandoahGenerationRegionClosure<OLD>::heap_region_do(ShenandoahHeapRegion* region) {\n-  \/\/ Visit old regions\n-  if (region->is_old()) {\n-    _cl->heap_region_do(region);\n-  }\n-}\n-\n-template<>\n-void ShenandoahGenerationRegionClosure<GLOBAL>::heap_region_do(ShenandoahHeapRegion* region) {\n-  _cl->heap_region_do(region);\n-}\n-\n-template<>\n-void ShenandoahGenerationRegionClosure<NON_GEN>::heap_region_do(ShenandoahHeapRegion* region) {\n-  _cl->heap_region_do(region);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -127,10 +127,0 @@\n-template<ShenandoahGenerationType GENERATION>\n-class ShenandoahGenerationRegionClosure : public ShenandoahHeapRegionClosure {\n- public:\n-  explicit ShenandoahGenerationRegionClosure(ShenandoahHeapRegionClosure* cl) : _cl(cl) {}\n-  void heap_region_do(ShenandoahHeapRegion* r);\n-  virtual bool is_thread_safe() { return _cl->is_thread_safe(); }\n- private:\n-  ShenandoahHeapRegionClosure* _cl;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -678,0 +678,1 @@\n+\n@@ -679,0 +680,1 @@\n+  generation->decrement_affiliated_region_count();\n@@ -689,1 +691,1 @@\n-  ShenandoahHeap::heap()->generation_for(affiliation())->decrement_affiliated_region_count();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,6 +83,0 @@\n-  if (!r->is_affiliated()) {\n-    \/\/ Heap iterators include FREE regions, which don't need to be cleared.\n-    \/\/ TODO: would be better for certain iterators to not include FREE regions.\n-    return;\n-  }\n-\n@@ -100,3 +94,0 @@\n-  \/\/ TODO: Why is clear_live_data here?\n-  r->clear_live_data();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -100,8 +100,0 @@\n-  if ((old_tams == r->bottom()) && (new_tams > old_tams)) {\n-    log_debug(gc)(\"Clearing mark bitmap for %s Region \" SIZE_FORMAT \" while capturing TAMS\",\n-                  r->affiliation_name(), idx);\n-    \/\/ TODO: Do we really need to do bitmap clears here?\n-    \/\/ This could take a while, and we would instead like to clear bitmaps outside the pause.\n-    clear_bitmap(r);\n-  }\n-\n@@ -109,4 +101,1 @@\n-  if (new_tams > r->bottom()) {\n-    \/\/ In this case, new_tams is greater than old _top_bitmaps[idx]\n-    _top_bitmaps[idx] = new_tams;\n-  }\n+  _top_bitmaps[idx] = new_tams;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-  ShenandoahGenerationRegionClosure<OLD> old_regions(cl);\n+  ShenandoahIncludeRegionClosure<OLD_GENERATION> old_regions(cl);\n@@ -253,1 +253,1 @@\n-  ShenandoahGenerationRegionClosure<OLD> old_regions(cl);\n+  ShenandoahIncludeRegionClosure<OLD_GENERATION> old_regions(cl);\n@@ -275,1 +275,0 @@\n-\n@@ -571,1 +570,7 @@\n-}\n\\ No newline at end of file\n+}\n+\n+void ShenandoahOldGeneration::parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+  \/\/ Iterate over old and free regions (exclude young).\n+  ShenandoahExcludeRegionClosure<YOUNG_GENERATION> exclude(cl);\n+  ShenandoahGeneration::parallel_region_iterate_free(&exclude);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -143,0 +143,3 @@\n+\n+  void parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) override;\n+\n@@ -152,1 +155,1 @@\n-  virtual void prepare_gc() override;\n+  void prepare_gc() override;\n@@ -154,2 +157,2 @@\n-  virtual void record_success_concurrent(bool abbreviated) override;\n-  virtual void cancel_marking() override;\n+  void record_success_concurrent(bool abbreviated) override;\n+  void cancel_marking() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  ShenandoahGenerationRegionClosure<YOUNG> young_regions(cl);\n+  ShenandoahIncludeRegionClosure<YOUNG_GENERATION> young_regions(cl);\n@@ -64,1 +64,1 @@\n-  ShenandoahGenerationRegionClosure<YOUNG> young_regions(cl);\n+  ShenandoahIncludeRegionClosure<YOUNG_GENERATION> young_regions(cl);\n@@ -101,0 +101,5 @@\n+\n+void ShenandoahYoungGeneration::parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahExcludeRegionClosure<OLD_GENERATION> exclude(cl);\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(&exclude);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+\n+  void parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}