{"files":[{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+  replay_files=$(ls $report_dir\/$base_path\/replay*.log 2> \/dev\/null || true)\n@@ -48,1 +49,0 @@\n-\n@@ -76,0 +76,14 @@\n+  if [[ \"$replay_files\" != \"\" ]]; then\n+    echo '<details><summary>View HotSpot replay file<\/summary>'\n+    echo ''\n+    for replay in $replay_files; do\n+      echo '```'\n+      echo \"$replay:\"\n+      echo ''\n+      cat \"$replay\"\n+      echo '```'\n+    done\n+\n+    echo '<\/details>'\n+    echo ''\n+  fi\n","filename":".github\/scripts\/gen-test-results.sh","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -756,0 +756,2 @@\n+<li>To install on Alpine Linux, try running\n+<code>sudo apk add fontconfig-dev<\/code>.<\/li>\n","filename":"doc\/building.html","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -575,0 +575,1 @@\n+* To install on Alpine Linux, try running `sudo apk add fontconfig-dev`.\n","filename":"doc\/building.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -623,0 +623,4 @@\n+# Microbenchmarks are executed from the root of the test image directory.\n+# This enables JMH tests to add dependencies using relative paths such as\n+# -Djava.library.path=micro\/native\n+\n@@ -628,0 +632,1 @@\n+\t    $$(CD) $$(TEST_IMAGE_DIR) && \\\n","filename":"make\/RunTests.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -392,0 +392,4 @@\n+\n+  # filter out some unwanted additions autoconf may add to CXX; we saw this on macOS with autoconf 2.72\n+  UTIL_GET_NON_MATCHING_VALUES(cxx_filtered, $CXX, -std=c++11 -std=gnu++11)\n+  CXX=\"$cxx_filtered\"\n","filename":"make\/autoconf\/toolchain.m4","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -202,1 +202,1 @@\n-    result=`$GREP -Fvx \"$legal_values\" <<< \"$values_to_check\" | $GREP -v '^$'`\n+    result=`$GREP -Fvx -- \"$legal_values\" <<< \"$values_to_check\" | $GREP -v '^$'`\n@@ -229,1 +229,1 @@\n-    result=`$GREP -Fx \"$illegal_values\" <<< \"$values_to_check\" | $GREP -v '^$'`\n+    result=`$GREP -Fx -- \"$illegal_values\" <<< \"$values_to_check\" | $GREP -v '^$'`\n","filename":"make\/autoconf\/util.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -551,0 +551,1 @@\n+\t      --with-debug-prefix-map=$(OUTPUT_ROOT)=devkit \\\n","filename":"make\/devkit\/Tools.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    maybe-uninitialized missing-field-initializers parentheses \\\n+    maybe-uninitialized missing-field-initializers \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"memory\/resourceArea.hpp\"\n@@ -192,2 +191,0 @@\n-  ResourceMark rm;\n-  int code_size = NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-  const ptrdiff_t estimate = 124;\n+  const ptrdiff_t estimate = 144;\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2865,0 +2865,1 @@\n+  assert(__ last_calls_return_pc() == __ pc(), \"pcn not at return pc\");\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-      CodeBlob* cb = CodeCache::find_blob(pc);\n+      CodeBlob* cb = CodeCache::find_blob_fast(pc);\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-    frame sender(sender_sp, sender_pc);\n+    frame sender(sender_sp, sender_pc, nullptr \/* unextended_sp *\/, nullptr \/* fp *\/, sender_blob);\n@@ -199,1 +199,1 @@\n-    frame fr(jfa->last_Java_sp(), jfa->last_Java_pc());\n+    frame fr(jfa->last_Java_sp(), jfa->last_Java_pc(), kind::code_blob);\n@@ -204,1 +204,1 @@\n-  frame fr(jfa->last_Java_sp());\n+  frame fr(jfa->last_Java_sp(), nullptr, kind::code_blob);\n@@ -232,1 +232,1 @@\n-  frame fr(jfa->last_Java_sp(), jfa->last_Java_pc());\n+  frame fr(jfa->last_Java_sp(), jfa->last_Java_pc(), kind::code_blob);\n@@ -454,1 +454,1 @@\n-frame::frame(void* sp, void* fp, void* pc) : frame((intptr_t*)sp, (address)pc) {}\n+frame::frame(void* sp, void* fp, void* pc) : frame((intptr_t*)sp, (address)pc, kind::unknown) {}\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -396,0 +396,9 @@\n+  enum class kind {\n+    unknown,          \/\/ The frame's pc is not necessarily in the CodeCache.\n+                      \/\/ CodeCache::find_blob_fast(void* pc) can yield wrong results in this case and must not be used.\n+    code_blob,        \/\/ The frame's pc is known to be in the CodeCache but it is likely not in an nmethod.\n+                      \/\/ CodeCache::find_blob_fast() will be correct but not faster in this case.\n+    nmethod           \/\/ This is likely the frame of a nmethod.\n+                      \/\/ The code cache lookup is optimized based on NativePostCallNops.\n+  };\n+\n@@ -399,1 +408,1 @@\n-  inline void setup();\n+  inline void setup(kind knd);\n@@ -405,1 +414,2 @@\n-  inline frame(intptr_t* sp, address pc, intptr_t* unextended_sp = nullptr, intptr_t* fp = nullptr, CodeBlob* cb = nullptr);\n+  inline frame(intptr_t* sp, address pc, kind knd = kind::nmethod);\n+  inline frame(intptr_t* sp, address pc, intptr_t* unextended_sp, intptr_t* fp = nullptr, CodeBlob* cb = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-inline void frame::setup() {\n+inline void frame::setup(kind knd) {\n@@ -45,1 +45,1 @@\n-    _cb = CodeCache::find_blob(_pc);\n+    _cb = (knd == kind::nmethod) ? CodeCache::find_blob_fast(_pc) : CodeCache::find_blob(_pc);\n@@ -92,1 +92,1 @@\n-inline frame::frame(intptr_t* sp) : frame(sp, nullptr) {}\n+inline frame::frame(intptr_t* sp) : frame(sp, nullptr, kind::nmethod) {}\n@@ -96,0 +96,6 @@\n+inline frame::frame(intptr_t* sp, address pc, kind knd)\n+  : _sp(sp), _pc(pc), _cb(nullptr), _oop_map(nullptr),\n+    _on_heap(false), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(sp), _fp(nullptr) {\n+  setup(knd);\n+}\n+\n@@ -99,1 +105,1 @@\n-  setup();\n+  setup(kind::nmethod);\n@@ -106,1 +112,1 @@\n-  setup();\n+  setup(kind::nmethod);\n@@ -116,1 +122,1 @@\n-    setup();\n+    setup(kind::nmethod);\n@@ -303,1 +309,1 @@\n-  return frame(sender_sp(), sender_pc());\n+  return frame(sender_sp(), sender_pc(), kind::code_blob);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-#include \"gc\/shared\/gcArguments.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"macroAssembler_ppc.hpp\"\n@@ -31,0 +28,2 @@\n+#include \"gc\/shared\/gcArguments.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"macroAssembler_ppc.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/register.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"asm\/register.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/x\/xBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1190,0 +1190,3 @@\n+  \/\/ We use CMPI\/CMPLI instructions to encode post call nops.\n+  \/\/ Refer to NativePostCallNop for details.\n+  relocate(post_call_nop_Relocation::spec());\n@@ -1191,1 +1194,2 @@\n-  nop();\n+  Assembler::emit_int32(Assembler::CMPLI_OPCODE | Assembler::opp_u_field(1, 9, 9));\n+  assert(is_post_call_nop(*(int*)(pc() - 4)), \"post call not not found\");\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -420,0 +420,6 @@\n+  static bool is_post_call_nop(int instr_bits) {\n+    const uint32_t nineth_bit = opp_u_field(1, 9, 9);\n+    const uint32_t opcode_mask = 0b111110 << OPCODE_SHIFT;\n+    const uint32_t pcn_mask = opcode_mask | nineth_bit;\n+    return (instr_bits & pcn_mask) == (Assembler::CMPLI_OPCODE | nineth_bit);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -432,0 +432,25 @@\n+bool NativePostCallNop::patch(int32_t oopmap_slot, int32_t cb_offset) {\n+  int32_t i2, i1;\n+  assert(is_aligned(cb_offset, 4), \"cb offset alignment does not match instruction alignment\");\n+  assert(!decode(i1, i2), \"already patched\");\n+\n+  cb_offset = cb_offset >> 2;\n+  if (((oopmap_slot & ppc_oopmap_slot_mask) != oopmap_slot) || ((cb_offset & ppc_cb_offset_mask) != cb_offset)) {\n+    return false;  \/\/ cannot encode\n+  }\n+  const uint32_t data = oopmap_slot << ppc_cb_offset_bits | cb_offset;\n+  const uint32_t lo_data = data & ppc_data_lo_mask;\n+  const uint32_t hi_data = data >> ppc_data_lo_bits;\n+  const uint32_t nineth_bit = 1 << (31 - 9);\n+  uint32_t instr = Assembler::CMPLI_OPCODE | hi_data << ppc_data_hi_shift | nineth_bit | lo_data;\n+  *(uint32_t*)addr_at(0) = instr;\n+\n+  int32_t oopmap_slot_dec, cb_offset_dec;\n+  assert(is_post_call_nop(), \"pcn not recognized\");\n+  assert(decode(oopmap_slot_dec, cb_offset_dec), \"encoding failed\");\n+  assert(oopmap_slot == oopmap_slot_dec, \"oopmap slot encoding is wrong\");\n+  assert((cb_offset << 2) == cb_offset_dec, \"cb offset encoding is wrong\");\n+\n+  return true;  \/\/ encoding succeeded\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  bool is_nop() const { return Assembler::is_nop(long_at(0)); }\n+  bool is_post_call_nop() const { return MacroAssembler::is_post_call_nop(long_at(0)); }\n@@ -509,0 +509,29 @@\n+\n+    \/\/ We use CMPI\/CMPLI to represent Post Call Nops (PCN)\n+\n+    \/\/   Bit |0         5|6    |9 |10|11     |16                          31|\n+    \/\/       +--------------------------------------------------------------+\n+    \/\/ Field |OPCODE     |BF   |\/ |L |RA     |SI                            |\n+    \/\/       +--------------------------------------------------------------+\n+    \/\/       |0 0 1 0 1|DATA HI| 1|        DATA LO                          |\n+    \/\/       |         |4 bits |  |        22 bits                          |\n+    \/\/\n+    \/\/ Bit 9 is always 1 for PCNs to distinguish them from regular CMPI\/CMPLI\n+    \/\/\n+    \/\/ Using both, CMPLI (opcode 10 = 0b001010) and CMPI (opcode 11 = 0b001011) for\n+    \/\/ PCNs allows using bit 5 from the opcode to encode DATA HI.\n+\n+    enum {\n+      ppc_data_lo_bits = 31 - 9,\n+      ppc_data_lo_mask = right_n_bits(ppc_data_lo_bits),\n+      ppc_data_hi_bits = 9 - 5,\n+      ppc_data_hi_shift = ppc_data_lo_bits + 1,\n+      ppc_data_hi_mask = right_n_bits(ppc_data_hi_bits) << ppc_data_hi_shift,\n+      ppc_data_bits = ppc_data_lo_bits + ppc_data_hi_bits,\n+\n+      ppc_oopmap_slot_bits = 9,\n+      ppc_oopmap_slot_mask = right_n_bits(ppc_oopmap_slot_bits),\n+      ppc_cb_offset_bits = ppc_data_bits - ppc_oopmap_slot_bits,\n+      ppc_cb_offset_mask = right_n_bits(ppc_cb_offset_bits),\n+};\n+\n@@ -510,3 +539,14 @@\n-  bool check() const { return is_nop(); }\n-  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const { return false; }\n-  bool patch(int32_t oopmap_slot, int32_t cb_offset) { return false; }\n+  bool check() const { return is_post_call_nop(); }\n+  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const {\n+    uint32_t instr_bits = long_at(0);\n+    uint32_t data_lo = instr_bits & ppc_data_lo_mask;\n+    uint32_t data_hi = (instr_bits & ppc_data_hi_mask) >> 1;\n+    uint32_t data = data_hi | data_lo;\n+    if (data == 0) {\n+      return false; \/\/ no data found\n+    }\n+    cb_offset = (data & ppc_cb_offset_mask) << 2;\n+    oopmap_slot = data >> ppc_cb_offset_bits;\n+    return true; \/\/ decoding succeeded\n+  }\n+  bool patch(int32_t oopmap_slot, int32_t cb_offset);\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -818,0 +818,2 @@\n+  INSN(fcvt_s_h, 0b1010011, 0b00010, 0b0100000);\n+  INSN(fcvt_h_s, 0b1010011, 0b00000, 0b0100010);\n@@ -1074,0 +1076,1 @@\n+  INSN(fmv_h_x,  0b1010011, 0b000, 0b00000, 0b1111010);\n@@ -1111,0 +1114,1 @@\n+  INSN(fclass_h, 0b1010011, 0b001, 0b00000, 0b1110010);\n@@ -1113,0 +1117,1 @@\n+  INSN(fmv_x_h,  0b1010011, 0b000, 0b00000, 0b1110010);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1786,0 +1786,46 @@\n+static void float16_to_float_slow_path(C2_MacroAssembler& masm, C2GeneralStub<FloatRegister, Register, Register>& stub) {\n+#define __ masm.\n+  FloatRegister dst = stub.data<0>();\n+  Register src = stub.data<1>();\n+  Register tmp = stub.data<2>();\n+  __ bind(stub.entry());\n+\n+  \/\/ following instructions mainly focus on NaN, as riscv does not handle\n+  \/\/ NaN well with fcvt, but the code also works for Inf at the same time.\n+\n+  \/\/ construct a NaN in 32 bits from the NaN in 16 bits,\n+  \/\/ we need the payloads of non-canonical NaNs to be preserved.\n+  __ mv(tmp, 0x7f800000);\n+  \/\/ sign-bit was already set via sign-extension if necessary.\n+  __ slli(t0, src, 13);\n+  __ orr(tmp, t0, tmp);\n+  __ fmv_w_x(dst, tmp);\n+\n+  __ j(stub.continuation());\n+#undef __\n+}\n+\n+\/\/ j.l.Float.float16ToFloat\n+void C2_MacroAssembler::float16_to_float(FloatRegister dst, Register src, Register tmp) {\n+  auto stub = C2CodeStub::make<FloatRegister, Register, Register>(dst, src, tmp, 20, float16_to_float_slow_path);\n+\n+  \/\/ in riscv, NaN needs a special process as fcvt does not work in that case.\n+  \/\/ in riscv, Inf does not need a special process as fcvt can handle it correctly.\n+  \/\/ but we consider to get the slow path to process NaN and Inf at the same time,\n+  \/\/ as both of them are rare cases, and if we try to get the slow path to handle\n+  \/\/ only NaN case it would sacrifise the performance for normal cases,\n+  \/\/ i.e. non-NaN and non-Inf cases.\n+\n+  \/\/ check whether it's a NaN or +\/- Inf.\n+  mv(t0, 0x7c00);\n+  andr(tmp, src, t0);\n+  \/\/ jump to stub processing NaN and Inf cases.\n+  beq(t0, tmp, stub->entry());\n+\n+  \/\/ non-NaN or non-Inf cases, just use built-in instructions.\n+  fmv_h_x(dst, src);\n+  fcvt_s_h(dst, dst);\n+\n+  bind(stub->continuation());\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -175,0 +175,2 @@\n+  void float16_to_float(FloatRegister dst, Register src, Register tmp);\n+\n@@ -177,0 +179,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+  product(bool, UseZfh, false, \"Use Zfh instructions\")                           \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"memory\/resourceArea.hpp\"\n@@ -160,1 +159,0 @@\n-  ResourceMark rm;\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1935,0 +1935,3 @@\n+\n+    case Op_ConvHF2F:\n+      return UseZfh;\n@@ -8278,0 +8281,14 @@\n+\/\/ single <-> half precision\n+\n+instruct convHF2F_reg_reg(fRegF dst, iRegINoSp src, iRegINoSp tmp) %{\n+  match(Set dst (ConvHF2F src));\n+  effect(TEMP tmp);\n+  format %{ \"fmv.h.x $dst, $src\\t# move source from $src to $dst\\n\\t\"\n+            \"fcvt.s.h $dst, $dst\\t# convert half to single precision\"\n+  %}\n+  ins_encode %{\n+    __ float16_to_float($dst$$FloatRegister, $src$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -84,0 +84,3 @@\n+    if (FLAG_IS_DEFAULT(UseZfh)) {\n+      FLAG_SET_DEFAULT(UseZfh, true);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,0 +108,2 @@\n+  \/\/ Zfh Half-Precision Floating-Point instructions\n+  \/\/\n@@ -146,0 +148,1 @@\n+  decl(ext_Zfh         , \"Zfh\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfh))         \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1092,1 +1092,2 @@\n-  assert_different_registers(a, b, tmp, atmp, btmp);\n+  assert_different_registers(a, tmp, atmp, btmp);\n+  assert_different_registers(b, tmp, atmp, btmp);\n@@ -1179,1 +1180,2 @@\n-  assert_different_registers(dst, a, b, atmp, btmp);\n+  assert_different_registers(dst, a, atmp, btmp);\n+  assert_different_registers(dst, b, atmp, btmp);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -62,3 +63,10 @@\n-  \/\/ check if locked\n-  __ testptr(result, markWord::unlocked_value);\n-  __ jcc(Assembler::zero, slowCase);\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ check if monitor\n+    __ testptr(result, markWord::monitor_value);\n+    __ jcc(Assembler::notZero, slowCase);\n+  } else {\n+    \/\/ check if locked\n+    __ testptr(result, markWord::unlocked_value);\n+    __ jcc(Assembler::zero, slowCase);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1121,1 +1121,3 @@\n-    ::strncpy(ebuf, \"dll_load: empty filename specified\", ebuflen - 1);\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      ::strncpy(ebuf, \"dll_load: empty filename specified\", ebuflen - 1);\n+    }\n@@ -1136,0 +1138,1 @@\n+  const char* error_report = nullptr;\n@@ -1137,1 +1140,1 @@\n-  result = ::dlopen(filename, dflags);\n+  result = Aix_dlopen(filename, dflags, &error_report);\n@@ -1146,1 +1149,0 @@\n-    const char* error_report = ::dlerror();\n@@ -3029,28 +3031,0 @@\n-\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n-int os::Aix::stat64x_via_LIBPATH(const char* path, struct stat64x* stat) {\n-  if (path[0] == '\/' ||\n-      (path[0] == '.' && (path[1] == '\/' ||\n-                          (path[1] == '.' && path[2] == '\/')))) {\n-    return stat64x(path, stat);\n-  }\n-\n-  const char* env = getenv(\"LIBPATH\");\n-  if (env == nullptr || *env == 0)\n-    return -1;\n-\n-  int ret = -1;\n-  size_t libpathlen = strlen(env);\n-  char* libpath = NEW_C_HEAP_ARRAY(char, libpathlen + 1, mtServiceability);\n-  char* combined = NEW_C_HEAP_ARRAY(char, libpathlen + strlen(path) + 1, mtServiceability);\n-  char *saveptr, *token;\n-  strcpy(libpath, env);\n-  for (token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr)) {\n-    sprintf(combined, \"%s\/%s\", token, path);\n-    if (0 == (ret = stat64x(combined, stat)))\n-      break;\n-  }\n-\n-  FREE_C_HEAP_ARRAY(char*, combined);\n-  FREE_C_HEAP_ARRAY(char*, libpath);\n-  return ret;\n-}\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -178,2 +178,0 @@\n-  \/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n-  static int stat64x_via_LIBPATH(const char* path, struct stat64x* stat);\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,6 @@\n+\/\/ needs to be defined first, so that the implicit loaded xcoff.h header defines\n+\/\/ the right structures to analyze the loader header of 64 Bit executable files\n+\/\/ this is needed for rtv_linkedin_libpath() to get the linked (burned) in library\n+\/\/ search path of an XCOFF executable\n+#define __XCOFF64__\n+#include <xcoff.h>\n@@ -894,0 +900,272 @@\n+\n+\/\/ variables needed to emulate linux behavior in os::dll_load() if library is loaded twice\n+static pthread_mutex_t g_handletable_mutex = PTHREAD_MUTEX_INITIALIZER;\n+\n+struct TableLocker {\n+  TableLocker() { pthread_mutex_lock(&g_handletable_mutex); }\n+  ~TableLocker() { pthread_mutex_unlock(&g_handletable_mutex); }\n+};\n+struct handletableentry{\n+    void*   handle;\n+    ino64_t inode;\n+    dev64_t devid;\n+    uint    refcount;\n+};\n+constexpr unsigned init_num_handles = 128;\n+static unsigned max_handletable = 0;\n+static unsigned g_handletable_used = 0;\n+\/\/ We start with an empty array. At first use we will dynamically allocate memory for 128 entries.\n+\/\/ If this table is full we dynamically reallocate a memory reagion of double size, and so on.\n+static struct handletableentry* p_handletable = nullptr;\n+\n+\/\/ get the library search path burned in to the executable file during linking\n+\/\/ If the libpath cannot be retrieved return an empty path\n+static const char* rtv_linkedin_libpath() {\n+  constexpr int bufsize = 4096;\n+  static char buffer[bufsize];\n+  static const char* libpath = 0;\n+\n+  \/\/ we only try to retrieve the libpath once. After that try we\n+  \/\/ let libpath point to buffer, which then contains a valid libpath\n+  \/\/ or an empty string\n+  if (libpath != nullptr) {\n+    return libpath;\n+  }\n+\n+  \/\/ retrieve the path to the currently running executable binary\n+  \/\/ to open it\n+  snprintf(buffer, 100, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n+  FILE* f = nullptr;\n+  struct xcoffhdr the_xcoff;\n+  struct scnhdr the_scn;\n+  struct ldhdr the_ldr;\n+  constexpr size_t xcoffsz = FILHSZ + _AOUTHSZ_EXEC;\n+  STATIC_ASSERT(sizeof(the_xcoff) == xcoffsz);\n+  STATIC_ASSERT(sizeof(the_scn) == SCNHSZ);\n+  STATIC_ASSERT(sizeof(the_ldr) == LDHDRSZ);\n+  \/\/ read the generic XCOFF header and analyze the substructures\n+  \/\/ to find the burned in libpath. In any case of error perform the assert\n+  if (nullptr == (f = fopen(buffer, \"r\")) ||\n+      xcoffsz != fread(&the_xcoff, 1, xcoffsz, f) ||\n+      the_xcoff.filehdr.f_magic != U64_TOCMAGIC ||\n+      0 != fseek(f, (FILHSZ + the_xcoff.filehdr.f_opthdr + (the_xcoff.aouthdr.o_snloader -1)*SCNHSZ), SEEK_SET) ||\n+      SCNHSZ != fread(&the_scn, 1, SCNHSZ, f) ||\n+      0 != strcmp(the_scn.s_name, \".loader\") ||\n+      0 != fseek(f, the_scn.s_scnptr, SEEK_SET) ||\n+      LDHDRSZ != fread(&the_ldr, 1, LDHDRSZ, f) ||\n+      0 != fseek(f, the_scn.s_scnptr + the_ldr.l_impoff, SEEK_SET) ||\n+      0 == fread(buffer, 1, bufsize, f)) {\n+    buffer[0] = 0;\n+    assert(false, \"could not retrieve burned in library path from executables loader section\");\n+  }\n+\n+  if (f) {\n+    fclose(f);\n+  }\n+  libpath = buffer;\n+\n+  return libpath;\n+}\n+\n+\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n+static bool search_file_in_LIBPATH(const char* path, struct stat64x* stat) {\n+  if (path == nullptr)\n+    return false;\n+\n+  char* path2 = os::strdup(path);\n+  \/\/ if exist, strip off trailing (shr_64.o) or similar\n+  char* substr;\n+  if (path2[strlen(path2) - 1] == ')' && (substr = strrchr(path2, '('))) {\n+    *substr = 0;\n+  }\n+\n+  bool ret = false;\n+  \/\/ If FilePath contains a slash character, FilePath is used directly,\n+  \/\/ and no directories are searched.\n+  \/\/ But if FilePath does not start with \/ or . we have to prepend it with .\/\n+  if (strchr(path2, '\/')) {\n+    stringStream combined;\n+    if (*path2 == '\/' || *path2 == '.') {\n+      combined.print(\"%s\", path2);\n+    } else {\n+      combined.print(\".\/%s\", path2);\n+    }\n+    ret = (0 == stat64x(combined.base(), stat));\n+    os::free(path2);\n+    return ret;\n+  }\n+\n+  const char* env = getenv(\"LIBPATH\");\n+  if (env == nullptr) {\n+    \/\/ no LIBPATH, try with LD_LIBRARY_PATH\n+    env = getenv(\"LD_LIBRARY_PATH\");\n+  }\n+\n+  stringStream Libpath;\n+  if (env == nullptr) {\n+    \/\/ no LIBPATH or LD_LIBRARY_PATH given -> try only with burned in libpath\n+    Libpath.print(\"%s\", rtv_linkedin_libpath());\n+  } else if (*env == 0) {\n+    \/\/ LIBPATH or LD_LIBRARY_PATH given but empty -> try first with burned\n+    \/\/  in libpath and with current working directory second\n+    Libpath.print(\"%s:.\", rtv_linkedin_libpath());\n+  } else {\n+    \/\/ LIBPATH or LD_LIBRARY_PATH given with content -> try first with\n+    \/\/ LIBPATH or LD_LIBRARY_PATH and second with burned in libpath.\n+    \/\/ No check against current working directory\n+    Libpath.print(\"%s:%s\", env, rtv_linkedin_libpath());\n+  }\n+\n+  char* libpath = os::strdup(Libpath.base());\n+\n+  char *saveptr, *token;\n+  for (token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr)) {\n+    stringStream combined;\n+    combined.print(\"%s\/%s\", token, path2);\n+    if ((ret = (0 == stat64x(combined.base(), stat))))\n+      break;\n+  }\n+\n+  os::free(libpath);\n+  os::free(path2);\n+  return ret;\n+}\n+\n+\/\/ specific AIX versions for ::dlopen() and ::dlclose(), which handles the struct g_handletable\n+\/\/ This way we mimic dl handle equality for a library\n+\/\/ opened a second time, as it is implemented on other platforms.\n+void* Aix_dlopen(const char* filename, int Flags, const char** error_report) {\n+  assert(error_report != nullptr, \"error_report is nullptr\");\n+  void* result;\n+  struct stat64x libstat;\n+\n+  if (false == search_file_in_LIBPATH(filename, &libstat)) {\n+    \/\/ file with filename does not exist\n+  #ifdef ASSERT\n+    result = ::dlopen(filename, Flags);\n+    assert(result == nullptr, \"dll_load: Could not stat() file %s, but dlopen() worked; Have to improve stat()\", filename);\n+  #endif\n+    *error_report = \"Could not load module .\\nSystem error: No such file or directory\";\n+    return nullptr;\n+  }\n+  else {\n+    unsigned i = 0;\n+    TableLocker lock;\n+    \/\/ check if library belonging to filename is already loaded.\n+    \/\/ If yes use stored handle from previous ::dlopen() and increase refcount\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if ((p_handletable + i)->handle &&\n+          (p_handletable + i)->inode == libstat.st_ino &&\n+          (p_handletable + i)->devid == libstat.st_dev) {\n+        (p_handletable + i)->refcount++;\n+        result = (p_handletable + i)->handle;\n+        break;\n+      }\n+    }\n+    if (i == g_handletable_used) {\n+      \/\/ library not yet loaded. Check if there is space left in array\n+      \/\/ to store new ::dlopen() handle\n+      if (g_handletable_used == max_handletable) {\n+        \/\/ No place in array anymore; increase array.\n+        unsigned new_max = MAX2(max_handletable * 2, init_num_handles);\n+        struct handletableentry* new_tab = (struct handletableentry*)::realloc(p_handletable, new_max * sizeof(struct handletableentry));\n+        assert(new_tab != nullptr, \"no more memory for handletable\");\n+        if (new_tab == nullptr) {\n+          *error_report = \"dlopen: no more memory for handletable\";\n+          return nullptr;\n+        }\n+        max_handletable = new_max;\n+        p_handletable = new_tab;\n+      }\n+      \/\/ Library not yet loaded; load it, then store its handle in handle table\n+      result = ::dlopen(filename, Flags);\n+      if (result != nullptr) {\n+        g_handletable_used++;\n+        (p_handletable + i)->handle = result;\n+        (p_handletable + i)->inode = libstat.st_ino;\n+        (p_handletable + i)->devid = libstat.st_dev;\n+        (p_handletable + i)->refcount = 1;\n+      }\n+      else {\n+        \/\/ error analysis when dlopen fails\n+        *error_report = ::dlerror();\n+        if (*error_report == nullptr) {\n+          *error_report = \"dlerror returned no error description\";\n+        }\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+  unsigned i = 0;\n+  bool res = false;\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  {\n+    TableLocker lock;\n+    \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if ((p_handletable + i)->handle == libhandle) {\n+        \/\/ handle found, decrease refcount\n+        assert((p_handletable + i)->refcount > 0, \"Sanity\");\n+        (p_handletable + i)->refcount--;\n+        if ((p_handletable + i)->refcount > 0) {\n+          \/\/ if refcount is still >0 then we have to keep library and just return true\n+          return true;\n+        }\n+        \/\/ refcount == 0, so we have to ::dlclose() the lib\n+        \/\/ and delete the entry from the array.\n+        break;\n+      }\n+    }\n+\n+    \/\/ If we reach this point either the libhandle was found with refcount == 0, or the libhandle\n+    \/\/ was not found in the array at all. In both cases we have to ::dlclose the lib and perform\n+    \/\/ the error handling. In the first case we then also have to delete the entry from the array\n+    \/\/ while in the second case we simply have to nag.\n+    res = (0 == ::dlclose(libhandle));\n+    if (!res) {\n+      \/\/ error analysis when dlopen fails\n+      const char* error_report = ::dlerror();\n+      if (error_report == nullptr) {\n+        error_report = \"dlerror returned no error description\";\n+      }\n+      if (ebuf != nullptr && ebuflen > 0) {\n+        snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+      }\n+      assert(false, \"os::pd_dll_unload() ::dlclose() failed\");\n+    }\n+\n+    if (i < g_handletable_used) {\n+      if (res) {\n+        \/\/ First case: libhandle was found (with refcount == 0) and ::dlclose successful,\n+        \/\/ so delete entry from array\n+        g_handletable_used--;\n+        \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n+        \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n+        \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n+        if (i < g_handletable_used) {\n+          *(p_handletable + i) = *(p_handletable + g_handletable_used);\n+          (p_handletable + g_handletable_used)->handle = nullptr;\n+        }\n+      }\n+    }\n+    else {\n+      \/\/ Second case: libhandle was not found (library was not loaded by os::dll_load())\n+      \/\/ therefore nag\n+      assert(false, \"os::pd_dll_unload() library was not loaded by os::dll_load()\");\n+    }\n+  }\n+\n+  \/\/ Update the dll cache\n+  LoadedLibraries::reload();\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n+\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":278,"deletions":0,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+void* Aix_dlopen(const char* filename, int Flags, const char** error_report);\n+\n","filename":"src\/hotspot\/os\/aix\/porting_aix.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2533,0 +2533,22 @@\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  bool res = (0 == ::dlclose(libhandle));\n+  if (!res) {\n+    \/\/ error analysis when dlopen fails\n+    const char* error_report = ::dlerror();\n+    if (error_report == nullptr) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    }\n+  }\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -5472,0 +5472,22 @@\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  bool res = (0 == ::dlclose(libhandle));\n+  if (!res) {\n+    \/\/ error analysis when dlopen fails\n+    const char* error_report = ::dlerror();\n+    if (error_report == nullptr) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    }\n+  }\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"os_aix.hpp\"\n@@ -734,1 +735,0 @@\n-  int res = ::dlclose(lib);\n@@ -736,1 +736,4 @@\n-  if (res == 0) {\n+  char ebuf[1024];\n+  bool res = os::pd_dll_unload(lib, ebuf, sizeof(ebuf));\n+\n+  if (res) {\n@@ -742,5 +745,0 @@\n-    const char* error_report = ::dlerror();\n-    if (error_report == nullptr) {\n-      error_report = \"dlerror returned no error description\";\n-    }\n-\n@@ -748,1 +746,1 @@\n-                            l_path, p2i(lib), error_report);\n+                            l_path, p2i(lib), ebuf);\n@@ -750,2 +748,2 @@\n-                  l_path, p2i(lib), error_report);\n-    JFR_ONLY(unload_event.set_error_msg(error_report);)\n+                  l_path, p2i(lib), ebuf);\n+    JFR_ONLY(unload_event.set_error_msg(ebuf);)\n@@ -753,2 +751,0 @@\n-  \/\/ Update the dll cache\n-  AIX_ONLY(LoadedLibraries::reload());\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-  return frame(sp, pc);\n+  \/\/ Likely the frame of a RuntimeStub.\n+  return frame(sp, pc, frame::kind::code_blob);\n@@ -53,1 +54,1 @@\n-    *fr_addr = frame(sp, pc);\n+    *fr_addr = frame(sp, pc, frame::kind::code_blob);\n@@ -69,1 +70,2 @@\n-    frame ret_frame((intptr_t*)uc->uc_mcontext.jmp_context.gpr[1\/*REG_SP*\/], pc);\n+    \/\/ pc could refer to a native address outside the code cache even though the thread isInJava.\n+    frame ret_frame((intptr_t*)uc->uc_mcontext.jmp_context.gpr[1\/*REG_SP*\/], pc, frame::kind::unknown);\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/javaThread_aix_ppc.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-    frame fr(sp, epc);\n+    frame fr(sp, epc, frame::kind::unknown);\n@@ -140,1 +140,1 @@\n-  return frame(sp, lr);\n+  return frame(sp, lr, frame::kind::unknown);\n@@ -146,1 +146,1 @@\n-    return frame(nullptr, nullptr);\n+    return frame();\n@@ -148,1 +148,1 @@\n-  return frame(fr->sender_sp(), fr->sender_pc());\n+  return frame(fr->sender_sp(), fr->sender_pc(), frame::kind::unknown);\n@@ -154,1 +154,1 @@\n-  frame topframe(csp, CAST_FROM_FN_PTR(address, os::current_frame));\n+  frame topframe(csp, CAST_FROM_FN_PTR(address, os::current_frame), frame::kind::unknown);\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-  return frame(sp, pc);\n+  \/\/ Likely the frame of a RuntimeStub.\n+  return frame(sp, pc, frame::kind::code_blob);\n@@ -52,1 +53,1 @@\n-    *fr_addr = frame(sp, pc);\n+    *fr_addr = frame(sp, pc, frame::kind::code_blob);\n@@ -68,1 +69,2 @@\n-    frame ret_frame((intptr_t*)uc->uc_mcontext.regs->gpr[1\/*REG_SP*\/], pc);\n+    \/\/ pc could refer to a native address outside the code cache even though the thread isInJava.\n+    frame ret_frame((intptr_t*)uc->uc_mcontext.regs->gpr[1\/*REG_SP*\/], pc, frame::kind::unknown);\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/javaThread_linux_ppc.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  return frame(sp, epc);\n+  return frame(sp, epc, frame::kind::unknown);\n@@ -166,1 +166,1 @@\n-  return frame(sp, lr);\n+  return frame(sp, lr, frame::kind::unknown);\n@@ -172,1 +172,1 @@\n-    return frame(nullptr, nullptr);\n+    return frame();\n@@ -174,1 +174,1 @@\n-  return frame(fr->sender_sp(), fr->sender_pc());\n+  return frame(fr->sender_sp(), fr->sender_pc(), frame::kind::unknown);\n@@ -180,1 +180,1 @@\n-  frame topframe(csp, CAST_FROM_FN_PTR(address, os::current_frame));\n+  frame topframe(csp, CAST_FROM_FN_PTR(address, os::current_frame), frame::kind::unknown);\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -245,0 +245,2 @@\n+  ext_Zfh.enable_feature();\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -424,2 +424,5 @@\n-    remove_range_check(ai);\n-    return;\n+    \/\/ Guard against underflow\/overflow (see 'range_cond' check in RangeCheckEliminator::in_block_motion)\n+    if (aii->_max < 0 || (aii->_max + min_jint) <= aii->_min) {\n+      remove_range_check(ai);\n+      return;\n+    }\n@@ -468,1 +471,1 @@\n-        int last_integer = 0;\n+        jint last_integer = 0;\n@@ -470,1 +473,1 @@\n-        int base = 0;\n+        jint base = 0;\n@@ -482,1 +485,1 @@\n-            int value = c->type()->as_IntConstant()->value();\n+            jint value = c->type()->as_IntConstant()->value();\n@@ -487,1 +490,1 @@\n-              base += value;\n+              base = java_add(base, value);\n@@ -509,1 +512,1 @@\n-        \/\/ length-1 and if min < 0, min + idx may overflow and be >=\n+        \/\/ length-1 and if min < 0, min + idx may underflow\/overflow and be >=\n@@ -514,1 +517,1 @@\n-        bool range_cond = (info->_max < 0 || info->_max + min_jint <= info->_min);\n+        bool range_cond = (info->_max < 0 || (info->_max + min_jint) <= info->_min);\n@@ -862,1 +865,1 @@\n-    } else if (_optimistic && loop_header) {\n+    } else if (false && _optimistic && loop_header) {\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2260,2 +2260,2 @@\n-    keys = high - low + 1;\n-    if (keys < 0) {\n+    int64_t keys64 = ((int64_t)high - low) + 1;\n+    if (keys64 > 65535) {  \/\/ Max code length\n@@ -2265,0 +2265,1 @@\n+    keys = (int)keys64;\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-    ICStub* stub = ICStub_from_destination_address(stub_address());\n+    ICStub* stub = ICStub::from_destination_address(stub_address());\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    assert(this == ICStub_from_destination_address(ic->stub_address()), \"wrong owner of ic buffer\");\n+    assert(this == ICStub::from_destination_address(ic->stub_address()), \"wrong owner of ic buffer\");\n@@ -149,5 +149,0 @@\n-ICStub* InlineCacheBuffer::new_ic_stub() {\n-  return (ICStub*)buffer()->request_committed(ic_stub_code_size());\n-}\n-\n-\n@@ -213,1 +208,1 @@\n-  ICStub* ic_stub = new_ic_stub();\n+  ICStub* ic_stub = (ICStub*) buffer()->request_committed(ic_stub_code_size());\n@@ -222,0 +217,9 @@\n+#ifdef ASSERT\n+  {\n+    ICStub* rev_stub = ICStub::from_destination_address(ic_stub->code_begin());\n+    assert(ic_stub == rev_stub,\n+           \"ICStub mapping is reversible: stub=\" PTR_FORMAT \", code=\" PTR_FORMAT \", rev_stub=\" PTR_FORMAT,\n+           p2i(ic_stub), p2i(ic_stub->code_begin()), p2i(rev_stub));\n+  }\n+#endif\n+\n@@ -224,1 +228,1 @@\n-    ICStub* old_stub = ICStub_from_destination_address(ic->stub_address());\n+    ICStub* old_stub = ICStub::from_destination_address(ic->stub_address());\n@@ -237,1 +241,1 @@\n-  ICStub* stub = ICStub_from_destination_address(ic->stub_address());\n+  ICStub* stub = ICStub::from_destination_address(ic->stub_address());\n@@ -243,1 +247,1 @@\n-  ICStub* stub = ICStub_from_destination_address(ic->stub_address());\n+  ICStub* stub = ICStub::from_destination_address(ic->stub_address());\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -65,3 +65,14 @@\n-  \/\/ ICStub_from_destination_address looks up Stub* address from code entry address,\n-  \/\/ which unfortunately means the stub head should be at the same alignment as the code.\n-  static  int alignment()                        { return CodeEntryAlignment; }\n+  \/\/ To be cautious, we want to make sure that each ICStub is in a separate instruction\n+  \/\/ cache line. This would allow for piggybacking on instruction cache coherency on\n+  \/\/ some architectures to order the updates to ICStub and setting the destination to\n+  \/\/ the ICStub. Note that cache line size might be larger than CodeEntryAlignment\n+  \/\/ that is normal alignment for CodeBlobs.\n+  static int alignment()                         { return DEFAULT_CACHE_LINE_SIZE; }\n+\n+  \/\/ Aligning the code section is normally done for performance reasons, which is not\n+  \/\/ required for ICStubs, as these stubs are transitional. Setting code alignment\n+  \/\/ to CodeEntryAlignment would waste a lot of memory in ICBuffer. Aligning to\n+  \/\/ word size should be enough. This also offsets the costs of aligning the entire\n+  \/\/ ICStub to cache line (see above), as smaller code alignment would allow ICStub\n+  \/\/ to fit a _single_ cache line.\n+  static int code_alignment()                    { return HeapWordSize; }\n@@ -74,1 +85,1 @@\n-  address code_begin() const                     { return align_up((address)this + sizeof(ICStub), CodeEntryAlignment); }\n+  address code_begin() const                     { return align_up((address)this + sizeof(ICStub), code_alignment()); }\n@@ -91,1 +102,7 @@\n-  friend ICStub* ICStub_from_destination_address(address destination_address);\n+  static inline ICStub* from_destination_address(address destination_address) {\n+    ICStub* stub = (ICStub*) align_down(destination_address - sizeof(ICStub), alignment());\n+#ifdef ASSERT\n+    stub->verify();\n+#endif\n+    return stub;\n+  }\n@@ -94,9 +111,0 @@\n-\/\/ ICStub Creation\n-inline ICStub* ICStub_from_destination_address(address destination_address) {\n-  ICStub* stub = (ICStub*) (destination_address - align_up(sizeof(ICStub), CodeEntryAlignment));\n-  #ifdef ASSERT\n-  stub->verify();\n-  #endif\n-  return stub;\n-}\n-\n@@ -154,2 +162,0 @@\n-  static ICStub* new_ic_stub();\n-\n","filename":"src\/hotspot\/share\/code\/icBuffer.hpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -76,3 +76,9 @@\n-  _buffer_size     = blob->content_size();\n-  _buffer_limit    = blob->content_size();\n-  _stub_buffer     = blob->content_begin();\n+\n+  \/\/ The code blob alignment can be smaller than the requested stub alignment.\n+  \/\/ Make sure we put the stubs at their requested alignment by aligning the buffer base and limits.\n+  address aligned_start = align_up(blob->content_begin(), stub_alignment());\n+  address aligned_end = align_down(blob->content_end(), stub_alignment());\n+  int aligned_size = aligned_end - aligned_start;\n+  _buffer_size     = aligned_size;\n+  _buffer_limit    = aligned_size;\n+  _stub_buffer     = aligned_start;\n@@ -97,2 +103,5 @@\n-  _buffer_size = blob->content_size();\n-  _buffer_limit = blob->content_size();\n+  address aligned_start = align_up(blob->content_begin(), stub_alignment());\n+  address aligned_end = align_down(blob->content_end(), stub_alignment());\n+  int aligned_size = aligned_end - aligned_start;\n+  _buffer_size = aligned_size;\n+  _buffer_limit = aligned_size;\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-\/\/ code_begin -->|--------|    |       <--- aligned by CodeEntryAlignment\n+\/\/ code_begin -->|--------|    |       <--- aligned by code_alignment()\n@@ -102,0 +102,1 @@\n+  virtual int     code_alignment() const                   = 0; \/\/ computes the code alignment\n@@ -130,0 +131,1 @@\n+    virtual int     code_alignment() const                 { return stub::code_alignment(); }      \\\n@@ -157,0 +159,1 @@\n+  void  check_stub_align(Stub* s) const          { assert(((intptr_t)s) % stub_alignment() == 0, \"incorrect stub alignment\"); }\n@@ -159,1 +162,1 @@\n-  Stub* stub_at(int i) const                     { check_index(i); return (Stub*)(_stub_buffer + i); }\n+  Stub* stub_at(int i) const                     { check_index(i); Stub* s = (Stub*)(_stub_buffer + i); check_stub_align(s); return s; }\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -406,1 +406,1 @@\n-                               \"marked %d pinned count %u reclaim candidate %d type array %d\",\n+                               \"marked %d pinned count %zu reclaim candidate %d type array %d\",\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -427,1 +427,1 @@\n-  st->print(\"|%3u\", Atomic::load(&_pinned_object_count));\n+  st->print(\"|%3zu\", Atomic::load(&_pinned_object_count));\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -260,1 +260,1 @@\n-  volatile uint _pinned_object_count;\n+  volatile size_t _pinned_object_count;\n@@ -411,1 +411,1 @@\n-  uint pinned_count() const { return Atomic::load(&_pinned_object_count); }\n+  size_t pinned_count() const { return Atomic::load(&_pinned_object_count); }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -557,1 +557,1 @@\n-  Atomic::add(&_pinned_object_count, 1u, memory_order_relaxed);\n+  Atomic::add(&_pinned_object_count, (size_t)1, memory_order_relaxed);\n@@ -561,1 +561,1 @@\n-  Atomic::sub(&_pinned_object_count, 1u, memory_order_relaxed);\n+  Atomic::sub(&_pinned_object_count, (size_t)1, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  nonstatic_field(HeapRegion, _pinned_object_count, volatile uint)            \\\n+  volatile_nonstatic_field(HeapRegion, _pinned_object_count, size_t)          \\\n","filename":"src\/hotspot\/share\/gc\/g1\/vmStructs_g1.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -586,6 +586,0 @@\n-  } else {\n-    \/\/ EXPERIMENTAL ADJUSTMENT\n-    \/\/ Only record that the estimator indicated such an action.\n-    \/\/ *desired_eden_size_ptr = *desired_eden_size_ptr + eden_heap_delta;\n-    set_change_young_gen_for_min_pauses(\n-      increase_young_gen_for_min_pauses_true);\n@@ -612,6 +606,0 @@\n-    } else {\n-      \/\/ EXPERIMENTAL ADJUSTMENT\n-      \/\/ Only record that the estimator indicated such an action.\n-      \/\/ *desired_promo_size_ptr = _promo_size +\n-      \/\/   promo_increment_aligned_up(*desired_promo_size_ptr);\n-      set_change_old_gen_for_maj_pauses(increase_old_gen_for_maj_pauses_true);\n@@ -703,8 +691,0 @@\n-        } else {\n-          \/\/ EXPERIMENTAL ADJUSTMENT\n-          \/\/ Record that decreasing the old gen size would decrease\n-          \/\/ the major collection cost but don't do it.\n-          \/\/ *desired_promo_size_ptr = _promo_size -\n-          \/\/   promo_decrement_aligned_down(*desired_promo_size_ptr);\n-          set_change_old_gen_for_throughput(\n-                decrease_old_gen_for_throughput_true);\n@@ -790,8 +770,0 @@\n-      } else {\n-        \/\/ EXPERIMENTAL ADJUSTMENT\n-        \/\/ Record that decreasing the young gen size would decrease\n-        \/\/ the minor collection cost but don't do it.\n-        \/\/ *desired_eden_size_ptr = _eden_size -\n-        \/\/   eden_decrement_aligned_down(*desired_eden_size_ptr);\n-        set_change_young_gen_for_throughput(\n-          decrease_young_gen_for_througput_true);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1107,5 +1107,0 @@\n-\/\/ Moved from inline file as they are not called inline\n-ContiguousSpace* DefNewGeneration::first_compaction_space() const {\n-  return eden();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/serial\/tenuredGeneration.hpp\"\n@@ -55,1 +56,2 @@\n-  Generation* _old_gen;\n+  TenuredGeneration* _old_gen;\n+\n@@ -171,2 +173,0 @@\n-  virtual ContiguousSpace* first_compaction_space() const;\n-\n@@ -259,2 +259,2 @@\n-  \/\/ at some additional cost. Override superclass's implementation.\n-  virtual bool collection_attempt_is_safe();\n+  \/\/ at some additional cost.\n+  bool collection_attempt_is_safe();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -116,8 +116,0 @@\n-bool Generation::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {\n-  size_t available = max_contiguous_available();\n-  bool   res = (available >= max_promotion_in_bytes);\n-  log_trace(gc)(\"Generation: promo attempt is%s safe: available(\" SIZE_FORMAT \") %s max_promo(\" SIZE_FORMAT \")\",\n-                res? \"\":\" not\", available, res? \">=\":\"<\", max_promotion_in_bytes);\n-  return res;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n-#ifndef SHARE_GC_SHARED_GENERATION_HPP\n-#define SHARE_GC_SHARED_GENERATION_HPP\n+#ifndef SHARE_GC_SERIAL_GENERATION_HPP\n+#define SHARE_GC_SERIAL_GENERATION_HPP\n@@ -58,10 +58,0 @@\n-\/\/ A \"ScratchBlock\" represents a block of memory in one generation usable by\n-\/\/ another.  It represents \"num_words\" free words, starting at and including\n-\/\/ the address of \"this\".\n-struct ScratchBlock {\n-  ScratchBlock* next;\n-  size_t num_words;\n-  HeapWord scratch_space[1];  \/\/ Actually, of size \"num_words-2\" (assuming\n-                              \/\/ first two fields are word-sized.)\n-};\n-\n@@ -135,6 +125,0 @@\n-  \/\/ Returns true if promotions of the specified amount are\n-  \/\/ likely to succeed without a promotion failure.\n-  \/\/ Promotion of the full amount is not guaranteed but\n-  \/\/ might be attempted in the worst case.\n-  virtual bool promotion_attempt_is_safe(size_t max_promotion_in_bytes) const;\n-\n@@ -178,4 +162,0 @@\n-  \/\/ Returns the first space, if any, in the generation that can participate\n-  \/\/ in compaction, or else \"null\".\n-  virtual ContiguousSpace* first_compaction_space() const = 0;\n-\n@@ -205,12 +185,0 @@\n-  virtual size_t tlab_capacity() const {\n-    guarantee(false, \"Generation doesn't support thread local allocation buffers\");\n-    return 0;\n-  }\n-  virtual size_t tlab_used() const {\n-    guarantee(false, \"Generation doesn't support thread local allocation buffers\");\n-    return 0;\n-  }\n-  virtual size_t unsafe_max_tlab_alloc() const {\n-    guarantee(false, \"Generation doesn't support thread local allocation buffers\");\n-    return 0;\n-  }\n@@ -231,1 +199,1 @@\n-  \/\/ Note: in the current (1.4) implementation, when genCollectedHeap's\n+  \/\/ Note: in the current (1.4) implementation, when serialHeap's\n@@ -243,10 +211,0 @@\n-  \/\/ Returns true if the collection is likely to be safely\n-  \/\/ completed. Even if this method returns true, a collection\n-  \/\/ may not be guaranteed to succeed, and the system should be\n-  \/\/ able to safely unwind and recover from that failure, albeit\n-  \/\/ at some additional cost.\n-  virtual bool collection_attempt_is_safe() {\n-    guarantee(false, \"Are you sure you want to call this method?\");\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":4,"deletions":46,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,8 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/stringTable.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/icBuffer.hpp\"\n+#include \"compiler\/oopMap.hpp\"\n+#include \"gc\/serial\/cardTableRS.hpp\"\n@@ -27,0 +35,2 @@\n+#include \"gc\/serial\/genMarkSweep.hpp\"\n+#include \"gc\/serial\/markSweep.hpp\"\n@@ -28,0 +38,2 @@\n+#include \"gc\/serial\/serialMemoryPools.hpp\"\n+#include \"gc\/serial\/serialVMOperations.hpp\"\n@@ -29,0 +41,7 @@\n+#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n+#include \"gc\/shared\/collectorCounters.hpp\"\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n+#include \"gc\/shared\/gcId.hpp\"\n+#include \"gc\/shared\/gcInitLogger.hpp\"\n@@ -30,1 +49,9 @@\n-#include \"gc\/shared\/genMemoryPools.hpp\"\n+#include \"gc\/shared\/gcPolicyCounters.hpp\"\n+#include \"gc\/shared\/gcTrace.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"gc\/shared\/genArguments.hpp\"\n+#include \"gc\/shared\/locationPrinter.inline.hpp\"\n+#include \"gc\/shared\/oopStorage.inline.hpp\"\n+#include \"gc\/shared\/oopStorageParState.inline.hpp\"\n+#include \"gc\/shared\/oopStorageSet.inline.hpp\"\n@@ -32,0 +59,1 @@\n+#include \"gc\/shared\/space.hpp\"\n@@ -34,0 +62,6 @@\n+#include \"gc\/shared\/weakProcessor.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"memory\/metaspaceCounters.hpp\"\n+#include \"memory\/metaspaceUtils.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -35,0 +69,4 @@\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n@@ -36,0 +74,2 @@\n+#include \"runtime\/threads.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -37,0 +77,10 @@\n+#include \"services\/memoryService.hpp\"\n+#include \"utilities\/autoRestore.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/stack.inline.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#endif\n@@ -43,3 +93,9 @@\n-    GenCollectedHeap(Generation::DefNew,\n-                     Generation::MarkSweepCompact,\n-                     \"Copy:MSC\"),\n+    CollectedHeap(),\n+    _young_gen(nullptr),\n+    _old_gen(nullptr),\n+    _rem_set(nullptr),\n+    _soft_ref_policy(),\n+    _gc_policy_counters(new GCPolicyCounters(\"Copy:MSC\", 2, 2)),\n+    _incremental_collection_failed(false),\n+    _young_manager(nullptr),\n+    _old_manager(nullptr),\n@@ -54,1 +110,0 @@\n-\n@@ -78,1 +133,0 @@\n-\n@@ -136,0 +190,925 @@\n+\n+jint SerialHeap::initialize() {\n+  \/\/ Allocate space for the heap.\n+\n+  ReservedHeapSpace heap_rs = allocate(HeapAlignment);\n+\n+  if (!heap_rs.is_reserved()) {\n+    vm_shutdown_during_initialization(\n+      \"Could not reserve enough space for object heap\");\n+    return JNI_ENOMEM;\n+  }\n+\n+  initialize_reserved_region(heap_rs);\n+\n+  ReservedSpace young_rs = heap_rs.first_part(MaxNewSize);\n+  ReservedSpace old_rs = heap_rs.last_part(MaxNewSize);\n+\n+  _rem_set = create_rem_set(heap_rs.region());\n+  _rem_set->initialize(young_rs.base(), old_rs.base());\n+\n+  CardTableBarrierSet *bs = new CardTableBarrierSet(_rem_set);\n+  bs->initialize();\n+  BarrierSet::set_barrier_set(bs);\n+\n+  _young_gen = new DefNewGeneration(young_rs, NewSize, MinNewSize, MaxNewSize);\n+  _old_gen = new TenuredGeneration(old_rs, OldSize, MinOldSize, MaxOldSize, rem_set());\n+\n+  GCInitLogger::print();\n+\n+  return JNI_OK;\n+}\n+\n+\n+CardTableRS* SerialHeap::create_rem_set(const MemRegion& reserved_region) {\n+  return new CardTableRS(reserved_region);\n+}\n+\n+ReservedHeapSpace SerialHeap::allocate(size_t alignment) {\n+  \/\/ Now figure out the total size.\n+  const size_t pageSize = UseLargePages ? os::large_page_size() : os::vm_page_size();\n+  assert(alignment % pageSize == 0, \"Must be\");\n+\n+  \/\/ Check for overflow.\n+  size_t total_reserved = MaxNewSize + MaxOldSize;\n+  if (total_reserved < MaxNewSize) {\n+    vm_exit_during_initialization(\"The size of the object heap + VM data exceeds \"\n+                                  \"the maximum representable size\");\n+  }\n+  assert(total_reserved % alignment == 0,\n+         \"Gen size; total_reserved=\" SIZE_FORMAT \", alignment=\"\n+         SIZE_FORMAT, total_reserved, alignment);\n+\n+  ReservedHeapSpace heap_rs = Universe::reserve_heap(total_reserved, alignment);\n+  size_t used_page_size = heap_rs.page_size();\n+\n+  os::trace_page_sizes(\"Heap\",\n+                       MinHeapSize,\n+                       total_reserved,\n+                       heap_rs.base(),\n+                       heap_rs.size(),\n+                       used_page_size);\n+\n+  return heap_rs;\n+}\n+\n+class GenIsScavengable : public BoolObjectClosure {\n+public:\n+  bool do_object_b(oop obj) {\n+    return SerialHeap::heap()->is_in_young(obj);\n+  }\n+};\n+\n+static GenIsScavengable _is_scavengable;\n+\n+void SerialHeap::post_initialize() {\n+  CollectedHeap::post_initialize();\n+\n+  DefNewGeneration* def_new_gen = (DefNewGeneration*)_young_gen;\n+\n+  def_new_gen->ref_processor_init();\n+\n+  MarkSweep::initialize();\n+\n+  ScavengableNMethods::initialize(&_is_scavengable);\n+}\n+\n+PreGenGCValues SerialHeap::get_pre_gc_values() const {\n+  const DefNewGeneration* const def_new_gen = (DefNewGeneration*) young_gen();\n+\n+  return PreGenGCValues(def_new_gen->used(),\n+                        def_new_gen->capacity(),\n+                        def_new_gen->eden()->used(),\n+                        def_new_gen->eden()->capacity(),\n+                        def_new_gen->from()->used(),\n+                        def_new_gen->from()->capacity(),\n+                        old_gen()->used(),\n+                        old_gen()->capacity());\n+}\n+\n+size_t SerialHeap::capacity() const {\n+  return _young_gen->capacity() + _old_gen->capacity();\n+}\n+\n+size_t SerialHeap::used() const {\n+  return _young_gen->used() + _old_gen->used();\n+}\n+\n+void SerialHeap::save_used_regions() {\n+  _old_gen->save_used_region();\n+  _young_gen->save_used_region();\n+}\n+\n+size_t SerialHeap::max_capacity() const {\n+  return _young_gen->max_capacity() + _old_gen->max_capacity();\n+}\n+\n+\/\/ Return true if any of the following is true:\n+\/\/ . the allocation won't fit into the current young gen heap\n+\/\/ . gc locker is occupied (jni critical section)\n+\/\/ . heap memory is tight -- the most recent previous collection\n+\/\/   was a full collection because a partial collection (would\n+\/\/   have) failed and is likely to fail again\n+bool SerialHeap::should_try_older_generation_allocation(size_t word_size) const {\n+  size_t young_capacity = _young_gen->capacity_before_gc();\n+  return    (word_size > heap_word_size(young_capacity))\n+         || GCLocker::is_active_and_needs_gc()\n+         || incremental_collection_failed();\n+}\n+\n+HeapWord* SerialHeap::expand_heap_and_allocate(size_t size, bool is_tlab) {\n+  HeapWord* result = nullptr;\n+  if (_old_gen->should_allocate(size, is_tlab)) {\n+    result = _old_gen->expand_and_allocate(size, is_tlab);\n+  }\n+  if (result == nullptr) {\n+    if (_young_gen->should_allocate(size, is_tlab)) {\n+      result = _young_gen->expand_and_allocate(size, is_tlab);\n+    }\n+  }\n+  assert(result == nullptr || is_in_reserved(result), \"result not in heap\");\n+  return result;\n+}\n+\n+HeapWord* SerialHeap::mem_allocate_work(size_t size,\n+                                        bool is_tlab) {\n+\n+  HeapWord* result = nullptr;\n+\n+  \/\/ Loop until the allocation is satisfied, or unsatisfied after GC.\n+  for (uint try_count = 1, gclocker_stalled_count = 0; \/* return or throw *\/; try_count += 1) {\n+\n+    \/\/ First allocation attempt is lock-free.\n+    Generation *young = _young_gen;\n+    if (young->should_allocate(size, is_tlab)) {\n+      result = young->par_allocate(size, is_tlab);\n+      if (result != nullptr) {\n+        assert(is_in_reserved(result), \"result not in heap\");\n+        return result;\n+      }\n+    }\n+    uint gc_count_before;  \/\/ Read inside the Heap_lock locked region.\n+    {\n+      MutexLocker ml(Heap_lock);\n+      log_trace(gc, alloc)(\"SerialHeap::mem_allocate_work: attempting locked slow path allocation\");\n+      \/\/ Note that only large objects get a shot at being\n+      \/\/ allocated in later generations.\n+      bool first_only = !should_try_older_generation_allocation(size);\n+\n+      result = attempt_allocation(size, is_tlab, first_only);\n+      if (result != nullptr) {\n+        assert(is_in_reserved(result), \"result not in heap\");\n+        return result;\n+      }\n+\n+      if (GCLocker::is_active_and_needs_gc()) {\n+        if (is_tlab) {\n+          return nullptr;  \/\/ Caller will retry allocating individual object.\n+        }\n+        if (!is_maximal_no_gc()) {\n+          \/\/ Try and expand heap to satisfy request.\n+          result = expand_heap_and_allocate(size, is_tlab);\n+          \/\/ Result could be null if we are out of space.\n+          if (result != nullptr) {\n+            return result;\n+          }\n+        }\n+\n+        if (gclocker_stalled_count > GCLockerRetryAllocationCount) {\n+          return nullptr; \/\/ We didn't get to do a GC and we didn't get any memory.\n+        }\n+\n+        \/\/ If this thread is not in a jni critical section, we stall\n+        \/\/ the requestor until the critical section has cleared and\n+        \/\/ GC allowed. When the critical section clears, a GC is\n+        \/\/ initiated by the last thread exiting the critical section; so\n+        \/\/ we retry the allocation sequence from the beginning of the loop,\n+        \/\/ rather than causing more, now probably unnecessary, GC attempts.\n+        JavaThread* jthr = JavaThread::current();\n+        if (!jthr->in_critical()) {\n+          MutexUnlocker mul(Heap_lock);\n+          \/\/ Wait for JNI critical section to be exited\n+          GCLocker::stall_until_clear();\n+          gclocker_stalled_count += 1;\n+          continue;\n+        } else {\n+          if (CheckJNICalls) {\n+            fatal(\"Possible deadlock due to allocating while\"\n+                  \" in jni critical section\");\n+          }\n+          return nullptr;\n+        }\n+      }\n+\n+      \/\/ Read the gc count while the heap lock is held.\n+      gc_count_before = total_collections();\n+    }\n+\n+    VM_GenCollectForAllocation op(size, is_tlab, gc_count_before);\n+    VMThread::execute(&op);\n+    if (op.prologue_succeeded()) {\n+      result = op.result();\n+      if (op.gc_locked()) {\n+         assert(result == nullptr, \"must be null if gc_locked() is true\");\n+         continue;  \/\/ Retry and\/or stall as necessary.\n+      }\n+\n+      assert(result == nullptr || is_in_reserved(result),\n+             \"result not in heap\");\n+      return result;\n+    }\n+\n+    \/\/ Give a warning if we seem to be looping forever.\n+    if ((QueuedAllocationWarningCount > 0) &&\n+        (try_count % QueuedAllocationWarningCount == 0)) {\n+          log_warning(gc, ergo)(\"SerialHeap::mem_allocate_work retries %d times,\"\n+                                \" size=\" SIZE_FORMAT \" %s\", try_count, size, is_tlab ? \"(TLAB)\" : \"\");\n+    }\n+  }\n+}\n+\n+HeapWord* SerialHeap::attempt_allocation(size_t size,\n+                                         bool is_tlab,\n+                                         bool first_only) {\n+  HeapWord* res = nullptr;\n+\n+  if (_young_gen->should_allocate(size, is_tlab)) {\n+    res = _young_gen->allocate(size, is_tlab);\n+    if (res != nullptr || first_only) {\n+      return res;\n+    }\n+  }\n+\n+  if (_old_gen->should_allocate(size, is_tlab)) {\n+    res = _old_gen->allocate(size, is_tlab);\n+  }\n+\n+  return res;\n+}\n+\n+HeapWord* SerialHeap::mem_allocate(size_t size,\n+                                   bool* gc_overhead_limit_was_exceeded) {\n+  return mem_allocate_work(size,\n+                           false \/* is_tlab *\/);\n+}\n+\n+bool SerialHeap::must_clear_all_soft_refs() {\n+  return _gc_cause == GCCause::_metadata_GC_clear_soft_refs ||\n+         _gc_cause == GCCause::_wb_full_gc;\n+}\n+\n+void SerialHeap::collect_generation(Generation* gen, bool full, size_t size,\n+                                    bool is_tlab, bool run_verification, bool clear_soft_refs) {\n+  FormatBuffer<> title(\"Collect gen: %s\", gen->short_name());\n+  GCTraceTime(Trace, gc, phases) t1(title);\n+  TraceCollectorStats tcs(gen->counters());\n+  TraceMemoryManagerStats tmms(gen->gc_manager(), gc_cause(), heap()->is_young_gen(gen) ? \"end of minor GC\" : \"end of major GC\");\n+\n+  gen->stat_record()->invocations++;\n+  gen->stat_record()->accumulated_time.start();\n+\n+  \/\/ Must be done anew before each collection because\n+  \/\/ a previous collection will do mangling and will\n+  \/\/ change top of some spaces.\n+  record_gen_tops_before_GC();\n+\n+  log_trace(gc)(\"%s invoke=%d size=\" SIZE_FORMAT, heap()->is_young_gen(gen) ? \"Young\" : \"Old\", gen->stat_record()->invocations, size * HeapWordSize);\n+\n+  if (run_verification && VerifyBeforeGC) {\n+    Universe::verify(\"Before GC\");\n+  }\n+  COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::clear());\n+\n+  \/\/ Do collection work\n+  {\n+    save_marks();   \/\/ save marks for all gens\n+\n+    gen->collect(full, clear_soft_refs, size, is_tlab);\n+  }\n+\n+  COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::update_pointers());\n+\n+  gen->stat_record()->accumulated_time.stop();\n+\n+  update_gc_stats(gen, full);\n+\n+  if (run_verification && VerifyAfterGC) {\n+    Universe::verify(\"After GC\");\n+  }\n+}\n+\n+void SerialHeap::do_collection(bool full,\n+                               bool clear_all_soft_refs,\n+                               size_t size,\n+                               bool is_tlab,\n+                               GenerationType max_generation) {\n+  ResourceMark rm;\n+  DEBUG_ONLY(Thread* my_thread = Thread::current();)\n+\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n+  assert(my_thread->is_VM_thread(), \"only VM thread\");\n+  assert(Heap_lock->is_locked(),\n+         \"the requesting thread should have the Heap_lock\");\n+  guarantee(!is_gc_active(), \"collection is not reentrant\");\n+\n+  if (GCLocker::check_active_before_gc()) {\n+    return; \/\/ GC is disabled (e.g. JNI GetXXXCritical operation)\n+  }\n+\n+  const bool do_clear_all_soft_refs = clear_all_soft_refs ||\n+                          soft_ref_policy()->should_clear_all_soft_refs();\n+\n+  ClearedAllSoftRefs casr(do_clear_all_soft_refs, soft_ref_policy());\n+\n+  AutoModifyRestore<bool> temporarily(_is_gc_active, true);\n+\n+  bool complete = full && (max_generation == OldGen);\n+  bool old_collects_young = complete && !ScavengeBeforeFullGC;\n+  bool do_young_collection = !old_collects_young && _young_gen->should_collect(full, size, is_tlab);\n+\n+  const PreGenGCValues pre_gc_values = get_pre_gc_values();\n+\n+  bool run_verification = total_collections() >= VerifyGCStartAt;\n+  bool prepared_for_verification = false;\n+  bool do_full_collection = false;\n+\n+  if (do_young_collection) {\n+    GCIdMark gc_id_mark;\n+    GCTraceCPUTime tcpu(((DefNewGeneration*)_young_gen)->gc_tracer());\n+    GCTraceTime(Info, gc) t(\"Pause Young\", nullptr, gc_cause(), true);\n+\n+    print_heap_before_gc();\n+\n+    if (run_verification && VerifyGCLevel <= 0 && VerifyBeforeGC) {\n+      prepare_for_verify();\n+      prepared_for_verification = true;\n+    }\n+\n+    gc_prologue(complete);\n+    increment_total_collections(complete);\n+\n+    collect_generation(_young_gen,\n+                       full,\n+                       size,\n+                       is_tlab,\n+                       run_verification && VerifyGCLevel <= 0,\n+                       do_clear_all_soft_refs);\n+\n+    if (size > 0 && (!is_tlab || _young_gen->supports_tlab_allocation()) &&\n+        size * HeapWordSize <= _young_gen->unsafe_max_alloc_nogc()) {\n+      \/\/ Allocation request was met by young GC.\n+      size = 0;\n+    }\n+\n+    \/\/ Ask if young collection is enough. If so, do the final steps for young collection,\n+    \/\/ and fallthrough to the end.\n+    do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);\n+    if (!do_full_collection) {\n+      \/\/ Adjust generation sizes.\n+      _young_gen->compute_new_size();\n+\n+      print_heap_change(pre_gc_values);\n+\n+      \/\/ Track memory usage and detect low memory after GC finishes\n+      MemoryService::track_memory_usage();\n+\n+      gc_epilogue(complete);\n+    }\n+\n+    print_heap_after_gc();\n+\n+  } else {\n+    \/\/ No young collection, ask if we need to perform Full collection.\n+    do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);\n+  }\n+\n+  if (do_full_collection) {\n+    GCIdMark gc_id_mark;\n+    GCTraceCPUTime tcpu(GenMarkSweep::gc_tracer());\n+    GCTraceTime(Info, gc) t(\"Pause Full\", nullptr, gc_cause(), true);\n+\n+    print_heap_before_gc();\n+\n+    if (!prepared_for_verification && run_verification &&\n+        VerifyGCLevel <= 1 && VerifyBeforeGC) {\n+      prepare_for_verify();\n+    }\n+\n+    if (!do_young_collection) {\n+      gc_prologue(complete);\n+      increment_total_collections(complete);\n+    }\n+\n+    \/\/ Accounting quirk: total full collections would be incremented when \"complete\"\n+    \/\/ is set, by calling increment_total_collections above. However, we also need to\n+    \/\/ account Full collections that had \"complete\" unset.\n+    if (!complete) {\n+      increment_total_full_collections();\n+    }\n+\n+    CodeCache::on_gc_marking_cycle_start();\n+\n+    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                              false \/* unregister_nmethods_during_purge *\/,\n+                              false \/* lock_codeblob_free_separately *\/);\n+\n+    collect_generation(_old_gen,\n+                       full,\n+                       size,\n+                       is_tlab,\n+                       run_verification && VerifyGCLevel <= 1,\n+                       do_clear_all_soft_refs);\n+\n+    CodeCache::on_gc_marking_cycle_finish();\n+    CodeCache::arm_all_nmethods();\n+\n+    \/\/ Adjust generation sizes.\n+    _old_gen->compute_new_size();\n+    _young_gen->compute_new_size();\n+\n+    \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n+    ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+    DEBUG_ONLY(MetaspaceUtils::verify();)\n+\n+    \/\/ Need to clear claim bits for the next mark.\n+    ClassLoaderDataGraph::clear_claimed_marks();\n+\n+    \/\/ Resize the metaspace capacity after full collections\n+    MetaspaceGC::compute_new_size();\n+\n+    print_heap_change(pre_gc_values);\n+\n+    \/\/ Track memory usage and detect low memory after GC finishes\n+    MemoryService::track_memory_usage();\n+\n+    \/\/ Need to tell the epilogue code we are done with Full GC, regardless what was\n+    \/\/ the initial value for \"complete\" flag.\n+    gc_epilogue(true);\n+\n+    print_heap_after_gc();\n+  }\n+}\n+\n+bool SerialHeap::should_do_full_collection(size_t size, bool full, bool is_tlab,\n+                                           SerialHeap::GenerationType max_gen) const {\n+  return max_gen == OldGen && _old_gen->should_collect(full, size, is_tlab);\n+}\n+\n+void SerialHeap::register_nmethod(nmethod* nm) {\n+  ScavengableNMethods::register_nmethod(nm);\n+}\n+\n+void SerialHeap::unregister_nmethod(nmethod* nm) {\n+  ScavengableNMethods::unregister_nmethod(nm);\n+}\n+\n+void SerialHeap::verify_nmethod(nmethod* nm) {\n+  ScavengableNMethods::verify_nmethod(nm);\n+}\n+\n+void SerialHeap::prune_scavengable_nmethods() {\n+  ScavengableNMethods::prune_nmethods_not_into_young();\n+}\n+\n+void SerialHeap::prune_unlinked_nmethods() {\n+  ScavengableNMethods::prune_unlinked_nmethods();\n+}\n+\n+HeapWord* SerialHeap::satisfy_failed_allocation(size_t size, bool is_tlab) {\n+  GCCauseSetter x(this, GCCause::_allocation_failure);\n+  HeapWord* result = nullptr;\n+\n+  assert(size != 0, \"Precondition violated\");\n+  if (GCLocker::is_active_and_needs_gc()) {\n+    \/\/ GC locker is active; instead of a collection we will attempt\n+    \/\/ to expand the heap, if there's room for expansion.\n+    if (!is_maximal_no_gc()) {\n+      result = expand_heap_and_allocate(size, is_tlab);\n+    }\n+    return result;   \/\/ Could be null if we are out of space.\n+  } else if (!incremental_collection_will_fail(false \/* don't consult_young *\/)) {\n+    \/\/ Do an incremental collection.\n+    do_collection(false,                     \/\/ full\n+                  false,                     \/\/ clear_all_soft_refs\n+                  size,                      \/\/ size\n+                  is_tlab,                   \/\/ is_tlab\n+                  SerialHeap::OldGen); \/\/ max_generation\n+  } else {\n+    log_trace(gc)(\" :: Trying full because partial may fail :: \");\n+    \/\/ Try a full collection; see delta for bug id 6266275\n+    \/\/ for the original code and why this has been simplified\n+    \/\/ with from-space allocation criteria modified and\n+    \/\/ such allocation moved out of the safepoint path.\n+    do_collection(true,                      \/\/ full\n+                  false,                     \/\/ clear_all_soft_refs\n+                  size,                      \/\/ size\n+                  is_tlab,                   \/\/ is_tlab\n+                  SerialHeap::OldGen); \/\/ max_generation\n+  }\n+\n+  result = attempt_allocation(size, is_tlab, false \/*first_only*\/);\n+\n+  if (result != nullptr) {\n+    assert(is_in_reserved(result), \"result not in heap\");\n+    return result;\n+  }\n+\n+  \/\/ OK, collection failed, try expansion.\n+  result = expand_heap_and_allocate(size, is_tlab);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+\n+  \/\/ If we reach this point, we're really out of memory. Try every trick\n+  \/\/ we can to reclaim memory. Force collection of soft references. Force\n+  \/\/ a complete compaction of the heap. Any additional methods for finding\n+  \/\/ free memory should be here, especially if they are expensive. If this\n+  \/\/ attempt fails, an OOM exception will be thrown.\n+  {\n+    UIntFlagSetting flag_change(MarkSweepAlwaysCompactCount, 1); \/\/ Make sure the heap is fully compacted\n+\n+    do_collection(true,                      \/\/ full\n+                  true,                      \/\/ clear_all_soft_refs\n+                  size,                      \/\/ size\n+                  is_tlab,                   \/\/ is_tlab\n+                  SerialHeap::OldGen); \/\/ max_generation\n+  }\n+\n+  result = attempt_allocation(size, is_tlab, false \/* first_only *\/);\n+  if (result != nullptr) {\n+    assert(is_in_reserved(result), \"result not in heap\");\n+    return result;\n+  }\n+\n+  assert(!soft_ref_policy()->should_clear_all_soft_refs(),\n+    \"Flag should have been handled and cleared prior to this point\");\n+\n+  \/\/ What else?  We might try synchronous finalization later.  If the total\n+  \/\/ space available is large enough for the allocation, then a more\n+  \/\/ complete compaction phase than we've tried so far might be\n+  \/\/ appropriate.\n+  return nullptr;\n+}\n+\n+#ifdef ASSERT\n+class AssertNonScavengableClosure: public OopClosure {\n+public:\n+  virtual void do_oop(oop* p) {\n+    assert(!SerialHeap::heap()->is_in_partial_collection(*p),\n+      \"Referent should not be scavengable.\");  }\n+  virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n+};\n+static AssertNonScavengableClosure assert_is_non_scavengable_closure;\n+#endif\n+\n+void SerialHeap::process_roots(ScanningOption so,\n+                               OopClosure* strong_roots,\n+                               CLDClosure* strong_cld_closure,\n+                               CLDClosure* weak_cld_closure,\n+                               CodeBlobToOopClosure* code_roots) {\n+  \/\/ General roots.\n+  assert(code_roots != nullptr, \"code root closure should always be set\");\n+\n+  ClassLoaderDataGraph::roots_cld_do(strong_cld_closure, weak_cld_closure);\n+\n+  \/\/ Only process code roots from thread stacks if we aren't visiting the entire CodeCache anyway\n+  CodeBlobToOopClosure* roots_from_code_p = (so & SO_AllCodeCache) ? nullptr : code_roots;\n+\n+  Threads::oops_do(strong_roots, roots_from_code_p);\n+\n+  OopStorageSet::strong_oops_do(strong_roots);\n+\n+  if (so & SO_ScavengeCodeCache) {\n+    assert(code_roots != nullptr, \"must supply closure for code cache\");\n+\n+    \/\/ We only visit parts of the CodeCache when scavenging.\n+    ScavengableNMethods::nmethods_do(code_roots);\n+  }\n+  if (so & SO_AllCodeCache) {\n+    assert(code_roots != nullptr, \"must supply closure for code cache\");\n+\n+    \/\/ CMSCollector uses this to do intermediate-strength collections.\n+    \/\/ We scan the entire code cache, since CodeCache::do_unloading is not called.\n+    CodeCache::blobs_do(code_roots);\n+  }\n+  \/\/ Verify that the code cache contents are not subject to\n+  \/\/ movement by a scavenging collection.\n+  DEBUG_ONLY(CodeBlobToOopClosure assert_code_is_non_scavengable(&assert_is_non_scavengable_closure, !CodeBlobToOopClosure::FixRelocations));\n+  DEBUG_ONLY(ScavengableNMethods::asserted_non_scavengable_nmethods_do(&assert_code_is_non_scavengable));\n+}\n+\n+bool SerialHeap::no_allocs_since_save_marks() {\n+  return _young_gen->no_allocs_since_save_marks() &&\n+         _old_gen->no_allocs_since_save_marks();\n+}\n+\n+\/\/ public collection interfaces\n+void SerialHeap::collect(GCCause::Cause cause) {\n+  \/\/ The caller doesn't have the Heap_lock\n+  assert(!Heap_lock->owned_by_self(), \"this thread should not own the Heap_lock\");\n+\n+  unsigned int gc_count_before;\n+  unsigned int full_gc_count_before;\n+\n+  {\n+    MutexLocker ml(Heap_lock);\n+    \/\/ Read the GC count while holding the Heap_lock\n+    gc_count_before      = total_collections();\n+    full_gc_count_before = total_full_collections();\n+  }\n+\n+  if (GCLocker::should_discard(cause, gc_count_before)) {\n+    return;\n+  }\n+\n+  bool should_run_young_gc =  (cause == GCCause::_wb_young_gc)\n+                           || (cause == GCCause::_gc_locker)\n+                DEBUG_ONLY(|| (cause == GCCause::_scavenge_alot));\n+\n+  const GenerationType max_generation = should_run_young_gc\n+                                      ? YoungGen\n+                                      : OldGen;\n+\n+  while (true) {\n+    VM_GenCollectFull op(gc_count_before, full_gc_count_before,\n+                         cause, max_generation);\n+    VMThread::execute(&op);\n+\n+    if (!GCCause::is_explicit_full_gc(cause)) {\n+      return;\n+    }\n+\n+    {\n+      MutexLocker ml(Heap_lock);\n+      \/\/ Read the GC count while holding the Heap_lock\n+      if (full_gc_count_before != total_full_collections()) {\n+        return;\n+      }\n+    }\n+\n+    if (GCLocker::is_active_and_needs_gc()) {\n+      \/\/ If GCLocker is active, wait until clear before retrying.\n+      GCLocker::stall_until_clear();\n+    }\n+  }\n+}\n+\n+void SerialHeap::do_full_collection(bool clear_all_soft_refs) {\n+   do_full_collection(clear_all_soft_refs, OldGen);\n+}\n+\n+void SerialHeap::do_full_collection(bool clear_all_soft_refs,\n+                                    GenerationType last_generation) {\n+  do_collection(true,                   \/\/ full\n+                clear_all_soft_refs,    \/\/ clear_all_soft_refs\n+                0,                      \/\/ size\n+                false,                  \/\/ is_tlab\n+                last_generation);       \/\/ last_generation\n+  \/\/ Hack XXX FIX ME !!!\n+  \/\/ A scavenge may not have been attempted, or may have\n+  \/\/ been attempted and failed, because the old gen was too full\n+  if (gc_cause() == GCCause::_gc_locker && incremental_collection_failed()) {\n+    log_debug(gc, jni)(\"GC locker: Trying a full collection because scavenge failed\");\n+    \/\/ This time allow the old gen to be collected as well\n+    do_collection(true,                \/\/ full\n+                  clear_all_soft_refs, \/\/ clear_all_soft_refs\n+                  0,                   \/\/ size\n+                  false,               \/\/ is_tlab\n+                  OldGen);             \/\/ last_generation\n+  }\n+}\n+\n+bool SerialHeap::is_in_young(const void* p) const {\n+  bool result = p < _old_gen->reserved().start();\n+  assert(result == _young_gen->is_in_reserved(p),\n+         \"incorrect test - result=%d, p=\" PTR_FORMAT, result, p2i(p));\n+  return result;\n+}\n+\n+bool SerialHeap::requires_barriers(stackChunkOop obj) const {\n+  return !is_in_young(obj);\n+}\n+\n+\/\/ Returns \"TRUE\" iff \"p\" points into the committed areas of the heap.\n+bool SerialHeap::is_in(const void* p) const {\n+  return _young_gen->is_in(p) || _old_gen->is_in(p);\n+}\n+\n+#ifdef ASSERT\n+\/\/ Don't implement this by using is_in_young().  This method is used\n+\/\/ in some cases to check that is_in_young() is correct.\n+bool SerialHeap::is_in_partial_collection(const void* p) {\n+  assert(is_in_reserved(p) || p == nullptr,\n+    \"Does not work if address is non-null and outside of the heap\");\n+  return p < _young_gen->reserved().end() && p != nullptr;\n+}\n+#endif\n+\n+void SerialHeap::object_iterate(ObjectClosure* cl) {\n+  _young_gen->object_iterate(cl);\n+  _old_gen->object_iterate(cl);\n+}\n+\n+HeapWord* SerialHeap::block_start(const void* addr) const {\n+  assert(is_in_reserved(addr), \"block_start of address outside of heap\");\n+  if (_young_gen->is_in_reserved(addr)) {\n+    assert(_young_gen->is_in(addr), \"addr should be in allocated part of generation\");\n+    return _young_gen->block_start(addr);\n+  }\n+\n+  assert(_old_gen->is_in_reserved(addr), \"Some generation should contain the address\");\n+  assert(_old_gen->is_in(addr), \"addr should be in allocated part of generation\");\n+  return _old_gen->block_start(addr);\n+}\n+\n+bool SerialHeap::block_is_obj(const HeapWord* addr) const {\n+  assert(is_in_reserved(addr), \"block_is_obj of address outside of heap\");\n+  assert(block_start(addr) == addr, \"addr must be a block start\");\n+  if (_young_gen->is_in_reserved(addr)) {\n+    return _young_gen->block_is_obj(addr);\n+  }\n+\n+  assert(_old_gen->is_in_reserved(addr), \"Some generation should contain the address\");\n+  return _old_gen->block_is_obj(addr);\n+}\n+\n+size_t SerialHeap::tlab_capacity(Thread* thr) const {\n+  assert(!_old_gen->supports_tlab_allocation(), \"Old gen supports TLAB allocation?!\");\n+  assert(_young_gen->supports_tlab_allocation(), \"Young gen doesn't support TLAB allocation?!\");\n+  return _young_gen->tlab_capacity();\n+}\n+\n+size_t SerialHeap::tlab_used(Thread* thr) const {\n+  assert(!_old_gen->supports_tlab_allocation(), \"Old gen supports TLAB allocation?!\");\n+  assert(_young_gen->supports_tlab_allocation(), \"Young gen doesn't support TLAB allocation?!\");\n+  return _young_gen->tlab_used();\n+}\n+\n+size_t SerialHeap::unsafe_max_tlab_alloc(Thread* thr) const {\n+  assert(!_old_gen->supports_tlab_allocation(), \"Old gen supports TLAB allocation?!\");\n+  assert(_young_gen->supports_tlab_allocation(), \"Young gen doesn't support TLAB allocation?!\");\n+  return _young_gen->unsafe_max_tlab_alloc();\n+}\n+\n+HeapWord* SerialHeap::allocate_new_tlab(size_t min_size,\n+                                        size_t requested_size,\n+                                        size_t* actual_size) {\n+  HeapWord* result = mem_allocate_work(requested_size \/* size *\/,\n+                                       true \/* is_tlab *\/);\n+  if (result != nullptr) {\n+    *actual_size = requested_size;\n+  }\n+\n+  return result;\n+}\n+\n+void SerialHeap::prepare_for_verify() {\n+  ensure_parsability(false);        \/\/ no need to retire TLABs\n+}\n+\n+void SerialHeap::generation_iterate(GenClosure* cl,\n+                                    bool old_to_young) {\n+  if (old_to_young) {\n+    cl->do_generation(_old_gen);\n+    cl->do_generation(_young_gen);\n+  } else {\n+    cl->do_generation(_young_gen);\n+    cl->do_generation(_old_gen);\n+  }\n+}\n+\n+bool SerialHeap::is_maximal_no_gc() const {\n+  return _young_gen->is_maximal_no_gc() && _old_gen->is_maximal_no_gc();\n+}\n+\n+void SerialHeap::save_marks() {\n+  _young_gen->save_marks();\n+  _old_gen->save_marks();\n+}\n+\n+void SerialHeap::verify(VerifyOption option \/* ignored *\/) {\n+  log_debug(gc, verify)(\"%s\", _old_gen->name());\n+  _old_gen->verify();\n+\n+  log_debug(gc, verify)(\"%s\", _young_gen->name());\n+  _young_gen->verify();\n+\n+  log_debug(gc, verify)(\"RemSet\");\n+  rem_set()->verify();\n+}\n+\n+void SerialHeap::print_on(outputStream* st) const {\n+  if (_young_gen != nullptr) {\n+    _young_gen->print_on(st);\n+  }\n+  if (_old_gen != nullptr) {\n+    _old_gen->print_on(st);\n+  }\n+  MetaspaceUtils::print_on(st);\n+}\n+\n+void SerialHeap::gc_threads_do(ThreadClosure* tc) const {\n+}\n+\n+bool SerialHeap::print_location(outputStream* st, void* addr) const {\n+  return BlockLocationPrinter<SerialHeap>::print_location(st, addr);\n+}\n+\n+void SerialHeap::print_tracing_info() const {\n+  if (log_is_enabled(Debug, gc, heap, exit)) {\n+    LogStreamHandle(Debug, gc, heap, exit) lsh;\n+    _young_gen->print_summary_info_on(&lsh);\n+    _old_gen->print_summary_info_on(&lsh);\n+  }\n+}\n+\n+void SerialHeap::print_heap_change(const PreGenGCValues& pre_gc_values) const {\n+  const DefNewGeneration* const def_new_gen = (DefNewGeneration*) young_gen();\n+\n+  log_info(gc, heap)(HEAP_CHANGE_FORMAT\" \"\n+                     HEAP_CHANGE_FORMAT\" \"\n+                     HEAP_CHANGE_FORMAT,\n+                     HEAP_CHANGE_FORMAT_ARGS(def_new_gen->short_name(),\n+                                             pre_gc_values.young_gen_used(),\n+                                             pre_gc_values.young_gen_capacity(),\n+                                             def_new_gen->used(),\n+                                             def_new_gen->capacity()),\n+                     HEAP_CHANGE_FORMAT_ARGS(\"Eden\",\n+                                             pre_gc_values.eden_used(),\n+                                             pre_gc_values.eden_capacity(),\n+                                             def_new_gen->eden()->used(),\n+                                             def_new_gen->eden()->capacity()),\n+                     HEAP_CHANGE_FORMAT_ARGS(\"From\",\n+                                             pre_gc_values.from_used(),\n+                                             pre_gc_values.from_capacity(),\n+                                             def_new_gen->from()->used(),\n+                                             def_new_gen->from()->capacity()));\n+  log_info(gc, heap)(HEAP_CHANGE_FORMAT,\n+                     HEAP_CHANGE_FORMAT_ARGS(old_gen()->short_name(),\n+                                             pre_gc_values.old_gen_used(),\n+                                             pre_gc_values.old_gen_capacity(),\n+                                             old_gen()->used(),\n+                                             old_gen()->capacity()));\n+  MetaspaceUtils::print_metaspace_change(pre_gc_values.metaspace_sizes());\n+}\n+\n+class GenGCPrologueClosure: public SerialHeap::GenClosure {\n+ private:\n+  bool _full;\n+ public:\n+  void do_generation(Generation* gen) {\n+    gen->gc_prologue(_full);\n+  }\n+  GenGCPrologueClosure(bool full) : _full(full) {};\n+};\n+\n+void SerialHeap::gc_prologue(bool full) {\n+  assert(InlineCacheBuffer::is_empty(), \"should have cleaned up ICBuffer\");\n+\n+  \/\/ Fill TLAB's and such\n+  ensure_parsability(true);   \/\/ retire TLABs\n+\n+  \/\/ Walk generations\n+  GenGCPrologueClosure blk(full);\n+  generation_iterate(&blk, false);  \/\/ not old-to-young.\n+};\n+\n+class GenGCEpilogueClosure: public SerialHeap::GenClosure {\n+ private:\n+  bool _full;\n+ public:\n+  void do_generation(Generation* gen) {\n+    gen->gc_epilogue(_full);\n+  }\n+  GenGCEpilogueClosure(bool full) : _full(full) {};\n+};\n+\n+void SerialHeap::gc_epilogue(bool full) {\n+#if COMPILER2_OR_JVMCI\n+  assert(DerivedPointerTable::is_empty(), \"derived pointer present\");\n+#endif \/\/ COMPILER2_OR_JVMCI\n+\n+  resize_all_tlabs();\n+\n+  GenGCEpilogueClosure blk(full);\n+  generation_iterate(&blk, false);  \/\/ not old-to-young.\n+\n+  MetaspaceCounters::update_performance_counters();\n+};\n+\n+#ifndef PRODUCT\n+class GenGCSaveTopsBeforeGCClosure: public SerialHeap::GenClosure {\n+ private:\n+ public:\n+  void do_generation(Generation* gen) {\n+    gen->record_spaces_top();\n+  }\n+};\n+\n+void SerialHeap::record_gen_tops_before_GC() {\n+  if (ZapUnusedHeapArea) {\n+    GenGCSaveTopsBeforeGCClosure blk;\n+    generation_iterate(&blk, false);  \/\/ not old-to-young.\n+  }\n+}\n+#endif  \/\/ not PRODUCT\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":986,"deletions":7,"binary":false,"changes":993,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -30,1 +31,4 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"gc\/shared\/oopStorageParState.hpp\"\n+#include \"gc\/shared\/preGCValues.hpp\"\n+#include \"gc\/shared\/softRefPolicy.hpp\"\n@@ -33,0 +37,3 @@\n+class CardTableRS;\n+class GCPolicyCounters;\n+\n@@ -58,1 +65,278 @@\n-class SerialHeap : public GenCollectedHeap {\n+class SerialHeap : public CollectedHeap {\n+  friend class Generation;\n+  friend class DefNewGeneration;\n+  friend class TenuredGeneration;\n+  friend class GenMarkSweep;\n+  friend class VM_GenCollectForAllocation;\n+  friend class VM_GenCollectFull;\n+  friend class VM_GC_HeapInspection;\n+  friend class VM_HeapDumper;\n+  friend class HeapInspection;\n+  friend class GCCauseSetter;\n+  friend class VMStructs;\n+public:\n+  friend class VM_PopulateDumpSharedSpace;\n+\n+  enum GenerationType {\n+    YoungGen,\n+    OldGen\n+  };\n+\n+private:\n+  DefNewGeneration* _young_gen;\n+  TenuredGeneration* _old_gen;\n+\n+private:\n+  \/\/ The singleton CardTable Remembered Set.\n+  CardTableRS* _rem_set;\n+\n+  SoftRefPolicy _soft_ref_policy;\n+\n+  GCPolicyCounters* _gc_policy_counters;\n+\n+  \/\/ Indicates that the most recent previous incremental collection failed.\n+  \/\/ The flag is cleared when an action is taken that might clear the\n+  \/\/ condition that caused that incremental collection to fail.\n+  bool _incremental_collection_failed;\n+\n+  \/\/ Collects the given generation.\n+  void collect_generation(Generation* gen, bool full, size_t size, bool is_tlab,\n+                          bool run_verification, bool clear_soft_refs);\n+\n+  \/\/ Reserve aligned space for the heap as needed by the contained generations.\n+  ReservedHeapSpace allocate(size_t alignment);\n+\n+  PreGenGCValues get_pre_gc_values() const;\n+\n+private:\n+  GCMemoryManager* _young_manager;\n+  GCMemoryManager* _old_manager;\n+\n+  \/\/ Helper functions for allocation\n+  HeapWord* attempt_allocation(size_t size,\n+                               bool   is_tlab,\n+                               bool   first_only);\n+\n+  \/\/ Helper function for two callbacks below.\n+  \/\/ Considers collection of the first max_level+1 generations.\n+  void do_collection(bool           full,\n+                     bool           clear_all_soft_refs,\n+                     size_t         size,\n+                     bool           is_tlab,\n+                     GenerationType max_generation);\n+\n+  \/\/ Callback from VM_GenCollectForAllocation operation.\n+  \/\/ This function does everything necessary\/possible to satisfy an\n+  \/\/ allocation request that failed in the youngest generation that should\n+  \/\/ have handled it (including collection, expansion, etc.)\n+  HeapWord* satisfy_failed_allocation(size_t size, bool is_tlab);\n+\n+  \/\/ Callback from VM_GenCollectFull operation.\n+  \/\/ Perform a full collection of the first max_level+1 generations.\n+  void do_full_collection(bool clear_all_soft_refs) override;\n+  void do_full_collection(bool clear_all_soft_refs, GenerationType max_generation);\n+\n+  \/\/ Does the \"cause\" of GC indicate that\n+  \/\/ we absolutely __must__ clear soft refs?\n+  bool must_clear_all_soft_refs();\n+\n+public:\n+  \/\/ Returns JNI_OK on success\n+  jint initialize() override;\n+  virtual CardTableRS* create_rem_set(const MemRegion& reserved_region);\n+\n+  \/\/ Does operations required after initialization has been done.\n+  void post_initialize() override;\n+\n+  bool is_young_gen(const Generation* gen) const { return gen == _young_gen; }\n+  bool is_old_gen(const Generation* gen) const { return gen == _old_gen; }\n+\n+  MemRegion reserved_region() const { return _reserved; }\n+  bool is_in_reserved(const void* addr) const { return _reserved.contains(addr); }\n+\n+  SoftRefPolicy* soft_ref_policy() override { return &_soft_ref_policy; }\n+\n+  \/\/ Performance Counter support\n+  GCPolicyCounters* counters()     { return _gc_policy_counters; }\n+\n+  size_t capacity() const override;\n+  size_t used() const override;\n+\n+  \/\/ Save the \"used_region\" for both generations.\n+  void save_used_regions();\n+\n+  size_t max_capacity() const override;\n+\n+  HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded) override;\n+\n+  \/\/ Perform a full collection of the heap; intended for use in implementing\n+  \/\/ \"System.gc\". This implies as full a collection as the CollectedHeap\n+  \/\/ supports. Caller does not hold the Heap_lock on entry.\n+  void collect(GCCause::Cause cause) override;\n+\n+  \/\/ Returns \"TRUE\" iff \"p\" points into the committed areas of the heap.\n+  \/\/ The methods is_in() and is_in_youngest() may be expensive to compute\n+  \/\/ in general, so, to prevent their inadvertent use in product jvm's, we\n+  \/\/ restrict their use to assertion checking or verification only.\n+  bool is_in(const void* p) const override;\n+\n+  \/\/ Returns true if p points into the reserved space for the young generation.\n+  \/\/ Assumes the young gen address range is less than that of the old gen.\n+  bool is_in_young(const void* p) const;\n+\n+  bool requires_barriers(stackChunkOop obj) const override;\n+\n+#ifdef ASSERT\n+  bool is_in_partial_collection(const void* p);\n+#endif\n+\n+  \/\/ Optimized nmethod scanning support routines\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nm) override;\n+\n+  void prune_scavengable_nmethods();\n+  void prune_unlinked_nmethods();\n+\n+  \/\/ Iteration functions.\n+  void object_iterate(ObjectClosure* cl) override;\n+\n+  \/\/ A CollectedHeap is divided into a dense sequence of \"blocks\"; that is,\n+  \/\/ each address in the (reserved) heap is a member of exactly\n+  \/\/ one block.  The defining characteristic of a block is that it is\n+  \/\/ possible to find its size, and thus to progress forward to the next\n+  \/\/ block.  (Blocks may be of different sizes.)  Thus, blocks may\n+  \/\/ represent Java objects, or they might be free blocks in a\n+  \/\/ free-list-based heap (or subheap), as long as the two kinds are\n+  \/\/ distinguishable and the size of each is determinable.\n+\n+  \/\/ Returns the address of the start of the \"block\" that contains the\n+  \/\/ address \"addr\".  We say \"blocks\" instead of \"object\" since some heaps\n+  \/\/ may not pack objects densely; a chunk may either be an object or a\n+  \/\/ non-object.\n+  HeapWord* block_start(const void* addr) const;\n+\n+  \/\/ Requires \"addr\" to be the start of a block, and returns \"TRUE\" iff\n+  \/\/ the block is an object. Assumes (and verifies in non-product\n+  \/\/ builds) that addr is in the allocated part of the heap and is\n+  \/\/ the start of a chunk.\n+  bool block_is_obj(const HeapWord* addr) const;\n+\n+  \/\/ Section on TLAB's.\n+  size_t tlab_capacity(Thread* thr) const override;\n+  size_t tlab_used(Thread* thr) const override;\n+  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n+  HeapWord* allocate_new_tlab(size_t min_size,\n+                              size_t requested_size,\n+                              size_t* actual_size) override;\n+\n+  \/\/ Update the gc statistics for each generation.\n+  void update_gc_stats(Generation* current_generation, bool full) {\n+    _old_gen->update_gc_stats(current_generation, full);\n+  }\n+\n+  void prepare_for_verify() override;\n+  void verify(VerifyOption option) override;\n+\n+  void print_on(outputStream* st) const override;\n+  void gc_threads_do(ThreadClosure* tc) const override;\n+  void print_tracing_info() const override;\n+\n+  \/\/ Used to print information about locations in the hs_err file.\n+  bool print_location(outputStream* st, void* addr) const override;\n+\n+  void print_heap_change(const PreGenGCValues& pre_gc_values) const;\n+\n+  \/\/ The functions below are helper functions that a subclass of\n+  \/\/ \"CollectedHeap\" can use in the implementation of its virtual\n+  \/\/ functions.\n+\n+  class GenClosure : public StackObj {\n+   public:\n+    virtual void do_generation(Generation* gen) = 0;\n+  };\n+\n+  \/\/ Apply \"cl.do_generation\" to all generations in the heap\n+  \/\/ If \"old_to_young\" determines the order.\n+  void generation_iterate(GenClosure* cl, bool old_to_young);\n+\n+  \/\/ Return \"true\" if all generations have reached the\n+  \/\/ maximal committed limit that they can reach, without a garbage\n+  \/\/ collection.\n+  virtual bool is_maximal_no_gc() const override;\n+\n+  \/\/ This function returns the CardTableRS object that allows us to scan\n+  \/\/ generations in a fully generational heap.\n+  CardTableRS* rem_set() { return _rem_set; }\n+\n+  \/\/ The ScanningOption determines which of the roots\n+  \/\/ the closure is applied to:\n+  \/\/ \"SO_None\" does none;\n+  enum ScanningOption {\n+    SO_None                =  0x0,\n+    SO_AllCodeCache        =  0x8,\n+    SO_ScavengeCodeCache   = 0x10\n+  };\n+\n+ protected:\n+  virtual void gc_prologue(bool full);\n+  virtual void gc_epilogue(bool full);\n+\n+ public:\n+  \/\/ Apply closures on various roots in Young GC or marking\/adjust phases of Full GC.\n+  void process_roots(ScanningOption so,\n+                     OopClosure* strong_roots,\n+                     CLDClosure* strong_cld_closure,\n+                     CLDClosure* weak_cld_closure,\n+                     CodeBlobToOopClosure* code_roots);\n+\n+  \/\/ Set the saved marks of generations, if that makes sense.\n+  \/\/ In particular, if any generation might iterate over the oops\n+  \/\/ in other generations, it should call this method.\n+  void save_marks();\n+\n+  \/\/ Returns \"true\" iff no allocations have occurred since the last\n+  \/\/ call to \"save_marks\".\n+  bool no_allocs_since_save_marks();\n+\n+  \/\/ Returns true if an incremental collection is likely to fail.\n+  \/\/ We optionally consult the young gen, if asked to do so;\n+  \/\/ otherwise we base our answer on whether the previous incremental\n+  \/\/ collection attempt failed with no corrective action as of yet.\n+  bool incremental_collection_will_fail(bool consult_young) {\n+    \/\/ The first disjunct remembers if an incremental collection failed, even\n+    \/\/ when we thought (second disjunct) that it would not.\n+    return incremental_collection_failed() ||\n+           (consult_young && !_young_gen->collection_attempt_is_safe());\n+  }\n+\n+  \/\/ If a generation bails out of an incremental collection,\n+  \/\/ it sets this flag.\n+  bool incremental_collection_failed() const {\n+    return _incremental_collection_failed;\n+  }\n+  void set_incremental_collection_failed() {\n+    _incremental_collection_failed = true;\n+  }\n+  void clear_incremental_collection_failed() {\n+    _incremental_collection_failed = false;\n+  }\n+\n+private:\n+  \/\/ Return true if an allocation should be attempted in the older generation\n+  \/\/ if it fails in the younger generation.  Return false, otherwise.\n+  bool should_try_older_generation_allocation(size_t word_size) const;\n+\n+  \/\/ Try to allocate space by expanding the heap.\n+  HeapWord* expand_heap_and_allocate(size_t size, bool is_tlab);\n+\n+  HeapWord* mem_allocate_work(size_t size,\n+                              bool is_tlab);\n+\n+  \/\/ Save the tops of the spaces in all generations\n+  void record_gen_tops_before_GC() PRODUCT_RETURN;\n+\n+  \/\/ Return true if we need to perform full collection.\n+  bool should_do_full_collection(size_t size, bool full,\n+                                 bool is_tlab, GenerationType max_gen) const;\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":287,"deletions":3,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"gc\/serial\/defNewGeneration.hpp\"\n@@ -27,1 +28,1 @@\n-#include \"gc\/shared\/genMemoryPools.hpp\"\n+#include \"gc\/serial\/serialMemoryPools.hpp\"\n@@ -29,3 +30,0 @@\n-#if INCLUDE_SERIALGC\n-#include \"gc\/serial\/defNewGeneration.hpp\"\n-#endif\n@@ -53,2 +51,0 @@\n-#if INCLUDE_SERIALGC\n-\n@@ -79,2 +75,0 @@\n-#endif \/\/ INCLUDE_SERIALGC\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialMemoryPools.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"previous_filename":"src\/hotspot\/share\/gc\/shared\/genMemoryPools.cpp","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n-#ifndef SHARE_GC_SHARED_GENMEMORYPOOLS_HPP\n-#define SHARE_GC_SHARED_GENMEMORYPOOLS_HPP\n+#ifndef SHARE_GC_SERIAL_SERIALMEMORYPOOLS_HPP\n+#define SHARE_GC_SERIAL_SERIALMEMORYPOOLS_HPP\n@@ -75,1 +75,1 @@\n-#endif \/\/ SHARE_GC_SHARED_GENMEMORYPOOLS_HPP\n+#endif \/\/ SHARE_GC_SERIAL_SERIALMEMORYPOOLS_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/serialMemoryPools.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/hotspot\/share\/gc\/shared\/genMemoryPools.hpp","status":"renamed"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/serial\/serialVMOperations.hpp\"\n+#include \"gc\/shared\/gcLocker.hpp\"\n+\n+void VM_GenCollectForAllocation::doit() {\n+  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n+\n+  SerialHeap* gch = SerialHeap::heap();\n+  GCCauseSetter gccs(gch, _gc_cause);\n+  _result = gch->satisfy_failed_allocation(_word_size, _tlab);\n+  assert(_result == nullptr || gch->is_in_reserved(_result), \"result not in heap\");\n+\n+  if (_result == nullptr && GCLocker::is_active_and_needs_gc()) {\n+    set_gc_locked();\n+  }\n+}\n+\n+void VM_GenCollectFull::doit() {\n+  SvcGCMarker sgcm(SvcGCMarker::FULL);\n+\n+  SerialHeap* gch = SerialHeap::heap();\n+  GCCauseSetter gccs(gch, _gc_cause);\n+  gch->do_full_collection(gch->must_clear_all_soft_refs(), _max_generation);\n+}\n","filename":"src\/hotspot\/share\/gc\/serial\/serialVMOperations.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SERIAL_SERIALVMOPERATIONS_HPP\n+#define SHARE_GC_SERIAL_SERIALVMOPERATIONS_HPP\n+\n+#include \"gc\/serial\/serialHeap.hpp\"\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+\n+class VM_GenCollectForAllocation : public VM_CollectForAllocation {\n+ private:\n+  bool        _tlab;                       \/\/ alloc is of a tlab.\n+ public:\n+  VM_GenCollectForAllocation(size_t word_size,\n+                             bool tlab,\n+                             uint gc_count_before)\n+    : VM_CollectForAllocation(word_size, gc_count_before, GCCause::_allocation_failure),\n+      _tlab(tlab) {\n+    assert(word_size != 0, \"An allocation should always be requested with this operation.\");\n+  }\n+  ~VM_GenCollectForAllocation()  {}\n+  virtual VMOp_Type type() const { return VMOp_GenCollectForAllocation; }\n+  virtual void doit();\n+};\n+\n+\/\/ VM operation to invoke a collection of the heap as a\n+\/\/ SerialHeap heap.\n+class VM_GenCollectFull: public VM_GC_Operation {\n+ private:\n+  SerialHeap::GenerationType _max_generation;\n+ public:\n+  VM_GenCollectFull(uint gc_count_before,\n+                    uint full_gc_count_before,\n+                    GCCause::Cause gc_cause,\n+                    SerialHeap::GenerationType max_generation)\n+    : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before,\n+                      max_generation != SerialHeap::YoungGen \/* full *\/),\n+      _max_generation(max_generation) { }\n+  ~VM_GenCollectFull() {}\n+  virtual VMOp_Type type() const { return VMOp_GenCollectFull; }\n+  virtual void doit();\n+};\n+\n+\n+#endif \/\/ SHARE_GC_SERIAL_SERIALVMOPERATIONS_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/serialVMOperations.hpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -104,2 +104,0 @@\n-  ContiguousSpace* first_compaction_space() const;\n-\n@@ -161,1 +159,5 @@\n-  virtual bool promotion_attempt_is_safe(size_t max_promoted_in_bytes) const;\n+  \/\/ Returns true if promotions of the specified amount are\n+  \/\/ likely to succeed without a promotion failure.\n+  \/\/ Promotion of the full amount is not guaranteed but\n+  \/\/ might be attempted in the worst case.\n+  bool promotion_attempt_is_safe(size_t max_promoted_in_bytes) const;\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,4 +52,0 @@\n-inline ContiguousSpace* TenuredGeneration::first_compaction_space() const {\n-  return space();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-  nonstatic_field(DefNewGeneration,                  _old_gen,               Generation*)                   \\\n+  nonstatic_field(DefNewGeneration,                  _old_gen,               TenuredGeneration*)            \\\n@@ -56,1 +56,4 @@\n-  nonstatic_field(TenuredSpace,                      _offsets,               SerialBlockOffsetTable)\n+  nonstatic_field(TenuredSpace,                      _offsets,               SerialBlockOffsetTable)        \\\n+                                                                                                            \\\n+  nonstatic_field(SerialHeap,                        _young_gen,             DefNewGeneration*)             \\\n+  nonstatic_field(SerialHeap,                        _old_gen,               TenuredGeneration*)            \\\n@@ -61,1 +64,1 @@\n-  declare_type(SerialHeap,                   GenCollectedHeap)                \\\n+  declare_type(SerialHeap,                   CollectedHeap)                   \\\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,6 +51,0 @@\n-    decrease_old_gen_for_throughput_true = -7,\n-    decrease_young_gen_for_througput_true = -6,\n-\n-    increase_young_gen_for_min_pauses_true = -2,\n-    increase_old_gen_for_maj_pauses_true = -1,\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -281,0 +281,3 @@\n+  \/\/ Estimated size of the node barrier in number of C2 Ideal nodes.\n+  \/\/ This is used to guide heuristics in C2, e.g. whether to unroll a loop.\n+  virtual uint estimated_barrier_size(const Node* node) const { return 0; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-\/\/     GenCollectedHeap(DefNew,Tenured) and\n+\/\/     SerialHeap(DefNew,Tenured) and\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,2 +87,1 @@\n-\/\/   GenCollectedHeap\n-\/\/     SerialHeap\n+\/\/   SerialHeap\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n+#include \"gc\/shared\/softRefPolicy.hpp\"\n@@ -197,22 +197,0 @@\n-\n-void VM_GenCollectForAllocation::doit() {\n-  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n-\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-  GCCauseSetter gccs(gch, _gc_cause);\n-  _result = gch->satisfy_failed_allocation(_word_size, _tlab);\n-  assert(_result == nullptr || gch->is_in_reserved(_result), \"result not in heap\");\n-\n-  if (_result == nullptr && GCLocker::is_active_and_needs_gc()) {\n-    set_gc_locked();\n-  }\n-}\n-\n-void VM_GenCollectFull::doit() {\n-  SvcGCMarker sgcm(SvcGCMarker::FULL);\n-\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-  GCCauseSetter gccs(gch, _gc_cause);\n-  gch->do_full_collection(gch->must_clear_all_soft_refs(), _max_generation);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":2,"deletions":24,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n+#include \"gc\/shared\/collectorCounters.hpp\"\n@@ -195,34 +195,0 @@\n-class VM_GenCollectForAllocation : public VM_CollectForAllocation {\n- private:\n-  bool        _tlab;                       \/\/ alloc is of a tlab.\n- public:\n-  VM_GenCollectForAllocation(size_t word_size,\n-                             bool tlab,\n-                             uint gc_count_before)\n-    : VM_CollectForAllocation(word_size, gc_count_before, GCCause::_allocation_failure),\n-      _tlab(tlab) {\n-    assert(word_size != 0, \"An allocation should always be requested with this operation.\");\n-  }\n-  ~VM_GenCollectForAllocation()  {}\n-  virtual VMOp_Type type() const { return VMOp_GenCollectForAllocation; }\n-  virtual void doit();\n-};\n-\n-\/\/ VM operation to invoke a collection of the heap as a\n-\/\/ GenCollectedHeap heap.\n-class VM_GenCollectFull: public VM_GC_Operation {\n- private:\n-  GenCollectedHeap::GenerationType _max_generation;\n- public:\n-  VM_GenCollectFull(uint gc_count_before,\n-                    uint full_gc_count_before,\n-                    GCCause::Cause gc_cause,\n-                    GenCollectedHeap::GenerationType max_generation)\n-    : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before,\n-                      max_generation != GenCollectedHeap::YoungGen \/* full *\/),\n-      _max_generation(max_generation) { }\n-  ~VM_GenCollectFull() {}\n-  virtual VMOp_Type type() const { return VMOp_GenCollectFull; }\n-  virtual void doit();\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":2,"deletions":36,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1,1035 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"classfile\/stringTable.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"code\/icBuffer.hpp\"\n-#include \"compiler\/oopMap.hpp\"\n-#include \"gc\/serial\/cardTableRS.hpp\"\n-#include \"gc\/serial\/defNewGeneration.hpp\"\n-#include \"gc\/serial\/genMarkSweep.hpp\"\n-#include \"gc\/serial\/markSweep.hpp\"\n-#include \"gc\/serial\/tenuredGeneration.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"gc\/shared\/classUnloadingContext.hpp\"\n-#include \"gc\/shared\/collectedHeap.inline.hpp\"\n-#include \"gc\/shared\/collectorCounters.hpp\"\n-#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n-#include \"gc\/shared\/gcId.hpp\"\n-#include \"gc\/shared\/gcInitLogger.hpp\"\n-#include \"gc\/shared\/gcLocker.hpp\"\n-#include \"gc\/shared\/gcPolicyCounters.hpp\"\n-#include \"gc\/shared\/gcTrace.hpp\"\n-#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n-#include \"gc\/shared\/gcVMOperations.hpp\"\n-#include \"gc\/shared\/genArguments.hpp\"\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n-#include \"gc\/shared\/locationPrinter.inline.hpp\"\n-#include \"gc\/shared\/oopStorage.inline.hpp\"\n-#include \"gc\/shared\/oopStorageParState.inline.hpp\"\n-#include \"gc\/shared\/oopStorageSet.inline.hpp\"\n-#include \"gc\/shared\/scavengableNMethods.hpp\"\n-#include \"gc\/shared\/space.hpp\"\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n-#include \"gc\/shared\/weakProcessor.hpp\"\n-#include \"gc\/shared\/workerThread.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"memory\/metaspaceCounters.hpp\"\n-#include \"memory\/metaspaceUtils.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/handles.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/threads.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n-#include \"services\/memoryService.hpp\"\n-#include \"utilities\/autoRestore.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/formatBuffer.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#include \"utilities\/stack.inline.hpp\"\n-#include \"utilities\/vmError.hpp\"\n-#if INCLUDE_JVMCI\n-#include \"jvmci\/jvmci.hpp\"\n-#endif\n-\n-GenCollectedHeap::GenCollectedHeap(Generation::Name young,\n-                                   Generation::Name old,\n-                                   const char* policy_counters_name) :\n-  CollectedHeap(),\n-  _young_gen(nullptr),\n-  _old_gen(nullptr),\n-  _rem_set(nullptr),\n-  _soft_ref_policy(),\n-  _gc_policy_counters(new GCPolicyCounters(policy_counters_name, 2, 2)),\n-  _incremental_collection_failed(false),\n-  _full_collections_completed(0),\n-  _young_manager(nullptr),\n-  _old_manager(nullptr) {\n-}\n-\n-jint GenCollectedHeap::initialize() {\n-  \/\/ Allocate space for the heap.\n-\n-  ReservedHeapSpace heap_rs = allocate(HeapAlignment);\n-\n-  if (!heap_rs.is_reserved()) {\n-    vm_shutdown_during_initialization(\n-      \"Could not reserve enough space for object heap\");\n-    return JNI_ENOMEM;\n-  }\n-\n-  initialize_reserved_region(heap_rs);\n-\n-  ReservedSpace young_rs = heap_rs.first_part(MaxNewSize);\n-  ReservedSpace old_rs = heap_rs.last_part(MaxNewSize);\n-\n-  _rem_set = create_rem_set(heap_rs.region());\n-  _rem_set->initialize(young_rs.base(), old_rs.base());\n-\n-  CardTableBarrierSet *bs = new CardTableBarrierSet(_rem_set);\n-  bs->initialize();\n-  BarrierSet::set_barrier_set(bs);\n-\n-  _young_gen = new DefNewGeneration(young_rs, NewSize, MinNewSize, MaxNewSize);\n-  _old_gen = new TenuredGeneration(old_rs, OldSize, MinOldSize, MaxOldSize, rem_set());\n-\n-  GCInitLogger::print();\n-\n-  return JNI_OK;\n-}\n-\n-CardTableRS* GenCollectedHeap::create_rem_set(const MemRegion& reserved_region) {\n-  return new CardTableRS(reserved_region);\n-}\n-\n-ReservedHeapSpace GenCollectedHeap::allocate(size_t alignment) {\n-  \/\/ Now figure out the total size.\n-  const size_t pageSize = UseLargePages ? os::large_page_size() : os::vm_page_size();\n-  assert(alignment % pageSize == 0, \"Must be\");\n-\n-  \/\/ Check for overflow.\n-  size_t total_reserved = MaxNewSize + MaxOldSize;\n-  if (total_reserved < MaxNewSize) {\n-    vm_exit_during_initialization(\"The size of the object heap + VM data exceeds \"\n-                                  \"the maximum representable size\");\n-  }\n-  assert(total_reserved % alignment == 0,\n-         \"Gen size; total_reserved=\" SIZE_FORMAT \", alignment=\"\n-         SIZE_FORMAT, total_reserved, alignment);\n-\n-  ReservedHeapSpace heap_rs = Universe::reserve_heap(total_reserved, alignment);\n-  size_t used_page_size = heap_rs.page_size();\n-\n-  os::trace_page_sizes(\"Heap\",\n-                       MinHeapSize,\n-                       total_reserved,\n-                       heap_rs.base(),\n-                       heap_rs.size(),\n-                       used_page_size);\n-\n-  return heap_rs;\n-}\n-\n-class GenIsScavengable : public BoolObjectClosure {\n-public:\n-  bool do_object_b(oop obj) {\n-    return GenCollectedHeap::heap()->is_in_young(obj);\n-  }\n-};\n-\n-static GenIsScavengable _is_scavengable;\n-\n-void GenCollectedHeap::post_initialize() {\n-  CollectedHeap::post_initialize();\n-\n-  DefNewGeneration* def_new_gen = (DefNewGeneration*)_young_gen;\n-\n-  def_new_gen->ref_processor_init();\n-\n-  MarkSweep::initialize();\n-\n-  ScavengableNMethods::initialize(&_is_scavengable);\n-}\n-\n-PreGenGCValues GenCollectedHeap::get_pre_gc_values() const {\n-  const DefNewGeneration* const def_new_gen = (DefNewGeneration*) young_gen();\n-\n-  return PreGenGCValues(def_new_gen->used(),\n-                        def_new_gen->capacity(),\n-                        def_new_gen->eden()->used(),\n-                        def_new_gen->eden()->capacity(),\n-                        def_new_gen->from()->used(),\n-                        def_new_gen->from()->capacity(),\n-                        old_gen()->used(),\n-                        old_gen()->capacity());\n-}\n-\n-size_t GenCollectedHeap::capacity() const {\n-  return _young_gen->capacity() + _old_gen->capacity();\n-}\n-\n-size_t GenCollectedHeap::used() const {\n-  return _young_gen->used() + _old_gen->used();\n-}\n-\n-void GenCollectedHeap::save_used_regions() {\n-  _old_gen->save_used_region();\n-  _young_gen->save_used_region();\n-}\n-\n-size_t GenCollectedHeap::max_capacity() const {\n-  return _young_gen->max_capacity() + _old_gen->max_capacity();\n-}\n-\n-\/\/ Update the _full_collections_completed counter\n-\/\/ at the end of a stop-world full GC.\n-unsigned int GenCollectedHeap::update_full_collections_completed() {\n-  assert(_full_collections_completed <= _total_full_collections,\n-         \"Can't complete more collections than were started\");\n-  _full_collections_completed = _total_full_collections;\n-  return _full_collections_completed;\n-}\n-\n-\/\/ Return true if any of the following is true:\n-\/\/ . the allocation won't fit into the current young gen heap\n-\/\/ . gc locker is occupied (jni critical section)\n-\/\/ . heap memory is tight -- the most recent previous collection\n-\/\/   was a full collection because a partial collection (would\n-\/\/   have) failed and is likely to fail again\n-bool GenCollectedHeap::should_try_older_generation_allocation(size_t word_size) const {\n-  size_t young_capacity = _young_gen->capacity_before_gc();\n-  return    (word_size > heap_word_size(young_capacity))\n-         || GCLocker::is_active_and_needs_gc()\n-         || incremental_collection_failed();\n-}\n-\n-HeapWord* GenCollectedHeap::expand_heap_and_allocate(size_t size, bool   is_tlab) {\n-  HeapWord* result = nullptr;\n-  if (_old_gen->should_allocate(size, is_tlab)) {\n-    result = _old_gen->expand_and_allocate(size, is_tlab);\n-  }\n-  if (result == nullptr) {\n-    if (_young_gen->should_allocate(size, is_tlab)) {\n-      result = _young_gen->expand_and_allocate(size, is_tlab);\n-    }\n-  }\n-  assert(result == nullptr || is_in_reserved(result), \"result not in heap\");\n-  return result;\n-}\n-\n-HeapWord* GenCollectedHeap::mem_allocate_work(size_t size,\n-                                              bool is_tlab) {\n-\n-  HeapWord* result = nullptr;\n-\n-  \/\/ Loop until the allocation is satisfied, or unsatisfied after GC.\n-  for (uint try_count = 1, gclocker_stalled_count = 0; \/* return or throw *\/; try_count += 1) {\n-\n-    \/\/ First allocation attempt is lock-free.\n-    Generation *young = _young_gen;\n-    if (young->should_allocate(size, is_tlab)) {\n-      result = young->par_allocate(size, is_tlab);\n-      if (result != nullptr) {\n-        assert(is_in_reserved(result), \"result not in heap\");\n-        return result;\n-      }\n-    }\n-    uint gc_count_before;  \/\/ Read inside the Heap_lock locked region.\n-    {\n-      MutexLocker ml(Heap_lock);\n-      log_trace(gc, alloc)(\"GenCollectedHeap::mem_allocate_work: attempting locked slow path allocation\");\n-      \/\/ Note that only large objects get a shot at being\n-      \/\/ allocated in later generations.\n-      bool first_only = !should_try_older_generation_allocation(size);\n-\n-      result = attempt_allocation(size, is_tlab, first_only);\n-      if (result != nullptr) {\n-        assert(is_in_reserved(result), \"result not in heap\");\n-        return result;\n-      }\n-\n-      if (GCLocker::is_active_and_needs_gc()) {\n-        if (is_tlab) {\n-          return nullptr;  \/\/ Caller will retry allocating individual object.\n-        }\n-        if (!is_maximal_no_gc()) {\n-          \/\/ Try and expand heap to satisfy request.\n-          result = expand_heap_and_allocate(size, is_tlab);\n-          \/\/ Result could be null if we are out of space.\n-          if (result != nullptr) {\n-            return result;\n-          }\n-        }\n-\n-        if (gclocker_stalled_count > GCLockerRetryAllocationCount) {\n-          return nullptr; \/\/ We didn't get to do a GC and we didn't get any memory.\n-        }\n-\n-        \/\/ If this thread is not in a jni critical section, we stall\n-        \/\/ the requestor until the critical section has cleared and\n-        \/\/ GC allowed. When the critical section clears, a GC is\n-        \/\/ initiated by the last thread exiting the critical section; so\n-        \/\/ we retry the allocation sequence from the beginning of the loop,\n-        \/\/ rather than causing more, now probably unnecessary, GC attempts.\n-        JavaThread* jthr = JavaThread::current();\n-        if (!jthr->in_critical()) {\n-          MutexUnlocker mul(Heap_lock);\n-          \/\/ Wait for JNI critical section to be exited\n-          GCLocker::stall_until_clear();\n-          gclocker_stalled_count += 1;\n-          continue;\n-        } else {\n-          if (CheckJNICalls) {\n-            fatal(\"Possible deadlock due to allocating while\"\n-                  \" in jni critical section\");\n-          }\n-          return nullptr;\n-        }\n-      }\n-\n-      \/\/ Read the gc count while the heap lock is held.\n-      gc_count_before = total_collections();\n-    }\n-\n-    VM_GenCollectForAllocation op(size, is_tlab, gc_count_before);\n-    VMThread::execute(&op);\n-    if (op.prologue_succeeded()) {\n-      result = op.result();\n-      if (op.gc_locked()) {\n-         assert(result == nullptr, \"must be null if gc_locked() is true\");\n-         continue;  \/\/ Retry and\/or stall as necessary.\n-      }\n-\n-      assert(result == nullptr || is_in_reserved(result),\n-             \"result not in heap\");\n-      return result;\n-    }\n-\n-    \/\/ Give a warning if we seem to be looping forever.\n-    if ((QueuedAllocationWarningCount > 0) &&\n-        (try_count % QueuedAllocationWarningCount == 0)) {\n-          log_warning(gc, ergo)(\"GenCollectedHeap::mem_allocate_work retries %d times,\"\n-                                \" size=\" SIZE_FORMAT \" %s\", try_count, size, is_tlab ? \"(TLAB)\" : \"\");\n-    }\n-  }\n-}\n-\n-HeapWord* GenCollectedHeap::attempt_allocation(size_t size,\n-                                               bool is_tlab,\n-                                               bool first_only) {\n-  HeapWord* res = nullptr;\n-\n-  if (_young_gen->should_allocate(size, is_tlab)) {\n-    res = _young_gen->allocate(size, is_tlab);\n-    if (res != nullptr || first_only) {\n-      return res;\n-    }\n-  }\n-\n-  if (_old_gen->should_allocate(size, is_tlab)) {\n-    res = _old_gen->allocate(size, is_tlab);\n-  }\n-\n-  return res;\n-}\n-\n-HeapWord* GenCollectedHeap::mem_allocate(size_t size,\n-                                         bool* gc_overhead_limit_was_exceeded) {\n-  return mem_allocate_work(size,\n-                           false \/* is_tlab *\/);\n-}\n-\n-bool GenCollectedHeap::must_clear_all_soft_refs() {\n-  return _gc_cause == GCCause::_metadata_GC_clear_soft_refs ||\n-         _gc_cause == GCCause::_wb_full_gc;\n-}\n-\n-void GenCollectedHeap::collect_generation(Generation* gen, bool full, size_t size,\n-                                          bool is_tlab, bool run_verification, bool clear_soft_refs) {\n-  FormatBuffer<> title(\"Collect gen: %s\", gen->short_name());\n-  GCTraceTime(Trace, gc, phases) t1(title);\n-  TraceCollectorStats tcs(gen->counters());\n-  TraceMemoryManagerStats tmms(gen->gc_manager(), gc_cause(), heap()->is_young_gen(gen) ? \"end of minor GC\" : \"end of major GC\");\n-\n-  gen->stat_record()->invocations++;\n-  gen->stat_record()->accumulated_time.start();\n-\n-  \/\/ Must be done anew before each collection because\n-  \/\/ a previous collection will do mangling and will\n-  \/\/ change top of some spaces.\n-  record_gen_tops_before_GC();\n-\n-  log_trace(gc)(\"%s invoke=%d size=\" SIZE_FORMAT, heap()->is_young_gen(gen) ? \"Young\" : \"Old\", gen->stat_record()->invocations, size * HeapWordSize);\n-\n-  if (run_verification && VerifyBeforeGC) {\n-    Universe::verify(\"Before GC\");\n-  }\n-  COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::clear());\n-\n-  \/\/ Do collection work\n-  {\n-    save_marks();   \/\/ save marks for all gens\n-\n-    gen->collect(full, clear_soft_refs, size, is_tlab);\n-  }\n-\n-  COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::update_pointers());\n-\n-  gen->stat_record()->accumulated_time.stop();\n-\n-  update_gc_stats(gen, full);\n-\n-  if (run_verification && VerifyAfterGC) {\n-    Universe::verify(\"After GC\");\n-  }\n-}\n-\n-void GenCollectedHeap::do_collection(bool           full,\n-                                     bool           clear_all_soft_refs,\n-                                     size_t         size,\n-                                     bool           is_tlab,\n-                                     GenerationType max_generation) {\n-  ResourceMark rm;\n-  DEBUG_ONLY(Thread* my_thread = Thread::current();)\n-\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n-  assert(my_thread->is_VM_thread(), \"only VM thread\");\n-  assert(Heap_lock->is_locked(),\n-         \"the requesting thread should have the Heap_lock\");\n-  guarantee(!is_gc_active(), \"collection is not reentrant\");\n-\n-  if (GCLocker::check_active_before_gc()) {\n-    return; \/\/ GC is disabled (e.g. JNI GetXXXCritical operation)\n-  }\n-\n-  const bool do_clear_all_soft_refs = clear_all_soft_refs ||\n-                          soft_ref_policy()->should_clear_all_soft_refs();\n-\n-  ClearedAllSoftRefs casr(do_clear_all_soft_refs, soft_ref_policy());\n-\n-  AutoModifyRestore<bool> temporarily(_is_gc_active, true);\n-\n-  bool complete = full && (max_generation == OldGen);\n-  bool old_collects_young = complete && !ScavengeBeforeFullGC;\n-  bool do_young_collection = !old_collects_young && _young_gen->should_collect(full, size, is_tlab);\n-\n-  const PreGenGCValues pre_gc_values = get_pre_gc_values();\n-\n-  bool run_verification = total_collections() >= VerifyGCStartAt;\n-  bool prepared_for_verification = false;\n-  bool do_full_collection = false;\n-\n-  if (do_young_collection) {\n-    GCIdMark gc_id_mark;\n-    GCTraceCPUTime tcpu(((DefNewGeneration*)_young_gen)->gc_tracer());\n-    GCTraceTime(Info, gc) t(\"Pause Young\", nullptr, gc_cause(), true);\n-\n-    print_heap_before_gc();\n-\n-    if (run_verification && VerifyGCLevel <= 0 && VerifyBeforeGC) {\n-      prepare_for_verify();\n-      prepared_for_verification = true;\n-    }\n-\n-    gc_prologue(complete);\n-    increment_total_collections(complete);\n-\n-    collect_generation(_young_gen,\n-                       full,\n-                       size,\n-                       is_tlab,\n-                       run_verification && VerifyGCLevel <= 0,\n-                       do_clear_all_soft_refs);\n-\n-    if (size > 0 && (!is_tlab || _young_gen->supports_tlab_allocation()) &&\n-        size * HeapWordSize <= _young_gen->unsafe_max_alloc_nogc()) {\n-      \/\/ Allocation request was met by young GC.\n-      size = 0;\n-    }\n-\n-    \/\/ Ask if young collection is enough. If so, do the final steps for young collection,\n-    \/\/ and fallthrough to the end.\n-    do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);\n-    if (!do_full_collection) {\n-      \/\/ Adjust generation sizes.\n-      _young_gen->compute_new_size();\n-\n-      print_heap_change(pre_gc_values);\n-\n-      \/\/ Track memory usage and detect low memory after GC finishes\n-      MemoryService::track_memory_usage();\n-\n-      gc_epilogue(complete);\n-    }\n-\n-    print_heap_after_gc();\n-\n-  } else {\n-    \/\/ No young collection, ask if we need to perform Full collection.\n-    do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);\n-  }\n-\n-  if (do_full_collection) {\n-    GCIdMark gc_id_mark;\n-    GCTraceCPUTime tcpu(GenMarkSweep::gc_tracer());\n-    GCTraceTime(Info, gc) t(\"Pause Full\", nullptr, gc_cause(), true);\n-\n-    print_heap_before_gc();\n-\n-    if (!prepared_for_verification && run_verification &&\n-        VerifyGCLevel <= 1 && VerifyBeforeGC) {\n-      prepare_for_verify();\n-    }\n-\n-    if (!do_young_collection) {\n-      gc_prologue(complete);\n-      increment_total_collections(complete);\n-    }\n-\n-    \/\/ Accounting quirk: total full collections would be incremented when \"complete\"\n-    \/\/ is set, by calling increment_total_collections above. However, we also need to\n-    \/\/ account Full collections that had \"complete\" unset.\n-    if (!complete) {\n-      increment_total_full_collections();\n-    }\n-\n-    CodeCache::on_gc_marking_cycle_start();\n-\n-    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n-                              false \/* unregister_nmethods_during_purge *\/,\n-                              false \/* lock_codeblob_free_separately *\/);\n-\n-    collect_generation(_old_gen,\n-                       full,\n-                       size,\n-                       is_tlab,\n-                       run_verification && VerifyGCLevel <= 1,\n-                       do_clear_all_soft_refs);\n-\n-    CodeCache::on_gc_marking_cycle_finish();\n-    CodeCache::arm_all_nmethods();\n-\n-    \/\/ Adjust generation sizes.\n-    _old_gen->compute_new_size();\n-    _young_gen->compute_new_size();\n-\n-    \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n-    DEBUG_ONLY(MetaspaceUtils::verify();)\n-\n-    \/\/ Need to clear claim bits for the next mark.\n-    ClassLoaderDataGraph::clear_claimed_marks();\n-\n-    \/\/ Resize the metaspace capacity after full collections\n-    MetaspaceGC::compute_new_size();\n-    update_full_collections_completed();\n-\n-    print_heap_change(pre_gc_values);\n-\n-    \/\/ Track memory usage and detect low memory after GC finishes\n-    MemoryService::track_memory_usage();\n-\n-    \/\/ Need to tell the epilogue code we are done with Full GC, regardless what was\n-    \/\/ the initial value for \"complete\" flag.\n-    gc_epilogue(true);\n-\n-    print_heap_after_gc();\n-  }\n-}\n-\n-bool GenCollectedHeap::should_do_full_collection(size_t size, bool full, bool is_tlab,\n-                                                 GenCollectedHeap::GenerationType max_gen) const {\n-  return max_gen == OldGen && _old_gen->should_collect(full, size, is_tlab);\n-}\n-\n-void GenCollectedHeap::register_nmethod(nmethod* nm) {\n-  ScavengableNMethods::register_nmethod(nm);\n-}\n-\n-void GenCollectedHeap::unregister_nmethod(nmethod* nm) {\n-  ScavengableNMethods::unregister_nmethod(nm);\n-}\n-\n-void GenCollectedHeap::verify_nmethod(nmethod* nm) {\n-  ScavengableNMethods::verify_nmethod(nm);\n-}\n-\n-void GenCollectedHeap::prune_scavengable_nmethods() {\n-  ScavengableNMethods::prune_nmethods_not_into_young();\n-}\n-\n-void GenCollectedHeap::prune_unlinked_nmethods() {\n-  ScavengableNMethods::prune_unlinked_nmethods();\n-}\n-\n-HeapWord* GenCollectedHeap::satisfy_failed_allocation(size_t size, bool is_tlab) {\n-  GCCauseSetter x(this, GCCause::_allocation_failure);\n-  HeapWord* result = nullptr;\n-\n-  assert(size != 0, \"Precondition violated\");\n-  if (GCLocker::is_active_and_needs_gc()) {\n-    \/\/ GC locker is active; instead of a collection we will attempt\n-    \/\/ to expand the heap, if there's room for expansion.\n-    if (!is_maximal_no_gc()) {\n-      result = expand_heap_and_allocate(size, is_tlab);\n-    }\n-    return result;   \/\/ Could be null if we are out of space.\n-  } else if (!incremental_collection_will_fail(false \/* don't consult_young *\/)) {\n-    \/\/ Do an incremental collection.\n-    do_collection(false,                     \/\/ full\n-                  false,                     \/\/ clear_all_soft_refs\n-                  size,                      \/\/ size\n-                  is_tlab,                   \/\/ is_tlab\n-                  GenCollectedHeap::OldGen); \/\/ max_generation\n-  } else {\n-    log_trace(gc)(\" :: Trying full because partial may fail :: \");\n-    \/\/ Try a full collection; see delta for bug id 6266275\n-    \/\/ for the original code and why this has been simplified\n-    \/\/ with from-space allocation criteria modified and\n-    \/\/ such allocation moved out of the safepoint path.\n-    do_collection(true,                      \/\/ full\n-                  false,                     \/\/ clear_all_soft_refs\n-                  size,                      \/\/ size\n-                  is_tlab,                   \/\/ is_tlab\n-                  GenCollectedHeap::OldGen); \/\/ max_generation\n-  }\n-\n-  result = attempt_allocation(size, is_tlab, false \/*first_only*\/);\n-\n-  if (result != nullptr) {\n-    assert(is_in_reserved(result), \"result not in heap\");\n-    return result;\n-  }\n-\n-  \/\/ OK, collection failed, try expansion.\n-  result = expand_heap_and_allocate(size, is_tlab);\n-  if (result != nullptr) {\n-    return result;\n-  }\n-\n-  \/\/ If we reach this point, we're really out of memory. Try every trick\n-  \/\/ we can to reclaim memory. Force collection of soft references. Force\n-  \/\/ a complete compaction of the heap. Any additional methods for finding\n-  \/\/ free memory should be here, especially if they are expensive. If this\n-  \/\/ attempt fails, an OOM exception will be thrown.\n-  {\n-    UIntFlagSetting flag_change(MarkSweepAlwaysCompactCount, 1); \/\/ Make sure the heap is fully compacted\n-\n-    do_collection(true,                      \/\/ full\n-                  true,                      \/\/ clear_all_soft_refs\n-                  size,                      \/\/ size\n-                  is_tlab,                   \/\/ is_tlab\n-                  GenCollectedHeap::OldGen); \/\/ max_generation\n-  }\n-\n-  result = attempt_allocation(size, is_tlab, false \/* first_only *\/);\n-  if (result != nullptr) {\n-    assert(is_in_reserved(result), \"result not in heap\");\n-    return result;\n-  }\n-\n-  assert(!soft_ref_policy()->should_clear_all_soft_refs(),\n-    \"Flag should have been handled and cleared prior to this point\");\n-\n-  \/\/ What else?  We might try synchronous finalization later.  If the total\n-  \/\/ space available is large enough for the allocation, then a more\n-  \/\/ complete compaction phase than we've tried so far might be\n-  \/\/ appropriate.\n-  return nullptr;\n-}\n-\n-#ifdef ASSERT\n-class AssertNonScavengableClosure: public OopClosure {\n-public:\n-  virtual void do_oop(oop* p) {\n-    assert(!GenCollectedHeap::heap()->is_in_partial_collection(*p),\n-      \"Referent should not be scavengable.\");  }\n-  virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-};\n-static AssertNonScavengableClosure assert_is_non_scavengable_closure;\n-#endif\n-\n-void GenCollectedHeap::process_roots(ScanningOption so,\n-                                     OopClosure* strong_roots,\n-                                     CLDClosure* strong_cld_closure,\n-                                     CLDClosure* weak_cld_closure,\n-                                     CodeBlobToOopClosure* code_roots) {\n-  \/\/ General roots.\n-  assert(code_roots != nullptr, \"code root closure should always be set\");\n-\n-  ClassLoaderDataGraph::roots_cld_do(strong_cld_closure, weak_cld_closure);\n-\n-  \/\/ Only process code roots from thread stacks if we aren't visiting the entire CodeCache anyway\n-  CodeBlobToOopClosure* roots_from_code_p = (so & SO_AllCodeCache) ? nullptr : code_roots;\n-\n-  Threads::oops_do(strong_roots, roots_from_code_p);\n-\n-  OopStorageSet::strong_oops_do(strong_roots);\n-\n-  if (so & SO_ScavengeCodeCache) {\n-    assert(code_roots != nullptr, \"must supply closure for code cache\");\n-\n-    \/\/ We only visit parts of the CodeCache when scavenging.\n-    ScavengableNMethods::nmethods_do(code_roots);\n-  }\n-  if (so & SO_AllCodeCache) {\n-    assert(code_roots != nullptr, \"must supply closure for code cache\");\n-\n-    \/\/ CMSCollector uses this to do intermediate-strength collections.\n-    \/\/ We scan the entire code cache, since CodeCache::do_unloading is not called.\n-    CodeCache::blobs_do(code_roots);\n-  }\n-  \/\/ Verify that the code cache contents are not subject to\n-  \/\/ movement by a scavenging collection.\n-  DEBUG_ONLY(CodeBlobToOopClosure assert_code_is_non_scavengable(&assert_is_non_scavengable_closure, !CodeBlobToOopClosure::FixRelocations));\n-  DEBUG_ONLY(ScavengableNMethods::asserted_non_scavengable_nmethods_do(&assert_code_is_non_scavengable));\n-}\n-\n-bool GenCollectedHeap::no_allocs_since_save_marks() {\n-  return _young_gen->no_allocs_since_save_marks() &&\n-         _old_gen->no_allocs_since_save_marks();\n-}\n-\n-\/\/ public collection interfaces\n-void GenCollectedHeap::collect(GCCause::Cause cause) {\n-  \/\/ The caller doesn't have the Heap_lock\n-  assert(!Heap_lock->owned_by_self(), \"this thread should not own the Heap_lock\");\n-\n-  unsigned int gc_count_before;\n-  unsigned int full_gc_count_before;\n-\n-  {\n-    MutexLocker ml(Heap_lock);\n-    \/\/ Read the GC count while holding the Heap_lock\n-    gc_count_before      = total_collections();\n-    full_gc_count_before = total_full_collections();\n-  }\n-\n-  if (GCLocker::should_discard(cause, gc_count_before)) {\n-    return;\n-  }\n-\n-  bool should_run_young_gc =  (cause == GCCause::_wb_young_gc)\n-                           || (cause == GCCause::_gc_locker)\n-                DEBUG_ONLY(|| (cause == GCCause::_scavenge_alot));\n-\n-  const GenerationType max_generation = should_run_young_gc\n-                                      ? YoungGen\n-                                      : OldGen;\n-\n-  while (true) {\n-    VM_GenCollectFull op(gc_count_before, full_gc_count_before,\n-                        cause, max_generation);\n-    VMThread::execute(&op);\n-\n-    if (!GCCause::is_explicit_full_gc(cause)) {\n-      return;\n-    }\n-\n-    {\n-      MutexLocker ml(Heap_lock);\n-      \/\/ Read the GC count while holding the Heap_lock\n-      if (full_gc_count_before != total_full_collections()) {\n-        return;\n-      }\n-    }\n-\n-    if (GCLocker::is_active_and_needs_gc()) {\n-      \/\/ If GCLocker is active, wait until clear before retrying.\n-      GCLocker::stall_until_clear();\n-    }\n-  }\n-}\n-\n-void GenCollectedHeap::do_full_collection(bool clear_all_soft_refs) {\n-   do_full_collection(clear_all_soft_refs, OldGen);\n-}\n-\n-void GenCollectedHeap::do_full_collection(bool clear_all_soft_refs,\n-                                          GenerationType last_generation) {\n-  do_collection(true,                   \/\/ full\n-                clear_all_soft_refs,    \/\/ clear_all_soft_refs\n-                0,                      \/\/ size\n-                false,                  \/\/ is_tlab\n-                last_generation);       \/\/ last_generation\n-  \/\/ Hack XXX FIX ME !!!\n-  \/\/ A scavenge may not have been attempted, or may have\n-  \/\/ been attempted and failed, because the old gen was too full\n-  if (gc_cause() == GCCause::_gc_locker && incremental_collection_failed()) {\n-    log_debug(gc, jni)(\"GC locker: Trying a full collection because scavenge failed\");\n-    \/\/ This time allow the old gen to be collected as well\n-    do_collection(true,                \/\/ full\n-                  clear_all_soft_refs, \/\/ clear_all_soft_refs\n-                  0,                   \/\/ size\n-                  false,               \/\/ is_tlab\n-                  OldGen);             \/\/ last_generation\n-  }\n-}\n-\n-bool GenCollectedHeap::is_in_young(const void* p) const {\n-  bool result = p < _old_gen->reserved().start();\n-  assert(result == _young_gen->is_in_reserved(p),\n-         \"incorrect test - result=%d, p=\" PTR_FORMAT, result, p2i(p));\n-  return result;\n-}\n-\n-bool GenCollectedHeap::requires_barriers(stackChunkOop obj) const {\n-  return !is_in_young(obj);\n-}\n-\n-\/\/ Returns \"TRUE\" iff \"p\" points into the committed areas of the heap.\n-bool GenCollectedHeap::is_in(const void* p) const {\n-  return _young_gen->is_in(p) || _old_gen->is_in(p);\n-}\n-\n-#ifdef ASSERT\n-\/\/ Don't implement this by using is_in_young().  This method is used\n-\/\/ in some cases to check that is_in_young() is correct.\n-bool GenCollectedHeap::is_in_partial_collection(const void* p) {\n-  assert(is_in_reserved(p) || p == nullptr,\n-    \"Does not work if address is non-null and outside of the heap\");\n-  return p < _young_gen->reserved().end() && p != nullptr;\n-}\n-#endif\n-\n-void GenCollectedHeap::object_iterate(ObjectClosure* cl) {\n-  _young_gen->object_iterate(cl);\n-  _old_gen->object_iterate(cl);\n-}\n-\n-HeapWord* GenCollectedHeap::block_start(const void* addr) const {\n-  assert(is_in_reserved(addr), \"block_start of address outside of heap\");\n-  if (_young_gen->is_in_reserved(addr)) {\n-    assert(_young_gen->is_in(addr), \"addr should be in allocated part of generation\");\n-    return _young_gen->block_start(addr);\n-  }\n-\n-  assert(_old_gen->is_in_reserved(addr), \"Some generation should contain the address\");\n-  assert(_old_gen->is_in(addr), \"addr should be in allocated part of generation\");\n-  return _old_gen->block_start(addr);\n-}\n-\n-bool GenCollectedHeap::block_is_obj(const HeapWord* addr) const {\n-  assert(is_in_reserved(addr), \"block_is_obj of address outside of heap\");\n-  assert(block_start(addr) == addr, \"addr must be a block start\");\n-  if (_young_gen->is_in_reserved(addr)) {\n-    return _young_gen->block_is_obj(addr);\n-  }\n-\n-  assert(_old_gen->is_in_reserved(addr), \"Some generation should contain the address\");\n-  return _old_gen->block_is_obj(addr);\n-}\n-\n-size_t GenCollectedHeap::tlab_capacity(Thread* thr) const {\n-  assert(!_old_gen->supports_tlab_allocation(), \"Old gen supports TLAB allocation?!\");\n-  assert(_young_gen->supports_tlab_allocation(), \"Young gen doesn't support TLAB allocation?!\");\n-  return _young_gen->tlab_capacity();\n-}\n-\n-size_t GenCollectedHeap::tlab_used(Thread* thr) const {\n-  assert(!_old_gen->supports_tlab_allocation(), \"Old gen supports TLAB allocation?!\");\n-  assert(_young_gen->supports_tlab_allocation(), \"Young gen doesn't support TLAB allocation?!\");\n-  return _young_gen->tlab_used();\n-}\n-\n-size_t GenCollectedHeap::unsafe_max_tlab_alloc(Thread* thr) const {\n-  assert(!_old_gen->supports_tlab_allocation(), \"Old gen supports TLAB allocation?!\");\n-  assert(_young_gen->supports_tlab_allocation(), \"Young gen doesn't support TLAB allocation?!\");\n-  return _young_gen->unsafe_max_tlab_alloc();\n-}\n-\n-HeapWord* GenCollectedHeap::allocate_new_tlab(size_t min_size,\n-                                              size_t requested_size,\n-                                              size_t* actual_size) {\n-  HeapWord* result = mem_allocate_work(requested_size \/* size *\/,\n-                                       true \/* is_tlab *\/);\n-  if (result != nullptr) {\n-    *actual_size = requested_size;\n-  }\n-\n-  return result;\n-}\n-\n-void GenCollectedHeap::prepare_for_verify() {\n-  ensure_parsability(false);        \/\/ no need to retire TLABs\n-}\n-\n-void GenCollectedHeap::generation_iterate(GenClosure* cl,\n-                                          bool old_to_young) {\n-  if (old_to_young) {\n-    cl->do_generation(_old_gen);\n-    cl->do_generation(_young_gen);\n-  } else {\n-    cl->do_generation(_young_gen);\n-    cl->do_generation(_old_gen);\n-  }\n-}\n-\n-bool GenCollectedHeap::is_maximal_no_gc() const {\n-  return _young_gen->is_maximal_no_gc() && _old_gen->is_maximal_no_gc();\n-}\n-\n-void GenCollectedHeap::save_marks() {\n-  _young_gen->save_marks();\n-  _old_gen->save_marks();\n-}\n-\n-GenCollectedHeap* GenCollectedHeap::heap() {\n-  \/\/ SerialHeap is the only subtype of GenCollectedHeap.\n-  return named_heap<GenCollectedHeap>(CollectedHeap::Serial);\n-}\n-\n-void GenCollectedHeap::verify(VerifyOption option \/* ignored *\/) {\n-  log_debug(gc, verify)(\"%s\", _old_gen->name());\n-  _old_gen->verify();\n-\n-  log_debug(gc, verify)(\"%s\", _young_gen->name());\n-  _young_gen->verify();\n-\n-  log_debug(gc, verify)(\"RemSet\");\n-  rem_set()->verify();\n-}\n-\n-void GenCollectedHeap::print_on(outputStream* st) const {\n-  if (_young_gen != nullptr) {\n-    _young_gen->print_on(st);\n-  }\n-  if (_old_gen != nullptr) {\n-    _old_gen->print_on(st);\n-  }\n-  MetaspaceUtils::print_on(st);\n-}\n-\n-void GenCollectedHeap::gc_threads_do(ThreadClosure* tc) const {\n-}\n-\n-bool GenCollectedHeap::print_location(outputStream* st, void* addr) const {\n-  return BlockLocationPrinter<GenCollectedHeap>::print_location(st, addr);\n-}\n-\n-void GenCollectedHeap::print_tracing_info() const {\n-  if (log_is_enabled(Debug, gc, heap, exit)) {\n-    LogStreamHandle(Debug, gc, heap, exit) lsh;\n-    _young_gen->print_summary_info_on(&lsh);\n-    _old_gen->print_summary_info_on(&lsh);\n-  }\n-}\n-\n-void GenCollectedHeap::print_heap_change(const PreGenGCValues& pre_gc_values) const {\n-  const DefNewGeneration* const def_new_gen = (DefNewGeneration*) young_gen();\n-\n-  log_info(gc, heap)(HEAP_CHANGE_FORMAT\" \"\n-                     HEAP_CHANGE_FORMAT\" \"\n-                     HEAP_CHANGE_FORMAT,\n-                     HEAP_CHANGE_FORMAT_ARGS(def_new_gen->short_name(),\n-                                             pre_gc_values.young_gen_used(),\n-                                             pre_gc_values.young_gen_capacity(),\n-                                             def_new_gen->used(),\n-                                             def_new_gen->capacity()),\n-                     HEAP_CHANGE_FORMAT_ARGS(\"Eden\",\n-                                             pre_gc_values.eden_used(),\n-                                             pre_gc_values.eden_capacity(),\n-                                             def_new_gen->eden()->used(),\n-                                             def_new_gen->eden()->capacity()),\n-                     HEAP_CHANGE_FORMAT_ARGS(\"From\",\n-                                             pre_gc_values.from_used(),\n-                                             pre_gc_values.from_capacity(),\n-                                             def_new_gen->from()->used(),\n-                                             def_new_gen->from()->capacity()));\n-  log_info(gc, heap)(HEAP_CHANGE_FORMAT,\n-                     HEAP_CHANGE_FORMAT_ARGS(old_gen()->short_name(),\n-                                             pre_gc_values.old_gen_used(),\n-                                             pre_gc_values.old_gen_capacity(),\n-                                             old_gen()->used(),\n-                                             old_gen()->capacity()));\n-  MetaspaceUtils::print_metaspace_change(pre_gc_values.metaspace_sizes());\n-}\n-\n-class GenGCPrologueClosure: public GenCollectedHeap::GenClosure {\n- private:\n-  bool _full;\n- public:\n-  void do_generation(Generation* gen) {\n-    gen->gc_prologue(_full);\n-  }\n-  GenGCPrologueClosure(bool full) : _full(full) {};\n-};\n-\n-void GenCollectedHeap::gc_prologue(bool full) {\n-  assert(InlineCacheBuffer::is_empty(), \"should have cleaned up ICBuffer\");\n-\n-  \/\/ Fill TLAB's and such\n-  ensure_parsability(true);   \/\/ retire TLABs\n-\n-  \/\/ Walk generations\n-  GenGCPrologueClosure blk(full);\n-  generation_iterate(&blk, false);  \/\/ not old-to-young.\n-};\n-\n-class GenGCEpilogueClosure: public GenCollectedHeap::GenClosure {\n- private:\n-  bool _full;\n- public:\n-  void do_generation(Generation* gen) {\n-    gen->gc_epilogue(_full);\n-  }\n-  GenGCEpilogueClosure(bool full) : _full(full) {};\n-};\n-\n-void GenCollectedHeap::gc_epilogue(bool full) {\n-#if COMPILER2_OR_JVMCI\n-  assert(DerivedPointerTable::is_empty(), \"derived pointer present\");\n-#endif \/\/ COMPILER2_OR_JVMCI\n-\n-  resize_all_tlabs();\n-\n-  GenGCEpilogueClosure blk(full);\n-  generation_iterate(&blk, false);  \/\/ not old-to-young.\n-\n-  MetaspaceCounters::update_performance_counters();\n-};\n-\n-#ifndef PRODUCT\n-class GenGCSaveTopsBeforeGCClosure: public GenCollectedHeap::GenClosure {\n- private:\n- public:\n-  void do_generation(Generation* gen) {\n-    gen->record_spaces_top();\n-  }\n-};\n-\n-void GenCollectedHeap::record_gen_tops_before_GC() {\n-  if (ZapUnusedHeapArea) {\n-    GenGCSaveTopsBeforeGCClosure blk;\n-    generation_iterate(&blk, false);  \/\/ not old-to-young.\n-  }\n-}\n-#endif  \/\/ not PRODUCT\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":1035,"binary":false,"changes":1035,"status":"deleted"},{"patch":"@@ -1,346 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP\n-#define SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP\n-\n-#include \"gc\/serial\/generation.hpp\"\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"gc\/shared\/oopStorageParState.hpp\"\n-#include \"gc\/shared\/preGCValues.hpp\"\n-#include \"gc\/shared\/softRefPolicy.hpp\"\n-\n-class CardTableRS;\n-class GCPolicyCounters;\n-\n-\/\/ A \"GenCollectedHeap\" is a CollectedHeap that uses generational\n-\/\/ collection.  It has two generations, young and old.\n-class GenCollectedHeap : public CollectedHeap {\n-  friend class Generation;\n-  friend class DefNewGeneration;\n-  friend class TenuredGeneration;\n-  friend class GenMarkSweep;\n-  friend class VM_GenCollectForAllocation;\n-  friend class VM_GenCollectFull;\n-  friend class VM_GC_HeapInspection;\n-  friend class VM_HeapDumper;\n-  friend class HeapInspection;\n-  friend class GCCauseSetter;\n-  friend class VMStructs;\n-public:\n-  friend class VM_PopulateDumpSharedSpace;\n-\n-  enum GenerationType {\n-    YoungGen,\n-    OldGen\n-  };\n-\n-protected:\n-  Generation* _young_gen;\n-  Generation* _old_gen;\n-\n-private:\n-  \/\/ The singleton CardTable Remembered Set.\n-  CardTableRS* _rem_set;\n-\n-  SoftRefPolicy _soft_ref_policy;\n-\n-  GCPolicyCounters* _gc_policy_counters;\n-\n-  \/\/ Indicates that the most recent previous incremental collection failed.\n-  \/\/ The flag is cleared when an action is taken that might clear the\n-  \/\/ condition that caused that incremental collection to fail.\n-  bool _incremental_collection_failed;\n-\n-  \/\/ In support of ExplicitGCInvokesConcurrent functionality\n-  unsigned int _full_collections_completed;\n-\n-  \/\/ Collects the given generation.\n-  void collect_generation(Generation* gen, bool full, size_t size, bool is_tlab,\n-                          bool run_verification, bool clear_soft_refs);\n-\n-  \/\/ Reserve aligned space for the heap as needed by the contained generations.\n-  ReservedHeapSpace allocate(size_t alignment);\n-\n-  PreGenGCValues get_pre_gc_values() const;\n-\n-protected:\n-\n-  GCMemoryManager* _young_manager;\n-  GCMemoryManager* _old_manager;\n-\n-  \/\/ Helper functions for allocation\n-  HeapWord* attempt_allocation(size_t size,\n-                               bool   is_tlab,\n-                               bool   first_only);\n-\n-  \/\/ Helper function for two callbacks below.\n-  \/\/ Considers collection of the first max_level+1 generations.\n-  void do_collection(bool           full,\n-                     bool           clear_all_soft_refs,\n-                     size_t         size,\n-                     bool           is_tlab,\n-                     GenerationType max_generation);\n-\n-  \/\/ Callback from VM_GenCollectForAllocation operation.\n-  \/\/ This function does everything necessary\/possible to satisfy an\n-  \/\/ allocation request that failed in the youngest generation that should\n-  \/\/ have handled it (including collection, expansion, etc.)\n-  HeapWord* satisfy_failed_allocation(size_t size, bool is_tlab);\n-\n-  \/\/ Callback from VM_GenCollectFull operation.\n-  \/\/ Perform a full collection of the first max_level+1 generations.\n-  void do_full_collection(bool clear_all_soft_refs) override;\n-  void do_full_collection(bool clear_all_soft_refs, GenerationType max_generation);\n-\n-  \/\/ Does the \"cause\" of GC indicate that\n-  \/\/ we absolutely __must__ clear soft refs?\n-  bool must_clear_all_soft_refs();\n-\n-  GenCollectedHeap(Generation::Name young,\n-                   Generation::Name old,\n-                   const char* policy_counters_name);\n-\n-public:\n-\n-  \/\/ Returns JNI_OK on success\n-  jint initialize() override;\n-  virtual CardTableRS* create_rem_set(const MemRegion& reserved_region);\n-\n-  \/\/ Does operations required after initialization has been done.\n-  void post_initialize() override;\n-\n-  Generation* young_gen() const { return _young_gen; }\n-  Generation* old_gen()   const { return _old_gen; }\n-\n-  bool is_young_gen(const Generation* gen) const { return gen == _young_gen; }\n-  bool is_old_gen(const Generation* gen) const { return gen == _old_gen; }\n-\n-  MemRegion reserved_region() const { return _reserved; }\n-  bool is_in_reserved(const void* addr) const { return _reserved.contains(addr); }\n-\n-  SoftRefPolicy* soft_ref_policy() override { return &_soft_ref_policy; }\n-\n-  \/\/ Performance Counter support\n-  GCPolicyCounters* counters()     { return _gc_policy_counters; }\n-\n-  size_t capacity() const override;\n-  size_t used() const override;\n-\n-  \/\/ Save the \"used_region\" for both generations.\n-  void save_used_regions();\n-\n-  size_t max_capacity() const override;\n-\n-  HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded) override;\n-\n-  \/\/ Perform a full collection of the heap; intended for use in implementing\n-  \/\/ \"System.gc\". This implies as full a collection as the CollectedHeap\n-  \/\/ supports. Caller does not hold the Heap_lock on entry.\n-  void collect(GCCause::Cause cause) override;\n-\n-  \/\/ Returns \"TRUE\" iff \"p\" points into the committed areas of the heap.\n-  \/\/ The methods is_in() and is_in_youngest() may be expensive to compute\n-  \/\/ in general, so, to prevent their inadvertent use in product jvm's, we\n-  \/\/ restrict their use to assertion checking or verification only.\n-  bool is_in(const void* p) const override;\n-\n-  \/\/ Returns true if p points into the reserved space for the young generation.\n-  \/\/ Assumes the young gen address range is less than that of the old gen.\n-  bool is_in_young(const void* p) const;\n-\n-  bool requires_barriers(stackChunkOop obj) const override;\n-\n-#ifdef ASSERT\n-  bool is_in_partial_collection(const void* p);\n-#endif\n-\n-  \/\/ Optimized nmethod scanning support routines\n-  void register_nmethod(nmethod* nm) override;\n-  void unregister_nmethod(nmethod* nm) override;\n-  void verify_nmethod(nmethod* nm) override;\n-\n-  void prune_scavengable_nmethods();\n-  void prune_unlinked_nmethods();\n-\n-  \/\/ Iteration functions.\n-  void object_iterate(ObjectClosure* cl) override;\n-\n-  \/\/ A CollectedHeap is divided into a dense sequence of \"blocks\"; that is,\n-  \/\/ each address in the (reserved) heap is a member of exactly\n-  \/\/ one block.  The defining characteristic of a block is that it is\n-  \/\/ possible to find its size, and thus to progress forward to the next\n-  \/\/ block.  (Blocks may be of different sizes.)  Thus, blocks may\n-  \/\/ represent Java objects, or they might be free blocks in a\n-  \/\/ free-list-based heap (or subheap), as long as the two kinds are\n-  \/\/ distinguishable and the size of each is determinable.\n-\n-  \/\/ Returns the address of the start of the \"block\" that contains the\n-  \/\/ address \"addr\".  We say \"blocks\" instead of \"object\" since some heaps\n-  \/\/ may not pack objects densely; a chunk may either be an object or a\n-  \/\/ non-object.\n-  HeapWord* block_start(const void* addr) const;\n-\n-  \/\/ Requires \"addr\" to be the start of a block, and returns \"TRUE\" iff\n-  \/\/ the block is an object. Assumes (and verifies in non-product\n-  \/\/ builds) that addr is in the allocated part of the heap and is\n-  \/\/ the start of a chunk.\n-  bool block_is_obj(const HeapWord* addr) const;\n-\n-  \/\/ Section on TLAB's.\n-  size_t tlab_capacity(Thread* thr) const override;\n-  size_t tlab_used(Thread* thr) const override;\n-  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n-  HeapWord* allocate_new_tlab(size_t min_size,\n-                              size_t requested_size,\n-                              size_t* actual_size) override;\n-\n-  \/\/ Total number of full collections completed.\n-  unsigned int total_full_collections_completed() {\n-    assert(_full_collections_completed <= _total_full_collections,\n-           \"Can't complete more collections than were started\");\n-    return _full_collections_completed;\n-  }\n-\n-  \/\/ Update above counter, as appropriate, at the end of a stop-world GC cycle\n-  unsigned int update_full_collections_completed();\n-\n-  \/\/ Update the gc statistics for each generation.\n-  void update_gc_stats(Generation* current_generation, bool full) {\n-    _old_gen->update_gc_stats(current_generation, full);\n-  }\n-\n-  bool no_gc_in_progress() { return !is_gc_active(); }\n-\n-  void prepare_for_verify() override;\n-  void verify(VerifyOption option) override;\n-\n-  void print_on(outputStream* st) const override;\n-  void gc_threads_do(ThreadClosure* tc) const override;\n-  void print_tracing_info() const override;\n-\n-  \/\/ Used to print information about locations in the hs_err file.\n-  bool print_location(outputStream* st, void* addr) const override;\n-\n-  void print_heap_change(const PreGenGCValues& pre_gc_values) const;\n-\n-  \/\/ The functions below are helper functions that a subclass of\n-  \/\/ \"CollectedHeap\" can use in the implementation of its virtual\n-  \/\/ functions.\n-\n-  class GenClosure : public StackObj {\n-   public:\n-    virtual void do_generation(Generation* gen) = 0;\n-  };\n-\n-  \/\/ Apply \"cl.do_generation\" to all generations in the heap\n-  \/\/ If \"old_to_young\" determines the order.\n-  void generation_iterate(GenClosure* cl, bool old_to_young);\n-\n-  \/\/ Return \"true\" if all generations have reached the\n-  \/\/ maximal committed limit that they can reach, without a garbage\n-  \/\/ collection.\n-  virtual bool is_maximal_no_gc() const override;\n-\n-  \/\/ This function returns the CardTableRS object that allows us to scan\n-  \/\/ generations in a fully generational heap.\n-  CardTableRS* rem_set() { return _rem_set; }\n-\n-  \/\/ Convenience function to be used in situations where the heap type can be\n-  \/\/ asserted to be this type.\n-  static GenCollectedHeap* heap();\n-\n-  \/\/ The ScanningOption determines which of the roots\n-  \/\/ the closure is applied to:\n-  \/\/ \"SO_None\" does none;\n-  enum ScanningOption {\n-    SO_None                =  0x0,\n-    SO_AllCodeCache        =  0x8,\n-    SO_ScavengeCodeCache   = 0x10\n-  };\n-\n- protected:\n-  virtual void gc_prologue(bool full);\n-  virtual void gc_epilogue(bool full);\n-\n- public:\n-  \/\/ Apply closures on various roots in Young GC or marking\/adjust phases of Full GC.\n-  void process_roots(ScanningOption so,\n-                     OopClosure* strong_roots,\n-                     CLDClosure* strong_cld_closure,\n-                     CLDClosure* weak_cld_closure,\n-                     CodeBlobToOopClosure* code_roots);\n-\n-  \/\/ Set the saved marks of generations, if that makes sense.\n-  \/\/ In particular, if any generation might iterate over the oops\n-  \/\/ in other generations, it should call this method.\n-  void save_marks();\n-\n-  \/\/ Returns \"true\" iff no allocations have occurred since the last\n-  \/\/ call to \"save_marks\".\n-  bool no_allocs_since_save_marks();\n-\n-  \/\/ Returns true if an incremental collection is likely to fail.\n-  \/\/ We optionally consult the young gen, if asked to do so;\n-  \/\/ otherwise we base our answer on whether the previous incremental\n-  \/\/ collection attempt failed with no corrective action as of yet.\n-  bool incremental_collection_will_fail(bool consult_young) {\n-    \/\/ The first disjunct remembers if an incremental collection failed, even\n-    \/\/ when we thought (second disjunct) that it would not.\n-    return incremental_collection_failed() ||\n-           (consult_young && !_young_gen->collection_attempt_is_safe());\n-  }\n-\n-  \/\/ If a generation bails out of an incremental collection,\n-  \/\/ it sets this flag.\n-  bool incremental_collection_failed() const {\n-    return _incremental_collection_failed;\n-  }\n-  void set_incremental_collection_failed() {\n-    _incremental_collection_failed = true;\n-  }\n-  void clear_incremental_collection_failed() {\n-    _incremental_collection_failed = false;\n-  }\n-\n-private:\n-  \/\/ Return true if an allocation should be attempted in the older generation\n-  \/\/ if it fails in the younger generation.  Return false, otherwise.\n-  bool should_try_older_generation_allocation(size_t word_size) const;\n-\n-  \/\/ Try to allocate space by expanding the heap.\n-  HeapWord* expand_heap_and_allocate(size_t size, bool is_tlab);\n-\n-  HeapWord* mem_allocate_work(size_t size,\n-                              bool is_tlab);\n-\n-  \/\/ Save the tops of the spaces in all generations\n-  void record_gen_tops_before_GC() PRODUCT_RETURN;\n-\n-  \/\/ Return true if we need to perform full collection.\n-  bool should_do_full_collection(size_t size, bool full,\n-                                 bool is_tlab, GenerationType max_gen) const;\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":0,"deletions":346,"binary":false,"changes":346,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-\/\/   GenSpaceMangler is used with the GenCollectedHeap collectors and\n+\/\/   GenSpaceMangler is used with the SerialHeap collectors and\n@@ -125,1 +125,1 @@\n-\/\/ For use with GenCollectedHeap's\n+\/\/ For use with SerialHeap's\n","filename":"src\/hotspot\/share\/gc\/shared\/spaceDecorator.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -112,3 +111,0 @@\n-  nonstatic_field(GenCollectedHeap,            _young_gen,                                    Generation*)                           \\\n-  nonstatic_field(GenCollectedHeap,            _old_gen,                                      Generation*)                           \\\n-                                                                                                                                     \\\n@@ -149,1 +145,0 @@\n-           declare_type(GenCollectedHeap,             CollectedHeap)      \\\n@@ -178,3 +173,0 @@\n-  declare_toplevel_type(DefNewGeneration*)                                \\\n-  declare_toplevel_type(GenCollectedHeap*)                                \\\n-  declare_toplevel_type(Generation*)                                      \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -144,1 +145,8 @@\n-void WorkerThreads::set_indirectly_suspendible_threads() {\n+template <typename Function>\n+void WorkerThreads::threads_do_f(Function function) const {\n+  for (uint i = 0; i < _created_workers; i++) {\n+    function(_workers[i]);\n+  }\n+}\n+\n+void WorkerThreads::set_indirect_states() {\n@@ -146,2 +154,7 @@\n-  class SetIndirectlySuspendibleThreadClosure : public ThreadClosure {\n-    virtual void do_thread(Thread* thread) {\n+  const bool is_suspendible = Thread::current()->is_suspendible_thread();\n+  const bool is_safepointed = Thread::current()->is_VM_thread() && SafepointSynchronize::is_at_safepoint();\n+\n+  threads_do_f([&](Thread* thread) {\n+    assert(!thread->is_indirectly_suspendible_thread(), \"Unexpected\");\n+    assert(!thread->is_indirectly_safepoint_thread(), \"Unexpected\");\n+    if (is_suspendible) {\n@@ -150,6 +163,4 @@\n-  };\n-\n-  if (Thread::current()->is_suspendible_thread()) {\n-    SetIndirectlySuspendibleThreadClosure cl;\n-    threads_do(&cl);\n-  }\n+    if (is_safepointed) {\n+      thread->set_indirectly_safepoint_thread();\n+    }\n+  });\n@@ -159,1 +170,1 @@\n-void WorkerThreads::clear_indirectly_suspendible_threads() {\n+void WorkerThreads::clear_indirect_states() {\n@@ -161,10 +172,4 @@\n-  class ClearIndirectlySuspendibleThreadClosure : public ThreadClosure {\n-    virtual void do_thread(Thread* thread) {\n-      thread->clear_indirectly_suspendible_thread();\n-    }\n-  };\n-\n-  if (Thread::current()->is_suspendible_thread()) {\n-    ClearIndirectlySuspendibleThreadClosure cl;\n-    threads_do(&cl);\n-  }\n+  threads_do_f([&](Thread* thread) {\n+    thread->clear_indirectly_suspendible_thread();\n+    thread->clear_indirectly_safepoint_thread();\n+  });\n@@ -175,1 +180,1 @@\n-  set_indirectly_suspendible_threads();\n+  set_indirect_states();\n@@ -177,1 +182,1 @@\n-  clear_indirectly_suspendible_threads();\n+  clear_indirect_states();\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -96,2 +96,2 @@\n-  void set_indirectly_suspendible_threads();\n-  void clear_indirectly_suspendible_threads();\n+  void set_indirect_states();\n+  void clear_indirect_states();\n@@ -114,0 +114,2 @@\n+  template <typename Function>\n+  void threads_do_f(Function function) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1232,1 +1232,1 @@\n-    return n->as_If()->dominated_by(prev_dom, phase->is_IterGVN());\n+    return n->as_If()->dominated_by(prev_dom, phase->is_IterGVN(), false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,7 +167,3 @@\n-  assert (((region_capacity <= _region_size_bytes) &&\n-           ((orig_set == Mutator) && (new_set == Collector)) ||\n-           ((orig_set == Collector) && (new_set == Mutator))) ||\n-          ((region_capacity == _region_size_bytes) &&\n-           ((orig_set == Mutator) && (new_set == Collector)) ||\n-           ((orig_set == OldCollector) && (new_set == Mutator)) ||\n-           (new_set == OldCollector)), \"Unexpected movement between sets\");\n+  assert((region_capacity <= _region_size_bytes && ((orig_set == Mutator && new_set == Collector) || (orig_set == Collector && new_set == Mutator))) \n+      || (region_capacity == _region_size_bytes && ((orig_set == Mutator && new_set == Collector) || (orig_set == OldCollector && new_set == Mutator) || new_set == OldCollector)), \n+      \"Unexpected movement between sets\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,3 +44,3 @@\n-  log_info(gc, init)(\"Heap Region Size: \" PROPERFMT, PROPERFMTARGS(ShenandoahHeapRegion::region_size_bytes()));\n-  log_info(gc, init)(\"TLAB Size Max: \" PROPERFMT, PROPERFMTARGS(ShenandoahHeapRegion::max_tlab_size_bytes()));\n-  log_info(gc, init)(\"Humongous Object Threshold: \" PROPERFMT, PROPERFMTARGS(ShenandoahHeapRegion::humongous_threshold_bytes()));\n+  log_info(gc, init)(\"Heap Region Size: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeapRegion::region_size_bytes()));\n+  log_info(gc, init)(\"TLAB Size Max: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeapRegion::max_tlab_size_bytes()));\n+  log_info(gc, init)(\"Humongous Object Threshold: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeapRegion::humongous_threshold_bytes()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -323,0 +323,14 @@\n+uint ZBarrierSetC2::estimated_barrier_size(const Node* node) const {\n+  uint8_t barrier_data = MemNode::barrier_data(node);\n+  assert(barrier_data != 0, \"should be a barrier node\");\n+  uint uncolor_or_color_size = node->is_Load() ? 1 : 2;\n+  if ((barrier_data & ZBarrierElided) != 0) {\n+    return uncolor_or_color_size;\n+  }\n+  \/\/ A compare and branch corresponds to approximately four fast-path Ideal\n+  \/\/ nodes (Cmp, Bool, If, If projection). The slow path (If projection and\n+  \/\/ runtime call) is excluded since the corresponding code is laid out\n+  \/\/ separately and does not directly affect performance.\n+  return uncolor_or_color_size + 4;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+  virtual uint estimated_barrier_size(const Node* node) const;\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"code\/codeCache.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"gc\/z\/zVerify.hpp\"\n@@ -36,1 +36,0 @@\n-#include \"runtime\/continuation.hpp\"\n@@ -323,8 +322,0 @@\n-inline void z_assert_is_barrier_safe() {\n-  assert(!Thread::current()->is_ConcurrentGC_thread() ||          \/* Need extra checks for ConcurrentGCThreads *\/\n-         Thread::current()->is_suspendible_thread() ||            \/* Thread prevents safepoints *\/\n-         Thread::current()->is_indirectly_suspendible_thread() || \/* Coordinator thread prevents safepoints *\/\n-         SafepointSynchronize::is_at_safepoint(),                 \/* Is at safepoint *\/\n-         \"Shouldn't perform load barrier\");\n-}\n-\n@@ -333,1 +324,1 @@\n-  z_assert_is_barrier_safe();\n+  z_verify_safepoints_are_blocked();\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"gc\/z\/zAddress.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -289,0 +289,4 @@\n+bool ZGeneration::is_relocate_queue_active() const {\n+  return _relocate.is_queue_active();\n+}\n+\n@@ -1500,1 +1504,1 @@\n-  \/\/ TODO: The STS joiner is only needed to satisfy z_assert_is_barrier_safe that doesn't\n+  \/\/ TODO: The STS joiner is only needed to satisfy ZBarrier::assert_is_state_barrier_safe that doesn't\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+  bool is_relocate_queue_active() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  return MaxHeapSize * ZFragmentationLimit;\n+  return MaxHeapSize * (ZFragmentationLimit \/ 100);\n@@ -108,1 +108,1 @@\n-  return MaxHeapSize * ZYoungCompactionLimit;\n+  return MaxHeapSize * (ZYoungCompactionLimit \/ 100);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zVerify.hpp\"\n@@ -34,0 +35,9 @@\n+  \/\/ This is a good place to make sure that we can't concurrently iterate over\n+  \/\/ objects while VMThread operations think they have exclusive access to the\n+  \/\/ object graph.\n+  \/\/\n+  \/\/ One example that have caused problems is the JFR Leak Profiler, which\n+  \/\/ sets the mark word to a value that makes the object arrays look like\n+  \/\/ invisible objects.\n+  z_verify_safepoints_are_blocked();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zIterator.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    _is_active(false),\n@@ -106,0 +107,14 @@\n+void ZRelocateQueue::activate(uint nworkers) {\n+  _is_active = true;\n+  join(nworkers);\n+}\n+\n+void ZRelocateQueue::deactivate() {\n+  Atomic::store(&_is_active, false);\n+  clear();\n+}\n+\n+bool ZRelocateQueue::is_active() const {\n+  return Atomic::load(&_is_active);\n+}\n+\n@@ -330,1 +345,1 @@\n-  _queue.join(workers()->active_workers());\n+  _queue.activate(workers()->active_workers());\n@@ -1091,0 +1106,3 @@\n+\n+    \/\/ Signal that we're not using the queue anymore. Used mostly for asserts.\n+    _queue->deactivate();\n@@ -1235,2 +1253,0 @@\n-\n-  _queue.clear();\n@@ -1319,0 +1335,4 @@\n+\n+bool ZRelocate::is_queue_active() const {\n+  return _queue.is_active();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  volatile bool        _is_active;\n@@ -56,0 +57,4 @@\n+  void activate(uint nworkers);\n+  void deactivate();\n+  bool is_active() const;\n+\n@@ -102,0 +107,2 @@\n+\n+  bool is_queue_active() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -109,0 +109,3 @@\n+    \/\/ Join the STS to block out VMThreads while running promote_barrier_on_young_oop_field\n+    SuspendibleThreadSetJoiner sts_joiner;\n+\n@@ -114,0 +117,2 @@\n+\n+      SuspendibleThreadSet::yield();\n@@ -121,0 +126,2 @@\n+\n+      SuspendibleThreadSet::yield();\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/z\/zBarrier.hpp\"\n@@ -36,1 +37,1 @@\n-  z_assert_is_barrier_safe();\n+  z_verify_safepoints_are_blocked();\n","filename":"src\/hotspot\/share\/gc\/z\/zUncoloredRoot.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -40,0 +39,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -46,1 +46,2 @@\n-#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -51,0 +52,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -56,0 +58,49 @@\n+#ifdef ASSERT\n+\n+\/\/ Used to verify that safepoints operations can't be scheduled concurrently\n+\/\/ with callers to this function. Typically used to verify that object oops\n+\/\/ and headers are safe to access.\n+void z_verify_safepoints_are_blocked() {\n+  Thread* current = Thread::current();\n+\n+  if (current->is_ConcurrentGC_thread()) {\n+    assert(current->is_suspendible_thread(), \/\/ Thread prevents safepoints\n+        \"Safepoints are not blocked by current thread\");\n+\n+  } else if (current->is_Worker_thread()) {\n+    assert(\/\/ Check if ...\n+        \/\/ the thread prevents safepoints\n+        current->is_suspendible_thread() ||\n+        \/\/ the coordinator thread is the safepointing VMThread\n+        current->is_indirectly_safepoint_thread() ||\n+        \/\/ the coordinator thread prevents safepoints\n+        current->is_indirectly_suspendible_thread() ||\n+        \/\/ the RelocateQueue prevents safepoints\n+        \/\/\n+        \/\/ RelocateQueue acts as a pseudo STS leaver\/joiner and blocks\n+        \/\/ safepoints. There's currently no infrastructure  to check if the\n+        \/\/ current thread is active or not, so check the global states instead.\n+        ZGeneration::young()->is_relocate_queue_active() ||\n+        ZGeneration::old()->is_relocate_queue_active(),\n+        \"Safepoints are not blocked by current thread\");\n+\n+  } else if (current->is_Java_thread()) {\n+    JavaThreadState state = JavaThread::cast(current)->thread_state();\n+    assert(state == _thread_in_Java || state == _thread_in_vm || state == _thread_new,\n+        \"Safepoints are not blocked by current thread from state: %d\", state);\n+\n+  } else if (current->is_JfrSampler_thread()) {\n+    \/\/ The JFR sampler thread blocks out safepoints with this lock.\n+    assert_lock_strong(Threads_lock);\n+\n+  } else if (current->is_VM_thread()) {\n+    \/\/ The VM Thread doesn't schedule new safepoints while executing\n+    \/\/ other safepoint or handshake operations.\n+\n+  } else {\n+    fatal(\"Unexpected thread type\");\n+  }\n+}\n+\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":53,"deletions":2,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+NOT_DEBUG(inline) void z_verify_safepoints_are_blocked() NOT_DEBUG_RETURN;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-      \/\/ Promote calculation to 64 bits to do range checks, used by the verifier.\n+      \/\/ Promote calculation to signed 64 bits to do range checks, used by the verifier.\n@@ -392,3 +392,8 @@\n-      \/\/ only return len if it can be represented as a positive int;\n-      \/\/ return -1 otherwise\n-      return (len > 0 && len == (int)len) ? (int)len : -1;\n+      \/\/ Only return len if it can be represented as a positive int and lo <= hi.\n+      \/\/ The caller checks for bytecode stream overflow.\n+      if (lo <= hi && len == (int)len) {\n+        assert(len > 0, \"must be\");\n+        return (int)len;\n+      } else {\n+        return -1;\n+      }\n@@ -407,3 +412,7 @@\n-      \/\/ only return len if it can be represented as a positive int;\n-      \/\/ return -1 otherwise\n-      return (len > 0 && len == (int)len) ? (int)len : -1;\n+      \/\/ Only return len if it can be represented as a positive int and npairs >= 0.\n+      if (npairs >= 0 && len == (int)len) {\n+        assert(len > 0, \"must be\");\n+        return (int)len;\n+      } else {\n+        return -1;\n+      }\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  static  int code_alignment()                   { return CodeEntryAlignment; }\n@@ -65,1 +66,1 @@\n-  address code_begin() const                     { return align_up((address)this + sizeof(InterpreterCodelet), CodeEntryAlignment); }\n+  address code_begin() const                     { return align_up((address)this + sizeof(InterpreterCodelet), code_alignment()); }\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-  char* os_name = NEW_RESOURCE_ARRAY(char, 2048);\n-  JfrOSInterface::os_version(&os_name);\n+  char* os_version = nullptr;\n+  JfrOSInterface::os_version(&os_version);\n@@ -121,1 +121,1 @@\n-  event.set_osVersion(os_name);\n+  event.set_osVersion(os_version);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -138,26 +138,0 @@\n-static inline bool should_do_cld_klass(const Klass* klass, bool leakp) {\n-  return klass != nullptr && _artifacts->should_do_cld_klass(klass, leakp);\n-}\n-\n-static inline KlassPtr get_cld_klass(CldPtr cld, bool leakp) {\n-  if (cld == nullptr) {\n-    return nullptr;\n-  }\n-  assert(leakp ? IS_LEAKP(cld) : used(cld), \"invariant\");\n-  KlassPtr cld_klass = cld->class_loader_klass();\n-  if (cld_klass == nullptr) {\n-    return nullptr;\n-  }\n-  if (should_do_cld_klass(cld_klass, leakp)) {\n-    if (current_epoch()) {\n-      \/\/ This will enqueue the klass, which is important for\n-      \/\/ reachability when doing clear and reset at rotation.\n-      JfrTraceId::load(cld_klass);\n-    } else {\n-      artifact_tag(cld_klass, leakp);\n-    }\n-    return cld_klass;\n-  }\n-  return nullptr;\n-}\n-\n@@ -176,0 +150,32 @@\n+static inline bool should_do_cld_klass(const Klass* cld_klass, bool leakp) {\n+  return cld_klass != nullptr && _artifacts->should_do_cld_klass(cld_klass, leakp);\n+}\n+\n+static inline bool should_enqueue(const Klass* cld_klass) {\n+  assert(cld_klass != nullptr, \"invariant\");\n+  if (previous_epoch()) {\n+    return false;\n+  }\n+  CldPtr cld = get_cld(cld_klass);\n+  return cld != nullptr && !cld->is_unloading();\n+}\n+\n+static inline KlassPtr get_cld_klass(CldPtr cld, bool leakp) {\n+  if (cld == nullptr) {\n+    return nullptr;\n+  }\n+  assert(leakp ? IS_LEAKP(cld) : used(cld), \"invariant\");\n+  KlassPtr cld_klass = cld->class_loader_klass();\n+  if (!should_do_cld_klass(cld_klass, leakp)) {\n+    return nullptr;\n+  }\n+  if (should_enqueue(cld_klass)) {\n+    \/\/ This will enqueue the klass, which is important for\n+    \/\/ reachability when doing clear and reset at rotation.\n+    JfrTraceId::load(cld_klass);\n+   } else {\n+     artifact_tag(cld_klass, leakp);\n+   }\n+   return cld_klass;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":32,"deletions":26,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -3040,0 +3040,7 @@\n+  if (!JVMCIENV->is_hotspot()) {\n+    \/\/ It's generally not safe to call Java code before the module system is initialized\n+    if (!Universe::is_module_initialized()) {\n+      JVMCI_event_1(\"callSystemExit(%d) before Universe::is_module_initialized() -> direct VM exit\", status);\n+      vm_exit_during_initialization();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -809,0 +809,7 @@\n+\n+  \/\/ Convert \"~a | ~b\" into \"~(a & b)\"\n+  if (AddNode::is_not(phase, in(1), T_INT) && AddNode::is_not(phase, in(2), T_INT)) {\n+    Node* and_a_b = new AndINode(in(1)->in(1), in(2)->in(1));\n+    Node* tn = phase->transform(and_a_b);\n+    return AddNode::make_not(phase, tn, T_INT);\n+  }\n@@ -875,0 +882,8 @@\n+\n+  \/\/ Convert \"~a | ~b\" into \"~(a & b)\"\n+  if (AddNode::is_not(phase, in(1), T_LONG) && AddNode::is_not(phase, in(2), T_LONG)) {\n+    Node* and_a_b = new AndLNode(in(1)->in(1), in(2)->in(1));\n+    Node* tn = phase->transform(and_a_b);\n+    return AddNode::make_not(phase, tn, T_LONG);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -284,0 +284,9 @@\n+CastIINode* CastIINode::pin_array_access_node() const {\n+  assert(_dependency == RegularDependency, \"already pinned\");\n+  if (has_range_check()) {\n+    return new CastIINode(in(0), in(1), bottom_type(), StrongDependency, has_range_check());\n+  }\n+  return nullptr;\n+}\n+\n+\n@@ -462,0 +471,1 @@\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  bool has_range_check() {\n+  bool has_range_check() const {\n@@ -126,0 +126,2 @@\n+  CastIINode* pin_array_access_node() const;\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -433,1 +433,0 @@\n-  Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn);\n@@ -435,0 +434,1 @@\n+  Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool pin_array_access_nodes);\n@@ -508,0 +508,2 @@\n+  void pin_array_access_nodes(PhaseIterGVN* igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4009,0 +4009,7 @@\n+    } else if (n->is_CallLeaf()) {\n+      \/\/ Runtime calls with narrow memory input (no MergeMem node)\n+      \/\/ get the memory projection\n+      n = n->as_Call()->proj_out_or_null(TypeFunc::Memory);\n+      if (n == nullptr) {\n+        continue;\n+      }\n@@ -4051,1 +4058,1 @@\n-      } else if (use->is_MemBar()) {\n+      } else if (use->is_MemBar() || use->is_CallLeaf()) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -542,1 +542,1 @@\n-static void adjust_check(Node* proj, Node* range, Node* index,\n+static void adjust_check(IfProjNode* proj, Node* range, Node* index,\n@@ -550,2 +550,2 @@\n-  DEBUG_ONLY( if( !bol->is_Bool() ) { proj->dump(3); fatal(\"Expect projection-->IfNode-->BoolNode\"); } )\n-  if( !bol->is_Bool() ) return;\n+  DEBUG_ONLY( if (!bol->is_Bool()) { proj->dump(3); fatal(\"Expect projection-->IfNode-->BoolNode\"); } )\n+  if (!bol->is_Bool()) return;\n@@ -556,2 +556,2 @@\n-  if( index ) {\n-    new_add = off_lo ? gvn->transform(new AddINode( index, new_add )) : index;\n+  if (index) {\n+    new_add = off_lo ? gvn->transform(new AddINode(index, new_add)) : index;\n@@ -560,2 +560,2 @@\n-    ? new CmpUNode( new_add, range )\n-    : new CmpUNode( range, new_add );\n+    ? new CmpUNode(new_add, range)\n+    : new CmpUNode(range, new_add);\n@@ -564,1 +564,1 @@\n-  if( new_cmp == cmp ) return;\n+  if (new_cmp == cmp) return;\n@@ -566,3 +566,9 @@\n-  Node *new_bol = gvn->transform( new BoolNode( new_cmp, bol->as_Bool()->_test._test ) );\n-  igvn->rehash_node_delayed( iff );\n-  iff->set_req_X( 1, new_bol, igvn );\n+  Node* new_bol = gvn->transform(new BoolNode(new_cmp, bol->as_Bool()->_test._test));\n+  igvn->rehash_node_delayed(iff);\n+  iff->set_req_X(1, new_bol, igvn);\n+  \/\/ As part of range check smearing, this range check is widened. Loads and range check Cast nodes that are control\n+  \/\/ dependent on this range check now depend on multiple dominating range checks. These control dependent nodes end up\n+  \/\/ at the lowest\/nearest dominating check in the graph. To ensure that these Loads\/Casts do not float above any of the\n+  \/\/ dominating checks (even when the lowest dominating check is later replaced by yet another dominating check), we\n+  \/\/ need to pin them at the lowest dominating check.\n+  proj->pin_array_access_nodes(igvn);\n@@ -1421,1 +1427,1 @@\n-  Node* ctl;\n+  IfProjNode* ctl;\n@@ -1489,1 +1495,1 @@\n-    return dominated_by(prev_dom, igvn);\n+    return dominated_by(prev_dom, igvn, false);\n@@ -1496,1 +1502,1 @@\n-Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {\n+Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool pin_array_access_nodes) {\n@@ -1509,9 +1515,0 @@\n-  \/\/ Loop predicates may have depending checks which should not\n-  \/\/ be skipped. For example, range check predicate has two checks\n-  \/\/ for lower and upper bounds.\n-  ProjNode* unc_proj = proj_out(1 - prev_dom->as_Proj()->_con)->as_Proj();\n-  if (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n-      unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr) {\n-    prev_dom = idom;\n-  }\n-\n@@ -1540,0 +1537,13 @@\n+        if (pin_array_access_nodes && data_target != top) {\n+          \/\/ As a result of range check smearing, Loads and range check Cast nodes that are control dependent on this\n+          \/\/ range check (that is about to be removed) now depend on multiple dominating range checks. After the removal\n+          \/\/ of this range check, these control dependent nodes end up at the lowest\/nearest dominating check in the\n+          \/\/ graph. To ensure that these Loads\/Casts do not float above any of the dominating checks (even when the\n+          \/\/ lowest dominating check is later replaced by yet another dominating check), we need to pin them at the\n+          \/\/ lowest dominating check.\n+          Node* clone = s->pin_array_access_node();\n+          if (clone != nullptr) {\n+            clone = igvn->transform(clone);\n+            igvn->replace_node(s, clone);\n+          }\n+        }\n@@ -1784,0 +1794,16 @@\n+void IfProjNode::pin_array_access_nodes(PhaseIterGVN* igvn) {\n+  for (DUIterator i = outs(); has_out(i); i++) {\n+    Node* u = out(i);\n+    if (!u->depends_only_on_test()) {\n+      continue;\n+    }\n+    Node* clone = u->pin_array_access_node();\n+    if (clone != nullptr) {\n+      clone = igvn->transform(clone);\n+      assert(clone != u, \"shouldn't common\");\n+      igvn->replace_node(u, clone);\n+      --i;\n+    }\n+  }\n+}\n+\n@@ -1875,0 +1901,40 @@\n+    \/\/\n+    \/\/ Example:\n+    \/\/ a[i+x] \/\/ (1) 1 < x < 6\n+    \/\/ a[i+3] \/\/ (2)\n+    \/\/ a[i+4] \/\/ (3)\n+    \/\/ a[i+6] \/\/ max = max of all constants\n+    \/\/ a[i+2]\n+    \/\/ a[i+1] \/\/ min = min of all constants\n+    \/\/\n+    \/\/ If x < 3:\n+    \/\/   (1) a[i+x]: Leave unchanged\n+    \/\/   (2) a[i+3]: Replace with a[i+max] = a[i+6]: i+x < i+3 <= i+6  -> (2) is covered\n+    \/\/   (3) a[i+4]: Replace with a[i+min] = a[i+1]: i+1 < i+4 <= i+6  -> (3) and all following checks are covered\n+    \/\/   Remove all other a[i+c] checks\n+    \/\/\n+    \/\/ If x >= 3:\n+    \/\/   (1) a[i+x]: Leave unchanged\n+    \/\/   (2) a[i+3]: Replace with a[i+min] = a[i+1]: i+1 < i+3 <= i+x  -> (2) is covered\n+    \/\/   (3) a[i+4]: Replace with a[i+max] = a[i+6]: i+1 < i+4 <= i+6  -> (3) and all following checks are covered\n+    \/\/   Remove all other a[i+c] checks\n+    \/\/\n+    \/\/ We only need the top 2 range checks if x is the min or max of all constants.\n+    \/\/\n+    \/\/ This, however, only works if the interval [i+min,i+max] is not larger than max_int (i.e. abs(max - min) < max_int):\n+    \/\/ The theoretical max size of an array is max_int with:\n+    \/\/ - Valid index space: [0,max_int-1]\n+    \/\/ - Invalid index space: [max_int,-1] \/\/ max_int, min_int, min_int - 1 ..., -1\n+    \/\/\n+    \/\/ The size of the consecutive valid index space is smaller than the size of the consecutive invalid index space.\n+    \/\/ If we choose min and max in such a way that:\n+    \/\/ - abs(max - min) < max_int\n+    \/\/ - i+max and i+min are inside the valid index space\n+    \/\/ then all indices [i+min,i+max] must be in the valid index space. Otherwise, the invalid index space must be\n+    \/\/ smaller than the valid index space which is never the case for any array size.\n+    \/\/\n+    \/\/ Choosing a smaller array size only makes the valid index space smaller and the invalid index space larger and\n+    \/\/ the argument above still holds.\n+    \/\/\n+    \/\/ Note that the same optimization with the same maximal accepted interval size can also be found in C1.\n+    const jlong maximum_number_of_min_max_interval_indices = (jlong)max_jint;\n@@ -1909,7 +1975,12 @@\n-          \/\/ Gather expanded bounds\n-          off_lo = MIN2(off_lo,offset2);\n-          off_hi = MAX2(off_hi,offset2);\n-          \/\/ Record top NRC range checks\n-          prev_checks[nb_checks%NRC].ctl = prev_dom;\n-          prev_checks[nb_checks%NRC].off = offset2;\n-          nb_checks++;\n+\n+          \/\/ \"x - y\" -> must add one to the difference for number of elements in [x,y]\n+          const jlong diff = (jlong)MIN2(offset2, off_lo) - (jlong)MAX2(offset2, off_hi);\n+          if (ABS(diff) < maximum_number_of_min_max_interval_indices) {\n+            \/\/ Gather expanded bounds\n+            off_lo = MIN2(off_lo, offset2);\n+            off_hi = MAX2(off_hi, offset2);\n+            \/\/ Record top NRC range checks\n+            prev_checks[nb_checks % NRC].ctl = prev_dom->as_IfProj();\n+            prev_checks[nb_checks % NRC].off = offset2;\n+            nb_checks++;\n+          }\n@@ -1930,0 +2001,9 @@\n+      if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+        \/\/ We are about to perform range check smearing (i.e. remove this RangeCheck if it is dominated by\n+        \/\/ a series of RangeChecks which have a range that covers this RangeCheck). This can cause array access nodes to\n+        \/\/ be pinned. We want to avoid that and first allow range check elimination a chance to remove the RangeChecks\n+        \/\/ from loops. Hence, we delay range check smearing until after loop opts.\n+        phase->C->record_for_post_loop_opts_igvn(this);\n+        return nullptr;\n+      }\n+\n@@ -2003,0 +2083,20 @@\n+      \/\/ The last RangeCheck is found to be redundant with a sequence of n (n >= 2) preceding RangeChecks.\n+      \/\/ If an array load is control dependent on the eliminated range check, the array load nodes (CastII and Load)\n+      \/\/ become control dependent on the last range check of the sequence, but they are really dependent on the entire\n+      \/\/ sequence of RangeChecks. If RangeCheck#n is later replaced by a dominating identical check, the array load\n+      \/\/ nodes must not float above the n-1 other RangeCheck in the sequence. We pin the array load nodes here to\n+      \/\/ guarantee it doesn't happen.\n+      \/\/\n+      \/\/ RangeCheck#1                 RangeCheck#1\n+      \/\/    |      \\                     |      \\\n+      \/\/    |      uncommon trap         |      uncommon trap\n+      \/\/    ..                           ..\n+      \/\/ RangeCheck#n              -> RangeCheck#n\n+      \/\/    |      \\                     |      \\\n+      \/\/    |      uncommon trap        CastII  uncommon trap\n+      \/\/ RangeCheck                     Load\n+      \/\/    |      \\\n+      \/\/   CastII  uncommon trap\n+      \/\/   Load\n+\n+      return dominated_by(prev_dom, igvn, true);\n@@ -2013,1 +2113,1 @@\n-  return dominated_by(prev_dom, igvn);\n+  return dominated_by(prev_dom, igvn, false);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":131,"deletions":31,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -4575,1 +4575,1 @@\n-  \/\/ Test the header to see if it is unlocked.\n+  \/\/ Test the header to see if it is safe to read w.r.t. locking.\n@@ -4578,3 +4578,4 @@\n-  Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);\n-  Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));\n-  Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n@@ -4582,1 +4583,8 @@\n-  generate_slow_guard(test_unlocked, slow_region);\n+    generate_slow_guard(test_monitor, slow_region);\n+  } else {\n+    Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n+    Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n+    Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+\n+    generate_slow_guard(test_not_unlocked, slow_region);\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -853,2 +853,2 @@\n-    idx_type = (TypeInt*)mul->mul_ring(idx_type, scale_type);\n-    if (overflow || TypeInt::INT->higher_equal(idx_type)) {\n+\n+    if (overflow || MulINode::does_overflow(idx_type, scale_type)) {\n@@ -856,0 +856,1 @@\n+      idx_type = TypeInt::INT;\n@@ -868,0 +869,1 @@\n+      idx_type = (TypeInt*)mul->mul_ring(idx_type, scale_type);\n@@ -1183,0 +1185,1 @@\n+  bool range_check_predicate = false;\n@@ -1215,0 +1218,1 @@\n+    range_check_predicate = true;\n@@ -1297,1 +1301,4 @@\n-  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con);\n+  \/\/ If a range check is eliminated, data dependent nodes (Load and range check CastII nodes) are now dependent on 2\n+  \/\/ Hoisted Check Predicates (one for the start of the loop, one for the end) but we can only keep track of one control\n+  \/\/ dependency: pin the data dependent nodes.\n+  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con, range_check_predicate);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n@@ -999,1 +1001,1 @@\n-  \/\/ Also count ModL, DivL and MulL which expand mightly\n+  \/\/ Also count ModL, DivL, MulL, and other nodes that expand mightly\n@@ -1002,0 +1004,3 @@\n+    if (MemNode::barrier_data(n) != 0) {\n+      body_size += BarrierSet::barrier_set()->barrier_set_c2()->estimated_barrier_size(n);\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  dominated_by(proj_true->as_IfProj(), unswitch_iff, false, false);\n+  dominated_by(proj_true->as_IfProj(), unswitch_iff);\n@@ -187,1 +187,1 @@\n-  dominated_by(proj_false->as_IfProj(), unswitch_iff_clone, false, false);\n+  dominated_by(proj_false->as_IfProj(), unswitch_iff_clone);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -494,3 +494,3 @@\n-static int check_stride_overflow(jlong stride_con, const TypeInteger* limit_t, BasicType bt) {\n-  if (stride_con > 0) {\n-    if (limit_t->lo_as_long() > (max_signed_integer(bt) - stride_con)) {\n+static int check_stride_overflow(jlong final_correction, const TypeInteger* limit_t, BasicType bt) {\n+  if (final_correction > 0) {\n+    if (limit_t->lo_as_long() > (max_signed_integer(bt) - final_correction)) {\n@@ -499,1 +499,1 @@\n-    if (limit_t->hi_as_long() > (max_signed_integer(bt) - stride_con)) {\n+    if (limit_t->hi_as_long() > (max_signed_integer(bt) - final_correction)) {\n@@ -503,1 +503,1 @@\n-    if (limit_t->hi_as_long() < (min_signed_integer(bt) - stride_con)) {\n+    if (limit_t->hi_as_long() < (min_signed_integer(bt) - final_correction)) {\n@@ -506,1 +506,1 @@\n-    if (limit_t->lo_as_long() < (min_signed_integer(bt) - stride_con)) {\n+    if (limit_t->lo_as_long() < (min_signed_integer(bt) - final_correction)) {\n@@ -1776,2 +1776,109 @@\n-  \/\/ Generate loop limit check to avoid integer overflow\n-  \/\/ in cases like next (cyclic loops):\n+  \/\/ We can only convert this loop to a counted loop if we can guarantee that the iv phi will never overflow at runtime.\n+  \/\/ This is an implicit assumption taken by some loop optimizations. We therefore must ensure this property at all cost.\n+  \/\/ At this point, we've already excluded some trivial cases where an overflow could have been proven statically.\n+  \/\/ But even though we cannot prove that an overflow will *not* happen, we still want to speculatively convert this loop\n+  \/\/ to a counted loop. This can be achieved by adding additional iv phi overflow checks before the loop. If they fail,\n+  \/\/ we trap and resume execution before the loop without having executed any iteration of the loop, yet.\n+  \/\/\n+  \/\/ These additional iv phi overflow checks can be inserted as Loop Limit Check Predicates above the Loop Limit Check\n+  \/\/ Parse Predicate which captures a JVM state just before the entry of the loop. If there is no such Parse Predicate,\n+  \/\/ we cannot generate a Loop Limit Check Predicate and thus cannot speculatively convert the loop to a counted loop.\n+  \/\/\n+  \/\/ In the following, we only focus on int loops with stride > 0 to keep things simple. The argumentation and proof\n+  \/\/ for stride < 0 is analogously. For long loops, we would replace max_int with max_long.\n+  \/\/\n+  \/\/\n+  \/\/ The loop to be converted does not always need to have the often used shape:\n+  \/\/\n+  \/\/                                                 i = init\n+  \/\/     i = init                                loop:\n+  \/\/     do {                                        ...\n+  \/\/         \/\/ ...               equivalent         i+=stride\n+  \/\/         i+=stride               <==>            if (i < limit)\n+  \/\/     } while (i < limit);                          goto loop\n+  \/\/                                             exit:\n+  \/\/                                                 ...\n+  \/\/\n+  \/\/ where the loop exit check uses the post-incremented iv phi and a '<'-operator.\n+  \/\/\n+  \/\/ We could also have '<='-operator (or '>='-operator for negative strides) or use the pre-incremented iv phi value\n+  \/\/ in the loop exit check:\n+  \/\/\n+  \/\/         i = init\n+  \/\/     loop:\n+  \/\/         ...\n+  \/\/         if (i <= limit)\n+  \/\/             i+=stride\n+  \/\/             goto loop\n+  \/\/     exit:\n+  \/\/         ...\n+  \/\/\n+  \/\/ Let's define the following terms:\n+  \/\/ - iv_pre_i: The pre-incremented iv phi before the i-th iteration.\n+  \/\/ - iv_post_i: The post-incremented iv phi after the i-th iteration.\n+  \/\/\n+  \/\/ The iv_pre_i and iv_post_i have the following relation:\n+  \/\/      iv_pre_i + stride = iv_post_i\n+  \/\/\n+  \/\/ When converting a loop to a counted loop, we want to have a canonicalized loop exit check of the form:\n+  \/\/     iv_post_i < adjusted_limit\n+  \/\/\n+  \/\/ If that is not the case, we need to canonicalize the loop exit check by using different values for adjusted_limit:\n+  \/\/ (LE1) iv_post_i < limit: Already canonicalized. We can directly use limit as adjusted_limit.\n+  \/\/           -> adjusted_limit = limit.\n+  \/\/ (LE2) iv_post_i <= limit:\n+  \/\/           iv_post_i < limit + 1\n+  \/\/           -> adjusted limit = limit + 1\n+  \/\/ (LE3) iv_pre_i < limit:\n+  \/\/           iv_pre_i + stride < limit + stride\n+  \/\/           iv_post_i < limit + stride\n+  \/\/           -> adjusted_limit = limit + stride\n+  \/\/ (LE4) iv_pre_i <= limit:\n+  \/\/           iv_pre_i < limit + 1\n+  \/\/           iv_pre_i + stride < limit + stride + 1\n+  \/\/           iv_post_i < limit + stride + 1\n+  \/\/           -> adjusted_limit = limit + stride + 1\n+  \/\/\n+  \/\/ Note that:\n+  \/\/     (AL) limit <= adjusted_limit.\n+  \/\/\n+  \/\/ The following loop invariant has to hold for counted loops with n iterations (i.e. loop exit check true after n-th\n+  \/\/ loop iteration) and a canonicalized loop exit check to guarantee that no iv_post_i over- or underflows:\n+  \/\/ (INV) For i = 1..n, min_int <= iv_post_i <= max_int\n+  \/\/\n+  \/\/ To prove (INV), we require the following two conditions\/assumptions:\n+  \/\/ (i): adjusted_limit - 1 + stride <= max_int\n+  \/\/ (ii): init < limit\n+  \/\/\n+  \/\/ If we can prove (INV), we know that there can be no over- or underflow of any iv phi value. We prove (INV) by\n+  \/\/ induction by assuming (i) and (ii).\n+  \/\/\n+  \/\/ Proof by Induction\n+  \/\/ ------------------\n+  \/\/ > Base case (i = 1): We show that (INV) holds after the first iteration:\n+  \/\/     min_int <= iv_post_1 = init + stride <= max_int\n+  \/\/ Proof:\n+  \/\/     First, we note that (ii) implies\n+  \/\/         (iii) init <= limit - 1\n+  \/\/     max_int >= adjusted_limit - 1 + stride   [using (i)]\n+  \/\/             >= limit - 1 + stride            [using (AL)]\n+  \/\/             >= init + stride                 [using (iii)]\n+  \/\/             >= min_int                       [using stride > 0, no underflow]\n+  \/\/ Thus, no overflow happens after the first iteration and (INV) holds for i = 1.\n+  \/\/\n+  \/\/ Note that to prove the base case we need (i) and (ii).\n+  \/\/\n+  \/\/ > Induction Hypothesis (i = j, j > 1): Assume that (INV) holds after the j-th iteration:\n+  \/\/     min_int <= iv_post_j <= max_int\n+  \/\/ > Step case (i = j + 1): We show that (INV) also holds after the j+1-th iteration:\n+  \/\/     min_int <= iv_post_{j+1} = iv_post_j + stride <= max_int\n+  \/\/ Proof:\n+  \/\/ If iv_post_j >= adjusted_limit:\n+  \/\/     We exit the loop after the j-th iteration, and we don't execute the j+1-th iteration anymore. Thus, there is\n+  \/\/     also no iv_{j+1}. Since (INV) holds for iv_j, there is nothing left to prove.\n+  \/\/ If iv_post_j < adjusted_limit:\n+  \/\/     First, we note that:\n+  \/\/         (iv) iv_post_j <= adjusted_limit - 1\n+  \/\/     max_int >= adjusted_limit - 1 + stride    [using (i)]\n+  \/\/             >= iv_post_j + stride             [using (iv)]\n+  \/\/             >= min_int                        [using stride > 0, no underflow]\n@@ -1779,2 +1886,1 @@\n-  \/\/ for (i=0; i <= max_jint; i++) {}\n-  \/\/ for (i=0; i <  max_jint; i+=2) {}\n+  \/\/ Note that to prove the step case we only need (i).\n@@ -1782,0 +1888,1 @@\n+  \/\/ Thus, by assuming (i) and (ii), we proved (INV).\n@@ -1783,1 +1890,0 @@\n-  \/\/ Limit check predicate depends on the loop test:\n@@ -1785,3 +1891,1 @@\n-  \/\/ for(;i != limit; i++)       --> limit <= (max_jint)\n-  \/\/ for(;i <  limit; i+=stride) --> limit <= (max_jint - stride + 1)\n-  \/\/ for(;i <= limit; i+=stride) --> limit <= (max_jint - stride    )\n+  \/\/ It is therefore enough to add the following two Loop Limit Check Predicates to check assumptions (i) and (ii):\n@@ -1789,0 +1893,52 @@\n+  \/\/ (1) Loop Limit Check Predicate for (i):\n+  \/\/     Using (i): adjusted_limit - 1 + stride <= max_int\n+  \/\/\n+  \/\/     This condition is now restated to use limit instead of adjusted_limit:\n+  \/\/\n+  \/\/     To prevent an overflow of adjusted_limit -1 + stride itself, we rewrite this check to\n+  \/\/         max_int - stride + 1 >= adjusted_limit\n+  \/\/     We can merge the two constants into\n+  \/\/         canonicalized_correction = stride - 1\n+  \/\/     which gives us\n+  \/\/        max_int - canonicalized_correction >= adjusted_limit\n+  \/\/\n+  \/\/     To directly use limit instead of adjusted_limit in the predicate condition, we split adjusted_limit into:\n+  \/\/         adjusted_limit = limit + limit_correction\n+  \/\/     Since stride > 0 and limit_correction <= stride + 1, we can restate this with no over- or underflow into:\n+  \/\/         max_int - canonicalized_correction - limit_correction >= limit\n+  \/\/     Since canonicalized_correction and limit_correction are both constants, we can replace them with a new constant:\n+  \/\/         final_correction = canonicalized_correction + limit_correction\n+  \/\/     which gives us:\n+  \/\/\n+  \/\/     Final predicate condition:\n+  \/\/         max_int - final_correction >= limit\n+  \/\/\n+  \/\/ (2) Loop Limit Check Predicate for (ii):\n+  \/\/     Using (ii): init < limit\n+  \/\/\n+  \/\/     This Loop Limit Check Predicate is not required if we can prove at compile time that either:\n+  \/\/        (2.1) type(init) < type(limit)\n+  \/\/             In this case, we know:\n+  \/\/                 all possible values of init < all possible values of limit\n+  \/\/             and we can skip the predicate.\n+  \/\/\n+  \/\/        (2.2) init < limit is already checked before (i.e. found as a dominating check)\n+  \/\/            In this case, we do not need to re-check the condition and can skip the predicate.\n+  \/\/            This is often found for while- and for-loops which have the following shape:\n+  \/\/\n+  \/\/                if (init < limit) { \/\/ Dominating test. Do not need the Loop Limit Check Predicate below.\n+  \/\/                    i = init;\n+  \/\/                    if (init >= limit) { trap(); } \/\/ Here we would insert the Loop Limit Check Predicate\n+  \/\/                    do {\n+  \/\/                        i += stride;\n+  \/\/                    } while (i < limit);\n+  \/\/                }\n+  \/\/\n+  \/\/        (2.3) init + stride <= max_int\n+  \/\/            In this case, there is no overflow of the iv phi after the first loop iteration.\n+  \/\/            In the proof of the base case above we showed that init + stride <= max_int by using assumption (ii):\n+  \/\/                init < limit\n+  \/\/            In the proof of the step case above, we did not need (ii) anymore. Therefore, if we already know at\n+  \/\/            compile time that init + stride <= max_int then we have trivially proven the base case and that\n+  \/\/            there is no overflow of the iv phi after the first iteration. In this case, we don't need to check (ii)\n+  \/\/            again and can skip the predicate.\n@@ -1790,3 +1946,0 @@\n-  \/\/ Check if limit is excluded to do more precise int overflow check.\n-  bool incl_limit = (bt == BoolTest::le || bt == BoolTest::ge);\n-  jlong stride_m  = stride_con - (incl_limit ? 0 : (stride_con > 0 ? 1 : -1));\n@@ -1794,8 +1947,2 @@\n-  \/\/ If compare points directly to the phi we need to adjust\n-  \/\/ the compare so that it points to the incr. Limit have\n-  \/\/ to be adjusted to keep trip count the same and the\n-  \/\/ adjusted limit should be checked for int overflow.\n-  Node* adjusted_limit = limit;\n-  if (phi_incr != nullptr) {\n-    stride_m  += stride_con;\n-  }\n+  \/\/ Accounting for (LE3) and (LE4) where we use pre-incremented phis in the loop exit check.\n+  const jlong limit_correction_for_pre_iv_exit_check = (phi_incr != nullptr) ? stride_con : 0;\n@@ -1803,1 +1950,10 @@\n-  Node *init_control = x->in(LoopNode::EntryControl);\n+  \/\/ Accounting for (LE2) and (LE4) where we use <= or >= in the loop exit check.\n+  const bool includes_limit = (bt == BoolTest::le || bt == BoolTest::ge);\n+  const jlong limit_correction_for_le_ge_exit_check = (includes_limit ? (stride_con > 0 ? 1 : -1) : 0);\n+\n+  const jlong limit_correction = limit_correction_for_pre_iv_exit_check + limit_correction_for_le_ge_exit_check;\n+  const jlong canonicalized_correction = stride_con + (stride_con > 0 ? -1 : 1);\n+  const jlong final_correction = canonicalized_correction + limit_correction;\n+\n+  int sov = check_stride_overflow(final_correction, limit_t, iv_bt);\n+  Node* init_control = x->in(LoopNode::EntryControl);\n@@ -1805,1 +1961,0 @@\n-  int sov = check_stride_overflow(stride_m, limit_t, iv_bt);\n@@ -1812,0 +1967,2 @@\n+    \/\/ (1) Loop Limit Check Predicate is required because we could not statically prove that\n+    \/\/     limit + final_correction = adjusted_limit - 1 + stride <= max_int\n@@ -1813,2 +1970,0 @@\n-    \/\/ Generate loop's limit check.\n-    \/\/ Loop limit check predicate should be near the loop.\n@@ -1818,1 +1973,1 @@\n-      \/\/ The limit check predicate is not generated if this method trapped here before.\n+      \/\/ The Loop Limit Check Parse Predicate is not generated if this method trapped here before.\n@@ -1838,1 +1993,1 @@\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_signed_integer(iv_bt) - stride_m, iv_bt), iv_bt);\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_signed_integer(iv_bt) - final_correction, iv_bt), iv_bt);\n@@ -1841,1 +1996,1 @@\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_signed_integer(iv_bt) - stride_m, iv_bt), iv_bt);\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_signed_integer(iv_bt) - final_correction, iv_bt), iv_bt);\n@@ -1848,14 +2003,24 @@\n-  \/\/ Now we need to canonicalize loop condition.\n-  if (bt == BoolTest::ne) {\n-    assert(stride_con == 1 || stride_con == -1, \"simple increment only\");\n-    if (stride_con > 0 && init_t->hi_as_long() < limit_t->lo_as_long()) {\n-      \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n-      bt = BoolTest::lt;\n-    } else if (stride_con < 0 && init_t->lo_as_long() > limit_t->hi_as_long()) {\n-      \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n-      bt = BoolTest::gt;\n-    } else {\n-      const Predicates predicates(init_control);\n-      const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n-      if (!loop_limit_check_predicate_block->has_parse_predicate()) {\n-        \/\/ The limit check predicate is not generated if this method trapped here before.\n+  \/\/ (2.3)\n+  const bool init_plus_stride_could_overflow =\n+          (stride_con > 0 && init_t->hi_as_long() > max_signed_integer(iv_bt) - stride_con) ||\n+          (stride_con < 0 && init_t->lo_as_long() < min_signed_integer(iv_bt) - stride_con);\n+  \/\/ (2.1)\n+  const bool init_gte_limit = (stride_con > 0 && init_t->hi_as_long() >= limit_t->lo_as_long()) ||\n+                              (stride_con < 0 && init_t->lo_as_long() <= limit_t->hi_as_long());\n+\n+  if (init_gte_limit && \/\/ (2.1)\n+     ((bt == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n+      !has_dominating_loop_limit_check(init_trip, limit, stride_con, iv_bt, init_control))) { \/\/ (2.2)\n+    \/\/ (2) Iteration Loop Limit Check Predicate is required because neither (2.1), (2.2), nor (2.3) holds.\n+    \/\/ We use the following condition:\n+    \/\/ - stride > 0: init < limit\n+    \/\/ - stride < 0: init > limit\n+    \/\/\n+    \/\/ This predicate is always required if we have a non-equal-operator in the loop exit check (where stride = 1 is\n+    \/\/ a requirement). We transform the loop exit check by using a less-than-operator. By doing so, we must always\n+    \/\/ check that init < limit. Otherwise, we could have a different number of iterations at runtime.\n+\n+    const Predicates predicates(init_control);\n+    const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+    if (!loop_limit_check_predicate_block->has_parse_predicate()) {\n+      \/\/ The Loop Limit Check Parse Predicate is not generated if this method trapped here before.\n@@ -1863,7 +2028,4 @@\n-        if (TraceLoopLimitCheck) {\n-          tty->print(\"Missing Loop Limit Check Parse Predicate:\");\n-          loop->dump_head();\n-          x->dump(1);\n-        }\n-#endif\n-        return false;\n+      if (TraceLoopLimitCheck) {\n+        tty->print(\"Missing Loop Limit Check Parse Predicate:\");\n+        loop->dump_head();\n+        x->dump(1);\n@@ -1871,0 +2033,3 @@\n+#endif\n+      return false;\n+    }\n@@ -1872,6 +2037,6 @@\n-      ParsePredicateNode* loop_limit_check_parse_predicate = loop_limit_check_predicate_block->parse_predicate();\n-      Node* parse_predicate_entry = loop_limit_check_parse_predicate->in(0);\n-      if (!is_dominator(get_ctrl(limit), parse_predicate_entry) ||\n-          !is_dominator(get_ctrl(init_trip), parse_predicate_entry)) {\n-        return false;\n-      }\n+    ParsePredicateNode* loop_limit_check_parse_predicate = loop_limit_check_predicate_block->parse_predicate();\n+    Node* parse_predicate_entry = loop_limit_check_parse_predicate->in(0);\n+    if (!is_dominator(get_ctrl(limit), parse_predicate_entry) ||\n+        !is_dominator(get_ctrl(init_trip), parse_predicate_entry)) {\n+      return false;\n+    }\n@@ -1879,2 +2044,2 @@\n-      Node* cmp_limit;\n-      Node* bol;\n+    Node* cmp_limit;\n+    Node* bol;\n@@ -1882,7 +2047,7 @@\n-      if (stride_con > 0) {\n-        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n-        bol = new BoolNode(cmp_limit, BoolTest::lt);\n-      } else {\n-        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n-        bol = new BoolNode(cmp_limit, BoolTest::gt);\n-      }\n+    if (stride_con > 0) {\n+      cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n+      bol = new BoolNode(cmp_limit, BoolTest::lt);\n+    } else {\n+      cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n+      bol = new BoolNode(cmp_limit, BoolTest::gt);\n+    }\n@@ -1890,1 +2055,2 @@\n-      insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+  }\n@@ -1892,7 +2058,10 @@\n-      if (stride_con > 0) {\n-        \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n-        bt = BoolTest::lt;\n-      } else if (stride_con < 0) {\n-        \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n-        bt = BoolTest::gt;\n-      }\n+  if (bt == BoolTest::ne) {\n+    \/\/ Now we need to canonicalize the loop condition if it is 'ne'.\n+    assert(stride_con == 1 || stride_con == -1, \"simple increment only - checked before\");\n+    if (stride_con > 0) {\n+      \/\/ 'ne' can be replaced with 'lt' only when init < limit. This is ensured by the inserted predicate above.\n+      bt = BoolTest::lt;\n+    } else {\n+      assert(stride_con < 0, \"must be\");\n+      \/\/ 'ne' can be replaced with 'gt' only when init > limit. This is ensured by the inserted predicate above.\n+      bt = BoolTest::gt;\n@@ -1943,0 +2112,1 @@\n+  Node* adjusted_limit = limit;\n@@ -1956,1 +2126,1 @@\n-  if (incl_limit) {\n+  if (includes_limit) {\n@@ -2137,0 +2307,31 @@\n+\/\/ Check if there is a dominating loop limit check of the form 'init < limit' starting at the loop entry.\n+\/\/ If there is one, then we do not need to create an additional Loop Limit Check Predicate.\n+bool PhaseIdealLoop::has_dominating_loop_limit_check(Node* init_trip, Node* limit, const jlong stride_con,\n+                                                     const BasicType iv_bt, Node* loop_entry) {\n+  \/\/ Eagerly call transform() on the Cmp and Bool node to common them up if possible. This is required in order to\n+  \/\/ successfully find a dominated test with the If node below.\n+  Node* cmp_limit;\n+  Node* bol;\n+  if (stride_con > 0) {\n+    cmp_limit = _igvn.transform(CmpNode::make(init_trip, limit, iv_bt));\n+    bol = _igvn.transform(new BoolNode(cmp_limit, BoolTest::lt));\n+  } else {\n+    cmp_limit = _igvn.transform(CmpNode::make(init_trip, limit, iv_bt));\n+    bol = _igvn.transform(new BoolNode(cmp_limit, BoolTest::gt));\n+  }\n+\n+  \/\/ Check if there is already a dominating init < limit check. If so, we do not need a Loop Limit Check Predicate.\n+  IfNode* iff = new IfNode(loop_entry, bol, PROB_MIN, COUNT_UNKNOWN);\n+  \/\/ Also add fake IfProj nodes in order to call transform() on the newly created IfNode.\n+  IfFalseNode* if_false = new IfFalseNode(iff);\n+  IfTrueNode* if_true = new IfTrueNode(iff);\n+  Node* dominated_iff = _igvn.transform(iff);\n+  \/\/ ConI node? Found dominating test (IfNode::dominated_by() returns a ConI node).\n+  const bool found_dominating_test = dominated_iff != nullptr && dominated_iff->is_ConI();\n+\n+  \/\/ Kill the If with its projections again in the next IGVN round by cutting it off from the graph.\n+  _igvn.replace_input_of(iff, 0, C->top());\n+  _igvn.replace_input_of(iff, 1, C->top());\n+  return found_dominating_test;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":278,"deletions":77,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -1349,0 +1349,2 @@\n+  bool has_dominating_loop_limit_check(Node* init_trip, Node* limit, jlong stride_con, BasicType iv_bt,\n+                                       Node* loop_entry);\n@@ -1510,1 +1512,1 @@\n-  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool exclude_loop_predicate = false);\n+  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool pin_array_access_nodes = false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -290,1 +290,5 @@\n-  assert(n->in(0) == nullptr, \"divisions with zero check should already have bailed out earlier in split-if\");\n+  if (n->in(0) != nullptr) {\n+    \/\/ Cannot split through phi if Div or Mod node has a control dependency to a zero check.\n+    return true;\n+  }\n+\n@@ -308,1 +312,1 @@\n-void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool exclude_loop_predicate) {\n+void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool pin_array_access_nodes) {\n@@ -333,1 +337,1 @@\n-  \/\/ If I dont have a reachable TRUE and FALSE path following the IfNode then\n+  \/\/ If I don't have a reachable TRUE and FALSE path following the IfNode then\n@@ -344,3 +348,0 @@\n-  \/\/ Loop predicates may have depending checks which should not\n-  \/\/ be skipped. For example, range check predicate has two checks\n-  \/\/ for lower and upper bounds.\n@@ -350,12 +351,0 @@\n-  ProjNode* dp_proj  = dp->as_Proj();\n-  ProjNode* unc_proj = iff->proj_out(1 - dp_proj->_con)->as_Proj();\n-  if (exclude_loop_predicate &&\n-      (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n-       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr ||\n-       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check) != nullptr)) {\n-    \/\/ If this is a range check (IfNode::is_range_check), do not\n-    \/\/ reorder because Compile::allow_range_check_smearing might have\n-    \/\/ changed the check.\n-    return; \/\/ Let IGVN transformation change control dependence.\n-  }\n-\n@@ -370,0 +359,14 @@\n+      if (pin_array_access_nodes) {\n+        \/\/ Because of Loop Predication, Loads and range check Cast nodes that are control dependent on this range\n+        \/\/ check (that is about to be removed) now depend on multiple dominating Hoisted Check Predicates. After the\n+        \/\/ removal of this range check, these control dependent nodes end up at the lowest\/nearest dominating predicate\n+        \/\/ in the graph. To ensure that these Loads\/Casts do not float above any of the dominating checks (even when the\n+        \/\/ lowest dominating check is later replaced by yet another dominating check), we need to pin them at the lowest\n+        \/\/ dominating check.\n+        Node* clone = cd->pin_array_access_node();\n+        if (clone != nullptr) {\n+          clone = _igvn.register_new_node_with_optimizer(clone, cd);\n+          _igvn.replace_node(cd, clone);\n+          cd = clone;\n+        }\n+      }\n@@ -1489,1 +1492,1 @@\n-          dominated_by(prevdom->as_IfProj(), n->as_If(), false, true);\n+          dominated_by(prevdom->as_IfProj(), n->as_If());\n@@ -1582,1 +1585,1 @@\n-        dominated_by(dom_proj_true->as_IfProj(), new_false_region->in(i)->in(0)->as_If(), false, false);\n+        dominated_by(dom_proj_true->as_IfProj(), new_false_region->in(i)->in(0)->as_If());\n@@ -1585,1 +1588,1 @@\n-        dominated_by(dom_proj_false->as_IfProj(), new_false_region->in(i)->in(0)->as_If(), false, false);\n+        dominated_by(dom_proj_false->as_IfProj(), new_false_region->in(i)->in(0)->as_If());\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -842,0 +842,9 @@\n+uint8_t MemNode::barrier_data(const Node* n) {\n+  if (n->is_LoadStore()) {\n+    return n->as_LoadStore()->barrier_data();\n+  } else if (n->is_Mem()) {\n+    return n->as_Mem()->barrier_data();\n+  }\n+  return 0;\n+}\n+\n@@ -848,2 +857,6 @@\n-bool LoadNode::cmp( const Node &n ) const\n-{ return !Type::cmp( _type, ((LoadNode&)n)._type ); }\n+bool LoadNode::cmp(const Node &n) const {\n+  LoadNode& load = (LoadNode &)n;\n+  return !Type::cmp(_type, load._type) &&\n+         _control_dependency == load._control_dependency &&\n+         _mo == load._mo;\n+}\n@@ -986,0 +999,8 @@\n+LoadNode* LoadNode::pin_array_access_node() const {\n+  const TypePtr* adr_type = this->adr_type();\n+  if (adr_type != nullptr && adr_type->isa_aryptr()) {\n+    return clone_pinned();\n+  }\n+  return nullptr;\n+}\n+\n@@ -1005,1 +1026,2 @@\n-    LoadNode* ld = clone()->as_Load();\n+    \/\/ load depends on the tests that validate the arraycopy\n+    LoadNode* ld = clone_pinned();\n@@ -1047,2 +1069,0 @@\n-    \/\/ load depends on the tests that validate the arraycopy\n-    ld->_control_dependency = UnknownControl;\n@@ -2502,0 +2522,6 @@\n+LoadNode* LoadNode::clone_pinned() const {\n+  LoadNode* ld = clone()->as_Load();\n+  ld->_control_dependency = UnknownControl;\n+  return ld;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -129,0 +129,3 @@\n+  \/\/ Return the barrier data of n, if available, or 0 otherwise.\n+  static uint8_t barrier_data(const Node* n);\n+\n@@ -295,0 +298,2 @@\n+  LoadNode* pin_array_access_node() const;\n+\n@@ -320,0 +325,2 @@\n+\n+  LoadNode* clone_pinned() const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -284,1 +284,2 @@\n-\/\/ Classes to perform mul_ring() for MulI\/MulLNode.\n+\/\/ This template class performs type multiplication for MulI\/MulLNode. NativeType is either jint or jlong.\n+\/\/ In this class, the inputs of the MulNodes are named left and right with types [left_lo,left_hi] and [right_lo,right_hi].\n@@ -286,4 +287,4 @@\n-\/\/ This class checks if all cross products of the left and right input of a multiplication have the same \"overflow value\".\n-\/\/ Without overflow\/underflow:\n-\/\/ Product is positive? High signed multiplication result: 0\n-\/\/ Product is negative? High signed multiplication result: -1\n+\/\/ In general, the multiplication of two x-bit values could produce a result that consumes up to 2x bits if there is\n+\/\/ enough space to hold them all. We can therefore distinguish the following two cases for the product:\n+\/\/ - no overflow (i.e. product fits into x bits)\n+\/\/ - overflow (i.e. product does not fit into x bits)\n@@ -291,8 +292,55 @@\n-\/\/ We normalize these values (see normalize_overflow_value()) such that we get the same \"overflow value\" by adding 1 if\n-\/\/ the product is negative. This allows us to compare all the cross product \"overflow values\". If one is different,\n-\/\/ compared to the others, then we know that this multiplication has a different number of over- or underflows compared\n-\/\/ to the others. In this case, we need to use bottom type and cannot guarantee a better type. Otherwise, we can take\n-\/\/ the min und max of all computed cross products as type of this Mul node.\n-template<typename IntegerType>\n-class IntegerMulRing {\n-  using NativeType = std::conditional_t<std::is_same<TypeInt, IntegerType>::value, jint, jlong>;\n+\/\/ When multiplying the two x-bit inputs 'left' and 'right' with their x-bit types [left_lo,left_hi] and [right_lo,right_hi]\n+\/\/ we need to find the minimum and maximum of all possible products to define a new type. To do that, we compute the\n+\/\/ cross product of [left_lo,left_hi] and [right_lo,right_hi] in 2x-bit space where no over- or underflow can happen.\n+\/\/ The cross product consists of the following four multiplications with 2x-bit results:\n+\/\/ (1) left_lo * right_lo\n+\/\/ (2) left_lo * right_hi\n+\/\/ (3) left_hi * right_lo\n+\/\/ (4) left_hi * right_hi\n+\/\/\n+\/\/ Let's define the following two functions:\n+\/\/ - Lx(i): Returns the lower x bits of the 2x-bit number i.\n+\/\/ - Ux(i): Returns the upper x bits of the 2x-bit number i.\n+\/\/\n+\/\/ Let's first assume all products are positive where only overflows are possible but no underflows. If there is no\n+\/\/ overflow for a product p, then the upper x bits of the 2x-bit result p are all zero:\n+\/\/     Ux(p) = 0\n+\/\/     Lx(p) = p\n+\/\/\n+\/\/ If none of the multiplications (1)-(4) overflow, we can truncate the upper x bits and use the following result type\n+\/\/ with x bits:\n+\/\/      [result_lo,result_hi] = [MIN(Lx(1),Lx(2),Lx(3),Lx(4)),MAX(Lx(1),Lx(2),Lx(3),Lx(4))]\n+\/\/\n+\/\/ If any of these multiplications overflows, we could pessimistically take the bottom type for the x bit result\n+\/\/ (i.e. all values in the x-bit space could be possible):\n+\/\/      [result_lo,result_hi] = [NativeType_min,NativeType_max]\n+\/\/\n+\/\/ However, in case of any overflow, we can do better by analyzing the upper x bits of all multiplications (1)-(4) with\n+\/\/ 2x-bit results. The upper x bits tell us something about how many times a multiplication has overflown the lower\n+\/\/ x bits. If the upper x bits of (1)-(4) are all equal, then we know that all of these multiplications overflowed\n+\/\/ the lower x bits the same number of times:\n+\/\/     Ux((1)) = Ux((2)) = Ux((3)) = Ux((4))\n+\/\/\n+\/\/ If all upper x bits are equal, we can conclude:\n+\/\/     Lx(MIN((1),(2),(3),(4))) = MIN(Lx(1),Lx(2),Lx(3),Lx(4)))\n+\/\/     Lx(MAX((1),(2),(3),(4))) = MAX(Lx(1),Lx(2),Lx(3),Lx(4)))\n+\/\/\n+\/\/ Therefore, we can use the same precise x-bit result type as for the no-overflow case:\n+\/\/     [result_lo,result_hi] = [(MIN(Lx(1),Lx(2),Lx(3),Lx(4))),MAX(Lx(1),Lx(2),Lx(3),Lx(4)))]\n+\/\/\n+\/\/\n+\/\/ Now let's assume that (1)-(4) are signed multiplications where over- and underflow could occur:\n+\/\/ Negative numbers are all sign extend with ones. Therefore, if a negative product does not underflow, then the\n+\/\/ upper x bits of the 2x-bit result are all set to ones which is minus one in two's complement. If there is an underflow,\n+\/\/ the upper x bits are decremented by the number of times an underflow occurred. The smallest possible negative product\n+\/\/ is NativeType_min*NativeType_max, where the upper x bits are set to NativeType_min \/ 2 (b11...0). It is therefore\n+\/\/ impossible to underflow the upper x bits. Thus, when having all ones (i.e. minus one) in the upper x bits, we know\n+\/\/ that there is no underflow.\n+\/\/\n+\/\/ To be able to compare the number of over-\/underflows of positive and negative products, respectively, we normalize\n+\/\/ the upper x bits of negative 2x-bit products by adding one. This way a product has no over- or underflow if the\n+\/\/ normalized upper x bits are zero. Now we can use the same improved type as for strictly positive products because we\n+\/\/ can compare the upper x bits in a unified way with N() being the normalization function:\n+\/\/     N(Ux((1))) = N(Ux((2))) = N(Ux((3)) = N(Ux((4)))\n+template<typename NativeType>\n+class IntegerTypeMultiplication {\n@@ -304,4 +352,0 @@\n-  NativeType _lo_lo_product;\n-  NativeType _lo_hi_product;\n-  NativeType _hi_lo_product;\n-  NativeType _hi_hi_product;\n@@ -312,8 +356,5 @@\n-  static NativeType multiply_high_signed_overflow_value(NativeType x, NativeType y);\n-\n-  \/\/ Pre-compute cross products which are used at several places\n-  void compute_cross_products() {\n-    _lo_lo_product = java_multiply(_lo_left, _lo_right);\n-    _lo_hi_product = java_multiply(_lo_left, _hi_right);\n-    _hi_lo_product = java_multiply(_hi_left, _lo_right);\n-    _hi_hi_product = java_multiply(_hi_left, _hi_right);\n+  static NativeType multiply_high(NativeType x, NativeType y);\n+  const Type* create_type(NativeType lo, NativeType hi) const;\n+\n+  static NativeType multiply_high_signed_overflow_value(NativeType x, NativeType y) {\n+    return normalize_overflow_value(x, y, multiply_high(x, y));\n@@ -322,1 +363,1 @@\n-  bool cross_products_not_same_overflow() const {\n+  bool cross_product_not_same_overflow_value() const {\n@@ -332,0 +373,4 @@\n+  bool does_product_overflow(NativeType x, NativeType y) const {\n+    return multiply_high_signed_overflow_value(x, y) != 0;\n+  }\n+\n@@ -337,4 +382,5 @@\n-  IntegerMulRing(const IntegerType* left, const IntegerType* right) : _lo_left(left->_lo), _lo_right(right->_lo),\n-    _hi_left(left->_hi), _hi_right(right->_hi), _widen_left(left->_widen), _widen_right(right->_widen)  {\n-    compute_cross_products();\n-  }\n+  template<class IntegerType>\n+  IntegerTypeMultiplication(const IntegerType* left, const IntegerType* right)\n+      : _lo_left(left->_lo), _lo_right(right->_lo),\n+        _hi_left(left->_hi), _hi_right(right->_hi),\n+        _widen_left(left->_widen), _widen_right(right->_widen)  {}\n@@ -347,1 +393,1 @@\n-    if (cross_products_not_same_overflow()) {\n+    if (cross_product_not_same_overflow_value()) {\n@@ -350,3 +396,8 @@\n-    const NativeType min = MIN4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n-    const NativeType max = MAX4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n-    return IntegerType::make(min, max, MAX2(_widen_left, _widen_right));\n+\n+    NativeType lo_lo_product = java_multiply(_lo_left, _lo_right);\n+    NativeType lo_hi_product = java_multiply(_lo_left, _hi_right);\n+    NativeType hi_lo_product = java_multiply(_hi_left, _lo_right);\n+    NativeType hi_hi_product = java_multiply(_hi_left, _hi_right);\n+    const NativeType min = MIN4(lo_lo_product, lo_hi_product, hi_lo_product, hi_hi_product);\n+    const NativeType max = MAX4(lo_lo_product, lo_hi_product, hi_lo_product, hi_hi_product);\n+    return create_type(min, max);\n@@ -354,1 +405,0 @@\n-};\n@@ -356,0 +406,7 @@\n+  bool does_overflow() const {\n+    return does_product_overflow(_lo_left, _lo_right) ||\n+           does_product_overflow(_lo_left, _hi_right) ||\n+           does_product_overflow(_hi_left, _lo_right) ||\n+           does_product_overflow(_hi_left, _hi_right);\n+  }\n+};\n@@ -358,1 +415,1 @@\n-const Type* IntegerMulRing<TypeInt>::overflow_type() {\n+const Type* IntegerTypeMultiplication<jint>::overflow_type() {\n@@ -363,1 +420,1 @@\n-jint IntegerMulRing<TypeInt>::multiply_high_signed_overflow_value(const jint x, const jint y) {\n+jint IntegerTypeMultiplication<jint>::multiply_high(const jint x, const jint y) {\n@@ -367,2 +424,1 @@\n-  const jint result = (jint)((uint64_t)product >> 32u);\n-  return normalize_overflow_value(x, y, result);\n+  return (jint)((uint64_t)product >> 32u);\n@@ -372,1 +428,6 @@\n-const Type* IntegerMulRing<TypeLong>::overflow_type() {\n+const Type* IntegerTypeMultiplication<jint>::create_type(jint lo, jint hi) const {\n+  return TypeInt::make(lo, hi, MAX2(_widen_left, _widen_right));\n+}\n+\n+template <>\n+const Type* IntegerTypeMultiplication<jlong>::overflow_type() {\n@@ -377,3 +438,7 @@\n-jlong IntegerMulRing<TypeLong>::multiply_high_signed_overflow_value(const jlong x, const jlong y) {\n-  const jlong result = multiply_high_signed(x, y);\n-  return normalize_overflow_value(x, y, result);\n+jlong IntegerTypeMultiplication<jlong>::multiply_high(const jlong x, const jlong y) {\n+  return multiply_high_signed(x, y);\n+}\n+\n+template <>\n+const Type* IntegerTypeMultiplication<jlong>::create_type(jlong lo, jlong hi) const {\n+  return TypeLong::make(lo, hi, MAX2(_widen_left, _widen_right));\n@@ -384,2 +449,7 @@\n-  const IntegerMulRing<TypeInt> integer_mul_ring(type_left->is_int(), type_right->is_int());\n-  return integer_mul_ring.compute();\n+  const IntegerTypeMultiplication<jint> integer_multiplication(type_left->is_int(), type_right->is_int());\n+  return integer_multiplication.compute();\n+}\n+\n+bool MulINode::does_overflow(const TypeInt* type_left, const TypeInt* type_right) {\n+  const IntegerTypeMultiplication<jint> integer_multiplication(type_left, type_right);\n+  return integer_multiplication.does_overflow();\n@@ -390,2 +460,2 @@\n-  const IntegerMulRing<TypeLong> integer_mul_ring(type_left->is_long(), type_right->is_long());\n-  return integer_mul_ring.compute();\n+  const IntegerTypeMultiplication<jlong> integer_multiplication(type_left->is_long(), type_right->is_long());\n+  return integer_multiplication.compute();\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":117,"deletions":47,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  static bool does_overflow(const TypeInt* type_left, const TypeInt* type_right);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1139,1 +1139,8 @@\n-\/\/----------------- Code Generation\n+  \/\/ Returns a clone of the current node that's pinned (if the current node is not) for nodes found in array accesses\n+  \/\/ (Load and range check CastII nodes).\n+  \/\/ This is used when an array access is made dependent on 2 or more range checks (range check smearing or Loop Predication).\n+  virtual Node* pin_array_access_node() const {\n+    return nullptr;\n+  }\n+\n+  \/\/----------------- Code Generation\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -778,1 +778,1 @@\n-    if (mv == NULL) {\n+    if (mv == nullptr) {\n@@ -786,1 +786,1 @@\n-      (void)FillLocArray(1, NULL, sfpt->in(selector_idx), &deps, NULL);\n+      (void)FillLocArray(1, nullptr, sfpt->in(selector_idx), &deps, nullptr);\n@@ -1088,0 +1088,24 @@\n+      } else if (obj_node->is_SafePointScalarMerge()) {\n+        SafePointScalarMergeNode* smerge = obj_node->as_SafePointScalarMerge();\n+        ObjectMergeValue* mv = (ObjectMergeValue*) sv_for_node_id(objs, smerge->_idx);\n+\n+        if (mv == nullptr) {\n+          GrowableArray<ScopeValue*> deps;\n+\n+          int merge_pointer_idx = smerge->merge_pointer_idx(youngest_jvms);\n+          FillLocArray(0, sfn, sfn->in(merge_pointer_idx), &deps, objs);\n+          assert(deps.length() == 1, \"missing value\");\n+\n+          int selector_idx = smerge->selector_idx(youngest_jvms);\n+          FillLocArray(1, nullptr, sfn->in(selector_idx), &deps, nullptr);\n+          assert(deps.length() == 2, \"missing value\");\n+\n+          mv = new ObjectMergeValue(smerge->_idx, deps.at(0), deps.at(1));\n+          set_sv_for_object_node(objs, mv);\n+\n+          for (uint i = 1; i < smerge->req(); i++) {\n+            Node* obj_node = smerge->in(i);\n+            FillLocArray(mv->possible_objects()->length(), sfn, obj_node, mv->possible_objects(), objs);\n+          }\n+        }\n+        scval = mv;\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-#include \"opto\/addnode.hpp\"\n-#include \"opto\/node.hpp\"\n@@ -29,0 +27,1 @@\n+#include \"opto\/addnode.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"opto\/node.hpp\"\n@@ -34,1 +34,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,12 +46,0 @@\n-      if (subk->is_same_java_type_as(superk) && !sub_t->maybe_null()) {\n-        \/\/ The super_t has no subclasses, and sub_t has the same type and is not null,\n-        \/\/ hence the check should always evaluate to EQ. However, this is an impossible\n-        \/\/ situation since super_t is also abstract, and hence sub_t cannot have the\n-        \/\/ same type and be non-null.\n-        \/\/ Still, if the non-static method of an abstract class without subclasses is\n-        \/\/ force-compiled, the Param0 has the self\/this pointer with NotNull. This\n-        \/\/ method would now never be called, because of the leaf-type dependency. Hence,\n-        \/\/ just for consistency with verification, we return EQ.\n-        return TypeInt::CC_EQ;\n-      }\n-      \/\/ subk is either a supertype of superk, or null. In either case, superk is a subtype.\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3431,2 +3431,2 @@\n-  while (n != 0) {\n-    bool swapped = false;\n+  do {\n+    int max_swap_index = 0;\n@@ -3439,1 +3439,0 @@\n-        Node_List* t = q_i;\n@@ -3442,1 +3441,1 @@\n-        swapped = true;\n+        max_swap_index = i;\n@@ -3445,3 +3444,2 @@\n-    if (swapped == false) break;\n-    n--;\n-  }\n+    n = max_swap_index;\n+  } while (n > 1);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -933,0 +933,5 @@\n+  if (selected_method->is_abstract()) {\n+    ResourceMark rm(THREAD);\n+    THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), selected_method->name()->as_C_string());\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -78,4 +78,0 @@\n-#ifdef AIX\n-  _inode(0),\n-  _device(0),\n-#endif\n@@ -126,18 +122,0 @@\n-#ifdef AIX\n-void JvmtiAgent::set_inode(ino64_t inode) {\n-  _inode = inode;\n-}\n-\n-void JvmtiAgent::set_device(dev64_t device) {\n-  _device = device;\n-}\n-\n-ino64_t JvmtiAgent::inode() const {\n-  return _inode;\n-}\n-\n-dev64_t JvmtiAgent::device() const {\n-  return _device;\n-}\n-#endif\n-\n@@ -298,14 +276,0 @@\n-#ifdef AIX\n-\/\/ save the inode and device of the library's file as a signature. This signature can be used\n-\/\/ in the same way as the library handle as a signature on other platforms.\n-static void save_library_signature(JvmtiAgent* agent, const char* name) {\n-  struct stat64x libstat;\n-  if (0 == os::Aix::stat64x_via_LIBPATH(name, &libstat)) {\n-    agent->set_inode(libstat.st_ino);\n-    agent->set_device(libstat.st_dev);\n-  } else {\n-    assert(false, \"stat64x failed\");\n-  }\n-}\n-#endif\n-\n@@ -321,1 +285,0 @@\n-  AIX_ONLY(if (library != nullptr) save_library_signature(agent, agent->name());)\n@@ -334,1 +297,0 @@\n-    AIX_ONLY(if (library != nullptr) save_library_signature(agent, &buffer[0]);)\n@@ -340,1 +302,0 @@\n-      AIX_ONLY(save_library_signature(agent, &buffer[0]);)\n@@ -558,3 +519,0 @@\n-  #ifdef AIX\n-    previously_loaded = JvmtiAgentList::is_dynamic_lib_loaded(agent->device(), agent->inode());\n-  #else\n@@ -562,1 +520,0 @@\n-  #endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -46,4 +46,0 @@\n-#ifdef AIX\n-  ino64_t _inode;\n-  dev64_t _device;\n-#endif\n@@ -87,6 +83,0 @@\n-#ifdef AIX\n-  void set_inode(ino64_t inode);\n-  void set_device(dev64_t device);\n-  unsigned long inode() const;\n-  unsigned long device() const;\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -246,13 +246,0 @@\n-#ifdef AIX\n-bool JvmtiAgentList::is_dynamic_lib_loaded(dev64_t device, ino64_t inode) {\n-  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n-  while (it.has_next()) {\n-    JvmtiAgent* const agent = it.next();\n-    if (!agent->is_static_lib() && device != 0 && inode != 0 &&\n-        agent->device() == device && agent->inode() == inode) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -81,3 +81,0 @@\n-#ifdef AIX\n-  static bool is_dynamic_lib_loaded(dev64_t device, ino64_t inode);\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2899,1 +2899,0 @@\n-\n@@ -2902,4 +2901,1 @@\n-  int result_count = 0;\n-  \/\/ First, count the fields.\n-  FilteredFieldStream flds(ik, true, true);\n-  result_count = flds.field_count();\n+  FilteredJavaFieldStream flds(ik);\n@@ -2907,5 +2903,1 @@\n-  \/\/ Allocate the result and fill it in\n-  jfieldID* result_list = (jfieldID*) jvmtiMalloc(result_count * sizeof(jfieldID));\n-  \/\/ The JVMTI spec requires fields in the order they occur in the class file,\n-  \/\/ this is the reverse order of what FieldStream hands out.\n-  int id_index = (result_count - 1);\n+  int result_count = flds.field_count();\n@@ -2913,4 +2905,5 @@\n-  for (FilteredFieldStream src_st(ik, true, true); !src_st.eos(); src_st.next()) {\n-    result_list[id_index--] = jfieldIDWorkaround::to_jfieldID(\n-                                            ik, src_st.offset(),\n-                                            src_st.access_flags().is_static());\n+  \/\/ Allocate the result and fill it in.\n+  jfieldID* result_list = (jfieldID*)jvmtiMalloc(result_count * sizeof(jfieldID));\n+  for (int i = 0; i < result_count; i++, flds.next()) {\n+    result_list[i] = jfieldIDWorkaround::to_jfieldID(ik, flds.offset(),\n+                                                     flds.access_flags().is_static());\n@@ -2918,1 +2911,2 @@\n-  assert(id_index == -1, \"just checking\");\n+  assert(flds.done(), \"just checking\");\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1066,0 +1066,1 @@\n+  static bool pd_dll_unload(void* libhandle, char* ebuf, int ebuflen);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -240,0 +241,32 @@\n+\/\/ Iterate over Java fields filtering fields like reflection does.\n+class FilteredJavaFieldStream : public JavaFieldStream {\n+private:\n+  InstanceKlass* _klass;\n+  int  _filtered_fields_count;\n+  bool has_filtered_field() const { return (_filtered_fields_count > 0); }\n+  void skip_filtered_fields() {\n+    if (has_filtered_field()) {\n+      while (!done() && FilteredFieldsMap::is_filtered_field((Klass*)_klass, offset())) {\n+        JavaFieldStream::next();\n+      }\n+    }\n+  }\n+\n+public:\n+  FilteredJavaFieldStream(InstanceKlass* klass)\n+    : JavaFieldStream(klass),\n+      _klass(klass),\n+      _filtered_fields_count(FilteredFieldsMap::filtered_fields_count(klass, true))\n+  {\n+    \/\/ skip filtered fields at the beginning\n+    skip_filtered_fields();\n+  }\n+  int field_count() const {\n+    return _klass->java_fields_count() - _filtered_fields_count;\n+  }\n+  void next() {\n+    JavaFieldStream::next();\n+    skip_filtered_fields();\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.hpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -522,2 +522,2 @@\n-        if (mark.is_neutral()) {\n-          assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n+        while (mark.is_neutral()) {\n+          \/\/ Retry until a lock state change has been observed.  cas_set_mark() may collide with non lock bits modifications.\n@@ -525,2 +525,3 @@\n-          markWord locked_mark = mark.set_fast_locked();\n-          markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n+          assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n+          const markWord locked_mark = mark.set_fast_locked();\n+          const markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n@@ -532,0 +533,1 @@\n+          mark = old_mark;\n@@ -581,13 +583,7 @@\n-      if (mark.is_fast_locked()) {\n-        markWord unlocked_mark = mark.set_unlocked();\n-        markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n-        if (old_mark != mark) {\n-          \/\/ Another thread won the CAS, it must have inflated the monitor.\n-          \/\/ It can only have installed an anonymously locked monitor at this point.\n-          \/\/ Fetch that monitor, set owner correctly to this thread, and\n-          \/\/ exit it (allowing waiting threads to enter).\n-          assert(old_mark.has_monitor(), \"must have monitor\");\n-          ObjectMonitor* monitor = old_mark.monitor();\n-          assert(monitor->is_owner_anonymous(), \"must be anonymous owner\");\n-          monitor->set_owner_from_anonymous(current);\n-          monitor->exit(current);\n+      while (mark.is_fast_locked()) {\n+        \/\/ Retry until a lock state change has been observed.  cas_set_mark() may collide with non lock bits modifications.\n+        const markWord unlocked_mark = mark.set_unlocked();\n+        const markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n+        if (old_mark == mark) {\n+          current->lock_stack().remove(object);\n+          return;\n@@ -595,3 +591,1 @@\n-        LockStack& lock_stack = current->lock_stack();\n-        lock_stack.remove(object);\n-        return;\n+        mark = old_mark;\n@@ -911,7 +905,0 @@\n-\/\/ Can be called from non JavaThreads (e.g., VMThread) for FastHashCode\n-\/\/ calculations as part of JVM\/TI tagging.\n-static bool is_lock_owned(Thread* thread, oop obj) {\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only call this with new lightweight locking enabled\");\n-  return thread->is_Java_thread() ? JavaThread::cast(thread)->lock_stack().contains(obj) : false;\n-}\n-\n@@ -929,1 +916,1 @@\n-    if (mark.is_neutral()) {               \/\/ if this is a normal header\n+    if (mark.is_neutral() || (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked())) {\n@@ -941,0 +928,4 @@\n+      if (LockingMode == LM_LIGHTWEIGHT) {\n+        \/\/ CAS failed, retry\n+        continue;\n+      }\n@@ -972,7 +963,0 @@\n-    } else if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked() && is_lock_owned(current, obj)) {\n-      \/\/ This is a fast-lock owned by the calling thread so use the\n-      \/\/ markWord from the object.\n-      hash = mark.hash();\n-      if (hash != 0) {                  \/\/ if it has a hash, just return it\n-        return hash;\n-      }\n@@ -1308,0 +1292,7 @@\n+\/\/ Can be called from non JavaThreads (e.g., VMThread) for FastHashCode\n+\/\/ calculations as part of JVM\/TI tagging.\n+static bool is_lock_owned(Thread* thread, oop obj) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only call this with new lightweight locking enabled\");\n+  return thread->is_Java_thread() ? JavaThread::cast(thread)->lock_stack().contains(obj) : false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":26,"deletions":35,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  DEBUG_ONLY(clear_indirectly_safepoint_thread();)\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+  DEBUG_ONLY(bool _indirectly_safepoint_thread;)\n@@ -228,0 +229,4 @@\n+\n+  void set_indirectly_safepoint_thread()   { _indirectly_safepoint_thread = true; }\n+  void clear_indirectly_safepoint_thread() { _indirectly_safepoint_thread = false; }\n+  bool is_indirectly_safepoint_thread()    { return _indirectly_safepoint_thread; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -100,1 +101,3 @@\n-    _zgc_phase_switch = new StringEventLog(\"ZGC Phase Switch\", \"zgcps\");\n+    if (UseZGC) {\n+      _zgc_phase_switch = new StringEventLog(\"ZGC Phase Switch\", \"zgcps\");\n+    }\n","filename":"src\/hotspot\/share\/utilities\/events.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,0 +430,3 @@\n+    \/\/ Majority of MacOSX fixed locales return Gregorian cal identifier\n+    \/\/ Using CFCalendarCopyCurrent() provides a cal that is based off OS settings\n+    \/\/ which is more accurate than one created with a Gregorian identifier\n","filename":"src\/java.base\/macosx\/native\/libjava\/HostLocaleProviderAdapter_md.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    private boolean forTlsPremasterSecret = false;\n@@ -289,0 +290,1 @@\n+                forTlsPremasterSecret = true;\n@@ -380,1 +382,1 @@\n-                if (result == null) {\n+                if (result == null && !forTlsPremasterSecret) {\n@@ -469,1 +471,0 @@\n-        Exception failover = null;\n@@ -475,8 +476,5 @@\n-        } catch (BadPaddingException e) {\n-            if (isTlsRsaPremasterSecret) {\n-                failover = e;\n-            } else {\n-                throw new InvalidKeyException(\"Unwrapping failed\", e);\n-            }\n-        } catch (IllegalBlockSizeException e) {\n-            \/\/ should not occur, handled with length check above\n+        } catch (BadPaddingException | IllegalBlockSizeException e) {\n+            \/\/ BadPaddingException cannot happen for TLS RSA unwrap.\n+            \/\/ In that case, padding error is indicated by returning null.\n+            \/\/ IllegalBlockSizeException cannot happen in any case,\n+            \/\/ because of the length check above.\n@@ -488,1 +486,1 @@\n-                if (!(spec instanceof TlsRsaPremasterSecretParameterSpec)) {\n+                if (!forTlsPremasterSecret) {\n@@ -497,1 +495,1 @@\n-                        random, encoded, (failover != null));\n+                        random, encoded, encoded == null);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipher.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,0 +222,3 @@\n+     * <p>\n+     * Memory segments {@linkplain #allocate(long, long) allocated} by the returned arena\n+     * are zero-initialized.\n@@ -234,0 +237,3 @@\n+     * <p>\n+     * Memory segments {@linkplain #allocate(long, long) allocated} by the returned arena\n+     * are zero-initialized.\n@@ -246,0 +252,3 @@\n+     * <p>\n+     * Memory segments {@linkplain #allocate(long, long) allocated} by the returned arena\n+     * are zero-initialized.\n@@ -254,0 +263,3 @@\n+     * <p>\n+     * Memory segments {@linkplain #allocate(long, long) allocated} by the returned arena\n+     * are zero-initialized.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,9 @@\n+ * @apiNote\n+ * Not all modifiers that are syntactic Java language modifiers are\n+ * represented in this class, only those modifiers that <em>also<\/em>\n+ * have a corresponding JVM {@linkplain AccessFlag access flag} are\n+ * included. In particular the {@code default} method modifier (JLS\n+ * {@jls 9.4.3}) and the {@code sealed} and {@code non-sealed} class\n+ * (JLS {@jls 8.1.1.2}) and interface (JLS {@jls 9.1.1.4}) modifiers\n+ * are <em>not<\/em> represented in this class.\n+ *\n@@ -211,0 +220,1 @@\n+     *\n@@ -224,0 +234,16 @@\n+     * @apiNote\n+     * To make a high-fidelity representation of the Java source\n+     * modifiers of a class or member, source-level modifiers that do\n+     * <em>not<\/em> have a constant in this class should be included\n+     * and appear in an order consistent with the full recommended\n+     * ordering for that kind of declaration as given in <cite>The\n+     * Java Language Specification<\/cite>. For example, for a\n+     * {@linkplain Method#toGenericString() method} the \"{@link\n+     * Method#isDefault() default}\" modifier is ordered immediately\n+     * before \"{@code static}\" (JLS {@jls 9.4}). For a {@linkplain\n+     * Class#toGenericString() class object}, the \"{@link\n+     * Class#isSealed() sealed}\" or {@code \"non-sealed\"} modifier is\n+     * ordered immediately after \"{@code final}\" for a class (JLS\n+     * {@jls 8.1.1}) and immediately after \"{@code static}\" for an\n+     * interface (JLS {@jls 9.1.1}).\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -3966,0 +3967,1 @@\n+    @Override\n@@ -3994,6 +3996,3 @@\n-        for (int i = 0; i < len1; i++) {\n-            int a = m1[i];\n-            int b = m2[i];\n-            if (a != b)\n-                return ((a & LONG_MASK) < (b & LONG_MASK)) ? -1 : 1;\n-        }\n+        int i = ArraysSupport.mismatch(m1, m2, len1);\n+        if (i != -1)\n+            return Integer.compareUnsigned(m1[i], m2[i]) < 0 ? -1 : 1;\n@@ -4026,1 +4025,1 @@\n-                return ((a & LONG_MASK) < (b & LONG_MASK))? -1 : 1;\n+                return Integer.compareUnsigned(a, b) < 0 ? -1 : 1;\n@@ -4035,1 +4034,1 @@\n-                return ((a & LONG_MASK) < (b & LONG_MASK))? -1 : 1;\n+                return Integer.compareUnsigned(a, b) < 0 ? -1 : 1;\n@@ -4040,1 +4039,1 @@\n-                return ((a & LONG_MASK) < (b & LONG_MASK))? -1 : 1;\n+                return Integer.compareUnsigned(a, b) < 0 ? -1 : 1;\n@@ -4053,0 +4052,1 @@\n+    @Override\n@@ -4064,4 +4064,1 @@\n-        int[] m = mag;\n-        int len = m.length;\n-        int[] xm = xInt.mag;\n-        if (len != xm.length)\n+        if (mag.length != xInt.mag.length)\n@@ -4070,5 +4067,1 @@\n-        for (int i = 0; i < len; i++)\n-            if (xm[i] != m[i])\n-                return false;\n-\n-        return true;\n+        return ArraysSupport.mismatch(mag, xInt.mag, mag.length) == -1;\n@@ -4103,3 +4096,1 @@\n-     * Returns the hash code for this BigInteger.\n-     *\n-     * @return hash code for this BigInteger.\n+     * {@return the hash code for this BigInteger}\n@@ -4107,0 +4098,1 @@\n+    @Override\n@@ -4108,6 +4100,2 @@\n-        int hashCode = 0;\n-\n-        for (int i=0; i < mag.length; i++)\n-            hashCode = (int)(31*hashCode + (mag[i] & LONG_MASK));\n-\n-        return hashCode * signum;\n+        return ArraysSupport.vectorizedHashCode(mag, 0, mag.length, 0,\n+                ArraysSupport.T_INT) * signum;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":15,"deletions":27,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1362,0 +1362,3 @@\n+     * If the {@code ATOMIC_MOVE} option is not specified, then the check\n+     * whether the target file exists and the actual move might not be atomic\n+     * with respect to other filesystem activities.\n@@ -1407,2 +1410,5 @@\n-     *          {@code REPLACE_EXISTING} option is not specified <i>(optional\n-     *          specific exception)<\/i>\n+     *          {@code REPLACE_EXISTING} option is <i>not<\/i> specified.\n+     *          It may also be thrown when the {@code REPLACE_EXISTING} option\n+     *          <i>is<\/i> specified, the move is not atomic, and the target\n+     *          file is created by some other entity at around the same time\n+     *          that this method is called\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1146,1 +1146,2 @@\n-        offer(e);\n+        Objects.requireNonNull(e);\n+        xfer(e, -1L);\n@@ -1159,1 +1160,3 @@\n-        return offer(e);\n+        Objects.requireNonNull(e);\n+        xfer(e, -1L);\n+        return true;\n@@ -1184,1 +1187,3 @@\n-        return offer(e);\n+        Objects.requireNonNull(e);\n+        xfer(e, -1L);\n+        return true;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.ArrayList;\n@@ -542,2 +543,10 @@\n-        if (list.isEmpty()) {\n-            throw new NoSuchAlgorithmException(algorithm + \" KEM not available\");\n+        List<Provider.Service> allowed = new ArrayList<>();\n+        for (Provider.Service s : list) {\n+            if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                continue;\n+            }\n+            allowed.add(s);\n+        }\n+        if (allowed.isEmpty()) {\n+            throw new NoSuchAlgorithmException\n+                    (algorithm + \" KEM not available\");\n@@ -545,1 +554,2 @@\n-        return new KEM(algorithm, new DelayedKEM(list.toArray(new Provider.Service[0])));\n+\n+        return new KEM(algorithm, new DelayedKEM(allowed.toArray(new Provider.Service[0])));\n@@ -571,1 +581,1 @@\n-        GetInstance.Instance instance = GetInstance.getInstance(\n+        GetInstance.Instance instance = JceSecurity.getInstance(\n@@ -604,1 +614,1 @@\n-        GetInstance.Instance instance = GetInstance.getInstance(\n+        GetInstance.Instance instance = JceSecurity.getInstance(\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEM.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.jimage.decompressor.ResourceDecompressor.StringsProvider;\n@@ -48,0 +47,8 @@\n+\n+    \/\/ Standard header offsets\n+    private static final int MAGIC_OFFSET = 0; \/\/ 4 bytes\n+    private static final int COMPRESSED_OFFSET = 4; \/\/ 8 bytes\n+    private static final int UNCOMPRESSED_OFFSET = 12; \/\/ 8 bytes\n+    private static final int DECOMPRESSOR_NAME_OFFSET = 20; \/\/ 4 bytes, followed by 4 byte gap\n+    private static final int IS_TERMINAL_OFFSET = 28; \/\/ 1 byte\n+\n@@ -51,1 +58,0 @@\n-    private final int contentOffset;\n@@ -55,1 +61,1 @@\n-            long uncompressedSize, int decompressorNameOffset, int contentOffset,\n+            long uncompressedSize, int decompressorNameOffset,\n@@ -60,1 +66,0 @@\n-        this.contentOffset = contentOffset;\n@@ -72,12 +77,0 @@\n-    public int getContentOffset() {\n-        return contentOffset;\n-    }\n-\n-    public String getStoredContent(StringsProvider provider) {\n-        Objects.requireNonNull(provider);\n-        if(contentOffset == -1) {\n-            return null;\n-        }\n-        return provider.getString(contentOffset);\n-    }\n-\n@@ -100,1 +93,2 @@\n-        buffer.putInt(contentOffset);\n+        \/\/ Compatibility\n+        buffer.putInt(-1);\n@@ -118,2 +112,2 @@\n-        int magic = buffer.getInt();\n-        if(magic != MAGIC) {\n+        int magic = buffer.getInt(MAGIC_OFFSET);\n+        if (magic != MAGIC) {\n@@ -122,5 +116,5 @@\n-        long size = buffer.getLong();\n-        long uncompressedSize = buffer.getLong();\n-        int decompressorNameOffset = buffer.getInt();\n-        int contentIndex = buffer.getInt();\n-        byte isTerminal = buffer.get();\n+        long size = buffer.getLong(COMPRESSED_OFFSET);\n+        long uncompressedSize = buffer.getLong(UNCOMPRESSED_OFFSET);\n+        int decompressorNameOffset = buffer.getInt(DECOMPRESSOR_NAME_OFFSET);\n+        \/\/ skip unused 'contentOffset' int\n+        byte isTerminal = buffer.get(IS_TERMINAL_OFFSET);\n@@ -128,1 +122,1 @@\n-                decompressorNameOffset, contentIndex, isTerminal == 1);\n+                decompressorNameOffset, isTerminal == 1);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/CompressedResourceHeader.java","additions":20,"deletions":26,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.io.ByteArrayInputStream;\n@@ -30,1 +29,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -34,1 +32,0 @@\n-import java.util.Properties;\n@@ -78,9 +75,0 @@\n-                    String storedContent = header.getStoredContent(provider);\n-                    Properties props = new Properties();\n-                    if (storedContent != null) {\n-                        try (ByteArrayInputStream stream\n-                                = new ByteArrayInputStream(storedContent.\n-                                        getBytes(StandardCharsets.UTF_8));) {\n-                            props.loadFromXML(stream);\n-                        }\n-                    }\n@@ -88,1 +76,1 @@\n-                            newResourceDecompressor(props, pluginName);\n+                            newResourceDecompressor(pluginName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/Decompressor.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Properties;\n@@ -57,1 +56,0 @@\n-     * @param properties Contains configuration.\n@@ -61,2 +59,1 @@\n-    public abstract ResourceDecompressor newDecompressor(Properties properties)\n-            throws IOException;\n+    public abstract ResourceDecompressor newDecompressor() throws IOException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/ResourceDecompressorFactory.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Properties;\n@@ -57,1 +56,0 @@\n-     * @param properties Contains plugin configuration.\n@@ -62,2 +60,1 @@\n-    public static ResourceDecompressor newResourceDecompressor(Properties properties,\n-            String name) throws IOException {\n+    public static ResourceDecompressor newResourceDecompressor(String name) throws IOException {\n@@ -67,1 +64,1 @@\n-            return fact.newDecompressor(properties);\n+            return fact.newDecompressor();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/ResourceDecompressorRepository.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.Properties;\n@@ -231,3 +230,1 @@\n-    public StringSharingDecompressor(Properties properties) {\n-\n-    }\n+    public StringSharingDecompressor() {}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/StringSharingDecompressor.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Properties;\n@@ -48,1 +47,1 @@\n-    public ResourceDecompressor newDecompressor(Properties properties)\n+    public ResourceDecompressor newDecompressor()\n@@ -50,1 +49,1 @@\n-        return new StringSharingDecompressor(properties);\n+        return new StringSharingDecompressor();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/StringSharingDecompressorFactory.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n@@ -47,1 +47,6 @@\n-    static byte[] decompress(byte[] bytesIn, int offset) throws Exception {\n+    static byte[] decompress(byte[] bytesIn, int offset, long originalSize) throws Exception {\n+        if (originalSize > Integer.MAX_VALUE) {\n+            throw new OutOfMemoryError(\"Required array size too large\");\n+        }\n+        byte[] bytesOut = new byte[(int) originalSize];\n+\n@@ -50,2 +55,0 @@\n-        ByteArrayOutputStream stream = new ByteArrayOutputStream(bytesIn.length - offset);\n-        byte[] buffer = new byte[1024];\n@@ -53,3 +56,3 @@\n-        while (!inflater.finished()) {\n-            int count = inflater.inflate(buffer);\n-            stream.write(buffer, 0, count);\n+        int count = 0;\n+        while (!inflater.finished() && count < originalSize) {\n+            count += inflater.inflate(bytesOut, count, bytesOut.length - count);\n@@ -58,3 +61,0 @@\n-        stream.close();\n-\n-        byte[] bytesOut = stream.toByteArray();\n@@ -63,0 +63,4 @@\n+        if (count != originalSize) {\n+            throw new IOException(\"Resource content size mismatch\");\n+        }\n+\n@@ -69,1 +73,1 @@\n-        byte[] decompressed = decompress(content, offset);\n+        byte[] decompressed = decompress(content, offset, originalSize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/ZipDecompressor.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Properties;\n@@ -47,1 +46,1 @@\n-    public ResourceDecompressor newDecompressor(Properties properties)\n+    public ResourceDecompressor newDecompressor()\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/ZipDecompressorFactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,0 +262,1 @@\n+            vec.release();\n@@ -473,0 +474,1 @@\n+            vec.release();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,1 @@\n-\n-import jdk.internal.misc.CarrierThreadLocal;\n-import jdk.internal.ref.CleanerFactory;\n+import jdk.internal.misc.TerminatingThreadLocal;\n@@ -74,4 +72,5 @@\n-    private static class Deallocator implements Runnable {\n-        private final AllocatedNativeObject obj;\n-        Deallocator(AllocatedNativeObject obj) {\n-            this.obj = obj;\n+    \/\/ per carrier-thread IOVecWrapper\n+    private static final TerminatingThreadLocal<IOVecWrapper[]> IOV_CACHE = new TerminatingThreadLocal<>() {\n+        @Override\n+        protected IOVecWrapper[] initialValue() {\n+            return new IOVecWrapper[1];  \/\/ one slot cache\n@@ -79,2 +78,6 @@\n-        public void run() {\n-            obj.free();\n+        @Override\n+        protected void threadTerminated(IOVecWrapper[] cache) {\n+            IOVecWrapper wrapper = cache[0];\n+            if (wrapper != null) {\n+                wrapper.vecArray.free();\n+            }\n@@ -82,4 +85,1 @@\n-    }\n-\n-    \/\/ per carrier-thread IOVecWrapper\n-    private static final CarrierThreadLocal<IOVecWrapper> cached = new CarrierThreadLocal<>();\n+    };\n@@ -98,5 +98,9 @@\n-        IOVecWrapper wrapper = cached.get();\n-        if (wrapper != null && wrapper.size < size) {\n-            \/\/ not big enough; eagerly release memory\n-            wrapper.vecArray.free();\n-            wrapper = null;\n+        IOVecWrapper[] cache = IOV_CACHE.get();\n+        IOVecWrapper wrapper = cache[0];\n+        if (wrapper != null) {\n+            cache[0] = null;\n+            if (wrapper.size < size) {\n+                \/\/ not big enough; eagerly release memory\n+                wrapper.vecArray.free();\n+                wrapper = null;\n+            }\n@@ -104,0 +108,6 @@\n+        return (wrapper != null) ? wrapper : new IOVecWrapper(size);\n+    }\n+\n+    void release() {\n+        IOVecWrapper[] cache = IOV_CACHE.get();\n+        IOVecWrapper wrapper = cache[0];\n@@ -105,3 +115,4 @@\n-            wrapper = new IOVecWrapper(size);\n-            CleanerFactory.cleaner().register(wrapper, new Deallocator(wrapper.vecArray));\n-            cached.set(wrapper);\n+            cache[0] = this;\n+        } else {\n+            \/\/ slot already used\n+            vecArray.free();\n@@ -109,1 +120,0 @@\n-        return wrapper;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOVecWrapper.java","additions":33,"deletions":23,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import sun.security.ec.point.AffinePoint;\n@@ -34,1 +33,0 @@\n-import sun.security.util.math.ImmutableIntegerModuloP;\n@@ -66,1 +64,1 @@\n-    ECOperations privateKeyOps;\n+    private ECOperations privateKeyOps;\n@@ -83,0 +81,4 @@\n+        privateKey = null;\n+        privateKeyOps = null;\n+        publicKey = null;\n+\n@@ -86,2 +88,2 @@\n-        privateKey = (ECPrivateKey)ECKeyFactory.toECKey(key);\n-        publicKey = null;\n+\n+        ECPrivateKey ecPrivateKey = (ECPrivateKey)ECKeyFactory.toECKey(key);\n@@ -89,1 +91,1 @@\n-            ECOperations.forParameters(privateKey.getParams());\n+            ECOperations.forParameters(ecPrivateKey.getParams());\n@@ -91,1 +93,1 @@\n-            NamedCurve nc = CurveDB.lookup(privateKey.getParams());\n+            NamedCurve nc = CurveDB.lookup(ecPrivateKey.getParams());\n@@ -96,1 +98,3 @@\n-        ECUtil.checkPrivateKey(privateKey);\n+        ECUtil.checkPrivateKey(ecPrivateKey);\n+\n+        privateKey = ecPrivateKey;\n@@ -142,0 +146,3 @@\n+        \/\/ Validate public key\n+        validate(privateKeyOps, (ECPublicKey) key);\n+\n@@ -148,3 +155,0 @@\n-        \/\/ Validate public key\n-        validate(privateKeyOps, publicKey);\n-\n@@ -157,5 +161,1 @@\n-        if (c.compareTo(BigInteger.ZERO) < 0) {\n-            throw new InvalidKeyException(\"Invalid coordinate\");\n-        }\n-\n-        if (c.compareTo(mod) >= 0) {\n+        if (c.compareTo(BigInteger.ZERO) < 0 || c.compareTo(mod) >= 0) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDHKeyAgreement.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.internal.misc.ThreadTracker;\n@@ -74,0 +75,4 @@\n+    private static class ThreadTrackerHolder {\n+        static final ThreadTracker AIA_TRACKER = new ThreadTracker();\n+    }\n+\n@@ -339,1 +344,1 @@\n-     * Download Certificates from the given AIA and add them to the\n+     * Download certificates from the given AIA and add them to the\n@@ -351,0 +356,1 @@\n+\n@@ -356,10 +362,27 @@\n-        boolean add = false;\n-        for (AccessDescription ad : adList) {\n-            CertStore cs = URICertStore.getInstance(ad);\n-            if (cs != null) {\n-                try {\n-                    if (certs.addAll((Collection<X509Certificate>)\n-                        cs.getCertificates(caSelector))) {\n-                        add = true;\n-                        if (!searchAllCertStores) {\n-                            return true;\n+        Object key = ThreadTrackerHolder.AIA_TRACKER.tryBegin();\n+        if (key == null) {\n+            \/\/ Avoid recursive fetching of certificates\n+            if (debug != null) {\n+                debug.println(\"Recursive fetching of certs via the AIA \" +\n+                    \"extension detected\");\n+            }\n+            return false;\n+        }\n+\n+        try {\n+            boolean add = false;\n+            for (AccessDescription ad : adList) {\n+                CertStore cs = URICertStore.getInstance(ad);\n+                if (cs != null) {\n+                    try {\n+                        if (certs.addAll((Collection<X509Certificate>)\n+                            cs.getCertificates(caSelector))) {\n+                            add = true;\n+                            if (!searchAllCertStores) {\n+                                return true;\n+                            }\n+                        }\n+                    } catch (CertStoreException cse) {\n+                        if (debug != null) {\n+                            debug.println(\"exception getting certs from CertStore:\");\n+                            cse.printStackTrace();\n@@ -367,5 +390,0 @@\n-                    }\n-                } catch (CertStoreException cse) {\n-                    if (debug != null) {\n-                        debug.println(\"exception getting certs from CertStore:\");\n-                        cse.printStackTrace();\n@@ -375,0 +393,3 @@\n+            return add;\n+        } finally {\n+            ThreadTrackerHolder.AIA_TRACKER.end(key);\n@@ -376,1 +397,0 @@\n-        return add;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardBuilder.java","additions":37,"deletions":17,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -294,2 +294,1 @@\n-     * @param  isFailOver whether the previous decryption of the\n-     *         encrypted PreMasterSecret message run into problem\n+     * @param  failure true if encoded is incorrect according to previous checks\n@@ -300,1 +299,3 @@\n-            byte[] encoded, boolean isFailOver) {\n+            byte[] encoded, boolean failure) {\n+\n+        byte[] tmp;\n@@ -308,17 +309,5 @@\n-        if (!isFailOver && (encoded != null)) {\n-            \/\/ check the length\n-            if (encoded.length != 48) {\n-                \/\/ private, don't need to clone the byte array.\n-                return replacer;\n-            }\n-\n-            int encodedVersion =\n-                    ((encoded[0] & 0xFF) << 8) | (encoded[1] & 0xFF);\n-            if (clientVersion != encodedVersion) {\n-                if (clientVersion > 0x0301 ||               \/\/ 0x0301: TLSv1\n-                       serverVersion != encodedVersion) {\n-                    encoded = replacer;\n-                }   \/\/ Otherwise, For compatibility, we maintain the behavior\n-                    \/\/ that the version in pre_master_secret can be the\n-                    \/\/ negotiated version for TLS v1.0 and SSL v3.0.\n-            }\n+        if (failure) {\n+            tmp = replacer;\n+        } else {\n+            tmp = encoded;\n+        }\n@@ -326,0 +315,7 @@\n+        if (tmp == null) {\n+            encoded = replacer;\n+        } else {\n+            encoded = tmp;\n+        }\n+        \/\/ check the length\n+        if (encoded.length != 48) {\n@@ -327,1 +323,3 @@\n-            return encoded;\n+            tmp = replacer;\n+        } else {\n+            tmp = encoded;\n@@ -330,2 +328,13 @@\n-        \/\/ private, don't need to clone the byte array.\n-        return replacer;\n+        int encodedVersion =\n+                ((tmp[0] & 0xFF) << 8) | (tmp[1] & 0xFF);\n+        int check1 = 0;\n+        int check2 = 0;\n+        int check3 = 0;\n+        if (clientVersion != encodedVersion) check1 = 1;\n+        if (clientVersion > 0x0301) check2 = 1;\n+        if (serverVersion != encodedVersion) check3 = 1;\n+        if ((check1 & (check2 | check3)) == 1) {\n+            return replacer;\n+        } else {\n+            return tmp;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":32,"deletions":23,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+#include <stdint.h>\n@@ -1198,1 +1199,1 @@\n-            keys = _ck_ntohl(lpc[2]) -  _ck_ntohl(lpc[1]) + 1;\n+            keys = _ck_ntohl(lpc[2]) - _ck_ntohl(lpc[1]) + 1;\n@@ -1680,1 +1681,1 @@\n-            int index;\n+            int64_t low, high, index;\n@@ -1684,1 +1685,4 @@\n-            index = _ck_ntohl(lpc[2]) - _ck_ntohl(lpc[1]);\n+            low  = _ck_ntohl(lpc[1]);\n+            high = _ck_ntohl(lpc[2]);\n+            index = high - low;\n+            \/\/ The value of low must be less than or equal to high - i.e. index >= 0\n","filename":"src\/java.base\/share\/native\/libverify\/check_code.c","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,4 +50,1 @@\n-        int h = dwVolumeSerialNumber;\n-        h = h << 31 + nFileIndexHigh;\n-        h = h << 31 + nFileIndexLow;\n-        return h;\n+        return dwVolumeSerialNumber + nFileIndexHigh + nFileIndexLow;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileKey.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,2 @@\n-     * @return if the event has been consumed\n+     * @return {@code true} if the event has been consumed, otherwise\n+     *         {@code false}\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/eawt\/event\/GestureEvent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -389,1 +389,3 @@\n-            \"F8\", \"focusHeader\"\n+            \"F8\", \"focusHeader\",\n+            \"ctrl shift UP\", \"selectFirstRowExtendSelection\",\n+            \"ctrl shift DOWN\", \"selectLastRowExtendSelection\"\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaKeyBindings.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.reflect.Constructor;\n@@ -66,0 +67,1 @@\n+import javax.swing.tree.TreePath;\n@@ -760,0 +762,15 @@\n+    private static Accessible createAccessibleTreeNode(JTree t, TreePath p) {\n+        Accessible a = null;\n+\n+        try {\n+            Class<?> accessibleJTreeNodeClass = Class.forName(\"javax.swing.JTree$AccessibleJTree$AccessibleJTreeNode\");\n+            Constructor<?> constructor = accessibleJTreeNodeClass.getConstructor(t.getAccessibleContext().getClass(), JTree.class, TreePath.class, Accessible.class);\n+            constructor.setAccessible(true);\n+            a = ((Accessible) constructor.newInstance(t.getAccessibleContext(), t, p, null));\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+\n+        return a;\n+    }\n+\n@@ -766,1 +783,0 @@\n-                ArrayList<Object> currentLevelChildren = new ArrayList<Object>();\n@@ -768,0 +784,47 @@\n+\n+                Accessible at = null;\n+                if (a instanceof CAccessible) {\n+                    at = CAccessible.getSwingAccessible(a);\n+                } else {\n+                    at = a;\n+                }\n+\n+                if (at instanceof JTree) {\n+                    JTree tree = ((JTree) at);\n+\n+                    if (whichChildren == JAVA_AX_ALL_CHILDREN) {\n+                        int count = tree.getRowCount();\n+                        for (int i = 0; i < count; i++) {\n+                            TreePath path = tree.getPathForRow(i);\n+                            Accessible an = createAccessibleTreeNode(tree, path);\n+                            if (an != null) {\n+                                AccessibleContext ac = an.getAccessibleContext();\n+                                if (ac != null) {\n+                                    allChildren.add(an);\n+                                    allChildren.add(ac.getAccessibleRole());;\n+                                    allChildren.add(String.valueOf((tree.isRootVisible() ? path.getPathCount() : path.getPathCount() - 1)));\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    if (whichChildren == JAVA_AX_SELECTED_CHILDREN) {\n+                        int count = tree.getSelectionCount();\n+                        for (int i = 0; i < count; i++) {\n+                            TreePath path = tree.getSelectionPaths()[i];\n+                            Accessible an = createAccessibleTreeNode(tree, path);\n+                            if (an != null) {\n+                                AccessibleContext ac = an.getAccessibleContext();\n+                                if (ac != null) {\n+                                    allChildren.add(an);\n+                                    allChildren.add(ac.getAccessibleRole());\n+                                    allChildren.add(String.valueOf((tree.isRootVisible() ? path.getPathCount() : path.getPathCount() - 1)));\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    return allChildren.toArray();\n+                }\n+\n+                ArrayList<Object> currentLevelChildren = new ArrayList<Object>();\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibility.java","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1700,0 +1700,1 @@\n+            [nsWindow makeKeyAndOrderFront: nil];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTWindow.m","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1061,1 +1061,1 @@\n-                      \"ctrl shift DOWN\", \"selectNextRowExtendSelection\",\n+                      \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n@@ -1069,1 +1069,1 @@\n-                        \"ctrl shift UP\", \"selectPreviousRowExtendSelection\",\n+                        \"ctrl shift UP\", \"selectFirstRowExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1032,1 +1032,1 @@\n-                      \"ctrl shift DOWN\", \"selectNextRowExtendSelection\",\n+                      \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n@@ -1040,1 +1040,1 @@\n-                        \"ctrl shift UP\", \"selectPreviousRowExtendSelection\",\n+                        \"ctrl shift UP\", \"selectFirstRowExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifLookAndFeel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,4 +233,2 @@\n-     * Reports\n-     * whether or not drag\n-     * {@code Image} support\n-     * is available on the underlying platform.\n+     * Reports whether or not drag {@code Image} support is available on the\n+     * underlying platform.\n@@ -238,1 +236,2 @@\n-     * @return if the Drag Image support is available on this platform\n+     * @return {@code true} if the Drag Image support is available on this\n+     *         platform, otherwise {@code false}\n@@ -240,1 +239,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/dnd\/DragSource.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,3 +245,2 @@\n-     * This method returns a {@code boolean}\n-     * indicating if the given {@code DataFlavor} is\n-     * supported by this {@code DropTargetContext}.\n+     * This method returns a {@code boolean} indicating if the given\n+     * {@code DataFlavor} is supported by this {@code DropTargetContext}.\n@@ -249,3 +248,3 @@\n-     * @param df the {@code DataFlavor}\n-     *\n-     * @return if the {@code DataFlavor} specified is supported\n+     * @param  df the {@code DataFlavor} to test\n+     * @return {@code true} if the {@code DataFlavor} specified is supported,\n+     *         otherwise {@code false}\n@@ -253,1 +252,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/dnd\/DropTargetContext.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,2 +157,2 @@\n-     * This method returns a {@code boolean} indicating\n-     * if the specified {@code DataFlavor} is supported.\n+     * This method returns a {@code boolean} indicating if the specified\n+     * {@code DataFlavor} is supported.\n@@ -160,3 +160,3 @@\n-     * @param df the {@code DataFlavor} to test\n-     *\n-     * @return if a particular DataFlavor is supported\n+     * @param  df the {@code DataFlavor} to test\n+     * @return {@code true} if a particular {@code DataFlavor} is supported,\n+     *         otherwise {@code false}\n@@ -164,1 +164,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/dnd\/DropTargetDragEvent.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,3 +191,2 @@\n-     * This method returns a {@code boolean} indicating if the\n-     * specified {@code DataFlavor} is available\n-     * from the source.\n+     * This method returns a {@code boolean} indicating if the specified\n+     * {@code DataFlavor} is available from the source.\n@@ -195,3 +194,3 @@\n-     * @param df the {@code DataFlavor} to test\n-     *\n-     * @return if the DataFlavor specified is available from the source\n+     * @param  df the {@code DataFlavor} to test\n+     * @return {@code true} if the {@code DataFlavor} specified is available\n+     *         from the source, otherwise {@code false}\n@@ -199,1 +198,0 @@\n-\n@@ -259,2 +257,2 @@\n-     * This method returns an {@code int} indicating if\n-     * the source is in the same JVM as the target.\n+     * This method returns a {@code boolean} indicating if the source is in the\n+     * same JVM as the target.\n@@ -262,1 +260,2 @@\n-     * @return if the Source is in the same JVM\n+     * @return {@code true} if the Source is in the same JVM, otherwise\n+     *         {@code false}\n@@ -264,1 +263,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/dnd\/DropTargetDropEvent.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,3 +81,5 @@\n-     * Return whether or not the DragSource Transferable is in the\n-     * same JVM as the Target.\n-     * @return if the DragSource Transferable is in the same JVM as the Target\n+     * Return whether or not the DragSource Transferable is in the same JVM as\n+     * the Target.\n+     *\n+     * @return {@code true} if the DragSource Transferable is in the same JVM as\n+     *         the Target, otherwise {@code false}\n@@ -85,1 +87,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/dnd\/peer\/DropTargetContextPeer.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -771,1 +771,1 @@\n-            for (int i = 0; i < srcNumComp; i++) {\n+            for (int i = 0; i < iccSrcNumComp; i++) {\n@@ -785,1 +785,1 @@\n-            for (int i = 0; i < dstNumComp; i++) {\n+            for (int i = 0; i < iccDstNumComp; i++) {\n@@ -838,1 +838,1 @@\n-                        color = srcColorSpace.fromCIEXYZ(dstColor);\n+                        color = dstColorSpace.fromCIEXYZ(dstColor);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorConvertOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -500,2 +500,4 @@\n-     * @param gc the reference graphics configuration\n-     * @return if the peer needs to be recreated for the changes to take effect\n+     *\n+     * @param  gc the reference graphics configuration\n+     * @return {@code true} if the peer needs to be recreated for the changes to\n+     *         take effect, otherwise {@code false}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/peer\/ComponentPeer.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,6 +206,5 @@\n-     * Reports whether or not this\n-     * {@code BeanContext} is empty.\n-     * A {@code BeanContext} is considered\n-     * empty when it contains zero\n-     * nested children.\n-     * @return if there are not children\n+     * Reports whether or not this {@code BeanContext} is empty. A\n+     * {@code BeanContext} is considered empty when it contains zero nested\n+     * children.\n+     *\n+     * @return {@code true} if there are no children, otherwise {@code false}\n@@ -220,4 +219,5 @@\n-     * Determines whether or not the specified object\n-     * is currently a child of this {@code BeanContext}.\n-     * @param o the Object in question\n-     * @return if this object is a child\n+     * Determines whether or not the specified object is currently a child of\n+     * this {@code BeanContext}.\n+     *\n+     * @param  o the Object in question\n+     * @return {@code true} if this object is a child, otherwise {@code false}\n@@ -232,4 +232,5 @@\n-     * Determines whether or not the specified object\n-     * is currently a child of this {@code BeanContext}.\n-     * @param o the Object in question\n-     * @return if this object is a child\n+     * Determines whether or not the specified object is currently a child of\n+     * this {@code BeanContext}.\n+     *\n+     * @param  o the Object in question\n+     * @return {@code true} if this object is a child, otherwise {@code false}\n@@ -842,4 +843,4 @@\n-     * Is this {@code BeanContext} in the\n-     * process of being serialized?\n-     * @return if this {@code BeanContext} is\n-     * currently being serialized\n+     * Is this {@code BeanContext} in the process of being serialized?\n+     *\n+     * @return {@code true} if this {@code BeanContext} is currently being\n+     *         serialized, otherwise {@code false}\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextSupport.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -333,0 +333,1 @@\n+                Thread.currentThread().interrupt();\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ImageIcon.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -321,4 +321,4 @@\n-     * Gets the line-wrapping policy of the text area.  If set\n-     * to true the lines will be wrapped if they are too long\n-     * to fit within the allocated width.  If set to false,\n-     * the lines will always be unwrapped.\n+     * Gets the line-wrapping policy of the text area. If set to {@code true}\n+     * the lines will be wrapped if they are too long to fit within the\n+     * allocated width. If set to {@code false}, the lines will always be\n+     * unwrapped.\n@@ -326,1 +326,1 @@\n-     * @return if lines will be wrapped\n+     * @return {@code true} if lines will be wrapped, otherwise {@code false}\n@@ -353,5 +353,4 @@\n-     * Gets the style of wrapping used if the text area is wrapping\n-     * lines.  If set to true the lines will be wrapped at word\n-     * boundaries (ie whitespace) if they are too long\n-     * to fit within the allocated width.  If set to false,\n-     * the lines will be wrapped at character boundaries.\n+     * Gets the style of wrapping used if the text area is wrapping lines. If\n+     * set to {@code true} the lines will be wrapped at word boundaries (ie\n+     * whitespace) if they are too long to fit within the allocated width. If\n+     * set to {@code false}, the lines will be wrapped at character boundaries.\n@@ -359,2 +358,2 @@\n-     * @return if the wrap style should be word boundaries\n-     *  instead of character boundaries\n+     * @return {@code true} if the wrap style should be word boundaries instead\n+     *         of character boundaries, otherwise {@code false}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTextArea.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1464,1 +1464,1 @@\n-                      \"ctrl shift DOWN\", \"selectNextRowExtendSelection\",\n+                      \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n@@ -1472,1 +1472,1 @@\n-                        \"ctrl shift UP\", \"selectPreviousRowExtendSelection\",\n+                        \"ctrl shift UP\", \"selectFirstRowExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLookAndFeel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1104,1 +1104,2 @@\n-         * @return if the width of children should be synchronized\n+         * @return {@code true} if the width of children should be synchronized,\n+         *         otherwise {@code false}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicOptionPaneUI.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2078,3 +2078,5 @@\n-         * Returns if scrolling should occur\n-         * @param direction the direction.\n-         * @return if scrolling should occur\n+         * Returns if scrolling should occur.\n+         *\n+         * @param  direction the direction\n+         * @return {@code true} if scrolling should occur, otherwise\n+         *         {@code false}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSliderUI.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1190,1 +1190,1 @@\n-                      \"ctrl shift DOWN\", \"selectNextRowExtendSelection\",\n+                      \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n@@ -1198,1 +1198,1 @@\n-                        \"ctrl shift UP\", \"selectPreviousRowExtendSelection\",\n+                        \"ctrl shift UP\", \"selectFirstRowExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalLookAndFeel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -576,1 +576,1 @@\n-                      \"ctrl shift DOWN\", \"selectNextRowExtendSelection\",\n+                      \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n@@ -584,1 +584,1 @@\n-                        \"ctrl shift UP\", \"selectPreviousRowExtendSelection\",\n+                        \"ctrl shift UP\", \"selectFirstRowExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthStyle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,3 @@\n-    private Icon expandedIconWrapper = new ExpandedIconWrapper();\n+    private Icon expandedIconWrapper;\n+\n+    private Icon collapsedIconWrapper;\n@@ -102,0 +104,5 @@\n+    @Override\n+    public Icon getCollapsedIcon() {\n+        return collapsedIconWrapper;\n+    }\n+\n@@ -108,0 +115,2 @@\n+        expandedIconWrapper = new IconWrapper(expandedIcon);\n+        collapsedIconWrapper = new IconWrapper(collapsedIcon);\n@@ -781,1 +790,2 @@\n-    \/\/ BasicTreeUI directly uses expandIcon outside of the Synth methods.\n+    \/\/ BasicTreeUI directly uses expandIcon and collapsedIcon outside of the\n+    \/\/ Synth methods.\n@@ -785,1 +795,9 @@\n-    private class ExpandedIconWrapper implements SynthIcon {\n+\n+    private class IconWrapper implements SynthIcon {\n+        Icon iconType;\n+\n+        public IconWrapper(Icon type) {\n+            super();\n+            iconType = type;\n+        }\n+\n@@ -790,4 +808,0 @@\n-                SynthGraphicsUtils.paintIcon(expandedIcon, context, g, x, y, w, h);\n-            }\n-            else {\n-                SynthGraphicsUtils.paintIcon(expandedIcon, context, g, x, y, w, h);\n@@ -795,0 +809,1 @@\n+            SynthGraphicsUtils.paintIcon(iconType, context, g, x, y, w, h);\n@@ -798,1 +813,0 @@\n-            int width;\n@@ -801,1 +815,0 @@\n-                width = SynthGraphicsUtils.getIconWidth(expandedIcon, context);\n@@ -803,4 +816,1 @@\n-            else {\n-                width = SynthGraphicsUtils.getIconWidth(expandedIcon, context);\n-            }\n-            return width;\n+            return SynthGraphicsUtils.getIconWidth(iconType, context);\n@@ -810,1 +820,0 @@\n-            int height;\n@@ -813,4 +822,0 @@\n-                height = SynthGraphicsUtils.getIconHeight(expandedIcon, context);\n-            }\n-            else {\n-                height = SynthGraphicsUtils.getIconHeight(expandedIcon, context);\n@@ -818,1 +823,1 @@\n-            return height;\n+            return SynthGraphicsUtils.getIconHeight(iconType, context);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTreeUI.java","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,3 +137,0 @@\n-     * @return if the layout is valid along the given axis\n-     *\n-     * @param axis either <code>View.X_AXIS<\/code> or <code>View.Y_AXIS<\/code>\n@@ -141,0 +138,3 @@\n+     * @param  axis either {@code View.X_AXIS} or {@code View.Y_AXIS}\n+     * @return {@code true} if the layout is valid along the given axis,\n+     *         otherwise {@code false}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/BoxView.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,3 +210,5 @@\n-     * Determine if the glyphs should be underlined.  If true,\n-     * an underline should be drawn through the baseline.\n-     * @return if the glyphs should be underlined\n+     * Determine if the glyphs should be underlined. If {@code true}, an\n+     * underline should be drawn through the baseline.\n+     *\n+     * @return {@code true} if the glyphs should be underlined, otherwise\n+     *         {@code false}\n@@ -220,4 +222,5 @@\n-     * Determine if the glyphs should have a strikethrough\n-     * line.  If true, a line should be drawn through the center\n-     * of the glyphs.\n-     * @return if the glyphs should have a strikethrough line\n+     * Determine if the glyphs should have a strikethrough line. If\n+     * {@code true}, a line should be drawn through the center of the glyphs.\n+     *\n+     * @return {@code true} if the glyphs should have a strikethrough line,\n+     *         otherwise {@code false}\n@@ -232,1 +235,3 @@\n-     * @return if the glyphs should be rendered as superscript\n+     *\n+     * @return {@code true} if the glyphs should be rendered as superscript,\n+     *         otherwise {@code false}\n@@ -241,1 +246,3 @@\n-     * @return if the glyphs should be rendered as subscript\n+     *\n+     * @return {@code true} if the glyphs should be rendered as subscript,\n+     *         otherwise {@code false}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/GlyphView.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2630,1 +2630,1 @@\n-                    lv.span = Math.max(0, Math.min(1, lu.value));\n+                    lv.span = Math.max(0, lu.value);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/CSS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,1 +203,1 @@\n-     * @return if the flavor is supported\n+     * @return {@code true} if the flavor is supported, otherwise {@code false}\n@@ -205,1 +205,0 @@\n-\n@@ -292,1 +291,2 @@\n-     * @return if the transfer is a local one\n+     * @return {@code true} if the transfer is a local one, otherwise\n+     *         {@code false}\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/dnd\/SunDropTargetContextPeer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -611,1 +611,1 @@\n-                        \"ctrl shift DOWN\", \"selectNextRowExtendSelection\",\n+                        \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n@@ -619,1 +619,1 @@\n-                        \"ctrl shift UP\", \"selectPreviousRowExtendSelection\",\n+                        \"ctrl shift UP\", \"selectFirstRowExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/plaf\/GTKKeybindings.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -519,1 +519,1 @@\n-                        \"ctrl shift DOWN\", \"selectNextRowExtendSelection\",\n+                        \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n@@ -527,1 +527,1 @@\n-                        \"ctrl shift UP\", \"selectPreviousRowExtendSelection\",\n+                        \"ctrl shift UP\", \"selectFirstRowExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/plaf\/WindowsKeybindings.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Little Color Management System (LCMS) v2.15\n+## Little Color Management System (LCMS) v2.16\n@@ -5,1 +5,0 @@\n-README.1ST file information\n@@ -7,1 +6,1 @@\n-LittleCMS core is released under MIT License\n+MIT License\n@@ -9,4 +8,1 @@\n----------------------------------\n-\n-Little CMS\n-Copyright (c) 1998-2023 Marti Maria Saguer\n+Copyright (C) 1998-2023 Marti Maria Saguer\n@@ -15,6 +11,5 @@\n-a copy of this software and associated documentation files (the\n-\"Software\"), to deal in the Software without restriction, including\n-without limitation the rights to use, copy, modify, merge, publish,\n-distribute, sublicense, and\/or sell copies of the Software, and to\n-permit persons to whom the Software is furnished to do so, subject\n-to the following conditions:\n+a copy of this software and associated documentation files (the \"Software\"),\n+to deal in the Software without restriction, including without limitation\n+the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+and\/or sell copies of the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following conditions:\n@@ -22,2 +17,2 @@\n-The above copyright notice and this permission notice shall be\n-included in all copies or substantial portions of the Software.\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n@@ -26,6 +21,6 @@\n-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n+THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n@@ -50,1 +45,0 @@\n-\n@@ -94,0 +88,1 @@\n+Diogo Teles Sant'Anna\n","filename":"src\/java.desktop\/share\/legal\/lcms.md","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-void ComputeIncrementsForChunky(cmsUInt32Number Format,\n+cmsBool ComputeIncrementsForChunky(cmsUInt32Number Format,\n@@ -448,1 +448,1 @@\n-           return;\n+           return FALSE;\n@@ -485,0 +485,2 @@\n+\n+       return TRUE;\n@@ -491,1 +493,1 @@\n-void ComputeIncrementsForPlanar(cmsUInt32Number Format,\n+cmsBool ComputeIncrementsForPlanar(cmsUInt32Number Format,\n@@ -505,1 +507,1 @@\n-           return;\n+           return FALSE;\n@@ -541,0 +543,2 @@\n+\n+       return TRUE;\n@@ -547,1 +551,1 @@\n-void  ComputeComponentIncrements(cmsUInt32Number Format,\n+cmsBool ComputeComponentIncrements(cmsUInt32Number Format,\n@@ -554,1 +558,1 @@\n-              ComputeIncrementsForPlanar(Format,  BytesPerPlane, ComponentStartingOrder, ComponentPointerIncrements);\n+              return ComputeIncrementsForPlanar(Format,  BytesPerPlane, ComponentStartingOrder, ComponentPointerIncrements);\n@@ -557,1 +561,1 @@\n-              ComputeIncrementsForChunky(Format,  ComponentStartingOrder, ComponentPointerIncrements);\n+              return ComputeIncrementsForChunky(Format,  ComponentStartingOrder, ComponentPointerIncrements);\n@@ -562,2 +566,0 @@\n-\n-\n@@ -598,2 +600,4 @@\n-    ComputeComponentIncrements(p->InputFormat, Stride->BytesPerPlaneIn, SourceStartingOrder, SourceIncrements);\n-    ComputeComponentIncrements(p->OutputFormat, Stride->BytesPerPlaneOut, DestStartingOrder, DestIncrements);\n+    if (!ComputeComponentIncrements(p->InputFormat, Stride->BytesPerPlaneIn, SourceStartingOrder, SourceIncrements))\n+        return;\n+    if (!ComputeComponentIncrements(p->OutputFormat, Stride->BytesPerPlaneOut, DestStartingOrder, DestIncrements))\n+        return;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsalpha.c","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        \/\/ Keywords\n+        \/\/ IT8 symbols\n@@ -98,1 +98,13 @@\n-        SINCLUDE\n+        SINCLUDE,\n+\n+        \/\/ Cube symbols\n+\n+        SDOMAIN_MAX,\n+        SDOMAIN_MIN,\n+        S_LUT1D_SIZE,\n+        S_LUT1D_INPUT_RANGE,\n+        S_LUT3D_SIZE,\n+        S_LUT3D_INPUT_RANGE,\n+        S_LUT_IN_VIDEO_RANGE,\n+        S_LUT_OUT_VIDEO_RANGE,\n+        STITLE\n@@ -181,0 +193,4 @@\n+        \/\/ Partser type\n+        cmsBool        IsCUBE;\n+\n+        \/\/ Tables\n@@ -240,2 +256,2 @@\n-\/\/ The keyword->symbol translation table. Sorting is required.\n-static const KEYWORD TabKeys[] = {\n+\/\/ The keyword->symbol translation tables. Sorting is required.\n+static const KEYWORD TabKeysIT8[] = {\n@@ -254,1 +270,19 @@\n-#define NUMKEYS (sizeof(TabKeys)\/sizeof(KEYWORD))\n+#define NUMKEYS_IT8 (sizeof(TabKeysIT8)\/sizeof(KEYWORD))\n+\n+static const KEYWORD TabKeysCUBE[] = {\n+\n+        {\"DOMAIN_MAX\",             SDOMAIN_MAX },\n+        {\"DOMAIN_MIN\",             SDOMAIN_MIN },\n+        {\"LUT_1D_SIZE\",            S_LUT1D_SIZE },\n+        {\"LUT_1D_INPUT_RANGE\",     S_LUT1D_INPUT_RANGE },\n+        {\"LUT_3D_SIZE\",            S_LUT3D_SIZE },\n+        {\"LUT_3D_INPUT_RANGE\",     S_LUT3D_INPUT_RANGE },\n+        {\"LUT_IN_VIDEO_RANGE\",     S_LUT_IN_VIDEO_RANGE },\n+        {\"LUT_OUT_VIDEO_RANGE\",    S_LUT_OUT_VIDEO_RANGE },\n+        {\"TITLE\",                  STITLE }\n+\n+};\n+\n+#define NUMKEYS_CUBE (sizeof(TabKeysCUBE)\/sizeof(KEYWORD))\n+\n+\n@@ -458,1 +492,1 @@\n-    return (c == ' ') || (c == '\\t') ;\n+    return (c == ' ') || (c == '\\t');\n@@ -479,1 +513,1 @@\n-     return !isdigit(c) && ismiddle(c);\n+     return c != '-' && !isdigit(c) && ismiddle(c);\n@@ -518,1 +552,1 @@\n-        strncpy(buffer, relPath, MaxLen);\n+        memcpy(buffer, relPath, MaxLen);\n@@ -524,1 +558,1 @@\n-    strncpy(buffer, basePath, MaxLen);\n+    memcpy(buffer, basePath, MaxLen);\n@@ -606,1 +640,1 @@\n-SYMBOL BinSrchKey(const char *id)\n+SYMBOL BinSrchKey(const char *id, int NumKeys, const KEYWORD* TabKeys)\n@@ -609,1 +643,1 @@\n-    int r = NUMKEYS;\n+    int r = NumKeys;\n@@ -779,1 +813,1 @@\n-\/\/ Reads a string, special case to avoid infinite resursion on .include\n+\/\/ Reads a string, special case to avoid infinite recursion on .include\n@@ -836,1 +870,3 @@\n-            key = BinSrchKey(StringPtr(it8->id));\n+            key = BinSrchKey(StringPtr(it8->id),\n+                    it8->IsCUBE ? NUMKEYS_CUBE : NUMKEYS_IT8,\n+                    it8->IsCUBE ? TabKeysCUBE : TabKeysIT8);\n@@ -945,0 +981,1 @@\n+                    StringClear(it8->id);\n@@ -974,1 +1011,1 @@\n-            if (it8 ->ch == '\\n')\n+            if (it8->ch == '\\n')\n@@ -1295,1 +1332,6 @@\n-        \/\/     return SynError(it8, \"duplicate key <%s>\", Key);\n+        if (cmsstrcasecmp(Key, \"NUMBER_OF_FIELDS\") == 0 ||\n+            cmsstrcasecmp(Key, \"NUMBER_OF_SETS\") == 0) {\n+\n+            SynError(it8, \"duplicate key <%s>\", Key);\n+            return NULL;\n+        }\n@@ -1416,0 +1458,2 @@\n+    it8->IsCUBE = FALSE;\n+\n@@ -1697,1 +1741,1 @@\n-    if (nSet >= nPatches || nField >= nSamples)\n+    if (nSet < 0 || nSet >= nPatches || nField < 0 || nField >= nSamples)\n@@ -1882,1 +1926,1 @@\n-       for (i = 0; i < nSamples; i++) {\n+       if (nSamples <= t->nSamples) {\n@@ -1884,3 +1928,6 @@\n-              WriteStr(fp, t->DataFormat[i]);\n-              WriteStr(fp, ((i == (nSamples-1)) ? \"\\n\" : \"\\t\"));\n-          }\n+           for (i = 0; i < nSamples; i++) {\n+\n+               WriteStr(fp, t->DataFormat[i]);\n+               WriteStr(fp, ((i == (nSamples - 1)) ? \"\\n\" : \"\\t\"));\n+           }\n+       }\n@@ -1896,1 +1943,1 @@\n-       int  i, j;\n+       int  i, j, nPatches;\n@@ -1903,1 +1950,1 @@\n-       t->nPatches = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n+       nPatches = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n@@ -1905,1 +1952,1 @@\n-       for (i = 0; i < t-> nPatches; i++) {\n+       if (nPatches <= t->nPatches) {\n@@ -1907,1 +1954,1 @@\n-              WriteStr(fp, \" \");\n+           for (i = 0; i < nPatches; i++) {\n@@ -1909,1 +1956,1 @@\n-              for (j = 0; j < t->nSamples; j++) {\n+               WriteStr(fp, \" \");\n@@ -1911,1 +1958,1 @@\n-                     char *ptr = t->Data[i*t->nSamples+j];\n+               for (j = 0; j < t->nSamples; j++) {\n@@ -1913,3 +1960,1 @@\n-                     if (ptr == NULL) WriteStr(fp, \"\\\"\\\"\");\n-                     else {\n-                         \/\/ If value contains whitespace, enclose within quote\n+                   char* ptr = t->Data[i * t->nSamples + j];\n@@ -1917,1 +1962,3 @@\n-                         if (strchr(ptr, ' ') != NULL) {\n+                   if (ptr == NULL) WriteStr(fp, \"\\\"\\\"\");\n+                   else {\n+                       \/\/ If value contains whitespace, enclose within quote\n@@ -1919,7 +1966,1 @@\n-                             WriteStr(fp, \"\\\"\");\n-                             WriteStr(fp, ptr);\n-                             WriteStr(fp, \"\\\"\");\n-                         }\n-                         else\n-                            WriteStr(fp, ptr);\n-                     }\n+                       if (strchr(ptr, ' ') != NULL) {\n@@ -1927,2 +1968,11 @@\n-                     WriteStr(fp, ((j == (t->nSamples-1)) ? \"\\n\" : \"\\t\"));\n-              }\n+                           WriteStr(fp, \"\\\"\");\n+                           WriteStr(fp, ptr);\n+                           WriteStr(fp, \"\\\"\");\n+                       }\n+                       else\n+                           WriteStr(fp, ptr);\n+                   }\n+\n+                   WriteStr(fp, ((j == (t->nSamples - 1)) ? \"\\n\" : \"\\t\"));\n+               }\n+           }\n@@ -1949,4 +1999,14 @@\n-            cmsIT8SetTable(hIT8, i);\n-            WriteHeader(it8, &sd);\n-            WriteDataFormat(&sd, it8);\n-            WriteData(&sd, it8);\n+        TABLE* t;\n+\n+        if (cmsIT8SetTable(hIT8, i) < 0) goto Error;\n+\n+        \/**\n+        * Check for wrong data\n+        *\/\n+        t = GetTable(it8);\n+        if (t->Data == NULL) goto Error;\n+        if (t->DataFormat == NULL) goto Error;\n+\n+        WriteHeader(it8, &sd);\n+        WriteDataFormat(&sd, it8);\n+        WriteData(&sd, it8);\n@@ -1956,1 +2016,0 @@\n-\n@@ -1958,0 +2017,5 @@\n+\n+Error:\n+    fclose(sd.stream);\n+    return FALSE;\n+\n@@ -2334,1 +2398,1 @@\n-    cmsUInt32Number nOldTable = it8 ->nTable;\n+    cmsUInt32Number nOldTable = it8->nTable;\n@@ -2336,1 +2400,1 @@\n-    for (j=0; j < it8 ->TablesCount; j++) {\n+    for (j = 0; j < it8->TablesCount; j++) {\n@@ -2338,1 +2402,1 @@\n-    TABLE* t = it8 ->Tab + j;\n+        TABLE* t = it8->Tab + j;\n@@ -2340,2 +2404,2 @@\n-    t -> SampleID = 0;\n-    it8 ->nTable = j;\n+        t->SampleID = 0;\n+        it8->nTable = j;\n@@ -2343,6 +2407,6 @@\n-    for (idField = 0; idField < t -> nSamples; idField++)\n-    {\n-        if (t ->DataFormat == NULL){\n-            SynError(it8, \"Undefined DATA_FORMAT\");\n-            return;\n-        }\n+        for (idField = 0; idField < t->nSamples; idField++)\n+        {\n+            if (t->DataFormat == NULL) {\n+                SynError(it8, \"Undefined DATA_FORMAT\");\n+                return;\n+            }\n@@ -2350,2 +2414,2 @@\n-        Fld = t->DataFormat[idField];\n-        if (!Fld) continue;\n+            Fld = t->DataFormat[idField];\n+            if (!Fld) continue;\n@@ -2354,1 +2418,1 @@\n-        if (cmsstrcasecmp(Fld, \"SAMPLE_ID\") == 0) {\n+            if (cmsstrcasecmp(Fld, \"SAMPLE_ID\") == 0) {\n@@ -2356,2 +2420,2 @@\n-            t -> SampleID = idField;\n-        }\n+                t->SampleID = idField;\n+            }\n@@ -2359,1 +2423,1 @@\n-        \/\/ \"LABEL\" is an extension. It keeps references to forward tables\n+            \/\/ \"LABEL\" is an extension. It keeps references to forward tables\n@@ -2361,1 +2425,1 @@\n-        if ((cmsstrcasecmp(Fld, \"LABEL\") == 0) || Fld[0] == '$') {\n+            if ((cmsstrcasecmp(Fld, \"LABEL\") == 0) || Fld[0] == '$') {\n@@ -2363,2 +2427,2 @@\n-            \/\/ Search for table references...\n-            for (i = 0; i < t->nPatches; i++) {\n+                \/\/ Search for table references...\n+                for (i = 0; i < t->nPatches; i++) {\n@@ -2366,1 +2430,1 @@\n-                char* Label = GetData(it8, i, idField);\n+                    char* Label = GetData(it8, i, idField);\n@@ -2368,1 +2432,1 @@\n-                if (Label) {\n+                    if (Label) {\n@@ -2370,1 +2434,1 @@\n-                    cmsUInt32Number k;\n+                        cmsUInt32Number k;\n@@ -2372,2 +2436,2 @@\n-                    \/\/ This is the label, search for a table containing\n-                    \/\/ this property\n+                        \/\/ This is the label, search for a table containing\n+                        \/\/ this property\n@@ -2375,1 +2439,1 @@\n-                    for (k = 0; k < it8->TablesCount; k++) {\n+                        for (k = 0; k < it8->TablesCount; k++) {\n@@ -2377,2 +2441,2 @@\n-                        TABLE* Table = it8->Tab + k;\n-                        KEYVALUE* p;\n+                            TABLE* Table = it8->Tab + k;\n+                            KEYVALUE* p;\n@@ -2380,1 +2444,1 @@\n-                        if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {\n+                            if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {\n@@ -2382,2 +2446,2 @@\n-                            \/\/ Available, keep type and table\n-                            char Buffer[256];\n+                                \/\/ Available, keep type and table\n+                                char Buffer[256];\n@@ -2385,2 +2449,2 @@\n-                            char* Type = p->Value;\n-                            int  nTable = (int)k;\n+                                char* Type = p->Value;\n+                                int  nTable = (int)k;\n@@ -2388,1 +2452,1 @@\n-                            snprintf(Buffer, 255, \"%s %d %s\", Label, nTable, Type);\n+                                snprintf(Buffer, 255, \"%s %d %s\", Label, nTable, Type);\n@@ -2390,1 +2454,2 @@\n-                            SetData(it8, i, idField, Buffer);\n+                                SetData(it8, i, idField, Buffer);\n+                            }\n@@ -2393,2 +2458,0 @@\n-\n-\n@@ -2396,1 +2459,0 @@\n-\n@@ -2398,2 +2460,0 @@\n-\n-\n@@ -2401,2 +2461,0 @@\n-\n-    }\n@@ -2405,1 +2463,1 @@\n-    it8 ->nTable = nOldTable;\n+    it8->nTable = nOldTable;\n@@ -2496,1 +2554,1 @@\n-        return FALSE;\n+        return NULL;\n@@ -2508,1 +2566,1 @@\n-        return FALSE;\n+        return NULL;\n@@ -2605,8 +2663,2 @@\n-        Props = (char**)AllocChunk(it8, sizeof(char*) * n);\n-        if (Props != NULL) {\n-\n-                \/\/ Pass#2 - Fill pointers\n-                n = 0;\n-                for (p = t->HeaderList; p != NULL; p = p->Next) {\n-                        Props[n++] = p->Keyword;\n-                }\n+    Props = (char**)AllocChunk(it8, sizeof(char*) * n);\n+    if (Props != NULL) {\n@@ -2614,0 +2666,4 @@\n+        \/\/ Pass#2 - Fill pointers\n+        n = 0;\n+        for (p = t->HeaderList; p != NULL; p = p->Next) {\n+            Props[n++] = p->Keyword;\n@@ -2615,1 +2671,3 @@\n-        *PropertyNames = Props;\n+\n+    }\n+    *PropertyNames = Props;\n@@ -2975,0 +3033,233 @@\n+\n+static\n+cmsBool ReadNumbers(cmsIT8* cube, int n, cmsFloat64Number* arr)\n+{\n+    int i;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (cube->sy == SINUM)\n+            arr[i] = cube->inum;\n+        else\n+            if (cube->sy == SDNUM)\n+                arr[i] = cube->dnum;\n+            else\n+                return SynError(cube, \"Number expected\");\n+\n+        InSymbol(cube);\n+    }\n+\n+    return CheckEOLN(cube);\n+}\n+\n+static\n+cmsBool ParseCube(cmsIT8* cube, cmsStage** Shaper, cmsStage** CLUT, char title[])\n+{\n+    cmsFloat64Number domain_min[3] = { 0, 0, 0 };\n+    cmsFloat64Number domain_max[3] = { 1.0, 1.0, 1.0 };\n+    cmsFloat64Number check_0_1[2] = { 0, 1.0 };\n+    int shaper_size = 0;\n+    int lut_size = 0;\n+    int i;\n+\n+    InSymbol(cube);\n+\n+    while (cube->sy != SEOF) {\n+        switch (cube->sy)\n+        {\n+        \/\/ Set profile description\n+        case STITLE:\n+            InSymbol(cube);\n+            if (!Check(cube, SSTRING, \"Title string expected\")) return FALSE;\n+            memcpy(title, StringPtr(cube->str), MAXSTR);\n+            title[MAXSTR - 1] = 0;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Define domain\n+        case SDOMAIN_MIN:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 3, domain_min)) return FALSE;\n+            break;\n+\n+        case SDOMAIN_MAX:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 3, domain_max)) return FALSE;\n+            break;\n+\n+        \/\/ Define shaper\n+        case S_LUT1D_SIZE:\n+            InSymbol(cube);\n+            if (!Check(cube, SINUM, \"Shaper size expected\")) return FALSE;\n+            shaper_size = cube->inum;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Deefine CLUT\n+        case S_LUT3D_SIZE:\n+            InSymbol(cube);\n+            if (!Check(cube, SINUM, \"LUT size expected\")) return FALSE;\n+            lut_size = cube->inum;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Range. If present, has to be 0..1.0\n+        case S_LUT1D_INPUT_RANGE:\n+        case S_LUT3D_INPUT_RANGE:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 2, check_0_1)) return FALSE;\n+            if (check_0_1[0] != 0 || check_0_1[1] != 1.0) {\n+                return SynError(cube, \"Unsupported format\");\n+            }\n+            break;\n+\n+        case SEOLN:\n+            InSymbol(cube);\n+            break;\n+\n+        default:\n+        case S_LUT_IN_VIDEO_RANGE:\n+        case S_LUT_OUT_VIDEO_RANGE:\n+            return SynError(cube, \"Unsupported format\");\n+\n+            \/\/ Read and create tables\n+        case SINUM:\n+        case SDNUM:\n+\n+            if (shaper_size > 0) {\n+\n+                cmsToneCurve* curves[3];\n+                cmsFloat32Number* shapers = (cmsFloat32Number*)_cmsMalloc(cube->ContextID, 3 * shaper_size * sizeof(cmsFloat32Number));\n+                if (shapers == NULL) return FALSE;\n+\n+                for (i = 0; i < shaper_size; i++) {\n+\n+                    cmsFloat64Number nums[3];\n+\n+                    if (!ReadNumbers(cube, 3, nums)) return FALSE;\n+\n+                    shapers[i + 0]               = (cmsFloat32Number) ((nums[0] - domain_min[0]) \/ (domain_max[0] - domain_min[0]));\n+                    shapers[i + 1 * shaper_size] = (cmsFloat32Number) ((nums[1] - domain_min[1]) \/ (domain_max[1] - domain_min[1]));\n+                    shapers[i + 2 * shaper_size] = (cmsFloat32Number) ((nums[2] - domain_min[2]) \/ (domain_max[2] - domain_min[2]));\n+                }\n+\n+                for (i = 0; i < 3; i++) {\n+\n+                    curves[i] = cmsBuildTabulatedToneCurveFloat(cube->ContextID, shaper_size,\n+                        &shapers[i * shaper_size]);\n+                    if (curves[i] == NULL) return FALSE;\n+                }\n+\n+                *Shaper = cmsStageAllocToneCurves(cube->ContextID, 3, curves);\n+\n+                cmsFreeToneCurveTriple(curves);\n+            }\n+\n+            if (lut_size > 0) {\n+\n+                int nodes = lut_size * lut_size * lut_size;\n+\n+                cmsFloat32Number* lut_table = _cmsMalloc(cube->ContextID, nodes * 3 * sizeof(cmsFloat32Number));\n+                if (lut_table == NULL) return FALSE;\n+\n+                for (i = 0; i < nodes; i++) {\n+\n+                    cmsFloat64Number nums[3];\n+\n+                    if (!ReadNumbers(cube, 3, nums)) return FALSE;\n+\n+                    lut_table[i * 3 + 2] = (cmsFloat32Number) ((nums[0] - domain_min[0]) \/ (domain_max[0] - domain_min[0]));\n+                    lut_table[i * 3 + 1] = (cmsFloat32Number) ((nums[1] - domain_min[1]) \/ (domain_max[1] - domain_min[1]));\n+                    lut_table[i * 3 + 0] = (cmsFloat32Number) ((nums[2] - domain_min[2]) \/ (domain_max[2] - domain_min[2]));\n+                }\n+\n+                *CLUT = cmsStageAllocCLutFloat(cube->ContextID, lut_size, 3, 3, lut_table);\n+                _cmsFree(cube->ContextID, lut_table);\n+            }\n+\n+            if (!Check(cube, SEOF, \"Extra symbols found in file\")) return FALSE;\n+        }\n+    }\n+\n+    return TRUE;\n+}\n+\n+\/\/ Share the parser to read .cube format and create RGB devicelink profiles\n+cmsHPROFILE CMSEXPORT cmsCreateDeviceLinkFromCubeFileTHR(cmsContext ContextID, const char* cFileName)\n+{\n+    cmsHPROFILE hProfile = NULL;\n+    cmsIT8* cube = NULL;\n+    cmsPipeline* Pipeline = NULL;\n+    cmsStage* CLUT = NULL;\n+    cmsStage* Shaper = NULL;\n+    cmsMLU* DescriptionMLU = NULL;\n+    char title[MAXSTR];\n+\n+    _cmsAssert(cFileName != NULL);\n+\n+    cube = (cmsIT8*) cmsIT8Alloc(ContextID);\n+    if (!cube) return NULL;\n+\n+    cube->IsCUBE = TRUE;\n+    cube->FileStack[0]->Stream = fopen(cFileName, \"rt\");\n+\n+    if (!cube->FileStack[0]->Stream) goto Done;\n+\n+    strncpy(cube->FileStack[0]->FileName, cFileName, cmsMAX_PATH - 1);\n+    cube->FileStack[0]->FileName[cmsMAX_PATH - 1] = 0;\n+\n+    if (!ParseCube(cube, &Shaper, &CLUT, title)) goto Done;\n+\n+    \/\/ Success on parsing, let's create the profile\n+    hProfile = cmsCreateProfilePlaceholder(ContextID);\n+    if (!hProfile) goto Done;\n+\n+    cmsSetProfileVersion(hProfile, 4.4);\n+\n+    cmsSetDeviceClass(hProfile, cmsSigLinkClass);\n+    cmsSetColorSpace(hProfile,  cmsSigRgbData);\n+    cmsSetPCS(hProfile,         cmsSigRgbData);\n+\n+    cmsSetHeaderRenderingIntent(hProfile, INTENT_PERCEPTUAL);\n+\n+    \/\/ Creates a Pipeline to hold CLUT and shaper\n+    Pipeline = cmsPipelineAlloc(ContextID, 3, 3);\n+    if (Pipeline == NULL) goto Done;\n+\n+    \/\/ Populates the pipeline\n+    if (Shaper != NULL) {\n+        if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, Shaper))\n+            goto Done;\n+    }\n+\n+    if (CLUT != NULL) {\n+        if (!cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT))\n+            goto Done;\n+    }\n+\n+    \/\/ Propagate the description. We put no copyright because we know\n+    \/\/ nothing on the copyrighted state of the .cube\n+    DescriptionMLU = cmsMLUalloc(ContextID, 1);\n+    if (!cmsMLUsetUTF8(DescriptionMLU, cmsNoLanguage, cmsNoCountry, title)) goto Done;\n+\n+    \/\/ Flush the tags\n+    if (!cmsWriteTag(hProfile, cmsSigProfileDescriptionTag, DescriptionMLU)) goto Done;\n+    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, (void*)Pipeline)) goto Done;\n+\n+Done:\n+\n+    if (DescriptionMLU != NULL)\n+        cmsMLUfree(DescriptionMLU);\n+\n+    if (Pipeline != NULL)\n+        cmsPipelineFree(Pipeline);\n+\n+    cmsIT8Free((cmsHANDLE) cube);\n+\n+    return hProfile;\n+}\n+\n+cmsHPROFILE CMSEXPORT cmsCreateDeviceLinkFromCubeFile(const char* cFileName)\n+{\n+    return cmsCreateDeviceLinkFromCubeFileTHR(NULL, cFileName);\n+}\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmscgats.c","additions":389,"deletions":98,"binary":false,"changes":487,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-    void Temp2CHAD(cmsMAT3* Chad, cmsFloat64Number Temp)\n+void Temp2CHAD(cmsMAT3* Chad, cmsFloat64Number Temp)\n@@ -747,0 +747,10 @@\n+\n+\/\/ Check whatever the profile is a CMYK->CMYK devicelink\n+static\n+cmsBool is_cmyk_devicelink(cmsHPROFILE hProfile)\n+{\n+    return cmsGetDeviceClass(hProfile) == cmsSigLinkClass &&\n+            cmsGetColorSpace(hProfile) == cmsSigCmykData &&\n+            cmsGetColorSpace(hProfile) == cmsSigCmykData;\n+}\n+\n@@ -779,1 +789,2 @@\n-    while (lastProfilePos > 1)\n+    \/\/ Skip CMYK->CMYK devicelinks on ending\n+    while (is_cmyk_devicelink(hLastProfile))\n@@ -781,3 +792,1 @@\n-        hLastProfile = hProfiles[--lastProfilePos];\n-        if (cmsGetColorSpace(hLastProfile) != cmsSigCmykData ||\n-            cmsGetDeviceClass(hLastProfile) != cmsSigLinkClass)\n+        if (lastProfilePos < 2)\n@@ -785,0 +794,2 @@\n+\n+        hLastProfile = hProfiles[--lastProfilePos];\n@@ -787,0 +798,1 @@\n+\n@@ -803,1 +815,1 @@\n-                                     preservationProfilesCount,\n+        preservationProfilesCount,\n@@ -815,1 +827,1 @@\n-                                    preservationProfilesCount,\n+        preservationProfilesCount,\n@@ -1005,1 +1017,2 @@\n-    while (lastProfilePos > 1)\n+    \/\/ Skip CMYK->CMYK devicelinks on ending\n+    while (is_cmyk_devicelink(hLastProfile))\n@@ -1007,3 +1020,1 @@\n-        hLastProfile = hProfiles[--lastProfilePos];\n-        if (cmsGetColorSpace(hLastProfile) != cmsSigCmykData ||\n-            cmsGetDeviceClass(hLastProfile) != cmsSigLinkClass)\n+        if (lastProfilePos < 2)\n@@ -1011,0 +1022,2 @@\n+\n+        hLastProfile = hProfiles[--lastProfilePos];\n@@ -1180,2 +1193,1 @@\n-\n-    for (nIntents=0, pt = ctx->Intents; pt != NULL; pt = pt -> Next)\n+    for (nIntents=0, pt = DefaultIntents; pt != NULL; pt = pt -> Next)\n@@ -1194,1 +1206,1 @@\n-    for (nIntents=0, pt = DefaultIntents; pt != NULL; pt = pt -> Next)\n+    for (pt = ctx->Intents; pt != NULL; pt = pt -> Next)\n@@ -1206,0 +1218,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmscnvrt.c","additions":27,"deletions":14,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-\/\/ amount of memoy that can be reclaimed. This is mostly as a safety feature to prevent\n+\/\/ amount of memory that can be reclaimed. This is mostly as a safety feature to prevent\n@@ -124,1 +124,2 @@\n-    if (size > MAX_MEMORY_FOR_ALLOC) return NULL;  \/\/ Never allow over maximum\n+    \/\/ Never allow 0 or over maximum\n+    if (size == 0 || size > MAX_MEMORY_FOR_ALLOC) return NULL;\n@@ -266,1 +267,1 @@\n-    \/\/ context internal data should be malloce'd by using those functions.\n+    \/\/ context internal data should be malloc'ed by using those functions.\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmserr.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -332,0 +332,4 @@\n+    for (i=0; i < nSegments; i++) {\n+        if (p ->Segments && p ->Segments[i].SampledPoints) _cmsFree(ContextID, p ->Segments[i].SampledPoints);\n+        if (p ->SegInterp && p ->SegInterp[i]) _cmsFree(ContextID, p ->SegInterp[i]);\n+    }\n@@ -625,4 +629,10 @@\n-        if (e < 0)\n-            Val = Params[3];\n-        else\n-            Val = pow(e, Params[0]) + Params[3];\n+        \/\/ On gamma 1.0, don't clamp\n+        if (Params[0] == 1.0) {\n+            Val = e + Params[3];\n+        }\n+        else {\n+            if (e < 0)\n+                Val = Params[3];\n+            else\n+                Val = pow(e, Params[0]) + Params[3];\n+        }\n@@ -1523,0 +1533,1 @@\n+\/\/ Retrieve segments on tone curves\n@@ -1524,3 +1535,1 @@\n-\/\/ Retrieve parameters on one-segment tone curves\n-\n-cmsFloat64Number* CMSEXPORT cmsGetToneCurveParams(const cmsToneCurve* t)\n+const cmsCurveSegment* CMSEXPORT cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t)\n@@ -1530,2 +1539,2 @@\n-    if (t->nSegments != 1) return NULL;\n-    return t->Segments[0].Params;\n+    if (n < 0 || n >= (cmsInt32Number) t->nSegments) return NULL;\n+    return t->Segments + n;\n@@ -1533,0 +1542,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsgamma.c","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-    \/\/ Assume in-gamut by default.\n+    \/\/ Assume in-gamut by default. NEVER READ, USED FOR DEBUG PURPOSES.\n@@ -628,1 +628,1 @@\n-\/\/ The algorithm obtains Y from a syntetical gray R=G=B. Then least squares fitting is used to estimate gamma.\n+\/\/ The algorithm obtains Y from a synthetical gray R=G=B. Then least squares fitting is used to estimate gamma.\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsgmt.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -563,0 +563,14 @@\n+    \/\/ Set default CMM (that's me!)\n+    Icc ->CMM = lcmsSignature;\n+\n+    \/\/ Set default creator\n+    \/\/ Created by LittleCMS (that's me!)\n+    Icc ->creator = lcmsSignature;\n+\n+    \/\/ Set default platform\n+#ifdef CMS_IS_WINDOWS_\n+    Icc ->platform = cmsSigMicrosoft;\n+#else\n+    Icc ->platform = cmsSigMacintosh;\n+#endif\n+\n@@ -816,0 +830,1 @@\n+    Icc -> CMM             = _cmsAdjustEndianess32(Header.cmmId);\n@@ -821,0 +836,1 @@\n+    Icc -> platform        = (cmsPlatformSignature)_cmsAdjustEndianess32(Header.platform);\n@@ -925,1 +941,1 @@\n-    Header.cmmId       = _cmsAdjustEndianess32(lcmsSignature);\n+    Header.cmmId       = _cmsAdjustEndianess32(Icc ->CMM);\n@@ -937,5 +953,1 @@\n-#ifdef CMS_IS_WINDOWS_\n-    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(cmsSigMicrosoft);\n-#else\n-    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(cmsSigMacintosh);\n-#endif\n+    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(Icc -> platform);\n@@ -957,2 +969,1 @@\n-    \/\/ Created by LittleCMS (that's me!)\n-    Header.creator      = _cmsAdjustEndianess32(lcmsSignature);\n+    Header.creator      = _cmsAdjustEndianess32(Icc ->creator);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsio0.c","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -610,1 +610,1 @@\n-\/\/ Create an output MPE LUT from agiven profile. Version mismatches are handled here\n+\/\/ Create an output MPE LUT from a given profile. Version mismatches are handled here\n@@ -1059,0 +1059,10 @@\n+\n+cmsUInt32Number  CMSEXPORT cmsGetProfileInfoUTF8(cmsHPROFILE hProfile, cmsInfoType Info,\n+                                                          const char LanguageCode[3], const char CountryCode[3],\n+                                                          char* Buffer, cmsUInt32Number BufferSize)\n+{\n+    const cmsMLU* mlu = GetInfo(hProfile, Info);\n+    if (mlu == NULL) return 0;\n+\n+    return cmsMLUgetUTF8(mlu, LanguageCode, CountryCode, Buffer, BufferSize);\n+}\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsio1.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -507,0 +507,3 @@\n+    \/\/ Again, prevent overflow\n+    if (rv > UINT_MAX \/ 15) return 0;\n+\n@@ -846,1 +849,7 @@\n-    _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe->Data;\n+    _cmsStageCLutData* clut;\n+\n+    if (mpe == NULL) return FALSE;\n+\n+    clut = (_cmsStageCLutData*)mpe->Data;\n+\n+    if (clut == NULL) return FALSE;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmslut.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -232,0 +232,36 @@\n+}\n+\n+\n+\/\/ Convert from UTF8 to wchar, returns len.\n+static\n+cmsUInt32Number decodeUTF8(wchar_t* out, const char* in)\n+{\n+    cmsUInt32Number codepoint = 0;\n+    cmsUInt32Number size = 0;\n+\n+    while (*in)\n+    {\n+        cmsUInt8Number ch = (cmsUInt8Number) *in;\n+\n+        if (ch <= 0x7f)\n+        {\n+            codepoint = ch;\n+        }\n+        else if (ch <= 0xbf)\n+        {\n+            codepoint = (codepoint << 6) | (ch & 0x3f);\n+        }\n+        else if (ch <= 0xdf)\n+        {\n+            codepoint = ch & 0x1f;\n+        }\n+        else if (ch <= 0xef)\n+        {\n+            codepoint = ch & 0x0f;\n+        }\n+        else\n+        {\n+            codepoint = ch & 0x07;\n+        }\n+\n+        in++;\n@@ -233,0 +269,92 @@\n+        if (((*in & 0xc0) != 0x80) && (codepoint <= 0x10ffff))\n+        {\n+            if (sizeof(wchar_t) > 2)\n+            {\n+                if (out) *out++ = (wchar_t) codepoint;\n+                size++;\n+            }\n+            else\n+                if (codepoint > 0xffff)\n+                {\n+                    if (out)\n+                    {\n+                        *out++ = (wchar_t)(0xd800 + (codepoint >> 10));\n+                        *out++ = (wchar_t)(0xdc00 + (codepoint & 0x03ff));\n+                        size += 2;\n+                    }\n+                }\n+                else\n+                    if (codepoint < 0xd800 || codepoint >= 0xe000)\n+                    {\n+                        if (out) *out++ = (wchar_t) codepoint;\n+                        size++;\n+                    }\n+        }\n+    }\n+\n+    return size;\n+}\n+\n+\/\/ Convert from wchar_t to UTF8\n+static\n+cmsUInt32Number encodeUTF8(char* out, const wchar_t* in, cmsUInt32Number max_wchars, cmsUInt32Number max_chars)\n+{\n+    cmsUInt32Number codepoint = 0;\n+    cmsUInt32Number size = 0;\n+    cmsUInt32Number len_w = 0;\n+\n+    while (*in && len_w < max_wchars)\n+    {\n+        if (*in >= 0xd800 && *in <= 0xdbff)\n+            codepoint = ((*in - 0xd800) << 10) + 0x10000;\n+        else\n+        {\n+            if (*in >= 0xdc00 && *in <= 0xdfff)\n+                codepoint |= *in - 0xdc00;\n+            else\n+                codepoint = *in;\n+\n+            if (codepoint <= 0x7f)\n+            {\n+                if (out && (size + 1 < max_chars)) *out++ = (char)codepoint;\n+                size++;\n+            }\n+\n+            else if (codepoint <= 0x7ff)\n+            {\n+                if (out && (max_chars > 0) && (size + 2 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xc0 | ((codepoint >> 6) & 0x1f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 2;\n+            }\n+            else if (codepoint <= 0xffff)\n+            {\n+                if (out && (max_chars > 0) && (size + 3 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xe0 | ((codepoint >> 12) & 0x0f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 6) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 3;\n+            }\n+            else\n+            {\n+                if (out && (max_chars > 0) && (size + 4 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xf0 | ((codepoint >> 18) & 0x07));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 12) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 6) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 4;\n+            }\n+\n+            codepoint = 0;\n+        }\n+\n+        in++; len_w++;\n+    }\n+\n+    return size;\n@@ -239,1 +367,1 @@\n-    cmsUInt32Number i, len = (cmsUInt32Number) strlen(ASCIIString);\n+    cmsUInt32Number i, len = (cmsUInt32Number)strlen(ASCIIString);\n@@ -242,1 +370,1 @@\n-    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Lang = strTo16(LanguageCode);\n@@ -250,1 +378,2 @@\n-        len = 1;\n+        wchar_t empty = 0;\n+        return AddMLUBlock(mlu, sizeof(wchar_t), &empty, Lang, Cntry);\n@@ -253,1 +382,1 @@\n-    WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, len,  sizeof(wchar_t));\n+    WStr = (wchar_t*)_cmsCalloc(mlu->ContextID, len, sizeof(wchar_t));\n@@ -256,2 +385,2 @@\n-    for (i=0; i < len; i++)\n-        WStr[i] = (wchar_t) ASCIIString[i];\n+    for (i = 0; i < len; i++)\n+        WStr[i] = (wchar_t)ASCIIString[i];\n@@ -259,1 +388,1 @@\n-    rc = AddMLUBlock(mlu, len  * sizeof(wchar_t), WStr, Lang, Cntry);\n+    rc = AddMLUBlock(mlu, len * sizeof(wchar_t), WStr, Lang, Cntry);\n@@ -261,1 +390,1 @@\n-    _cmsFree(mlu ->ContextID, WStr);\n+    _cmsFree(mlu->ContextID, WStr);\n@@ -266,0 +395,33 @@\n+\/\/ Add an UTF8 entry. Do not add any \\0 termination (ICC1v43_2010-12.pdf page 61)\n+\/\/ In the case the user explicitly sets an empty string, we force a \\0\n+cmsBool CMSEXPORT cmsMLUsetUTF8(cmsMLU* mlu, const char LanguageCode[3], const char CountryCode[3], const char* UTF8String)\n+{\n+    cmsUInt32Number UTF8len;\n+    wchar_t* WStr;\n+    cmsBool  rc;\n+    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Cntry = strTo16(CountryCode);\n+\n+    if (mlu == NULL) return FALSE;\n+\n+    if (*UTF8String == '\\0')\n+    {\n+        wchar_t empty = 0;\n+        return AddMLUBlock(mlu, sizeof(wchar_t), &empty, Lang, Cntry);\n+    }\n+\n+    \/\/ Len excluding terminator 0\n+    UTF8len = decodeUTF8(NULL, UTF8String);\n+\n+    \/\/ Get space for dest\n+    WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, UTF8len,  sizeof(wchar_t));\n+    if (WStr == NULL) return FALSE;\n+\n+    decodeUTF8(WStr, UTF8String);\n+\n+    rc = AddMLUBlock(mlu, UTF8len  * sizeof(wchar_t), WStr, Lang, Cntry);\n+\n+    _cmsFree(mlu ->ContextID, WStr);\n+    return rc;\n+}\n+\n@@ -404,1 +566,1 @@\n-    return(wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v ->StrW);\n+    return (wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v ->StrW);\n@@ -442,2 +604,4 @@\n-        if (Wide[i] == 0)\n-            Buffer[i] = 0;\n+        wchar_t wc = Wide[i];\n+\n+        if (wc < 0xff)\n+            Buffer[i] = (char)wc;\n@@ -445,1 +609,1 @@\n-            Buffer[i] = (char) Wide[i];\n+            Buffer[i] = '?';\n@@ -453,0 +617,40 @@\n+\n+\/\/ Obtain a UTF8 representation of the wide string. Setting buffer to NULL returns the len\n+cmsUInt32Number CMSEXPORT cmsMLUgetUTF8(const cmsMLU* mlu,\n+                                       const char LanguageCode[3], const char CountryCode[3],\n+                                       char* Buffer, cmsUInt32Number BufferSize)\n+{\n+    const wchar_t *Wide;\n+    cmsUInt32Number  StrLen = 0;\n+    cmsUInt32Number UTF8len;\n+\n+    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Cntry = strTo16(CountryCode);\n+\n+    \/\/ Sanitize\n+    if (mlu == NULL) return 0;\n+\n+    \/\/ Get WideChar\n+    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);\n+    if (Wide == NULL) return 0;\n+\n+    UTF8len = encodeUTF8(NULL, Wide, StrLen \/ sizeof(wchar_t), BufferSize);\n+\n+    \/\/ Maybe we want only to know the len?\n+    if (Buffer == NULL) return UTF8len + 1; \/\/ Note the zero at the end\n+\n+    \/\/ No buffer size means no data\n+    if (BufferSize <= 0) return 0;\n+\n+    \/\/ Some clipping may be required\n+    if (BufferSize < UTF8len + 1)\n+        UTF8len = BufferSize - 1;\n+\n+    \/\/ Process it\n+    encodeUTF8(Buffer, Wide, StrLen \/ sizeof(wchar_t), BufferSize);\n+\n+    \/\/ We put a termination \"\\0\"\n+    Buffer[UTF8len] = 0;\n+    return UTF8len + 1;\n+}\n+\n@@ -473,2 +677,2 @@\n-  \/\/ No buffer size means no data\n-    if (BufferSize <= 0) return 0;\n+    \/\/ Invalid buffer size means no data\n+    if (BufferSize < sizeof(wchar_t)) return 0;\n@@ -478,1 +682,1 @@\n-        StrLen = BufferSize - + sizeof(wchar_t);\n+        StrLen = BufferSize - sizeof(wchar_t);\n@@ -846,4 +1050,11 @@\n-    for (i=0; i < pseq ->n; i++) {\n-        if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);\n-        if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);\n-        if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);\n+    if (pseq == NULL)\n+        return;\n+\n+    if (pseq ->seq != NULL) {\n+        for (i=0; i < pseq ->n; i++) {\n+            if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);\n+            if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);\n+            if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);\n+        }\n+\n+        _cmsFree(pseq ->ContextID, pseq ->seq);\n@@ -852,1 +1063,0 @@\n-    if (pseq ->seq != NULL) _cmsFree(pseq ->ContextID, pseq ->seq);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsnamed.c","additions":230,"deletions":20,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -215,0 +215,1 @@\n+\n@@ -1145,1 +1146,4 @@\n-            Trans[t] ->Table16[i] = _cmsQuickSaturateWord(Out[t] * 65535.0);\n+        {\n+            if (Trans[t]->Table16 != NULL)\n+                Trans[t] ->Table16[i] = _cmsQuickSaturateWord(Out[t] * 65535.0);\n+        }\n@@ -1152,1 +1156,1 @@\n-    \/\/ Check for validity\n+    \/\/ Check for validity. lIsLinear is here for debug purposes\n@@ -1756,0 +1760,2 @@\n+                     if (Matrix1->InputChannels != 3 || Matrix1->OutputChannels != 3) return FALSE;\n+\n@@ -1800,1 +1806,1 @@\n-        \/\/ the cache that with the pixel handling\n+        \/\/ the cache than with the pixel handling\n@@ -1957,1 +1963,1 @@\n-        if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n+            if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsopt.c","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2983,0 +2983,102 @@\n+static\n+cmsUInt8Number* PackBytesFromFloat(_cmsTRANSFORM* info,\n+                                    cmsFloat32Number wOut[],\n+                                    cmsUInt8Number* output,\n+                                    cmsUInt32Number Stride)\n+{\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt8Number* swap1 = (cmsUInt8Number*)output;\n+    cmsFloat64Number v = 0;\n+    cmsUInt8Number vv = 0;\n+    cmsUInt32Number i, start = 0;\n+\n+    if (ExtraFirst)\n+        start = Extra;\n+\n+    for (i = 0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+\n+        v = wOut[index] * 65535.0;\n+\n+        if (Reverse)\n+            v = 65535.0 - v;\n+\n+        vv =  FROM_16_TO_8(_cmsQuickSaturateWord(v));\n+\n+        if (Planar)\n+            ((cmsUInt8Number*)output)[(i + start) * Stride] = vv;\n+        else\n+            ((cmsUInt8Number*)output)[i + start] = vv;\n+    }\n+\n+\n+    if (Extra == 0 && SwapFirst) {\n+\n+        memmove(swap1 + 1, swap1, (nChan - 1) * sizeof(cmsUInt8Number));\n+        *swap1 = vv;\n+    }\n+\n+    if (T_PLANAR(info->OutputFormat))\n+        return output + sizeof(cmsUInt8Number);\n+    else\n+        return output + (nChan + Extra) * sizeof(cmsUInt8Number);\n+}\n+\n+static\n+cmsUInt8Number* PackWordsFromFloat(_cmsTRANSFORM* info,\n+                                    cmsFloat32Number wOut[],\n+                                    cmsUInt8Number* output,\n+                                    cmsUInt32Number Stride)\n+{\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt16Number* swap1 = (cmsUInt16Number*)output;\n+    cmsFloat64Number v = 0;\n+    cmsUInt16Number vv = 0;\n+    cmsUInt32Number i, start = 0;\n+\n+    if (ExtraFirst)\n+        start = Extra;\n+\n+    for (i = 0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+\n+        v = wOut[index] * 65535.0;\n+\n+        if (Reverse)\n+            v = 65535.0 - v;\n+\n+        vv = _cmsQuickSaturateWord(v);\n+\n+        if (Planar)\n+            ((cmsUInt16Number*)output)[(i + start) * Stride] = vv;\n+        else\n+            ((cmsUInt16Number*)output)[i + start] = vv;\n+    }\n+\n+    if (Extra == 0 && SwapFirst) {\n+\n+        memmove(swap1 + 1, swap1, (nChan - 1) * sizeof(cmsUInt16Number));\n+        *swap1 = vv;\n+    }\n+\n+    if (T_PLANAR(info->OutputFormat))\n+        return output + sizeof(cmsUInt16Number);\n+    else\n+        return output + (nChan + Extra) * sizeof(cmsUInt16Number);\n+}\n+\n+\n@@ -3146,0 +3248,71 @@\n+static\n+cmsUInt8Number* PackEncodedBytesLabV2FromFloat(_cmsTRANSFORM* Info,\n+                                           cmsFloat32Number wOut[],\n+                                           cmsUInt8Number* output,\n+                                           cmsUInt32Number Stride)\n+{\n+    cmsCIELab Lab;\n+    cmsUInt16Number wlab[3];\n+\n+    Lab.L = (cmsFloat64Number)(wOut[0] * 100.0);\n+    Lab.a = (cmsFloat64Number)(wOut[1] * 255.0 - 128.0);\n+    Lab.b = (cmsFloat64Number)(wOut[2] * 255.0 - 128.0);\n+\n+    cmsFloat2LabEncoded(wlab, &Lab);\n+\n+    if (T_PLANAR(Info -> OutputFormat)) {\n+\n+        Stride \/= PixelSize(Info->OutputFormat);\n+\n+        output[0]        = wlab[0] >> 8;\n+        output[Stride]   = wlab[1] >> 8;\n+        output[Stride*2] = wlab[2] >> 8;\n+\n+        return output + 1;\n+    }\n+    else {\n+\n+        output[0] = wlab[0] >> 8;\n+        output[1] = wlab[1] >> 8;\n+        output[2] = wlab[2] >> 8;\n+\n+        return output + (3 + T_EXTRA(Info ->OutputFormat));\n+    }\n+}\n+\n+static\n+cmsUInt8Number* PackEncodedWordsLabV2FromFloat(_cmsTRANSFORM* Info,\n+                                           cmsFloat32Number wOut[],\n+                                           cmsUInt8Number* output,\n+                                           cmsUInt32Number Stride)\n+{\n+    cmsCIELab Lab;\n+    cmsUInt16Number wlab[3];\n+\n+    Lab.L = (cmsFloat64Number)(wOut[0] * 100.0);\n+    Lab.a = (cmsFloat64Number)(wOut[1] * 255.0 - 128.0);\n+    Lab.b = (cmsFloat64Number)(wOut[2] * 255.0 - 128.0);\n+\n+    cmsFloat2LabEncodedV2(wlab, &Lab);\n+\n+    if (T_PLANAR(Info -> OutputFormat)) {\n+\n+        Stride \/= PixelSize(Info->OutputFormat);\n+\n+        ((cmsUInt16Number*) output)[0]        = wlab[0];\n+        ((cmsUInt16Number*) output)[Stride]   = wlab[1];\n+        ((cmsUInt16Number*) output)[Stride*2] = wlab[2];\n+\n+        return output + sizeof(cmsUInt16Number);\n+    }\n+    else {\n+\n+         ((cmsUInt16Number*) output)[0] = wlab[0];\n+         ((cmsUInt16Number*) output)[1] = wlab[1];\n+         ((cmsUInt16Number*) output)[2] = wlab[2];\n+\n+        return output + (3 + T_EXTRA(Info ->OutputFormat)) * sizeof(cmsUInt16Number);\n+    }\n+}\n+\n+\n@@ -3679,0 +3852,3 @@\n+    {     TYPE_LabV2_8,                                                ANYPLANAR|ANYEXTRA,   PackEncodedBytesLabV2FromFloat},\n+    {     TYPE_LabV2_16,                                               ANYPLANAR|ANYEXTRA,   PackEncodedWordsLabV2FromFloat},\n+\n@@ -3683,0 +3859,7 @@\n+\n+    {     BYTES_SH(2), ANYPLANAR|\n+                             ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackWordsFromFloat },\n+\n+    {     BYTES_SH(1), ANYPLANAR|\n+                             ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackBytesFromFloat },\n+\n@@ -3893,1 +4076,1 @@\n-    cmsUInt32Number nOutputChans = cmsChannelsOf(ColorSpace);\n+    cmsInt32Number  nOutputChans = cmsChannelsOfColorSpace(ColorSpace);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmspack.c","additions":184,"deletions":1,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -396,6 +396,1 @@\n-       cmsUInt8Number  msb, lsb;\n-\n-       lsb = (cmsUInt8Number) (fixed8 & 0xff);\n-       msb = (cmsUInt8Number) (((cmsUInt16Number) fixed8 >> 8) & 0xff);\n-\n-       return (cmsFloat64Number) ((cmsFloat64Number) msb + ((cmsFloat64Number) lsb \/ 256.0));\n+    return fixed8 \/ 256.0;\n@@ -413,13 +408,1 @@\n-    cmsFloat64Number floater, sign, mid;\n-    int Whole, FracPart;\n-\n-    sign  = (fix32 < 0 ? -1 : 1);\n-    fix32 = abs(fix32);\n-\n-    Whole     = (cmsUInt16Number)(fix32 >> 16) & 0xffff;\n-    FracPart  = (cmsUInt16Number)(fix32 & 0xffff);\n-\n-    mid     = (cmsFloat64Number) FracPart \/ 65536.0;\n-    floater = (cmsFloat64Number) Whole + mid;\n-\n-    return sign * floater;\n+    return fix32 \/ 65536.0;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsplugin.c","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -463,6 +463,0 @@\n-static\n-void EmitSafeGuardBegin(cmsIOHANDLER* m, const char* name)\n-{\n-    _cmsIOPrintf(m, \"%%LCMS2: Save previous definition of %s on the operand stack\\n\", name);\n-    _cmsIOPrintf(m, \"currentdict \/%s known { \/%s load } { null } ifelse\\n\", name, name);\n-}\n@@ -470,10 +464,0 @@\n-static\n-void EmitSafeGuardEnd(cmsIOHANDLER* m, const char* name, int depth)\n-{\n-    _cmsIOPrintf(m, \"%%LCMS2: Restore previous definition of %s\\n\", name);\n-    if (depth > 1) {\n-        \/\/ cycle topmost items on the stack to bring the previous definition to the front\n-        _cmsIOPrintf(m, \"%d -1 roll \", depth);\n-    }\n-    _cmsIOPrintf(m, \"dup null eq { pop currentdict \/%s undef } { \/%s exch def } ifelse\\n\", name, name);\n-}\n@@ -484,1 +468,1 @@\n-void Emit1Gamma(cmsIOHANDLER* m, cmsToneCurve* Table, const char* name)\n+void Emit1Gamma(cmsIOHANDLER* m, cmsToneCurve* Table)\n@@ -489,1 +473,6 @@\n-    if (Table == NULL) return; \/\/ Error\n+    \/**\n+    * On error, empty tables or lienar assume gamma 1.0\n+    *\/\n+    if (Table == NULL ||\n+        Table->nEntries <= 0 ||\n+        cmsIsToneCurveLinear(Table)) {\n@@ -491,1 +480,3 @@\n-    if (Table ->nEntries <= 0) return;  \/\/ Empty table\n+        _cmsIOPrintf(m, \"{ 1 } bind \");\n+        return;\n+    }\n@@ -493,2 +484,0 @@\n-    \/\/ Suppress whole if identity\n-    if (cmsIsToneCurveLinear(Table)) return;\n@@ -499,1 +488,1 @@\n-            _cmsIOPrintf(m, \"\/%s { %g exp } bind def\\n\", name, gamma);\n+            _cmsIOPrintf(m, \"{ %g exp } bind \", gamma);\n@@ -503,2 +492,11 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammatable\");\n-    _cmsIOPrintf(m, \"\/lcms2gammatable [\");\n+    _cmsIOPrintf(m, \"{ \");\n+\n+    \/\/ Bounds check\n+    EmitRangeCheck(m);\n+\n+    \/\/ Emit intepolation code\n+\n+    \/\/ PostScript code                      Stack\n+    \/\/ ===============                      ========================\n+                                            \/\/ v\n+    _cmsIOPrintf(m, \" [\");\n@@ -512,1 +510,1 @@\n-    _cmsIOPrintf(m, \"] def\\n\");\n+    _cmsIOPrintf(m, \"] \");                        \/\/ v tab\n@@ -514,12 +512,0 @@\n-\n-    \/\/ Emit interpolation code\n-\n-    \/\/ PostScript code                            Stack\n-    \/\/ ===============                            ========================\n-                                                  \/\/ v\n-    _cmsIOPrintf(m, \"\/%s {\\n  \", name);\n-\n-    \/\/ Bounds check\n-    EmitRangeCheck(m);\n-\n-    _cmsIOPrintf(m, \"\\n  \/\/lcms2gammatable \");    \/\/ v tab\n@@ -552,3 +538,1 @@\n-    _cmsIOPrintf(m, \"} bind def\\n\");\n-\n-    EmitSafeGuardEnd(m, \"lcms2gammatable\", 1);\n+    _cmsIOPrintf(m, \" } bind \");\n@@ -571,1 +555,1 @@\n-void EmitNGamma(cmsIOHANDLER* m, cmsUInt32Number n, cmsToneCurve* g[], const char* nameprefix)\n+void EmitNGamma(cmsIOHANDLER* m, cmsUInt32Number n, cmsToneCurve* g[])\n@@ -574,1 +558,1 @@\n-    static char buffer[2048];\n+\n@@ -582,1 +566,1 @@\n-            _cmsIOPrintf(m, \"\/%s%d \/%s%d load def\\n\", nameprefix, i, nameprefix, i-1);\n+            _cmsIOPrintf(m, \"dup \");\n@@ -585,3 +569,1 @@\n-            snprintf(buffer, sizeof(buffer), \"%s%d\", nameprefix, (int) i);\n-        buffer[sizeof(buffer)-1] = '\\0';\n-            Emit1Gamma(m, g[i], buffer);\n+            Emit1Gamma(m, g[i]);\n@@ -711,1 +693,1 @@\n-    _cmsIOPrintf(m, \"[\");\n+    if (sc.Pipeline != NULL && sc.Pipeline->Params != NULL) {\n@@ -713,2 +695,1 @@\n-    for (i=0; i < sc.Pipeline->Params->nInputs; i++)\n-        _cmsIOPrintf(m, \" %d \", sc.Pipeline->Params->nSamples[i]);\n+        _cmsIOPrintf(m, \"[\");\n@@ -716,1 +697,2 @@\n-    _cmsIOPrintf(m, \" [\\n\");\n+        for (i = 0; i < sc.Pipeline->Params->nInputs; i++)\n+            _cmsIOPrintf(m, \" %d \", sc.Pipeline->Params->nSamples[i]);\n@@ -718,1 +700,1 @@\n-    cmsStageSampleCLut16bit(mpe, OutputValueSampler, (void*) &sc, SAMPLER_INSPECT);\n+        _cmsIOPrintf(m, \" [\\n\");\n@@ -720,3 +702,6 @@\n-    _cmsIOPrintf(m, PostMin);\n-    _cmsIOPrintf(m, PostMaj);\n-    _cmsIOPrintf(m, \"] \");\n+        cmsStageSampleCLut16bit(mpe, OutputValueSampler, (void*)&sc, SAMPLER_INSPECT);\n+\n+        _cmsIOPrintf(m, PostMin);\n+        _cmsIOPrintf(m, PostMaj);\n+        _cmsIOPrintf(m, \"] \");\n+    }\n@@ -736,2 +721,3 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc\");\n-    Emit1Gamma(m, Curve, \"lcms2gammaproc\");\n+    _cmsIOPrintf(m, \"\/DecodeA \");\n+\n+    Emit1Gamma(m, Curve);\n@@ -739,2 +725,1 @@\n-    _cmsIOPrintf(m, \"\/DecodeA \/lcms2gammaproc load\\n\");\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc\", 3);\n+    _cmsIOPrintf(m, \" \\n\");\n@@ -764,0 +749,3 @@\n+    _cmsIOPrintf(m, \"\/DecodeABC [ \");\n+\n+    EmitNGamma(m, 3, CurveSet);\n@@ -765,8 +753,0 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc0\");\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc1\");\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc2\");\n-    EmitNGamma(m, 3, CurveSet, \"lcms2gammaproc\");\n-    _cmsIOPrintf(m, \"\/DecodeABC [\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc0 load\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc1 load\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc2 load\\n\");\n@@ -774,3 +754,0 @@\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc2\", 3);\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc1\", 3);\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc0\", 3);\n@@ -808,1 +785,1 @@\n-    const char* PreMin, * PostMin;\n+    const char* PreMin, *PostMin;\n@@ -810,2 +787,0 @@\n-    int i, numchans;\n-    static char buffer[2048];\n@@ -840,13 +815,2 @@\n-        numchans = (int) cmsStageOutputChannels(mpe);\n-        for (i = 0; i < numchans; ++i) {\n-            snprintf(buffer, sizeof(buffer), \"lcms2gammaproc%d\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            EmitSafeGuardBegin(m, buffer);\n-        }\n-        EmitNGamma(m, cmsStageOutputChannels(mpe), _cmsStageGetPtrToCurveSet(mpe), \"lcms2gammaproc\");\n-        _cmsIOPrintf(m, \"\/DecodeDEF [\\n\");\n-        for (i = 0; i < numchans; ++i) {\n-            snprintf(buffer, sizeof(buffer), \"  \/lcms2gammaproc%d load\\n\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            _cmsIOPrintf(m, buffer);\n-        }\n+        _cmsIOPrintf(m, \"\/DecodeDEF [ \");\n+        EmitNGamma(m, cmsStageOutputChannels(mpe), _cmsStageGetPtrToCurveSet(mpe));\n@@ -854,5 +818,0 @@\n-        for (i = numchans - 1; i >= 0; --i) {\n-            snprintf(buffer, sizeof(buffer), \"lcms2gammaproc%d\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            EmitSafeGuardEnd(m, buffer, 3);\n-        }\n@@ -860,1 +819,1 @@\n-        mpe = mpe->Next;\n+        mpe = mpe ->Next;\n@@ -865,3 +824,3 @@\n-        _cmsIOPrintf(m, \"\/Table \");\n-        WriteCLUT(m, mpe, PreMaj, PostMaj, PreMin, PostMin, FALSE, (cmsColorSpaceSignature)0);\n-        _cmsIOPrintf(m, \"]\\n\");\n+            _cmsIOPrintf(m, \"\/Table \");\n+            WriteCLUT(m, mpe, PreMaj, PostMaj, PreMin, PostMin, FALSE, (cmsColorSpaceSignature) 0);\n+            _cmsIOPrintf(m, \"]\\n\");\n@@ -1027,3 +986,3 @@\n-            rc = EmitCIEBasedABC(m, (cmsFloat64Number *)&Mat,\n-                _cmsStageGetPtrToCurveSet(Shaper),\n-                &BlackPointAdaptedToD50);\n+            rc = EmitCIEBasedABC(m,  (cmsFloat64Number *) &Mat,\n+                                _cmsStageGetPtrToCurveSet(Shaper),\n+                                 &BlackPointAdaptedToD50);\n@@ -1056,0 +1015,2 @@\n+    cmsCloseProfile(hLab);\n+\n@@ -1059,1 +1020,4 @@\n-    if (NamedColorList == NULL) return 0;\n+    if (NamedColorList == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n@@ -1068,1 +1032,0 @@\n-\n@@ -1083,2 +1046,0 @@\n-\n-\n@@ -1088,1 +1049,0 @@\n-    cmsCloseProfile(hLab);\n@@ -1342,1 +1302,1 @@\n-\n+    cmsStage* first;\n@@ -1369,1 +1329,0 @@\n-\n@@ -1377,2 +1336,4 @@\n-    if (DeviceLink == NULL) return 0;\n-\n+    if (DeviceLink == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n@@ -1380,1 +1341,1 @@\n-    \/\/ We need a CLUT\n+     \/\/ We need a CLUT\n@@ -1407,2 +1368,4 @@\n-\n-    WriteCLUT(m, cmsPipelineGetPtrToFirstStage(DeviceLink), \"<\", \">\\n\", \"\", \"\", lFixWhite, ColorSpace);\n+    first = cmsPipelineGetPtrToFirstStage(DeviceLink);\n+    if (first != NULL) {\n+        WriteCLUT(m, first, \"<\", \">\\n\", \"\", \"\", lFixWhite, ColorSpace);\n+    }\n@@ -1417,1 +1380,0 @@\n-\n@@ -1480,1 +1442,4 @@\n-    if (NamedColorList == NULL) return 0;\n+    if (NamedColorList == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsps2.c","additions":76,"deletions":111,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    \/\/ Force it to be neutral, check for inconsistences\n+    \/\/ Force it to be neutral, check for inconsistencies\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmssamp.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-\/\/ Return handler for a given type or NULL if not found. Shared between normal types and MPE. It first tries the additons\n+\/\/ Return handler for a given type or NULL if not found. Shared between normal types and MPE. It first tries the additions\n@@ -957,0 +957,1 @@\n+    wchar_t* UnicodeString = NULL;\n@@ -976,1 +977,1 @@\n-    mlu = cmsMLUalloc(self ->ContextID, 1);\n+    mlu = cmsMLUalloc(self ->ContextID, 2);\n@@ -1001,1 +1002,11 @@\n-    if (SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n+    if (UnicodeCount == 0 || SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n+\n+    UnicodeString = (wchar_t*)_cmsMallocZero(self->ContextID, (UnicodeCount + 1) * sizeof(wchar_t));\n+    if (UnicodeString == NULL) goto Done;\n+\n+    if (!_cmsReadWCharArray(io, UnicodeCount, UnicodeString)) {\n+        _cmsFree(self->ContextID, (void*)UnicodeString);\n+        goto Done;\n+    }\n+\n+    UnicodeString[UnicodeCount] = 0;\n@@ -1003,2 +1014,3 @@\n-    for (i=0; i < UnicodeCount; i++) {\n-        if (!io ->Read(io, &Dummy, sizeof(cmsUInt16Number), 1)) goto Done;\n+    if (!cmsMLUsetWide(mlu, cmsV2Unicode, cmsV2Unicode, UnicodeString)) {\n+        _cmsFree(self->ContextID, (void*)UnicodeString);\n+        goto Done;\n@@ -1006,0 +1018,4 @@\n+\n+    _cmsFree(self->ContextID, (void*)UnicodeString);\n+    UnicodeString = NULL;\n+\n@@ -1009,1 +1025,1 @@\n-    \/\/ data that stricttly required. We need to skip it as this type may come\n+    \/\/ data that strictly required. We need to skip it as this type may come\n@@ -1029,0 +1045,1 @@\n+    if (UnicodeString)  _cmsFree(self->ContextID, (void*)UnicodeString);\n@@ -1081,1 +1098,1 @@\n-        cmsMLUgetWide(mlu,  cmsNoLanguage, cmsNoCountry,  Wide, len * sizeof(wchar_t));\n+        cmsMLUgetWide(mlu,  cmsV2Unicode,  cmsV2Unicode,  Wide, len * sizeof(wchar_t));\n@@ -1580,2 +1597,0 @@\n-        NumOfWchar = 0;\n-\n@@ -1943,1 +1958,1 @@\n-cmsBool  Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n+cmsBool Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n@@ -1956,0 +1971,6 @@\n+\n+    if (mpe == NULL) {  \/\/ Should never be empty. Corrupted?\n+        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"empty LUT8 is not supported\");\n+        return FALSE;\n+    }\n+\n@@ -2697,2 +2718,2 @@\n-        if ((Curves[i] ->nSegments == 0)||\n-            ((Curves[i]->nSegments == 2) && (Curves[i] ->Segments[1].Type == 0)) )\n+        if ((Curves[i] ->nSegments == 0) ||                                         \/\/ 16 bits tabulated\n+            ((Curves[i]->nSegments == 3) && (Curves[i] ->Segments[1].Type == 0)) )  \/\/ Floating-point tabulated\n@@ -4462,2 +4483,2 @@\n-    if (InputChans == 0) goto Error;\n-    if (OutputChans == 0) goto Error;\n+    if (InputChans == 0 || InputChans >= cmsMAXCHANNELS) goto Error;\n+    if (OutputChans == 0 || OutputChans >= cmsMAXCHANNELS) goto Error;\n@@ -5253,1 +5274,2 @@\n-    e ->Offsets[i] = Before - BaseOffset;\n+    if (e->Offsets != NULL)\n+        e ->Offsets[i] = Before - BaseOffset;\n@@ -5257,1 +5279,2 @@\n-    e ->Sizes[i] = io ->Tell(io) - Before;\n+    if (e->Sizes != NULL)\n+        e ->Sizes[i] = io ->Tell(io) - Before;\n@@ -5502,0 +5525,210 @@\n+\n+\/\/ ********************************************************************************\n+\/\/ Microsoft's MHC2 Type support\n+\/\/ ********************************************************************************\n+\n+static\n+void SetIdentity(cmsFloat64Number XYZ2XYZmatrix[3][4])\n+{\n+    XYZ2XYZmatrix[0][0] = 1.0; XYZ2XYZmatrix[0][1] = 0.0; XYZ2XYZmatrix[0][2] = 0.0; XYZ2XYZmatrix[0][3] = 0.0;\n+    XYZ2XYZmatrix[1][0] = 0.0; XYZ2XYZmatrix[1][1] = 1.0; XYZ2XYZmatrix[1][2] = 0.0; XYZ2XYZmatrix[1][3] = 0.0;\n+    XYZ2XYZmatrix[2][0] = 0.0; XYZ2XYZmatrix[2][1] = 0.0; XYZ2XYZmatrix[2][2] = 1.0; XYZ2XYZmatrix[2][3] = 0.0;\n+}\n+\n+static\n+cmsBool CloseEnough(cmsFloat64Number a, cmsFloat64Number b)\n+{\n+    return fabs(b - a) < (1.0 \/ 65535.0);\n+}\n+\n+cmsBool IsIdentity(cmsFloat64Number XYZ2XYZmatrix[3][4])\n+{\n+    cmsFloat64Number Identity[3][4];\n+    int i, j;\n+\n+    SetIdentity(Identity);\n+\n+    for (i = 0; i < 3; i++)\n+        for (j = 0; j < 4; j++)\n+            if (!CloseEnough(XYZ2XYZmatrix[i][j], Identity[i][j])) return FALSE;\n+\n+    return TRUE;\n+}\n+\n+static\n+void Type_MHC2_Free(struct _cms_typehandler_struct* self, void* Ptr)\n+{\n+    cmsMHC2Type* mhc2 = (cmsMHC2Type*)Ptr;\n+\n+    if (mhc2->RedCurve != NULL) _cmsFree(self->ContextID, mhc2->RedCurve);\n+    if (mhc2->GreenCurve != NULL) _cmsFree(self->ContextID, mhc2->GreenCurve);\n+    if (mhc2->BlueCurve != NULL) _cmsFree(self->ContextID, mhc2->BlueCurve);\n+\n+    _cmsFree(self->ContextID, Ptr);\n+}\n+\n+void* Type_MHC2_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n+{\n+    cmsMHC2Type* mhc2 = _cmsDupMem(self->ContextID, Ptr, sizeof(cmsMHC2Type));\n+\n+    mhc2->RedCurve = _cmsDupMem(self->ContextID,   mhc2->RedCurve, mhc2->CurveEntries*sizeof(cmsFloat64Number));\n+    mhc2->GreenCurve = _cmsDupMem(self->ContextID, mhc2->GreenCurve, mhc2->CurveEntries * sizeof(cmsFloat64Number));\n+    mhc2->BlueCurve = _cmsDupMem(self->ContextID,  mhc2->BlueCurve, mhc2->CurveEntries * sizeof(cmsFloat64Number));\n+\n+    if (mhc2->RedCurve == NULL ||\n+        mhc2->GreenCurve == NULL ||\n+        mhc2->BlueCurve == NULL) {\n+\n+        Type_MHC2_Free(self, mhc2);\n+        return NULL;\n+    }\n+\n+    return mhc2;\n+\n+    cmsUNUSED_PARAMETER(n);\n+}\n+\n+\n+static\n+cmsBool WriteDoubles(cmsIOHANDLER* io, cmsUInt32Number n, cmsFloat64Number* Values)\n+{\n+    cmsUInt32Number i;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (!_cmsWrite15Fixed16Number(io, *Values++)) return FALSE;\n+    }\n+\n+    return TRUE;\n+}\n+\n+static\n+cmsBool Type_MHC2_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n+{\n+    cmsMHC2Type* mhc2 = (cmsMHC2Type*)Ptr;\n+    cmsUInt32Number BaseOffset = io->Tell(io) - sizeof(_cmsTagBase);\n+    cmsUInt32Number TablesOffsetPos;\n+    cmsUInt32Number MatrixOffset;\n+    cmsUInt32Number OffsetRedTable, OffsetGreenTable, OffsetBlueTable;\n+\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, mhc2->CurveEntries)) return FALSE;\n+\n+    if (!_cmsWrite15Fixed16Number(io, mhc2->MinLuminance)) return FALSE;\n+    if (!_cmsWrite15Fixed16Number(io, mhc2->PeakLuminance)) return FALSE;\n+\n+    TablesOffsetPos = io->Tell(io);\n+\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Matrix\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve R\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve G\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve B\n+\n+\n+    if (IsIdentity(mhc2->XYZ2XYZmatrix))\n+    {\n+        MatrixOffset = 0;\n+    }\n+    else\n+    {\n+        MatrixOffset = io->Tell(io) - BaseOffset;\n+        if (!WriteDoubles(io, 3 * 4, &mhc2->XYZ2XYZmatrix[0][0])) return FALSE;\n+    }\n+\n+    OffsetRedTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->RedCurve)) return FALSE;\n+    OffsetGreenTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->GreenCurve)) return FALSE;\n+    OffsetBlueTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->BlueCurve)) return FALSE;\n+\n+    if (!io->Seek(io, TablesOffsetPos)) return FALSE;\n+\n+    if (!_cmsWriteUInt32Number(io, MatrixOffset)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetRedTable)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetGreenTable)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetBlueTable)) return FALSE;\n+\n+    return TRUE;\n+\n+    cmsUNUSED_PARAMETER(self);\n+    cmsUNUSED_PARAMETER(nItems);\n+}\n+\n+\n+static\n+cmsBool ReadDoublesAt(cmsIOHANDLER* io, cmsUInt32Number At, cmsUInt32Number n, cmsFloat64Number* Values)\n+{\n+    cmsUInt32Number CurrentPos = io->Tell(io);\n+    cmsUInt32Number i;\n+\n+    if (!io->Seek(io, At)) return FALSE;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (!_cmsRead15Fixed16Number(io, Values++)) return FALSE;\n+    }\n+\n+    if (!io->Seek(io, CurrentPos)) return FALSE;\n+\n+    return TRUE;\n+}\n+\n+static\n+void* Type_MHC2_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n+{\n+    cmsMHC2Type* mhc2 = NULL;\n+\n+    cmsUInt32Number BaseOffset = io->Tell(io) - sizeof(_cmsTagBase);\n+    cmsUInt32Number MatrixOffset;\n+    cmsUInt32Number OffsetRedTable, OffsetGreenTable, OffsetBlueTable;\n+\n+    if (!_cmsReadUInt32Number(io, NULL)) return NULL;\n+\n+    mhc2 = (cmsMHC2Type*)_cmsCalloc(self->ContextID, 1, sizeof(cmsMHC2Type));\n+    if (mhc2 == NULL) return NULL;\n+\n+    if (!_cmsReadUInt32Number(io,    &mhc2->CurveEntries)) goto Error;\n+\n+    if (mhc2->CurveEntries > 4096) goto Error;\n+\n+    mhc2->RedCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+    mhc2->GreenCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+    mhc2->BlueCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+\n+    if (mhc2->RedCurve == NULL ||\n+        mhc2->GreenCurve == NULL ||\n+        mhc2->BlueCurve == NULL)  goto Error;\n+\n+    if (!_cmsRead15Fixed16Number(io, &mhc2->MinLuminance)) goto Error;\n+    if (!_cmsRead15Fixed16Number(io, &mhc2->PeakLuminance)) goto Error;\n+\n+    if (!_cmsReadUInt32Number(io, &MatrixOffset)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetRedTable)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetGreenTable)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetBlueTable)) goto Error;\n+\n+    if (MatrixOffset == 0)\n+        SetIdentity(mhc2->XYZ2XYZmatrix);\n+    else\n+    {\n+        if (!ReadDoublesAt(io, BaseOffset + MatrixOffset, 3*4, &mhc2->XYZ2XYZmatrix[0][0])) goto Error;\n+    }\n+\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetRedTable, mhc2->CurveEntries, mhc2->RedCurve)) goto Error;\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetGreenTable, mhc2->CurveEntries, mhc2->GreenCurve)) goto Error;\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetBlueTable, mhc2->CurveEntries, mhc2->BlueCurve)) goto Error;\n+\n+    \/\/ Success\n+    *nItems = 1;\n+    return mhc2;\n+\n+Error:\n+    Type_MHC2_Free(self, mhc2);\n+    return NULL;\n+\n+    cmsUNUSED_PARAMETER(SizeOfTag);\n+}\n+\n+\n+\n@@ -5541,1 +5774,2 @@\n-{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),                NULL }\n+{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),               (_cmsTagTypeLinkedList*) &SupportedTagTypes[32] },\n+{TYPE_HANDLER(cmsSigMHC2Type,                  MHC2),                NULL }\n@@ -5737,1 +5971,2 @@\n-    { cmsSigArgyllArtsTag,          { 9, 1, { cmsSigS15Fixed16ArrayType},    NULL}, NULL}\n+    { cmsSigArgyllArtsTag,          { 9, 1, { cmsSigS15Fixed16ArrayType},    NULL}, &SupportedTags[65]},\n+    { cmsSigMHC2Tag,                { 1, 1, { cmsSigMHC2Type },              NULL}, NULL}\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmstypes.c","additions":253,"deletions":18,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -438,2 +438,2 @@\n-        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 0..400\");\n-        if (Limit < 0) Limit = 0;\n+        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 1..400\");\n+        if (Limit < 1) Limit = 1;\n@@ -441,1 +441,0 @@\n-\n@@ -704,0 +703,121 @@\n+\/**\n+* Oklab colorspace profile (experimental)\n+*\n+* This virtual profile cannot be saved as an ICC file\n+*\/\n+cmsHPROFILE cmsCreate_OkLabProfile(cmsContext ctx)\n+{\n+    cmsStage* XYZPCS = _cmsStageNormalizeFromXyzFloat(ctx);\n+    cmsStage* PCSXYZ = _cmsStageNormalizeToXyzFloat(ctx);\n+\n+    const double M_D65_D50[] =\n+    {\n+       1.047886, 0.022919, -0.050216,\n+       0.029582, 0.990484, -0.017079,\n+      -0.009252, 0.015073,  0.751678\n+    };\n+\n+    const double M_D50_D65[] =\n+    {\n+         0.955512609517083, -0.023073214184645,  0.063308961782107,\n+        -0.028324949364887,  1.009942432477107,  0.021054814890112,\n+         0.012328875695483, -0.020535835374141,  1.330713916450354\n+    };\n+\n+    cmsStage* D65toD50 = cmsStageAllocMatrix(ctx, 3, 3, M_D65_D50, NULL);\n+    cmsStage* D50toD65 = cmsStageAllocMatrix(ctx, 3, 3, M_D50_D65, NULL);\n+\n+    const double M_D65_LMS[] =\n+    {\n+        0.8189330101, 0.3618667424, -0.1288597137,\n+        0.0329845436, 0.9293118715,  0.0361456387,\n+        0.0482003018, 0.2643662691,  0.6338517070\n+    };\n+\n+    const double M_LMS_D65[] =\n+    {\n+        1.227013851103521, -0.557799980651822,  0.281256148966468,\n+       -0.040580178423281,  1.112256869616830, -0.071676678665601,\n+       -0.076381284505707, -0.421481978418013,  1.586163220440795\n+    };\n+\n+    cmsStage* D65toLMS = cmsStageAllocMatrix(ctx, 3, 3, M_D65_LMS, NULL);\n+    cmsStage* LMStoD65 = cmsStageAllocMatrix(ctx, 3, 3, M_LMS_D65, NULL);\n+\n+    cmsToneCurve* CubeRoot = cmsBuildGamma(ctx, 1.0 \/ 3.0);\n+    cmsToneCurve* Cube     = cmsBuildGamma(ctx,  3.0);\n+\n+    cmsToneCurve* Roots[3] = { CubeRoot, CubeRoot, CubeRoot };\n+    cmsToneCurve* Cubes[3] = { Cube, Cube, Cube };\n+\n+    cmsStage* NonLinearityFw = cmsStageAllocToneCurves(ctx, 3, Roots);\n+    cmsStage* NonLinearityRv = cmsStageAllocToneCurves(ctx, 3, Cubes);\n+\n+    const double M_LMSprime_OkLab[] =\n+    {\n+        0.2104542553,  0.7936177850, -0.0040720468,\n+        1.9779984951, -2.4285922050,  0.4505937099,\n+        0.0259040371,  0.7827717662, -0.8086757660\n+    };\n+\n+    const double M_OkLab_LMSprime[] =\n+    {\n+        0.999999998450520,  0.396337792173768,  0.215803758060759,\n+        1.000000008881761, -0.105561342323656, -0.063854174771706,\n+        1.000000054672411, -0.089484182094966, -1.291485537864092\n+    };\n+\n+    cmsStage* LMSprime_OkLab = cmsStageAllocMatrix(ctx, 3, 3, M_LMSprime_OkLab, NULL);\n+    cmsStage* OkLab_LMSprime = cmsStageAllocMatrix(ctx, 3, 3, M_OkLab_LMSprime, NULL);\n+\n+    cmsPipeline* AToB = cmsPipelineAlloc(ctx, 3, 3);\n+    cmsPipeline* BToA = cmsPipelineAlloc(ctx, 3, 3);\n+\n+    cmsHPROFILE hProfile = cmsCreateProfilePlaceholder(ctx);\n+\n+    cmsSetProfileVersion(hProfile, 4.4);\n+\n+    cmsSetDeviceClass(hProfile, cmsSigColorSpaceClass);\n+    cmsSetColorSpace(hProfile, cmsSig3colorData);\n+    cmsSetPCS(hProfile, cmsSigXYZData);\n+\n+    cmsSetHeaderRenderingIntent(hProfile, INTENT_RELATIVE_COLORIMETRIC);\n+\n+    \/**\n+    * Conversion PCS (XYZ\/D50) to OkLab\n+    *\/\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, PCSXYZ)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, D50toD65)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, D65toLMS)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, NonLinearityFw)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, LMSprime_OkLab)) goto error;\n+\n+    if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, BToA)) goto error;\n+\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, OkLab_LMSprime)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, NonLinearityRv)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, LMStoD65)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, D65toD50)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, XYZPCS)) goto error;\n+\n+    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, AToB)) goto error;\n+\n+    cmsPipelineFree(BToA);\n+    cmsPipelineFree(AToB);\n+\n+    cmsFreeToneCurve(CubeRoot);\n+    cmsFreeToneCurve(Cube);\n+\n+    return hProfile;\n+\n+error:\n+    cmsPipelineFree(BToA);\n+    cmsPipelineFree(AToB);\n+\n+    cmsFreeToneCurve(CubeRoot);\n+    cmsFreeToneCurve(Cube);\n+    cmsCloseProfile(hProfile);\n+\n+    return NULL;\n+\n+}\n@@ -1063,1 +1183,1 @@\n-        if (n > Tab ->nTypes) return FALSE;\n+        if (n >= Tab ->nTypes) return FALSE;\n@@ -1094,3 +1214,3 @@\n-        cmsUInt32Number FrmIn, FrmOut;\n-        cmsInt32Number ChansIn, ChansOut;\n-        int ColorSpaceBitsIn, ColorSpaceBitsOut;\n+    cmsUInt32Number FrmIn, FrmOut;\n+    cmsInt32Number ChansIn, ChansOut;\n+    int ColorSpaceBitsIn, ColorSpaceBitsOut;\n@@ -1107,0 +1227,3 @@\n+    \/\/ Check if the pipeline holding is valid\n+    if (xform -> Lut == NULL) return NULL;\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsvirt.c","additions":130,"deletions":7,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-    if (_cmsFormatterIsFloat(*OutputFormat)) {\n+    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) {\n@@ -1021,0 +1021,13 @@\n+    \/**\n+    * Check consistency for alpha channel copy\n+    *\/\n+    if (*dwFlags & cmsFLAGS_COPY_ALPHA)\n+    {\n+        if (T_EXTRA(*InputFormat) != T_EXTRA(*OutputFormat))\n+        {\n+            cmsSignalError(ContextID, cmsERROR_NOT_SUITABLE, \"Mismatched alpha channels\");\n+            cmsDeleteTransform(p);\n+            return NULL;\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsxform.c","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-\/\/ Version 2.15\n+\/\/ Version 2.16\n@@ -108,0 +108,3 @@\n+#       if __cplusplus >= 201703L\n+#            define CMS_NO_REGISTER_KEYWORD 1\n+#       endif\n@@ -113,1 +116,1 @@\n-#define LCMS_VERSION        2150\n+#define LCMS_VERSION        2160\n@@ -357,1 +360,2 @@\n-    cmsSigXYZType                           = 0x58595A20   \/\/ 'XYZ '\n+    cmsSigXYZType                           = 0x58595A20,  \/\/ 'XYZ '\n+    cmsSigMHC2Type                          = 0x4D484332   \/\/ 'MHC2'\n@@ -435,1 +439,2 @@\n-    cmsSigArgyllArtsTag                     = 0x61727473   \/\/ 'arts'\n+    cmsSigArgyllArtsTag                     = 0x61727473,  \/\/ 'arts'\n+    cmsSigMHC2Tag                           = 0x4D484332   \/\/ 'MHC2'\n@@ -980,0 +985,1 @@\n+#define TYPE_OKLAB_DBL        (FLOAT_SH(1)|COLORSPACE_SH(PT_MCH3)|CHANNELS_SH(3)|BYTES_SH(0))\n@@ -1080,0 +1086,13 @@\n+typedef struct {\n+    cmsUInt32Number   CurveEntries;\n+    cmsFloat64Number* RedCurve;\n+    cmsFloat64Number* GreenCurve;\n+    cmsFloat64Number* BlueCurve;\n+\n+    cmsFloat64Number  MinLuminance;         \/\/ ST.2086 min luminance in nits\n+    cmsFloat64Number  PeakLuminance;        \/\/ ST.2086 peak luminance in nits\n+\n+    cmsFloat64Number XYZ2XYZmatrix[3][4];\n+\n+} cmsMHC2Type;\n+\n@@ -1252,1 +1271,2 @@\n-CMSAPI cmsFloat64Number* CMSEXPORT cmsGetToneCurveParams(const cmsToneCurve* t);\n+\n+CMSAPI const cmsCurveSegment* CMSEXPORT cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t);\n@@ -1346,2 +1366,5 @@\n-#define  cmsNoLanguage \"\\0\\0\"\n-#define  cmsNoCountry  \"\\0\\0\"\n+#define  cmsNoLanguage    \"\\0\\0\"\n+#define  cmsNoCountry     \"\\0\\0\"\n+\n+\/\/ Special language\/country to retrieve unicode field for description in V2 profiles. Use with care.\n+#define  cmsV2Unicode     \"\\xff\\xff\"\n@@ -1359,0 +1382,3 @@\n+CMSAPI cmsBool           CMSEXPORT cmsMLUsetUTF8(cmsMLU* mlu,\n+                                                  const char LanguageCode[3], const char CountryCode[3],\n+                                                  const char* UTF8String);\n@@ -1367,0 +1393,4 @@\n+CMSAPI cmsUInt32Number   CMSEXPORT cmsMLUgetUTF8(const cmsMLU* mlu,\n+                                                 const char LanguageCode[3], const char CountryCode[3],\n+                                                 char* Buffer, cmsUInt32Number BufferSize);\n+\n@@ -1591,0 +1621,4 @@\n+CMSAPI cmsUInt32Number  CMSEXPORT cmsGetProfileInfoUTF8(cmsHPROFILE hProfile, cmsInfoType Info,\n+                                                            const char LanguageCode[3], const char CountryCode[3],\n+                                                            char* Buffer, cmsUInt32Number BufferSize);\n+\n@@ -1653,0 +1687,3 @@\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateDeviceLinkFromCubeFile(const char* cFileName);\n+\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateDeviceLinkFromCubeFileTHR(cmsContext ContextID, const char* cFileName);\n@@ -1665,0 +1702,2 @@\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreate_OkLabProfile(cmsContext ctx);\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/lcms2.h","additions":46,"deletions":7,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -291,0 +291,1 @@\n+#          pragma warning(disable : 4127)\n@@ -548,1 +549,1 @@\n-    void* chunks[MemoryClientMax];    \/\/ array of pointers to client chunks. Memory itself is hold in the suballocator.\n+    void* chunks[MemoryClientMax];    \/\/ array of pointers to client chunks. Memory itself is held in the suballocator.\n@@ -842,0 +843,3 @@\n+    \/\/ Color management module identification\n+    cmsUInt32Number          CMM;\n+\n@@ -849,0 +853,1 @@\n+    cmsPlatformSignature     platform;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/lcms2_internal.h","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1347,1 +1347,1 @@\n-                      \"ctrl shift DOWN\", \"selectNextRowExtendSelection\",\n+                      \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n@@ -1355,1 +1355,1 @@\n-                        \"ctrl shift UP\", \"selectPreviousRowExtendSelection\",\n+                        \"ctrl shift UP\", \"selectFirstRowExtendSelection\",\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsLookAndFeel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -173,11 +173,0 @@\n-\n-\/*\n-    HWND hList = GetListHandle();\n-    if (hList != NULL) {\n-        long flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOCOPYBITS;\n-        \/*\n-         * Fix for bug 4046446.\n-         * \/\n-        SetWindowPos(hList, 0, 0, 0, w, h, flags);\n-    }\n-*\/\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_List.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,2 +129,1 @@\n-    jboolean hasException;\n-    JNU_CallStaticMethodByName(env, &hasException,\n+    JNU_CallStaticMethodByName(env, NULL,\n@@ -133,5 +132,0 @@\n-    if (hasException) {\n-        J2dTraceLn(J2D_TRACE_INFO, \"Exception occurred in DWMIsCompositionEnabled\");\n-        env->ExceptionDescribe();\n-        env->ExceptionClear();\n-    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsEnv.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,3 +47,2 @@\n-     * References the property that specifies the directory where\n-     * the native libraries will be stored before the MLet Service\n-     * loads them into memory.\n+     * References the property that optionally specifies the class name\n+     * of an alternative MBeanServerBuilder.\n@@ -51,1 +50,1 @@\n-     * Property Name: <B>jmx.mlet.library.dir<\/B>\n+     * Property Name: <B>javax.management.builder.initial<\/B>\n@@ -56,9 +55,0 @@\n-    \/**\n-     * References the property that specifies the directory where\n-     * the native libraries will be stored before the MLet Service\n-     * loads them into memory.\n-     * <p>\n-     * Property Name: <B>jmx.mlet.library.dir<\/B>\n-     *\/\n-    public static final String MLET_LIB_DIR = \"jmx.mlet.library.dir\";\n-\n@@ -125,12 +115,0 @@\n-    \/**\n-     * Logger name for MLet service information.\n-     *\/\n-    public static final String MLET_LOGGER_NAME =\n-            \"javax.management.mlet\";\n-\n-    \/**\n-     * Logger for MLet service information.\n-     *\/\n-    public static final Logger MLET_LOGGER =\n-            System.getLogger(MLET_LOGGER_NAME);\n-\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/defaults\/JmxProperties.java","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,8 +47,0 @@\n-    \/**\n-     * The default key properties for registering the class loader of the\n-     * MLet service.\n-     * <BR>\n-     * The value is <CODE>type=MLet<\/CODE>.\n-     *\/\n-    public static final String MLET = \"type=MLet\";\n-\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/defaults\/ServiceName.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,12 +209,0 @@\n-                \/* We used to have a special case for \"instanceof\n-                   MLet\" here, where we invoked the method\n-                   loadClass(className, null) to prevent infinite\n-                   recursion.  But the rule whereby the MLet only\n-                   consults loaders that precede it in the CLR (via\n-                   loadClassBefore) means that the recursion can't\n-                   happen, and the test here caused some legitimate\n-                   classloading to fail.  For example, if you have\n-                   dependencies C->D->E with loaders {E D C} in the\n-                   CLR in that order, you would expect to be able to\n-                   load C.  The problem is that while resolving D, CLR\n-                   delegation is disabled, so it can't find E.  *\/\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/ClassLoaderRepositorySupport.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,2 +78,1 @@\n- * to create an MBean that is a ClassLoader, which includes MLets, or to\n- * execute the method addURL on an MBean that is an MLet. This prevents\n+ * to create an MBean that is a ClassLoader.  This prevents\n@@ -83,1 +82,1 @@\n- * users who do want the ability to use MLets are presumably advanced enough\n+ * users who do want an MBean which is a ClassLoader are presumably advanced enough\n@@ -471,1 +470,0 @@\n-        checkMLetMethods(name, operationName);\n@@ -623,43 +621,0 @@\n-    private void checkMLetMethods(ObjectName name, String operation)\n-    throws InstanceNotFoundException {\n-        \/\/ Check if security manager installed\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            return;\n-        }\n-        \/\/ Check for addURL and getMBeansFromURL methods\n-        if (!operation.equals(\"addURL\") &&\n-                !operation.equals(\"getMBeansFromURL\")) {\n-            return;\n-        }\n-        \/\/ Check if MBean is instance of MLet\n-        if (!getMBeanServer().isInstanceOf(name,\n-                \"javax.management.loading.MLet\")) {\n-            return;\n-        }\n-        \/\/ Throw security exception\n-        if (operation.equals(\"addURL\")) { \/\/ addURL\n-            throw new SecurityException(\"Access denied! MLet method addURL \" +\n-                    \"cannot be invoked unless a security manager is installed.\");\n-        } else { \/\/ getMBeansFromURL\n-            \/\/ Whether or not calling getMBeansFromURL is allowed is controlled\n-            \/\/ by the value of the \"jmx.remote.x.mlet.allow.getMBeansFromURL\"\n-            \/\/ system property. If the value of this property is true, calling\n-            \/\/ the MLet's getMBeansFromURL method is allowed. The default value\n-            \/\/ for this property is false.\n-            final String propName = \"jmx.remote.x.mlet.allow.getMBeansFromURL\";\n-            GetPropertyAction propAction = new GetPropertyAction(propName);\n-            @SuppressWarnings(\"removal\")\n-            String propValue = AccessController.doPrivileged(propAction);\n-            boolean allowGetMBeansFromURL = \"true\".equalsIgnoreCase(propValue);\n-            if (!allowGetMBeansFromURL) {\n-                throw new SecurityException(\"Access denied! MLet method \" +\n-                        \"getMBeansFromURL cannot be invoked unless a \" +\n-                        \"security manager is installed or the system property \" +\n-                        \"-Djmx.remote.x.mlet.allow.getMBeansFromURL=true \" +\n-                        \"is specified.\");\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/MBeanServerAccessController.java","additions":3,"deletions":48,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,1294 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javax.management.loading;\n-\n-import com.sun.jmx.defaults.ServiceName;\n-\n-import com.sun.jmx.remote.util.EnvHelp;\n-\n-import java.io.Externalizable;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.ObjectInput;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutput;\n-import java.lang.reflect.Constructor;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLStreamHandlerFactory;\n-import java.nio.file.Files;\n-import java.nio.file.StandardCopyOption;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.lang.System.Logger.Level;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-\n-import javax.management.InstanceAlreadyExistsException;\n-import javax.management.InstanceNotFoundException;\n-import javax.management.MBeanException;\n-import javax.management.MBeanRegistration;\n-import javax.management.MBeanRegistrationException;\n-import javax.management.MBeanServer;\n-import javax.management.NotCompliantMBeanException;\n-import javax.management.ObjectInstance;\n-import javax.management.ObjectName;\n-import javax.management.ReflectionException;\n-\n-import static com.sun.jmx.defaults.JmxProperties.MLET_LIB_DIR;\n-import static com.sun.jmx.defaults.JmxProperties.MLET_LOGGER;\n-import javax.management.ServiceNotFoundException;\n-\n-\/**\n- * Allows you to instantiate and register one or several MBeans in the MBean server\n- * coming from a remote URL. M-let is a shortcut for management applet. The m-let service does this\n- * by loading an m-let text file, which specifies information on the MBeans to be obtained.\n- * The information on each MBean is specified in a single instance of a tag, called the MLET tag.\n- * The location of the m-let text file is specified by a URL.\n- * <p>\n- * The <CODE>MLET<\/CODE> tag has the following syntax:\n- * <p>\n- * &lt;<CODE>MLET<\/CODE><BR>\n- *      <CODE>CODE = <\/CODE><VAR>class<\/VAR><CODE> | OBJECT = <\/CODE><VAR>serfile<\/VAR><BR>\n- *      <CODE>ARCHIVE = &quot;<\/CODE><VAR>archiveList<\/VAR><CODE>&quot;<\/CODE><BR>\n- *      <CODE>[CODEBASE = <\/CODE><VAR>codebaseURL<\/VAR><CODE>]<\/CODE><BR>\n- *      <CODE>[NAME = <\/CODE><VAR>mbeanname<\/VAR><CODE>]<\/CODE><BR>\n- *      <CODE>[VERSION = <\/CODE><VAR>version<\/VAR><CODE>]<\/CODE><BR>\n- * &gt;<BR>\n- *      <CODE>[<\/CODE><VAR>arglist<\/VAR><CODE>]<\/CODE><BR>\n- * &lt;<CODE>\/MLET<\/CODE>&gt;\n- * <p>\n- * where:\n- * <DL>\n- * <DT><CODE>CODE = <\/CODE><VAR>class<\/VAR><\/DT>\n- * <DD>\n- * This attribute specifies the full Java class name, including package name, of the MBean to be obtained.\n- * The compiled <CODE>.class<\/CODE> file of the MBean must be contained in one of the <CODE>.jar<\/CODE> files specified by the <CODE>ARCHIVE<\/CODE>\n- * attribute. Either <CODE>CODE<\/CODE> or <CODE>OBJECT<\/CODE> must be present.\n- * <\/DD>\n- * <DT><CODE>OBJECT = <\/CODE><VAR>serfile<\/VAR><\/DT>\n- * <DD>\n- * This attribute specifies the <CODE>.ser<\/CODE> file that contains a serialized representation of the MBean to be obtained.\n- * This file must be contained in one of the <CODE>.jar<\/CODE> files specified by the <CODE>ARCHIVE<\/CODE> attribute. If the <CODE>.jar<\/CODE> file contains a directory hierarchy, specify the path of the file within this hierarchy. Otherwise  a match will not be found. Either <CODE>CODE<\/CODE> or <CODE>OBJECT<\/CODE> must be present.\n- * <\/DD>\n- * <DT><CODE>ARCHIVE = &quot;<\/CODE><VAR>archiveList<\/VAR><CODE>&quot;<\/CODE><\/DT>\n- * <DD>\n- * This mandatory attribute specifies one or more <CODE>.jar<\/CODE> files\n- * containing MBeans or other resources used by\n- * the MBean to be obtained. One of the <CODE>.jar<\/CODE> files must contain the file specified by the <CODE>CODE<\/CODE> or <CODE>OBJECT<\/CODE> attribute.\n- * If archivelist contains more than one file:\n- * <UL>\n- * <LI>Each file must be separated from the one that follows it by a comma (,).\n- * <LI><VAR>archivelist<\/VAR> must be enclosed in double quote marks.\n- * <\/UL>\n- * All <CODE>.jar<\/CODE> files in <VAR>archivelist<\/VAR> must be stored in the directory specified by the code base URL.\n- * <\/DD>\n- * <DT><CODE>CODEBASE = <\/CODE><VAR>codebaseURL<\/VAR><\/DT>\n- * <DD>\n- * This optional attribute specifies the code base URL of the MBean to be obtained. It identifies the directory that contains\n- * the <CODE>.jar<\/CODE> files specified by the <CODE>ARCHIVE<\/CODE> attribute. Specify this attribute only if the <CODE>.jar<\/CODE> files are not in the same\n- * directory as the m-let text file. If this attribute is not specified, the base URL of the m-let text file is used.\n- * <\/DD>\n- * <DT><CODE>NAME = <\/CODE><VAR>mbeanname<\/VAR><\/DT>\n- * <DD>\n- * This optional attribute specifies the object name to be assigned to the\n- * MBean instance when the m-let service registers it. If\n- * <VAR>mbeanname<\/VAR> starts with the colon character (:), the domain\n- * part of the object name is the default domain of the MBean server,\n- * as returned by {@link javax.management.MBeanServer#getDefaultDomain()}.\n- * <\/DD>\n- * <DT><CODE>VERSION = <\/CODE><VAR>version<\/VAR><\/DT>\n- * <DD>\n- * This optional attribute specifies the version number of the MBean and\n- * associated <CODE>.jar<\/CODE> files to be obtained. This version number can\n- * be used to specify that the <CODE>.jar<\/CODE> files are loaded from the\n- * server to update those stored locally in the cache the next time the m-let\n- * text file is loaded. <VAR>version<\/VAR> must be a series of non-negative\n- * decimal integers each separated by a period from the one that precedes it.\n- * <\/DD>\n- * <DT><VAR>arglist<\/VAR><\/DT>\n- * <DD>\n- * This optional attribute specifies a list of one or more parameters for the\n- * MBean to be instantiated. This list describes the parameters to be passed the MBean's constructor.\n- * Use the following syntax to specify each item in\n- * <VAR>arglist<\/VAR>:\n- * <DL>\n- * <DT>&lt;<CODE>ARG TYPE=<\/CODE><VAR>argumentType<\/VAR> <CODE>VALUE=<\/CODE><VAR>value<\/VAR>&gt;<\/DT>\n- * <DD>where:\n- * <UL>\n- * <LI><VAR>argumentType<\/VAR> is the type of the argument that will be passed as parameter to the MBean's constructor.<\/UL>\n- * <\/DD>\n- * <\/DL>\n- * <P>The arguments' type in the argument list should be a Java primitive type or a Java basic type\n- * (<CODE>java.lang.Boolean, java.lang.Byte, java.lang.Short, java.lang.Long, java.lang.Integer, java.lang.Float, java.lang.Double, java.lang.String<\/CODE>).\n- * <\/DD>\n- * <\/DL>\n- *\n- * When an m-let text file is loaded, an\n- * instance of each MBean specified in the file is created and registered.\n- * <P>\n- * The m-let service extends the <CODE>java.net.URLClassLoader<\/CODE> and can be used to load remote classes\n- * and jar files in the VM of the agent.\n- * <p><STRONG>Note - <\/STRONG> The <CODE>MLet<\/CODE> class loader uses the {@link javax.management.MBeanServerFactory#getClassLoaderRepository(javax.management.MBeanServer)}\n- * to load classes that could not be found in the loaded jar files.\n- *\n- * @deprecated This API is part of Management Applets (m-lets), which is a legacy feature that allows loading\n- * of remote MBeans. This feature is not usable without a Security Manager, which is deprecated and subject to\n- * removal in a future release. Consequently, this API is also deprecated and subject to removal. There is no replacement.\n- *\n- * @since 1.5\n- *\/\n-@Deprecated(since=\"20\", forRemoval=true)\n-@SuppressWarnings(\"removal\")\n-public class MLet extends java.net.URLClassLoader\n-     implements MLetMBean, MBeanRegistration, Externalizable {\n-\n-     private static final long serialVersionUID = 3636148327800330130L;\n-\n-     \/*\n-     * ------------------------------------------\n-     *   PRIVATE VARIABLES\n-     * ------------------------------------------\n-     *\/\n-\n-     \/**\n-      * The reference to the MBean server.\n-      * @serial\n-      *\/\n-     @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-     private MBeanServer server = null;\n-\n-\n-     \/**\n-      * The list of instances of the <CODE>MLetContent<\/CODE>\n-      * class found at the specified URL.\n-      * @serial\n-      *\/\n-     @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-     private List<MLetContent> mletList = new ArrayList<>();\n-\n-\n-     \/**\n-      * The directory used for storing libraries locally before they are loaded.\n-      *\/\n-     private String libraryDirectory;\n-\n-\n-     \/**\n-      * The object name of the MLet Service.\n-      * @serial\n-      *\/\n-     private ObjectName mletObjectName = null;\n-\n-     \/**\n-      * The URLs of the MLet Service.\n-      * @serial\n-      *\/\n-     private URL[] myUrls = null;\n-\n-     \/**\n-      * What ClassLoaderRepository, if any, to use if this MLet\n-      * doesn't find an asked-for class.\n-      *\/\n-     private transient ClassLoaderRepository currentClr;\n-\n-     \/**\n-      * True if we should consult the {@link ClassLoaderRepository}\n-      * when we do not find a class ourselves.\n-      *\/\n-     private transient boolean delegateToCLR;\n-\n-     \/**\n-      * objects maps from primitive classes to primitive object classes.\n-      *\/\n-     @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-     private Map<String,Class<?>> primitiveClasses = new HashMap<>(8) ;\n-     {\n-         primitiveClasses.put(Boolean.TYPE.toString(), Boolean.class);\n-         primitiveClasses.put(Character.TYPE.toString(), Character.class);\n-         primitiveClasses.put(Byte.TYPE.toString(), Byte.class);\n-         primitiveClasses.put(Short.TYPE.toString(), Short.class);\n-         primitiveClasses.put(Integer.TYPE.toString(), Integer.class);\n-         primitiveClasses.put(Long.TYPE.toString(), Long.class);\n-         primitiveClasses.put(Float.TYPE.toString(), Float.class);\n-         primitiveClasses.put(Double.TYPE.toString(), Double.class);\n-\n-     }\n-\n-\n-     \/*\n-      * ------------------------------------------\n-      *  CONSTRUCTORS\n-      * ------------------------------------------\n-      *\/\n-\n-     \/*\n-      * The constructor stuff would be considerably simplified if our\n-      * parent, URLClassLoader, specified that its one- and\n-      * two-argument constructors were equivalent to its\n-      * three-argument constructor with trailing null arguments.  But\n-      * it doesn't, which prevents us from having all the constructors\n-      * but one call this(...args...).\n-      *\/\n-\n-     \/**\n-      * Constructs a new MLet using the default delegation parent ClassLoader.\n-      *\/\n-     public MLet() {\n-         this(new URL[0]);\n-     }\n-\n-     \/**\n-      * Constructs a new MLet for the specified URLs using the default\n-      * delegation parent ClassLoader.  The URLs will be searched in\n-      * the order specified for classes and resources after first\n-      * searching in the parent class loader.\n-      *\n-      * @param  urls  The URLs from which to load classes and resources.\n-      *\n-      *\/\n-     public MLet(URL[] urls) {\n-         this(urls, true);\n-     }\n-\n-     \/**\n-      * Constructs a new MLet for the given URLs. The URLs will be\n-      * searched in the order specified for classes and resources\n-      * after first searching in the specified parent class loader.\n-      * The parent argument will be used as the parent class loader\n-      * for delegation.\n-      *\n-      * @param  urls  The URLs from which to load classes and resources.\n-      * @param  parent The parent class loader for delegation.\n-      *\n-      *\/\n-     public MLet(URL[] urls, ClassLoader parent) {\n-         this(urls, parent, true);\n-     }\n-\n-     \/**\n-      * Constructs a new MLet for the specified URLs, parent class\n-      * loader, and URLStreamHandlerFactory. The parent argument will\n-      * be used as the parent class loader for delegation. The factory\n-      * argument will be used as the stream handler factory to obtain\n-      * protocol handlers when creating new URLs.\n-      *\n-      * @param  urls  The URLs from which to load classes and resources.\n-      * @param  parent The parent class loader for delegation.\n-      * @param  factory  The URLStreamHandlerFactory to use when creating URLs.\n-      *\n-      *\/\n-     public MLet(URL[] urls,\n-                 ClassLoader parent,\n-                 URLStreamHandlerFactory factory) {\n-         this(urls, parent, factory, true);\n-     }\n-\n-     \/**\n-      * Constructs a new MLet for the specified URLs using the default\n-      * delegation parent ClassLoader.  The URLs will be searched in\n-      * the order specified for classes and resources after first\n-      * searching in the parent class loader.\n-      *\n-      * @param  urls  The URLs from which to load classes and resources.\n-      * @param  delegateToCLR  True if, when a class is not found in\n-      * either the parent ClassLoader or the URLs, the MLet should delegate\n-      * to its containing MBeanServer's {@link ClassLoaderRepository}.\n-      *\n-      *\/\n-     public MLet(URL[] urls, boolean delegateToCLR) {\n-         super(urls);\n-         init(delegateToCLR);\n-     }\n-\n-     \/**\n-      * Constructs a new MLet for the given URLs. The URLs will be\n-      * searched in the order specified for classes and resources\n-      * after first searching in the specified parent class loader.\n-      * The parent argument will be used as the parent class loader\n-      * for delegation.\n-      *\n-      * @param  urls  The URLs from which to load classes and resources.\n-      * @param  parent The parent class loader for delegation.\n-      * @param  delegateToCLR  True if, when a class is not found in\n-      * either the parent ClassLoader or the URLs, the MLet should delegate\n-      * to its containing MBeanServer's {@link ClassLoaderRepository}.\n-      *\n-      *\/\n-     public MLet(URL[] urls, ClassLoader parent, boolean delegateToCLR) {\n-         super(urls, parent);\n-         init(delegateToCLR);\n-     }\n-\n-     \/**\n-      * Constructs a new MLet for the specified URLs, parent class\n-      * loader, and URLStreamHandlerFactory. The parent argument will\n-      * be used as the parent class loader for delegation. The factory\n-      * argument will be used as the stream handler factory to obtain\n-      * protocol handlers when creating new URLs.\n-      *\n-      * @param  urls  The URLs from which to load classes and resources.\n-      * @param  parent The parent class loader for delegation.\n-      * @param  factory  The URLStreamHandlerFactory to use when creating URLs.\n-      * @param  delegateToCLR  True if, when a class is not found in\n-      * either the parent ClassLoader or the URLs, the MLet should delegate\n-      * to its containing MBeanServer's {@link ClassLoaderRepository}.\n-      *\n-      *\/\n-     public MLet(URL[] urls,\n-                 ClassLoader parent,\n-                 URLStreamHandlerFactory factory,\n-                 boolean delegateToCLR) {\n-         super(urls, parent, factory);\n-         init(delegateToCLR);\n-     }\n-\n-     private void init(boolean delegateToCLR) {\n-         this.delegateToCLR = delegateToCLR;\n-\n-         try {\n-             libraryDirectory = System.getProperty(MLET_LIB_DIR);\n-             if (libraryDirectory == null)\n-                 libraryDirectory = getTmpDir();\n-         } catch (SecurityException e) {\n-             \/\/ OK : We don't do AccessController.doPrivileged, but we don't\n-             \/\/      stop the user from creating an MLet just because they\n-             \/\/      can't read the MLET_LIB_DIR or java.io.tmpdir properties\n-             \/\/      either.\n-         }\n-     }\n-\n-\n-     \/*\n-      * ------------------------------------------\n-      *  PUBLIC METHODS\n-      * ------------------------------------------\n-      *\/\n-\n-\n-     \/**\n-      * Appends the specified URL to the list of URLs to search for classes and\n-      * resources.\n-      *\/\n-     public void addURL(URL url) {\n-         if (!Arrays.asList(getURLs()).contains(url))\n-             super.addURL(url);\n-     }\n-\n-     \/**\n-      * Appends the specified URL to the list of URLs to search for classes and\n-      * resources.\n-      * @exception ServiceNotFoundException The specified URL is malformed.\n-      *\/\n-     public void addURL(String url) throws ServiceNotFoundException {\n-         try {\n-             @SuppressWarnings(\"deprecation\")\n-             URL ur = new URL(url);\n-             if (!Arrays.asList(getURLs()).contains(ur))\n-                 super.addURL(ur);\n-         } catch (MalformedURLException e) {\n-             if (MLET_LOGGER.isLoggable(Level.DEBUG)) {\n-                 MLET_LOGGER.log(Level.DEBUG, \"Malformed URL: \" + url, e);\n-             }\n-             throw new\n-                 ServiceNotFoundException(\"The specified URL is malformed\");\n-         }\n-     }\n-\n-     \/** Returns the search path of URLs for loading classes and resources.\n-      * This includes the original list of URLs specified to the constructor,\n-      * along with any URLs subsequently appended by the addURL() method.\n-      *\/\n-     public URL[] getURLs() {\n-         return super.getURLs();\n-     }\n-\n-     \/**\n-      * Loads a text file containing MLET tags that define the MBeans to\n-      * be added to the MBean server. The location of the text file is specified by\n-      * a URL. The MBeans specified in the MLET file will be instantiated and\n-      * registered in the MBean server.\n-      *\n-      * @param url The URL of the text file to be loaded as URL object.\n-      *\n-      * @return  A set containing one entry per MLET tag in the m-let text file loaded.\n-      * Each entry specifies either the ObjectInstance for the created MBean, or a throwable object\n-      * (that is, an error or an exception) if the MBean could not be created.\n-      *\n-      * @exception ServiceNotFoundException One of the following errors has occurred: The m-let text file does\n-      * not contain an MLET tag, the m-let text file is not found, a mandatory\n-      * attribute of the MLET tag is not specified, the value of url is\n-      * null.\n-      * @exception IllegalStateException MLet MBean is not registered with an MBeanServer.\n-      *\/\n-     public Set<Object> getMBeansFromURL(URL url)\n-             throws ServiceNotFoundException  {\n-         if (url == null) {\n-             throw new ServiceNotFoundException(\"The specified URL is null\");\n-         }\n-         return getMBeansFromURL(url.toString());\n-     }\n-\n-     \/**\n-      * Loads a text file containing MLET tags that define the MBeans to\n-      * be added to the MBean server. The location of the text file is specified by\n-      * a URL. The MBeans specified in the MLET file will be instantiated and\n-      * registered in the MBean server.\n-      *\n-      * @param url The URL of the text file to be loaded as String object.\n-      *\n-      * @return A set containing one entry per MLET tag in the m-let\n-      * text file loaded.  Each entry specifies either the\n-      * ObjectInstance for the created MBean, or a throwable object\n-      * (that is, an error or an exception) if the MBean could not be\n-      * created.\n-      *\n-      * @exception ServiceNotFoundException One of the following\n-      * errors has occurred: The m-let text file does not contain an\n-      * MLET tag, the m-let text file is not found, a mandatory\n-      * attribute of the MLET tag is not specified, the url is\n-      * malformed.\n-      * @exception IllegalStateException MLet MBean is not registered\n-      * with an MBeanServer.\n-      *\n-      *\/\n-     public Set<Object> getMBeansFromURL(String url)\n-             throws ServiceNotFoundException  {\n-\n-         if (server == null) {\n-             throw new IllegalStateException(\"This MLet MBean is not \" +\n-                                             \"registered with an MBeanServer.\");\n-         }\n-         \/\/ Parse arguments\n-         if (url == null) {\n-             MLET_LOGGER.log(Level.TRACE, \"URL is null\");\n-             throw new ServiceNotFoundException(\"The specified URL is null\");\n-         } else {\n-             url = url.replace(File.separatorChar,'\/');\n-         }\n-         if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-             MLET_LOGGER.log(Level.TRACE, \"<URL = \" + url + \">\");\n-         }\n-\n-         \/\/ Parse URL\n-         try {\n-             MLetParser parser = new MLetParser();\n-             mletList = parser.parseURL(url);\n-         } catch (Exception e) {\n-             final String msg =\n-                 \"Problems while parsing URL [\" + url +\n-                 \"], got exception [\" + e.toString() + \"]\";\n-             MLET_LOGGER.log(Level.TRACE, msg);\n-             throw EnvHelp.initCause(new ServiceNotFoundException(msg), e);\n-         }\n-\n-         \/\/ Check that the list of MLets is not empty\n-         if (mletList.size() == 0) {\n-             final String msg =\n-                 \"File \" + url + \" not found or MLET tag not defined in file\";\n-             MLET_LOGGER.log(Level.TRACE, msg);\n-             throw new ServiceNotFoundException(msg);\n-         }\n-\n-         \/\/ Walk through the list of MLets\n-         Set<Object> mbeans = new HashSet<>();\n-         for (MLetContent elmt : mletList) {\n-             \/\/ Initialize local variables\n-             String code = elmt.getCode();\n-             if (code != null) {\n-                 if (code.endsWith(\".class\")) {\n-                     code = code.substring(0, code.length() - 6);\n-                 }\n-             }\n-             String name = elmt.getName();\n-             URL codebase = elmt.getCodeBase();\n-             String version = elmt.getVersion();\n-             String serName = elmt.getSerializedObject();\n-             String jarFiles = elmt.getJarFiles();\n-             URL documentBase = elmt.getDocumentBase();\n-\n-             \/\/ Display debug information\n-             if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-                 final StringBuilder strb = new StringBuilder()\n-                 .append(\"\\n\\tMLET TAG     = \").append(elmt.getAttributes())\n-                 .append(\"\\n\\tCODEBASE     = \").append(codebase)\n-                 .append(\"\\n\\tARCHIVE      = \").append(jarFiles)\n-                 .append(\"\\n\\tCODE         = \").append(code)\n-                 .append(\"\\n\\tOBJECT       = \").append(serName)\n-                 .append(\"\\n\\tNAME         = \").append(name)\n-                 .append(\"\\n\\tVERSION      = \").append(version)\n-                 .append(\"\\n\\tDOCUMENT URL = \").append(documentBase);\n-                 MLET_LOGGER.log(Level.TRACE, strb::toString);\n-             }\n-\n-             \/\/ Load classes from JAR files\n-             StringTokenizer st = new StringTokenizer(jarFiles, \",\", false);\n-             while (st.hasMoreTokens()) {\n-                 String tok = st.nextToken().trim();\n-                 if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-                     MLET_LOGGER.log(Level.TRACE,\n-                             \"Load archive for codebase <\" + codebase +\n-                             \">, file <\" + tok + \">\");\n-                 }\n-                 \/\/ Check which is the codebase to be used for loading the jar file.\n-                 \/\/ If we are using the base MLet implementation then it will be\n-                 \/\/ always the remote server but if the service has been extended in\n-                 \/\/ order to support caching and versioning then this method will\n-                 \/\/ return the appropriate one.\n-                 \/\/\n-                 try {\n-                     codebase = check(version, codebase, tok, elmt);\n-                 } catch (Exception ex) {\n-                     MLET_LOGGER.log(Level.DEBUG,\n-                             \"Got unexpected exception\", ex);\n-                     mbeans.add(ex);\n-                     continue;\n-                 }\n-\n-                 \/\/ Appends the specified JAR file URL to the list of\n-                 \/\/ URLs to search for classes and resources.\n-                 try {\n-                     @SuppressWarnings(\"deprecation\")\n-                     var u = new URL(codebase.toString() + tok);\n-                     if (!Arrays.asList(getURLs())\n-                         .contains(u)) {\n-                         addURL(codebase + tok);\n-                     }\n-                 } catch (MalformedURLException me) {\n-                     \/\/ OK : Ignore jar file if its name provokes the\n-                     \/\/ URL to be an invalid one.\n-                 }\n-\n-             }\n-             \/\/ Instantiate the class specified in the\n-             \/\/ CODE or OBJECT section of the MLet tag\n-             \/\/\n-             Object o;\n-             ObjectInstance objInst;\n-\n-             if (code != null && serName != null) {\n-                 final String msg =\n-                     \"CODE and OBJECT parameters cannot be specified at the \" +\n-                     \"same time in tag MLET\";\n-                 MLET_LOGGER.log(Level.TRACE, msg);\n-                 mbeans.add(new Error(msg));\n-                 continue;\n-             }\n-             if (code == null && serName == null) {\n-                 final String msg =\n-                     \"Either CODE or OBJECT parameter must be specified in \" +\n-                     \"tag MLET\";\n-                 MLET_LOGGER.log(Level.TRACE, msg);\n-                 mbeans.add(new Error(msg));\n-                 continue;\n-             }\n-             try {\n-                 if (code != null) {\n-\n-                     List<String> signat = elmt.getParameterTypes();\n-                     List<String> stringPars = elmt.getParameterValues();\n-                     List<Object> objectPars = new ArrayList<>();\n-\n-                     for (int i = 0; i < signat.size(); i++) {\n-                         objectPars.add(constructParameter(stringPars.get(i),\n-                                                           signat.get(i)));\n-                     }\n-                     if (signat.isEmpty()) {\n-                         if (name == null) {\n-                             objInst = server.createMBean(code, null,\n-                                                          mletObjectName);\n-                         } else {\n-                             objInst = server.createMBean(code,\n-                                                          new ObjectName(name),\n-                                                          mletObjectName);\n-                         }\n-                     } else {\n-                         Object[] parms = objectPars.toArray();\n-                         String[] signature = new String[signat.size()];\n-                         signat.toArray(signature);\n-                         if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-                             final StringBuilder strb = new StringBuilder();\n-                             for (int i = 0; i < signature.length; i++) {\n-                                 strb.append(\"\\n\\tSignature     = \")\n-                                 .append(signature[i])\n-                                 .append(\"\\t\\nParams        = \")\n-                                 .append(parms[i]);\n-                             }\n-                             MLET_LOGGER.log(Level.TRACE, strb::toString);\n-                         }\n-                         if (name == null) {\n-                             objInst =\n-                                 server.createMBean(code, null, mletObjectName,\n-                                                    parms, signature);\n-                         } else {\n-                             objInst =\n-                                 server.createMBean(code, new ObjectName(name),\n-                                                    mletObjectName, parms,\n-                                                    signature);\n-                         }\n-                     }\n-                 } else {\n-                     o = loadSerializedObject(codebase,serName);\n-                     if (name == null) {\n-                         server.registerMBean(o, null);\n-                     } else {\n-                         server.registerMBean(o,  new ObjectName(name));\n-                     }\n-                     objInst = new ObjectInstance(name, o.getClass().getName());\n-                 }\n-             } catch (ReflectionException  ex) {\n-                 MLET_LOGGER.log(Level.TRACE, \"ReflectionException\", ex);\n-                 mbeans.add(ex);\n-                 continue;\n-             } catch (InstanceAlreadyExistsException  ex) {\n-                 MLET_LOGGER.log(Level.TRACE,\n-                         \"InstanceAlreadyExistsException\", ex);\n-                 mbeans.add(ex);\n-                 continue;\n-             } catch (MBeanRegistrationException ex) {\n-                 MLET_LOGGER.log(Level.TRACE, \"MBeanRegistrationException\", ex);\n-                 mbeans.add(ex);\n-                 continue;\n-             } catch (MBeanException  ex) {\n-                 MLET_LOGGER.log(Level.TRACE, \"MBeanException\", ex);\n-                 mbeans.add(ex);\n-                 continue;\n-             } catch (NotCompliantMBeanException  ex) {\n-                 MLET_LOGGER.log(Level.TRACE,\n-                         \"NotCompliantMBeanException\", ex);\n-                 mbeans.add(ex);\n-                 continue;\n-             } catch (InstanceNotFoundException   ex) {\n-                 MLET_LOGGER.log(Level.TRACE,\n-                         \"InstanceNotFoundException\", ex);\n-                 mbeans.add(ex);\n-                 continue;\n-             } catch (IOException ex) {\n-                 MLET_LOGGER.log(Level.TRACE, \"IOException\", ex);\n-                 mbeans.add(ex);\n-                 continue;\n-             } catch (SecurityException ex) {\n-                 MLET_LOGGER.log(Level.TRACE, \"SecurityException\", ex);\n-                 mbeans.add(ex);\n-                 continue;\n-             } catch (Exception ex) {\n-                 MLET_LOGGER.log(Level.TRACE, \"Exception\", ex);\n-                 mbeans.add(ex);\n-                 continue;\n-             } catch (Error ex) {\n-                 MLET_LOGGER.log(Level.TRACE, \"Error\", ex);\n-                 mbeans.add(ex);\n-                 continue;\n-             }\n-             mbeans.add(objInst);\n-         }\n-         return mbeans;\n-     }\n-\n-     \/**\n-      * Gets the current directory used by the library loader for\n-      * storing native libraries before they are loaded into memory.\n-      *\n-      * @return The current directory used by the library loader.\n-      *\n-      * @see #setLibraryDirectory\n-      *\n-      * @throws UnsupportedOperationException if this implementation\n-      * does not support storing native libraries in this way.\n-      *\/\n-     public synchronized String getLibraryDirectory() {\n-         return libraryDirectory;\n-     }\n-\n-     \/**\n-      * Sets the directory used by the library loader for storing\n-      * native libraries before they are loaded into memory.\n-      *\n-      * @param libdir The directory used by the library loader.\n-      *\n-      * @see #getLibraryDirectory\n-      *\n-      * @throws UnsupportedOperationException if this implementation\n-      * does not support storing native libraries in this way.\n-      *\/\n-     public synchronized void setLibraryDirectory(String libdir) {\n-         libraryDirectory = libdir;\n-     }\n-\n-     \/**\n-      * Allows the m-let to perform any operations it needs before\n-      * being registered in the MBean server. If the ObjectName is\n-      * null, the m-let provides a default name for its registration\n-      * &lt;defaultDomain&gt;:type=MLet\n-      *\n-      * @param server The MBean server in which the m-let will be registered.\n-      * @param name The object name of the m-let.\n-      *\n-      * @return  The name of the m-let registered.\n-      *\n-      * @exception java.lang.Exception This exception should be caught by the MBean server and re-thrown\n-      *as an MBeanRegistrationException.\n-      *\/\n-     public ObjectName preRegister(MBeanServer server, ObjectName name)\n-             throws Exception {\n-\n-         \/\/ Initialize local pointer to the MBean server\n-         setMBeanServer(server);\n-\n-         \/\/ If no name is specified return a default name for the MLet\n-         if (name == null) {\n-             name = new ObjectName(server.getDefaultDomain() + \":\" + ServiceName.MLET);\n-         }\n-\n-        this.mletObjectName = name;\n-        return this.mletObjectName;\n-     }\n-\n-     \/**\n-      * Allows the m-let to perform any operations needed after having been\n-      * registered in the MBean server or after the registration has failed.\n-      *\n-      * @param registrationDone Indicates whether or not the m-let has\n-      * been successfully registered in the MBean server. The value\n-      * false means that either the registration phase has failed.\n-      *\n-      *\/\n-     public void postRegister (Boolean registrationDone) {\n-     }\n-\n-     \/**\n-      * Allows the m-let to perform any operations it needs before being unregistered\n-      * by the MBean server.\n-      *\n-      * @exception java.lang.Exception This exception should be caught\n-      * by the MBean server and re-thrown as an\n-      * MBeanRegistrationException.\n-      *\/\n-     public void preDeregister() throws java.lang.Exception {\n-     }\n-\n-\n-     \/**\n-      * Allows the m-let to perform any operations needed after having been\n-      * unregistered in the MBean server.\n-      *\/\n-     public void postDeregister() {\n-     }\n-\n-     \/**\n-      * <p>Save this MLet's contents to the given {@link ObjectOutput}.\n-      * Not all implementations support this method.  Those that do not\n-      * throw {@link UnsupportedOperationException}.  A subclass may\n-      * override this method to support it or to change the format of\n-      * the written data.<\/p>\n-      *\n-      * <p>The format of the written data is not specified, but if\n-      * an implementation supports {@link #writeExternal} it must\n-      * also support {@link #readExternal} in such a way that what is\n-      * written by the former can be read by the latter.<\/p>\n-      *\n-      * @param out The object output stream to write to.\n-      *\n-      * @exception IOException If a problem occurred while writing.\n-      * @exception UnsupportedOperationException If this\n-      * implementation does not support this operation.\n-      *\/\n-     public void writeExternal(ObjectOutput out)\n-             throws IOException, UnsupportedOperationException {\n-         throw new UnsupportedOperationException(\"MLet.writeExternal\");\n-     }\n-\n-     \/**\n-      * <p>Restore this MLet's contents from the given {@link ObjectInput}.\n-      * Not all implementations support this method.  Those that do not\n-      * throw {@link UnsupportedOperationException}.  A subclass may\n-      * override this method to support it or to change the format of\n-      * the read data.<\/p>\n-      *\n-      * <p>The format of the read data is not specified, but if an\n-      * implementation supports {@link #readExternal} it must also\n-      * support {@link #writeExternal} in such a way that what is\n-      * written by the latter can be read by the former.<\/p>\n-      *\n-      * @param in The object input stream to read from.\n-      *\n-      * @exception IOException if a problem occurred while reading.\n-      * @exception ClassNotFoundException if the class for the object\n-      * being restored cannot be found.\n-      * @exception UnsupportedOperationException if this\n-      * implementation does not support this operation.\n-      *\/\n-     public void readExternal(ObjectInput in)\n-             throws IOException, ClassNotFoundException,\n-                    UnsupportedOperationException {\n-         throw new UnsupportedOperationException(\"MLet.readExternal\");\n-     }\n-\n-     \/*\n-      * ------------------------------------------\n-      *  PACKAGE METHODS\n-      * ------------------------------------------\n-      *\/\n-\n-     \/**\n-      * <p>Load a class, using the given {@link ClassLoaderRepository} if\n-      * the class is not found in this MLet's URLs.  The given\n-      * ClassLoaderRepository can be null, in which case a {@link\n-      * ClassNotFoundException} occurs immediately if the class is not\n-      * found in this MLet's URLs.<\/p>\n-      *\n-      * @param name The name of the class we want to load.\n-      * @param clr  The ClassLoaderRepository that will be used to search\n-      *             for the given class, if it is not found in this\n-      *             ClassLoader.  May be null.\n-      * @return The resulting Class object.\n-      * @exception ClassNotFoundException The specified class could not be\n-      *            found in this ClassLoader nor in the given\n-      *            ClassLoaderRepository.\n-      *\n-      *\/\n-     public synchronized Class<?> loadClass(String name,\n-                                            ClassLoaderRepository clr)\n-              throws ClassNotFoundException {\n-         final ClassLoaderRepository before=currentClr;\n-         try {\n-             currentClr = clr;\n-             return loadClass(name);\n-         } finally {\n-             currentClr = before;\n-         }\n-     }\n-\n-     \/*\n-      * ------------------------------------------\n-      *  PROTECTED METHODS\n-      * ------------------------------------------\n-      *\/\n-\n-     \/**\n-      * This is the main method for class loaders that is being redefined.\n-      *\n-      * @param name The name of the class.\n-      *\n-      * @return The resulting Class object.\n-      *\n-      * @exception ClassNotFoundException The specified class could not be\n-      *            found.\n-      *\/\n-     protected Class<?> findClass(String name) throws ClassNotFoundException {\n-         \/* currentClr is context sensitive - used to avoid recursion\n-            in the class loader repository.  (This is no longer\n-            necessary with the new CLR semantics but is kept for\n-            compatibility with code that might have called the\n-            two-parameter loadClass explicitly.)  *\/\n-         return findClass(name, currentClr);\n-     }\n-\n-     \/**\n-      * Called by {@link MLet#findClass(java.lang.String)}.\n-      *\n-      * @param name The name of the class that we want to load\/find.\n-      * @param clr The ClassLoaderRepository that can be used to search\n-      *            for the given class. This parameter is\n-      *            <code>null<\/code> when called from within the\n-      *            {@link javax.management.MBeanServerFactory#getClassLoaderRepository(javax.management.MBeanServer) Class Loader Repository}.\n-      * @exception ClassNotFoundException The specified class could not be\n-      *            found.\n-      *\n-      **\/\n-     Class<?> findClass(String name, ClassLoaderRepository clr)\n-         throws ClassNotFoundException {\n-         Class<?> c = null;\n-         MLET_LOGGER.log(Level.TRACE, name);\n-         \/\/ Try looking in the JAR:\n-         try {\n-             c = super.findClass(name);\n-             if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-                 MLET_LOGGER.log(Level.TRACE,\n-                         \"Class \" + name + \" loaded through MLet classloader\");\n-             }\n-         } catch (ClassNotFoundException e) {\n-             \/\/ Drop through\n-             if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-                 MLET_LOGGER.log(Level.TRACE,\n-                         \"Class \" + name + \" not found locally\");\n-             }\n-         }\n-         \/\/ if we are not called from the ClassLoaderRepository\n-         if (c == null && delegateToCLR && clr != null) {\n-             \/\/ Try the classloader repository:\n-             \/\/\n-             try {\n-                 if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-                     MLET_LOGGER.log(Level.TRACE,\n-                             \"Class \" + name + \" : looking in CLR\");\n-                 }\n-                 c = clr.loadClassBefore(this, name);\n-                 \/\/ The loadClassBefore method never returns null.\n-                 \/\/ If the class is not found we get an exception.\n-                 if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-                     MLET_LOGGER.log(Level.TRACE,\n-                             \"Class \" + name + \" loaded through \" +\n-                             \"the default classloader repository\");\n-                 }\n-             } catch (ClassNotFoundException e) {\n-                 \/\/ Drop through\n-                 if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-                     MLET_LOGGER.log(Level.TRACE,\n-                             \"Class \" + name + \" not found in CLR\");\n-                 }\n-             }\n-         }\n-         if (c == null) {\n-             MLET_LOGGER.log(Level.TRACE, \"Failed to load class \" + name);\n-             throw new ClassNotFoundException(name);\n-         }\n-         return c;\n-     }\n-\n-     \/**\n-      * Returns the absolute path name of a native library. The VM\n-      * invokes this method to locate the native libraries that belong\n-      * to classes loaded with this class loader. Libraries are\n-      * searched in the JAR files using first just the native library\n-      * name and if not found the native library name together with\n-      * the architecture-specific path name\n-      * (<code>OSName\/OSArch\/OSVersion\/lib\/nativelibname<\/code>), i.e.\n-      * <p>\n-      * the library stat on Solaris SPARC 5.7 will be searched in the JAR file as:\n-      * <OL>\n-      * <LI>libstat.so\n-      * <LI>SunOS\/sparc\/5.7\/lib\/libstat.so\n-      * <\/OL>\n-      * the library stat on Windows NT 4.0 will be searched in the JAR file as:\n-      * <OL>\n-      * <LI>stat.dll\n-      * <LI>WindowsNT\/x86\/4.0\/lib\/stat.dll\n-      * <\/OL>\n-      *\n-      * <p>More specifically, let <em>{@code nativelibname}<\/em> be the result of\n-      * {@link System#mapLibraryName(java.lang.String)\n-      * System.mapLibraryName}{@code (libname)}.  Then the following names are\n-      * searched in the JAR files, in order:<br>\n-      * <em>{@code nativelibname}<\/em><br>\n-      * {@code <os.name>\/<os.arch>\/<os.version>\/lib\/}<em>{@code nativelibname}<\/em><br>\n-      * where {@code <X>} means {@code System.getProperty(X)} with any\n-      * spaces in the result removed, and {@code \/} stands for the\n-      * file separator character ({@link File#separator}).\n-      * <p>\n-      * If this method returns <code>null<\/code>, i.e. the libraries\n-      * were not found in any of the JAR files loaded with this class\n-      * loader, the VM searches the library along the path specified\n-      * as the <code>java.library.path<\/code> property.\n-      *\n-      * @param libname The library name.\n-      *\n-      * @return The absolute path of the native library.\n-      *\/\n-     protected String findLibrary(String libname) {\n-\n-         String abs_path;\n-         String mth = \"findLibrary\";\n-\n-         \/\/ Get the platform-specific string representing a native library.\n-         \/\/\n-         String nativelibname = System.mapLibraryName(libname);\n-\n-         \/\/\n-         \/\/ See if the native library is accessible as a resource through the JAR file.\n-         \/\/\n-         if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-             MLET_LOGGER.log(Level.TRACE,\n-                     \"Search \" + libname + \" in all JAR files\");\n-         }\n-\n-         \/\/ First try to locate the library in the JAR file using only\n-         \/\/ the native library name.  e.g. if user requested a load\n-         \/\/ for \"foo\" on Solaris SPARC 5.7 we try to load \"libfoo.so\"\n-         \/\/ from the JAR file.\n-         \/\/\n-         if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-             MLET_LOGGER.log(Level.TRACE,\n-                     \"loadLibraryAsResource(\" + nativelibname + \")\");\n-         }\n-         abs_path = loadLibraryAsResource(nativelibname);\n-         if (abs_path != null) {\n-             if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-                 MLET_LOGGER.log(Level.TRACE,\n-                         nativelibname + \" loaded, absolute path = \" + abs_path);\n-             }\n-             return abs_path;\n-         }\n-\n-         \/\/ Next try to locate it using the native library name and\n-         \/\/ the architecture-specific path name.  e.g. if user\n-         \/\/ requested a load for \"foo\" on Solaris SPARC 5.7 we try to\n-         \/\/ load \"SunOS\/sparc\/5.7\/lib\/libfoo.so\" from the JAR file.\n-         \/\/\n-         nativelibname = removeSpace(System.getProperty(\"os.name\")) + File.separator +\n-             removeSpace(System.getProperty(\"os.arch\")) + File.separator +\n-             removeSpace(System.getProperty(\"os.version\")) + File.separator +\n-             \"lib\" + File.separator + nativelibname;\n-         if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-             MLET_LOGGER.log(Level.TRACE,\n-                     \"loadLibraryAsResource(\" + nativelibname + \")\");\n-         }\n-\n-         abs_path = loadLibraryAsResource(nativelibname);\n-         if (abs_path != null) {\n-             if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-                 MLET_LOGGER.log(Level.TRACE,\n-                         nativelibname + \" loaded, absolute path = \" + abs_path);\n-             }\n-             return abs_path;\n-         }\n-\n-         \/\/\n-         \/\/ All paths exhausted, library not found in JAR file.\n-         \/\/\n-\n-         if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-             MLET_LOGGER.log(Level.TRACE,\n-                     libname + \" not found in any JAR file\");\n-             MLET_LOGGER.log(Level.TRACE,\n-                     \"Search \" + libname + \" along the path \" +\n-                     \"specified as the java.library.path property\");\n-         }\n-\n-         \/\/ Let the VM search the library along the path\n-         \/\/ specified as the java.library.path property.\n-         \/\/\n-         return null;\n-     }\n-\n-\n-     \/*\n-      * ------------------------------------------\n-      *  PRIVATE METHODS\n-      * ------------------------------------------\n-      *\/\n-\n-     private String getTmpDir() {\n-         \/\/ JDK 1.4\n-         String tmpDir = System.getProperty(\"java.io.tmpdir\");\n-         if (tmpDir != null) return tmpDir;\n-\n-         \/\/ JDK < 1.4\n-         File tmpFile = null;\n-         try {\n-             \/\/ Try to guess the system temporary dir...\n-             tmpFile = File.createTempFile(\"tmp\",\"jmx\");\n-             if (tmpFile == null) return null;\n-             final File tmpDirFile = tmpFile.getParentFile();\n-             if (tmpDirFile == null) return null;\n-             return tmpDirFile.getAbsolutePath();\n-         } catch (Exception x) {\n-             MLET_LOGGER.log(Level.DEBUG,\n-                     \"Failed to determine system temporary dir\");\n-             return null;\n-         } finally {\n-             \/\/ Cleanup ...\n-             if (tmpFile!=null) {\n-                 try {\n-                     boolean deleted = tmpFile.delete();\n-                     if (!deleted) {\n-                         MLET_LOGGER.log(Level.DEBUG,\n-                                 \"Failed to delete temp file\");\n-                     }\n-                 } catch (Exception x) {\n-                     MLET_LOGGER.log(Level.DEBUG,\n-                             \"Failed to delete temporary file\", x);\n-                 }\n-             }\n-        }\n-     }\n-\n-     \/**\n-      * Search the specified native library in any of the JAR files\n-      * loaded by this classloader.  If the library is found copy it\n-      * into the library directory and return the absolute path.  If\n-      * the library is not found then return null.\n-      *\/\n-     private synchronized String loadLibraryAsResource(String libname) {\n-         try {\n-             InputStream is = getResourceAsStream(\n-                     libname.replace(File.separatorChar,'\/'));\n-             if (is != null) {\n-                 try {\n-                     File directory = new File(libraryDirectory);\n-                     directory.mkdirs();\n-                     File file = Files.createTempFile(directory.toPath(),\n-                                                      libname + \".\", null)\n-                                      .toFile();\n-                     file.deleteOnExit();\n-                     Files.copy(is, file.toPath(), StandardCopyOption.REPLACE_EXISTING);\n-                     return file.getAbsolutePath();\n-                 } finally {\n-                     is.close();\n-                 }\n-             }\n-         } catch (Exception e) {\n-             MLET_LOGGER.log(Level.DEBUG,\n-                     \"Failed to load library : \" + libname, e);\n-             return null;\n-         }\n-         return null;\n-     }\n-\n-   \/**\n-    * Removes any white space from a string. This is used to\n-    * convert strings such as \"Windows NT\" to \"WindowsNT\".\n-    *\/\n-     private static String removeSpace(String s) {\n-         return s.trim().replace(\" \", \"\");\n-     }\n-\n-     \/**\n-      * <p>This method is to be overridden when extending this service to\n-      * support caching and versioning.  It is called from {@link\n-      * #getMBeansFromURL getMBeansFromURL} when the version,\n-      * codebase, and jarfile have been extracted from the MLet file,\n-      * and can be used to verify that it is all right to load the\n-      * given MBean, or to replace the given URL with a different one.<\/p>\n-      *\n-      * <p>The default implementation of this method returns\n-      * <code>codebase<\/code> unchanged.<\/p>\n-      *\n-      * @param version The version number of the <CODE>.jar<\/CODE>\n-      * file stored locally.\n-      * @param codebase The base URL of the remote <CODE>.jar<\/CODE> file.\n-      * @param jarfile The name of the <CODE>.jar<\/CODE> file to be loaded.\n-      * @param mlet The <CODE>MLetContent<\/CODE> instance that\n-      * represents the <CODE>MLET<\/CODE> tag.\n-      *\n-      * @return the codebase to use for the loaded MBean.  The returned\n-      * value should not be null.\n-      *\n-      * @exception Exception if the MBean is not to be loaded for some\n-      * reason.  The exception will be added to the set returned by\n-      * {@link #getMBeansFromURL getMBeansFromURL}.\n-      *\n-      *\/\n-     protected URL check(String version, URL codebase, String jarfile,\n-                         MLetContent mlet)\n-             throws Exception {\n-         return codebase;\n-     }\n-\n-    \/**\n-     * Loads the serialized object specified by the <CODE>OBJECT<\/CODE>\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     *\n-     * @param codebase The <CODE>codebase<\/CODE>.\n-     * @param filename The name of the file containing the serialized object.\n-     * @return The serialized object.\n-     * @exception ClassNotFoundException The specified serialized\n-     * object could not be found.\n-     * @exception IOException An I\/O error occurred while loading\n-     * serialized object.\n-     *\/\n-     private Object loadSerializedObject(URL codebase, String filename)\n-             throws IOException, ClassNotFoundException {\n-        if (filename != null) {\n-            filename = filename.replace(File.separatorChar,'\/');\n-        }\n-        if (MLET_LOGGER.isLoggable(Level.TRACE)) {\n-            MLET_LOGGER.log(Level.TRACE, codebase.toString() + filename);\n-        }\n-        InputStream is = getResourceAsStream(filename);\n-        if (is != null) {\n-            try {\n-                ObjectInputStream ois = new MLetObjectInputStream(is, this);\n-                Object serObject = ois.readObject();\n-                ois.close();\n-                return serObject;\n-            } catch (IOException | ClassNotFoundException e) {\n-                if (MLET_LOGGER.isLoggable(Level.DEBUG)) {\n-                    MLET_LOGGER.log(Level.DEBUG,\n-                            \"Exception while deserializing \" + filename, e);\n-                }\n-                throw e;\n-            }\n-        } else {\n-            if (MLET_LOGGER.isLoggable(Level.DEBUG)) {\n-                MLET_LOGGER.log(Level.DEBUG, \"Error: File \" + filename +\n-                        \" containing serialized object not found\");\n-            }\n-            throw new Error(\"File \" + filename + \" containing serialized object not found\");\n-        }\n-     }\n-\n-     \/**\n-      * Converts the String value of the constructor's parameter to\n-      * a basic Java object with the type of the parameter.\n-      *\/\n-     private  Object constructParameter(String param, String type) {\n-         \/\/ check if it is a primitive type\n-         Class<?> c = primitiveClasses.get(type);\n-         if (c != null) {\n-            try {\n-                Constructor<?> cons =\n-                    c.getConstructor(String.class);\n-                Object[] oo = new Object[1];\n-                oo[0]=param;\n-                return(cons.newInstance(oo));\n-\n-            } catch (Exception  e) {\n-                MLET_LOGGER.log(Level.DEBUG, \"Got unexpected exception\", e);\n-            }\n-        }\n-         return switch (type) {\n-             case \"java.lang.Boolean\" -> Boolean.valueOf(param);\n-             case \"java.lang.Byte\" -> Byte.valueOf(param);\n-             case \"java.lang.Short\" -> Short.valueOf(param);\n-             case \"java.lang.Long\" -> Long.valueOf(param);\n-             case \"java.lang.Integer\" -> Integer.valueOf(param);\n-             case \"java.lang.Float\" -> Float.valueOf(param);\n-             case \"java.lang.Double\" -> Double.valueOf(param);\n-             default -> param;\n-         };\n-     }\n-\n-    @SuppressWarnings(\"removal\")\n-    private synchronized void setMBeanServer(final MBeanServer server) {\n-        this.server = server;\n-        PrivilegedAction<ClassLoaderRepository> act =\n-            new PrivilegedAction<>() {\n-                public ClassLoaderRepository run() {\n-                    return server.getClassLoaderRepository();\n-                }\n-            };\n-        currentClr = AccessController.doPrivileged(act);\n-    }\n-\n-}\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLet.java","additions":0,"deletions":1294,"binary":false,"changes":1294,"status":"deleted"},{"patch":"@@ -1,245 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javax.management.loading;\n-\n-\n-\/\/ java import\n-\n-import java.net.URL;\n-import java.net.MalformedURLException;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-\n-\/**\n- * This class represents the contents of the <CODE>MLET<\/CODE> tag.\n- * It can be consulted by a subclass of {@link MLet} that overrides\n- * the {@link MLet#check MLet.check} method.\n- *\n- * @deprecated This API is part of Management Applets (m-lets), which is a legacy feature that allows loading\n- * of remote MBeans. This feature is not usable without a Security Manager, which is deprecated and subject to\n- * removal in a future release. Consequently, this API is also deprecated and subject to removal. There is no replacement.\n- *\n- * @since 1.6\n- *\/\n-@Deprecated(since=\"20\", forRemoval=true)\n-public class MLetContent {\n-\n-    \/**\n-     * A map of the attributes of the <CODE>MLET<\/CODE> tag\n-     * and their values.\n-     *\/\n-    private Map<String,String> attributes;\n-\n-    \/**\n-     * An ordered list of the TYPE attributes that appeared in nested\n-     * &lt;PARAM&gt; tags.\n-     *\/\n-    private List<String> types;\n-\n-    \/**\n-     * An ordered list of the VALUE attributes that appeared in nested\n-     * &lt;PARAM&gt; tags.\n-     *\/\n-    private List<String> values;\n-\n-    \/**\n-     * The MLet text file's base URL.\n-     *\/\n-    private URL documentURL;\n-    \/**\n-     * The base URL.\n-     *\/\n-    private URL baseURL;\n-\n-\n-    \/**\n-     * Creates an <CODE>MLet<\/CODE> instance initialized with attributes read\n-     * from an <CODE>MLET<\/CODE> tag in an MLet text file.\n-     *\n-     * @param url The URL of the MLet text file containing the\n-     * <CODE>MLET<\/CODE> tag.\n-     * @param attributes A map of the attributes of the <CODE>MLET<\/CODE> tag.\n-     * The keys in this map are the attribute names in lowercase, for\n-     * example <code>codebase<\/code>.  The values are the associated attribute\n-     * values.\n-     * @param types A list of the TYPE attributes that appeared in nested\n-     * &lt;PARAM&gt; tags.\n-     * @param values A list of the VALUE attributes that appeared in nested\n-     * &lt;PARAM&gt; tags.\n-     *\/\n-    public MLetContent(URL url, Map<String,String> attributes,\n-                       List<String> types, List<String> values) {\n-        this.documentURL = url;\n-        this.attributes = Collections.unmodifiableMap(attributes);\n-        this.types = Collections.unmodifiableList(types);\n-        this.values = Collections.unmodifiableList(values);\n-\n-        \/\/ Initialize baseURL\n-        \/\/\n-        String att = getParameter(\"codebase\");\n-        if (att != null) {\n-            if (!att.endsWith(\"\/\")) {\n-                att += \"\/\";\n-            }\n-            try {\n-                @SuppressWarnings(\"deprecation\")\n-                var _unused = baseURL = new URL(documentURL, att);\n-            } catch (MalformedURLException e) {\n-                \/\/ OK : Move to next block as baseURL could not be initialized.\n-            }\n-        }\n-        if (baseURL == null) {\n-            String file = documentURL.getFile();\n-            int i = file.lastIndexOf('\/');\n-            if (i >= 0 && i < file.length() - 1) {\n-                try {\n-                    @SuppressWarnings(\"deprecation\")\n-                    var _unused = baseURL = new URL(documentURL, file.substring(0, i + 1));\n-                } catch (MalformedURLException e) {\n-                    \/\/ OK : Move to next block as baseURL could not be initialized.\n-                }\n-            }\n-        }\n-        if (baseURL == null)\n-            baseURL = documentURL;\n-\n-    }\n-\n-    \/\/ GETTERS AND SETTERS\n-    \/\/--------------------\n-\n-    \/**\n-     * Gets the attributes of the <CODE>MLET<\/CODE> tag.  The keys in\n-     * the returned map are the attribute names in lowercase, for\n-     * example <code>codebase<\/code>.  The values are the associated\n-     * attribute values.\n-     * @return A map of the attributes of the <CODE>MLET<\/CODE> tag\n-     * and their values.\n-     *\/\n-    public Map<String,String> getAttributes() {\n-        return attributes;\n-    }\n-\n-    \/**\n-     * Gets the MLet text file's base URL.\n-     * @return The MLet text file's base URL.\n-     *\/\n-    public URL getDocumentBase() {\n-        return documentURL;\n-    }\n-\n-    \/**\n-     * Gets the code base URL.\n-     * @return The code base URL.\n-     *\/\n-    public URL getCodeBase() {\n-        return baseURL;\n-    }\n-\n-    \/**\n-     * Gets the list of <CODE>.jar<\/CODE> files specified by the <CODE>ARCHIVE<\/CODE>\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     * @return A comma-separated list of <CODE>.jar<\/CODE> file names.\n-     *\/\n-    public String getJarFiles() {\n-        return getParameter(\"archive\");\n-    }\n-\n-    \/**\n-     * Gets the value of the <CODE>CODE<\/CODE>\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     * @return The value of the <CODE>CODE<\/CODE>\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     *\/\n-    public String getCode() {\n-        return getParameter(\"code\");\n-    }\n-\n-    \/**\n-     * Gets the value of the <CODE>OBJECT<\/CODE>\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     * @return The value of the <CODE>OBJECT<\/CODE>\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     *\/\n-    public String getSerializedObject() {\n-        return getParameter(\"object\");\n-    }\n-\n-    \/**\n-     * Gets the value of the <CODE>NAME<\/CODE>\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     * @return The value of the <CODE>NAME<\/CODE>\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     *\/\n-    public String getName() {\n-        return getParameter(\"name\");\n-    }\n-\n-\n-    \/**\n-     * Gets the value of the <CODE>VERSION<\/CODE>\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     * @return The value of the <CODE>VERSION<\/CODE>\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     *\/\n-    public String getVersion() {\n-        return getParameter(\"version\");\n-    }\n-\n-    \/**\n-     * Gets the list of values of the <code>TYPE<\/code> attribute in\n-     * each nested &lt;PARAM&gt; tag within the <code>MLET<\/code>\n-     * tag.\n-     * @return the list of types.\n-     *\/\n-    public List<String> getParameterTypes() {\n-        return types;\n-    }\n-\n-    \/**\n-     * Gets the list of values of the <code>VALUE<\/code> attribute in\n-     * each nested &lt;PARAM&gt; tag within the <code>MLET<\/code>\n-     * tag.\n-     * @return the list of values.\n-     *\/\n-    public List<String> getParameterValues() {\n-        return values;\n-    }\n-\n-    \/**\n-     * Gets the value of the specified\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     *\n-     * @param name A string representing the name of the attribute.\n-     * @return The value of the specified\n-     * attribute of the <CODE>MLET<\/CODE> tag.\n-     *\/\n-    private String getParameter(String name) {\n-        return attributes.get(name.toLowerCase());\n-    }\n-\n-}\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLetContent.java","additions":0,"deletions":245,"binary":false,"changes":245,"status":"deleted"},{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javax.management.loading;\n-\n-import java.net.URL;\n-import java.io.InputStream;\n-import java.io.IOException;\n-import java.util.Set;\n-import java.util.Enumeration;\n-\n-import javax.management.*;\n-\n-\n-\n-\/**\n- * Exposes the remote management interface of the MLet\n- * MBean.\n- *\n- * @deprecated This API is part of Management Applets (m-lets), which is a legacy feature that allows loading\n- * of remote MBeans. This feature is not usable without a Security Manager, which is deprecated and subject to\n- * removal in a future release. Consequently, this API is also deprecated and subject to removal. There is no replacement.\n- *\n- * @since 1.5\n- *\/\n-@Deprecated(since=\"20\", forRemoval=true)\n-public interface MLetMBean   {\n-\n-    \/**\n-     * Loads a text file containing MLET tags that define the MBeans\n-     * to be added to the MBean server. The location of the text file is\n-     * specified by a URL. The text file is read using the UTF-8\n-     * encoding. The MBeans specified in the MLET file will be\n-     * instantiated and registered in the MBean server.\n-     *\n-     * @param url The URL of the text file to be loaded as String object.\n-     *\n-     * @return A set containing one entry per MLET tag in the m-let\n-     * text file loaded.  Each entry specifies either the\n-     * ObjectInstance for the created MBean, or a throwable object\n-     * (that is, an error or an exception) if the MBean could not be\n-     * created.\n-     *\n-     * @exception ServiceNotFoundException One of the following errors\n-     * has occurred: The m-let text file does not contain an MLET tag,\n-     * the m-let text file is not found, a mandatory attribute of the\n-     * MLET tag is not specified, the value of url is malformed.\n-     *\/\n-    public Set<Object> getMBeansFromURL(String url)\n-            throws ServiceNotFoundException;\n-\n-    \/**\n-     * Loads a text file containing MLET tags that define the MBeans\n-     * to be added to the MBean server. The location of the text file is\n-     * specified by a URL. The text file is read using the UTF-8\n-     * encoding. The MBeans specified in the MLET file will be\n-     * instantiated and registered in the MBean server.\n-     *\n-     * @param url The URL of the text file to be loaded as URL object.\n-     *\n-     * @return A set containing one entry per MLET tag in the m-let\n-     * text file loaded.  Each entry specifies either the\n-     * ObjectInstance for the created MBean, or a throwable object\n-     * (that is, an error or an exception) if the MBean could not be\n-     * created.\n-     *\n-     * @exception ServiceNotFoundException One of the following errors\n-     * has occurred: The m-let text file does not contain an MLET tag,\n-     * the m-let text file is not found, a mandatory attribute of the\n-     * MLET tag is not specified, the value of url is null.\n-     *\/\n-    public Set<Object> getMBeansFromURL(URL url)\n-            throws ServiceNotFoundException;\n-\n-    \/**\n-     * Appends the specified URL to the list of URLs to search for classes and\n-     * resources.\n-     *\n-     * @param url the URL to add.\n-     *\/\n-    public void addURL(URL url) ;\n-\n-    \/**\n-     * Appends the specified URL to the list of URLs to search for classes and\n-     * resources.\n-     *\n-     * @param url the URL to add.\n-     *\n-     * @exception ServiceNotFoundException The specified URL is malformed.\n-     *\/\n-    public void addURL(String url) throws ServiceNotFoundException;\n-\n-    \/**\n-     * Returns the search path of URLs for loading classes and resources.\n-     * This includes the original list of URLs specified to the constructor,\n-     * along with any URLs subsequently appended by the addURL() method.\n-     *\n-     * @return the list of URLs.\n-     *\/\n-    public URL[] getURLs();\n-\n-    \/** Finds the resource with the given name.\n-     * A resource is some data (images, audio, text, etc) that can be accessed by class code in a way that is\n-     *   independent of the location of the code.\n-     *   The name of a resource is a \"\/\"-separated path name that identifies the resource.\n-     *\n-     * @param name The resource name\n-     *\n-     * @return  An URL for reading the resource, or null if the resource could not be found or the caller doesn't have adequate privileges to get the\n-     * resource.\n-     *\/\n-    public URL getResource(String name);\n-\n-    \/** Returns an input stream for reading the specified resource. The search order is described in the documentation for\n-     *  getResource(String).\n-     *\n-     * @param name  The resource name\n-     *\n-     * @return An input stream for reading the resource, or null if the resource could not be found\n-     *\n-     *\/\n-    public InputStream getResourceAsStream(String name);\n-\n-    \/**\n-     * Finds all the resources with the given name. A resource is some\n-     * data (images, audio, text, etc) that can be accessed by class\n-     * code in a way that is independent of the location of the code.\n-     * The name of a resource is a \"\/\"-separated path name that\n-     * identifies the resource.\n-     *\n-     * @param name The  resource name.\n-     *\n-     * @return An enumeration of URL to the resource. If no resources\n-     * could be found, the enumeration will be empty. Resources that\n-     * cannot be accessed will not be in the enumeration.\n-     *\n-     * @exception IOException if an I\/O exception occurs when\n-     * searching for resources.\n-     *\/\n-    public Enumeration<URL> getResources(String name) throws IOException;\n-\n-    \/**\n-     * Gets the current directory used by the library loader for\n-     * storing native libraries before they are loaded into memory.\n-     *\n-     * @return The current directory used by the library loader.\n-     *\n-     * @see #setLibraryDirectory\n-     *\n-     * @throws UnsupportedOperationException if this implementation\n-     * does not support storing native libraries in this way.\n-     *\/\n-    public String getLibraryDirectory();\n-\n-    \/**\n-     * Sets the directory used by the library loader for storing\n-     * native libraries before they are loaded into memory.\n-     *\n-     * @param libdir The directory used by the library loader.\n-     *\n-     * @see #getLibraryDirectory\n-     *\n-     * @throws UnsupportedOperationException if this implementation\n-     * does not support storing native libraries in this way.\n-     *\/\n-    public void setLibraryDirectory(String libdir);\n-\n- }\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLetMBean.java","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javax.management.loading;\n-\n-\n-\/\/ java import\n-\n-import java.io.*;\n-import java.lang.reflect.Array;\n-\n-\n-\/**\n- * This subclass of ObjectInputStream delegates loading of classes to\n- * an existing MLetClassLoader.\n- *\n- * @since 1.5\n- *\/\n-@Deprecated(since=\"20\", forRemoval=true)\n-class MLetObjectInputStream extends ObjectInputStream {\n-\n-    @SuppressWarnings(\"removal\")\n-    private MLet loader;\n-\n-    \/**\n-     * Loader must be non-null;\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public MLetObjectInputStream(InputStream in, MLet loader)\n-        throws IOException, StreamCorruptedException {\n-\n-        super(in);\n-        if (loader == null) {\n-            throw new IllegalArgumentException(\"Illegal null argument to MLetObjectInputStream\");\n-        }\n-        this.loader = loader;\n-    }\n-\n-    private Class<?> primitiveType(char c) {\n-        switch(c) {\n-        case 'B':\n-            return Byte.TYPE;\n-\n-        case 'C':\n-            return Character.TYPE;\n-\n-        case 'D':\n-            return Double.TYPE;\n-\n-        case 'F':\n-            return Float.TYPE;\n-\n-        case 'I':\n-            return Integer.TYPE;\n-\n-        case 'J':\n-            return Long.TYPE;\n-\n-        case 'S':\n-            return Short.TYPE;\n-\n-        case 'Z':\n-            return Boolean.TYPE;\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Use the given ClassLoader rather than using the system class\n-     *\/\n-    @Override\n-    protected Class<?> resolveClass(ObjectStreamClass objectstreamclass)\n-        throws IOException, ClassNotFoundException {\n-\n-        String s = objectstreamclass.getName();\n-        if (s.startsWith(\"[\")) {\n-            int i;\n-            for (i = 1; s.charAt(i) == '['; i++);\n-            Class<?> class1;\n-            if (s.charAt(i) == 'L') {\n-                class1 = loader.loadClass(s.substring(i + 1, s.length() - 1));\n-            } else {\n-                if (s.length() != i + 1)\n-                    throw new ClassNotFoundException(s);\n-                class1 = primitiveType(s.charAt(i));\n-            }\n-            int ai[] = new int[i];\n-            for (int j = 0; j < i; j++)\n-                ai[j] = 0;\n-\n-            return Array.newInstance(class1, ai).getClass();\n-        } else {\n-            return loader.loadClass(s);\n-        }\n-    }\n-\n-    \/**\n-     * Returns the ClassLoader being used\n-     *\/\n-    public ClassLoader getClassLoader() {\n-        return loader;\n-    }\n-}\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLetObjectInputStream.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -1,279 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javax.management.loading;\n-\n-import static com.sun.jmx.defaults.JmxProperties.MLET_LOGGER;\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.lang.System.Logger.Level;\n-\n-\/**\n- * This class is used for parsing URLs.\n- *\n- * @since 1.5\n- *\/\n-@Deprecated(since=\"20\", forRemoval=true)\n-class MLetParser {\n-\n-\/*\n-  * ------------------------------------------\n-  *   PRIVATE VARIABLES\n-  * ------------------------------------------\n-  *\/\n-\n-    \/**\n-     * The current character\n-     *\/\n-    private int c;\n-\n-    \/**\n-     * Tag to parse.\n-     *\/\n-    private static String tag = \"mlet\";\n-\n-\n-  \/*\n-  * ------------------------------------------\n-  *   CONSTRUCTORS\n-  * ------------------------------------------\n-  *\/\n-\n-    \/**\n-     * Create an MLet parser object\n-     *\/\n-    public MLetParser() {\n-    }\n-\n-    \/*\n-     * ------------------------------------------\n-     *   PUBLIC METHODS\n-     * ------------------------------------------\n-     *\/\n-\n-    \/**\n-     * Scan spaces.\n-     *\/\n-    public void skipSpace(Reader in) throws IOException {\n-        while ((c >= 0) && ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'))) {\n-            c = in.read();\n-        }\n-    }\n-\n-    \/**\n-     * Scan identifier\n-     *\/\n-    public String scanIdentifier(Reader in) throws IOException {\n-        StringBuilder buf = new StringBuilder();\n-        while (true) {\n-            if (((c >= 'a') && (c <= 'z')) ||\n-                ((c >= 'A') && (c <= 'Z')) ||\n-                ((c >= '0') && (c <= '9')) || (c == '_')) {\n-                buf.append((char)c);\n-                c = in.read();\n-            } else {\n-                return buf.toString();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Scan tag\n-     *\/\n-    public Map<String,String> scanTag(Reader in) throws IOException {\n-        Map<String,String> atts = new HashMap<>();\n-        skipSpace(in);\n-        while (c >= 0 && c != '>') {\n-            if (c == '<')\n-                throw new IOException(\"Missing '>' in tag\");\n-            String att = scanIdentifier(in);\n-            String val = \"\";\n-            skipSpace(in);\n-            if (c == '=') {\n-                int quote = -1;\n-                c = in.read();\n-                skipSpace(in);\n-                if ((c == '\\'') || (c == '\\\"')) {\n-                    quote = c;\n-                    c = in.read();\n-                }\n-                StringBuilder buf = new StringBuilder();\n-                while ((c > 0) &&\n-                       (((quote < 0) && (c != ' ') && (c != '\\t') &&\n-                         (c != '\\n') && (c != '\\r') && (c != '>'))\n-                        || ((quote >= 0) && (c != quote)))) {\n-                    buf.append((char)c);\n-                    c = in.read();\n-                }\n-                if (c == quote) {\n-                    c = in.read();\n-                }\n-                skipSpace(in);\n-                val = buf.toString();\n-            }\n-            atts.put(att.toLowerCase(Locale.ENGLISH), val);\n-            skipSpace(in);\n-        }\n-        return atts;\n-    }\n-\n-    \/**\n-     * Scan an html file for {@literal <mlet>} tags.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public List<MLetContent> parse(URL url) throws IOException {\n-        \/\/ Warning Messages\n-        String requiresTypeWarning = \"<arg type=... value=...> tag requires type parameter.\";\n-        String requiresValueWarning = \"<arg type=... value=...> tag requires value parameter.\";\n-        String paramOutsideWarning = \"<arg> tag outside <mlet> ... <\/mlet>.\";\n-        String requiresCodeWarning = \"<mlet> tag requires either code or object parameter.\";\n-        String requiresJarsWarning = \"<mlet> tag requires archive parameter.\";\n-\n-        URLConnection conn;\n-\n-        conn = url.openConnection();\n-        Reader in = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n-                                                             UTF_8));\n-\n-        \/\/ The original URL may have been redirected - this\n-        \/\/ sets it to whatever URL\/codebase we ended up getting\n-        \/\/\n-        url = conn.getURL();\n-\n-        List<MLetContent> mlets = new ArrayList<>();\n-        Map<String,String> atts = null;\n-\n-        List<String> types = new ArrayList<>();\n-        List<String> values = new ArrayList<>();\n-\n-        \/\/ debug(\"parse\",\"*** Parsing \" + url );\n-        while(true) {\n-            c = in.read();\n-            if (c == -1)\n-                break;\n-            if (c == '<') {\n-                c = in.read();\n-                if (c == '\/') {\n-                    c = in.read();\n-                    String nm = scanIdentifier(in);\n-                    if (c != '>')\n-                        throw new IOException(\"Missing '>' in tag\");\n-                    if (nm.equalsIgnoreCase(tag)) {\n-                        if (atts != null) {\n-                            mlets.add(new MLetContent(url, atts, types, values));\n-                        }\n-                        atts = null;\n-                        types = new ArrayList<>();\n-                        values = new ArrayList<>();\n-                    }\n-                } else {\n-                    String nm = scanIdentifier(in);\n-                    if (nm.equalsIgnoreCase(\"arg\")) {\n-                        Map<String,String> t = scanTag(in);\n-                        String att = t.get(\"type\");\n-                        if (att == null) {\n-                            MLET_LOGGER.log(Level.TRACE, requiresTypeWarning);\n-                            throw new IOException(requiresTypeWarning);\n-                        } else {\n-                            if (atts != null) {\n-                                types.add(att);\n-                            } else {\n-                                MLET_LOGGER.log(Level.TRACE, paramOutsideWarning);\n-                                throw new IOException(paramOutsideWarning);\n-                            }\n-                        }\n-                        String val = t.get(\"value\");\n-                        if (val == null) {\n-                            MLET_LOGGER.log(Level.TRACE, requiresValueWarning);\n-                            throw new IOException(requiresValueWarning);\n-                        } else {\n-                            if (atts != null) {\n-                                values.add(val);\n-                            } else {\n-                                MLET_LOGGER.log(Level.TRACE, paramOutsideWarning);\n-                                throw new IOException(paramOutsideWarning);\n-                            }\n-                        }\n-                    } else {\n-                        if (nm.equalsIgnoreCase(tag)) {\n-                            atts = scanTag(in);\n-                            if (atts.get(\"code\") == null && atts.get(\"object\") == null) {\n-                                MLET_LOGGER.log(Level.TRACE, requiresCodeWarning);\n-                                throw new IOException(requiresCodeWarning);\n-                            }\n-                            if (atts.get(\"archive\") == null) {\n-                                MLET_LOGGER.log(Level.TRACE, requiresJarsWarning);\n-                                throw new IOException(requiresJarsWarning);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        in.close();\n-        return mlets;\n-    }\n-\n-    \/**\n-     * Parse the document pointed by the URL urlname\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public List<MLetContent> parseURL(String urlname) throws IOException {\n-        \/\/ Parse the document\n-        \/\/\n-        URL url;\n-        if (urlname.indexOf(':') <= 1) {\n-            String userDir = System.getProperty(\"user.dir\");\n-            String prot;\n-            if (userDir.charAt(0) == '\/' ||\n-                userDir.charAt(0) == File.separatorChar) {\n-                prot = \"file:\";\n-            } else {\n-                prot = \"file:\/\";\n-            }\n-            url =\n-                new URL(prot + userDir.replace(File.separatorChar, '\/') + \"\/\");\n-            url = new URL(url, urlname);\n-        } else {\n-            url = new URL(urlname);\n-        }\n-        \/\/ Return list of parsed MLets\n-        \/\/\n-        return parse(url);\n-    }\n-\n-}\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLetParser.java","additions":0,"deletions":279,"binary":false,"changes":279,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javax.management.loading;\n-\n-import java.net.URL;\n-import java.net.URLStreamHandlerFactory;\n-\n-\/**\n- * An MLet that is not added to the {@link ClassLoaderRepository}.\n- * This class acts exactly like its parent class, {@link MLet}, with\n- * one exception.  When a PrivateMLet is registered in an MBean\n- * server, it is not added to that MBean server's {@link\n- * ClassLoaderRepository}.  This is true because this class implements\n- * the interface {@link PrivateClassLoader}.\n- *\n- * @deprecated This API is part of Management Applets (m-lets), which is a legacy feature that allows loading\n- * of remote MBeans. This feature is not usable without a Security Manager, which is deprecated and subject to\n- * removal in a future release. Consequently, this API is also deprecated and subject to removal. There is no replacement.\n- *\n- * @since 1.5\n- *\/\n-@Deprecated(since=\"20\", forRemoval=true)\n-@SuppressWarnings({\"serial\", \"removal\"}) \/\/ Externalizable class w\/o no-arg c'tor\n-public class PrivateMLet extends MLet implements PrivateClassLoader {\n-    private static final long serialVersionUID = 2503458973393711979L;\n-\n-    \/**\n-      * Constructs a new PrivateMLet for the specified URLs using the\n-      * default delegation parent ClassLoader.  The URLs will be\n-      * searched in the order specified for classes and resources\n-      * after first searching in the parent class loader.\n-      *\n-      * @param  urls  The URLs from which to load classes and resources.\n-      * @param  delegateToCLR  True if, when a class is not found in\n-      * either the parent ClassLoader or the URLs, the MLet should delegate\n-      * to its containing MBeanServer's {@link ClassLoaderRepository}.\n-      *\n-      *\/\n-    public PrivateMLet(URL[] urls, boolean delegateToCLR) {\n-        super(urls, delegateToCLR);\n-    }\n-\n-    \/**\n-      * Constructs a new PrivateMLet for the given URLs. The URLs will\n-      * be searched in the order specified for classes and resources\n-      * after first searching in the specified parent class loader.\n-      * The parent argument will be used as the parent class loader\n-      * for delegation.\n-      *\n-      * @param  urls  The URLs from which to load classes and resources.\n-      * @param  parent The parent class loader for delegation.\n-      * @param  delegateToCLR  True if, when a class is not found in\n-      * either the parent ClassLoader or the URLs, the MLet should delegate\n-      * to its containing MBeanServer's {@link ClassLoaderRepository}.\n-      *\n-      *\/\n-    public PrivateMLet(URL[] urls, ClassLoader parent, boolean delegateToCLR) {\n-        super(urls, parent, delegateToCLR);\n-    }\n-\n-    \/**\n-      * Constructs a new PrivateMLet for the specified URLs, parent\n-      * class loader, and URLStreamHandlerFactory. The parent argument\n-      * will be used as the parent class loader for delegation. The\n-      * factory argument will be used as the stream handler factory to\n-      * obtain protocol handlers when creating new URLs.\n-      *\n-      * @param  urls  The URLs from which to load classes and resources.\n-      * @param  parent The parent class loader for delegation.\n-      * @param  factory  The URLStreamHandlerFactory to use when creating URLs.\n-      * @param  delegateToCLR  True if, when a class is not found in\n-      * either the parent ClassLoader or the URLs, the MLet should delegate\n-      * to its containing MBeanServer's {@link ClassLoaderRepository}.\n-      *\n-      *\/\n-    public PrivateMLet(URL[] urls,\n-                       ClassLoader parent,\n-                       URLStreamHandlerFactory factory,\n-                       boolean delegateToCLR) {\n-        super(urls, parent, factory, delegateToCLR);\n-    }\n-}\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/PrivateMLet.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -5,1 +5,1 @@\n-Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,9 +42,1 @@\n-\tObject[], String[])}.  The {@link\n-\tjavax.management.loading.MLet MLet} class is an example of\n-\tsuch an MBean.  It is a {@link java.net.URLClassLoader\n-\tURLClassLoader}, so the list of URLs to load classes from can\n-\tbe configured.<\/p>\n-\n-      <p>Additionally, an <code>MLet<\/code> can read a configuration\n-\tfile that specifies a set of MBeans to be registered in the same\n-\tMBean Server as the <code>MLet<\/code>.<\/p>\n+\tObject[], String[])}.<\/p>\n@@ -58,3 +50,1 @@\n-\tinterface that do not have an explicit loader parameter.  It\n-\tis also used by the <code>MLet<\/code> class when it does not\n-\tfind a class in its own set of URLs.<\/p>\n+\tinterface that do not have an explicit loader parameter.<\/p>\n@@ -64,4 +54,1 @@\n-\tthen it is not added to the class loader repository.  The class\n-\t{@link javax.management.loading.PrivateMLet PrivateMLet} is a\n-\tsubclass of <code>MLet<\/code> that implements\n-\t<code>PrivateClassLoader<\/code>.<\/p>\n+\tthen it is not added to the class loader repository.<\/p>\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/package.html","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-            return inBuf[0];\n+            return inBuf[0] & 0xff;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/sasl\/SaslInputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n- * @LastModified: Nov 2023\n+ * @LastModified: Jan 2024\n@@ -1041,2 +1041,3 @@\n-        if ((publicId != null || literalSystemId != null) &&\n-                staxInputSource == null && (fUseCatalog && fCatalogFile != null)) {\n+        if (staxInputSource == null\n+                && (publicId != null || literalSystemId != null)\n+                && (fUseCatalog && fCatalogFile != null)) {\n@@ -1052,2 +1053,3 @@\n-        if ((publicId != null || literalSystemId != null) &&\n-                staxInputSource == null && JdkXmlUtils.isResolveContinue(fCatalogFeatures)) {\n+        if (staxInputSource == null\n+                && (publicId != null || literalSystemId != null)\n+                && JdkXmlUtils.isResolveContinue(fCatalogFeatures)) {\n@@ -1064,3 +1066,3 @@\n-        } else if ((publicId == null && literalSystemId == null) ||\n-                (JdkXmlUtils.isResolveContinue(fCatalogFeatures) &&\n-                fSecurityManager.is(Limit.JDKCATALOG_RESOLVE, JdkConstants.CONTINUE))) {\n+        } else if ((publicId == null && literalSystemId == null)\n+                || (JdkXmlUtils.isResolveContinue(fCatalogFeatures)\n+                && fSecurityManager.is(Limit.JDKCATALOG_RESOLVE, JdkConstants.CONTINUE))) {\n@@ -1209,2 +1211,3 @@\n-        if ((publicId != null || literalSystemId != null || resourceIdentifier.getNamespace() !=null)\n-                && xmlInputSource == null && (fUseCatalog && fCatalogFile != null)) {\n+        if (xmlInputSource == null\n+                && (publicId != null || literalSystemId != null || resourceIdentifier.getNamespace() !=null)\n+                && (fUseCatalog && fCatalogFile != null)) {\n@@ -1220,2 +1223,3 @@\n-        if ((publicId != null || literalSystemId != null)\n-                && xmlInputSource == null && JdkXmlUtils.isResolveContinue(fCatalogFeatures)) {\n+        if (xmlInputSource == null\n+                && (publicId != null || literalSystemId != null)\n+                && JdkXmlUtils.isResolveContinue(fCatalogFeatures)) {\n@@ -1229,5 +1233,7 @@\n-        \/\/ Note if both publicId and systemId are null, the resolution process continues as usual\n-        if ((publicId == null && literalSystemId == null) ||\n-                ((xmlInputSource == null) && JdkXmlUtils.isResolveContinue(fCatalogFeatures) &&\n-                fSecurityManager.is(Limit.JDKCATALOG_RESOLVE, JdkConstants.CONTINUE))) {\n-            xmlInputSource = new XMLInputSource(publicId, literalSystemId, baseSystemId, false);\n+        if (xmlInputSource == null) {\n+            \/\/ Note if both publicId and systemId are null, the resolution process continues as usual\n+            if ((publicId == null && literalSystemId == null) ||\n+                    (JdkXmlUtils.isResolveContinue(fCatalogFeatures) &&\n+                    fSecurityManager.is(Limit.JDKCATALOG_RESOLVE, JdkConstants.CONTINUE))) {\n+                xmlInputSource = new XMLInputSource(publicId, literalSystemId, baseSystemId, false);\n+            }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLEntityManager.java","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.Arrays;\n@@ -64,0 +65,3 @@\n+    private static final int ERROR_INVALID_PARAMETER = 0x57;\n+    private static final int NTE_INVALID_PARAMETER = 0x80090027;\n+\n@@ -104,0 +108,2 @@\n+    private boolean forTlsPremasterSecret = false;\n+\n@@ -174,0 +180,3 @@\n+            this.forTlsPremasterSecret = true;\n+        } else {\n+            this.forTlsPremasterSecret = false;\n@@ -281,2 +290,1 @@\n-    private byte[] doFinal() throws BadPaddingException,\n-            IllegalBlockSizeException {\n+    private byte[] doFinal() throws IllegalBlockSizeException {\n@@ -311,1 +319,1 @@\n-        } catch (KeyException e) {\n+        } catch (KeyException | BadPaddingException e) {\n@@ -334,1 +342,1 @@\n-            throws BadPaddingException, IllegalBlockSizeException {\n+            throws IllegalBlockSizeException {\n@@ -341,1 +349,1 @@\n-            int outOfs) throws ShortBufferException, BadPaddingException,\n+            int outOfs) throws ShortBufferException,\n@@ -357,0 +365,1 @@\n+\n@@ -365,6 +374,1 @@\n-        try {\n-            return doFinal();\n-        } catch (BadPaddingException e) {\n-            \/\/ should not occur\n-            throw new InvalidKeyException(\"Wrapping failed\", e);\n-        }\n+        return doFinal();\n@@ -391,6 +395,0 @@\n-        } catch (BadPaddingException e) {\n-            if (isTlsRsaPremasterSecret) {\n-                failover = e;\n-            } else {\n-                throw new InvalidKeyException(\"Unwrapping failed\", e);\n-            }\n@@ -402,4 +400,12 @@\n-        if (isTlsRsaPremasterSecret) {\n-            if (!(spec instanceof TlsRsaPremasterSecretParameterSpec)) {\n-                throw new IllegalStateException(\n-                        \"No TlsRsaPremasterSecretParameterSpec specified\");\n+        try {\n+            if (isTlsRsaPremasterSecret) {\n+                if (!forTlsPremasterSecret) {\n+                    throw new IllegalStateException(\n+                            \"No TlsRsaPremasterSecretParameterSpec specified\");\n+                }\n+\n+                \/\/ polish the TLS premaster secret\n+                encoded = KeyUtil.checkTlsPreMasterSecretKey(\n+                        ((TlsRsaPremasterSecretParameterSpec) spec).getClientVersion(),\n+                        ((TlsRsaPremasterSecretParameterSpec) spec).getServerVersion(),\n+                        random, encoded, encoded == null);\n@@ -408,5 +414,5 @@\n-            \/\/ polish the TLS premaster secret\n-            encoded = KeyUtil.checkTlsPreMasterSecretKey(\n-                ((TlsRsaPremasterSecretParameterSpec)spec).getClientVersion(),\n-                ((TlsRsaPremasterSecretParameterSpec)spec).getServerVersion(),\n-                random, encoded, (failover != null));\n+            return constructKey(encoded, algorithm, type);\n+        } finally {\n+            if (encoded != null) {\n+                Arrays.fill(encoded, (byte) 0);\n+            }\n@@ -414,2 +420,0 @@\n-\n-        return constructKey(encoded, algorithm, type);\n@@ -499,2 +503,4 @@\n-    private static byte[] encryptDecrypt(byte[] data, int dataSize,\n-            CKey key, boolean doEncrypt) throws KeyException {\n+    private byte[] encryptDecrypt(byte[] data, int dataSize,\n+            CKey key, boolean doEncrypt) throws KeyException, BadPaddingException {\n+        int[] returnStatus = new int[1];\n+        byte[] result;\n@@ -502,1 +508,1 @@\n-            return encryptDecrypt(data, dataSize, key.getHCryptKey(), doEncrypt);\n+            result = encryptDecrypt(returnStatus, data, dataSize, key.getHCryptKey(), doEncrypt);\n@@ -504,1 +510,1 @@\n-            return cngEncryptDecrypt(data, dataSize, key.getHCryptProvider(), doEncrypt);\n+            result = cngEncryptDecrypt(returnStatus, data, dataSize, key.getHCryptProvider(), doEncrypt);\n@@ -506,0 +512,11 @@\n+        if ((returnStatus[0] == ERROR_INVALID_PARAMETER) || (returnStatus[0] == NTE_INVALID_PARAMETER)) {\n+            if (forTlsPremasterSecret) {\n+                result = null;\n+            } else {\n+                throw new BadPaddingException(\"Error \" + returnStatus[0] + \" returned by MSCAPI\");\n+            }\n+        } else if (returnStatus[0] != 0) {\n+            throw new KeyException(\"Error \" + returnStatus[0] + \" returned by MSCAPI\");\n+        }\n+\n+        return result;\n@@ -508,1 +525,1 @@\n-    private static native byte[] encryptDecrypt(byte[] data, int dataSize,\n+    private static native byte[] encryptDecrypt(int[] returnStatus, byte[] data, int dataSize,\n@@ -510,1 +527,1 @@\n-    private static native byte[] cngEncryptDecrypt(byte[] data, int dataSize,\n+    private static native byte[] cngEncryptDecrypt(int[] returnStatus, byte[] data, int dataSize,\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CRSACipher.java","additions":52,"deletions":35,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1908,1 +1908,1 @@\n- * Signature: ([BIJZ)[B\n+ * Signature: ([I[BIJZ)[B\n@@ -1911,1 +1911,1 @@\n-  (JNIEnv *env, jclass clazz, jbyteArray jData, jint jDataSize, jlong hKey,\n+  (JNIEnv *env, jclass clazz, jintArray jResultStatus, jbyteArray jData, jint jDataSize, jlong hKey,\n@@ -1916,0 +1916,1 @@\n+    jbyte* resultData = NULL;\n@@ -1920,0 +1921,6 @@\n+    BOOL success;\n+    DWORD ss = ERROR_SUCCESS;\n+    DWORD lastError = ERROR_SUCCESS;\n+    DWORD resultLen = 0;\n+    DWORD pmsLen = 48;\n+    jbyte pmsArr[48] = {0};\n@@ -1946,0 +1953,2 @@\n+            resultData = pData;\n+            resultLen = dwBufLen;\n@@ -1955,5 +1964,11 @@\n-            if (! ::CryptDecrypt((HCRYPTKEY) hKey, 0, TRUE, 0, (BYTE *)pData, \/\/deprecated\n-                &dwBufLen)) {\n-\n-                ThrowException(env, KEY_EXCEPTION, GetLastError());\n-                __leave;\n+            success = ::CryptDecrypt((HCRYPTKEY) hKey, 0, TRUE, 0, (BYTE *)pData, \/\/deprecated\n+                &dwBufLen);\n+            lastError = GetLastError();\n+            if (success) {\n+                ss = ERROR_SUCCESS;\n+                resultData = pData;\n+                resultLen = dwBufLen;\n+            } else {\n+                ss = lastError;\n+                resultData = pmsArr;\n+                resultLen = pmsLen;\n@@ -1961,0 +1976,1 @@\n+            env->SetIntArrayRegion(jResultStatus, 0, 1, (jint*) &ss);\n@@ -1963,2 +1979,2 @@\n-        \/\/ Create new byte array\n-        if ((result = env->NewByteArray(dwBufLen)) == NULL) {\n+            \/\/ Create new byte array\n+        if ((result = env->NewByteArray(resultLen)) == NULL) {\n@@ -1969,1 +1985,1 @@\n-        env->SetByteArrayRegion(result, 0, dwBufLen, (jbyte*) pData);\n+        env->SetByteArrayRegion(result, 0, resultLen, (jbyte*) resultData);\n@@ -1983,1 +1999,1 @@\n- * Signature: ([BIJZ)[B\n+ * Signature: ([I[BIJZ)[B\n@@ -1986,1 +2002,1 @@\n-  (JNIEnv *env, jclass clazz, jbyteArray jData, jint jDataSize, jlong hKey,\n+  (JNIEnv *env, jclass clazz, jintArray jResultStatus, jbyteArray jData, jint jDataSize, jlong hKey,\n@@ -1992,0 +2008,1 @@\n+    jbyte* resultData = NULL;\n@@ -1994,0 +2011,4 @@\n+    DWORD resultLen = 0;\n+    DWORD pmsLen = 48;\n+    jbyte pmsArr[48] = {0};\n+\n@@ -2013,0 +2034,3 @@\n+            } else {\n+                resultLen = dwBufLen;\n+                resultData = pData;\n@@ -2021,3 +2045,7 @@\n-            if (ss != ERROR_SUCCESS) {\n-                ThrowException(env, KEY_EXCEPTION, ss);\n-                __leave;\n+            env->SetIntArrayRegion(jResultStatus, 0, 1, (jint*) &ss);\n+            if (ss == ERROR_SUCCESS) {\n+                resultLen = dwBufLen;\n+                resultData = pData;\n+            } else {\n+                resultLen = pmsLen;\n+                resultData = pmsArr;\n@@ -2025,1 +2053,1 @@\n-        }\n+       }\n@@ -2027,1 +2055,1 @@\n-        if ((result = env->NewByteArray(dwBufLen)) == NULL) {\n+        if ((result = env->NewByteArray(resultLen)) == NULL) {\n@@ -2032,1 +2060,1 @@\n-        env->SetByteArrayRegion(result, 0, dwBufLen, (jbyte*) pData);\n+        env->SetByteArrayRegion(result, 0, resultLen, (jbyte*) resultData);\n","filename":"src\/jdk.crypto.mscapi\/windows\/native\/libsunmscapi\/security.cpp","additions":46,"deletions":18,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import sun.jvm.hotspot.gc.serial.*;\n@@ -1079,2 +1080,2 @@\n-                        if (collHeap instanceof GenCollectedHeap) {\n-                          GenCollectedHeap heap = (GenCollectedHeap) collHeap;\n+                        if (collHeap instanceof SerialHeap) {\n+                          SerialHeap heap = (SerialHeap) collHeap;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2017, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -27,3 +27,1 @@\n-import sun.jvm.hotspot.debugger.Address;\n-import sun.jvm.hotspot.gc.shared.GenCollectedHeap;\n-import sun.jvm.hotspot.gc.shared.CollectedHeapName;\n+import java.io.*;\n@@ -31,1 +29,7 @@\n-public class SerialHeap extends GenCollectedHeap {\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.gc.shared.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.*;\n+\n+public class SerialHeap extends CollectedHeap {\n@@ -40,0 +44,87 @@\n+\n+  private static AddressField youngGenField;\n+  private static AddressField oldGenField;\n+\n+  private static GenerationFactory genFactory;\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) {\n+    Type type = db.lookupType(\"SerialHeap\");\n+\n+    youngGenField = type.getAddressField(\"_young_gen\");\n+    oldGenField = type.getAddressField(\"_old_gen\");\n+\n+    genFactory = new GenerationFactory();\n+  }\n+\n+  public int nGens() {\n+    return 2; \/\/ Young + Old\n+  }\n+\n+  public Generation getGen(int i) {\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that((i == 0) || (i == 1), \"Index \" + i +\n+                  \" out of range (should be 0 or 1)\");\n+    }\n+\n+    switch (i) {\n+    case 0:\n+      return genFactory.newObject(youngGenField.getValue(addr));\n+    case 1:\n+      return genFactory.newObject(oldGenField.getValue(addr));\n+    default:\n+      \/\/ no generation for i, and assertions disabled.\n+      return null;\n+    }\n+  }\n+\n+  public boolean isIn(Address a) {\n+    for (int i = 0; i < nGens(); i++) {\n+      Generation gen = getGen(i);\n+      if (gen.isIn(a)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  public long capacity() {\n+    long capacity = 0;\n+    for (int i = 0; i < nGens(); i++) {\n+      capacity += getGen(i).capacity();\n+    }\n+    return capacity;\n+  }\n+\n+  public long used() {\n+    long used = 0;\n+    for (int i = 0; i < nGens(); i++) {\n+      used += getGen(i).used();\n+    }\n+    return used;\n+  }\n+\n+  public void liveRegionsIterate(LiveRegionsClosure closure) {\n+    \/\/ Run through all generations, obtaining bottom-top pairs.\n+    for (int i = 0; i < nGens(); i++) {\n+      Generation gen = getGen(i);\n+      gen.liveRegionsIterate(closure);\n+    }\n+  }\n+\n+  public void printOn(PrintStream tty) {\n+    for (int i = 0; i < nGens(); i++) {\n+      tty.print(\"Gen \" + i + \": \");\n+      getGen(i).printOn(tty);\n+      tty.println(\"Invocations: \" + getGen(i).invocations());\n+      tty.println();\n+    }\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/SerialHeap.java","additions":96,"deletions":5,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.shared;\n-\n-import java.io.*;\n-import java.util.*;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.gc.shared.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public abstract class GenCollectedHeap extends CollectedHeap {\n-  private static AddressField youngGenField;\n-  private static AddressField oldGenField;\n-\n-  private static GenerationFactory genFactory;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"GenCollectedHeap\");\n-\n-    youngGenField = type.getAddressField(\"_young_gen\");\n-    oldGenField = type.getAddressField(\"_old_gen\");\n-\n-    genFactory = new GenerationFactory();\n-  }\n-\n-  public GenCollectedHeap(Address addr) {\n-    super(addr);\n-  }\n-\n-  public int nGens() {\n-    return 2; \/\/ Young + Old\n-  }\n-\n-  public Generation getGen(int i) {\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that((i == 0) || (i == 1), \"Index \" + i +\n-                  \" out of range (should be 0 or 1)\");\n-    }\n-\n-    switch (i) {\n-    case 0:\n-      return genFactory.newObject(youngGenField.getValue(addr));\n-    case 1:\n-      return genFactory.newObject(oldGenField.getValue(addr));\n-    default:\n-      \/\/ no generation for i, and assertions disabled.\n-      return null;\n-    }\n-  }\n-\n-  public boolean isIn(Address a) {\n-    for (int i = 0; i < nGens(); i++) {\n-      Generation gen = getGen(i);\n-      if (gen.isIn(a)) {\n-        return true;\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n-  public long capacity() {\n-    long capacity = 0;\n-    for (int i = 0; i < nGens(); i++) {\n-      capacity += getGen(i).capacity();\n-    }\n-    return capacity;\n-  }\n-\n-  public long used() {\n-    long used = 0;\n-    for (int i = 0; i < nGens(); i++) {\n-      used += getGen(i).used();\n-    }\n-    return used;\n-  }\n-\n-  public void liveRegionsIterate(LiveRegionsClosure closure) {\n-    \/\/ Run through all generations, obtaining bottom-top pairs.\n-    for (int i = 0; i < nGens(); i++) {\n-      Generation gen = getGen(i);\n-      gen.liveRegionsIterate(closure);\n-    }\n-  }\n-\n-  public void printOn(PrintStream tty) {\n-    for (int i = 0; i < nGens(); i++) {\n-      tty.print(\"Gen \" + i + \": \");\n-      getGen(i).printOn(tty);\n-      tty.println(\"Invocations: \" + getGen(i).invocations());\n-      tty.println();\n-    }\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/GenCollectedHeap.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,4 +96,4 @@\n-      if (heap instanceof GenCollectedHeap) {\n-         GenCollectedHeap genHeap = (GenCollectedHeap) heap;\n-         for (int n = 0; n < genHeap.nGens(); n++) {\n-            Generation gen = genHeap.getGen(n);\n+      if (heap instanceof SerialHeap) {\n+         SerialHeap sh = (SerialHeap) heap;\n+         for (int n = 0; n < sh.nGens(); n++) {\n+            Generation gen = sh.getGen(n);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/HeapSummary.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import sun.jvm.hotspot.gc.serial.*;\n@@ -87,3 +88,3 @@\n-    if (heap instanceof GenCollectedHeap) {\n-      GenCollectedHeap genheap = (GenCollectedHeap) heap;\n-      if (genheap.isIn(a)) {\n+    if (heap instanceof SerialHeap) {\n+      SerialHeap sh = (SerialHeap) heap;\n+      if (sh.isIn(a)) {\n@@ -91,2 +92,2 @@\n-        for (int i = 0; i < genheap.nGens(); i++) {\n-          Generation g = genheap.getGen(i);\n+        for (int i = 0; i < sh.nGens(); i++) {\n+          Generation g = sh.getGen(i);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PointerFinder.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import sun.jvm.hotspot.gc.serial.*;\n@@ -114,1 +115,1 @@\n-    return ((gen != null) && (gen.equals(((GenCollectedHeap)heap).getGen(0))));\n+    return ((gen != null) && (gen.equals(((SerialHeap)heap).getGen(0))));\n@@ -118,1 +119,1 @@\n-    return ((gen != null) && (gen.equals(((GenCollectedHeap)heap).getGen(1))));\n+    return ((gen != null) && (gen.equals(((SerialHeap)heap).getGen(1))));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PointerLocation.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -255,0 +255,1 @@\n+doclet.unexpectedRedirect=Unexpected redirection for URL {0} to {1}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -671,2 +671,7 @@\n-            configuration.getReporter().print(Kind.WARNING,\n-                    resources.getText(\"doclet.urlRedirected\", url, conn.getURL()));\n+            if (!getLastPathComponent(conn.getURL()).equals(getLastPathComponent(url))) {\n+                configuration.getReporter().print(Kind.ERROR,\n+                        resources.getText(\"doclet.unexpectedRedirect\", url, conn.getURL()));\n+            } else {\n+                configuration.getReporter().print(Kind.WARNING,\n+                        resources.getText(\"doclet.urlRedirected\", url, conn.getURL()));\n+            }\n@@ -678,0 +683,6 @@\n+    private String getLastPathComponent(URL u) {\n+        var path = u.getPath();\n+        var sep = path.lastIndexOf('\/');\n+        return sep == -1 ? path : path.substring(sep + 1);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Extern.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,1 +309,1 @@\n-     * -see {@link VirtualMachine#canBeModified()}.\n+     * - see {@link VirtualMachine#canBeModified()}.\n@@ -320,1 +320,1 @@\n-     * -see {@link VirtualMachine#canBeModified()}.\n+     * - see {@link VirtualMachine#canBeModified()}.\n@@ -331,1 +331,1 @@\n-     * -see {@link VirtualMachine#canBeModified()}.\n+     * - see {@link VirtualMachine#canBeModified()}.\n@@ -354,1 +354,1 @@\n-     * VirtualMachine#canGetMonitorInfo to determine if the\n+     * {@link VirtualMachine#canGetMonitorInfo} to determine if the\n@@ -375,1 +375,1 @@\n-     * VirtualMachine#canGetMonitorInfo to determine if the\n+     * {@link VirtualMachine#canGetMonitorInfo} to determine if the\n@@ -395,1 +395,1 @@\n-     * VirtualMachine#canGetMonitorInfo to determine if the\n+     * {@link VirtualMachine#canGetMonitorInfo} to determine if the\n@@ -425,1 +425,1 @@\n-     * @return a of List of {@link ObjectReference} objects. If there are\n+     * @return a List of {@link ObjectReference} objects. If there are\n@@ -430,1 +430,1 @@\n-     * {@link VirtualMachine#canGetInstanceInfo() canGetInstanceInfo()}\n+     * {@link VirtualMachine#canGetInstanceInfo()}\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ObjectReference.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,1 +430,1 @@\n-     * -see {@link VirtualMachine#canBeModified()}.\n+     * - see {@link VirtualMachine#canBeModified()}.\n@@ -451,1 +451,1 @@\n-     * -see {@link VirtualMachine#canBeModified()}.\n+     * - see {@link VirtualMachine#canBeModified()}.\n@@ -681,1 +681,2 @@\n-     * see {@link ClassPrepareRequest#addSourceNameFilter}.\n+     * @see ClassPrepareRequest#addSourceNameFilter\n+     *\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/VirtualMachine.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -398,4 +398,1 @@\n-\/*\n- * Input is sockaddr just because all clients have it.\n- *\/\n-static void convertIPv4ToIPv6(const struct sockaddr *addr4, struct in6_addr *addr6) {\n+static void convertIPv4ToIPv6(const struct in_addr *addr4, struct in6_addr *addr6) {\n@@ -404,1 +401,0 @@\n-    struct in_addr *a4 = &(((struct sockaddr_in*)addr4)->sin_addr);\n@@ -409,1 +405,1 @@\n-    memcpy(&(addr6->s6_addr[12]), &(a4->s_addr), 4);\n+    memcpy(&(addr6->s6_addr[12]), &(addr4->s_addr), 4);\n@@ -418,22 +414,3 @@\n-    struct addrinfo hints;\n-    struct addrinfo *addrInfo = NULL;\n-    jdwpTransportError err;\n-\n-    \/*\n-     * To parse both IPv4 and IPv6 need to specify AF_UNSPEC family\n-     * (with AF_INET6 IPv4 addresses are not parsed even with AI_V4MAPPED and AI_ALL flags).\n-     *\/\n-    memset (&hints, 0, sizeof(hints));\n-    hints.ai_family = AF_UNSPEC;            \/\/ IPv6 or mapped IPv4\n-    hints.ai_socktype = SOCK_STREAM;\n-    hints.ai_protocol = IPPROTO_TCP;\n-    hints.ai_flags = AI_NUMERICHOST;        \/\/ only numeric addresses, no resolution\n-\n-    err = getAddrInfo(buffer, strlen(buffer), NULL, &hints, &addrInfo);\n-\n-    if (err != JDWPTRANSPORT_ERROR_NONE) {\n-        return err;\n-    }\n-\n-    if (addrInfo->ai_family == AF_INET6) {\n-        memcpy(result, &(((struct sockaddr_in6 *)(addrInfo->ai_addr))->sin6_addr), sizeof(*result));\n+    struct in_addr addr;\n+    struct in6_addr addr6;\n+    if (inet_pton(AF_INET6, buffer, &addr6) == 1) {\n@@ -441,4 +418,3 @@\n-    } else {    \/\/ IPv4 address - convert to mapped IPv6\n-        struct in6_addr addr6;\n-        convertIPv4ToIPv6(addrInfo->ai_addr, &addr6);\n-        memcpy(result, &addr6, sizeof(*result));\n+    } else if (inet_pton(AF_INET, buffer, &addr) == 1) {\n+        \/\/ IPv4 address - convert to mapped IPv6\n+        convertIPv4ToIPv6(&addr, &addr6);\n@@ -446,0 +422,2 @@\n+    } else {\n+        return JDWPTRANSPORT_ERROR_IO_ERROR;\n@@ -448,1 +426,1 @@\n-    dbgsysFreeAddrInfo(addrInfo);\n+    memcpy(result, &addr6, sizeof(*result));\n@@ -606,1 +584,2 @@\n-        convertIPv4ToIPv6((struct sockaddr *)peer, &tmp);\n+        struct in_addr *addr4 = &(((struct sockaddr_in*)peer)->sin_addr);\n+        convertIPv4ToIPv6(addr4, &tmp);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libdt_socket\/socketTransport.c","additions":13,"deletions":34,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n@@ -79,1 +81,1 @@\n-    private SafePath dumpOnExitDirectory = new SafePath(\".\");\n+    private SafePath dumpDirectory;\n@@ -92,1 +94,1 @@\n-    private AccessControlContext noDestinationDumpOnExitAccessControlContext;\n+    private final AccessControlContext dumpDirectoryControlContext;\n@@ -102,1 +104,1 @@\n-        \/\/ but if no destination is set and dumpOnExit=true\n+        \/\/ but if no destination is set and the filename is auto-generated,\n@@ -106,1 +108,1 @@\n-        this.noDestinationDumpOnExitAccessControlContext = AccessController.getContext();\n+        this.dumpDirectoryControlContext = AccessController.getContext();\n@@ -177,1 +179,3 @@\n-\n+        if (dest == null && dumpDirectory != null) {\n+            dest = makeDumpPath();\n+        }\n@@ -194,0 +198,27 @@\n+    @SuppressWarnings(\"removal\")\n+    public WriteableUserPath makeDumpPath() {\n+        try {\n+            String name = JVMSupport.makeFilename(getRecording());\n+            return AccessController.doPrivileged(new PrivilegedExceptionAction<WriteableUserPath>() {\n+                @Override\n+                public WriteableUserPath run() throws Exception {\n+                    SafePath p = dumpDirectory;\n+                    if (p == null) {\n+                        p = new SafePath(\".\");\n+                    }\n+                    return new WriteableUserPath(p.toPath().resolve(name));\n+                }\n+            }, dumpDirectoryControlContext);\n+        } catch (PrivilegedActionException e) {\n+            Throwable t = e.getCause();\n+            if (t instanceof SecurityException) {\n+                Logger.log(LogTag.JFR, LogLevel.WARN, \"Not allowed to create dump path for recording \" + recording.getId() + \" on exit.\");\n+            }\n+            if (t instanceof IOException) {\n+                Logger.log(LogTag.JFR, LogLevel.WARN, \"Could not dump \" + recording.getId() + \" on exit.\");\n+            }\n+            return null;\n+        }\n+    }\n+\n+\n@@ -700,5 +731,0 @@\n-    @SuppressWarnings(\"removal\")\n-    public AccessControlContext getNoDestinationDumpOnExitAccessControlContext() {\n-        return noDestinationDumpOnExitAccessControlContext;\n-    }\n-\n@@ -831,6 +857,7 @@\n-    public void setDumpOnExitDirectory(SafePath directory) {\n-       this.dumpOnExitDirectory = directory;\n-    }\n-\n-    public SafePath getDumpOnExitDirectory()  {\n-        return this.dumpOnExitDirectory;\n+    \/**\n+     * Sets the dump directory.\n+     * <p>\n+     * Only to be used by DCmdStart.\n+     *\/\n+    public void setDumpDirectory(SafePath directory) {\n+       this.dumpDirectory = directory;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":44,"deletions":17,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-                dest = makeDumpOnExitPath(recording);\n+                dest = recording.makeDumpPath();\n@@ -81,23 +81,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private WriteableUserPath makeDumpOnExitPath(PlatformRecording recording) {\n-        try {\n-            String name = JVMSupport.makeFilename(recording.getRecording());\n-            AccessControlContext acc = recording.getNoDestinationDumpOnExitAccessControlContext();\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<WriteableUserPath>() {\n-                @Override\n-                public WriteableUserPath run() throws Exception {\n-                    return new WriteableUserPath(recording.getDumpOnExitDirectory().toPath().resolve(name));\n-                }\n-            }, acc);\n-        } catch (PrivilegedActionException e) {\n-            Throwable t = e.getCause();\n-            if (t instanceof SecurityException) {\n-                Logger.log(LogTag.JFR, LogLevel.WARN, \"Not allowed to create dump path for recording \" + recording.getId() + \" on exit.\");\n-            }\n-            if (t instanceof IOException) {\n-                Logger.log(LogTag.JFR, LogLevel.WARN, \"Could not dump \" + recording.getId() + \" on exit.\");\n-            }\n-            return null;\n-        }\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ShutdownHook.java","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,3 @@\n-                Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Missing object id=\" + id + \" in pool \" + getName() + \". All ids should reference an object\");\n+                String msg = \"Missing object ID \" + id + \" in pool \" + getName() + \". All IDs should reference an object\";\n+                Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, msg);\n+                assert false : msg;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ConstantMap.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n@@ -168,1 +170,1 @@\n-                if (Files.isDirectory(p) && Boolean.TRUE.equals(dumpOnExit)) {\n+                if (Files.isDirectory(p)) {\n@@ -172,1 +174,2 @@\n-                    PrivateAccess.getInstance().getPlatformRecording(recording).setDumpOnExitDirectory(new SafePath(p));\n+                    PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);\n+                    pr.setDumpDirectory(new SafePath(p));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -451,1 +451,2 @@\n-            String plugin, String pluginConfig, StringTable strings,\n+            String plugin,\n+            StringTable strings,\n@@ -464,4 +465,0 @@\n-        int configOffset = -1;\n-        if (pluginConfig != null) {\n-            configOffset = strings.addString(plugin);\n-        }\n@@ -470,1 +467,1 @@\n-                        nameOffset, configOffset, isTerminal);\n+                        nameOffset, isTerminal);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ResourcePoolManager.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.io.InputStream;\n@@ -309,1 +308,1 @@\n-                byte[] compressed = null;\n+                byte[] compressed;\n@@ -316,1 +315,1 @@\n-                        ByteBuffer.wrap(compressed), getName(), null,\n+                        ByteBuffer.wrap(compressed), getName(),\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/StringSharingPlugin.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-                        ByteBuffer.wrap(compressed), getName(), null,\n+                        ByteBuffer.wrap(compressed), getName(),\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ZipPlugin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,2 @@\n-    systemctl enable --now \"$unit\"\n+    local unit_name=`basename \"$unit\"`\n+    systemctl enable --now \"$unit_name\"\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/services_utils.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-#ifndef _AIX\n-    \/\/ See JDK-8202772: temporarily disabled.\n@@ -80,1 +78,0 @@\n-#endif \/\/ !_AIX\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -510,0 +510,1 @@\n+\n@@ -511,0 +512,1 @@\n+\n@@ -554,2 +556,2 @@\n-  const size_t stripe_len = 4 * M;\n-  const int num_stripes = 4;\n+  const size_t stripe_len = os::vm_allocation_granularity();\n+  const int num_stripes = 6;\n@@ -560,1 +562,0 @@\n-  ASSERT_NE(p, (address)NULL);\n@@ -562,0 +563,1 @@\n+  ASSERT_NE(p, (address)nullptr);\n@@ -563,2 +565,3 @@\n-  \/\/ .. release it...\n-  ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  \/\/ \/\/ make things even more difficult by trying to reserve at the border of the region\n+  address border = p + num_stripes * stripe_len;\n+  address p2 = (address)os::attempt_reserve_memory_at((char*)border, stripe_len);\n@@ -567,4 +570,1 @@\n-  \/\/ re-reserve it. This should work unless release failed.\n-  address p2 = (address)os::attempt_reserve_memory_at((char*)p, total_range_len);\n-  ASSERT_EQ(p2, p);\n-  PRINT_MAPPINGS(\"C\");\n+  ASSERT_TRUE(p2 == nullptr || p2 == border);\n@@ -573,1 +573,6 @@\n-  PRINT_MAPPINGS(\"D\");\n+  PRINT_MAPPINGS(\"C\");\n+\n+  if (p2 != nullptr) {\n+    ASSERT_TRUE(os::release_memory((char*)p2, stripe_len));\n+    PRINT_MAPPINGS(\"D\");\n+  }\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+compiler\/c2\/irTests\/TestDuplicateBackedge.java 8318904 generic-all\n@@ -92,1 +93,0 @@\n-gc\/stress\/TestStressG1Humongous.java 8286554 windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -249,0 +249,1 @@\n+  applications\/ctw\/modules \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8322077\n+ * @summary Test that Ideal transformations on the De Morgan's Law perform\n+            as expected for int.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.DeMorganLawIntTests\n+ *\/\n+public class DeMorganLawIntTests {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\" })\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+        int c = RunInfo.getRandom().nextInt();\n+        int d = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, 0, 0);\n+        assertResult(a, b, c, d);\n+        assertResult(min, min, min, min);\n+        assertResult(max, max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, int c, int d) {\n+        Asserts.assertEQ((~a | ~b) & (~c | ~d), test1(a, b, c, d));\n+        Asserts.assertEQ((~a & ~b) | (~c & ~d), test2(a, b, c, d));\n+        Asserts.assertEQ((~a | ~b) | (~c | ~d), test3(a, b, c, d));\n+        Asserts.assertEQ((~a & ~b) & (~c & ~d), test4(a, b, c, d));\n+    }\n+\n+    \/\/ Checks (~a | ~b) & (~c | ~d)\n+    \/\/     => ~(a & b) & ~(c & d)\n+    \/\/     => ~((a & b) | (c & d))\n+    @Test\n+    @IR(counts = { IRNode.AND , \"2\",\n+                   IRNode.OR , \"1\",\n+                   IRNode.XOR, \"1\", })\n+    public int test1(int a, int b, int c, int d) {\n+        return (~a | ~b) & (~c | ~d);\n+    }\n+\n+    \/\/ Checks (~a & ~b) | (~c & ~d)\n+    \/\/     => ~(a | b) | ~(c | d)\n+    \/\/     => ~((a | b) & (c | d))\n+    @Test\n+    @IR(counts = { IRNode.AND , \"1\",\n+                   IRNode.OR , \"2\",\n+                   IRNode.XOR, \"1\", })\n+    public int test2(int a, int b, int c, int d) {\n+        return (~a & ~b) | (~c & ~d);\n+    }\n+\n+    \/\/ Checks (~a | ~b) | (~c | ~d)\n+    \/\/     => ~(a & b) | ~(c & d)\n+    \/\/     => ~((a & b) & (c & d))\n+    @Test\n+    @IR(failOn = { IRNode.OR })\n+    @IR(counts = { IRNode.AND , \"3\",\n+                   IRNode.XOR, \"1\", })\n+    public int test3(int a, int b, int c, int d) {\n+        return (~a | ~b) | (~c | ~d);\n+    }\n+\n+    \/\/ Checks (~a & ~b) & (~c & ~d)\n+    \/\/     => ~(a | b) & ~(c | d)\n+    \/\/     => ~((a | b) | (c | d))\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    @IR(counts = { IRNode.OR , \"3\",\n+                   IRNode.XOR, \"1\", })\n+    public int test4(int a, int b, int c, int d) {\n+        return (~a & ~b) & (~c & ~d);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DeMorganLawIntTests.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8322077\n+ * @summary Test that Ideal transformations on the De Morgan's Law perform\n+            as expected for long.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.DeMorganLawLongTests\n+ *\/\n+public class DeMorganLawLongTests {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\" })\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+        long c = RunInfo.getRandom().nextLong();\n+        long d = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, 0, 0);\n+        assertResult(a, b, c, d);\n+        assertResult(min, min, min, min);\n+        assertResult(max, max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, long c, long d) {\n+        Asserts.assertEQ((~a | ~b) & (~c | ~d), test1(a, b, c, d));\n+        Asserts.assertEQ((~a & ~b) | (~c & ~d), test2(a, b, c, d));\n+        Asserts.assertEQ((~a | ~b) | (~c | ~d), test3(a, b, c, d));\n+        Asserts.assertEQ((~a & ~b) & (~c & ~d), test4(a, b, c, d));\n+    }\n+\n+    \/\/ Checks (~a | ~b) & (~c | ~d)\n+    \/\/     => ~(a & b) & ~(c & d)\n+    \/\/     => ~((a & b) | (c & d))\n+    @Test\n+    @IR(counts = { IRNode.AND , \"2\",\n+                   IRNode.OR , \"1\",\n+                   IRNode.XOR, \"1\", })\n+    public long test1(long a, long b, long c, long d) {\n+        return (~a | ~b) & (~c | ~d);\n+    }\n+\n+    \/\/ Checks (~a & ~b) | (~c & ~d)\n+    \/\/     => ~(a | b) | ~(c | d)\n+    \/\/     => ~((a | b) & (c | d))\n+    @Test\n+    @IR(counts = { IRNode.AND , \"1\",\n+                   IRNode.OR , \"2\",\n+                   IRNode.XOR, \"1\", })\n+    public long test2(long a, long b, long c, long d) {\n+        return (~a & ~b) | (~c & ~d);\n+    }\n+\n+    \/\/ Checks (~a | ~b) | (~c | ~d)\n+    \/\/     => ~(a & b) | ~(c & d)\n+    \/\/     => ~((a & b) & (c & d))\n+    @Test\n+    @IR(failOn = { IRNode.OR })\n+    @IR(counts = { IRNode.AND , \"3\",\n+                   IRNode.XOR, \"1\", })\n+    public long test3(long a, long b, long c, long d) {\n+        return (~a | ~b) | (~c | ~d);\n+    }\n+\n+    \/\/ Checks (~a & ~b) & (~c & ~d)\n+    \/\/     => ~(a | b) & ~(c | d)\n+    \/\/     => ~((a | b) | (c | d))\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    @IR(counts = { IRNode.OR , \"3\",\n+                   IRNode.XOR, \"1\", })\n+    public long test4(long a, long b, long c, long d) {\n+        return (~a & ~b) & (~c & ~d);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DeMorganLawLongTests.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8322077\n+ * @summary Test that Ideal transformations of OrINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.OrINodeIdealizationTests\n+ *\/\n+public class OrINodeIdealizationTests {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = { \"test1\" })\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b) {\n+        Asserts.assertEQ((~a) | (~b), test1(a, b));\n+    }\n+\n+    \/\/ Checks (~a) | (~b) => ~(a & b)\n+    @Test\n+    @IR(failOn = { IRNode.OR })\n+    @IR(counts = { IRNode.AND, \"1\",\n+                   IRNode.XOR, \"1\" })\n+    public int test1(int a, int b) {\n+        return (~a) | (~b);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/OrINodeIdealizationTests.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8322077\n+ * @summary Test that Ideal transformations of OrLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.OrLNodeIdealizationTests\n+ *\/\n+public class OrLNodeIdealizationTests {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = { \"test1\" })\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEQ((~a) | (~b), test1(a, b));\n+    }\n+\n+    \/\/ Checks (~a) | (~b) => ~(a & b)\n+    @Test\n+    @IR(failOn = { IRNode.OR })\n+    @IR(counts = { IRNode.AND, \"1\",\n+                   IRNode.XOR, \"1\" })\n+    public long test1(long a, long b) {\n+        return (~a) | (~b);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/OrLNodeIdealizationTests.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @requires vm.opt.DeoptimizeALot != true\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPrunedExHandler.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,4 +61,1 @@\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        \/\/ The vectorization of some conversions may fail when `+AlignVector`.\n-        \/\/ We can remove the condition after JDK-8303827.\n-        applyIf = {\"AlignVector\", \"false\"})\n+                  IRNode.STORE_VECTOR, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizeTypeConversion.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323190\n+ * @summary C2 Segfaults during code generation because of unhandled SafePointScalarMerge monitor debug info.\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp -XX:+ReduceAllocationMerges TestInvalidLocation\n+ *\/\n+\n+public class TestInvalidLocation {\n+    static boolean var2 = true;\n+    static double[] var4 = new double[1];\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10; i++) {\n+            System.out.println(test());\n+        }\n+    }\n+\n+    static Class0 test() {\n+        double[] var14;\n+        double var3;\n+        StringBuilder var1 = new StringBuilder();\n+        Class0 var0 = Class1.Class1_sfield0;\n+        synchronized (var2 ? new StringBuilder() : var1) {\n+            var14 = var4;\n+            for (int i0 = 0; i0 < var0.Class0_field0.length && i0 < var14.length; i0 = 1) {\n+                var3 = var14[i0];\n+            }\n+        }\n+        return var0;\n+    }\n+\n+    static class Class0 {\n+        double[] Class0_field0;\n+        Class0() {\n+            Class0_field0 = new double[] { 85.42200639495138 };\n+        }\n+    }\n+\n+    class Class1 {\n+        static Class0 Class1_sfield0 = new Class0();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestInvalidLocation.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.gcbarriers;\n+\n+import compiler.lib.ir_framework.*;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.MethodHandles;\n+\n+\/**\n+ * @test\n+ * @summary Test that the expanded size of ZGC barriers is taken into account in\n+ *          C2's loop unrolling heuristics so that over-unrolling is avoided.\n+ *          The tests use volatile memory accesses to prevent C2 from simply\n+ *          optimizing them away.\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.ZGenerational\n+ * @run driver compiler.gcbarriers.TestZGCUnrolling\n+ *\/\n+\n+public class TestZGCUnrolling {\n+\n+    static class Outer {\n+        Object f;\n+    }\n+\n+    static final VarHandle fVarHandle;\n+    static {\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        try {\n+            fVarHandle = l.findVarHandle(Outer.class, \"f\", Object.class);\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UseZGC\", \"-XX:+ZGenerational\",\n+                                   \"-XX:LoopUnrollLimit=24\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_P, \"1\"})\n+    public static void testNoUnrolling(Outer o, Object o1) {\n+        for (int i = 0; i < 64; i++) {\n+            fVarHandle.setVolatile(o, o1);\n+        }\n+    }\n+\n+    @Run(test = {\"testNoUnrolling\"})\n+    void run() {\n+        testNoUnrolling(new Outer(), new Object());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCUnrolling.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh,.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16Conversion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh,.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16ConversionNaN.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh,.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestAllFloat16ToFloat.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh,.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestConstFloat16ToFloat.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,2 +51,5 @@\n-        Asserts.assertEQ(expectStdout, output.getStdout());\n-        output.stderrShouldBeEmpty();\n+        \/\/ Test for containment instead of equality as -XX:+EagerJVMCI means\n+        \/\/ the main thread and one or more libjvmci compiler threads\n+        \/\/ may initialize libjvmci at the same time and thus the error\n+        \/\/ message can appear multiple times.\n+        output.stdoutShouldContain(expectStdout);\n@@ -54,0 +57,1 @@\n+        output.stderrShouldBeEmpty();\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestInvalidJVMCIOption.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -559,1 +559,1 @@\n-        \/\/ Only run for 90% of the time, and subtract some margin. This ensures the shutdown has sufficient time,\n+        \/\/ Only run for 40% of the time, and subtract some margin. This ensures the shutdown has sufficient time,\n@@ -561,5 +561,7 @@\n-        long test_time_allowance = System.currentTimeMillis() +\n-                                   (long)(Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) * 0.9) -\n-                                   20_000;\n-        long test_hard_timeout = System.currentTimeMillis() +\n-                                Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT);\n+        System.out.println(\"Adjusted Timeout: \" + Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT));\n+        long testTimeAllowanceDiff = (long)(Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) * 0.4) -\n+                                     20_000;\n+        System.out.println(\"Time Allowance:   \" + testTimeAllowanceDiff);\n+        long testTimeAllowance = System.currentTimeMillis() + testTimeAllowanceDiff;\n+        long testHardTimeout   = System.currentTimeMillis() +\n+                                 Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT);\n@@ -572,2 +574,2 @@\n-                long allowance = test_time_allowance - System.currentTimeMillis();\n-                long until_timeout = test_hard_timeout - System.currentTimeMillis();\n+                long allowance    = testTimeAllowance - System.currentTimeMillis();\n+                long untilTimeout = testHardTimeout   - System.currentTimeMillis();\n@@ -575,1 +577,1 @@\n-                                   \", time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+                                   \", time allowance: \" + allowance + \", until timeout: \" + untilTimeout);\n@@ -586,3 +588,3 @@\n-                if (System.currentTimeMillis() > test_time_allowance) {\n-                    allowance = test_time_allowance - System.currentTimeMillis();\n-                    until_timeout = test_hard_timeout - System.currentTimeMillis();\n+                if (System.currentTimeMillis() > testTimeAllowance) {\n+                    allowance    = testTimeAllowance - System.currentTimeMillis();\n+                    untilTimeout = testHardTimeout   - System.currentTimeMillis();\n@@ -590,1 +592,1 @@\n-                                       \", time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+                                       \", time allowance: \" + allowance + \", until timeout: \" + untilTimeout);\n@@ -595,3 +597,3 @@\n-        long allowance = test_time_allowance - System.currentTimeMillis();\n-        long until_timeout = test_hard_timeout - System.currentTimeMillis();\n-        System.out.println(\"TEST PASSED, time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+        long allowance    = testTimeAllowance - System.currentTimeMillis();\n+        long untilTimeout = testHardTimeout   - System.currentTimeMillis();\n+        System.out.println(\"TEST PASSED, time allowance: \" + allowance + \", until timeout: \" + untilTimeout);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVectorFuzzer.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8319793\n+ * @summary Replacing a test with a dominating test can cause an array load to float above a range check that guards it\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:-TieredCompilation TestArrayAccessAboveRCAfterSmearingOrPredication\n+ *\/\n+\n+\n+public class TestArrayAccessAboveRCAfterSmearingOrPredication {\n+    private static int field;\n+    private static int flagField;\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        float[] array = new float[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            testRangeCheckSmearing(array, 0, 1, true, true, true);\n+            testRangeCheckSmearing(array, 0, 1, true, false, true);\n+            testRangeCheckSmearing(array, 0, 1, false, false, true);\n+            testRangeCheckSmearing(array, 0, 1, true, true, false);\n+            testRangeCheckSmearing(array, 0, 1, true, false, false);\n+            testRangeCheckSmearing(array, 0, 1, false, false, false);\n+            testHelper(0);\n+\n+            testLoopPredication(array, 0, 1, true, true, true);\n+            testLoopPredication(array, 0, 1, true, false, true);\n+            testLoopPredication(array, 0, 1, false, false, true);\n+            testLoopPredication(array, 0, 1, true, true, false);\n+            testLoopPredication(array, 0, 1, true, false, false);\n+            testLoopPredication(array, 0, 1, false, false, false);\n+        }\n+        try {\n+            testRangeCheckSmearing(array, Integer.MAX_VALUE, 1, false, false, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            testLoopPredication(array, Integer.MAX_VALUE, 1, false, false, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static float testRangeCheckSmearing(float[] array, int i, int flag, boolean flag2, boolean flag3, boolean flag4) {\n+        if (array == null) {\n+        }\n+        flagField = flag;\n+        int j;\n+        for (j = 0; j < 10; j++) {\n+        }\n+        for (int k = 0; k < 10; k++) {\n+            for (int l = 0; l < 10; l++) {\n+            }\n+        }\n+        testHelper(j);\n+        float v = 0;\n+        if (flag == 1) {\n+            if (flag4) {\n+                v += array[i];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    v += array[i];\n+                }\n+            } else {\n+                v += array[i];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    v += array[i];\n+                }\n+            }\n+        }\n+        return v;\n+    }\n+\n+    private static void testHelper(int j) {\n+        if (j == 10) {\n+            return;\n+        }\n+        flagField = 0;\n+    }\n+\n+    private static float testLoopPredication(float[] array, int i, int flag, boolean flag2, boolean flag3, boolean flag4) {\n+        i = Math.min(i, Integer.MAX_VALUE - 2);\n+        if (array == null) {\n+        }\n+        flagField = flag;\n+        int j;\n+        for (j = 0; j < 10; j++) {\n+            for (int k = 0; k < 10; k++) {\n+            }\n+        }\n+        testHelper(j);\n+\n+        float v = 0;\n+        if (flag == 1) {\n+            if (flag4) {\n+                float dummy = array[i];\n+                dummy = array[i + 2];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    for (int m = 0; m < 3; m++) {\n+                        v += array[i + m];\n+                    }\n+                }\n+                volatileField = 42;\n+            } else {\n+                float dummy = array[i];\n+                dummy = array[i + 2];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    for (int m = 0; m < 3; m++) {\n+                        v += array[i + m];\n+                    }\n+                }\n+                volatileField = 42;\n+            }\n+        }\n+\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterSmearingOrPredication.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8319793\n+ * @summary Replacing a test with a dominating test can cause an array access CastII to float above a range check that guards it\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation TestArrayAccessCastIIAboveRC\n+ *\/\n+\n+public class TestArrayAccessCastIIAboveRC {\n+    static int N = 400;\n+    static int iArrFld[] = new int[N];\n+\n+    static void test() {\n+        float fArr[] = new float[N];\n+        int i9, i10, i12;\n+        long lArr1[] = new long[N];\n+        for (i9 = 7; i9 < 43; i9++) {\n+            try {\n+                i10 = 7 % i9;\n+                iArrFld[i9 + 1] = i9 \/ i10;\n+            } catch (ArithmeticException a_e) {\n+            }\n+            for (i12 = 1; 7 > i12; i12++)\n+                lArr1[i9 - 1] = 42;\n+            iArrFld[i12] = 4;\n+            fArr[i9 - 1] = 0;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 50_000; ++i) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessCastIIAboveRC.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=normal\n+ * @bug 8323101\n+ * @summary Test split_thru_phi with pinned divisions\/modulo that have phi as inputs.\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivThroughPhiWithControl::*\n+ *                   compiler.splitif.TestSplitDivThroughPhiWithControl\n+ *\/\n+\n+\/*\n+ * @test id=fuzzer\n+ * @bug 8323101\n+ * @summary Test split_thru_phi with pinned divisions\/modulo that have phi as inputs.\n+ * @run main\/othervm -Xbatch -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivThroughPhiWithControl::*\n+ *                   compiler.splitif.TestSplitDivThroughPhiWithControl\n+ *\/\n+\n+package compiler.splitif;\n+\n+public class TestSplitDivThroughPhiWithControl {\n+    static int divisorInt = 34;\n+    static int iFld;\n+    static int x;\n+    static int y;\n+    static long divisorLong = 34L;\n+    static long lFld;\n+    static long lFld2;\n+    static long lFld3;\n+    static boolean flag;\n+\n+    static int[] iArr = new int[400];\n+\n+    public static void main(String[] strArr) {\n+        iArr[0] = 52329;\n+        for (int i = 0; i < 10000; i++) {\n+            flag = i % 3 == 0;                 \/\/ Avoid unstable if trap\n+            divisorInt = i % 2 == 0 ? 0 : 23;  \/\/ Avoid div by zero trap\n+            divisorLong = divisorInt;          \/\/ Avoid div by zero trap\n+            try {\n+                testIntDiv();\n+            } catch (ArithmeticException e) {\n+                \/\/ Expected.\n+            }\n+\n+            try {\n+                testIntMod();\n+            } catch (ArithmeticException e) {\n+                \/\/ Expected.\n+            }\n+\n+            try {\n+                testLongDiv(); \/\/ Currently does not trigger due to JDK-8323652\n+            } catch (ArithmeticException e) {\n+                \/\/ Expected.\n+            }\n+\n+            try {\n+                testLongMod(); \/\/ Currently does not trigger due to JDK-8323652\n+            } catch (ArithmeticException e) {\n+                \/\/ Expected.\n+            }\n+\n+            testFuzzer();\n+        }\n+    }\n+\n+    static void testIntDiv() {\n+        int a;\n+\n+        for (int j = 0; j < 100; j++) {\n+            y += 5;\n+            int sub = j - 3; \/\/ AddI\n+            int div = (sub \/ divisorInt); \/\/ DivI with AddI input\n+\n+            if (flag) {\n+                a = y;\n+            } else {\n+                a = 2;\n+            }\n+            \/\/ Region\n+\n+            \/\/ Use StoreI with AddI input. Store needs to be split through Region in Split-If which is done together\n+            \/\/ with AddI.\n+            iFld = sub;\n+\n+            if (a < 3) { \/\/ If that's split in Split-If\n+                \/\/ Use of DivI -> after Split-If, DivI gets a Phi input that merges the split AddI nodes.\n+                \/\/ -> triggers assert that we should not find pinned div nodes in cannot_split_division().\n+                x = div;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as testIntDiv() but with ModI\n+    static void testIntMod() {\n+        int a;\n+\n+        for (int j = 0; j < 100; j++) {\n+            y += 5;\n+            int sub = j - 3;\n+            int mod = (sub % divisorInt);\n+\n+            if (flag) {\n+                a = y;\n+            } else {\n+                a = 2;\n+            }\n+\n+            iFld = sub;\n+\n+            if (a < 3) {\n+                x = mod; \/\/ Only StoreI visited first but not mod since it's an input\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as testIntDiv() but with DivL\n+    static void testLongDiv() {\n+        long a;\n+\n+        for (int j = 0; j < 100; j++) {\n+            y += 5;\n+            long sub = j - 3;\n+            long div = (sub \/ divisorLong);\n+\n+            if (flag) {\n+                a = lFld2;\n+            } else {\n+                a = 2;\n+            }\n+\n+            lFld = sub;\n+\n+            if (a < 3) {\n+                lFld3 = div;\n+            }\n+        }\n+    }\n+\n+\n+    \/\/ Same as testIntDiv() but with ModL\n+    static void testLongMod() {\n+        long a;\n+\n+        for (long j = 0; j < 100; j++) {\n+            lFld2 += 5;\n+            long sub = j - 3;\n+            long mod = (sub % divisorLong);\n+\n+            if (flag) {\n+                a = lFld2;\n+            } else {\n+                a = 2;\n+            }\n+\n+            lFld = sub;\n+\n+            if (a < 3) {\n+                lFld3 = mod; \/\/ Only StoreI visited first but not mod since it's an input\n+            }\n+        }\n+    }\n+\n+    \/\/ Original fuzzer crash\n+    static void testFuzzer() {\n+        int i19, i21 = 4928, i23 = 14;\n+        for (int i = 5; i < 100; i++) {\n+            i19 = i23;\n+            int j = 1;\n+            while (true) {\n+                try {\n+                    i21 = (iArr[0] \/ 34);\n+                    i23 = (j % i21);\n+                } catch (ArithmeticException a_e) {\n+                }\n+                iArr = iArr;\n+                iFld = i21;\n+                iArr[1] += 5;\n+                if (j == 1000) {\n+                    break;\n+                }\n+                j++;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestSplitDivThroughPhiWithControl.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8316533\n- * @summary Oop of abstract class A with no subclass is subtype checked after null-check\n- * @run driver compiler.types.TestSubTypeOfAbstractClass\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8316533\n- * @summary Oop of abstract class A is subtype checked after null-check\n- * @requires vm.compiler2.enabled\n- * @run main\/othervm -XX:CompileCommand=compileonly,*A::test\n- *                   -Xcomp -XX:+IgnoreUnrecognizedVMOptions -XX:+StressReflectiveCode\n- *                   compiler.types.TestSubTypeOfAbstractClass\n- *\/\n-\n-package compiler.types;\n-\n-public class TestSubTypeOfAbstractClass {\n-\n-    abstract class A {\n-        public static A get_null() {\n-            return null;\n-        }\n-\n-        public static boolean test() {\n-            \/\/ NullCheck -> CastPP with type A:NotNull\n-            \/\/ But A is abstract with no subclass, hence this type is impossible\n-            return get_null() instanceof A;\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        for (int i = 0; i < 10_000; i++ ) {\n-            A.test();\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestSubTypeOfAbstractClass.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8316756\n+ * @summary Test UNSAFE.copyMemory in combination with Escape Analysis\n+ * @library \/test\/lib\n+ *\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,compiler.unsafe.UnsafeArrayCopy::test*\n+ *                   compiler.unsafe.UnsafeArrayCopy\n+ *\/\n+\n+package compiler.unsafe;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+\n+public class UnsafeArrayCopy {\n+\n+    private static Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    static long SRC_BASE = UNSAFE.allocateMemory(4);\n+    static long DST_BASE = UNSAFE.allocateMemory(4);\n+\n+    static class MyClass {\n+        int x;\n+    }\n+\n+    static int test() {\n+        MyClass obj = new MyClass(); \/\/ Non-escaping to trigger Escape Analysis\n+        UNSAFE.copyMemory(null, SRC_BASE, null, DST_BASE, 4);\n+        obj.x = 42;\n+        return obj.x;\n+    }\n+\n+    static int[] test2() {\n+         int[] src = new int[4];\n+         int[] dst = new int[4];\n+         MyClass obj = new MyClass();\n+         UNSAFE.copyMemory(src, 0, dst, 0, 4);\n+         obj.x = 42;\n+         dst[1] = obj.x;\n+         return dst;\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 50_000; ++i) {\n+            test();\n+            test2();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/UnsafeArrayCopy.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -146,3 +146,0 @@\n-        \/\/ The vectorization of some conversions may fail when `+AlignVector`.\n-        \/\/ We can remove the condition after JDK-8303827.\n-        applyIf = {\"AlignVector\", \"false\"},\n@@ -236,3 +233,0 @@\n-        \/\/ The vectorization of some conversions may fail when `+AlignVector`.\n-        \/\/ We can remove the condition after JDK-8303827.\n-        applyIf = {\"AlignVector\", \"false\"},\n@@ -320,3 +314,0 @@\n-        \/\/ The vectorization of some conversions may fail when `+AlignVector`.\n-        \/\/ We can remove the condition after JDK-8303827.\n-        applyIf = {\"AlignVector\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,0 +241,11 @@\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.MAX_VD, \">0\"})\n+    public double[] vectorMax_8322090() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.max(d[i], d[i]);\n+        }\n+        return res;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires vm.flagless\n@@ -48,1 +49,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJava(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousAllocConcurrentStart.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/*\n+ *  This is a non-abstract class with an abstract method.\n+ *\n+ *\/\n+super public class AbstractMethodClass\n+      extends java\/lang\/Object\n+              version 51:0  \/\/ Java 7 version\n+{\n+\n+    public Method \"<init>\":\"()V\"\n+       stack 1 locals 1\n+    {\n+        aload_0;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public abstract Method \"abstractM\":\"()V\";\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/abstractMethod\/AbstractMethodClass.jasm","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323243\n+ * @summary Test that invocation of an abstract method from JNI works correctly\n+ * @compile AbstractMethodClass.jasm\n+ * @run main\/othervm\/native TestJNIAbstractMethod\n+ *\/\n+\n+\/**\n+ * We are testing invocation of an abstract method from JNI - which should\n+ * simply result in throwning AbstractMethodError. To invoke an abstract method\n+ * we must have an instance method (as abstract static methods are illegal),\n+ * but instantiating an abstract class is also illegal at the Java language\n+ * level, so we have to use a custom jasm class that contains an abstract method\n+ * declaration, but which is not itself declared as an abstract class.\n+ *\/\n+public class TestJNIAbstractMethod {\n+\n+    \/\/ Invokes an abstract method from JNI and throws AbstractMethodError.\n+    private static native void invokeAbstractM(Class<?> AMclass,\n+                                               AbstractMethodClass receiver);\n+\n+    static {\n+        System.loadLibrary(\"JNIAbstractMethod\");\n+    }\n+\n+    public static void main(String[] args) {\n+        AbstractMethodClass obj = new AbstractMethodClass();\n+        try {\n+            System.out.println(\"Attempting direct invocation via Java\");\n+            obj.abstractM();\n+            throw new RuntimeException(\"Did not get AbstractMethodError from Java!\");\n+        } catch (AbstractMethodError expected) {\n+            System.out.println(\"ok - got expected exception: \" + expected);\n+        }\n+        try {\n+            System.out.println(\"Attempting direct invocation via JNI\");\n+            invokeAbstractM(obj.getClass(), obj);\n+            throw new RuntimeException(\"Did not get AbstractMethodError from JNI!\");\n+        } catch (AbstractMethodError expected) {\n+            System.out.println(\"ok - got expected exception: \" + expected);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/abstractMethod\/TestJNIAbstractMethod.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include <jni.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+JNIEXPORT void JNICALL Java_TestJNIAbstractMethod_invokeAbstractM(JNIEnv* env,\n+                                                                  jclass this_cls,\n+                                                                  jclass target_cls,\n+                                                                  jobject receiver) {\n+\n+  jmethodID mid = (*env)->GetMethodID(env, target_cls, \"abstractM\", \"()V\");\n+  if (mid == NULL) {\n+    fprintf(stderr, \"Error looking up method abstractM\\n\");\n+    (*env)->ExceptionDescribe(env);\n+    exit(1);\n+  }\n+\n+  printf(\"Invoking abstract method ...\\n\");\n+  (*env)->CallVoidMethod(env, receiver, mid);  \/\/ Should raise exception\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/abstractMethod\/libJNIAbstractMethod.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -64,1 +64,1 @@\n-        public static void main(String args[]) {\n+        public static void main(String args[]) throws Exception {\n@@ -67,3 +67,2 @@\n-                \/\/ HotSpot implementation detail: asking for the hash code\n-                \/\/ when the object is locked causes monitor inflation.\n-                if (obj.hashCode() == 0xBAD) System.out.println(\"!\");\n+                \/\/ The current implementation of notify-wait requires inflation.\n+                obj.wait(1);\n","filename":"test\/hotspot\/jtreg\/runtime\/whitebox\/TestWBDeflateIdleMonitors.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.catalog;\n+\n+import org.w3c.dom.ls.LSInput;\n+import org.w3c.dom.ls.LSResourceResolver;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.catalog.CatalogFeatures;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.SchemaFactory;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.util.Objects.requireNonNull;\n+import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;\n+import static javax.xml.catalog.CatalogManager.catalogResolver;\n+import javax.xml.catalog.CatalogResolver;\n+import javax.xml.validation.Validator;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8323571\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @run testng common.catalog.NullIdTest\n+ * @summary Verifies null values are handled properly in the source resolution\n+ * process.\n+ *\/\n+public class NullIdTest {\n+    private static final Map<String, String> SCHEMAS;\n+    \/\/ Source Level JDK 8\n+    static {\n+        Map<String, String> map = new HashMap<>();\n+        map.put(\"https:\/\/schemas.opentest4j.org\/reporting\/events\/0.1.0\", \"events.xsd\");\n+        map.put(\"https:\/\/schemas.opentest4j.org\/reporting\/core\/0.1.0\", \"core.xsd\");\n+        SCHEMAS = Collections.unmodifiableMap(map);\n+    }\n+\n+    \/*\n+     * Verifies that the source resolution process recognizes the custom InputSource\n+     * correctly even though the public and system IDs are null.\n+    *\/\n+    @Test\n+    public void test() throws Exception {\n+        String xml = \"<events xmlns=\\\"https:\/\/schemas.opentest4j.org\/reporting\/events\/0.1.0\\\"\/>\";\n+        validate(new StreamSource(new StringReader(xml)));\n+        System.out.println(\"Successfully validated\");\n+    }\n+\n+    private static void validate(Source source) throws SAXException, IOException {\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);\n+        Validator validator = schemaFactory.newSchema().newValidator();\n+        validator.setResourceResolver(createResourceResolver());\n+        validator.validate(source);\n+    }\n+\n+    private static LSResourceResolver createResourceResolver() {\n+        return (type, namespaceURI, publicId, systemId, baseURI) -> {\n+            if (namespaceURI != null) {\n+                if (SCHEMAS.containsKey(namespaceURI)) {\n+                    CustomLSInputImpl input = new CustomLSInputImpl();\n+                    input.setPublicId(publicId);\n+                    String schema = SCHEMAS.get(namespaceURI);\n+                    input.setSystemId(requireNonNull(NullIdTest.class.getResource(schema)).toExternalForm());\n+                    input.setBaseURI(baseURI);\n+                    InputStream stream = NullIdTest.class.getResourceAsStream(schema);\n+                    input.setCharacterStream(new InputStreamReader(requireNonNull(stream)));\n+                    return input;\n+                }\n+            }\n+            if (systemId != null) {\n+                CatalogFeatures features = CatalogFeatures.builder()\n+                        .with(CatalogFeatures.Feature.RESOLVE, \"continue\")\n+                        .build();\n+                CatalogResolver catalogResolver = catalogResolver(features);\n+                return catalogResolver.resolveResource(type, namespaceURI, publicId, systemId, baseURI);\n+            }\n+            return null;\n+        };\n+    }\n+\n+    static class CustomLSInputImpl implements LSInput {\n+\n+        private Reader characterStream;\n+        private InputStream byteStream;\n+        private String stringData;\n+        private String systemId;\n+        private String publicId;\n+        private String baseURI;\n+        private String encoding;\n+        private boolean certifiedText;\n+\n+        @Override\n+        public Reader getCharacterStream() {\n+            return characterStream;\n+        }\n+\n+        @Override\n+        public void setCharacterStream(Reader characterStream) {\n+            this.characterStream = characterStream;\n+        }\n+\n+        @Override\n+        public InputStream getByteStream() {\n+            return byteStream;\n+        }\n+\n+        @Override\n+        public void setByteStream(InputStream byteStream) {\n+            this.byteStream = byteStream;\n+        }\n+\n+        @Override\n+        public String getStringData() {\n+            return stringData;\n+        }\n+\n+        @Override\n+        public void setStringData(String stringData) {\n+            this.stringData = stringData;\n+        }\n+\n+        @Override\n+        public String getSystemId() {\n+            return systemId;\n+        }\n+\n+        @Override\n+        public void setSystemId(String systemId) {\n+            this.systemId = systemId;\n+        }\n+\n+        @Override\n+        public String getPublicId() {\n+            return publicId;\n+        }\n+\n+        @Override\n+        public void setPublicId(String publicId) {\n+            this.publicId = publicId;\n+        }\n+\n+        @Override\n+        public String getBaseURI() {\n+            return baseURI;\n+        }\n+\n+        @Override\n+        public void setBaseURI(String baseURI) {\n+            this.baseURI = baseURI;\n+        }\n+\n+        @Override\n+        public String getEncoding() {\n+            return encoding;\n+        }\n+\n+        @Override\n+        public void setEncoding(String encoding) {\n+            this.encoding = encoding;\n+        }\n+\n+        @Override\n+        public boolean getCertifiedText() {\n+            return certifiedText;\n+        }\n+\n+        @Override\n+        public void setCertifiedText(boolean certifiedText) {\n+            this.certifiedText = certifiedText;\n+        }\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/NullIdTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+<xs:schema xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+           xmlns:core=\"https:\/\/schemas.opentest4j.org\/reporting\/core\/0.1.0\"\n+           targetNamespace=\"https:\/\/schemas.opentest4j.org\/reporting\/core\/0.1.0\"\n+           elementFormDefault=\"qualified\">\n+  <xs:element name=\"infrastructure\" type=\"core:Infrastructure\"\/>\n+  <xs:complexType name=\"Infrastructure\">\n+    <xs:sequence>\n+      <xs:element name=\"hostName\" minOccurs=\"0\" type=\"xs:string\"\/>\n+      <xs:element name=\"userName\" minOccurs=\"0\" type=\"xs:string\"\/>\n+      <xs:element name=\"operatingSystem\" minOccurs=\"0\" type=\"xs:string\"\/>\n+      <xs:element name=\"cpuCores\" minOccurs=\"0\" type=\"xs:int\"\/>\n+      <xs:any minOccurs=\"0\" maxOccurs=\"unbounded\" namespace=\"##other\"\/>\n+    <\/xs:sequence>\n+  <\/xs:complexType>\n+  <xs:complexType name=\"TestInfo\">\n+    <xs:sequence>\n+      <xs:element name=\"metadata\" minOccurs=\"0\">\n+        <xs:complexType>\n+          <xs:sequence>\n+            <xs:element name=\"tags\" minOccurs=\"0\">\n+              <xs:complexType>\n+                <xs:sequence>\n+                  <xs:element name=\"tag\" type=\"xs:string\" maxOccurs=\"unbounded\"\/>\n+                <\/xs:sequence>\n+              <\/xs:complexType>\n+            <\/xs:element>\n+            <xs:any minOccurs=\"0\" maxOccurs=\"unbounded\" namespace=\"##other\"\/>\n+          <\/xs:sequence>\n+        <\/xs:complexType>\n+      <\/xs:element>\n+      <xs:element name=\"sources\" minOccurs=\"0\">\n+        <xs:complexType>\n+          <xs:sequence>\n+            <xs:element name=\"directorySource\" minOccurs=\"0\" maxOccurs=\"unbounded\">\n+              <xs:complexType>\n+                <xs:attribute name=\"path\" type=\"xs:string\" use=\"required\"\/>\n+              <\/xs:complexType>\n+            <\/xs:element>\n+            <xs:element name=\"fileSource\" minOccurs=\"0\" maxOccurs=\"unbounded\">\n+              <xs:complexType>\n+                <xs:sequence>\n+                  <xs:element name=\"filePosition\" type=\"core:FilePosition\" minOccurs=\"0\"\/>\n+                <\/xs:sequence>\n+                <xs:attribute name=\"path\" type=\"xs:string\" use=\"required\"\/>\n+              <\/xs:complexType>\n+            <\/xs:element>\n+            <xs:any minOccurs=\"0\" maxOccurs=\"unbounded\" namespace=\"##other\"\/>\n+          <\/xs:sequence>\n+        <\/xs:complexType>\n+      <\/xs:element>\n+      <xs:element name=\"attachments\" minOccurs=\"0\">\n+        <xs:complexType>\n+          <xs:sequence>\n+            <xs:element name=\"data\" minOccurs=\"0\" maxOccurs=\"unbounded\">\n+              <xs:complexType>\n+                <xs:sequence>\n+                  <xs:element name=\"entry\" minOccurs=\"0\" maxOccurs=\"unbounded\">\n+                    <xs:complexType>\n+                      <xs:simpleContent>\n+                        <xs:extension base=\"xs:string\">\n+                          <xs:attribute name=\"key\" type=\"xs:string\" use=\"required\"\/>\n+                        <\/xs:extension>\n+                      <\/xs:simpleContent>\n+                    <\/xs:complexType>\n+                  <\/xs:element>\n+                <\/xs:sequence>\n+                <xs:attribute name=\"time\" type=\"xs:dateTime\" use=\"required\"\/>\n+              <\/xs:complexType>\n+            <\/xs:element>\n+            <xs:any minOccurs=\"0\" maxOccurs=\"unbounded\" namespace=\"##other\"\/>\n+          <\/xs:sequence>\n+        <\/xs:complexType>\n+      <\/xs:element>\n+      <xs:element name=\"result\" minOccurs=\"0\">\n+        <xs:complexType>\n+          <xs:sequence>\n+            <xs:element name=\"reason\" type=\"xs:string\" minOccurs=\"0\"\/>\n+            <xs:any minOccurs=\"0\" maxOccurs=\"unbounded\" namespace=\"##other\"\/>\n+          <\/xs:sequence>\n+          <xs:attribute name=\"status\" type=\"core:Status\"\/>\n+        <\/xs:complexType>\n+      <\/xs:element>\n+    <\/xs:sequence>\n+  <\/xs:complexType>\n+  <xs:simpleType name=\"Status\">\n+    <xs:restriction base=\"xs:string\">\n+      <xs:enumeration value=\"SUCCESSFUL\"\/>\n+      <xs:enumeration value=\"SKIPPED\"\/>\n+      <xs:enumeration value=\"ABORTED\"\/>\n+      <xs:enumeration value=\"FAILED\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+  <xs:complexType name=\"FilePosition\">\n+    <xs:attribute name=\"line\" type=\"xs:int\" use=\"required\"\/>\n+    <xs:attribute name=\"column\" type=\"xs:int\"\/>\n+  <\/xs:complexType>\n+<\/xs:schema>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/core.xsd","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+<xs:schema xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+           xmlns:core=\"https:\/\/schemas.opentest4j.org\/reporting\/core\/0.1.0\"\n+           xmlns:e=\"https:\/\/schemas.opentest4j.org\/reporting\/events\/0.1.0\"\n+           targetNamespace=\"https:\/\/schemas.opentest4j.org\/reporting\/events\/0.1.0\"\n+           elementFormDefault=\"qualified\">\n+  <xs:import schemaLocation=\"core.xsd\" namespace=\"https:\/\/schemas.opentest4j.org\/reporting\/core\/0.1.0\"\/>\n+  <xs:element name=\"events\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element ref=\"core:infrastructure\" minOccurs=\"0\"\/>\n+        <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+          <xs:element name=\"started\" type=\"e:Started\"\/>\n+          <xs:element name=\"reported\" type=\"e:Event\"\/>\n+          <xs:element name=\"finished\" type=\"e:Event\"\/>\n+        <\/xs:choice>\n+      <\/xs:sequence>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+  <xs:complexType name=\"Event\">\n+    <xs:complexContent>\n+      <xs:extension base=\"core:TestInfo\">\n+        <xs:attribute name=\"id\" type=\"xs:string\" use=\"required\"\/>\n+        <xs:attribute name=\"time\" type=\"xs:dateTime\" use=\"required\"\/>\n+      <\/xs:extension>\n+    <\/xs:complexContent>\n+  <\/xs:complexType>\n+  <xs:complexType name=\"Started\">\n+    <xs:complexContent>\n+      <xs:extension base=\"e:Event\">\n+        <xs:attribute name=\"parentId\" type=\"xs:string\"\/>\n+        <xs:attribute name=\"name\" type=\"xs:string\" use=\"required\"\/>\n+      <\/xs:extension>\n+    <\/xs:complexContent>\n+  <\/xs:complexType>\n+<\/xs:schema>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/events.xsd","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -627,1 +627,0 @@\n-sun\/security\/pkcs11\/Provider\/MultipleLogins.sh                  8319128 linux-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -876,0 +876,70 @@\n+            \/\/ Random test data\n+            new Data(AES, 4, \"272f16edb81a7abbea887357a58c1917\",\n+                \"794ec588176c703d3d2a7a07\",\n+                new byte[2075], null,\n+                \"15b461672153270e8ba1e6789f7641c5411f3e642abda731b6086f535c216457\" +\n+                \"e87305bc59a1ff1f7e1e0bbdf302b75549b136606c67d7e5f71277aeca4bc670\" +\n+                \"07a98f78e0cfa002ed183e62f07893ad31fe67aad1bb37e15b957a14d145f14f\" +\n+                \"7483d041f2c3612ad5033155984470bdfc64d18df73c2745d92f28461bb09832\" +\n+                \"33524811321ba87d213692825815dd13f528dba601a3c319cac6be9b48686c23\" +\n+                \"a0ce23d5062916ea8827bbb243f585e446131489e951354c8ab24661f625c02e\" +\n+                \"15536c5bb602244e98993ff745f3e523399b2059f0e062d8933fad2366e7e147\" +\n+                \"510a931282bb0e3f635efe7bf05b1dd715f95f5858261b00735224256b6b3e80\" +\n+                \"7364cb53ff6d4e88f928cf67ac70da127718a8a35542efbae9dd7567c818a074\" +\n+                \"9a0c74bd69014639f59768bc55056d1166ea5523e8c66f9d78d980beb8f0d83b\" +\n+                \"a9e2c5544b94dc3a1a4b6f0f95f897b010150e89ebcacf0daee3c2793d6501a0\" +\n+                \"b58b411de273dee987e8e8cf8bb29ef2e7f655b46b55fabf64c6a4295e0d080b\" +\n+                \"6a570ace90eb0fe0f5b5d878bdd90eddaa1150e4d5a6505b350aac814fe99615\" +\n+                \"317ecd0516a464c7904011ef5922409c0d65b1e43b69d7c3293a8f7d3e9fbee9\" +\n+                \"eb91ec0007a7d6f72e64deb675d459c5ba07dcfd58d08e6820b100465e6e04f0\" +\n+                \"663e310584a00d36d23699c1bffc6afa094c75184fc7cde7ad35909c0f49f2f3\" +\n+                \"fe1e6d745ab628d74ea56b757047de57ce18b4b3c71e8af31a6fac16189cb0a3\" +\n+                \"a97a1bea447042ce382fcf726560476d759c24d5c735525ea26a332c2094408e\" +\n+                \"671c7deb81d5505bbfd178f866a6f3a011b3cfdbe089b4957a790688028dfdf7\" +\n+                \"9a096b3853f9d0d6d3feef230c7f5f46ffbf7486ebdaca5804dc5bf9d202415e\" +\n+                \"e0d67b365c2f92a17ea740807e4f0b198b42b54f15faa9dff2c7c35d2cf8d72e\" +\n+                \"b8f8b18875a2e7b5c43d1e0aa5139c461e8153c7f632895aa46ffe2b134e6a0d\" +\n+                \"dfbf6a336e709adfe951bd52c4dfc7b07a15fb3888fc35b7e758922f87a104c4\" +\n+                \"563c5c7839cfe5a7edbdb97264a7c4ebc90367b10cbe09dbf2390767ad7afaa8\" +\n+                \"8fb46b39d3f55f216d2104e5cf040bf3d39b758bea28e2dbce576c808d17a8eb\" +\n+                \"e2fd183ef42a774e39119dff1f539efeb6ad15d889dfcb0d54d0d4d4cc03c8d9\" +\n+                \"aa6c9ebd157f5e7170183298d6a30ada8792dcf793d931e2a1eafccbc63c11c0\" +\n+                \"c5c5ed60837f30017d693ccb294df392a8066a0594a56954aea7b78a16e9a11f\" +\n+                \"4a8bc2104070a7319f5fab0d2c4ccad8ec5cd8f47c839179bfd54a7bf225d502\" +\n+                \"cd0a318752fe763e8c09eb88fa57fc5399ad1f797d0595c7b8afdd23f13603e9\" +\n+                \"6802192bb51433b7723f4e512bd4f799feb94b458e7f9792f5f9bd6733828f70\" +\n+                \"a6b7ffbbc0bb7575021f081ec2a0d37fecd7cda2daec9a3a9d9dfe1c8034cead\" +\n+                \"e4b56b581cc82bd5b74b2b30817967d9da33850336f171a4c68e2438e03f4b11\" +\n+                \"96da92f01b3b7aeab795180ccf40a4b090b1175a1fc0b67c95f93105c3aef00e\" +\n+                \"13d76cc402539192274fee703730cd0d1c5635257719cc96cacdbad00c6255e2\" +\n+                \"bd40c775b43ad09599e84f2c3205d75a6661ca3f151183be284b354ce21457d1\" +\n+                \"3ba65b9b2cdb81874bd14469c2008b3ddec78f7225ecc710cc70de7912ca6a6d\" +\n+                \"348168322ab59fdafcf5c833bfa0ad4046f4b6da90e9f263db7079af592eda07\" +\n+                \"5bf16c6b1a8346da9c292a48bf660860a4fc89eaef40bc132779938eca294569\" +\n+                \"787c740af2b5a8de7f5e10ac750d1e3d0ef3ed168ba408a676e10b8a20bd4be8\" +\n+                \"3e8336b45e54481726d73e1bd19f165a98e242aca0d8387f2dd22d02d74e23db\" +\n+                \"4cef9a523587413e0a44d7e3260019a34d3a6b38426ae9fa4655be338d721970\" +\n+                \"cb9fe76c073f26f9303093a033022cd2c62b2790bce633ba9026a1c93b6535f1\" +\n+                \"1882bf5880e511b9e1b0b7d8f23a993aae5fd275faac3a5b4ccaf7c06b0b266a\" +\n+                \"ee970a1e3a4cd7a41094f516960630534e692545b25a347c30e3f328bba4825f\" +\n+                \"ed754e5525d846131ecba7ca120a6aeabc7bab9f59c890c80b7e31f9bc741591\" +\n+                \"55d292433ce9558e104102f2cc63ee267c1c8333e841522707ea6d595cb802b9\" +\n+                \"61697da77bbc4cb404ea62570ab335ebffa2023730732ac5ddba1c3dbb5be408\" +\n+                \"3c50aea462c1ffa166d7cc3db4b742b747e81b452db2363e91374dee8c6b40f0\" +\n+                \"e7fbf50e60eaf5cc5649f6bb553aae772c185026ceb052af088c545330a1ffbf\" +\n+                \"50615b8c7247c6cd386afd7440654f4e15bcfae0c45442ec814fe88433a9d616\" +\n+                \"ee6cc3f163f0d3d325526d05f25d3b37ad5eeb3ca77248ad86c9042b16c65554\" +\n+                \"aebb6ad3e17b981492b13f42c5a5dc088e991da303e5a273fdbb8601aece4267\" +\n+                \"47b01f6cb972e6da1743a0d7866cf206e95f23c6f8e337c901b9cd34a9a1fbbe\" +\n+                \"1694f2c26b00dfa4d02c0d54540163e798fbdc9c25f30d6406f5b4c13f7ed619\" +\n+                \"34e350f4059c13aa5e973307a9e3058917cda96fdd082e9c629ccfb2a9f98d12\" +\n+                \"5c6e4703a7b0f348f5cdeb63cef2133d1c6c1a087591e0a2bca29d09c6565e66\" +\n+                \"e91042f83b0e74e60a5d57562c23e2fbcd6599c29d7c19e47cf625c2ce24bb8a\" +\n+                \"13f8e54041498437eec2cedd1e3d8e57a051baa962c0a62d70264d99c5ee716d\" +\n+                \"5c8b9078db08c8b2c5613f464198a7aff43f76c5b4612b46a4f1cd2a494386c5\" +\n+                \"7fd28f3d199f0ba8d8e39116cc7db16ce6188205ee49a9dce3d4fa32ea394919\" +\n+                \"f6e91ef58b84d00b99596b4306c2d9f432d917bb4ac73384c42ae12adb4920d8\" +\n+                \"c33a816febcb299dcddf3ec7a8eb6e04cdc90891c6e145bd9fc5f41dc4061a46\" +\n+                \"9feba38545b64ec8203f386ceef52785619e991d274ae80af7e54af535e0b011\" +\n+                \"5effdf847472992875e09398457604d04e0bb965db692c0cdcf11a\",\n+                \"687cc09c89298491deb51061d709af\"),\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/AEADBufferTest.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @summary Uses GCMBufferTest to run a long test with incrementing through\n- * each byte in each byte array\n+ * @summary Uses AEADBufferTest to run a long test with incrementing through\n+ * each byte in each byte array using AES GCM\n@@ -36,4 +36,4 @@\n-        GCMBufferTest.initTest();\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(GCMBufferTest.dtype.BYTE, GCMBufferTest.dtype.BYTE,\n-                GCMBufferTest.dtype.BYTE)).incrementalSegments().dataSet(4).\n+        AEADBufferTest.initTest();\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(AEADBufferTest.dtype.BYTE, AEADBufferTest.dtype.BYTE,\n+                AEADBufferTest.dtype.BYTE)).incrementalSegments().dataSet(4).\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMIncrementByte4.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @summary Uses GCMBufferTest to run a long test with incrementing through\n- * each byte in each direct bytebuffer\n+ * @summary Uses AEADBufferTest to run a long test with incrementing through\n+ * each byte in each direct bytebuffer using AES GCM\n@@ -36,4 +36,4 @@\n-        GCMBufferTest.initTest();\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(GCMBufferTest.dtype.DIRECT, GCMBufferTest.dtype.DIRECT,\n-                GCMBufferTest.dtype.DIRECT)).incrementalSegments().dataSet(4).\n+        AEADBufferTest.initTest();\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(AEADBufferTest.dtype.DIRECT, AEADBufferTest.dtype.DIRECT,\n+                AEADBufferTest.dtype.DIRECT)).incrementalSegments().dataSet(4).\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMIncrementDirect4.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import javax.crypto.spec.IvParameterSpec;\n@@ -28,0 +29,1 @@\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -34,0 +36,2 @@\n+ * @run main OverlapByteBuffer AES\/GCM\/NoPadding\n+ * @run main OverlapByteBuffer ChaCha20-Poly1305\n@@ -48,0 +52,7 @@\n+    byte[] baseBuf = new byte[8192];\n+    ByteBuffer output, input, in;\n+    int outOfs;\n+    String algorithm;\n+    SecretKeySpec key;\n+    AlgorithmParameterSpec params;\n+\n@@ -49,2 +60,19 @@\n-        byte[] baseBuf = new byte[8192];\n-        ByteBuffer output, input, in;\n+        new OverlapByteBuffer(args[0]).test();\n+    }\n+\n+    OverlapByteBuffer(String algorithm) throws Exception {\n+        this.algorithm = algorithm;\n+        switch (algorithm) {\n+            case \"AES\/GCM\/NoPadding\" -> {\n+                params = new GCMParameterSpec(128, new byte[12]);\n+                key = new SecretKeySpec(new byte[16], \"AES\");\n+            }\n+            case \"ChaCha20-Poly1305\" -> {\n+                params = new IvParameterSpec(new byte[12]);\n+                key = new SecretKeySpec(new byte[32], \"\");\n+            }\n+            default -> throw new Exception(\"unknown algorithm: \" + algorithm);\n+        }\n+    }\n+\n+    void test() throws Exception {\n@@ -52,2 +80,0 @@\n-        int outOfs;\n-\n@@ -57,4 +83,1 @@\n-                SecretKeySpec key = new SecretKeySpec(new byte[16], \"AES\");\n-                GCMParameterSpec params =\n-                    new GCMParameterSpec(128, new byte[12]);\n-                Cipher cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                Cipher cipher = Cipher.getInstance(algorithm);\n@@ -87,1 +110,2 @@\n-                        System.out.println(\"Using read-only array-backed \" + \"ByteBuffer\");\n+                        System.out.println(\"Using read-only array-backed \" +\n+                            \"ByteBuffer\");\n@@ -105,3 +129,1 @@\n-                    default -> {\n-                        throw new Exception(\"Unknown index \" + i);\n-                    }\n+                    default -> throw new Exception(\"Unknown index \" + i);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/OverlapByteBuffer.java","additions":35,"deletions":13,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @build java.base\/com.sun.crypto.provider.EvenKEMImpl\n@@ -30,0 +31,1 @@\n+ * @run main\/othervm Compliance\n@@ -48,0 +50,2 @@\n+import static com.sun.crypto.provider.EvenKEMImpl.isEven;\n+\n@@ -54,6 +58,5 @@\n-        try {\n-            Security.insertProviderAt(new ProviderImpl(), 1);\n-            delayed();\n-        } finally {\n-            Security.removeProvider(\"XP\");\n-        }\n+        \/\/ Patch an alternate DHKEM in SunEC which is ahead of SunJCE\n+        \/\/ in security provider listing.\n+        Security.getProvider(\"SunEC\")\n+                .put(\"KEM.DHKEM\", \"com.sun.crypto.provider.EvenKEMImpl\");\n+        delayed();\n@@ -223,28 +226,0 @@\n-    public static class ProviderImpl extends Provider {\n-        ProviderImpl() {\n-            super(\"XP\", \"1\", \"XP\");\n-            put(\"KEM.DHKEM\", \"Compliance$KEMImpl\");\n-        }\n-    }\n-\n-    static boolean isEven(Key k) {\n-        return Arrays.hashCode(k.getEncoded()) % 2 == 0;\n-    }\n-\n-    public static class KEMImpl extends DHKEM {\n-\n-        @Override\n-        public EncapsulatorSpi engineNewEncapsulator(PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom)\n-                throws InvalidAlgorithmParameterException, InvalidKeyException {\n-            if (!isEven(pk)) throw new InvalidKeyException(\"Only accept even keys\");\n-            return super.engineNewEncapsulator(pk, spec, secureRandom);\n-        }\n-\n-        @Override\n-        public DecapsulatorSpi engineNewDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)\n-                throws InvalidAlgorithmParameterException, InvalidKeyException {\n-            if (!isEven(sk)) throw new InvalidKeyException(\"Only accept even keys\");\n-            return super.engineNewDecapsulator(sk, spec);\n-        }\n-    }\n-\n@@ -269,1 +244,1 @@\n-        Asserts.assertEQ(eeven.providerName(), \"XP\");\n+        Asserts.assertEQ(eeven.providerName(), \"SunEC\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/Compliance.java","additions":11,"deletions":36,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.crypto.provider;\n+\n+import java.security.*;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+\n+\/\/ The alternate DHKEM implementation used by the Compliance.java test.\n+public class EvenKEMImpl extends DHKEM {\n+\n+    public static boolean isEven(Key k) {\n+        return Arrays.hashCode(k.getEncoded()) % 2 == 0;\n+    }\n+\n+    @Override\n+    public EncapsulatorSpi engineNewEncapsulator(\n+            PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (!isEven(pk)) throw new InvalidKeyException(\"Only accept even keys\");\n+        return super.engineNewEncapsulator(pk, spec, secureRandom);\n+    }\n+\n+    @Override\n+    public DecapsulatorSpi engineNewDecapsulator(\n+            PrivateKey sk, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (!isEven(sk)) throw new InvalidKeyException(\"Only accept even keys\");\n+        return super.engineNewDecapsulator(sk, spec);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/java.base\/com\/sun\/crypto\/provider\/EvenKEMImpl.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm\/timeout=180 StressDirListings\n+ * @run testng\/othervm\/timeout=180 -Dsun.net.httpserver.nodelay=true StressDirListings\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/StressDirListings.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Robot;\n+import jtreg.SkippedException;\n+\n+import static java.awt.EventQueue.invokeAndWait;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8312518\n+ * @library \/test\/lib\n+ * @summary Setting fullscreen window using setFullScreenWindow() shows up\n+ *          as black screen on newer macOS versions (13 & 14).\n+ *\/\n+\n+public class SetFullScreenTest {\n+    private static Frame frame;\n+    private static GraphicsDevice gd;\n+    private static Robot robot;\n+    private static volatile int width;\n+    private static volatile int height;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            invokeAndWait(() -> {\n+                gd = GraphicsEnvironment.getLocalGraphicsEnvironment().\n+                        getDefaultScreenDevice();\n+                if (!gd.isFullScreenSupported()) {\n+                    throw new SkippedException(\"Full Screen mode not supported\");\n+                }\n+            });\n+\n+            invokeAndWait(() -> {\n+                frame = new Frame(\"Test FullScreen mode\");\n+                frame.setBackground(Color.RED);\n+                frame.setSize(100, 100);\n+                frame.setLocation(10, 10);\n+                frame.setVisible(true);\n+            });\n+            robot.delay(1000);\n+\n+            invokeAndWait(() -> gd.setFullScreenWindow(frame));\n+            robot.waitForIdle();\n+            robot.delay(300);\n+\n+            invokeAndWait(() -> {\n+                width = gd.getFullScreenWindow().getWidth();\n+                height = gd.getFullScreenWindow().getHeight();\n+            });\n+\n+            if (!robot.getPixelColor(width \/ 2, height \/ 2).equals(Color.RED)) {\n+                System.err.println(\"Actual color: \" + robot.getPixelColor(width \/ 2, height \/ 2)\n+                                    + \" Expected color: \" + Color.RED);\n+                throw new RuntimeException(\"Test Failed! Window not in full screen mode\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/FullScreen\/SetFullScreenTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,3 +97,7 @@\n-            SwingUtilities.invokeLater(() -> {\n-                frame1.dispose();\n-                frame2.dispose();\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame1 != null) {\n+                    frame1.dispose();\n+                }\n+                if (frame2 != null) {\n+                    frame2.dispose();\n+                }\n","filename":"test\/jdk\/java\/awt\/Mouse\/GetMousePositionTest\/GetMousePositionWithPopup.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @bug 4760025\n+ * @summary Verifies sRGB conversions to and from CIE XYZ\n+ *\/\n+public final class SimpleSRGBToFromCIEXYZ {\n+\n+    public static void main(String[] args) {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        for (float g : new float[]{1.0f, 0.8f, 0.6f}) {\n+            float[] rgb = {0, g, 0};\n+            float[] xyz = cs.toCIEXYZ(rgb);\n+            float[] inv = cs.fromCIEXYZ(xyz);\n+\n+            if (inv[0] != 0 || Math.abs(inv[1] - g) > 0.0001f || inv[2] != 0) {\n+                System.err.println(\"Expected color:\\t\" + Arrays.toString(rgb));\n+                System.err.println(\"XYZ color:\\t\\t\" + Arrays.toString(xyz));\n+                System.err.println(\"Actual color:\\t\" + Arrays.toString(inv));\n+                throw new Error(\"Wrong color\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_ColorSpace\/SimpleSRGBToFromCIEXYZ.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics2D;\n+import java.awt.Transparency;\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.WritableRaster;\n+\n+\/*\n+ * @test\n+ * @bug 8316497\n+ * @summary Verifies Color filter on non-ICC profile\n+ *\/\n+public final class NonICCFilterTest {\n+    private static final int WIDTH = 100;\n+    private static final int HEIGHT = 100;\n+\n+    private enum ColorSpaceSelector {\n+        GRAY,\n+        RGB,\n+        PYCC,\n+        WRAPPED_GRAY,\n+        WRAPPED_RGB,\n+        WRAPPED_PYCC\n+    }\n+\n+    private static final class TestColorSpace extends ColorSpace {\n+\n+        private final ColorSpace cs;\n+\n+        TestColorSpace(ColorSpace cs) {\n+            super(cs.getType(), cs.getNumComponents());\n+            this.cs = cs;\n+        }\n+\n+        @Override\n+        public float[] toRGB(float[] colorvalue) {\n+            return cs.toRGB(colorvalue);\n+        }\n+\n+        @Override\n+        public float[] fromRGB(float[] rgbvalue) {\n+            return cs.fromRGB(rgbvalue);\n+        }\n+\n+        @Override\n+        public float[] toCIEXYZ(float[] colorvalue) {\n+            return cs.toCIEXYZ(colorvalue);\n+        }\n+\n+        @Override\n+        public float[] fromCIEXYZ(float[] xyzvalue) {\n+            return cs.fromCIEXYZ(xyzvalue);\n+        }\n+    }\n+\n+    private static BufferedImage createTestImage(final ColorSpace cs) {\n+        ComponentColorModel cm = new ComponentColorModel(cs, false, false,\n+                Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = cm.createCompatibleWritableRaster(WIDTH, HEIGHT);\n+        BufferedImage img = new BufferedImage(cm, raster, false, null);\n+\n+        Graphics2D g = img.createGraphics();\n+        GradientPaint gp = new GradientPaint(0, 0, Color.GREEN,\n+                raster.getWidth(), raster.getHeight(), Color.BLUE);\n+        g.setPaint(gp);\n+        g.fillRect(0, 0, raster.getWidth(), raster.getHeight());\n+        g.dispose();\n+\n+        return img;\n+    }\n+\n+    private static ColorSpace createCS(ColorSpaceSelector selector) {\n+        return switch (selector) {\n+            case GRAY -> ColorSpace.getInstance(ColorSpace.CS_GRAY);\n+            case WRAPPED_GRAY -> new TestColorSpace(ColorSpace.getInstance(ColorSpace.CS_GRAY));\n+\n+            case RGB -> ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+            case WRAPPED_RGB -> new TestColorSpace(ColorSpace.getInstance(ColorSpace.CS_sRGB));\n+\n+            case PYCC -> ColorSpace.getInstance(ColorSpace.CS_PYCC);\n+            case WRAPPED_PYCC -> new TestColorSpace(ColorSpace.getInstance(ColorSpace.CS_PYCC));\n+        };\n+    }\n+\n+    private static boolean areImagesEqual(BufferedImage destTest, BufferedImage destGold) {\n+        for (int x = 0; x < destTest.getWidth(); x++) {\n+            for (int y = 0; y < destTest.getHeight(); y++) {\n+                int rgb1 = destTest.getRGB(x, y);\n+                int rgb2 = destGold.getRGB(x, y);\n+                if (rgb1 != rgb2) {\n+                    System.err.println(\"x = \" + x + \", y = \" + y);\n+                    System.err.println(\"rgb1 = \" + Integer.toHexString(rgb1));\n+                    System.err.println(\"rgb2 = \" + Integer.toHexString(rgb2));\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static void main(String[] args) {\n+        BufferedImage srcTest = createTestImage(createCS(ColorSpaceSelector.WRAPPED_GRAY));\n+        BufferedImage destTest = createTestImage(createCS(ColorSpaceSelector.WRAPPED_RGB));\n+\n+        BufferedImage srcGold = createTestImage(createCS(ColorSpaceSelector.GRAY));\n+        BufferedImage destGold = createTestImage(createCS(ColorSpaceSelector.RGB));\n+\n+        ColorConvertOp gold = new ColorConvertOp(createCS(ColorSpaceSelector.PYCC), null);\n+        gold.filter(srcTest, destTest);\n+        gold.filter(srcGold, destGold);\n+\n+        if (!areImagesEqual(destTest, destGold)) {\n+            throw new RuntimeException(\"ICC test failed\");\n+        }\n+\n+        ColorConvertOp test = new ColorConvertOp(createCS(ColorSpaceSelector.WRAPPED_PYCC), null);\n+        test.filter(srcTest, destTest);\n+        test.filter(srcGold, destGold);\n+\n+        if (!areImagesEqual(destTest, destGold)) {\n+            throw new RuntimeException(\"Wrapper test failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/NonICCFilterTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,13 @@\n+import java.awt.BasicStroke;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Pageable;\n+import java.awt.print.Paper;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import jtreg.SkippedException;\n+\n@@ -27,0 +40,12 @@\n+ * @key printer\n+ * @summary Prints a rectangle to show the imageable area of a\n+ *          12in x 14in custom paper size.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @library \/test\/lib\n+ * @build PassFailJFrame\n+ * @build jtreg.SkippedException\n+ * @run main\/manual CustomPaper 4355514\n+ *\/\n+\n+\/*\n+ * @test\n@@ -31,1 +56,5 @@\n- * @run main\/manual CustomPaper\n+ * @library \/java\/awt\/regtesthelpers\n+ * @library \/test\/lib\n+ * @build PassFailJFrame\n+ * @build jtreg.SkippedException\n+ * @run main\/manual CustomPaper 4385157\n@@ -33,0 +62,1 @@\n+public class CustomPaper implements Pageable, Printable {\n@@ -34,50 +64,4 @@\n-import java.awt.*;\n-import java.awt.print.*;\n-import java.awt.geom.*;\n-\n-public class CustomPaper implements Pageable, Printable{\n-\n-  private static double PIXELS_PER_INCH = 72.0;\n-\n-  private PrinterJob printerJob;\n-  private PageFormat pageFormat;\n-\n-  CustomPaper(){\n-    printerJob = PrinterJob.getPrinterJob();\n-    createPageFormat();\n-  }\n-\n-  private void createPageFormat(){\n-    pageFormat = new PageFormat();\n-    Paper p = new Paper();\n-    double width   = 12.0*PIXELS_PER_INCH;\n-    double height  = 14.0*PIXELS_PER_INCH;\n-    double ix      = PIXELS_PER_INCH;\n-    double iy      = PIXELS_PER_INCH;\n-    double iwidth  = width  - 2.0*PIXELS_PER_INCH;\n-    double iheight = height - 2.0*PIXELS_PER_INCH;\n-    p.setSize(width, height);\n-    p.setImageableArea(ix, iy, iwidth, iheight);\n-    pageFormat.setPaper(p);\n-  }\n-\n-  public Printable getPrintable(int index){\n-    return this;\n-  }\n-\n-  public PageFormat getPageFormat(int index){\n-    return pageFormat;\n-  }\n-\n-  public int getNumberOfPages(){\n-    return 1;\n-  }\n-\n-  public void print(){\n-    if(printerJob.printDialog())\n-        {\n-      try{\n-        printerJob.setPageable(this);\n-        printerJob.print();\n-      }catch(Exception e){e.printStackTrace();}\n-    }\n+    private static final double PIXELS_PER_INCH = 72.0;\n+\n+    private final PrinterJob printerJob;\n+    private PageFormat pageFormat;\n@@ -85,14 +69,3 @@\n-  }\n-\n-  public int print(Graphics g, PageFormat pf, int pageIndex){\n-    if(pageIndex == 0){\n-        Graphics2D g2 = (Graphics2D)g;\n-        Rectangle2D r = new Rectangle2D.Double(pf.getImageableX(),\n-                                               pf.getImageableY(),\n-                                               pf.getImageableWidth(),\n-                                               pf.getImageableHeight());\n-      g2.setStroke(new BasicStroke(3.0f));\n-      g2.draw(r);\n-      return PAGE_EXISTS;\n-    }else{\n-      return NO_SUCH_PAGE;\n+    CustomPaper() {\n+        printerJob = PrinterJob.getPrinterJob();\n+        createPageFormat();\n@@ -100,23 +73,0 @@\n-  }\n-\n-  public static void main(String[] args){\n-\n-        String[] instructions =\n-        {\n-            \"You must have a printer that supports custom paper size of \",\n-            \"at least 12 x 14 inches to perform this test. It requires\",\n-            \"user interaction and you must have a 12 x 14 inch paper available.\",\n-            \" \",\n-            \"To test bug ID 4385157, click OK on print dialog box to print.\",\n-            \" \",\n-            \"To test bug ID 4355514, select the printer in the Print Setup dialog and add a \",\n-            \"custom paper size under Printer properties' Paper selection menu. \",\n-            \"Set the dimension  to width=12 inches and height=14 inches.\",\n-            \"Select this custom paper size before proceeding to print.\",\n-            \" \",\n-            \"Visual inspection of the one-page printout is needed. A passing\",\n-            \"test will print a rectangle of the imageable area which is approximately\",\n-            \"10 x 12 inches.\",\n-        };\n-        Sysout.createDialog( );\n-        Sysout.printInstructions( instructions );\n@@ -124,4 +74,11 @@\n-        CustomPaper pt = new CustomPaper();\n-        pt.print();\n-        \/\/System.exit (0);\n-  }\n+    private void createPageFormat() {\n+        pageFormat = new PageFormat();\n+        Paper p = new Paper();\n+        double width = 12.0 * PIXELS_PER_INCH;\n+        double height = 14.0 * PIXELS_PER_INCH;\n+        double iwidth = width - 2.0 * PIXELS_PER_INCH;\n+        double iheight = height - 2.0 * PIXELS_PER_INCH;\n+        p.setSize(width, height);\n+        p.setImageableArea(PIXELS_PER_INCH, PIXELS_PER_INCH, iwidth, iheight);\n+        pageFormat.setPaper(p);\n+    }\n@@ -129,1 +86,4 @@\n-}\n+    @Override\n+    public Printable getPrintable(int index) {\n+        return this;\n+    }\n@@ -131,0 +91,4 @@\n+    @Override\n+    public PageFormat getPageFormat(int index) {\n+        return pageFormat;\n+    }\n@@ -132,2 +96,4 @@\n-class Sysout {\n-   private static TestDialog dialog;\n+    @Override\n+    public int getNumberOfPages() {\n+        return 1;\n+    }\n@@ -135,6 +101,7 @@\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    private void print() throws PrinterException {\n+        if (printerJob.printDialog()) {\n+            printerJob.setPageable(this);\n+            printerJob.print();\n+        } else {\n+            PassFailJFrame.forceFail(\"Printing canceled by user\");\n+        }\n@@ -143,7 +110,14 @@\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    @Override\n+    public int print(Graphics g, PageFormat pf, int pageIndex) {\n+        if (pageIndex == 0) {\n+            Graphics2D g2 = (Graphics2D) g;\n+            Rectangle2D r = new Rectangle2D.Double(pf.getImageableX(),\n+                    pf.getImageableY(),\n+                    pf.getImageableWidth(),\n+                    pf.getImageableHeight());\n+            g2.setStroke(new BasicStroke(3.0f));\n+            g2.draw(r);\n+            return PAGE_EXISTS;\n+        } else {\n+            return NO_SUCH_PAGE;\n+        }\n@@ -152,0 +126,4 @@\n+    private static final String TOP = \"\"\"\n+         You must have a printer that supports custom paper size of\n+         at least 12 x 14 inches to perform this test. It requires\n+         user interaction and you must have a 12 x 14 inch paper available.\n@@ -153,4 +131,1 @@\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n+        \"\"\";\n@@ -158,0 +133,1 @@\n+    private static final String BOTTOM = \"\"\"\n@@ -159,4 +135,4 @@\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n+         Visual inspection of the one-page printout is needed. A passing\n+         test will print a rectangle of the imageable area which is\n+         approximately 10 x 12 inches.\n+        \"\"\";\n@@ -164,79 +140,18 @@\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n+    private static final String INSTRUCTIONS_4355514 = \"\"\"\n+         Select the printer in the Print Setup dialog and add a custom\n+         paper size under 'Printer properties' Paper selection menu.\n+         Set the dimension to width=12 inches and height=14 inches.\n+         Select this custom paper size before proceeding to print.\n+        \"\"\";\n+\n+    private static final String INSTRUCTIONS_4385157 = \"\"\"\n+         Click OK on print dialog box to print.\n+        \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        String instructions;\n+\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new SkippedException(\"Printer not configured or available.\"\n+                    + \" Test cannot continue.\");\n+        }\n@@ -244,1 +159,24 @@\n- }\/\/ TestDialog  class\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Select a test by passing 4355514 or 4385157\");\n+        }\n+\n+        instructions = switch (args[0]) {\n+            case \"4355514\" -> TOP + INSTRUCTIONS_4355514 + BOTTOM;\n+            case \"4385157\" -> TOP + INSTRUCTIONS_4385157 + BOTTOM;\n+            default -> throw new RuntimeException(\"Unknown bugid \" + args[0] + \".\"\n+                    + \"Valid values: 4355514 or 4385157\");\n+        };\n+\n+        PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n+                .title(\"CustomPaper Test Instructions\")\n+                .instructions(instructions)\n+                .testTimeOut(5)\n+                .rows((int) instructions.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+\n+        CustomPaper pt = new CustomPaper();\n+        pt.print();\n+        passFailJFrame.awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PageFormat\/CustomPaper.java","additions":135,"deletions":197,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +37,2 @@\n+import java.util.HexFormat;\n+import java.util.stream.LongStream;\n@@ -111,0 +114,24 @@\n+    @Test\n+    public void testZeroedOfAuto() {\n+        testZeroed(Arena.ofAuto());\n+    }\n+\n+    @Test\n+    public void testZeroedGlobal() {\n+        testZeroed(Arena.global());\n+    }\n+\n+    @Test\n+    public void testZeroedOfConfined() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            testZeroed(arena);\n+        }\n+    }\n+\n+    @Test\n+    public void testZeroedOfShared() {\n+        try (Arena arena = Arena.ofShared()) {\n+            testZeroed(arena);\n+        }\n+    }\n+\n@@ -122,0 +149,10 @@\n+\n+    private static final MemorySegment ZEROED_MEMORY = MemorySegment.ofArray(new byte[8102]);\n+\n+    void testZeroed(Arena arena) {\n+        long byteSize = ZEROED_MEMORY.byteSize();\n+        var segment = arena.allocate(byteSize, Long.BYTES);\n+        long mismatch = ZEROED_MEMORY.mismatch(segment);\n+        assertEquals(mismatch, -1);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestScope.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,1 +29,3 @@\n- * @run main GetStackTraceALotWhenPinned 25000\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm GetStackTraceALotWhenPinned 500000\n@@ -35,1 +37,3 @@\n- * @run main\/timeout=300 GetStackTraceALotWhenPinned 10000\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=300 GetStackTraceALotWhenPinned 200000\n@@ -41,0 +45,1 @@\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -45,1 +50,7 @@\n-        var counter = new AtomicInteger(Integer.parseInt(args[0]));\n+        \/\/ need at least two carrier threads when main thread is a virtual thread\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n+\n+        int iterations = Integer.parseInt(args[0]);\n+        var barrier = new Barrier(2);\n@@ -52,1 +63,4 @@\n-            while (counter.decrementAndGet() > 0) {\n+            for (int i = 0; i < iterations; i++) {\n+                \/\/ wait for main thread to arrive\n+                barrier.await();\n+\n@@ -66,1 +80,4 @@\n-        while (thread.isAlive()) {\n+        for (int i = 0; i < iterations; i++) {\n+            \/\/ wait for virtual thread to arrive\n+            barrier.await();\n+\n@@ -69,0 +86,1 @@\n+\n@@ -71,1 +89,1 @@\n-                System.out.format(\"%s %d remaining ...%n\", Instant.now(), counter.get());\n+                System.out.format(\"%s %d remaining ...%n\", Instant.now(), (iterations - i));\n@@ -76,0 +94,29 @@\n+\n+    \/**\n+     * Alow threads wait for each other to reach a common barrier point. This class does\n+     * not park threads that are waiting for the barrier to trip, instead it spins. This\n+     * makes it suitable for tests that use LockSupport.park or Thread.yield.\n+     *\/\n+    private static class Barrier {\n+        private final int parties;\n+        private final AtomicInteger count;\n+        private volatile int generation;\n+\n+        Barrier(int parties) {\n+            this.parties = parties;\n+            this.count = new AtomicInteger(parties);\n+        }\n+\n+        void await() {\n+            int g = generation;\n+            if (count.decrementAndGet() == 0) {\n+                count.set(parties);\n+                generation = g + 1;\n+            } else {\n+                while (generation == g) {\n+                    Thread.onSpinWait();\n+                }\n+            }\n+        }\n+\n+    }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenPinned.java","additions":53,"deletions":6,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.math.BigInteger;\n+\n+\/*\n+ * @test\n+ * @bug 8310813\n+ * @summary Check hashCode implementation against reference values\n+ *\/\n+public class HashCode {\n+\n+    \/\/ This test guards against inadvertent changes to BigInteger.hashCode,\n+    \/\/ by checking generated hashCode values against reference values\n+    \/\/ captured immediately before 8310813\n+\n+    public static void main(String[] args) {\n+        equals(          0, BigInteger.ZERO);\n+        equals(          1, BigInteger.ONE);\n+        equals(          2, BigInteger.TWO);\n+        equals(         10, BigInteger.TEN);\n+        equals(       -128, BigInteger.valueOf(Byte.MIN_VALUE));\n+        equals(        127, BigInteger.valueOf(Byte.MAX_VALUE));\n+        equals(     -32768, BigInteger.valueOf(Short.MIN_VALUE));\n+        equals(      32767, BigInteger.valueOf(Short.MAX_VALUE));\n+        equals(          0, BigInteger.valueOf(Character.MIN_VALUE));\n+        equals(      65535, BigInteger.valueOf(Character.MAX_VALUE));\n+        equals(-2147483648, BigInteger.valueOf(Integer.MIN_VALUE));\n+        equals( 2147483647, BigInteger.valueOf(Integer.MAX_VALUE));\n+        equals(-2147483648, BigInteger.valueOf(Long.MIN_VALUE));\n+        equals( 2147483616, BigInteger.valueOf(Long.MAX_VALUE));\n+        equals(         -1, BigInteger.valueOf(-1));\n+\n+        \/\/ a 37-byte negative number, generated at random\n+        equals( 1428257188, new BigInteger(\"\"\"\n+                -5573526435790097067262357965922443376770234990700620666883\\\n+                2705705469477701887396205062479\"\"\"));\n+        \/\/ a 123-byte positive number, generated at random\n+        equals( -412503667, new BigInteger(\"\"\"\n+                13093241912251296135908856604398494061635394768699286753760\\\n+                22827291528069076557720973813183142494646514532475660126948\\\n+                43316474303725664231917408569680292008962577772928370936861\\\n+                12952691245923210726443405774197400117701581498597123145452\\\n+                15111774818054200162634242662445757757255702394598235971294\\\n+                50\"\"\"));\n+    }\n+\n+    private static void equals(int expectedHashCode, BigInteger i) {\n+        int actualHashCode = i.hashCode();\n+        if (expectedHashCode != actualHashCode)\n+            throw new AssertionError(\"%s: expectedHashCode=%s, actual=%s\"\n+                    .formatted(i, expectedHashCode, actualHashCode));\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/HashCode.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,4 @@\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n@@ -450,1 +454,2 @@\n-    \/\/ Run only if the platform locale is en-GB\n+    \/\/ Run only if the underlying platform locale is en-GB\n+    \/\/ (Setting the java locale via command line properties does not substitute this)\n@@ -479,0 +484,26 @@\n+\n+    \/* Method is used by the LocaleProviders* related tests to launch a\n+     * LocaleProviders test method with the appropriate LocaleProvider (e.g. CLDR,\n+     * COMPAT, ETC.)\n+     *\/\n+    static void test(String prefList, String methodName, String... params) throws Throwable {\n+\n+        List<String> command = List.of(\n+                \"-ea\", \"-esa\",\n+                \"-cp\", Utils.TEST_CLASS_PATH,\n+                \/\/ Required for LocaleProvidersLogger\n+                \"-Djava.util.logging.config.class=LocaleProviders$LogConfig\",\n+                \"-Djava.locale.providers=\" + prefList,\n+                \"--add-exports=java.base\/sun.util.locale.provider=ALL-UNNAMED\",\n+                \"LocaleProviders\", methodName);\n+\n+        \/\/ Build process with arguments, if required by the method\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Stream.concat(command.stream(), Stream.of(params)).toList());\n+\n+        \/\/ Evaluate process status\n+        int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n+        if (exitCode != 0) {\n+            throw new RuntimeException(\"Unexpected exit code: \" + exitCode);\n+        }\n+    }\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleProviders.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8228465 8232871 8257964\n+ * @summary Test any Calendar Locale provider related issues\n+ * @library \/test\/lib\n+ * @build LocaleProviders\n+ * @modules java.base\/sun.util.locale.provider\n+ * @run junit\/othervm LocaleProvidersCalendar\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+\n+import static org.junit.jupiter.api.condition.OS.MAC;\n+import static org.junit.jupiter.api.condition.OS.WINDOWS;\n+\n+public class LocaleProvidersCalendar {\n+\n+    \/*\n+     * 8228465 (Windows only): Ensure correct ERA display name under HOST Windows\n+     *\/\n+    @Test\n+    @EnabledOnOs(WINDOWS)\n+    public void gregCalEraHost() throws Throwable {\n+        LocaleProviders.test(\"HOST\", \"bug8228465Test\");\n+    }\n+\n+    \/*\n+     * 8232871 (macOS only): Ensure correct Japanese calendar values under\n+     * HOST Mac.\n+     *\/\n+    @Test\n+    @EnabledOnOs(MAC)\n+    public void japaneseCalValuesHost() throws Throwable {\n+        LocaleProviders.test(\"HOST\", \"bug8232871Test\");\n+    }\n+\n+    \/*\n+     * 8257964 (macOS\/Windows only): Ensure correct Calendar::getMinimalDaysInFirstWeek\n+     * value under HOST Windows \/ Mac. Only run against machine with underlying\n+     * OS locale of en-GB.\n+     *\/\n+    @Test\n+    @EnabledOnOs({WINDOWS, MAC})\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    @EnabledIfSystemProperty(named = \"user.country\", matches = \"GB\")\n+    public void minDaysFirstWeekHost() throws Throwable {\n+        LocaleProviders.test(\"HOST\", \"bug8257964Test\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleProvidersCalendar.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8248695\n+ * @summary Test any java.time.DateTimeFormatter Locale provider related issues\n+ * @library \/test\/lib\n+ * @build LocaleProviders\n+ * @modules java.base\/sun.util.locale.provider\n+ * @run junit\/othervm LocaleProvidersDateTimeFormatter\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class LocaleProvidersDateTimeFormatter {\n+\n+    \/*\n+     * 8248695: Ensure DateTimeFormatter::ofLocalizedDate does not throw exception\n+     * under HOST (date only pattern leaks time field)\n+     *\/\n+    @Test\n+    public void dateOnlyJavaTimePattern() throws Throwable {\n+        LocaleProviders.test(\"HOST\", \"bug8248695Test\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleProvidersDateTimeFormatter.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 7198834 8001440 8013086 8013903 8027289 8232860\n+ * @summary Test any java.text.Format Locale provider related issues\n+ * @library \/test\/lib\n+ * @build LocaleProviders\n+ *        providersrc.spi.src.tznp\n+ *        providersrc.spi.src.tznp8013086\n+ * @modules java.base\/sun.util.locale.provider\n+ * @run junit\/othervm LocaleProvidersFormat\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+\n+import static org.junit.jupiter.api.condition.OS.MAC;\n+import static org.junit.jupiter.api.condition.OS.WINDOWS;\n+\n+public class LocaleProvidersFormat {\n+\n+    \/*\n+     * 7198834: Ensure under Windows\/HOST, adapter does not append an extra space for date patterns.\n+     *\/\n+    @Test\n+    @EnabledOnOs(WINDOWS)\n+    public void dateFormatExtraSpace() throws Throwable {\n+        LocaleProviders.test(\"HOST\", \"bug7198834Test\");\n+    }\n+\n+    \/*\n+     * 8001440: Ensure under CLDR, when number extension of the language\n+     * tag is invalid, test program does not throw exception when calling\n+     * NumberFormat::format.\n+     *\/\n+    @Test\n+    public void formatWithInvalidLocaleExtension() throws Throwable {\n+        LocaleProviders.test(\"CLDR\", \"bug8001440Test\");\n+    }\n+\n+    \/*\n+     * 8013086: Ensure a custom TimeZoneNameProvider does not cause an NPE\n+     * in simpleDateFormat, as SimpleDateFormat::matchZoneString expects the\n+     * name array is fully filled with non-null names.\n+     *\/\n+    @Test\n+    public void simpleDateFormatWithTZNProvider() throws Throwable {\n+        LocaleProviders.test(\"JRE,SPI\", \"bug8013086Test\", \"ja\", \"JP\");\n+        LocaleProviders.test(\"COMPAT,SPI\", \"bug8013086Test\", \"ja\", \"JP\");\n+    }\n+\n+    \/*\n+     * 8013903 (Windows only): Ensure HOST adapter with Japanese locale produces\n+     * the correct Japanese era, month, day names.\n+     *\/\n+    @Test\n+    @EnabledOnOs(WINDOWS)\n+    public void windowsJapaneseDateFields() throws Throwable {\n+        LocaleProviders.test(\"HOST,JRE\", \"bug8013903Test\");\n+        LocaleProviders.test(\"HOST\", \"bug8013903Test\");\n+        LocaleProviders.test(\"HOST,COMPAT\", \"bug8013903Test\");\n+    }\n+\n+    \/*\n+     * 8027289: Ensure if underlying system format locale is zh_CN, the Window's currency\n+     * symbol under HOST provider is \\u00A5, the yen (yuan) sign.\n+     *\/\n+    @Test\n+    @EnabledOnOs(WINDOWS)\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"zh\")\n+    @EnabledIfSystemProperty(named = \"user.country\", matches = \"CN\")\n+    public void windowsChineseCurrencySymbol() throws Throwable {\n+        LocaleProviders.test(\"JRE,HOST\", \"bug8027289Test\", \"FFE5\");\n+        LocaleProviders.test(\"COMPAT,HOST\", \"bug8027289Test\", \"FFE5\");\n+        LocaleProviders.test(\"HOST\", \"bug8027289Test\", \"00A5\");\n+    }\n+\n+    \/*\n+     * 8232860 (macOS\/Windows only): Ensure the Host adapter returns the number\n+     * pattern for number\/integer instances, which require optional fraction digits.\n+     *\/\n+    @Test\n+    @EnabledOnOs({WINDOWS, MAC})\n+    public void hostOptionalFracDigits() throws Throwable {\n+        LocaleProviders.test(\"HOST\", \"bug8232860Test\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleProvidersFormat.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8245241 8246721 8261919\n+ * @summary Test the Locale provider preference is logged\n+ * @library \/test\/lib\n+ * @build LocaleProviders\n+ * @modules java.base\/sun.util.locale.provider\n+ * @run junit\/othervm -Djdk.lang.Process.allowAmbiguousCommands=false LocaleProvidersLogger\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class LocaleProvidersLogger {\n+\n+    \/*\n+     * 8245241 8246721 8261919: Ensure if an incorrect system property for locale providers is set,\n+     * it should be logged and presented to the user. The option\n+     * jdk.lang.Process.allowAmbiguousCommands=false is needed for properly escaping\n+     * double quotes in the string argument.\n+     *\/\n+    @Test\n+    public void logIncorrectLocaleProvider() throws Throwable {\n+        LocaleProviders.test(\"FOO\", \"bug8245241Test\",\n+                \"Invalid locale provider adapter \\\"FOO\\\" ignored.\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleProvidersLogger.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,6 +26,5 @@\n- * @bug 6336885 7196799 7197573 7198834 8000245 8000615 8001440 8008577\n- *      8010666 8013086 8013233 8013903 8015960 8028771 8054482 8062006\n- *      8150432 8215913 8220227 8228465 8232871 8232860 8236495 8245241\n- *      8246721 8248695 8257964 8261919\n- * @summary tests for \"java.locale.providers\" system property\n- * @requires vm.flagless\n+ * @bug 6336885 7196799 7197573 8008577 8010666 8013233 8015960 8028771\n+ *      8054482 8062006 8150432 8215913 8220227 8236495\n+ * @summary General Locale provider test (ex: adapter loading). See the\n+ *          other LocaleProviders* test classes for more specific tests (ex:\n+ *          java.text.Format related bugs).\n@@ -34,5 +33,2 @@\n- *        providersrc.spi.src.tznp\n- *        providersrc.spi.src.tznp8013086\n- * @modules java.base\/sun.util.locale\n- *          java.base\/sun.util.locale.provider\n- * @run main\/othervm -Djdk.lang.Process.allowAmbiguousCommands=false LocaleProvidersRun\n+ * @modules java.base\/sun.util.locale.provider\n+ * @run junit\/othervm LocaleProvidersRun\n@@ -42,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -43,2 +40,8 @@\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.Utils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.DisabledIfSystemProperty;\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -46,0 +49,7 @@\n+import static org.junit.jupiter.api.condition.OS.WINDOWS;\n+\n+\/*\n+ * Note: If this test launches too many JVMs, consider increasing timeout.\n+ * As the LocaleProvider is set during java startup time, this test and the subclasses\n+ * will always have to launch a separate JVM for testing of different providers.\n+ *\/\n@@ -47,7 +57,0 @@\n-    public static void main(String[] args) throws Throwable {\n-        \/\/get the platform default locales\n-        Locale platDefLoc = Locale.getDefault(Locale.Category.DISPLAY);\n-        String defLang = platDefLoc.getLanguage();\n-        String defCtry = platDefLoc.getCountry();\n-        System.out.println(\"DEFLANG = \" + defLang);\n-        System.out.println(\"DEFCTRY = \" + defCtry);\n@@ -55,0 +58,9 @@\n+    private static String defLang;\n+    private static String defCtry;\n+    private static String defFmtLang;\n+    private static String defFmtCtry;\n+\n+    \/\/ Get the system default locale values. Used to decide param values for tests.\n+    @BeforeAll\n+    static void setUp() {\n+        Locale platDefLoc = Locale.getDefault(Locale.Category.DISPLAY);\n@@ -56,8 +68,28 @@\n-        String defFmtLang = platDefFormat.getLanguage();\n-        String defFmtCtry = platDefFormat.getCountry();\n-        System.out.println(\"DEFFMTLANG = \" + defFmtLang);\n-        System.out.println(\"DEFFMTCTRY = \" + defFmtCtry);\n-\n-        \/\/Run Test\n-        \/\/testing HOST is selected for the default locale,\n-        \/\/ if specified on Windows or MacOSX\n+        defLang = platDefLoc.getLanguage();\n+        defCtry = platDefLoc.getCountry();\n+        defFmtLang = platDefFormat.getLanguage();\n+        defFmtCtry = platDefFormat.getCountry();\n+\n+        \/\/ Print out system defaults for diagnostic purposes\n+        System.out.printf(\"DEFLANG = %s, DEFCTRY = %s, DEFFMTLANG = %s, DEFFMTCTRY = %s\",\n+                defLang, defCtry, defFmtLang, defFmtCtry);\n+    }\n+\n+    \/*\n+     * Test the adapter loading logic in LocaleProviderAdapter.\n+     * Ensures that correct fallbacks are implemented.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource\n+    public void adapterTest(String prefList, String param1,\n+                            String param2, String param3) throws Throwable {\n+        LocaleProviders.test(prefList, \"adapterTest\", param1, param2, param3);\n+    }\n+\n+    \/*\n+     * Data provider which only launches against the LocaleProvider::adapterTest\n+     * method. The arguments are dictated based off the operating system\/platform\n+     * Locale. Tests against variety of provider orders.\n+     *\/\n+    private static Stream<Arguments> adapterTest() {\n+        \/\/ Testing HOST is selected for the default locale if specified on Windows or MacOSX\n@@ -66,1 +98,1 @@\n-        if(osName.startsWith(\"Windows\") || osName.startsWith(\"Mac\")) {\n+        if (osName.startsWith(\"Windows\") || osName.startsWith(\"Mac\")) {\n@@ -69,1 +101,0 @@\n-        testRun(\"HOST,JRE\", \"adapterTest\", param1, defLang, defCtry);\n@@ -71,2 +102,2 @@\n-        \/\/testing HOST is NOT selected for the non-default locale, if specified\n-        \/\/Try to find the locale JRE supports which is not the platform default\n+        \/\/ Testing HOST is NOT selected for the non-default locale, if specified\n+        \/\/ try to find the locale JRE supports which is not the platform default\n@@ -76,1 +107,1 @@\n-        if (!defLang.equals(\"en\") && !defFmtLang.equals(\"en\")){\n+        if (!defLang.equals(\"en\") && !defFmtLang.equals(\"en\")) {\n@@ -79,1 +110,1 @@\n-        } else if(!defLang.equals(\"ja\") && !defFmtLang.equals(\"ja\")){\n+        } else if (!defLang.equals(\"ja\") && !defFmtLang.equals(\"ja\")) {\n@@ -86,66 +117,0 @@\n-        testRun(\"HOST,JRE\", \"adapterTest\", \"JRE\", param2, param3);\n-\n-        \/\/testing SPI is NOT selected, as there is none.\n-        testRun(\"SPI,JRE\", \"adapterTest\", \"JRE\", \"en\", \"US\");\n-        testRun(\"SPI,COMPAT\", \"adapterTest\", \"JRE\", \"en\", \"US\");\n-\n-        \/\/testing the order, variant #1. This assumes en_GB DateFormat data are\n-        \/\/ available both in JRE & CLDR\n-        testRun(\"CLDR,JRE\", \"adapterTest\", \"CLDR\", \"en\", \"GB\");\n-        testRun(\"CLDR,COMPAT\", \"adapterTest\", \"CLDR\", \"en\", \"GB\");\n-\n-        \/\/testing the order, variant #2. This assumes en_GB DateFormat data are\n-        \/\/ available both in JRE & CLDR\n-        testRun(\"JRE,CLDR\", \"adapterTest\", \"JRE\", \"en\", \"GB\");\n-        testRun(\"COMPAT,CLDR\", \"adapterTest\", \"JRE\", \"en\", \"GB\");\n-\n-        \/\/testing the order, variant #3 for non-existent locale in JRE\n-        \/\/ assuming \"haw\" is not in JRE.\n-        testRun(\"JRE,CLDR\", \"adapterTest\", \"CLDR\", \"haw\", \"\");\n-        testRun(\"COMPAT,CLDR\", \"adapterTest\", \"CLDR\", \"haw\", \"\");\n-\n-        \/\/testing the order, variant #4 for the bug 7196799. CLDR's \"zh\" data\n-        \/\/ should be used in \"zh_CN\"\n-        testRun(\"CLDR\", \"adapterTest\", \"CLDR\", \"zh\", \"CN\");\n-\n-        \/\/testing FALLBACK provider. SPI and invalid one cases.\n-        testRun(\"SPI\", \"adapterTest\", \"FALLBACK\", \"en\", \"US\");\n-        testRun(\"FOO\", \"adapterTest\", \"CLDR\", \"en\", \"US\");\n-        testRun(\"BAR,SPI\", \"adapterTest\", \"FALLBACK\", \"en\", \"US\");\n-\n-        \/\/testing 7198834 fix.\n-        testRun(\"HOST\", \"bug7198834Test\", \"\", \"\", \"\");\n-\n-        \/\/testing 8000245 fix.\n-        testRun(\"JRE\", \"tzNameTest\", \"Europe\/Moscow\", \"\", \"\");\n-        testRun(\"COMPAT\", \"tzNameTest\", \"Europe\/Moscow\", \"\", \"\");\n-\n-        \/\/testing 8000615 fix.\n-        testRun(\"JRE\", \"tzNameTest\", \"America\/Los_Angeles\", \"\", \"\");\n-        testRun(\"COMPAT\", \"tzNameTest\", \"America\/Los_Angeles\", \"\", \"\");\n-\n-        \/\/testing 8001440 fix.\n-        testRun(\"CLDR\", \"bug8001440Test\", \"\", \"\", \"\");\n-\n-        \/\/testing 8010666 fix.\n-        if (defLang.equals(\"en\")) {\n-            testRun(\"HOST\", \"bug8010666Test\", \"\", \"\", \"\");\n-        }\n-\n-        \/\/testing 8013086 fix.\n-        testRun(\"JRE,SPI\", \"bug8013086Test\", \"ja\", \"JP\", \"\");\n-        testRun(\"COMPAT,SPI\", \"bug8013086Test\", \"ja\", \"JP\", \"\");\n-\n-        \/\/testing 8013903 fix. (Windows only)\n-        testRun(\"HOST,JRE\", \"bug8013903Test\", \"\", \"\", \"\");\n-        testRun(\"HOST\", \"bug8013903Test\", \"\", \"\", \"\");\n-        testRun(\"HOST,COMPAT\", \"bug8013903Test\", \"\", \"\", \"\");\n-\n-        \/\/testing 8027289 fix, if the platform format default is zh_CN\n-        \/\/ this assumes Windows' currency symbol for zh_CN is \\u00A5, the yen\n-        \/\/ (yuan) sign.\n-        if (defFmtLang.equals(\"zh\") && defFmtCtry.equals(\"CN\")) {\n-            testRun(\"JRE,HOST\", \"bug8027289Test\", \"FFE5\", \"\", \"\");\n-            testRun(\"COMPAT,HOST\", \"bug8027289Test\", \"FFE5\", \"\", \"\");\n-            testRun(\"HOST\", \"bug8027289Test\", \"00A5\", \"\", \"\");\n-        }\n@@ -153,22 +118,33 @@\n-        \/\/testing 8220227 fix. (Windows only)\n-        if (!defLang.equals(\"en\")) {\n-            testRun(\"HOST\", \"bug8220227Test\", \"\", \"\", \"\");\n-        }\n-\n-        \/\/testing 8228465 fix. (Windows only)\n-        testRun(\"HOST\", \"bug8228465Test\", \"\", \"\", \"\");\n-\n-        \/\/testing 8232871 fix. (macOS only)\n-        testRun(\"HOST\", \"bug8232871Test\", \"\", \"\", \"\");\n-\n-        \/\/testing 8232860 fix. (macOS\/Windows only)\n-        testRun(\"HOST\", \"bug8232860Test\", \"\", \"\", \"\");\n-\n-        \/\/testing 8245241 fix.\n-        \/\/jdk.lang.Process.allowAmbiguousCommands=false is needed for properly escaping\n-        \/\/double quotes in the string argument.\n-        testRun(\"FOO\", \"bug8245241Test\",\n-            \"Invalid locale provider adapter \\\"FOO\\\" ignored.\", \"\", \"\");\n-\n-        \/\/testing 8248695 fix.\n-        testRun(\"HOST\", \"bug8248695Test\", \"\", \"\", \"\");\n+        return Stream.of(\n+                Arguments.of(\"HOST,JRE\", param1, defLang, defCtry),\n+                Arguments.of(\"HOST,JRE\", \"JRE\", param2, param3),\n+\n+                \/\/ Testing SPI is NOT selected, as there is none.\n+                Arguments.of(\"SPI,JRE\", \"JRE\", \"en\", \"US\"),\n+                Arguments.of(\"SPI,COMPAT\", \"JRE\", \"en\", \"US\"),\n+\n+                \/\/ Testing the order, variant #1. This assumes en_GB DateFormat data are\n+                \/\/ available both in JRE & CLDR\n+                Arguments.of(\"CLDR,JRE\", \"CLDR\", \"en\", \"GB\"),\n+                Arguments.of(\"CLDR,COMPAT\", \"CLDR\", \"en\", \"GB\"),\n+\n+                \/\/ Testing the order, variant #2. This assumes en_GB DateFormat data are\n+                \/\/ available both in JRE & CLDR\n+                Arguments.of(\"JRE,CLDR\", \"JRE\", \"en\", \"GB\"),\n+                Arguments.of(\"COMPAT,CLDR\", \"JRE\", \"en\", \"GB\"),\n+\n+                \/\/ Testing the order, variant #3 for non-existent locale in JRE\n+                \/\/ assuming \"haw\" is not in JRE.\n+                Arguments.of(\"JRE,CLDR\", \"CLDR\", \"haw\", \"\"),\n+                Arguments.of(\"COMPAT,CLDR\", \"CLDR\", \"haw\", \"\"),\n+\n+                \/\/ Testing the order, variant #4 for the bug 7196799. CLDR's \"zh\" data\n+                \/\/ should be used in \"zh_CN\"\n+                Arguments.of(\"CLDR\", \"CLDR\", \"zh\", \"CN\"),\n+\n+                \/\/ Testing FALLBACK provider. SPI and invalid one cases.\n+                Arguments.of(\"SPI\", \"FALLBACK\", \"en\", \"US\"),\n+                Arguments.of(\"FOO\", \"CLDR\", \"en\", \"US\"),\n+                Arguments.of(\"BAR,SPI\", \"FALLBACK\", \"en\", \"US\")\n+            );\n+    }\n@@ -176,2 +152,9 @@\n-        \/\/testing 8257964 fix. (macOS\/Windows only)\n-        testRun(\"HOST\", \"bug8257964Test\", \"\", \"\", \"\");\n+    \/*\n+     * 8010666: Test to ensure correct implementation of Currency\/LocaleNameProvider\n+     * in HOST Windows provider (English locale)\n+     *\/\n+    @Test\n+    @EnabledOnOs(WINDOWS)\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void currencyNameProviderWindowsHost() throws Throwable {\n+        LocaleProviders.test(\"HOST\", \"bug8010666Test\");\n@@ -180,16 +163,9 @@\n-    private static void testRun(String prefList, String methodName,\n-            String param1, String param2, String param3) throws Throwable {\n-\n-        \/\/ Build process (without VM flags)\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                \"-ea\", \"-esa\",\n-                \"-cp\", Utils.TEST_CLASS_PATH,\n-                \"-Djava.util.logging.config.class=LocaleProviders$LogConfig\",\n-                \"-Djava.locale.providers=\" + prefList,\n-                \"--add-exports=java.base\/sun.util.locale.provider=ALL-UNNAMED\",\n-                \"LocaleProviders\", methodName, param1, param2, param3);\n-        \/\/ Evaluate process status\n-        int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n-        if (exitCode != 0) {\n-            throw new RuntimeException(\"Unexpected exit code: \" + exitCode);\n-        }\n+    \/*\n+     * 8220227: Ensure Locale::getDisplayCountry does not display error message\n+     * under HOST Windows (non-english locale)\n+     *\/\n+    @Test\n+    @EnabledOnOs(WINDOWS)\n+    @DisabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void nonEnglishDisplayCountryHost() throws Throwable {\n+        LocaleProviders.test(\"HOST\", \"bug8220227Test\");\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleProvidersRun.java","additions":117,"deletions":141,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8000245 8000615\n+ * @summary Test any TimeZone Locale provider related issues\n+ * @library \/test\/lib\n+ * @build LocaleProviders\n+ *        providersrc.spi.src.tznp\n+ *        providersrc.spi.src.tznp8013086\n+ * @modules java.base\/sun.util.locale.provider\n+ * @run junit\/othervm LocaleProvidersTimeZone\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class LocaleProvidersTimeZone {\n+\n+    \/*\n+     * 8000245 and 8000615: Ensure preference is followed, even with a custom\n+     * SPI defined.\n+     *\/\n+    @Test\n+    public void timeZoneWithCustomProvider() throws Throwable {\n+        LocaleProviders.test(\"JRE\", \"tzNameTest\", \"Europe\/Moscow\");\n+        LocaleProviders.test(\"COMPAT\", \"tzNameTest\", \"Europe\/Moscow\");\n+        LocaleProviders.test(\"JRE\", \"tzNameTest\", \"America\/Los_Angeles\");\n+        LocaleProviders.test(\"COMPAT\", \"tzNameTest\", \"America\/Los_Angeles\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleProvidersTimeZone.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323659\n+ * @summary Ensures that the implementation of LTQ add and put methods does\n+ *  not call overridable offer. This test specifically asserts implementation\n+ *  details of LTQ. It's not that such impl details cannot change, just that\n+ *  such a change should be deliberately done with suitable consideration\n+ *  to compatibility.\n+ * @run testng SubclassTest\n+ *\/\n+\n+import java.util.concurrent.LinkedTransferQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class SubclassTest {\n+\n+    public void testPut() {\n+        var queue = new TestLinkedTransferQueue();\n+        queue.put(new Object());\n+        assertEquals(queue.size(), 1);\n+    }\n+\n+    public void testAdd() {\n+        var queue = new TestLinkedTransferQueue();\n+        queue.add(new Object());\n+        assertEquals(queue.size(), 1);\n+    }\n+\n+    public void testTimedOffer() {\n+        var queue = new TestLinkedTransferQueue();\n+        queue.offer(new Object(), 60, TimeUnit.SECONDS);\n+        assertEquals(queue.size(), 1);\n+    }\n+\n+    static class TestLinkedTransferQueue extends LinkedTransferQueue<Object> {\n+        @Override\n+        public boolean offer(Object obj) {\n+            return false;  \/\/  simulate fails to add the given obj\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/LinkedTransferQueue\/SubclassTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules java.base\/java.util.concurrent:open\n@@ -30,0 +31,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -31,0 +34,1 @@\n+import java.util.concurrent.LinkedTransferQueue;\n@@ -36,2 +40,20 @@\n-    private static void testFairness(boolean fair,\n-                                     final BlockingQueue<Integer> q)\n+    private final static VarHandle underlyingTransferQueueAccess;\n+\n+    static {\n+        try {\n+            underlyingTransferQueueAccess =\n+                MethodHandles.privateLookupIn(\n+                    SynchronousQueue.class,\n+                    MethodHandles.lookup()\n+                ).findVarHandle(\n+                    SynchronousQueue.class,\n+                    \"transferer\",\n+                    Class.forName(SynchronousQueue.class.getName() + \"$Transferer\")\n+            );\n+        } catch (Exception ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+\n+    private static void testFairness(boolean fair, final SynchronousQueue<Integer> q)\n@@ -40,0 +62,3 @@\n+        final LinkedTransferQueue<Integer> underlying =\n+            (LinkedTransferQueue<Integer>)underlyingTransferQueueAccess.get(q);\n+\n@@ -56,2 +81,2 @@\n-            \/\/ Probably unnecessary, but should be bullet-proof\n-            while (t.getState() == Thread.State.RUNNABLE)\n+            \/\/ Wait until previous put:ing thread is provably parked\n+            while (underlying.size() < (i + 1))\n@@ -59,0 +84,3 @@\n+\n+            if (underlying.size() > (i + 1))\n+                throw new Error(\"Unexpected number of waiting producers: \" + i);\n@@ -71,3 +99,3 @@\n-        testFairness(false, new SynchronousQueue<Integer>());\n-        testFairness(false, new SynchronousQueue<Integer>(false));\n-        testFairness(true,  new SynchronousQueue<Integer>(true));\n+        testFairness(false, new SynchronousQueue<>());\n+        testFairness(false, new SynchronousQueue<>(false));\n+        testFairness(true,  new SynchronousQueue<>(true));\n","filename":"test\/jdk\/java\/util\/concurrent\/SynchronousQueue\/Fairness.java","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ *          java.base\/javax.crypto:+open\n@@ -91,1 +92,1 @@\n-                KEM kem1 = KEM.getInstance(\"RSA-KEM\", p);\n+                KEM kem1 = getKemImpl(p);\n@@ -104,1 +105,1 @@\n-                KEM kem2 = KEM.getInstance(\"RSA-KEM\", p);\n+                KEM kem2 = getKemImpl(p);\n@@ -125,0 +126,8 @@\n+    \/\/ To bypass the JCE security provider signature check\n+    private static KEM getKemImpl(Provider p) throws Exception {\n+        var ctor = KEM.class.getDeclaredConstructor(\n+                String.class, KEMSpi.class, Provider.class);\n+        ctor.setAccessible(true);\n+        return ctor.newInstance(\"RSA-KEM\", new KEMImpl(), p);\n+    }\n+\n","filename":"test\/jdk\/javax\/crypto\/KEM\/RSA_KEM.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main ClassLeakTest\n+ * @run main\/othervm ClassLeakTest\n@@ -36,0 +36,1 @@\n+import java.lang.management.ManagementFactory;\n@@ -51,1 +52,0 @@\n-\n@@ -59,3 +59,2 @@\n-        @SuppressWarnings(\"removal\")\n-        PrivateMLet mlet = new PrivateMLet(urls, null, false);\n-        Class<?> shadowClass = mlet.loadClass(TestMBean.class.getName());\n+        Test loaderMBean = new Test(urls);\n+        Class<?> shadowClass = loaderMBean.loadClass(TestMBean.class.getName());\n@@ -63,1 +62,1 @@\n-            System.out.println(\"TEST INVALID: MLet got original \" +\n+            System.out.println(\"TEST INVALID: MBean got original \" +\n@@ -70,2 +69,2 @@\n-        ObjectName mletName = new ObjectName(\"x:type=mlet\");\n-        mbs.registerMBean(mlet, mletName);\n+        ObjectName loaderMBeanName = new ObjectName(\"x:name=loader\");\n+        mbs.registerMBean(loaderMBean, loaderMBeanName);\n@@ -74,1 +73,1 @@\n-        mbs.createMBean(Test.class.getName(), testName, mletName);\n+        mbs.createMBean(Test.class.getName(), testName, loaderMBeanName);\n@@ -77,1 +76,1 @@\n-        if (testLoader != mlet) {\n+        if (testLoader != loaderMBean) {\n@@ -112,0 +111,1 @@\n+        WeakReference mbeanRef = new WeakReference(loaderMBean);\n@@ -113,4 +113,2 @@\n-        mbs.unregisterMBean(mletName);\n-\n-        WeakReference mletRef = new WeakReference(mlet);\n-        mlet = null;\n+        mbs.unregisterMBean(loaderMBeanName);\n+        loaderMBean = null;\n@@ -120,1 +118,1 @@\n-        for (int i = 0; i < 10000 && mletRef.get() != null; i++) {\n+        for (int i = 0; i < 10000 && mbeanRef.get() != null; i++) {\n@@ -125,1 +123,1 @@\n-        if (mletRef.get() == null)\n+        if (mbeanRef.get() == null)\n@@ -139,4 +137,7 @@\n-    public static class Test implements TestMBean {\n-        public Test() {}\n-        public Test(int x) {}\n-\n+    public static class Test extends URLClassLoader implements TestMBean, PrivateClassLoader {\n+        public Test() {\n+            super(new URL[0], null);\n+        }\n+        public Test(URL[] urls) {\n+            super(urls, null);\n+        }\n","filename":"test\/jdk\/javax\/management\/Introspector\/ClassLeakTest.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.net.URLClassLoader;\n@@ -38,1 +39,0 @@\n-import javax.management.loading.MLet;\n@@ -98,1 +98,1 @@\n-        \/\/ Wich method is used to create the MBean is indicated by \"how\"\n+        \/\/ Which method is used to create the MBean is indicated by \"how\"\n@@ -378,1 +378,1 @@\n-                final ObjectName loaderName = registerMLet(server);\n+                final ObjectName loaderName = registerMB(server);\n@@ -407,1 +407,1 @@\n-                        registerMLet(server), params, signature);\n+                        registerMB(server), params, signature);\n@@ -425,1 +425,1 @@\n-        \/\/ This is a bit of a hack - we use an MLet that delegates to the\n+        \/\/ Create an MBean that delegates to the\n@@ -430,2 +430,2 @@\n-        public ObjectName registerMLet(MBeanServer server) throws Exception {\n-            final ObjectName name = new ObjectName(\"test:type=MLet\");\n+        public ObjectName registerMB(MBeanServer server) throws Exception {\n+            final ObjectName name = new ObjectName(\"test:type=TestMBean\");\n@@ -435,4 +435,2 @@\n-            @SuppressWarnings(\"removal\")\n-            final MLet mlet = new MLet(new URL[0],\n-                    ClassLoader.getSystemClassLoader());\n-            return server.registerMBean(mlet, name).getObjectName();\n+            final TestMBean mbean = new Test();\n+            return server.registerMBean(mbean, name).getObjectName();\n@@ -443,1 +441,1 @@\n-     *A Wombat MBean that can throw exceptions or errors in any of the\n+     * A Wombat MBean that can throw exceptions or errors in any of the\n@@ -517,0 +515,9 @@\n+    public static interface TestMBean {\n+    }\n+\n+    public static class Test extends URLClassLoader implements TestMBean {\n+        public Test() {\n+            super(new URL[0], ClassLoader.getSystemClassLoader());\n+        }\n+    }\n+\n","filename":"test\/jdk\/javax\/management\/MBeanServer\/PostExceptionTest.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        \/\/ Create an MLet that can load the same class names but\n+        \/\/ Create a SpyLoader MBean that can load the same class names but\n@@ -108,4 +108,0 @@\n-    \/* We originally had this extend MLet but for some reason that\n-       stopped the bug from happening.  Some side-effect of registering\n-       the MLet in the MBean server caused it not to fail when asked\n-       to load Z[].  *\/\n@@ -120,13 +116,0 @@\n-        \/*\n-        public Class loadClass(String name) throws ClassNotFoundException {\n-            System.out.println(\"loadClass: \" + name);\n-            return super.loadClass(name);\n-        }\n-\n-        public Class loadClass(String name, boolean resolve)\n-                throws ClassNotFoundException {\n-            System.out.println(\"loadClass: \" + name + \", \" + resolve);\n-            return super.loadClass(name, resolve);\n-        }\n-        *\/\n-\n","filename":"test\/jdk\/javax\/management\/loading\/ArrayClassTest.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6500139\n- * @summary Test parsing error when the mlet file is\n- *          located in the web server's document root.\n- * @author Luis-Miguel Alventosa\n- *\n- * @run clean DocumentRootTest\n- * @run build DocumentRootTest\n- * @run main DocumentRootTest\n- *\/\n-\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import javax.management.loading.MLetContent;\n-\n-@SuppressWarnings(\"removal\")\n-public class DocumentRootTest {\n-    public static int test(URL documentBase, URL codeBase) {\n-        int error = 0;\n-        MLetContent mc = new MLetContent(\n-                documentBase,\n-                new HashMap<String,String>(),\n-                new ArrayList<String>(),\n-                new ArrayList<String>());\n-        System.out.println(\"\\nACTUAL   DOCUMENT BASE = \" + mc.getDocumentBase());\n-        System.out.println(\"EXPECTED DOCUMENT BASE = \" + documentBase);\n-        if (!documentBase.equals(mc.getDocumentBase())) {\n-            System.out.println(\"ERROR: Wrong document base\");\n-            error++;\n-        };\n-        System.out.println(\"ACTUAL   CODEBASE = \" + mc.getCodeBase());\n-        System.out.println(\"EXPECTED CODEBASE = \" + codeBase);\n-        if (!codeBase.equals(mc.getCodeBase())) {\n-            System.out.println(\"ERROR: Wrong code base\");\n-            error++;\n-        };\n-        return error;\n-    }\n-    public static void main(String[] args) throws Exception {\n-        int error = 0;\n-        error += test(new URL(\"file:\/mlet.txt\"), new URL(\"file:\/\"));\n-        error += test(new URL(\"http:\/\/localhost\/mlet.txt\"), new URL(\"http:\/\/localhost\/\"));\n-        if (error > 0) {\n-            System.out.println(\"\\nTest FAILED!\\n\");\n-            throw new IllegalArgumentException(\"Test FAILED!\");\n-        } else {\n-            System.out.println(\"\\nTest PASSED!\\n\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/loading\/DocumentRootTest.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 5018593\n- * @summary Test that calling getMBeansFromURL(url) with a bogus URL on a\n- *          given MLet instance throws a ServiceNotFoundException exception\n- *          with a non null cause.\n- * @author Luis-Miguel Alventosa\n- *\n- * @run clean GetMBeansFromURLTest\n- * @run build GetMBeansFromURLTest\n- * @run main GetMBeansFromURLTest\n- *\/\n-\n-import javax.management.MBeanServer;\n-import javax.management.MBeanServerFactory;\n-import javax.management.ObjectName;\n-import javax.management.ServiceNotFoundException;\n-import javax.management.loading.MLet;\n-\n-@SuppressWarnings(\"removal\")\n-public class GetMBeansFromURLTest {\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        boolean error = false;\n-\n-        \/\/ Instantiate the MBean server\n-        \/\/\n-        System.out.println(\"Create the MBean server\");\n-        MBeanServer mbs = MBeanServerFactory.createMBeanServer();\n-\n-        \/\/ Instantiate an MLet\n-        \/\/\n-        System.out.println(\"Create the MLet\");\n-        MLet mlet = new MLet();\n-\n-        \/\/ Register the MLet MBean with the MBeanServer\n-        \/\/\n-        System.out.println(\"Register the MLet MBean\");\n-        ObjectName mletObjectName = new ObjectName(\"Test:type=MLet\");\n-        mbs.registerMBean(mlet, mletObjectName);\n-\n-        \/\/ Call getMBeansFromURL\n-        \/\/\n-        System.out.println(\"Call mlet.getMBeansFromURL(<url>)\");\n-        try {\n-            mlet.getMBeansFromURL(\"bogus:\/\/whatever\");\n-            System.out.println(\"TEST FAILED: Expected \" +\n-                               ServiceNotFoundException.class +\n-                               \" exception not thrown.\");\n-            error = true;\n-        } catch (ServiceNotFoundException e) {\n-            if (e.getCause() == null) {\n-                System.out.println(\"TEST FAILED: Got null cause in \" +\n-                                   ServiceNotFoundException.class +\n-                                   \" exception.\");\n-                error = true;\n-            } else {\n-                System.out.println(\"TEST PASSED: Got non-null cause in \" +\n-                                   ServiceNotFoundException.class +\n-                                   \" exception.\");\n-                error = false;\n-            }\n-            e.printStackTrace(System.out);\n-        }\n-\n-        \/\/ Unregister the MLet MBean\n-        \/\/\n-        System.out.println(\"Unregister the MLet MBean\");\n-        mbs.unregisterMBean(mletObjectName);\n-\n-        \/\/ Release MBean server\n-        \/\/\n-        System.out.println(\"Release the MBean server\");\n-        MBeanServerFactory.releaseMBeanServer(mbs);\n-\n-        \/\/ End Test\n-        \/\/\n-        System.out.println(\"Bye! Bye!\");\n-        if (error) System.exit(1);\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/loading\/GetMBeansFromURLTest.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,155 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4969756\n- * @summary Test that the same native library coming from the same jar file can\n- * be loaded twice by two different MLets on the same JVM without conflict.\n- * @author Luis-Miguel Alventosa\n- *\n- * @run clean LibraryLoaderTest\n- * @run build LibraryLoaderTest\n- * @run main\/othervm LibraryLoaderTest\n- *\/\n-\n-import java.io.File;\n-import java.util.Set;\n-import javax.management.Attribute;\n-import javax.management.MBeanServer;\n-import javax.management.MBeanServerFactory;\n-import javax.management.ObjectInstance;\n-import javax.management.ObjectName;\n-import javax.management.ReflectionException;\n-\n-public class LibraryLoaderTest {\n-\n-    private static final String mletInfo[][] = {\n-        {\"testDomain:type=MLet,index=0\", \"UseNativeLib0.html\"},\n-        {\"testDomain:type=MLet,index=1\", \"UseNativeLib1.html\"}\n-    };\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        String osName = System.getProperty(\"os.name\");\n-        System.out.println(\"os.name=\" + osName);\n-        String osArch = System.getProperty(\"os.arch\");\n-        System.out.println(\"os.name=\" + osArch);\n-\n-        \/\/ Check for supported platforms:\n-        \/\/\n-        \/\/ Windows\/x86\n-        \/\/\n-        if ((!(osName.startsWith(\"Windows\") && osArch.equals(\"x86\")))) {\n-            System.out.println(\n-              \"This test runs only on Windows\/x86 platforms\");\n-            System.out.println(\"Bye! Bye!\");\n-            return;\n-        }\n-\n-        String libPath = System.getProperty(\"java.library.path\");\n-        System.out.println(\"java.library.path=\" + libPath);\n-        String testSrc = System.getProperty(\"test.src\");\n-        System.out.println(\"test.src=\" + testSrc);\n-        String workingDir = System.getProperty(\"user.dir\");\n-        System.out.println(\"user.dir=\" + workingDir);\n-\n-        String urlCodebase;\n-        if (testSrc.startsWith(\"\/\")) {\n-            urlCodebase =\n-                \"file:\" + testSrc.replace(File.separatorChar, '\/') + \"\/\";\n-        } else {\n-            urlCodebase =\n-                \"file:\/\" + testSrc.replace(File.separatorChar, '\/') + \"\/\";\n-        }\n-\n-        \/\/ Create MBeanServer\n-        \/\/\n-        MBeanServer server = MBeanServerFactory.newMBeanServer();\n-\n-        \/\/ Create MLet instances and call getRandom on the loaded MBeans\n-        \/\/\n-        for (int i = 0; i < mletInfo.length; i++) {\n-            \/\/ Create ObjectName for MLet\n-            \/\/\n-            ObjectName mlet = new ObjectName(mletInfo[i][0]);\n-            server.createMBean(\"javax.management.loading.MLet\", mlet);\n-            System.out.println(\"MLet = \" + mlet);\n-\n-            \/\/ Display old library directory and set it to test.classes\n-            \/\/\n-            String libraryDirectory =\n-                (String) server.getAttribute(mlet, \"LibraryDirectory\");\n-            System.out.println(\"Old Library Directory = \" +\n-                               libraryDirectory);\n-            Attribute attribute =\n-                new Attribute(\"LibraryDirectory\", workingDir);\n-            server.setAttribute(mlet, attribute);\n-            libraryDirectory =\n-                (String) server.getAttribute(mlet, \"LibraryDirectory\");\n-            System.out.println(\"New Library Directory = \" +\n-                               libraryDirectory);\n-\n-            \/\/ Get MBeans from URL\n-            \/\/\n-            String mletURL = urlCodebase + mletInfo[i][1];\n-            System.out.println(\"MLet URL = \" + mletURL);\n-            Object[] params = new Object[] { mletURL };\n-            String[] signature = new String[] {\"java.lang.String\"};\n-            Object res[] = ((Set<?>) server.invoke(mlet,\n-                                                   \"getMBeansFromURL\",\n-                                                   params,\n-                                                   signature)).toArray();\n-\n-            \/\/ Iterate through all the loaded MBeans\n-            \/\/\n-            for (int j = 0; j < res.length; j++) {\n-                \/\/ Now ensure none of the returned objects is a Throwable\n-                \/\/\n-                if (res[j] instanceof Throwable) {\n-                    ((Throwable) res[j]).printStackTrace(System.out);\n-                    throw new Exception(\"Failed to load the MBean #\" + j\n-                        ,(Throwable)res[j]);\n-                }\n-\n-                \/\/ On each of the loaded MBeans, try to invoke their\n-                \/\/ native operation\n-                \/\/\n-                Object result = null;\n-                try {\n-                    ObjectName mbean =\n-                        ((ObjectInstance) res[j]).getObjectName();\n-                    result = server.getAttribute(mbean, \"Random\");\n-                    System.out.println(\"MBean #\" + j + \" = \" + mbean);\n-                    System.out.println(\"Random number = \" + result);\n-                } catch (ReflectionException e) {\n-                    e.getTargetException().printStackTrace(System.out);\n-                    throw new Exception (\"A ReflectionException \"\n-                            + \"occured when attempting to invoke \"\n-                            + \"a native library based operation.\",\n-                            e.getTargetException());\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/loading\/LibraryLoader\/LibraryLoaderTest.java","additions":0,"deletions":155,"binary":false,"changes":155,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-<HTML>\n-<MLET\n-\tCODE = \"UseNativeLib.class\"\n-\tARCHIVE = \"native.jar\"\n-\tNAME = \"mletTests:type=nativeLibLoading,index=0.0\"\n->\n-<\/MLET>\n-<MLET\n-\tCODE = \"UseNativeLib.class\"\n-\tARCHIVE = \"native.jar\"\n-\tNAME = \"mletTests:type=nativeLibLoading,index=0.1\"\n->\n-<\/MLET>\n-<BODY>\n-\n-Test MLet.\n-\n-<\/BODY>\n-<\/HTML>\n","filename":"test\/jdk\/javax\/management\/loading\/LibraryLoader\/UseNativeLib0.html","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-<HTML>\n-<MLET\n-\tCODE = \"UseNativeLib.class\"\n-\tARCHIVE = \"native.jar\"\n-\tNAME = \"mletTests:type=nativeLibLoading,index=1.0\"\n->\n-<\/MLET>\n-<MLET\n-\tCODE = \"UseNativeLib.class\"\n-\tARCHIVE = \"native.jar\"\n-\tNAME = \"mletTests:type=nativeLibLoading,index=1.1\"\n->\n-<\/MLET>\n-<BODY>\n-\n-Test MLet.\n-\n-<\/BODY>\n-<\/HTML>\n","filename":"test\/jdk\/javax\/management\/loading\/LibraryLoader\/UseNativeLib1.html","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-#include <jni.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-JNIEXPORT jint JNICALL Java_UseNativeLib_getRandom(JNIEnv *env, jobject obj) {\n-        return rand();\n-}\n-\n-#ifdef __cplusplus\n-}\n-#endif\n","filename":"test\/jdk\/javax\/management\/loading\/LibraryLoader\/jar_src\/RandomGen.c","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-#include <jni.h>\n-\n-#ifndef RandomGen\n-#define RandomGen\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-JNIEXPORT jint JNICALL Java_RandomGen_getRandom\n-  (JNIEnv *, jobject);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif\n","filename":"test\/jdk\/javax\/management\/loading\/LibraryLoader\/jar_src\/RandomGen.h","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public class UseNativeLib implements java.io.Serializable, UseNativeLibMBean {\n-\n-    public native int getRandom();\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"genrandom\");\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/javax\/management\/loading\/LibraryLoader\/jar_src\/UseNativeLib.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public interface UseNativeLibMBean {\n-    public int getRandom();\n-}\n","filename":"test\/jdk\/javax\/management\/loading\/LibraryLoader\/jar_src\/UseNativeLibMBean.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"filename":"test\/jdk\/javax\/management\/loading\/LibraryLoader\/native.jar","binary":true,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4836468\n- * @summary Test that the getClassLoaderRepository permission is not necessary\n- * for the test codebase as it is executed by the MLet code using\n- * doPrivileged.\n- * @author Luis-Miguel Alventosa\n- *\n- * @run clean MLetCommand\n- * @run build MLetCommand\n- * @run main\/othervm\/java.security.policy=policy MLetCommand\n- *\/\n-\n-import javax.management.MBeanServer;\n-import javax.management.MBeanServerFactory;\n-import javax.management.ObjectName;\n-import java.io.File;\n-\n-@SuppressWarnings(\"removal\")\n-public class MLetCommand {\n-\n-    public static void main(String[] args) throws Exception {\n-        if (System.getSecurityManager() == null)\n-            throw new IllegalStateException(\"No security manager installed!\");\n-\n-        System.out.println(\"java.security.policy=\" +\n-                           System.getProperty(\"java.security.policy\"));\n-\n-        \/\/ Instantiate the MBean server\n-        \/\/\n-        System.out.println(\"Create the MBean server\");\n-        MBeanServer mbs = MBeanServerFactory.createMBeanServer();\n-        \/\/ Register the MLetMBean\n-        \/\/\n-        System.out.println(\"Create MLet MBean\");\n-        ObjectName mlet = new ObjectName(\"MLetTest:name=MLetMBean\");\n-        mbs.createMBean(\"javax.management.loading.MLet\", mlet);\n-        \/\/ Test OK!\n-        \/\/\n-        System.out.println(\"Bye! Bye!\");\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/loading\/MLetCLR\/MLetCommand.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-\n-grant {\n-  permission java.util.PropertyPermission \"*\", \"read\";\n-  permission javax.management.MBeanServerPermission \"createMBeanServer\";\n-  permission javax.management.MBeanPermission \"javax.management.loading.MLet#-[-]\", \"instantiate\";\n-  permission javax.management.MBeanPermission \"javax.management.loading.MLet#-[MLetTest:name=MLetMBean]\", \"registerMBean\";\n-  permission java.lang.RuntimePermission \"createClassLoader\";\n-};\n","filename":"test\/jdk\/javax\/management\/loading\/MLetCLR\/policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4796780\n- * @summary The class MLetContentTest becomes public\n- * @author Shanliang JIANG\n- *\n- * @run clean MLetContentTest\n- * @run build MLetContentTest\n- * @run main MLetContentTest\n- *\/\n-\n-import java.util.*;\n-import java.net.*;\n-\n-import javax.management.loading.*;\n-\n-@SuppressWarnings(\"removal\")\n-public class MLetContentTest {\n-    public static void main(String[] args) throws Exception {\n-        System.out.println(\">>> General test for the public class MLetContent.\");\n-\n-        Map<String,String> attributes = new HashMap();\n-        attributes.put(\"archive\", archive);\n-        attributes.put(\"Archive\", \"hahaha\");\n-\n-        attributes.put(\"code\", code);\n-        attributes.put(\"codE\", \"hihi\");\n-\n-        attributes.put(\"object\", object);\n-        attributes.put(\"obJect\", \"toto\");\n-\n-        attributes.put(\"name\", name);\n-        attributes.put(\"NAME\", \"titi\");\n-\n-        attributes.put(\"version\", version);\n-        attributes.put(\"VeRsIoN\", \"tttt\");\n-\n-        List<String> types = new ArrayList();\n-        types.add(\"my type\");\n-\n-        List<String> values = new ArrayList();\n-        values.add(\"my values\");\n-\n-        URL url = new URL(baseUrl+myfile);\n-        MLetContent content = new MLetContent(url, attributes, types, values);\n-\n-        if (!attributes.equals(content.getAttributes())) {\n-            throw new RuntimeException(\"The user specific attributes are changed.\");\n-        }\n-\n-        if (!url.equals(content.getDocumentBase())) {\n-            throw new RuntimeException(\"The user specific document bas is changed.\");\n-        }\n-\n-        if (!archive.equals(content.getJarFiles())) {\n-            throw new RuntimeException(\"The user specific archive files are changed.\");\n-        }\n-\n-        if (!code.equals(content.getCode())) {\n-            throw new RuntimeException(\"The user specific code is changed.\");\n-        }\n-\n-        if (!object.equals(content.getSerializedObject())) {\n-            throw new RuntimeException(\"The user specific object is changed.\");\n-        }\n-\n-        if (!name.equals(content.getName())) {\n-            throw new RuntimeException(\"The user specific name is changed.\");\n-        }\n-\n-        if (!version.equals(content.getVersion())) {\n-            throw new RuntimeException(\"The user specific version is changed.\");\n-        }\n-\n-        if (!types.equals(content.getParameterTypes())) {\n-            throw new RuntimeException(\"The user specific types are changed.\");\n-        }\n-\n-        if (!values.equals(content.getParameterValues())) {\n-            throw new RuntimeException(\"The user specific values are changed.\");\n-        }\n-\n-        if (!baseUrl.equals(content.getCodeBase().toString())) {\n-            throw new RuntimeException(\"The user specific base url are changed.\");\n-        }\n-\n-        url = new URL(baseUrl);\n-        attributes.put(\"codebase\", codebase);\n-        content = new MLetContent(url, attributes, types, values);\n-\n-        if (!content.getCodeBase().toString().equals(baseUrl+codebase)) {\n-            throw new RuntimeException(\"The user specific base url are changed.\");\n-        }\n-\n-        final MyMLet myMlet = new MyMLet();\n-\n-        if (myMlet.check(null, null, null, content) != content.getCodeBase()) {\n-            throw new RuntimeException(\"Failed to overrid the protected methed check\");\n-        }\n-\n-        System.out.println(\">>> The test is well passed.\");\n-    }\n-\n-    private static class MyMLet extends MLet {\n-        public URL check(String version,\n-                         URL codebase,\n-                         String jarfile,\n-                         MLetContent content) {\n-            return content.getCodeBase();\n-        }\n-    }\n-\n-    private static final String archive = \"my jarfile\";\n-    private static final String code = \"my code\";\n-    private static final String object = \"my object\";\n-    private static final String name = \"my name\";\n-    private static final String version = \"my version\";\n-\n-    private static final String myfile = \"My file\";\n-    private static final String baseUrl = \"file:\/tmp\/test\/\";\n-\n-    private final static String codebase = \"my code base\/\";\n-}\n","filename":"test\/jdk\/javax\/management\/loading\/MLetContentTest.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.Map;\n-import javax.management.loading.MLet;\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeTest;\n-\n-import static org.testng.Assert.*;\n-\n-\/*\n- * @test\n- * @bug 8058089\n- * @summary Tests various internal functions provided by MLet for correctness\n- * @author Jaroslav Bachorik\n- * @modules java.management\/javax.management.loading:open\n- * @run testng MLetInternalsTest\n- *\/\n-@SuppressWarnings(\"removal\")\n-public class MLetInternalsTest {\n-    private final static String CONSTRUCT_PARAMETER = \"constructParameter\";\n-\n-    private final static Map<String, Method> testedMethods = new HashMap<>();\n-\n-    @BeforeClass\n-    public static void setupClass() {\n-        testedMethods.clear();\n-        try {\n-            Method m = MLet.class.getDeclaredMethod(\n-                    CONSTRUCT_PARAMETER,\n-                    String.class, String.class\n-            );\n-            m.setAccessible(true);\n-\n-            testedMethods.put(CONSTRUCT_PARAMETER, m);\n-        } catch (Exception ex) {\n-            throw new Error(ex);\n-        }\n-    }\n-\n-    private MLet mlet;\n-\n-    @BeforeTest\n-    public void setupTest() {\n-        mlet = new MLet();\n-    }\n-\n-    @Test\n-    public void testConstructParameter() throws Exception {\n-        assertEquals(constructParameter(\"120\", \"int\"), 120);\n-        assertEquals(constructParameter(\"120\", \"java.lang.Integer\"), Integer.valueOf(120));\n-        assertEquals(constructParameter(\"120\", \"long\"), 120L);\n-        assertEquals(constructParameter(\"120\", \"java.lang.Long\"), Long.valueOf(120));\n-        assertEquals(constructParameter(\"120.0\", \"float\"), 120.0f);\n-        assertEquals(constructParameter(\"120.0\", \"java.lang.Float\"), Float.valueOf(120.0f));\n-        assertEquals(constructParameter(\"120.0\", \"double\"), 120.0d);\n-        assertEquals(constructParameter(\"120\", \"java.lang.Double\"), Double.valueOf(120d));\n-        assertEquals(constructParameter(\"120\", \"java.lang.String\"), \"120\");\n-        assertEquals(constructParameter(\"120\", \"byte\"), (byte)120);\n-        assertEquals(constructParameter(\"120\", \"java.lang.Byte\"), (byte)120);\n-        assertEquals(constructParameter(\"120\", \"short\"), (short)120);\n-        assertEquals(constructParameter(\"120\", \"java.lang.Short\"), (short)120);\n-        assertEquals(constructParameter(\"true\", \"boolean\"), true);\n-        assertEquals(constructParameter(\"true\", \"java.lang.Boolean\"), Boolean.valueOf(true));\n-    }\n-\n-    private Object constructParameter(String param, String type) throws Exception {\n-        return testedMethods.get(CONSTRUCT_PARAMETER).invoke(mlet, param, type);\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/loading\/MLetInternalsTest.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 7065236\n- * @summary Checking MletParser for Locale insensitive strings\n- * @author Harsha Wardhana B\n- *\n- * @run clean MletParserLocaleTest\n- * @run build MletParserLocaleTest\n- * @run main\/othervm MletParserLocaleTest mlet4.html\n- *\/\n-\n-import java.io.File;\n-import java.util.Locale;\n-import javax.management.MBeanServer;\n-import javax.management.MBeanServerFactory;\n-import javax.management.ObjectName;\n-import javax.management.loading.MLet;\n-\n-@SuppressWarnings(\"removal\")\n-public class MletParserLocaleTest {\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        boolean error = false;\n-\n-        \/\/ Instantiate the MBean server\n-        \/\/\n-        System.out.println(\"Create the MBean server\");\n-        MBeanServer mbs = MBeanServerFactory.createMBeanServer();\n-\n-        \/\/ Get Default Locale\n-        Locale loc = Locale.getDefault();\n-\n-        \/\/ Instantiate an MLet\n-        \/\/\n-        System.out.println(\"Create the MLet\");\n-        MLet mlet = new MLet();\n-\n-        \/\/ Register the MLet MBean with the MBeanServer\n-        \/\/\n-        System.out.println(\"Register the MLet MBean\");\n-        ObjectName mletObjectName = new ObjectName(\"Test:type=MLet\");\n-        mbs.registerMBean(mlet, mletObjectName);\n-\n-        \/\/ Call getMBeansFromURL\n-        \/\/\n-        System.out.println(\"Call mlet.getMBeansFromURL(<url>)\");\n-        String testSrc = System.getProperty(\"test.src\");\n-        System.out.println(\"test.src = \" + testSrc);\n-        String urlCodebase;\n-        if (testSrc.startsWith(\"\/\")) {\n-            urlCodebase =\n-                \"file:\" + testSrc.replace(File.separatorChar, '\/') + \"\/\";\n-        } else {\n-            urlCodebase =\n-                \"file:\/\" + testSrc.replace(File.separatorChar, '\/') + \"\/\";\n-        }\n-        String mletFile = urlCodebase + args[0];\n-        System.out.println(\"MLet File = \" + mletFile);\n-        try {\n-            \/\/ Change default Locale to Turkish\n-            Locale.setDefault(Locale.of(\"tr\", \"TR\"));\n-            mlet.getMBeansFromURL(mletFile);\n-            System.out.println(\"Test Passes\");\n-        } catch (Exception e) {\n-            error = true;\n-            e.printStackTrace(System.out);\n-        }finally {\n-            Locale.setDefault(loc);\n-        }\n-\n-        \/\/ Unregister the MLet MBean\n-        \/\/\n-        System.out.println(\"Unregister the MLet MBean\");\n-        mbs.unregisterMBean(mletObjectName);\n-\n-        \/\/ Release MBean server\n-        \/\/\n-        System.out.println(\"Release the MBean server\");\n-        MBeanServerFactory.releaseMBeanServer(mbs);\n-\n-        \/\/ End Test\n-        \/\/\n-        System.out.println(\"Bye! Bye!\");\n-        if (error) System.exit(1);\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/loading\/MletParserLocaleTest.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 5042364\n- * @summary Malformed MLet text file causes infinite loop in parser.\n- * The MLetParser goes into an infinite loop when a tag is not\n- * terminated with the corresponding '>' and an opening '<' for\n- * the subsequent tag is encountered.\n- * @author Luis-Miguel Alventosa\n- *\n- * @run clean ParserInfiniteLoopTest\n- * @run build ParserInfiniteLoopTest\n- * @run main\/othervm ParserInfiniteLoopTest mlet1.html\n- * @run main\/othervm ParserInfiniteLoopTest mlet2.html\n- * @run main\/othervm ParserInfiniteLoopTest mlet3.html\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-import javax.management.MBeanServer;\n-import javax.management.MBeanServerFactory;\n-import javax.management.ObjectName;\n-import javax.management.ServiceNotFoundException;\n-import javax.management.loading.MLet;\n-\n-@SuppressWarnings(\"removal\")\n-public class ParserInfiniteLoopTest {\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        boolean error = false;\n-\n-        \/\/ Instantiate the MBean server\n-        \/\/\n-        System.out.println(\"Create the MBean server\");\n-        MBeanServer mbs = MBeanServerFactory.createMBeanServer();\n-\n-        \/\/ Instantiate an MLet\n-        \/\/\n-        System.out.println(\"Create the MLet\");\n-        MLet mlet = new MLet();\n-\n-        \/\/ Register the MLet MBean with the MBeanServer\n-        \/\/\n-        System.out.println(\"Register the MLet MBean\");\n-        ObjectName mletObjectName = new ObjectName(\"Test:type=MLet\");\n-        mbs.registerMBean(mlet, mletObjectName);\n-\n-        \/\/ Call getMBeansFromURL\n-        \/\/\n-        System.out.println(\"Call mlet.getMBeansFromURL(<url>)\");\n-        String testSrc = System.getProperty(\"test.src\");\n-        System.out.println(\"test.src = \" + testSrc);\n-        String urlCodebase;\n-        if (testSrc.startsWith(\"\/\")) {\n-            urlCodebase =\n-                \"file:\" + testSrc.replace(File.separatorChar, '\/') + \"\/\";\n-        } else {\n-            urlCodebase =\n-                \"file:\/\" + testSrc.replace(File.separatorChar, '\/') + \"\/\";\n-        }\n-        String mletFile = urlCodebase + args[0];\n-        System.out.println(\"MLet File = \" + mletFile);\n-        try {\n-            mlet.getMBeansFromURL(mletFile);\n-            System.out.println(\n-                \"TEST FAILED: Expected ServiceNotFoundException not thrown\");\n-            error = true;\n-        } catch (ServiceNotFoundException e) {\n-            if (e.getCause() == null) {\n-                System.out.println(\"TEST FAILED: Got unexpected null cause \" +\n-                    \"in ServiceNotFoundException\");\n-                error = true;\n-            } else if (!(e.getCause() instanceof IOException)) {\n-                System.out.println(\"TEST FAILED: Got unexpected non-null \" +\n-                    \"cause in ServiceNotFoundException\");\n-                error = true;\n-            } else {\n-                System.out.println(\"TEST PASSED: Got expected non-null \" +\n-                    \"cause in ServiceNotFoundException\");\n-                error = false;\n-            }\n-            e.printStackTrace(System.out);\n-        }\n-\n-        \/\/ Unregister the MLet MBean\n-        \/\/\n-        System.out.println(\"Unregister the MLet MBean\");\n-        mbs.unregisterMBean(mletObjectName);\n-\n-        \/\/ Release MBean server\n-        \/\/\n-        System.out.println(\"Release the MBean server\");\n-        MBeanServerFactory.releaseMBeanServer(mbs);\n-\n-        \/\/ End Test\n-        \/\/\n-        System.out.println(\"Bye! Bye!\");\n-        if (error) System.exit(1);\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/loading\/ParserInfiniteLoopTest.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-<MLET CODE=HelloWorld ARCHIVE=\"helloworld.jar\"\n-<\/MLET>\n","filename":"test\/jdk\/javax\/management\/loading\/mlet1.html","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-<MLET CODE=HelloWorld ARCHIVE=\"helloworld.jar\">\n-<\/MLET\n","filename":"test\/jdk\/javax\/management\/loading\/mlet2.html","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-<MLET CODE=HelloWorld ARCHIVE=\"helloworld.jar\">\n-<ARG TYPE=argumentType VALUE=value\n-<\/MLET>\n","filename":"test\/jdk\/javax\/management\/loading\/mlet3.html","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-<MLET CODE=HelloWorld ARCHIVE=\"helloworld.jar\">\n-<\/MLET>\n","filename":"test\/jdk\/javax\/management\/loading\/mlet4.html","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.net.URLClassLoader;\n@@ -48,0 +49,1 @@\n+import javax.management.ObjectInstance;\n@@ -49,1 +51,1 @@\n-import javax.management.loading.PrivateMLet;\n+import javax.management.loading.PrivateClassLoader;\n@@ -63,1 +65,0 @@\n-\n@@ -84,3 +85,2 @@\n-            @SuppressWarnings(\"removal\")\n-            PrivateMLet mlet = new PrivateMLet(urls, null, false);\n-            Class<?> shadowClass = mlet.loadClass(TestMXBean.class.getName());\n+            Loader loader = new Loader(urls);\n+            Class<?> shadowClass = loader.loadClass(TestMXBean.class.getName());\n@@ -89,1 +89,1 @@\n-                String message = \"(ERROR) MLet got original TestMXBean, not shadow\";\n+                String message = \"(ERROR) Loader got original TestMXBean, not shadow\";\n@@ -96,2 +96,2 @@\n-            ObjectName mletName = new ObjectName(\"x:type=mlet\");\n-            mbs.registerMBean(mlet, mletName);\n+            ObjectName loaderName = new ObjectName(\"x:type=myloader\");\n+            mbs.registerMBean(loader, loaderName);\n@@ -100,1 +100,1 @@\n-            mbs.createMBean(Test.class.getName(), testName, mletName);\n+            mbs.createMBean(Test.class.getName(), testName, loaderName);\n@@ -106,3 +106,3 @@\n-            if (testLoader != mlet) {\n-                System.out.println(\"MLet \" + mlet);\n-                String message = \"(ERROR) MXBean's class loader is not MLet: \"\n+            if (testLoader != loader) {\n+                System.out.println(\"Loader \" + loader);\n+                String message = \"(ERROR) MXBean's class loader is not Loader: \"\n@@ -115,1 +115,0 @@\n-\n@@ -267,0 +266,1 @@\n+            WeakReference<Loader> loaderRef = new WeakReference<>(loader);\n@@ -268,6 +268,2 @@\n-            mbs.unregisterMBean(mletName);\n-\n-            @SuppressWarnings(\"removal\")\n-            WeakReference<PrivateMLet> mletRef =\n-                    new WeakReference<PrivateMLet>(mlet);\n-            mlet = null;\n+            mbs.unregisterMBean(loaderName);\n+            loader = null;\n@@ -278,1 +274,1 @@\n-            for (int i = 0; i < 10000 && mletRef.get() != null; i++) {\n+            for (int i = 0; i < 10000 && loaderRef.get() != null; i++) {\n@@ -283,1 +279,1 @@\n-            if (mletRef.get() == null)\n+            if (loaderRef.get() == null)\n@@ -298,0 +294,8 @@\n+    public static interface LoaderMBean {\n+    }\n+\n+    public static class Loader extends URLClassLoader implements LoaderMBean, PrivateClassLoader {\n+        public Loader(URL[] urls) {\n+            super(urls, null);\n+        }\n+    }\n","filename":"test\/jdk\/javax\/management\/mxbean\/MXBeanLoadingTest1.java","additions":26,"deletions":22,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-import javax.management.loading.MLet;\n+import javax.management.timer.Timer;\n@@ -42,1 +42,0 @@\n-    @SuppressWarnings(\"removal\") \/\/ use of MLet\n@@ -54,4 +53,4 @@\n-        ObjectName mlet1Name = new ObjectName(\"r:type=MLet,instance=1\");\n-        ObjectName mlet2Name = new ObjectName(\"r:type=MLet,instance=2\");\n-        mbs.createMBean(MLet.class.getName(), mlet1Name);\n-        mbs.createMBean(MLet.class.getName(), mlet2Name);\n+        ObjectName mb1Name = new ObjectName(\"r:type=Timer,instance=1\");\n+        ObjectName mb2Name = new ObjectName(\"r:type=Timer,instance=2\");\n+        mbs.createMBean(Timer.class.getName(), mb1Name);\n+        mbs.createMBean(Timer.class.getName(), mb2Name);\n@@ -59,2 +58,2 @@\n-        RoleInfo leftRoleInfo = new RoleInfo(\"left\", MLet.class.getName());\n-        RoleInfo rightRoleInfo = new RoleInfo(\"right\", MLet.class.getName());\n+        RoleInfo leftRoleInfo = new RoleInfo(\"left\", Timer.class.getName());\n+        RoleInfo rightRoleInfo = new RoleInfo(\"right\", Timer.class.getName());\n@@ -63,1 +62,1 @@\n-            new ArrayList(Arrays.asList(new ObjectName[] {mlet1Name}));\n+            new ArrayList(Arrays.asList(new ObjectName[] {mb1Name}));\n@@ -65,1 +64,1 @@\n-            new ArrayList(Arrays.asList(new ObjectName[] {mlet2Name}));\n+            new ArrayList(Arrays.asList(new ObjectName[] {mb2Name}));\n","filename":"test\/jdk\/javax\/management\/relation\/NonArrayListTest.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,3 +214,2 @@\n-                    final String name = \"d:type=mlet,instance=\" + i;\n-                    mbs.createMBean(\"javax.management.loading.MLet\",\n-                                    new ObjectName(name));\n+                    final String name = \"d:instance=\" + i;\n+                    mbs.registerMBean(new Test(), new ObjectName(name));\n@@ -313,0 +312,13 @@\n+\n+    public static interface TestMBean {\n+        public int getA();\n+        public void setA(int a);\n+    }\n+\n+    public static class Test implements TestMBean {\n+        public Test() {}\n+        public Test(int x) {}\n+\n+        public int getA() {return 0;}\n+        public void setA(int a) {}\n+    }\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/connection\/IdleTimeoutTest.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  We test this as follows.  We fabricate an MLet that has the same set\n+  We test this as follows.  We create an MBean that has the same set\n@@ -54,1 +54,1 @@\n-  loader (or at least, it is a URLClassLoader).  This MLet is\n+  loader (or at least, it is a URLClassLoader).  This MBean is\n@@ -58,1 +58,1 @@\n-  Then, we use the MLet to create an RMIConnectorServer MBean.  This\n+  Then, we use the MBean to create an RMIConnectorServer MBean.  This\n@@ -75,1 +75,1 @@\n-    private static final ObjectName mletName;\n+    private static final ObjectName mbeanName;\n@@ -78,1 +78,1 @@\n-            mletName = new ObjectName(\"x:type=mlet\");\n+            mbeanName = new ObjectName(\"x:type=TestMBean\");\n@@ -104,3 +104,2 @@\n-        @SuppressWarnings(\"removal\")\n-        PrivateMLet mlet = new PrivateMLet(urls, null, false);\n-        Class shadowClass = mlet.loadClass(JMXServiceURL.class.getName());\n+        TestMBean mbean = new Test(urls);\n+        Class shadowClass = mbean.loadClass(JMXServiceURL.class.getName());\n@@ -108,1 +107,1 @@\n-            System.out.println(\"TEST INVALID: MLet got original \" +\n+            System.out.println(\"TEST INVALID: Test MBean got original \" +\n@@ -114,1 +113,1 @@\n-        mbs.registerMBean(mlet, mletName);\n+        mbs.registerMBean(mbean, mbeanName);\n@@ -158,1 +157,1 @@\n-                         mletName,\n+                         mbeanName,\n@@ -169,0 +168,14 @@\n+\n+    public static interface TestMBean {\n+        public Class<?> loadClass(String name) throws ClassNotFoundException;\n+    }\n+\n+    public static class Test extends URLClassLoader implements TestMBean {\n+        public Test(URL[] urls) {\n+            super(urls, null);\n+        }\n+\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            return loadClass(name, false);\n+        }\n+    }\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/loading\/TargetMBeanTest.java","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-import javax.management.loading.MLet;\n+import javax.management.timer.Timer;\n@@ -83,1 +83,0 @@\n-    @SuppressWarnings(\"removal\") \/\/ use of MLet\n@@ -124,1 +123,1 @@\n-        mbs.createMBean(MLet.class.getName(), null);\n+        mbs.createMBean(Timer.class.getName(), new ObjectName(\":type=Timer\"));\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/notif\/NotificationBufferTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,6 +94,0 @@\n-            \/\/ Register the ClassPathClassLoaderMBean\n-            \/\/\n-            System.out.println(\"Create ClassPathClassLoader MBean\");\n-            ObjectName cpcl =\n-                new ObjectName(\"ClassLoader:name=ClassPathClassLoader\");\n-            mbs.createMBean(\"javax.management.loading.MLet\", cpcl);\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAuthenticator\/RMIAltAuthTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,6 +92,0 @@\n-            \/\/ Register the ClassPathClassLoaderMBean\n-            \/\/\n-            System.out.println(\"Create ClassPathClassLoader MBean\");\n-            ObjectName cpcl =\n-                new ObjectName(\"ClassLoader:name=ClassPathClassLoader\");\n-            mbs.createMBean(\"javax.management.loading.MLet\", cpcl);\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAuthenticator\/RMIPasswdAuthTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @bug 8236987\n+ * @bug 8236987 8320328\n@@ -77,0 +77,2 @@\n+        boolean interrupted = Thread.currentThread().isInterrupted();\n+\n@@ -87,0 +89,4 @@\n+\n+        if (!interrupted) {\n+            throw new RuntimeException(\"Interrupted state of the thread is not preserved\");\n+        }\n@@ -89,1 +95,0 @@\n-\n","filename":"test\/jdk\/javax\/swing\/ImageIcon\/LoadInterruptTest.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+\n+import javax.swing.DefaultCellEditor;\n+import javax.swing.JComboBox;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.border.BevelBorder;\n+import javax.swing.table.AbstractTableModel;\n+import javax.swing.table.DefaultTableCellRenderer;\n+import javax.swing.table.TableCellRenderer;\n+import javax.swing.table.TableColumn;\n+import javax.swing.table.TableModel;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4112270 8264102\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test Keyboard Navigation in JTable.\n+ * @run main\/manual KeyBoardNavigation\n+ *\/\n+\n+public class KeyBoardNavigation {\n+    static JFrame frame;\n+    public static PassFailJFrame passFailJFrame;\n+\n+    static void initTest() throws Exception {\n+        final String INSTRUCTIONS = \"\"\"\n+                Instructions to Test:\n+                1. Refer the below keyboard navigation specs\n+                 (referenced from bug report 4112270).\n+                2. Check all combinations of navigational keys in all four modes\n+                  shift and control verifying each change to the selection against\n+                  the spec. If it does, press \"pass\", otherwise press \"fail\".\n+\n+                  Navigate In - Tab, shift-tab, control-tab, shift-control-tab\n+                  Return\/shift-return - move focus one cell down\/up.\n+                  Tab\/shift-tab - move focus one cell right\/left.\n+                  Up\/down arrow - deselect current selection; move focus one cell up\/down\n+                  Left\/right arrow - deselect current selection; move focus one cell\n+                                             left\/right\n+                  PageUp\/PageDown - deselect current selection; scroll up\/down one\n+                                    JViewport view; first visible cell in current\n+                                    column gets focus\n+                  Control-PageUp\/PageDown - deselect current selection; scroll\n+                                            left\/right one JViewport view; first\n+                                            visible cell in current row gets\n+                                            focus\n+                  Home\/end - deselect current selection; move focus and view to\n+                                     first\/last cell in current row\n+                  Control-home\/end - deselect current selection; move focus and view to\n+                                             upper-left\/lower-right cell in table\n+                  F2 - Allows editing in a cell containing information without\n+                               overwriting the information\n+                  Esc - Resets the cell content back to the state it was in before\n+                                editing started\n+                  Ctrl+A, Ctrl+\/ = Select all\n+                  Ctrl+\\\\ = De-select all\n+                  Shift-up\/down arrow - extend selection up\/down one row\n+                  Shift-left\/right arrow - extend selection left\/right one column\n+                  Control-shift up\/down arrow - extend selection to top\/bottom of column\n+                  Shift-home\/end - extend selection to left\/right end of row\n+                  Control-shift-home\/end - extend selection to beginning\/end of data\n+                  Shift-PageUp\/PageDown - extend selection up\/down one view and scroll\n+                                          table\n+                  Control-shift-PageUp\/PageDown - extend selection left\/right one view\n+                                                          and scroll table\n+                \"\"\";\n+\n+        final String[] names = {\"First Name\", \"Last Name\", \"Favorite Color\",\n+                \"Favorite Number\", \"Vegetarian\"};\n+        final Object[][] data = {\n+                {\"Mark\", \"Andrews\", \"Red\", 2, Boolean.TRUE},\n+                {\"Tom\", \"Ball\", \"Blue\", 99, Boolean.FALSE},\n+                {\"Alan\", \"Chung\", \"Green\", 838, Boolean.FALSE},\n+                {\"Jeff\", \"Dinkins\", \"Turquois\", 8, Boolean.TRUE},\n+                {\"Amy\", \"Fowler\", \"Yellow\", 3, Boolean.FALSE},\n+                {\"Brian\", \"Gerhold\", \"Green\", 0, Boolean.FALSE},\n+                {\"James\", \"Gosling\", \"Pink\", 21, Boolean.FALSE},\n+                {\"David\", \"Karlton\", \"Red\", 1, Boolean.FALSE},\n+                {\"Dave\", \"Kloba\", \"Yellow\", 14, Boolean.FALSE},\n+                {\"Peter\", \"Korn\", \"Purple\", 12, Boolean.FALSE},\n+                {\"Phil\", \"Milne\", \"Purple\", 3, Boolean.FALSE},\n+                {\"Dave\", \"Moore\", \"Green\", 88, Boolean.FALSE},\n+                {\"Hans\", \"Muller\", \"Maroon\", 5, Boolean.FALSE},\n+                {\"Rick\", \"Levenson\", \"Blue\", 2, Boolean.FALSE},\n+                {\"Tim\", \"Prinzing\", \"Blue\", 22, Boolean.FALSE},\n+                {\"Chester\", \"Rose\", \"Black\", 0, Boolean.FALSE},\n+                {\"Ray\", \"Ryan\", \"Gray\", 77, Boolean.FALSE},\n+                {\"Georges\", \"Saab\", \"Red\", 4, Boolean.FALSE},\n+                {\"Willie\", \"Walker\", \"Phthalo Blue\", 4, Boolean.FALSE},\n+                {\"Kathy\", \"Walrath\", \"Blue\", 8, Boolean.FALSE},\n+                {\"Arnaud\", \"Weber\", \"Green\", 44, Boolean.FALSE}\n+        };\n+\n+        frame = new JFrame(\"JTable Keyboard Navigation Test\");\n+        passFailJFrame = new PassFailJFrame(\"Test Instructions\",\n+                INSTRUCTIONS, 5L, 15, 50);\n+\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.VERTICAL);\n+\n+        JTable tableView = getTableDetails(names, data);\n+\n+        \/\/ Create a combo box to show that you can use one in a table.\n+        JComboBox<String> comboBox = new JComboBox<>();\n+        comboBox.addItem(\"Red\");\n+        comboBox.addItem(\"Orange\");\n+        comboBox.addItem(\"Yellow\");\n+        comboBox.addItem(\"Green\");\n+        comboBox.addItem(\"Blue\");\n+        comboBox.addItem(\"Indigo\");\n+        comboBox.addItem(\"Violet\");\n+\n+        TableColumn colorColumn = tableView.getColumn(\"Favorite Color\");\n+        \/\/ Use the combo box as the editor in the \"Favorite Color\" column.\n+        colorColumn.setCellEditor(new DefaultCellEditor(comboBox));\n+\n+        \/\/ Set a pink background and tooltip for the Color column renderer.\n+        DefaultTableCellRenderer colorColumnRenderer = new DefaultTableCellRenderer();\n+        colorColumnRenderer.setBackground(Color.pink);\n+        colorColumnRenderer.setToolTipText(\"Click for combo box\");\n+        colorColumn.setCellRenderer(colorColumnRenderer);\n+\n+        \/\/ Set a tooltip for the header of the colors column.\n+        TableCellRenderer headerRenderer = colorColumn.getHeaderRenderer();\n+        if (headerRenderer instanceof DefaultTableCellRenderer)\n+            ((DefaultTableCellRenderer) headerRenderer).setToolTipText(\"Hi Mom!\");\n+\n+        \/\/ Set the width of the \"Vegetarian\" column.\n+        TableColumn vegetarianColumn = tableView.getColumn(\"Vegetarian\");\n+        vegetarianColumn.setPreferredWidth(100);\n+\n+        \/\/ Show the values in the \"Favorite Number\" column in different colors.\n+        TableColumn numbersColumn = tableView.getColumn(\"Favorite Number\");\n+        DefaultTableCellRenderer numberColumnRenderer = new DefaultTableCellRenderer() {\n+            public void setValue(Object value) {\n+                int cellValue = (value instanceof Number) ? ((Number) value).intValue() : 0;\n+                setForeground((cellValue > 30) ? Color.black : Color.red);\n+                setText((value == null) ? \"\" : value.toString());\n+            }\n+        };\n+        numberColumnRenderer.setHorizontalAlignment(JLabel.RIGHT);\n+        numbersColumn.setCellRenderer(numberColumnRenderer);\n+        numbersColumn.setPreferredWidth(110);\n+\n+        JScrollPane scrollPane = new JScrollPane(tableView);\n+        scrollPane.setBorder(new BevelBorder(BevelBorder.LOWERED));\n+        scrollPane.setPreferredSize(new Dimension(430, 200));\n+\n+        frame.add(scrollPane);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    private static JTable getTableDetails(String[] names, Object[][] data) {\n+        TableModel dataModel = new AbstractTableModel() {\n+            \/\/ These methods always need to be implemented.\n+            public int getColumnCount() {\n+                return names.length;\n+            }\n+\n+            public int getRowCount() {\n+                return data.length;\n+            }\n+\n+            public Object getValueAt(int row, int col) {\n+                return data[row][col];\n+            }\n+\n+            \/\/ The default implementations of these methods in\n+            \/\/ AbstractTableModel would work, but we can refine them.\n+            public String getColumnName(int column) {\n+                return names[column];\n+            }\n+\n+            public Class<?> getColumnClass(int c) {\n+                return getValueAt(0, c).getClass();\n+            }\n+\n+            public boolean isCellEditable(int row, int col) {\n+                return true;\n+            }\n+\n+            public void setValueAt(Object aValue, int row, int column) {\n+                System.out.println(\"Setting value to: \" + aValue);\n+                data[row][column] = aValue;\n+            }\n+        };\n+\n+        JTable tableView = new JTable(dataModel);\n+        \/\/ Turn off auto-resizing so that we can set column sizes programmatically.\n+        \/\/ In this mode, all columns will get their preferred widths, as set below.\n+        tableView.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n+        return tableView;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                initTest();\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTable\/KeyBoardNavigation.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -1,43 +0,0 @@\n-<!--\n- Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- This code is free software; you can redistribute it and\/or modify it\n- under the terms of the GNU General Public License version 2 only, as\n- published by the Free Software Foundation.\n-\n- This code is distributed in the hope that it will be useful, but WITHOUT\n- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- version 2 for more details (a copy is included in the LICENSE file that\n- accompanied this code).\n-\n- You should have received a copy of the GNU General Public License version\n- 2 along with this work; if not, write to the Free Software Foundation,\n- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n- Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- or visit www.oracle.com if you need additional information or have any\n- questions.\n--->\n-\n-<!DOCTYPE HTML PUBLIC \"-\/\/IETF\/\/DTD HTML\/\/EN\">\n-<html>\n-  <head>\n-    <title>Keyboard Navigation in JTable<\/title>\n-  <\/head>\n-\n-  <body>\n-    <h1>Keyboard Navigation in JTable<\/h1>\n-    <applet code=KeyBoardNavigation width=500 height=200>\n-    <\/applet>\n-\n-    <p>\n-      Refer to bug report 4112270 for spec of keyboard navigation. Check all combinations of navigational keys in all four modes shift and control verifying each change to the selection against the spec.\n-       If it does, press \"pass\", otherwise press \"fail\".\n-    <hr>\n-    <address><a href=\"mailto:milne@taller\">Philip Milne<\/a><\/address>\n-\n-  <\/body>\n-<\/html>\n-\n","filename":"test\/jdk\/javax\/swing\/JTable\/KeyBoardNavigation\/KeyBoardNavigation.html","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.Color;\n-import java.awt.Container;\n-import java.awt.Dimension;\n-\n-import javax.swing.DefaultCellEditor;\n-import javax.swing.JApplet;\n-import javax.swing.JComboBox;\n-import javax.swing.JLabel;\n-import javax.swing.JScrollPane;\n-import javax.swing.JTable;\n-import javax.swing.SwingUtilities;\n-import javax.swing.UIManager;\n-import javax.swing.border.BevelBorder;\n-import javax.swing.table.AbstractTableModel;\n-import javax.swing.table.DefaultTableCellRenderer;\n-import javax.swing.table.TableCellRenderer;\n-import javax.swing.table.TableColumn;\n-import javax.swing.table.TableModel;\n-\n-\n-\/**\n- * @test\n- * @bug 4112270\n- * @summary\n- *     Keyboard Navigation in JTable\n- * @author milne\n- * @run applet\/manual=yesno KeyBoardNavigation.html\n- *\/\n-public class KeyBoardNavigation extends JApplet\n-{\n-    static void initTest(Container contentPane)\n-    {\n-        \/\/ Take the dummy data from SwingSet.\n-        final String[] names = {\"First Name\", \"Last Name\", \"Favorite Color\",\n-                \"Favorite Number\", \"Vegetarian\"};\n-        final Object[][] data = {\n-                {\"Mark\", \"Andrews\", \"Red\", new Integer(2), new Boolean(true)},\n-                {\"Tom\", \"Ball\", \"Blue\", new Integer(99), new Boolean(false)},\n-                {\"Alan\", \"Chung\", \"Green\", new Integer(838), new Boolean(false)},\n-                {\"Jeff\", \"Dinkins\", \"Turquois\", new Integer(8), new Boolean(true)},\n-                {\"Amy\", \"Fowler\", \"Yellow\", new Integer(3), new Boolean(false)},\n-                {\"Brian\", \"Gerhold\", \"Green\", new Integer(0), new Boolean(false)},\n-                {\"James\", \"Gosling\", \"Pink\", new Integer(21), new Boolean(false)},\n-                {\"David\", \"Karlton\", \"Red\", new Integer(1), new Boolean(false)},\n-                {\"Dave\", \"Kloba\", \"Yellow\", new Integer(14), new Boolean(false)},\n-                {\"Peter\", \"Korn\", \"Purple\", new Integer(12), new Boolean(false)},\n-                {\"Phil\", \"Milne\", \"Purple\", new Integer(3), new Boolean(false)},\n-                {\"Dave\", \"Moore\", \"Green\", new Integer(88), new Boolean(false)},\n-                {\"Hans\", \"Muller\", \"Maroon\", new Integer(5), new Boolean(false)},\n-                {\"Rick\", \"Levenson\", \"Blue\", new Integer(2), new Boolean(false)},\n-                {\"Tim\", \"Prinzing\", \"Blue\", new Integer(22), new Boolean(false)},\n-                {\"Chester\", \"Rose\", \"Black\", new Integer(0), new Boolean(false)},\n-                {\"Ray\", \"Ryan\", \"Gray\", new Integer(77), new Boolean(false)},\n-                {\"Georges\", \"Saab\", \"Red\", new Integer(4), new Boolean(false)},\n-                {\"Willie\", \"Walker\", \"Phthalo Blue\", new Integer(4), new Boolean(false)},\n-                {\"Kathy\", \"Walrath\", \"Blue\", new Integer(8), new Boolean(false)},\n-                {\"Arnaud\", \"Weber\", \"Green\", new Integer(44), new Boolean(false)}\n-        };\n-\n-        \/\/ Create a model of the data.\n-        TableModel dataModel = new AbstractTableModel() {\n-            \/\/ These methods always need to be implemented.\n-            public int getColumnCount() { return names.length; }\n-            public int getRowCount() { return data.length;}\n-            public Object getValueAt(int row, int col) {return data[row][col];}\n-\n-            \/\/ The default implementations of these methods in\n-            \/\/ AbstractTableModel would work, but we can refine them.\n-            public String getColumnName(int column) {return names[column];}\n-            public Class getColumnClass(int c) {return getValueAt(0, c).getClass();}\n-            public boolean isCellEditable(int row, int col) {return true;}\n-            public void setValueAt(Object aValue, int row, int column) {\n-                System.out.println(\"Setting value to: \" + aValue);\n-                data[row][column] = aValue;\n-            }\n-        };\n-\n-        \/\/ Create the table\n-        JTable tableView = new JTable(dataModel);\n-        \/\/ Turn off auto-resizing so that we can set column sizes programmatically.\n-        \/\/ In this mode, all columns will get their preferred widths, as set blow.\n-        tableView.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n-\n-        \/\/ Create a combo box to show that you can use one in a table.\n-        JComboBox comboBox = new JComboBox();\n-        comboBox.addItem(\"Red\");\n-        comboBox.addItem(\"Orange\");\n-        comboBox.addItem(\"Yellow\");\n-        comboBox.addItem(\"Green\");\n-        comboBox.addItem(\"Blue\");\n-        comboBox.addItem(\"Indigo\");\n-        comboBox.addItem(\"Violet\");\n-\n-        TableColumn colorColumn = tableView.getColumn(\"Favorite Color\");\n-        \/\/ Use the combo box as the editor in the \"Favorite Color\" column.\n-        colorColumn.setCellEditor(new DefaultCellEditor(comboBox));\n-\n-        \/\/ Set a pink background and tooltip for the Color column renderer.\n-        DefaultTableCellRenderer colorColumnRenderer = new DefaultTableCellRenderer();\n-        colorColumnRenderer.setBackground(Color.pink);\n-        colorColumnRenderer.setToolTipText(\"Click for combo box\");\n-        colorColumn.setCellRenderer(colorColumnRenderer);\n-\n-        \/\/ Set a tooltip for the header of the colors column.\n-        TableCellRenderer headerRenderer = colorColumn.getHeaderRenderer();\n-        if (headerRenderer instanceof DefaultTableCellRenderer)\n-            ((DefaultTableCellRenderer)headerRenderer).setToolTipText(\"Hi Mom!\");\n-\n-        \/\/ Set the width of the \"Vegetarian\" column.\n-        TableColumn vegetarianColumn = tableView.getColumn(\"Vegetarian\");\n-        vegetarianColumn.setPreferredWidth(100);\n-\n-        \/\/ Show the values in the \"Favorite Number\" column in different colors.\n-        TableColumn numbersColumn = tableView.getColumn(\"Favorite Number\");\n-        DefaultTableCellRenderer numberColumnRenderer = new DefaultTableCellRenderer() {\n-            public void setValue(Object value) {\n-                int cellValue = (value instanceof Number) ? ((Number)value).intValue() : 0;\n-                setForeground((cellValue > 30) ? Color.black : Color.red);\n-                setText((value == null) ? \"\" : value.toString());\n-            }\n-        };\n-        numberColumnRenderer.setHorizontalAlignment(JLabel.RIGHT);\n-        numbersColumn.setCellRenderer(numberColumnRenderer);\n-        numbersColumn.setPreferredWidth(110);\n-\n-        \/\/ Finish setting up the table.\n-        JScrollPane scrollpane = new JScrollPane(tableView);\n-        scrollpane.setBorder(new BevelBorder(BevelBorder.LOWERED));\n-        scrollpane.setPreferredSize(new Dimension(430, 200));\n-\n-        contentPane.add(scrollpane);\n-    }\n-\n-\n-    public void init() {\n-        SwingUtilities.invokeLater(() -> {\n-            try {\n-                UIManager.setLookAndFeel(\n-                        \"javax.swing.plaf.metal.MetalLookAndFeel\");\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-\n-            initTest(getContentPane());\n-        });\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JTable\/KeyBoardNavigation\/KeyBoardNavigation.java","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-<!--\n- Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- This code is free software; you can redistribute it and\/or modify it\n- under the terms of the GNU General Public License version 2 only, as\n- published by the Free Software Foundation.\n-\n- This code is distributed in the hope that it will be useful, but WITHOUT\n- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- version 2 for more details (a copy is included in the LICENSE file that\n- accompanied this code).\n-\n- You should have received a copy of the GNU General Public License version\n- 2 along with this work; if not, write to the Free Software Foundation,\n- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n- Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- or visit www.oracle.com if you need additional information or have any\n- questions.\n--->\n-\n-<html>\n-<body>\n-\n-Verify that scaled icons are rendered smoothly.\n-\n-1. Run the test.\n-2. Check that Collapsed  and Expanded JTree icons are drawn smoothly.\n-If so, press PASS, else press FAIL.\n-\n-<applet  code=\"bug8038113.class\" width=400 height=400><\/applet>\n-\n-<\/body>\n-<\/html>\n","filename":"test\/jdk\/javax\/swing\/JTree\/8038113\/bug8038113.html","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import java.awt.BasicStroke;\n-import java.awt.BorderLayout;\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import javax.swing.Icon;\n-import javax.swing.JApplet;\n-import javax.swing.JPanel;\n-import javax.swing.JTree;\n-import javax.swing.SwingUtilities;\n-import javax.swing.plaf.basic.BasicTreeUI;\n-\n-\/* @test\n- * @bug 8038113\n- * @summary [macosx] JTree icon is not rendered in high resolution on Retina\n- * @run applet\/manual=yesno bug8038113.html\n- *\/\n-public class bug8038113 extends JApplet {\n-\n-    @Override\n-    public void init() {\n-        SwingUtilities.invokeLater(new Runnable() {\n-\n-            @Override\n-            public void run() {\n-\n-                final JTree tree = new JTree();\n-                final BasicTreeUI treeUI = (BasicTreeUI) tree.getUI();\n-\n-                final JPanel panel = new JPanel() {\n-\n-                    @Override\n-                    public void paint(Graphics g) {\n-                        super.paint(g);\n-                        Graphics2D g2 = (Graphics2D) g;\n-                        g2.setStroke(new BasicStroke(0.5f));\n-                        g2.scale(2, 2);\n-\n-                        int x = 10;\n-                        int y = 10;\n-                        Icon collapsedIcon = treeUI.getCollapsedIcon();\n-                        Icon expandeIcon = treeUI.getExpandedIcon();\n-                        int w = collapsedIcon.getIconWidth();\n-                        int h = collapsedIcon.getIconHeight();\n-                        collapsedIcon.paintIcon(this, g, x, y);\n-                        g.drawRect(x, y, w, h);\n-\n-                        y += 10 + h;\n-                        w = expandeIcon.getIconWidth();\n-                        h = expandeIcon.getIconHeight();\n-                        expandeIcon.paintIcon(this, g, x, y);\n-                        g.drawRect(x, y, w, h);\n-\n-                    }\n-                };\n-                getContentPane().setLayout(new BorderLayout());\n-                getContentPane().add(panel, BorderLayout.CENTER);\n-            }\n-        });\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JTree\/8038113\/bug8038113.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import javax.imageio.ImageIO;\n+import javax.swing.Icon;\n+import javax.swing.JLabel;\n+import javax.swing.JTree;\n+import javax.swing.SwingUtilities;\n+import javax.swing.plaf.basic.BasicTreeUI;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+\n+\/* @test\n+ * @key headful\n+ * @bug 8038113 8258979\n+ * @summary [macosx] JTree icon is not rendered in high resolution on Retina,\n+ *          collapsed icon is not rendered for GTK LAF as well.\n+ * @run main bug8038113\n+ *\/\n+\n+public class bug8038113 {\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf :\n+                UIManager.getInstalledLookAndFeels()) {\n+            if (!laf.getName().contains(\"Motif\")) {\n+                System.out.println(\"Testing LAF: \" + laf.getName());\n+                SwingUtilities.invokeAndWait(() -> test(laf));\n+            }\n+        }\n+    }\n+\n+    public static void test(UIManager.LookAndFeelInfo laf) {\n+        setLookAndFeel(laf);\n+        final JTree tree = new JTree();\n+        final BasicTreeUI treeUI = (BasicTreeUI) tree.getUI();\n+\n+        Icon collapsedIcon = treeUI.getCollapsedIcon();\n+        Icon expandedIcon = treeUI.getExpandedIcon();\n+        BufferedImage img1 = paintToImage(expandedIcon);\n+        BufferedImage img2 = paintToImage(collapsedIcon);\n+\n+        if (!isImgRendered(img1)) {\n+            try {\n+                ImageIO.write(img1, \"png\", new File(\"Expanded_Icon_\" + laf.getName() + \".png\"));\n+            } catch (IOException ignored) {\n+            }\n+            throw new RuntimeException(\"Test Failed, Expanded not rendered for: \"+laf.getName());\n+        }\n+\n+        if (!isImgRendered(img2)) {\n+            try {\n+                ImageIO.write(img2, \"png\", new File(\"Collapsed_Icon_\" + laf.getName() + \".png\"));\n+            } catch (IOException ignored) {\n+            }\n+            throw new RuntimeException(\"Test Failed, Collapsed Icon not rendered for: \"+laf.getName());\n+        }\n+        System.out.println(\"Test Passed\");\n+    }\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static BufferedImage paintToImage(Icon content) {\n+        BufferedImage im = new BufferedImage(content.getIconWidth(),\n+                content.getIconHeight(), TYPE_INT_RGB);\n+        Graphics2D g = (Graphics2D) im.getGraphics();\n+        g.setBackground(Color.WHITE);\n+        g.clearRect(0, 0, content.getIconWidth(), content.getIconHeight());\n+        content.paintIcon(new JLabel(), g, 0, 0);\n+        g.dispose();\n+        return im;\n+    }\n+\n+    private static boolean isImgRendered(BufferedImage img) {\n+        Color white = new Color(255, 255, 255);\n+        for (int x = 0; x < img.getWidth(); ++x) {\n+            for (int y = 0; y < img.getHeight(); ++y) {\n+                if (img.getRGB(x, y) != white.getRGB()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTree\/bug8038113.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @bug 7083187 8318113\n+ * @bug 7083187 8318113 8318112\n@@ -94,0 +94,1 @@\n+            {\"width: 100%\", \"width: 200 %\"},\n","filename":"test\/jdk\/javax\/swing\/text\/html\/CSS\/CSSAttributeEqualityBug.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                blackHole(new byte[16 * 1024 * 1024]);\n+                blackHole(new byte[4 * 1024 * 1024]);\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestZAllocationStallEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @summary Verify that a filename is generated\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jcmd.TestJcmdStartGeneratedFilename\n+ *\/\n+public class TestJcmdStartGeneratedFilename {\n+\n+    public static void main(String[] args) throws Exception {\n+        CountDownLatch recordingClosed = new CountDownLatch(1);\n+        FlightRecorder.addListener(new FlightRecorderListener() {\n+            public void recordingStateChanged(Recording recording) {\n+                if (recording.getState() == RecordingState.CLOSED) {\n+                    recordingClosed.countDown();\n+                }\n+            }\n+        });\n+        Path directory = Paths.get(\".\", \"recordings\");\n+        Files.createDirectories(directory);\n+        JcmdHelper.jcmd(\"JFR.start\", \"duration=1s\", \"filename=\" + directory);\n+        recordingClosed.await();\n+        for (Path path : Files.list(directory).toList()) {\n+            String file = path.toString();\n+            System.out.println(\"Found file: \" + file);\n+            if (file.endsWith(\".jfr\") && file.contains(\"hotspot-\")) {\n+                return;\n+            }\n+        }\n+        throw new Exception(\"Expected dump file on the format hotspot-...jfr\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdStartGeneratedFilename.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import java.io.File;\n@@ -46,1 +45,0 @@\n-import java.util.Properties;\n@@ -49,1 +47,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n@@ -51,0 +48,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -90,22 +88,4 @@\n-        var launcher = Path.of(System.getProperty(\"test.nativepath\"), \"NullCallerTest\");\n-        var pb = new ProcessBuilder(launcher.toString());\n-        var env = pb.environment();\n-\n-        var libDir = Platform.libDir().toString();\n-        var vmDir = Platform.jvmLibDir().toString();\n-\n-        \/\/ set up shared library path\n-        var sharedLibraryPathEnvName = Platform.sharedLibraryPathVariableName();\n-        env.compute(sharedLibraryPathEnvName,\n-                (k, v) -> (v == null) ? libDir : v + File.pathSeparator + libDir);\n-        env.compute(sharedLibraryPathEnvName,\n-                (k, v) -> (v == null) ? vmDir : v + File.pathSeparator + vmDir);\n-\n-        \/\/ launch the actual test\n-        System.out.println(\"Launching: \" + launcher + \" shared library path: \" +\n-                env.get(sharedLibraryPathEnvName));\n-        new OutputAnalyzer(pb.start())\n-                .outputTo(System.out)\n-                .errorTo(System.err)\n-                .shouldHaveExitValue(0);\n-\n+        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder(\"NullCallerTest\");\n+        System.out.println(\"Launching: \" + pb.command() + \" shared library path: \" +\n+                               pb.environment().get(Platform.sharedLibraryPathVariableName()));\n+        ProcessTools.executeProcess(pb).shouldHaveExitValue(0);\n","filename":"test\/jdk\/jni\/nullCaller\/NullCallerTest.java","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (C) 2024, THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8320449\n+ * @summary ECDHKeyAgreement should validate parameters before assigning them to fields.\n+ * @library \/test\/lib\n+ * @run main ECDHKeyAgreementParamValidation\n+ *\/\n+\n+import javax.crypto.KeyAgreement;\n+import java.math.BigInteger;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.interfaces.ECPrivateKey;\n+import java.security.spec.ECPrivateKeySpec;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class ECDHKeyAgreementParamValidation {\n+\n+    private static void testInitWithInvalidKey() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\");\n+        kpg.initialize(256);\n+        KeyPair kp = kpg.generateKeyPair();\n+        ECPrivateKey privateKey = (ECPrivateKey) kp.getPrivate();\n+\n+        KeyFactory keyFactory = KeyFactory.getInstance(\"EC\");\n+        ECPrivateKey invalidPrivateKey\n+                = (ECPrivateKey) keyFactory.generatePrivate(\n+                        new ECPrivateKeySpec(BigInteger.ZERO,\n+                                privateKey.getParams()));\n+\n+        KeyAgreement ka = KeyAgreement.getInstance(\"ECDH\");\n+\n+        \/\/ The first initiation should succeed.\n+        ka.init(privateKey);\n+\n+        \/\/ The second initiation should fail with invalid private key,\n+        \/\/ and the private key assigned by the first initiation should be cleared.\n+        Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> ka.init(invalidPrivateKey));\n+\n+        \/\/ Cannot doPhase due to no private key.\n+        Asserts.assertThrows(\n+                IllegalStateException.class,\n+                () -> ka.doPhase(kp.getPublic(), true));\n+\n+        \/\/ Cannot generate shared key due to no key\n+        Asserts.assertThrows(IllegalStateException.class, ka::generateSecret);\n+    }\n+\n+    private static void testDoPhaseWithInvalidKey() throws Exception {\n+        \/\/ SECP256R1 key pair\n+        KeyPairGenerator kpgP256 = KeyPairGenerator.getInstance(\"EC\");\n+        kpgP256.initialize(256);\n+        KeyPair kpP256 = kpgP256.generateKeyPair();\n+\n+        \/\/ SECP384R1 key pair\n+        KeyPairGenerator kpgP384 = KeyPairGenerator.getInstance(\"EC\");\n+        kpgP384.initialize(384);\n+        KeyPair kpP384 = kpgP384.generateKeyPair();\n+\n+        KeyAgreement ka = KeyAgreement.getInstance(\"ECDH\");\n+        ka.init(kpP256.getPrivate());\n+\n+        Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> ka.doPhase(kpP384.getPublic(), true));\n+\n+        \/\/ Should not generate shared key with SECP256R1 private key and SECP384R1 public key\n+        Asserts.assertThrows(IllegalStateException.class, ka::generateSecret);\n+    }\n+\n+    public static void main(String[] args) {\n+        boolean failed = false;\n+\n+        try {\n+            testInitWithInvalidKey();\n+        } catch (Exception e) {\n+            failed = true;\n+            e.printStackTrace();\n+        }\n+\n+        try {\n+            testDoPhaseWithInvalidKey();\n+        } catch (Exception e) {\n+            failed = true;\n+            e.printStackTrace();\n+        }\n+\n+        if (failed) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ec\/ECDHKeyAgreementParamValidation.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -57,0 +57,3 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n@@ -61,0 +64,1 @@\n+import jdk.test.lib.Platform;\n@@ -746,1 +750,5 @@\n-                return fetchNssLib(LINUX_X64.class);\n+                if (Platform.isOracleLinux7()) {\n+                    throw new SkippedException(\"Skipping Oracle Linux prior to v8\");\n+                } else {\n+                    return fetchNssLib(LINUX_X64.class);\n+                }\n@@ -749,1 +757,5 @@\n-                throw new SkippedException(\"Per JDK-8319128, skipping Linux aarch64 platforms.\");\n+                if (Platform.isOracleLinux7()) {\n+                    throw new SkippedException(\"Skipping Oracle Linux prior to v8\");\n+                } else {\n+                    return fetchNssLib(LINUX_AARCH64.class);\n+                }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+\n@@ -35,1 +36,0 @@\n-import java.util.Iterator;\n@@ -37,2 +37,0 @@\n-import java.util.ServiceConfigurationError;\n-import java.util.ServiceLoader;\n@@ -41,0 +39,1 @@\n+import jtreg.SkippedException;\n@@ -49,1 +48,7 @@\n-        String nssConfig = PKCS11Test.getNssConfig();\n+        String nssConfig = null;\n+        try {\n+            nssConfig = PKCS11Test.getNssConfig();\n+        } catch (SkippedException exc) {\n+            System.out.println(\"Skipping test: \" + exc.getMessage());\n+        }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#        jdk.test.lib.Platform\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins.sh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.io.ByteArrayInputStream;\n@@ -38,1 +37,0 @@\n-import java.util.Collection;\n@@ -47,1 +45,0 @@\n-import jdk.tools.jlink.plugin.ResourcePool;\n@@ -142,1 +139,1 @@\n-                                ByteBuffer.allocate(99), \"bitcruncher\", null,\n+                                ByteBuffer.allocate(99), \"bitcruncher\",\n@@ -210,1 +207,1 @@\n-                ByteBuffer.allocate(7), \"zip\", null, resources1.getStringTable(),\n+                ByteBuffer.allocate(7), \"zip\", resources1.getStringTable(),\n","filename":"test\/jdk\/tools\/jlink\/ResourcePoolTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-                    ResourceDecompressor decompressor = factory.newDecompressor(new Properties());\n+                    ResourceDecompressor decompressor = factory.newDecompressor();\n","filename":"test\/jdk\/tools\/jlink\/plugins\/CompressorPluginTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8299627\n+ * @summary Fix\/improve handling of \"missing\" element-list file\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build   toolbox.ToolBox javadoc.tester.*\n+ * @run main TestExternRedirects\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestExternRedirects extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestExternRedirects();\n+        tester.runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+    private HttpServer httpServer;\n+\n+    @Override\n+    public void runTests() throws Exception {\n+        httpServer = startServer();\n+        var address = httpServer.getAddress();\n+        out.println(\"server running at \" + address);\n+        try {\n+            super.runTests();\n+        } finally {\n+            httpServer.stop(0);\n+        }\n+    }\n+\n+    private HttpServer startServer() throws IOException {\n+        HttpServer server = HttpServer.create(new InetSocketAddress(\"localhost\", 0), 0);\n+        server.createContext(\"\/docs\", new MyHandler());\n+        server.setExecutor(null); \/\/ creates a default executor\n+        server.start();\n+        return server;\n+    }\n+\n+    private class MyHandler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange t) throws IOException {\n+            out.println(\"MyHandler: \" + t.getRequestMethod() + \" \" + t.getRequestURI());\n+            assert t.getRequestMethod().equals(\"GET\");\n+            var uriPath = t.getRequestURI().getPath();\n+            if (uriPath.contains(\"no-redirect\")) {\n+                respond(t, HttpURLConnection.HTTP_OK, \"\");\n+            } else if (uriPath.matches(\".*\/redirect-[1-9]\/.*\")) {\n+                Matcher m = Pattern.compile(\"redirect-([1-9])\").matcher(uriPath);\n+                if (m.find()) {\n+                    var count = Integer.parseInt(m.group(1));\n+                    var u = t.getRequestURI().toString();\n+                    var u2 = u.replace(\"redirect-\" + count,\n+                            (count == 1) ? \"no-redirect\" : \"redirect-\" + (count - 1));\n+                    t.getResponseHeaders().add(\"Location\", u2);\n+                    respond(t, HttpURLConnection.HTTP_MOVED_PERM, \"\");\n+                } else {\n+                    throw new IOException(\"internal error\");\n+                }\n+            } else if (uriPath.contains(\"bad-redirect\")){\n+                var u = t.getRequestURI().toString();\n+                var u2 = u.replace(\"bad-redirect\", \"no-redirect\")\n+                                .replaceAll(\"[^\/]+-list$\", \"not-found.html\");\n+                t.getResponseHeaders().add(\"Location\", u2);\n+                respond(t, HttpURLConnection.HTTP_MOVED_PERM, \"\");\n+            } else {\n+                respond(t, HttpURLConnection.HTTP_NOT_FOUND, \"\");\n+            }\n+        }\n+    }\n+\n+    private void respond(HttpExchange t, int code, String body) throws IOException {\n+        out.println(\"  respond: \" + code);\n+        t.getResponseHeaders().forEach((k, v) -> out.println(\"  header: \" + k + \": \" + v));\n+        body.lines().map(l -> \"  body \" + l).forEach(out::println);\n+\n+        t.sendResponseHeaders(code, body.length());\n+        try (var os = t.getResponseBody()) {\n+            os.write(body.getBytes());\n+        }\n+    }\n+\n+    @Test\n+    public void testNoRedirect(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"package p; public class C { }\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-Xdoclint:none\",\n+                \"-link\", getURL(\"no-redirect\").toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+    }\n+\n+    @Test\n+    public void testSomeRedirect(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"package p; public class C { }\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-Xdoclint:none\",\n+                \"-link\", getURL(\"redirect-3\").toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        new OutputChecker(Output.OUT)\n+                .check(Pattern.compile(\"warning: URL .*\/docs\/redirect-3\/element-list\" +\n+                        \" was redirected to .*\/docs\/no-redirect\/element-list\"));\n+    }\n+\n+    @Test\n+    public void testBadRedirect(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"package p; public class C { }\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-Xdoclint:none\",\n+                \"-link\", getURL(\"bad-redirect\").toString(),\n+                \"p\");\n+        checkExit(Exit.ERROR);\n+\n+        checkOutput(Output.OUT, true,\n+                \"error: Unexpected redirection for URL\");\n+    }\n+\n+    private URL getURL(String key) throws URISyntaxException, MalformedURLException {\n+        return new URI(\"http\",\n+                null,  \/\/ user-info\n+                httpServer.getAddress().getHostName(),\n+                httpServer.getAddress().getPort(),\n+                \"\/docs\/\" + key,\n+                null, \/\/ query\n+                null \/\/ fragment\n+                ).toURL();\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/testExternRedirects\/TestExternRedirects.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1784,1 +1784,1 @@\n-                        processingEnv.getMessager().printMessage(Kind.NOTE, name + \" found in module: \" + processingEnv.getElementUtils().getModuleOf(type));\n+                        processingEnv.getMessager().printNote(name + \" found in module: \" + processingEnv.getElementUtils().getModuleOf(type));\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationProcessing.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    processingEnv.getMessager().printMessage(Kind.NOTE, \"round \" + round);\n+    processingEnv.getMessager().printNote(\"round \" + round);\n","filename":"test\/langtools\/tools\/javac\/processing\/8268575\/Processor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -22,2 +22,2 @@\n-            processingEnv.getMessager().printMessage(Kind.ERROR, \"error1\", root);\n-            processingEnv.getMessager().printMessage(Kind.ERROR, \"error2\", root);\n+            processingEnv.getMessager().printError(\"error1\", root);\n+            processingEnv.getMessager().printError(\"error2\", root);\n","filename":"test\/langtools\/tools\/javac\/processing\/TestMultipleErrors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-            messager.printMessage(NOTE, \"note:elem\", e);\n+            messager.printNote(\"note:elem\", e);\n","filename":"test\/langtools\/tools\/javac\/processing\/messager\/6362067\/T6362067.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-\/\/            messager.printMessage(NOTE, \"expected \" + label + \" found: \" + expect, te);\n+\/\/            messager.printNote(\"expected \" + label + \" found: \" + expect, te);\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestMissingElement\/TestMissingElement.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-                \"isHardenedOSX\", \"hasOSXPlistEntries\");\n+                \"isHardenedOSX\", \"hasOSXPlistEntries\", \"isOracleLinux7\");\n","filename":"test\/lib-test\/jdk\/test\/lib\/TestMutuallyExclusivePlatformPredicates.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.regex.Matcher;\n@@ -351,0 +352,14 @@\n+    public static boolean isOracleLinux7() {\n+        if (System.getProperty(\"os.name\").toLowerCase().contains(\"linux\") &&\n+                System.getProperty(\"os.version\").toLowerCase().contains(\"el\")) {\n+            Pattern p = Pattern.compile(\"el(\\\\d+)\");\n+            Matcher m = p.matcher(System.getProperty(\"os.version\"));\n+            if (m.find()) {\n+                try {\n+                    return Integer.parseInt(m.group(1)) <= 7;\n+                } catch (NumberFormatException nfe) {}\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/Platform.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadVirtual.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CriticalCalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(3)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToCStringTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToJavaStringTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-@Fork(3)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/PointsAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/PointsAlloc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/PointsDistance.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/PointsFree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/XorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.math;\n+\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 5)\n+@Measurement(iterations = 3, time = 5)\n+@Fork(value = 3)\n+public class BigIntegerCompareTo {\n+\n+    public enum Group {S, M, L}\n+\n+    @Param({\"S\", \"M\", \"L\"})\n+    private Group group;\n+\n+    private static final int MAX_LENGTH = Arrays.stream(Group.values())\n+            .mapToInt(p -> getNumbersOfBits(p).length)\n+            .max()\n+            .getAsInt();\n+\n+    private BigInteger[] numbers;\n+\n+    @Setup\n+    public void setup() {\n+        int[] nBits = getNumbersOfBits(group);\n+        numbers = new BigInteger[2 * MAX_LENGTH];\n+        for (int i = 0; i < MAX_LENGTH; i++) {\n+            var p = Shared.createPair(nBits[i % nBits.length]);\n+            numbers[2 * i] = p.x();\n+            numbers[2 * i + 1] = p.y();\n+        }\n+    }\n+\n+    private static int[] getNumbersOfBits(Group p) {\n+        \/\/ the below arrays were derived from stats gathered from running tests in\n+        \/\/ the security area, which is the biggest client of BigInteger in JDK\n+        return switch (p) {\n+            case S -> new int[]{0, 1, 2, 11, 12, 13, 14, 15, 16, 17, 18, 19};\n+            case M -> new int[]{255, 256, 512};\n+            case L -> new int[]{1023, 1024, 1534, 1535, 1536};\n+        };\n+    }\n+\n+    @Benchmark\n+    public void testCompareTo(Blackhole bh) {\n+        for (int i = 0; i < numbers.length; i += 2)\n+            bh.consume(numbers[i].compareTo(numbers[i + 1]));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerCompareTo.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.math;\n+\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 5)\n+@Measurement(iterations = 3, time = 5)\n+@Fork(value = 3)\n+public class BigIntegerEquals {\n+\n+    public enum Group {S, M, L}\n+\n+    @Param({\"S\", \"M\", \"L\"})\n+    private Group group;\n+\n+    private static final int MAX_LENGTH = Arrays.stream(Group.values())\n+            .mapToInt(p -> getNumbersOfBits(p).length)\n+            .max()\n+            .getAsInt();\n+\n+    private BigInteger[] numbers;\n+\n+    @Setup\n+    public void setup() {\n+        int[] nBits = getNumbersOfBits(group);\n+        numbers = new BigInteger[2 * MAX_LENGTH];\n+        for (int i = 0; i < MAX_LENGTH; i++) {\n+            var p = Shared.createPair(nBits[i % nBits.length]);\n+            numbers[2 * i] = p.x();\n+            numbers[2 * i + 1] = p.y();\n+        }\n+    }\n+\n+    private static int[] getNumbersOfBits(Group p) {\n+        \/\/ the below arrays were derived from stats gathered from running tests in\n+        \/\/ the security area, which is the biggest client of BigInteger in JDK\n+        return switch (p) {\n+            case S -> new int[]{1, 46};\n+            case M -> new int[]{129, 130, 251, 252, 253, 254, 255, 256};\n+            case L -> new int[]{382, 383, 384, 445, 446, 447, 448, 519, 520, 521};\n+        };\n+    }\n+\n+    @Benchmark\n+    public void testEquals(Blackhole bh) {\n+        for (int i = 0; i < numbers.length; i += 2)\n+            bh.consume(numbers[i].equals(numbers[i + 1]));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerEquals.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.math;\n+\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 5)\n+@Measurement(iterations = 3, time = 5)\n+@Fork(value = 3)\n+public class BigIntegerHashCode {\n+\n+    public enum Group {S, M, L}\n+\n+    @Param({\"S\", \"M\", \"L\"})\n+    private Group group;\n+\n+    private static final int MAX_LENGTH = Arrays.stream(Group.values())\n+            .mapToInt(p -> getNumbersOfBits(p).length)\n+            .max()\n+            .getAsInt();\n+\n+    private BigInteger[] numbers;\n+\n+    @Setup\n+    public void setup() {\n+        int[] nBits = getNumbersOfBits(group);\n+        numbers = new BigInteger[MAX_LENGTH];\n+        for (int i = 0; i < MAX_LENGTH; i++) {\n+            numbers[i] = Shared.createSingle(nBits[i % nBits.length]);\n+        }\n+    }\n+\n+    private static int[] getNumbersOfBits(Group p) {\n+        \/\/ the below arrays were derived from stats gathered from running tests in\n+        \/\/ the security area, which is the biggest client of BigInteger in JDK\n+        return switch (p) {\n+            case S -> new int[]{2, 7, 13, 64};\n+            case M -> new int[]{256, 384, 511, 512, 521, 767, 768};\n+            case L -> new int[]{1024, 1025, 2047, 2048, 2049, 3072, 4096, 5120, 6144};\n+        };\n+    }\n+\n+    @Benchmark\n+    public void testHashCode(Blackhole bh) {\n+        for (var n : numbers)\n+            bh.consume(n.hashCode());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerHashCode.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.math;\n+\n+import java.math.BigInteger;\n+import java.util.Random;\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ THIS IS NOT A BENCHMARK\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+public final class Shared {\n+\n+    \/\/ General note\n+    \/\/ ============\n+    \/\/\n+    \/\/ Isn't there a simple way to get a BigInteger of the specified number\n+    \/\/ of bits of magnitude? It does not seem like it.\n+    \/\/\n+    \/\/ We cannot create a BigInteger of the specified number of bytes,\n+    \/\/ directly and *cheaply*. This constructor does not do what you\n+    \/\/ might think it does:\n+    \/\/\n+    \/\/      BigInteger(int numBits, Random rnd)\n+    \/\/\n+    \/\/  The only real direct option we have is this constructor:\n+    \/\/\n+    \/\/      BigInteger(int bitLength, int certainty, Random rnd)\n+    \/\/\n+    \/\/  But even with certainty == 0, it is not cheap. So, create the\n+    \/\/  number with the closest number of bytes and then shift right\n+    \/\/  the excess bits.\n+\n+    private Shared() {\n+        throw new AssertionError(\"This is a utility class\");\n+    }\n+\n+    \/\/\n+    \/\/ Creates a pair of same sign numbers x and y that minimally differ in\n+    \/\/ magnitude.\n+    \/\/\n+    \/\/ More formally: x.bitLength() == nBits and x.signum() == y.signum()\n+    \/\/ and either\n+    \/\/\n+    \/\/   * y.bitLength() == nBits, and\n+    \/\/   * x.testBit(0) != y.testBit(0)\n+    \/\/\n+    \/\/ or\n+    \/\/\n+    \/\/   * y.bitLength() == nBits + 1\n+    \/\/\n+    \/\/ By construction, such numbers are unequal to each other, but the\n+    \/\/ difference in magnitude is minimal. That way, the comparison\n+    \/\/ methods, such as equals and compareTo, are forced to examine\n+    \/\/ the _complete_ number representation.\n+    \/\/\n+    \/\/ Assumptions on BigInteger mechanics\n+    \/\/ ===================================\n+    \/\/\n+    \/\/ 1. bigLength() is not consulted with for short-circuiting; if it is,\n+    \/\/    then we have a problem with nBits={0,1}\n+    \/\/ 2. new BigInteger(0, new byte[]{0}) and new BigInteger(1, new byte[]{1})\n+    \/\/    are not canonicalized to BigInteger.ZERO and BigInteger.ONE,\n+    \/\/    respectively; if they are, then internal optimizations might be\n+    \/\/    possible (BigInteger is not exactly a value-based class).\n+    \/\/ 3. Comparison and equality are checked from the most significant bit\n+    \/\/    to the least significant bit, not the other way around (for\n+    \/\/    comparison it seems natural, but not for equality). If any\n+    \/\/    of those are checked in the opposite direction, then the check\n+    \/\/    might short-circuit.\n+    \/\/\n+    public static Pair createPair(int nBits) {\n+        if (nBits < 0) {\n+            throw new IllegalArgumentException(String.valueOf(nBits));\n+        } else if (nBits == 0) {\n+            var zero = new BigInteger(nBits, new byte[0]);\n+            var one = new BigInteger(\/* positive *\/ 1, new byte[]{1});\n+            return new Pair(zero, one);\n+        } else if (nBits == 1) {\n+            var one = new BigInteger(\/* positive *\/ 1, new byte[]{1});\n+            var two = new BigInteger(\/* positive *\/ 1, new byte[]{2});\n+            return new Pair(one, two);\n+        }\n+        int nBytes = (nBits + 7) \/ 8;\n+        var r = new Random();\n+        var bytes = new byte[nBytes];\n+        r.nextBytes(bytes);\n+        \/\/ Create a BigInteger of the exact bit length by:\n+        \/\/ 1. ensuring that the most significant bit is set so that\n+        \/\/    no leading zeros are truncated, and\n+        \/\/ 2. explicitly specifying signum, so it's not calculated from\n+        \/\/    the passed bytes, which must represent magnitude only\n+        bytes[0] |= (byte) 0b1000_0000;\n+        var x = new BigInteger(\/* positive *\/ 1, bytes)\n+                .shiftRight(nBytes * 8 - nBits);\n+        var y = x.flipBit(0);\n+        \/\/ do not rely on the assert statement in benchmark\n+        if (x.bitLength() != nBits)\n+            throw new AssertionError(x.bitLength() + \", \" + nBits);\n+        return new Pair(x, y);\n+    }\n+\n+    public record Pair(BigInteger x, BigInteger y) {\n+        public Pair {\n+            if (x.signum() == -y.signum()) \/\/ if the pair comprises positive and negative\n+                throw new IllegalArgumentException(\"x.signum()=\" + x.signum()\n+                        + \", y=signum()=\" + y.signum());\n+            if (y.bitLength() - x.bitLength() > 1)\n+                throw new IllegalArgumentException(\"x.bitLength()=\" + x.bitLength()\n+                        + \", y.bitLength()=\" + y.bitLength());\n+        }\n+    }\n+\n+    public static BigInteger createSingle(int nBits) {\n+        if (nBits < 0) {\n+            throw new IllegalArgumentException(String.valueOf(nBits));\n+        }\n+        if (nBits == 0) {\n+            return new BigInteger(nBits, new byte[0]);\n+        }\n+        int nBytes = (nBits + 7) \/ 8;\n+        var r = new Random();\n+        var bytes = new byte[nBytes];\n+        r.nextBytes(bytes);\n+        \/\/ Create a BigInteger of the exact bit length by:\n+        \/\/ 1. ensuring that the most significant bit is set so that\n+        \/\/    no leading zeros are truncated, and\n+        \/\/ 2. explicitly specifying signum, so it's not calculated from\n+        \/\/    the passed bytes, which must represent magnitude only\n+        bytes[0] |= (byte) 0b1000_0000;\n+        var x = new BigInteger(\/* positive *\/ 1, bytes)\n+                .shiftRight(nBytes * 8 - nBits);\n+        if (x.bitLength() != nBits)\n+            throw new AssertionError(x.bitLength() + \", \" + nBits);\n+        return x;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/Shared.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"}]}