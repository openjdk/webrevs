{"files":[{"patch":"@@ -239,0 +239,5 @@\n+\n+  \/\/ Instead of always reset before collect, some reset can be done after collect to save\n+  \/\/ the time before before the cycle so the cycle can be started as soon as possible.\n+  entry_reset_after_collect();\n+\n@@ -581,0 +586,10 @@\n+void ShenandoahConcurrentGC::entry_reset_after_collect() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  const char* msg = conc_reset_after_collect_event_message();\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset_after_collect);\n+  EventMark em(\"%s\", msg);\n+\n+  op_reset_after_collect();\n+}\n+\n@@ -1178,1 +1193,22 @@\n-  ShenandoahHeap::heap()->free_set()->recycle_trash();\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  heap->free_set()->recycle_trash();\n+}\n+\n+void ShenandoahConcurrentGC::op_reset_after_collect() {\n+  ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n+                          ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n+                          \"reset after collection.\");\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational()) {\n+    if (!_do_old_gc_bootstrap) {\n+      \/\/ Only reset for young generation, bitmap for old generation must be retained,\n+      \/\/ except there is collection(global\/old\/degen\/full) trigged to collect regions in old gen.\n+      heap->young_generation()->reset_mark_bitmap();\n+      heap->young_generation()->unset_need_bitmap_reset();\n+    }\n+  } else {\n+    _generation->reset_mark_bitmap();\n+    _generation->unset_need_bitmap_reset();\n+\n+  }\n@@ -1230,0 +1266,8 @@\n+const char* ShenandoahConcurrentGC::conc_reset_after_collect_event_message() const {\n+  if (ShenandoahHeap::heap()->unload_classes()) {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent reset after collect\", \" (unload classes)\");\n+  } else {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent reset after collect\", \"\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  void op_reset_after_collect();\n@@ -135,0 +136,2 @@\n+  \/\/ Called when concurrent GC succeeds.\n+  void entry_reset_after_collect();\n@@ -148,0 +151,1 @@\n+  const char* conc_reset_after_collect_event_message() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -196,0 +196,2 @@\n+    heap->global_generation()->set_need_bitmap_reset();\n+    heap->global_generation()->set_mark_incomplete();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,2 @@\n-  ShenandoahHeap* _heap;\n+  ShenandoahGeneration* const _generation;\n+  ShenandoahHeap* const _heap;\n@@ -50,1 +51,2 @@\n-  ShenandoahResetUpdateRegionStateClosure() :\n+  ShenandoahResetUpdateRegionStateClosure(ShenandoahGeneration* generation) :\n+    _generation(generation),\n@@ -55,1 +57,1 @@\n-    if (r->is_active()) {\n+    if (r->is_active() && _generation->contains(r)) {\n@@ -70,0 +72,1 @@\n+  bool const _include_not_affiliated;\n@@ -72,2 +75,4 @@\n-  ShenandoahResetBitmapTask(ShenandoahGeneration* generation) :\n-    WorkerTask(\"Shenandoah Reset Bitmap\"), _generation(generation) {}\n+  ShenandoahResetBitmapTask(ShenandoahGeneration* generation, bool const include_not_affiliated = true) :\n+    WorkerTask(\"Shenandoah Reset Bitmap\"),\n+    _generation(generation),\n+    _include_not_affiliated(include_not_affiliated){}\n@@ -81,1 +86,1 @@\n-      bool needs_reset = affiliation == FREE || _generation->contains(affiliation);\n+      bool needs_reset = (_include_not_affiliated && affiliation == FREE) || _generation->contains(affiliation);\n@@ -192,1 +197,1 @@\n-void ShenandoahGeneration::reset_mark_bitmap() {\n+void ShenandoahGeneration::reset_mark_bitmap(bool include_not_affiliated) {\n@@ -196,3 +201,1 @@\n-  set_mark_incomplete();\n-\n-  ShenandoahResetBitmapTask task(this);\n+  ShenandoahResetBitmapTask task(this, include_not_affiliated);\n@@ -232,0 +235,12 @@\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  if (need_bitmap_reset()) {\n+    if (heap->mode()->is_generational() && is_global() && !heap->young_generation()->need_bitmap_reset()) {\n+      assert(heap->young_generation()->is_bitmap_clear(), \"Bitmap of young generation must be clear.\");\n+      \/\/Only need to reset bitmap for old generation.\n+      heap->old_generation()->reset_mark_bitmap(false);\n+    } else {\n+      reset_mark_bitmap();\n+    }\n+  }\n+  \/\/ For next cycle\n+  set_need_bitmap_reset();\n@@ -233,1 +248,1 @@\n-  reset_mark_bitmap();\n+  set_mark_incomplete();\n@@ -235,2 +250,2 @@\n-  \/\/ Capture Top At Mark Start for this generation (typically young) and reset mark bitmap.\n-  ShenandoahResetUpdateRegionStateClosure cl;\n+  \/\/ Capture Top At Mark Start for this generation (typically young).\n+  ShenandoahResetUpdateRegionStateClosure cl(this);\n@@ -765,0 +780,16 @@\n+bool ShenandoahGeneration::need_bitmap_reset() {\n+  return _need_bitmap_reset.is_set();\n+}\n+\n+void ShenandoahGeneration::set_need_bitmap_reset() {\n+  _need_bitmap_reset.set();\n+  if (ShenandoahHeap::heap()->mode()->is_generational() && is_global()) {\n+    ShenandoahHeap::heap()->old_generation()->set_need_bitmap_reset();\n+    ShenandoahHeap::heap()->young_generation()->set_need_bitmap_reset();\n+  }\n+}\n+\n+void ShenandoahGeneration::unset_need_bitmap_reset() {\n+  _need_bitmap_reset.unset();\n+}\n+\n@@ -805,0 +836,1 @@\n+  _need_bitmap_reset.set();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":45,"deletions":13,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  ShenandoahSharedFlag _need_bitmap_reset;\n@@ -162,1 +163,1 @@\n-  void reset_mark_bitmap();\n+  void reset_mark_bitmap(bool include_not_affiliated = true);\n@@ -202,0 +203,5 @@\n+  \/\/ Fast check if the mark bitmap need to be reset for next cycle.\n+  bool need_bitmap_reset();\n+  void set_need_bitmap_reset();\n+  void unset_need_bitmap_reset();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  f(conc_reset_after_collect,                       \"Concurrent Reset After Collect\")  \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}