{"files":[{"patch":"@@ -239,0 +239,5 @@\n+\n+  \/\/ Instead of always reset before collect, some reset can be done after collect to save\n+  \/\/ the time before before the cycle so the cycle can be started as soon as possible.\n+  entry_reset_after_collect();\n+\n@@ -581,0 +586,10 @@\n+void ShenandoahConcurrentGC::entry_reset_after_collect() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  const char* msg = conc_reset_after_collect_event_message();\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset_after_collect);\n+  EventMark em(\"%s\", msg);\n+\n+  op_reset_after_collect();\n+}\n+\n@@ -1178,1 +1193,22 @@\n-  ShenandoahHeap::heap()->free_set()->recycle_trash();\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  heap->free_set()->recycle_trash();\n+}\n+\n+void ShenandoahConcurrentGC::op_reset_after_collect() {\n+  ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n+                          ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n+                          \"reset after collection.\");\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational()) {\n+    if (!_do_old_gc_bootstrap) {\n+      \/\/ Only reset for young generation, bitmap for old generation must be retained,\n+      \/\/ except there is collection(global\/old\/degen\/full) trigged to collect regions in old gen.\n+      heap->young_generation()->reset_mark_bitmap();\n+      heap->young_generation()->unset_need_bitmap_reset();\n+    }\n+  } else {\n+    _generation->reset_mark_bitmap();\n+    _generation->unset_need_bitmap_reset();\n+\n+  }\n@@ -1230,0 +1266,8 @@\n+const char* ShenandoahConcurrentGC::conc_reset_after_collect_event_message() const {\n+  if (ShenandoahHeap::heap()->unload_classes()) {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent reset after collect\", \" (unload classes)\");\n+  } else {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent reset after collect\", \"\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  void op_reset_after_collect();\n@@ -135,0 +136,2 @@\n+  \/\/ Called when concurrent GC succeeds.\n+  void entry_reset_after_collect();\n@@ -148,0 +151,1 @@\n+  const char* conc_reset_after_collect_event_message() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -196,0 +196,2 @@\n+    heap->global_generation()->set_need_bitmap_reset();\n+    heap->global_generation()->set_mark_incomplete();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+  bool const _include_not_affiliated;\n@@ -72,2 +73,4 @@\n-  ShenandoahResetBitmapTask(ShenandoahGeneration* generation) :\n-    WorkerTask(\"Shenandoah Reset Bitmap\"), _generation(generation) {}\n+  ShenandoahResetBitmapTask(ShenandoahGeneration* generation, bool const include_not_affiliated = true) :\n+    WorkerTask(\"Shenandoah Reset Bitmap\"),\n+    _generation(generation),\n+    _include_not_affiliated(include_not_affiliated){}\n@@ -80,1 +83,1 @@\n-      bool needs_reset = _generation->contains(region) || !region->is_affiliated();\n+      bool needs_reset = _generation->contains(region) || (_include_not_affiliated && !region->is_affiliated());\n@@ -191,1 +194,1 @@\n-void ShenandoahGeneration::reset_mark_bitmap() {\n+void ShenandoahGeneration::reset_mark_bitmap(bool include_not_affiliated) {\n@@ -195,3 +198,1 @@\n-  set_mark_incomplete();\n-\n-  ShenandoahResetBitmapTask task(this);\n+  ShenandoahResetBitmapTask task(this, include_not_affiliated);\n@@ -231,0 +232,12 @@\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  if (need_bitmap_reset()) {\n+    if (heap->mode()->is_generational() && is_global() && !heap->young_generation()->need_bitmap_reset()) {\n+      assert(heap->young_generation()->is_bitmap_clear(), \"Bitmap of young generation must be clear.\");\n+      \/\/Only need to reset bitmap for old generation.\n+      heap->old_generation()->reset_mark_bitmap(false);\n+    } else {\n+      reset_mark_bitmap();\n+    }\n+  }\n+  \/\/ For next cycle\n+  set_need_bitmap_reset();\n@@ -232,1 +245,1 @@\n-  reset_mark_bitmap();\n+  set_mark_incomplete();\n@@ -764,0 +777,16 @@\n+bool ShenandoahGeneration::need_bitmap_reset() {\n+  return _need_bitmap_reset.is_set();\n+}\n+\n+void ShenandoahGeneration::set_need_bitmap_reset() {\n+  _need_bitmap_reset.set();\n+  if (ShenandoahHeap::heap()->mode()->is_generational() && is_global()) {\n+    ShenandoahHeap::heap()->old_generation()->set_need_bitmap_reset();\n+    ShenandoahHeap::heap()->young_generation()->set_need_bitmap_reset();\n+  }\n+}\n+\n+void ShenandoahGeneration::unset_need_bitmap_reset() {\n+  _need_bitmap_reset.unset();\n+}\n+\n@@ -804,0 +833,1 @@\n+  _need_bitmap_reset.set();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+  ShenandoahSharedFlag _need_bitmap_reset;\n@@ -161,1 +162,1 @@\n-  void reset_mark_bitmap();\n+  void reset_mark_bitmap(bool include_not_affiliated = true);\n@@ -199,0 +200,5 @@\n+  \/\/ Fast check if the mark bitmap need to be reset for next cycle.\n+  bool need_bitmap_reset();\n+  void set_need_bitmap_reset();\n+  void unset_need_bitmap_reset();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -854,0 +854,5 @@\n+  if (region_affiliation == OLD_GENERATION) {\n+    \/\/Need to reset bitmap in next GC after change affiliation from OLD_GENERATION\n+    heap->young_generation()->set_need_bitmap_reset();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -155,0 +155,2 @@\n+  entry_reset_after_collect();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  f(conc_reset_after_collect,                       \"Concurrent Reset After Collect\")  \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}