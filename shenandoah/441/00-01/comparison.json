{"files":[{"patch":"@@ -107,1 +107,1 @@\n-  void entry_global_coalesce_and_fill();\n+\n@@ -127,1 +127,1 @@\n-  void op_global_coalesce_and_fill();\n+\n@@ -136,0 +136,2 @@\n+  static bool has_in_place_promotions(ShenandoahHeap* heap) ;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-      }\n@@ -169,7 +168,8 @@\n-      if (_degen_point == ShenandoahDegenPoint::_degenerated_roots) {\n-        \/\/ We only need this if the concurrent cycle has already swapped the card tables.\n-        \/\/ Marking will use the 'read' table, but interesting pointers may have been\n-        \/\/ recorded in the 'write' table in the time between the cancelled concurrent cycle\n-        \/\/ and this degenerated cycle. These pointers need to be included the 'read' table\n-        \/\/ used to scan the remembered set during the STW mark which follows here.\n-        _generation->merge_write_table();\n+        if (_degen_point == ShenandoahDegenPoint::_degenerated_roots) {\n+          \/\/ We only need this if the concurrent cycle has already swapped the card tables.\n+          \/\/ Marking will use the 'read' table, but interesting pointers may have been\n+          \/\/ recorded in the 'write' table in the time between the cancelled concurrent cycle\n+          \/\/ and this degenerated cycle. These pointers need to be included the 'read' table\n+          \/\/ used to scan the remembered set during the STW mark which follows here.\n+          _generation->merge_write_table();\n+        }\n@@ -283,7 +283,0 @@\n-      if (heap->mode()->is_generational() && heap->is_concurrent_old_mark_in_progress()) {\n-        \/\/ This is still necessary for degenerated cycles because the degeneration point may occur\n-        \/\/ after final mark of the young generation. See ShenandoahConcurrentGC::op_final_updaterefs for\n-        \/\/ a more detailed explanation.\n-        heap->old_generation()->transfer_pointers_from_satb();\n-      }\n-\n@@ -291,1 +284,1 @@\n-      \/\/ We defer generation resizing actions until after cset regions have been recycled.\n+\n@@ -293,6 +286,1 @@\n-        auto result = ShenandoahGenerationalHeap::heap()->balance_generations();\n-        LogTarget(Info, gc, ergo) lt;\n-        if (lt.is_enabled()) {\n-          LogStream ls(lt);\n-          result.print_on(\"Degenerated GC\", &ls);\n-        }\n+        ShenandoahGenerationalHeap::heap()->complete_degenerated_cycle();\n@@ -300,0 +288,1 @@\n+\n@@ -305,10 +294,0 @@\n-  if (heap->mode()->is_generational()) {\n-    \/\/ In case degeneration interrupted concurrent evacuation or update references, we need to clean up transient state.\n-    \/\/ Otherwise, these actions have no effect.\n-    ShenandoahGenerationalHeap::heap()->reset_generation_reserves();\n-\n-    if (!ShenandoahGenerationalHeap::heap()->old_generation()->is_parseable()) {\n-      op_global_coalesce_and_fill();\n-    }\n-  }\n-\n@@ -406,5 +385,0 @@\n-void ShenandoahDegenGC::op_global_coalesce_and_fill() {\n-  ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_coalesce_and_fill);\n-  ShenandoahGenerationalHeap::heap()->coalesce_and_fill_old_regions(false);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":11,"deletions":37,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -61,3 +61,0 @@\n-  \/\/ This will rebuild card offsets, which is necessary if classes were unloaded\n-  void op_global_coalesce_and_fill();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n@@ -41,0 +42,1 @@\n+#include \"gc\/shenandoah\/shenandoahWorkerPolicy.hpp\"\n@@ -44,0 +46,1 @@\n+#include \"utilities\/events.hpp\"\n@@ -946,0 +949,83 @@\n+\n+void ShenandoahGenerationalHeap::complete_degenerated_cycle() {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  if (is_concurrent_old_mark_in_progress()) {\n+    \/\/ This is still necessary for degenerated cycles because the degeneration point may occur\n+    \/\/ after final mark of the young generation. See ShenandoahConcurrentGC::op_final_updaterefs for\n+    \/\/ a more detailed explanation.\n+    old_generation()->transfer_pointers_from_satb();\n+  }\n+\n+  \/\/ We defer generation resizing actions until after cset regions have been recycled.\n+  TransferResult result = balance_generations();\n+  LogTarget(Info, gc, ergo) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    result.print_on(\"Degenerated GC\", &ls);\n+  }\n+\n+  \/\/ In case degeneration interrupted concurrent evacuation or update references, we need to clean up\n+  \/\/ transient state. Otherwise, these actions have no effect.\n+  reset_generation_reserves();\n+\n+  if (!old_generation()->is_parseable()) {\n+    ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_coalesce_and_fill);\n+    coalesce_and_fill_old_regions(false);\n+  }\n+}\n+\n+void ShenandoahGenerationalHeap::complete_concurrent_cycle() {\n+  if (!old_generation()->is_parseable()) {\n+    \/\/ Class unloading may render the card offsets unusable, so we must rebuild them before\n+    \/\/ the next remembered set scan. We _could_ let the control thread do this sometime after\n+    \/\/ the global cycle has completed and before the next young collection, but under memory\n+    \/\/ pressure the control thread may not have the time (that is, because it's running back\n+    \/\/ to back GCs). In that scenario, we would have to make the old regions parsable before\n+    \/\/ we could start a young collection. This could delay the start of the young cycle and\n+    \/\/ throw off the heuristics.\n+    entry_global_coalesce_and_fill();\n+  }\n+\n+  TransferResult result;\n+  {\n+    ShenandoahHeapLocker locker(lock());\n+\n+    result = balance_generations();\n+    reset_generation_reserves();\n+  }\n+\n+  LogTarget(Info, gc, ergo) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    result.print_on(\"Concurrent GC\", &ls);\n+  }\n+}\n+\n+void ShenandoahGenerationalHeap::entry_global_coalesce_and_fill() {\n+  const char* msg = \"Coalescing and filling old regions\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_coalesce_and_fill);\n+\n+  TraceCollectorStats tcs(monitoring_support()->concurrent_collection_counters());\n+  EventMark em(\"%s\", msg);\n+  ShenandoahWorkerScope scope(workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n+                              \"concurrent coalesce and fill\");\n+\n+  coalesce_and_fill_old_regions(true);\n+}\n+\n+void ShenandoahGenerationalHeap::update_region_ages() {\n+  ShenandoahMarkingContext *ctx = complete_marking_context();\n+  for (size_t i = 0; i < num_regions(); i++) {\n+    ShenandoahHeapRegion *r = get_region(i);\n+    if (r->is_active() && r->is_young()) {\n+      HeapWord* tams = ctx->top_at_mark_start(r);\n+      HeapWord* top = r->top();\n+      if (top > tams) {\n+        r->reset_age();\n+      } else if (is_aging_cycle()) {\n+        r->increment_age();\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":86,"deletions":0,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -53,0 +53,4 @@\n+  \/\/ Ages regions that haven't been used for allocations in the current cycle.\n+  \/\/ Resets ages for regions that have been used for allocations.\n+  void update_region_ages();\n+\n@@ -65,0 +69,1 @@\n+\n@@ -106,3 +111,3 @@\n-  \/\/ Makes old regions parsable\n-  void coalesce_and_fill_old_regions(bool concurrent);\n-\n+  \/\/ Balances generations, coalesces and fills old regions if necessary\n+  void complete_degenerated_cycle();\n+  void complete_concurrent_cycle();\n@@ -111,0 +116,4 @@\n+  void entry_global_coalesce_and_fill();\n+\n+  \/\/ Makes old regions parsable. This will also rebuild card offsets, which is necessary if classes were unloaded\n+  void coalesce_and_fill_old_regions(bool concurrent);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"}]}