{"files":[{"patch":"@@ -1166,2 +1166,13 @@\n-  size_t young_reserve, old_reserve;\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t young_reserve(0), old_reserve(0);\n+\n+\n+  \/\/ Evac reserve: reserve trailing space for evacuations, with regions reserved for old evacuations placed to the right\n+  \/\/ of regions reserved of young evacuations.\n+  if (!_heap->mode()->is_generational()) {\n+    young_reserve = (_heap->max_capacity() \/ 100) * ShenandoahEvacReserve;\n+    old_reserve = 0;\n+  } else {\n+    compute_young_and_old_reserves(young_cset_regions, old_cset_regions, have_evacuation_reserves,\n+                                   &young_reserve, &old_reserve);\n+\n+  }\n@@ -1169,2 +1180,13 @@\n-  ShenandoahOldGeneration* old_generation = _heap->old_generation();\n-  size_t old_capacity = old_generation->max_capacity();\n+  reserve_regions(young_reserve, old_reserve);\n+  _free_sets.establish_alloc_bias(OldCollector);\n+  _free_sets.assert_bounds();\n+  log_status();\n+}\n+\n+void ShenandoahFreeSet::compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions,\n+                                                       bool have_evacuation_reserves, size_t* young_reserve_result,\n+                                                       size_t* old_reserve_result) const {\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t young_reserve(0), old_reserve(0);\n+\n+  ShenandoahOldGeneration* const old_generation = _heap->old_generation();\n@@ -1173,1 +1195,1 @@\n-  ShenandoahYoungGeneration* young_generation = _heap->young_generation();\n+  ShenandoahYoungGeneration* const young_generation = _heap->young_generation();\n@@ -1175,1 +1197,0 @@\n-  size_t young_available = young_generation->available();\n@@ -1178,0 +1199,1 @@\n+  \/\/ Add in the regions we anticipate to be freed by evacuation of the collection set\n@@ -1181,1 +1203,0 @@\n-  young_available += young_cset_regions * region_size_bytes;\n@@ -1183,1 +1204,1 @@\n-  \/\/ Consult old-region surplus and deficit to make adjustments to current generation capacities and availability.\n+  \/\/ Consult old-region balance to make adjustments to current generation capacities and availability.\n@@ -1185,2 +1206,7 @@\n-  size_t old_region_surplus = old_generation->get_region_surplus();\n-  size_t old_region_deficit = old_generation->get_region_deficit();\n+  const ssize_t old_region_balance = old_generation->get_region_balance();\n+  if (old_region_balance != 0) {\n+    if (old_region_balance > 0) {\n+      assert(old_region_balance <= checked_cast<ssize_t>(old_unaffiliated_regions), \"Cannot transfer regions that are affiliated\");\n+    } else {\n+      assert(0 - old_region_balance <= checked_cast<ssize_t>(young_unaffiliated_regions), \"Cannot transfer regions that are affiliated\");\n+    }\n@@ -1188,4 +1214,1 @@\n-  if (old_region_surplus > 0) {\n-    size_t xfer_bytes = old_region_surplus * region_size_bytes;\n-    assert(old_region_surplus <= old_unaffiliated_regions, \"Cannot transfer regions that are affiliated\");\n-    old_capacity -= xfer_bytes;\n+    ssize_t xfer_bytes = old_region_balance * checked_cast<ssize_t>(region_size_bytes);\n@@ -1193,1 +1216,1 @@\n-    old_unaffiliated_regions -= old_region_surplus;\n+    old_unaffiliated_regions -= old_region_balance;\n@@ -1195,11 +1218,1 @@\n-    young_available += xfer_bytes;\n-    young_unaffiliated_regions += old_region_surplus;\n-  } else if (old_region_deficit > 0) {\n-    size_t xfer_bytes = old_region_deficit * region_size_bytes;\n-    assert(old_region_deficit <= young_unaffiliated_regions, \"Cannot transfer regions that are affiliated\");\n-    old_capacity += xfer_bytes;\n-    old_available += xfer_bytes;\n-    old_unaffiliated_regions += old_region_deficit;\n-    young_capacity -= xfer_bytes;\n-    young_available -= xfer_bytes;\n-    young_unaffiliated_regions -= old_region_deficit;\n+    young_unaffiliated_regions += old_region_balance;\n@@ -1208,5 +1221,13 @@\n-  \/\/ Evac reserve: reserve trailing space for evacuations, with regions reserved for old evacuations placed to the right\n-  \/\/ of regions reserved of young evacuations.\n-  if (!_heap->mode()->is_generational()) {\n-    young_reserve = (_heap->max_capacity() \/ 100) * ShenandoahEvacReserve;\n-    old_reserve = 0;\n+  \/\/ All allocations taken from the old collector set are performed by GC, generally using PLABs for both\n+  \/\/ promotions and evacuations.  The partition between which old memory is reserved for evacuation and\n+  \/\/ which is reserved for promotion is enforced using thread-local variables that prescribe intentons for\n+  \/\/ each PLAB's available memory.\n+  if (have_evacuation_reserves) {\n+    \/\/ We are rebuilding at the end of final mark, having already established evacuation budgets for this GC pass.\n+    const size_t promoted_reserve = old_generation->get_promoted_reserve();\n+    const size_t old_evac_reserve = old_generation->get_evacuation_reserve();\n+    young_reserve = young_generation->get_evacuation_reserve();\n+    old_reserve = promoted_reserve + old_evac_reserve;\n+    assert(old_reserve <= old_available,\n+           \"Cannot reserve (\" SIZE_FORMAT \" + \" SIZE_FORMAT\") more OLD than is available: \" SIZE_FORMAT,\n+           promoted_reserve, old_evac_reserve, old_available);\n@@ -1214,22 +1235,6 @@\n-    \/\/ All allocations taken from the old collector set are performed by GC, generally using PLABs for both\n-    \/\/ promotions and evacuations.  The partition between which old memory is reserved for evacuation and\n-    \/\/ which is reserved for promotion is enforced using thread-local variables that prescribe intentons for\n-    \/\/ each PLAB's available memory.\n-    if (have_evacuation_reserves) {\n-      \/\/ We are rebuilding at the end of final mark, having already established evacuation budgets for this GC pass.\n-\n-      size_t promoted_reserve = old_generation->get_promoted_reserve();\n-      size_t old_evac_reserve = old_generation->get_evacuation_reserve();\n-      young_reserve = young_generation->get_evacuation_reserve();\n-      old_reserve = promoted_reserve + old_evac_reserve;\n-      assert(old_reserve <= old_available,\n-             \"Cannot reserve (\" SIZE_FORMAT \" + \" SIZE_FORMAT\") more OLD than is available: \" SIZE_FORMAT,\n-             promoted_reserve, old_evac_reserve, old_available);\n-    } else {\n-      \/\/ We are rebuilding at end of GC, so we set aside budgets specified on command line (or defaults)\n-      young_reserve = (young_capacity * ShenandoahEvacReserve) \/ 100;\n-      \/\/ The auto-sizer has already made old-gen large enough to hold all anticipated evacuations and promotions.\n-      \/\/ Affiliated old-gen regions are already in the OldCollector free set.  Add in the relevant number of\n-      \/\/ unaffiliated regions.\n-      old_reserve = old_available;\n-    }\n+    \/\/ We are rebuilding at end of GC, so we set aside budgets specified on command line (or defaults)\n+    young_reserve = (young_capacity * ShenandoahEvacReserve) \/ 100;\n+    \/\/ The auto-sizer has already made old-gen large enough to hold all anticipated evacuations and promotions.\n+    \/\/ Affiliated old-gen regions are already in the OldCollector free set.  Add in the relevant number of\n+    \/\/ unaffiliated regions.\n+    old_reserve = old_available;\n@@ -1250,4 +1255,2 @@\n-  reserve_regions(young_reserve, old_reserve);\n-  _free_sets.establish_alloc_bias(OldCollector);\n-  _free_sets.assert_bounds();\n-  log_status();\n+  *young_reserve_result = young_reserve;\n+  *old_reserve_result = old_reserve;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":60,"deletions":57,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -236,0 +236,3 @@\n+\n+  void compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions, bool have_evacuation_reserves,\n+                                      size_t* young_reserve, size_t* old_reserve) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -124,4 +124,2 @@\n-  const size_t old_region_surplus = old_gen->get_region_surplus();\n-  const size_t old_region_deficit = old_gen->get_region_deficit();\n-  old_gen->set_region_surplus(0);\n-  old_gen->set_region_deficit(0);\n+  const ssize_t old_region_balance = old_gen->get_region_balance();\n+  old_gen->set_region_balance(0);\n@@ -129,2 +127,3 @@\n-  if (old_region_surplus) {\n-    bool success = generation_sizer()->transfer_to_young(old_region_surplus);\n+  if (old_region_balance > 0) {\n+    const auto old_region_surplus = checked_cast<size_t>(old_region_balance);\n+    const bool success = generation_sizer()->transfer_to_young(old_region_surplus);\n@@ -136,1 +135,2 @@\n-  if (old_region_deficit) {\n+  if (old_region_balance < 0) {\n+    const auto old_region_deficit = checked_cast<size_t>(-old_region_balance);\n@@ -221,3 +221,0 @@\n-  size_t old_region_deficit = 0;\n-  size_t old_region_surplus = 0;\n-\n@@ -228,1 +225,0 @@\n-    old_region_surplus = old_surplus \/ region_size_bytes;\n@@ -230,1 +226,2 @@\n-    old_region_surplus = MIN2(old_region_surplus, unaffiliated_old_regions);\n+    const size_t old_region_surplus = MIN2(old_surplus \/ region_size_bytes, unaffiliated_old_regions);\n+    old_generation()->set_region_balance(checked_cast<ssize_t>(old_region_surplus));\n@@ -236,0 +233,2 @@\n+    const size_t max_old_region_xfer = old_xfer_limit \/ region_size_bytes;\n+\n@@ -237,1 +236,1 @@\n-    old_region_deficit = (old_need + region_size_bytes - 1) \/ region_size_bytes;\n+    size_t old_region_deficit = (old_need + region_size_bytes - 1) \/ region_size_bytes;\n@@ -242,1 +241,0 @@\n-    const size_t max_old_region_xfer = old_xfer_limit \/ region_size_bytes;\n@@ -244,0 +242,1 @@\n+    old_generation()->set_region_balance(0 - checked_cast<ssize_t>(old_region_deficit));\n@@ -245,4 +244,0 @@\n-  assert(old_region_deficit == 0 || old_region_surplus == 0, \"Only surplus or deficit, never both\");\n-\n-  old_generation()->set_region_surplus(old_region_surplus);\n-  old_generation()->set_region_deficit(old_region_deficit);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -172,2 +172,1 @@\n-    _region_surplus(0),\n-    _region_deficit(0),\n+    _region_balance(0),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,6 +40,6 @@\n-  \/\/ After determining the desired size of the old generation (see compute_old_generation_balance), these\n-  \/\/ quantities represent the number of regions above (surplus) or below (deficit) that size.\n-  \/\/ These values are computed prior to the actual exchange of any regions. These may never both\n-  \/\/ be positive simultaneously.\n-  size_t _region_surplus;\n-  size_t _region_deficit;\n+  \/\/ After determining the desired size of the old generation (see compute_old_generation_balance), this\n+  \/\/ quantity represents the number of regions above (surplus) or below (deficit) that size.\n+  \/\/ This value is computed prior to the actual exchange of any regions. A positive value represents\n+  \/\/ a surplus of old regions which will be transferred from old _to_ young. A negative value represents\n+  \/\/ a deficit of regions that will be replenished by a transfer _from_ young to old.\n+  ssize_t _region_balance;\n@@ -110,5 +110,2 @@\n-  void set_region_surplus(size_t surplus) { _region_surplus = surplus; };\n-  void set_region_deficit(size_t deficit) { _region_deficit = deficit; };\n-  size_t get_region_surplus() const { return _region_surplus; };\n-  size_t get_region_deficit() const { return _region_deficit; };\n-\n+  void set_region_balance(ssize_t balance) { _region_balance = balance; }\n+  ssize_t get_region_balance() const { return _region_balance; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"}]}