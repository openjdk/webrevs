{"files":[{"patch":"@@ -1173,1 +1173,1 @@\n-                                   &young_reserve, &old_reserve);\n+                                   young_reserve, old_reserve);\n@@ -1183,3 +1183,2 @@\n-void ShenandoahFreeSet::compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions,\n-                                                       bool have_evacuation_reserves, size_t* young_reserve_result,\n-                                                       size_t* old_reserve_result) const {\n+void ShenandoahFreeSet::compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions, bool have_evacuation_reserves,\n+                                                       size_t& young_reserve_result, size_t& old_reserve_result) const {\n@@ -1187,1 +1186,0 @@\n-  size_t young_reserve(0), old_reserve(0);\n@@ -1220,1 +1218,1 @@\n-  \/\/ which is reserved for promotion is enforced using thread-local variables that prescribe intentons for\n+  \/\/ which is reserved for promotion is enforced using thread-local variables that prescribe intentions for\n@@ -1226,3 +1224,3 @@\n-    young_reserve = young_generation->get_evacuation_reserve();\n-    old_reserve = promoted_reserve + old_evac_reserve;\n-    assert(old_reserve <= old_available,\n+    young_reserve_result = young_generation->get_evacuation_reserve();\n+    old_reserve_result = promoted_reserve + old_evac_reserve;\n+    assert(old_reserve_result <= old_available,\n@@ -1233,1 +1231,1 @@\n-    young_reserve = (young_capacity * ShenandoahEvacReserve) \/ 100;\n+    young_reserve_result = (young_capacity * ShenandoahEvacReserve) \/ 100;\n@@ -1237,1 +1235,1 @@\n-    old_reserve = old_available;\n+    old_reserve_result = old_available;\n@@ -1244,2 +1242,2 @@\n-  if (old_reserve > _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes) {\n-    old_reserve = _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes;\n+  if (old_reserve_result > _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes) {\n+    old_reserve_result = _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes;\n@@ -1248,2 +1246,2 @@\n-  if (young_reserve > young_unaffiliated_regions * region_size_bytes) {\n-    young_reserve = young_unaffiliated_regions * region_size_bytes;\n+  if (old_reserve_result > young_unaffiliated_regions * region_size_bytes) {\n+    young_reserve_result = young_unaffiliated_regions * region_size_bytes;\n@@ -1251,3 +1249,0 @@\n-\n-  *young_reserve_result = young_reserve;\n-  *old_reserve_result = old_reserve;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-                                      size_t* young_reserve, size_t* old_reserve) const;\n+                                      size_t &young_reserve_result, size_t &old_reserve_result) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-    const size_t old_surplus = max_old_available - old_reserve;\n+    const size_t old_surplus = (max_old_available - old_reserve) \/ region_size_bytes;\n@@ -226,1 +226,1 @@\n-    const size_t old_region_surplus = MIN2(old_surplus \/ region_size_bytes, unaffiliated_old_regions);\n+    const size_t old_region_surplus = MIN2(old_surplus, unaffiliated_old_regions);\n@@ -232,1 +232,2 @@\n-    const size_t old_need = old_reserve - max_old_available;\n+    \/\/ Note that deficit is rounded up by one region.\n+    const size_t old_need = (old_reserve - max_old_available + region_size_bytes - 1) \/ region_size_bytes;\n@@ -235,3 +236,0 @@\n-    \/\/ The old region deficit (rounded up) will come from young\n-    size_t old_region_deficit = (old_need + region_size_bytes - 1) \/ region_size_bytes;\n-\n@@ -241,1 +239,1 @@\n-    old_region_deficit = MIN2(old_region_deficit, max_old_region_xfer);\n+    const size_t old_region_deficit = MIN2(old_need, max_old_region_xfer);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -502,30 +502,0 @@\n-size_t ShenandoahHeap::max_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return _generation_sizer.max_young_size();\n-    case OLD:\n-      return max_capacity() - _generation_sizer.min_young_size();\n-    case GLOBAL:\n-    case NON_GEN:\n-      return max_capacity();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n-size_t ShenandoahHeap::min_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return _generation_sizer.min_young_size();\n-    case OLD:\n-      return max_capacity() - _generation_sizer.max_young_size();\n-    case GLOBAL:\n-    case NON_GEN:\n-      return min_capacity();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -516,3 +516,0 @@\n-  size_t max_size_for(ShenandoahGeneration* generation) const;\n-  size_t min_size_for(ShenandoahGeneration* generation) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -269,7 +269,2 @@\n-\/\/ Returns true iff transfer is successful\n-bool ShenandoahGenerationSizer::transfer_to_old(size_t regions) const {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  ShenandoahGeneration* old_gen = heap->old_generation();\n-  ShenandoahGeneration* young_gen = heap->young_generation();\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-  size_t bytes_to_transfer = regions * region_size_bytes;\n+bool ShenandoahGenerationSizer::transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const {\n+  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n@@ -277,1 +272,3 @@\n-  if (young_gen->free_unaffiliated_regions() < regions) {\n+  if (src->free_unaffiliated_regions() < regions) {\n+    \/\/ Source does not have enough free regions for this transfer. The caller should have\n+    \/\/ already capped the transfer based on available unaffiliated regions.\n@@ -279,1 +276,4 @@\n-  } else if (old_gen->max_capacity() + bytes_to_transfer > heap->max_size_for(old_gen)) {\n+  }\n+\n+  if (dst->max_capacity() + bytes_to_transfer > max_size_for(dst)) {\n+    \/\/ This transfer would cause the destination generation to grow above its configured maximum size.\n@@ -281,1 +281,4 @@\n-  } else if (young_gen->max_capacity() - bytes_to_transfer < heap->min_size_for(young_gen)) {\n+  }\n+\n+  if (src->max_capacity() - bytes_to_transfer < min_size_for(src)) {\n+    \/\/ This transfer would cause the source generation to shrink below its configured minimum size.\n@@ -283,8 +286,0 @@\n-  } else {\n-    young_gen->decrease_capacity(bytes_to_transfer);\n-    old_gen->increase_capacity(bytes_to_transfer);\n-    size_t new_size = old_gen->max_capacity();\n-    log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" SIZE_FORMAT \"%s\",\n-                 regions, young_gen->name(), old_gen->name(),\n-                 byte_size_in_proper_unit(new_size), proper_unit_for_byte_size(new_size));\n-    return true;\n@@ -292,0 +287,39 @@\n+\n+  src->decrease_capacity(bytes_to_transfer);\n+  dst->increase_capacity(bytes_to_transfer);\n+  const size_t new_size = dst->max_capacity();\n+  log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+               regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n+  return true;\n+}\n+\n+\n+size_t ShenandoahGenerationSizer::max_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->type()) {\n+    case YOUNG:\n+      return max_young_size();\n+    case OLD:\n+      return min_young_size();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+size_t ShenandoahGenerationSizer::min_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->type()) {\n+    case YOUNG:\n+      return min_young_size();\n+    case OLD:\n+      return ShenandoahHeap::heap()->max_capacity() - max_young_size();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+\n+\/\/ Returns true iff transfer is successful\n+bool ShenandoahGenerationSizer::transfer_to_old(size_t regions) const {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  return transfer_regions(heap->young_generation(), heap->old_generation(), regions);\n@@ -300,2 +334,1 @@\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-  size_t bytes_to_transfer = regions * region_size_bytes;\n+  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n@@ -305,4 +338,3 @@\n-  size_t new_size = old_gen->max_capacity();\n-  log_info(gc)(\"Forcing transfer of \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" SIZE_FORMAT \"%s\",\n-               regions, young_gen->name(), old_gen->name(),\n-               byte_size_in_proper_unit(new_size), proper_unit_for_byte_size(new_size));\n+  const size_t new_size = old_gen->max_capacity();\n+  log_info(gc)(\"Forcing transfer of \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+               regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n@@ -314,20 +346,1 @@\n-  ShenandoahGeneration* old_gen = heap->old_generation();\n-  ShenandoahGeneration* young_gen = heap->young_generation();\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-  size_t bytes_to_transfer = regions * region_size_bytes;\n-\n-  if (old_gen->free_unaffiliated_regions() < regions) {\n-    return false;\n-  } else if (young_gen->max_capacity() + bytes_to_transfer > heap->max_size_for(young_gen)) {\n-    return false;\n-  } else if (old_gen->max_capacity() - bytes_to_transfer < heap->min_size_for(old_gen)) {\n-    return false;\n-  } else {\n-    old_gen->decrease_capacity(bytes_to_transfer);\n-    young_gen->increase_capacity(bytes_to_transfer);\n-    size_t new_size = young_gen->max_capacity();\n-    log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" SIZE_FORMAT \"%s\",\n-                 regions, old_gen->name(), young_gen->name(),\n-                 byte_size_in_proper_unit(new_size), proper_unit_for_byte_size(new_size));\n-    return true;\n-  }\n+  return transfer_regions(heap->old_generation(), heap->young_generation(), regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":57,"deletions":44,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -128,1 +128,5 @@\n-public:\n+  bool transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const;\n+  size_t max_size_for(ShenandoahGeneration* generation) const;\n+  size_t min_size_for(ShenandoahGeneration* generation) const;\n+\n+    public:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}