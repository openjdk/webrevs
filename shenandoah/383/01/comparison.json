{"files":[{"patch":"@@ -3,0 +3,1 @@\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +30,1 @@\n-    echo \"are in the canonical order given by Modifier#toString().\"\n+    echo \"are in the canonical order.\"\n@@ -34,1 +35,6 @@\n-    echo \"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/lang\/reflect\/Modifier.html#toString-int-\"\n+    echo \"https:\/\/docs.oracle.com\/javase\/specs\/jls\/se21\/html\/jls-8.html#jls-8.1.1\"\n+    echo \"https:\/\/docs.oracle.com\/javase\/specs\/jls\/se21\/html\/jls-8.html#jls-8.3.1\"\n+    echo \"https:\/\/docs.oracle.com\/javase\/specs\/jls\/se21\/html\/jls-8.html#jls-8.4.3\"\n+    echo \"https:\/\/docs.oracle.com\/javase\/specs\/jls\/se21\/html\/jls-8.html#jls-8.8.3\"\n+    echo \"https:\/\/docs.oracle.com\/javase\/specs\/jls\/se21\/html\/jls-9.html#jls-9.1.1\"\n+    echo \"https:\/\/docs.oracle.com\/javase\/specs\/jls\/se21\/html\/jls-9.html#jls-9.4\"\n@@ -49,1 +55,1 @@\n-  abstract static final transient\n+  abstract default static final sealed non-sealed transient\n","filename":"bin\/blessed-modifier-order.sh","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1292,1 +1292,1 @@\n-            .filter(p -> p.toFile().isFile())\n+            .filter(p -> p.toFile().isFile() && !p.endsWith(\"jdk11_backward\"))\n@@ -1298,0 +1298,2 @@\n+                    boolean inVanguard = false;\n+                    boolean inRearguard = false;\n@@ -1299,1 +1301,28 @@\n-                        if (line.contains(\"#STDOFF\")) continue;\n+                        \/\/ Interpret the line in rearguard mode so that STD\/DST\n+                        \/\/ correctly handles negative DST cases, such as \"GMT\/IST\"\n+                        \/\/ vs. \"IST\/GMT\" case for Europe\/Dublin\n+                        if (inVanguard) {\n+                            if (line.startsWith(\"# Rearguard\")) {\n+                                inVanguard = false;\n+                                inRearguard = true;\n+                            }\n+                            continue;\n+                        } else if (line.startsWith(\"# Vanguard\")) {\n+                            inVanguard = true;\n+                            continue;\n+                        }\n+                        if (inRearguard) {\n+                            if (line.startsWith(\"# End of rearguard\")) {\n+                                inRearguard = false;\n+                                continue;\n+                            } else {\n+                                if (line.startsWith(\"#\\t\")) {\n+                                    line = line.substring(1); \/\/ omit #\n+                                }\n+                            }\n+                        }\n+                        if (line.isBlank() || line.matches(\"^[ \\t]*#.*\")) {\n+                            \/\/ ignore blank\/comment lines\n+                            continue;\n+                        }\n+                        \/\/ remove comments in-line\n@@ -1304,0 +1333,3 @@\n+                            if (zone != null) {\n+                                tzdbShortNamesMap.put(zone, format + NBSP + rule);\n+                            }\n@@ -1310,1 +1342,2 @@\n-                                if (line.isBlank()) {\n+                                if (line.startsWith(\"Rule\") ||\n+                                    line.startsWith(\"Link\")) {\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,4 @@\n+ifeq ($(call isTargetOs, windows), false)\n+  BUILD_LIBTEST_LIBRARIES_EXCLUDE += libFileUtils.c\n+endif\n+\n","filename":"make\/test\/BuildTestLibNative.gmk","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -860,0 +860,5 @@\n+ifeq ($(call And, $(call isTargetOs, linux) $(call isTargetCpu, aarch64)), false)\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += libTestSVEWithJNI.c\n+endif\n+\n+\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1719,1 +1719,1 @@\n-                java.util.Arrays.sort(members);\n+                Arrays.sort(members);\n","filename":"src\/demo\/share\/jfc\/J2Ddemo\/java2d\/Intro.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -8240,0 +8240,18 @@\n+\/\/ ============================================================================\n+\/\/ VerifyVectorAlignment Instruction\n+\n+instruct verify_vector_alignment(iRegP addr, immL_positive_bitmaskI mask, rFlagsReg cr) %{\n+  match(Set addr (VerifyVectorAlignment addr mask));\n+  effect(KILL cr);\n+  format %{ \"verify_vector_alignment $addr $mask \\t! verify alignment\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ check if masked bits of addr are zero\n+    __ tst($addr$$Register, $mask$$constant);\n+    __ br(Assembler::EQ, Lskip);\n+    __ stop(\"verify_vector_alignment found a misaligned vector memory access\");\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -285,1 +285,2 @@\n-      __ ldp(r19, r20, Address(OSR_buf, slot_offset));\n+      __ ldr(r19, Address(OSR_buf, slot_offset));\n+      __ ldr(r20, Address(OSR_buf, slot_offset + BytesPerWord));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -159,2 +159,0 @@\n-  const ImmutableOopMap* get_oop_map() const;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-  assert(!ret || ret && cb() == other.cb() && _deopt_state == other._deopt_state, \"inconsistent construction\");\n+  assert(!ret || (cb() == other.cb() && _deopt_state == other._deopt_state), \"inconsistent construction\");\n@@ -362,14 +362,0 @@\n-inline const ImmutableOopMap* frame::get_oop_map() const {\n-  if (_cb == nullptr) return nullptr;\n-  if (_cb->oop_maps() != nullptr) {\n-    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n-    if (nop != nullptr && nop->displacement() != 0) {\n-      int slot = ((nop->displacement() >> 24) & 0xff);\n-      return _cb->oop_map_for_slot(slot, _pc);\n-    }\n-    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n-    return oop_map;\n-  }\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+\/\/ The expected size in bytes of a cache line.\n@@ -47,0 +48,3 @@\n+\/\/ The default padding size for data structures to avoid false sharing.\n+#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -563,1 +563,5 @@\n-void NativePostCallNop::patch(jint diff) {\n+bool NativePostCallNop::patch(int32_t oopmap_slot, int32_t cb_offset) {\n+  if (((oopmap_slot & 0xff) != oopmap_slot) || ((cb_offset & 0xffffff) != cb_offset)) {\n+    return false; \/\/ cannot encode\n+  }\n+  uint32_t data = ((uint32_t)oopmap_slot << 24) | cb_offset;\n@@ -565,1 +569,1 @@\n-  assert(diff != 0, \"must be\");\n+  assert(data != 0, \"must be\");\n@@ -571,2 +575,2 @@\n-  uint32_t lo = diff & 0xffff;\n-  uint32_t hi = (uint32_t)diff >> 16;\n+  uint32_t lo = data & 0xffff;\n+  uint32_t hi = data >> 16;\n@@ -575,0 +579,1 @@\n+  return true; \/\/ successfully encoded\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -694,1 +694,1 @@\n-  jint displacement() const {\n+  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const {\n@@ -698,3 +698,7 @@\n-    uint32_t result = (hi << 16) | lo;\n-\n-    return (jint)result;\n+    uint32_t data = (hi << 16) | lo;\n+    if (data == 0) {\n+      return false; \/\/ no information encoded\n+    }\n+    cb_offset = (data & 0xffffff);\n+    oopmap_slot = (data >> 24) & 0xff;\n+    return true; \/\/ decoding succeeded\n@@ -703,1 +707,1 @@\n-  void patch(jint diff);\n+  bool patch(int32_t oopmap_slot, int32_t cb_offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -9196,1 +9196,1 @@\n-    Label(loop);\n+    Label loop;\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,1 @@\n-             (abs(_disp) & 0xf0) << 4 | abs(_disp) & 0x0f;\n+             (abs(_disp) & 0xf0) << 4 | (abs(_disp) & 0x0f);\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2643,2 +2643,2 @@\n-  assert(src->is_double_cpu() && dest->is_address() ||\n-         src->is_address() && dest->is_double_cpu(),\n+  assert((src->is_double_cpu() && dest->is_address()) ||\n+         (src->is_address() && dest->is_double_cpu()),\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,2 +102,0 @@\n-  const ImmutableOopMap* get_oop_map() const;\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-  assert(!ret || ret && cb() == other.cb() && _deopt_state == other._deopt_state, \"inconsistent construction\");\n+  assert(!ret || (cb() == other.cb() && _deopt_state == other._deopt_state), \"inconsistent construction\");\n@@ -221,14 +221,0 @@\n-inline const ImmutableOopMap* frame::get_oop_map() const {\n-  if (_cb == nullptr) return nullptr;\n-  if (_cb->oop_maps() != nullptr) {\n-    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n-    if (nop != nullptr && nop->displacement() != 0) {\n-      int slot = ((nop->displacement() >> 24) & 0xff);\n-      return _cb->oop_map_for_slot(slot, _pc);\n-    }\n-    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n-    return oop_map;\n-  }\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+\/\/ The expected size in bytes of a cache line.\n@@ -54,0 +55,3 @@\n+\/\/ The default padding size for data structures to avoid false sharing.\n+#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n+\n","filename":"src\/hotspot\/cpu\/arm\/globalDefinitions_arm.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,1 +165,1 @@\n-  } else if (oop_addr == nullptr & metadata_addr == nullptr) {\n+  } else if (oop_addr == nullptr && metadata_addr == nullptr) {\n@@ -344,4 +344,0 @@\n-void NativePostCallNop::patch(jint diff) {\n-  \/\/ unsupported for now\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -399,1 +399,1 @@\n-         ni->is_movw() && VM_Version::supports_movw(), \"must be\");\n+         (ni->is_movw() && VM_Version::supports_movw()), \"must be\");\n@@ -441,2 +441,2 @@\n-  int displacement() const { return 0; }\n-  void patch(jint diff);\n+  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const { return false; }\n+  bool patch(int32_t oopmap_slot, int32_t cb_offset) { return false; }\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -403,2 +403,0 @@\n-  const ImmutableOopMap* get_oop_map() const;\n-\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-         (is_aligned(_sp, alignment_in_bytes) || is_interpreted_frame()) &&\n-         (is_aligned(_fp, alignment_in_bytes) || !is_fully_initialized()),\n+         ((is_aligned(_sp, alignment_in_bytes) || is_interpreted_frame()) &&\n+          (is_aligned(_fp, alignment_in_bytes) || !is_fully_initialized())),\n@@ -364,14 +364,0 @@\n-inline const ImmutableOopMap* frame::get_oop_map() const {\n-  if (_cb == nullptr) return nullptr;\n-  if (_cb->oop_maps() != nullptr) {\n-    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n-    if (nop != nullptr && nop->displacement() != 0) {\n-      int slot = ((nop->displacement() >> 24) & 0xff);\n-      return _cb->oop_map_for_slot(slot, _pc);\n-    }\n-    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n-    return oop_map;\n-  }\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-\/\/ The expected size in bytes of a cache line, used to pad data structures.\n+\/\/ The expected size in bytes of a cache line.\n@@ -54,0 +54,3 @@\n+\/\/ The default padding size for data structures to avoid false sharing.\n+#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n+\n","filename":"src\/hotspot\/cpu\/ppc\/globalDefinitions_ppc.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -432,4 +432,0 @@\n-void NativePostCallNop::patch(jint diff) {\n-  \/\/ unsupported for now\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -511,2 +511,2 @@\n-  int displacement() const { return 0; }\n-  void patch(jint diff);\n+  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const { return false; }\n+  bool patch(int32_t oopmap_slot, int32_t cb_offset) { return false; }\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -509,1 +509,1 @@\n-  INSN(mul,   0b0110011, 0b000, 0b0000001);\n+  INSN(_mul,  0b0110011, 0b000, 0b0000001);\n@@ -540,3 +540,3 @@\n-  INSN(lbu, 0b0000011, 0b100);\n-  INSN(lh,  0b0000011, 0b001);\n-  INSN(lhu, 0b0000011, 0b101);\n+  INSN(_lbu, 0b0000011, 0b100);\n+  INSN(_lh,  0b0000011, 0b001);\n+  INSN(_lhu, 0b0000011, 0b101);\n@@ -612,2 +612,2 @@\n-  INSN(sb,   Register,      0b0100011, 0b000);\n-  INSN(sh,   Register,      0b0100011, 0b001);\n+  INSN(_sb,   Register,      0b0100011, 0b000);\n+  INSN(_sh,   Register,      0b0100011, 0b001);\n@@ -1159,4 +1159,2 @@\n-    if (vill == 1) {                                         \\\n-      guarantee((vlmul | vsew | vta | vma == 0),             \\\n-                \"the other bits in vtype shall be zero\");    \\\n-    }                                                        \\\n+    \/* If vill then other bits of vtype must be zero. *\/     \\\n+    guarantee(!vill, \"vill not supported\");                  \\\n@@ -1337,0 +1335,1 @@\n+  INSN(vslideup_vi,   0b1010111, 0b011, 0b001110);\n@@ -1692,1 +1691,0 @@\n-#undef patch_VArith\n@@ -1734,2 +1732,2 @@\n-#define INSN(NAME, op, lumop, vm, mop, nf)                                           \\\n-  void NAME(VectorRegister Vd, Register Rs1, uint32_t width = 0, bool mew = false) { \\\n+#define INSN(NAME, op, width, lumop, vm, mop, mew, nf)                               \\\n+  void NAME(VectorRegister Vd, Register Rs1) {                                       \\\n@@ -1741,1 +1739,16 @@\n-  INSN(vl1re8_v, 0b0000111, 0b01000, 0b1, 0b00, g1);\n+  INSN(vl1re8_v,  0b0000111, 0b000, 0b01000, 0b1, 0b00, 0b0, g1);\n+  INSN(vl1re16_v, 0b0000111, 0b101, 0b01000, 0b1, 0b00, 0b0, g1);\n+  INSN(vl1re32_v, 0b0000111, 0b110, 0b01000, 0b1, 0b00, 0b0, g1);\n+  INSN(vl1re64_v, 0b0000111, 0b111, 0b01000, 0b1, 0b00, 0b0, g1);\n+  INSN(vl2re8_v,  0b0000111, 0b000, 0b01000, 0b1, 0b00, 0b0, g2);\n+  INSN(vl2re16_v, 0b0000111, 0b101, 0b01000, 0b1, 0b00, 0b0, g2);\n+  INSN(vl2re32_v, 0b0000111, 0b110, 0b01000, 0b1, 0b00, 0b0, g2);\n+  INSN(vl2re64_v, 0b0000111, 0b111, 0b01000, 0b1, 0b00, 0b0, g2);\n+  INSN(vl4re8_v,  0b0000111, 0b000, 0b01000, 0b1, 0b00, 0b0, g4);\n+  INSN(vl4re16_v, 0b0000111, 0b101, 0b01000, 0b1, 0b00, 0b0, g4);\n+  INSN(vl4re32_v, 0b0000111, 0b110, 0b01000, 0b1, 0b00, 0b0, g4);\n+  INSN(vl4re64_v, 0b0000111, 0b111, 0b01000, 0b1, 0b00, 0b0, g4);\n+  INSN(vl8re8_v,  0b0000111, 0b000, 0b01000, 0b1, 0b00, 0b0, g8);\n+  INSN(vl8re16_v, 0b0000111, 0b101, 0b01000, 0b1, 0b00, 0b0, g8);\n+  INSN(vl8re32_v, 0b0000111, 0b110, 0b01000, 0b1, 0b00, 0b0, g8);\n+  INSN(vl8re64_v, 0b0000111, 0b111, 0b01000, 0b1, 0b00, 0b0, g8);\n@@ -1752,0 +1765,3 @@\n+  INSN(vs2r_v, 0b0100111, 0b000, 0b01000, 0b1, 0b00, 0b0, g2);\n+  INSN(vs4r_v, 0b0100111, 0b000, 0b01000, 0b1, 0b00, 0b0, g4);\n+  INSN(vs8r_v, 0b0100111, 0b000, 0b01000, 0b1, 0b00, 0b0, g8);\n@@ -1797,0 +1813,1 @@\n+  INSN( vluxei8_v, 0b0000111, 0b000, 0b01, 0b0);\n@@ -1800,0 +1817,1 @@\n+  INSN( vsuxei8_v, 0b0100111, 0b000, 0b01, 0b0);\n@@ -1823,0 +1841,49 @@\n+\/\/ ====================================\n+\/\/ RISC-V Vector Crypto Extension\n+\/\/ ====================================\n+\n+#define INSN(NAME, op, funct3, funct6)                                                             \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, VectorRegister Vs1, VectorMask vm = unmasked) { \\\n+    patch_VArith(op, Vd, funct3, Vs1->raw_encoding(), Vs2, vm, funct6);                            \\\n+  }\n+\n+  \/\/ Vector Bit-manipulation used in Cryptography (Zvkb) Extension\n+  INSN(vandn_vv,   0b1010111, 0b000, 0b000001);\n+  INSN(vandn_vx,   0b1010111, 0b100, 0b000001);\n+  INSN(vandn_vi,   0b1010111, 0b011, 0b000001);\n+  INSN(vclmul_vv,  0b1010111, 0b010, 0b001100);\n+  INSN(vclmul_vx,  0b1010111, 0b110, 0b001100);\n+  INSN(vclmulh_vv, 0b1010111, 0b010, 0b001101);\n+  INSN(vclmulh_vx, 0b1010111, 0b110, 0b001101);\n+  INSN(vror_vv,    0b1010111, 0b000, 0b010100);\n+  INSN(vror_vx,    0b1010111, 0b100, 0b010100);\n+  INSN(vrol_vv,    0b1010111, 0b000, 0b010101);\n+  INSN(vrol_vx,    0b1010111, 0b100, 0b010101);\n+\n+#undef INSN\n+\n+#define INSN(NAME, op, funct3, Vs1, funct6)                                    \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, VectorMask vm = unmasked) { \\\n+    patch_VArith(op, Vd, funct3, Vs1, Vs2, vm, funct6);                        \\\n+  }\n+\n+  \/\/ Vector Bit-manipulation used in Cryptography (Zvkb) Extension\n+  INSN(vbrev8_v, 0b1010111, 0b010, 0b01000, 0b010010);\n+  INSN(vrev8_v,  0b1010111, 0b010, 0b01001, 0b010010);\n+\n+#undef INSN\n+\n+#define INSN(NAME, op, funct3, vm, funct6)                                   \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, VectorRegister Vs1) {     \\\n+    patch_VArith(op, Vd, funct3, Vs1->raw_encoding(), Vs2, vm, funct6);      \\\n+  }\n+\n+  \/\/ Vector SHA-2 Secure Hash (Zvknh[ab]) Extension\n+  INSN(vsha2ms_vv,  0b1110111, 0b010, 0b1, 0b101101);\n+  INSN(vsha2ch_vv,  0b1110111, 0b010, 0b1, 0b101110);\n+  INSN(vsha2cl_vv,  0b1110111, 0b010, 0b1, 0b101111);\n+\n+#undef INSN\n+\n+#undef patch_VArith\n+\n@@ -1872,3 +1939,3 @@\n-  INSN(sext_b, 0b0010011, 0b001, 0b011000000100);\n-  INSN(sext_h, 0b0010011, 0b001, 0b011000000101);\n-  INSN(zext_h, 0b0111011, 0b100, 0b000010000000);\n+  INSN(_sext_b, 0b0010011, 0b001, 0b011000000100);\n+  INSN(_sext_h, 0b0010011, 0b001, 0b011000000101);\n+  INSN(_zext_h, 0b0111011, 0b100, 0b000010000000);\n@@ -2586,0 +2653,9 @@\n+  bool do_compress_zcb(Register reg1 = noreg, Register reg2 = noreg) const {\n+    return do_compress() && VM_Version::ext_Zcb.enabled() &&\n+           (reg1 == noreg || reg1->is_compressed_valid()) && (reg2 == noreg || reg2->is_compressed_valid());\n+  }\n+\n+  bool do_compress_zcb_zbb(Register reg1 = noreg, Register reg2 = noreg) const {\n+    return do_compress_zcb(reg1, reg2) && UseZbb;\n+  }\n+\n@@ -2920,0 +2996,232 @@\n+\/\/ --------------  ZCB Instruction Definitions  --------------\n+\/\/ Zcb additional C instructions\n+ private:\n+  \/\/ Format CLH, c.lh\/c.lhu\n+  template <bool Unsigned>\n+  void c_lh_if(Register Rd_Rs2, Register Rs1, uint32_t uimm) {\n+    assert_cond(uimm == 0 || uimm == 2);\n+    assert_cond(do_compress_zcb(Rd_Rs2, Rs1));\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b00);\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(1)) >> 1);\n+    c_patch((address)&insn, 6, 6, Unsigned ? 0 : 1);\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 12, 10, 0b001);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+  template <bool Unsigned>\n+  void lh_c_mux(Register Rd_Rs2, Register Rs1, const int32_t uimm) {\n+    if (do_compress_zcb(Rd_Rs2, Rs1) &&\n+        (uimm == 0 || uimm == 2)) {\n+      c_lh_if<Unsigned>(Rd_Rs2, Rs1, uimm);\n+    } else {\n+      if (Unsigned) {\n+        _lhu(Rd_Rs2, Rs1, uimm);\n+      } else {\n+        _lh(Rd_Rs2, Rs1, uimm);\n+      }\n+    }\n+  }\n+\n+  \/\/ Format CU, c.[sz]ext.*, c.not\n+  template <uint8_t InstructionType>\n+  void c_u_if(Register Rs1) {\n+    assert_cond(do_compress_zcb(Rs1));\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b01);\n+    c_patch((address)&insn, 4, 2, InstructionType);\n+    c_patch((address)&insn, 6, 5, 0b11);\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 12, 10, 0b111);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+ public:\n+\n+  \/\/ Prerequisites: Zcb\n+  void c_lh(Register Rd_Rs2, Register Rs1, const int32_t uimm)  {  c_lh_if<false>(Rd_Rs2, Rs1, uimm); }\n+  void lh(Register Rd_Rs2, Register Rs1, const int32_t uimm)    { lh_c_mux<false>(Rd_Rs2, Rs1, uimm); }\n+\n+  \/\/ Prerequisites: Zcb\n+  void c_lhu(Register Rd_Rs2, Register Rs1, const int32_t uimm) {  c_lh_if<true>(Rd_Rs2, Rs1, uimm); }\n+  void lhu(Register Rd_Rs2, Register Rs1, const int32_t uimm)   { lh_c_mux<true>(Rd_Rs2, Rs1, uimm); }\n+\n+  \/\/ Prerequisites: Zcb\n+  \/\/ Format CLB, single instruction\n+  void c_lbu(Register Rd_Rs2, Register Rs1, uint32_t uimm) {\n+    assert_cond(uimm <= 3);\n+    assert_cond(do_compress_zcb(Rd_Rs2, Rs1));\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b00);\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(1)) >> 1);\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(0)) >> 0);\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 12, 10, 0b000);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+  void lbu(Register Rd_Rs2, Register Rs1, const int32_t uimm) {\n+    if (do_compress_zcb(Rd_Rs2, Rs1) &&\n+        uimm >= 0 && uimm <= 3) {\n+      c_lbu(Rd_Rs2, Rs1, uimm);\n+    } else {\n+      _lbu(Rd_Rs2, Rs1, uimm);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb\n+  \/\/ Format CSB, single instruction\n+  void c_sb(Register Rd_Rs2, Register Rs1, uint32_t uimm) {\n+    assert_cond(uimm <= 3);\n+    assert_cond(do_compress_zcb(Rd_Rs2, Rs1));\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b00);\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(1)) >> 1);\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(0)) >> 0);\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 12, 10, 0b010);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+  void sb(Register Rd_Rs2, Register Rs1, const int32_t uimm) {\n+    if (do_compress_zcb(Rd_Rs2, Rs1) &&\n+        uimm >= 0 && uimm <= 3) {\n+      c_sb(Rd_Rs2, Rs1, uimm);\n+    } else {\n+      _sb(Rd_Rs2, Rs1, uimm);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb\n+  \/\/ Format CSH, single instruction\n+  void c_sh(Register Rd_Rs2, Register Rs1, uint32_t uimm) {\n+    assert_cond(uimm == 0 || uimm == 2);\n+    assert_cond(do_compress_zcb(Rd_Rs2, Rs1));\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b00);\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(1)) >> 1);\n+    c_patch((address)&insn, 6, 6, 0);\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 12, 10, 0b011);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+  void sh(Register Rd_Rs2, Register Rs1, const int32_t uimm) {\n+    if (do_compress_zcb(Rd_Rs2, Rs1) &&\n+        (uimm == 0 || uimm == 2)) {\n+      c_sh(Rd_Rs2, Rs1, uimm);\n+    } else {\n+      _sh(Rd_Rs2, Rs1, uimm);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb\n+  \/\/ Format CS\n+  void c_zext_b(Register Rs1) {\n+    assert_cond(do_compress_zcb(Rs1));\n+    c_u_if<0b000>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zbb\n+  void sext_b(Register Rd_Rs2, Register Rs1) {\n+    assert_cond(UseZbb);\n+    if (do_compress_zcb_zbb(Rd_Rs2, Rs1) && (Rd_Rs2 == Rs1)) {\n+      c_sext_b(Rd_Rs2);\n+    } else {\n+      _sext_b(Rd_Rs2, Rs1);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb, Zbb\n+  \/\/ Format CS\n+  void c_sext_b(Register Rs1) {\n+    c_u_if<0b001>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zbb\n+  void zext_h(Register Rd_Rs2, Register Rs1) {\n+    assert_cond(UseZbb);\n+    if (do_compress_zcb_zbb(Rd_Rs2, Rs1) && (Rd_Rs2 == Rs1)) {\n+      c_zext_h(Rd_Rs2);\n+    } else {\n+      _zext_h(Rd_Rs2, Rs1);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb, Zbb\n+  \/\/ Format CS\n+  void c_zext_h(Register Rs1) {\n+    c_u_if<0b010>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zbb\n+  void sext_h(Register Rd_Rs2, Register Rs1) {\n+    assert_cond(UseZbb);\n+    if (do_compress_zcb_zbb(Rd_Rs2, Rs1) && (Rd_Rs2 == Rs1)) {\n+      c_sext_h(Rd_Rs2);\n+    } else {\n+      _sext_h(Rd_Rs2, Rs1);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb, Zbb\n+  \/\/ Format CS\n+  void c_sext_h(Register Rs1) {\n+    c_u_if<0b011>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zcb, Zba\n+  \/\/ Format CS\n+  void c_zext_w(Register Rs1) {\n+    c_u_if<0b100>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zcb\n+  \/\/ Format CS\n+  void c_not(Register Rs1) {\n+    c_u_if<0b101>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zcb (M or Zmmul)\n+  \/\/ Format CA, c.mul\n+  void c_mul(Register Rd_Rs1, Register Rs2) {\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b01);\n+    c_patch_compressed_reg((address)&insn, 2, Rs2);\n+    c_patch((address)&insn, 6, 5, 0b10);\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);\n+    c_patch((address)&insn, 12, 10, 0b111);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+  void mul(Register Rd, Register Rs1, Register Rs2) {\n+    if (Rd != Rs1 && Rd != Rs2) {\n+      \/\/ Three registers needed without a mv, emit uncompressed\n+      _mul(Rd, Rs1, Rs2);\n+      return;\n+    }\n+\n+    \/\/ Rd is either Rs1 or Rs2\n+    if (!do_compress_zcb(Rs2, Rs1)) {\n+      _mul(Rd, Rs1, Rs2);\n+    } else {\n+      if (Rd == Rs2) {\n+        Rs2 = Rs1;\n+      } else {\n+        assert(Rd == Rs1, \"must be\");\n+      }\n+      c_mul(Rd, Rs2);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":326,"deletions":18,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -192,2 +192,0 @@\n-  const ImmutableOopMap* get_oop_map() const;\n-\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,1 +189,1 @@\n-  assert(!ret || ret && cb() == other.cb() && _deopt_state == other._deopt_state, \"inconsistent construction\");\n+  assert(!ret || (cb() == other.cb() && _deopt_state == other._deopt_state), \"inconsistent construction\");\n@@ -348,14 +348,0 @@\n-inline const ImmutableOopMap* frame::get_oop_map() const {\n-  if (_cb == nullptr) return nullptr;\n-  if (_cb->oop_maps() != nullptr) {\n-    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n-    if (nop != nullptr && nop->displacement() != 0) {\n-      int slot = ((nop->displacement() >> 24) & 0xff);\n-      return _cb->oop_map_for_slot(slot, _pc);\n-    }\n-    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n-    return oop_map;\n-  }\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+\/\/ The expected size in bytes of a cache line.\n@@ -55,0 +56,3 @@\n+\/\/ The default padding size for data structures to avoid false sharing.\n+#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n+\n","filename":"src\/hotspot\/cpu\/riscv\/globalDefinitions_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,0 +116,2 @@\n+  product(bool, UseZvkn, false, EXPERIMENTAL,                                    \\\n+          \"Use Zvkn group extension, Zvkned, Zvknhb, Zvkb, Zvkt\")                \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4681,15 +4681,21 @@\n-  if (UseZba && bits == 32) {\n-    zext_w(dst, src);\n-    return;\n-  }\n-\n-  if (UseZbb && bits == 16) {\n-    zext_h(dst, src);\n-    return;\n-  }\n-\n-  if (bits == 8) {\n-    zext_b(dst, src);\n-  } else {\n-    slli(dst, src, XLEN - bits);\n-    srli(dst, dst, XLEN - bits);\n+  switch (bits) {\n+    case 32:\n+      if (UseZba) {\n+        zext_w(dst, src);\n+        return;\n+      }\n+      break;\n+    case 16:\n+      if (UseZbb) {\n+        zext_h(dst, src);\n+        return;\n+      }\n+      break;\n+    case 8:\n+      if (UseZbb) {\n+        zext_b(dst, src);\n+        return;\n+      }\n+      break;\n+    default:\n+      break;\n@@ -4697,0 +4703,2 @@\n+  slli(dst, src, XLEN - bits);\n+  srli(dst, dst, XLEN - bits);\n@@ -4700,3 +4708,3 @@\n-  if (UseZbb) {\n-    if (bits == 8) {\n-      sext_b(dst, src);\n+  switch (bits) {\n+    case 32:\n+      sext_w(dst, src);\n@@ -4704,11 +4712,14 @@\n-    } else if (bits == 16) {\n-      sext_h(dst, src);\n-      return;\n-    }\n-  }\n-\n-  if (bits == 32) {\n-    sext_w(dst, src);\n-  } else {\n-    slli(dst, src, XLEN - bits);\n-    srai(dst, dst, XLEN - bits);\n+    case 16:\n+      if (UseZbb) {\n+        sext_h(dst, src);\n+        return;\n+      }\n+      break;\n+    case 8:\n+      if (UseZbb) {\n+        sext_b(dst, src);\n+        return;\n+      }\n+      break;\n+    default:\n+      break;\n@@ -4716,0 +4727,2 @@\n+  slli(dst, src, XLEN - bits);\n+  srai(dst, dst, XLEN - bits);\n@@ -4894,3 +4907,3 @@\n-  assert(src.first()->is_stack() && dst.first()->is_stack() ||\n-         src.first()->is_reg() && dst.first()->is_reg() ||\n-         src.first()->is_stack() && dst.first()->is_reg(), \"Unexpected error\");\n+  assert((src.first()->is_stack() && dst.first()->is_stack()) ||\n+         (src.first()->is_reg() && dst.first()->is_reg()) ||\n+         (src.first()->is_stack() && dst.first()->is_reg()), \"Unexpected error\");\n@@ -4938,3 +4951,3 @@\n-  assert(src.first()->is_stack() && dst.first()->is_stack() ||\n-         src.first()->is_reg() && dst.first()->is_reg() ||\n-         src.first()->is_stack() && dst.first()->is_reg(), \"Unexpected error\");\n+  assert((src.first()->is_stack() && dst.first()->is_stack()) ||\n+         (src.first()->is_reg() && dst.first()->is_reg()) ||\n+         (src.first()->is_stack() && dst.first()->is_reg()), \"Unexpected error\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":49,"deletions":36,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -476,1 +476,5 @@\n-    xori(Rd, Rs, -1);\n+    if (do_compress_zcb(Rd, Rs) && (Rd == Rs)) {\n+      c_not(Rd);\n+    } else {\n+      xori(Rd, Rs, -1);\n+    }\n@@ -492,1 +496,5 @@\n-    andi(Rd, Rs, 0xFF);\n+    if (do_compress_zcb(Rd, Rs) && (Rd == Rs)) {\n+      c_zext_b(Rd);\n+    } else {\n+      andi(Rd, Rs, 0xFF);\n+    }\n@@ -514,1 +522,6 @@\n-    add_uw(Rd, Rs, zr);\n+    assert(UseZba, \"must be\");\n+    if (do_compress_zcb(Rd, Rs) && (Rd == Rs)) {\n+      c_zext_w(Rd);\n+    } else {\n+      add_uw(Rd, Rs, zr);\n+    }\n@@ -1364,0 +1377,10 @@\n+  inline void vmsltu_vi(VectorRegister Vd, VectorRegister Vs2, uint32_t imm, VectorMask vm = unmasked) {\n+    guarantee(imm >= 1 && imm <= 16, \"imm is invalid\");\n+    vmsleu_vi(Vd, Vs2, imm-1, vm);\n+  }\n+\n+  inline void vmsgeu_vi(VectorRegister Vd, VectorRegister Vs2, uint32_t imm, VectorMask vm = unmasked) {\n+    guarantee(imm >= 1 && imm <= 16, \"imm is invalid\");\n+    vmsgtu_vi(Vd, Vs2, imm-1, vm);\n+  }\n+\n@@ -1379,0 +1402,4 @@\n+  inline void vnot_v(VectorRegister Vd, VectorRegister Vs, VectorMask vm = unmasked) {\n+    vxor_vi(Vd, Vs, -1, vm);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -454,1 +454,1 @@\n-int NativePostCallNop::displacement() const {\n+bool NativePostCallNop::decode(int32_t& oopmap_slot, int32_t& cb_offset) const {\n@@ -456,1 +456,7 @@\n-  return (int)(intptr_t)MacroAssembler::get_target_of_li32(addr_at(4));\n+  int32_t data = (int32_t)(intptr_t)MacroAssembler::get_target_of_li32(addr_at(4));\n+  if (data == 0) {\n+    return false; \/\/ no information encoded\n+  }\n+  cb_offset = (data & 0xffffff);\n+  oopmap_slot = (data >> 24) & 0xff;\n+  return true; \/\/ decoding succeeded\n@@ -459,2 +465,6 @@\n-void NativePostCallNop::patch(jint diff) {\n-  assert(diff != 0, \"must be\");\n+bool NativePostCallNop::patch(int32_t oopmap_slot, int32_t cb_offset) {\n+  if (((oopmap_slot & 0xff) != oopmap_slot) || ((cb_offset & 0xffffff) != cb_offset)) {\n+    return false; \/\/ cannot encode\n+  }\n+  int32_t data = (oopmap_slot << 24) | cb_offset;\n+  assert(data != 0, \"must be\");\n@@ -463,1 +473,2 @@\n-  MacroAssembler::patch_imm_in_li32(addr_at(4), diff);\n+  MacroAssembler::patch_imm_in_li32(addr_at(4), data);\n+  return true; \/\/ successfully encoded\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -594,2 +594,2 @@\n-  int displacement() const;\n-  void patch(jint diff);\n+  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const;\n+  bool patch(int32_t oopmap_slot, int32_t cb_offset);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1004,0 +1004,1 @@\n+  int_def FMVX_COST            (  100,  1 * DEFAULT_COST);          \/\/ shuffles with no conversion\n@@ -8677,1 +8678,1 @@\n-  ins_cost(XFER_COST);\n+  ins_cost(FMVX_COST);\n@@ -8695,1 +8696,1 @@\n-  ins_cost(XFER_COST);\n+  ins_cost(FMVX_COST);\n@@ -8713,1 +8714,1 @@\n-  ins_cost(XFER_COST);\n+  ins_cost(FMVX_COST);\n@@ -8731,1 +8732,1 @@\n-  ins_cost(XFER_COST);\n+  ins_cost(FMVX_COST);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3662,0 +3662,1 @@\n+\n@@ -3664,0 +3665,385 @@\n+#undef __\n+#define __ this->\n+  class Sha2Generator : public MacroAssembler {\n+    StubCodeGenerator* _cgen;\n+   public:\n+      Sha2Generator(MacroAssembler* masm, StubCodeGenerator* cgen) : MacroAssembler(masm->code()), _cgen(cgen) {}\n+      address generate_sha256_implCompress(bool multi_block) {\n+        return generate_sha2_implCompress(Assembler::e32, multi_block);\n+      }\n+      address generate_sha512_implCompress(bool multi_block) {\n+        return generate_sha2_implCompress(Assembler::e64, multi_block);\n+      }\n+   private:\n+\n+    void vleXX_v(Assembler::SEW vset_sew, VectorRegister vr, Register sr) {\n+      if (vset_sew == Assembler::e32) __ vle32_v(vr, sr);\n+      else                            __ vle64_v(vr, sr);\n+    }\n+\n+    void vseXX_v(Assembler::SEW vset_sew, VectorRegister vr, Register sr) {\n+      if (vset_sew == Assembler::e32) __ vse32_v(vr, sr);\n+      else                            __ vse64_v(vr, sr);\n+    }\n+\n+    \/\/ Overview of the logic in each \"quad round\".\n+    \/\/\n+    \/\/ The code below repeats 16\/20 times the logic implementing four rounds\n+    \/\/ of the SHA-256\/512 core loop as documented by NIST. 16\/20 \"quad rounds\"\n+    \/\/ to implementing the 64\/80 single rounds.\n+    \/\/\n+    \/\/    \/\/ Load four word (u32\/64) constants (K[t+3], K[t+2], K[t+1], K[t+0])\n+    \/\/    \/\/ Output:\n+    \/\/    \/\/   vTmp1 = {K[t+3], K[t+2], K[t+1], K[t+0]}\n+    \/\/    vl1reXX.v vTmp1, ofs\n+    \/\/\n+    \/\/    \/\/ Increment word constant address by stride (16\/32 bytes, 4*4B\/8B, 128b\/256b)\n+    \/\/    addi ofs, ofs, 16\/32\n+    \/\/\n+    \/\/    \/\/ Add constants to message schedule words:\n+    \/\/    \/\/  Input\n+    \/\/    \/\/    vTmp1 = {K[t+3], K[t+2], K[t+1], K[t+0]}\n+    \/\/    \/\/    vW0 = {W[t+3], W[t+2], W[t+1], W[t+0]}; \/\/ Vt0 = W[3:0];\n+    \/\/    \/\/  Output\n+    \/\/    \/\/    vTmp0 = {W[t+3]+K[t+3], W[t+2]+K[t+2], W[t+1]+K[t+1], W[t+0]+K[t+0]}\n+    \/\/    vadd.vv vTmp0, vTmp1, vW0\n+    \/\/\n+    \/\/    \/\/  2 rounds of working variables updates.\n+    \/\/    \/\/     vState1[t+4] <- vState1[t], vState0[t], vTmp0[t]\n+    \/\/    \/\/  Input:\n+    \/\/    \/\/    vState1 = {c[t],d[t],g[t],h[t]}   \" = vState1[t] \"\n+    \/\/    \/\/    vState0 = {a[t],b[t],e[t],f[t]}\n+    \/\/    \/\/    vTmp0 = {W[t+3]+K[t+3], W[t+2]+K[t+2], W[t+1]+K[t+1], W[t+0]+K[t+0]}\n+    \/\/    \/\/  Output:\n+    \/\/    \/\/    vState1 = {f[t+2],e[t+2],b[t+2],a[t+2]}  \" = vState0[t+2] \"\n+    \/\/    \/\/        = {h[t+4],g[t+4],d[t+4],c[t+4]}  \" = vState1[t+4] \"\n+    \/\/    vsha2cl.vv vState1, vState0, vTmp0\n+    \/\/\n+    \/\/    \/\/  2 rounds of working variables updates.\n+    \/\/    \/\/     vState0[t+4] <- vState0[t], vState0[t+2], vTmp0[t]\n+    \/\/    \/\/  Input\n+    \/\/    \/\/   vState0 = {a[t],b[t],e[t],f[t]}       \" = vState0[t] \"\n+    \/\/    \/\/       = {h[t+2],g[t+2],d[t+2],c[t+2]}   \" = vState1[t+2] \"\n+    \/\/    \/\/   vState1 = {f[t+2],e[t+2],b[t+2],a[t+2]}   \" = vState0[t+2] \"\n+    \/\/    \/\/   vTmp0 = {W[t+3]+K[t+3], W[t+2]+K[t+2], W[t+1]+K[t+1], W[t+0]+K[t+0]}\n+    \/\/    \/\/  Output:\n+    \/\/    \/\/   vState0 = {f[t+4],e[t+4],b[t+4],a[t+4]}   \" = vState0[t+4] \"\n+    \/\/    vsha2ch.vv vState0, vState1, vTmp0\n+    \/\/\n+    \/\/    \/\/ Combine 2QW into 1QW\n+    \/\/    \/\/\n+    \/\/    \/\/ To generate the next 4 words, \"new_vW0\"\/\"vTmp0\" from vW0-vW3, vsha2ms needs\n+    \/\/    \/\/     vW0[0..3], vW1[0], vW2[1..3], vW3[0, 2..3]\n+    \/\/    \/\/ and it can only take 3 vectors as inputs. Hence we need to combine\n+    \/\/    \/\/ vW1[0] and vW2[1..3] in a single vector.\n+    \/\/    \/\/\n+    \/\/    \/\/ vmerge Vt4, Vt1, Vt2, V0\n+    \/\/    \/\/ Input\n+    \/\/    \/\/  V0 = mask \/\/ first word from vW2, 1..3 words from vW1\n+    \/\/    \/\/  vW2 = {Wt-8, Wt-7, Wt-6, Wt-5}\n+    \/\/    \/\/  vW1 = {Wt-12, Wt-11, Wt-10, Wt-9}\n+    \/\/    \/\/ Output\n+    \/\/    \/\/  Vt4 = {Wt-12, Wt-7, Wt-6, Wt-5}\n+    \/\/    vmerge.vvm vTmp0, vW2, vW1, v0\n+    \/\/\n+    \/\/    \/\/ Generate next Four Message Schedule Words (hence allowing for 4 more rounds)\n+    \/\/    \/\/ Input\n+    \/\/    \/\/  vW0 = {W[t+ 3], W[t+ 2], W[t+ 1], W[t+ 0]}     W[ 3: 0]\n+    \/\/    \/\/  vW3 = {W[t+15], W[t+14], W[t+13], W[t+12]}     W[15:12]\n+    \/\/    \/\/  vTmp0 = {W[t+11], W[t+10], W[t+ 9], W[t+ 4]}     W[11: 9,4]\n+    \/\/    \/\/ Output (next four message schedule words)\n+    \/\/    \/\/  vW0 = {W[t+19],  W[t+18],  W[t+17],  W[t+16]}  W[19:16]\n+    \/\/    vsha2ms.vv vW0, vTmp0, vW3\n+    \/\/\n+    \/\/ BEFORE\n+    \/\/  vW0 - vW3 hold the message schedule words (initially the block words)\n+    \/\/    vW0 = W[ 3: 0]   \"oldest\"\n+    \/\/    vW1 = W[ 7: 4]\n+    \/\/    vW2 = W[11: 8]\n+    \/\/    vW3 = W[15:12]   \"newest\"\n+    \/\/\n+    \/\/  vt6 - vt7 hold the working state variables\n+    \/\/    vState0 = {a[t],b[t],e[t],f[t]}   \/\/ initially {H5,H4,H1,H0}\n+    \/\/    vState1 = {c[t],d[t],g[t],h[t]}   \/\/ initially {H7,H6,H3,H2}\n+    \/\/\n+    \/\/ AFTER\n+    \/\/  vW0 - vW3 hold the message schedule words (initially the block words)\n+    \/\/    vW1 = W[ 7: 4]   \"oldest\"\n+    \/\/    vW2 = W[11: 8]\n+    \/\/    vW3 = W[15:12]\n+    \/\/    vW0 = W[19:16]   \"newest\"\n+    \/\/\n+    \/\/  vState0 and vState1 hold the working state variables\n+    \/\/    vState0 = {a[t+4],b[t+4],e[t+4],f[t+4]}\n+    \/\/    vState1 = {c[t+4],d[t+4],g[t+4],h[t+4]}\n+    \/\/\n+    \/\/  The group of vectors vW0,vW1,vW2,vW3 is \"rotated\" by one in each quad-round,\n+    \/\/  hence the uses of those vectors rotate in each round, and we get back to the\n+    \/\/  initial configuration every 4 quad-rounds. We could avoid those changes at\n+    \/\/  the cost of moving those vectors at the end of each quad-rounds.\n+    void sha2_quad_round(Assembler::SEW vset_sew, VectorRegister rot1, VectorRegister rot2, VectorRegister rot3, VectorRegister rot4,\n+                         Register scalarconst, VectorRegister vtemp, VectorRegister vtemp2, VectorRegister v_abef, VectorRegister v_cdgh,\n+                         bool gen_words = true, bool step_const = true) {\n+      __ vleXX_v(vset_sew, vtemp, scalarconst);\n+      if (step_const) {\n+        __ addi(scalarconst, scalarconst, vset_sew == Assembler::e32 ? 16 : 32);\n+      }\n+      __ vadd_vv(vtemp2, vtemp, rot1);\n+      __ vsha2cl_vv(v_cdgh, v_abef, vtemp2);\n+      __ vsha2ch_vv(v_abef, v_cdgh, vtemp2);\n+      if (gen_words) {\n+        __ vmerge_vvm(vtemp2, rot3, rot2);\n+        __ vsha2ms_vv(rot1, vtemp2, rot4);\n+      }\n+    }\n+\n+    const char* stub_name(Assembler::SEW vset_sew, bool multi_block) {\n+      if (vset_sew == Assembler::e32 && !multi_block) return \"sha256_implCompress\";\n+      if (vset_sew == Assembler::e32 &&  multi_block) return \"sha256_implCompressMB\";\n+      if (vset_sew == Assembler::e64 && !multi_block) return \"sha512_implCompress\";\n+      if (vset_sew == Assembler::e64 &&  multi_block) return \"sha512_implCompressMB\";\n+      ShouldNotReachHere();\n+      return \"bad name lookup\";\n+    }\n+\n+    \/\/ Arguments:\n+    \/\/\n+    \/\/ Inputs:\n+    \/\/   c_rarg0   - byte[]  source+offset\n+    \/\/   c_rarg1   - int[]   SHA.state\n+    \/\/   c_rarg2   - int     offset\n+    \/\/   c_rarg3   - int     limit\n+    \/\/\n+    address generate_sha2_implCompress(Assembler::SEW vset_sew, bool multi_block) {\n+      alignas(64) static const uint32_t round_consts_256[64] = {\n+        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n+        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n+        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n+        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n+        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n+        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n+        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n+        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n+        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n+        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n+        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n+        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n+        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n+        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n+        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n+        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n+      };\n+      alignas(64) static const uint64_t round_consts_512[80] = {\n+        0x428a2f98d728ae22l, 0x7137449123ef65cdl, 0xb5c0fbcfec4d3b2fl,\n+        0xe9b5dba58189dbbcl, 0x3956c25bf348b538l, 0x59f111f1b605d019l,\n+        0x923f82a4af194f9bl, 0xab1c5ed5da6d8118l, 0xd807aa98a3030242l,\n+        0x12835b0145706fbel, 0x243185be4ee4b28cl, 0x550c7dc3d5ffb4e2l,\n+        0x72be5d74f27b896fl, 0x80deb1fe3b1696b1l, 0x9bdc06a725c71235l,\n+        0xc19bf174cf692694l, 0xe49b69c19ef14ad2l, 0xefbe4786384f25e3l,\n+        0x0fc19dc68b8cd5b5l, 0x240ca1cc77ac9c65l, 0x2de92c6f592b0275l,\n+        0x4a7484aa6ea6e483l, 0x5cb0a9dcbd41fbd4l, 0x76f988da831153b5l,\n+        0x983e5152ee66dfabl, 0xa831c66d2db43210l, 0xb00327c898fb213fl,\n+        0xbf597fc7beef0ee4l, 0xc6e00bf33da88fc2l, 0xd5a79147930aa725l,\n+        0x06ca6351e003826fl, 0x142929670a0e6e70l, 0x27b70a8546d22ffcl,\n+        0x2e1b21385c26c926l, 0x4d2c6dfc5ac42aedl, 0x53380d139d95b3dfl,\n+        0x650a73548baf63del, 0x766a0abb3c77b2a8l, 0x81c2c92e47edaee6l,\n+        0x92722c851482353bl, 0xa2bfe8a14cf10364l, 0xa81a664bbc423001l,\n+        0xc24b8b70d0f89791l, 0xc76c51a30654be30l, 0xd192e819d6ef5218l,\n+        0xd69906245565a910l, 0xf40e35855771202al, 0x106aa07032bbd1b8l,\n+        0x19a4c116b8d2d0c8l, 0x1e376c085141ab53l, 0x2748774cdf8eeb99l,\n+        0x34b0bcb5e19b48a8l, 0x391c0cb3c5c95a63l, 0x4ed8aa4ae3418acbl,\n+        0x5b9cca4f7763e373l, 0x682e6ff3d6b2b8a3l, 0x748f82ee5defb2fcl,\n+        0x78a5636f43172f60l, 0x84c87814a1f0ab72l, 0x8cc702081a6439ecl,\n+        0x90befffa23631e28l, 0xa4506cebde82bde9l, 0xbef9a3f7b2c67915l,\n+        0xc67178f2e372532bl, 0xca273eceea26619cl, 0xd186b8c721c0c207l,\n+        0xeada7dd6cde0eb1el, 0xf57d4f7fee6ed178l, 0x06f067aa72176fbal,\n+        0x0a637dc5a2c898a6l, 0x113f9804bef90dael, 0x1b710b35131c471bl,\n+        0x28db77f523047d84l, 0x32caab7b40c72493l, 0x3c9ebe0a15c9bebcl,\n+        0x431d67c49c100d4cl, 0x4cc5d4becb3e42b6l, 0x597f299cfc657e2al,\n+        0x5fcb6fab3ad6faecl, 0x6c44198c4a475817l\n+      };\n+      const int const_add = vset_sew == Assembler::e32 ? 16 : 32;\n+\n+      __ align(CodeEntryAlignment);\n+      StubCodeMark mark(_cgen, \"StubRoutines\", stub_name(vset_sew, multi_block));\n+      address start = __ pc();\n+\n+      Register buf   = c_rarg0;\n+      Register state = c_rarg1;\n+      Register ofs   = c_rarg2;\n+      Register limit = c_rarg3;\n+      Register consts =  t2; \/\/ caller saved\n+      Register state_c = x28; \/\/ caller saved\n+      VectorRegister vindex = v2;\n+      VectorRegister vW0 = v4;\n+      VectorRegister vW1 = v6;\n+      VectorRegister vW2 = v8;\n+      VectorRegister vW3 = v10;\n+      VectorRegister vState0 = v12;\n+      VectorRegister vState1 = v14;\n+      VectorRegister vHash0  = v16;\n+      VectorRegister vHash1  = v18;\n+      VectorRegister vTmp0   = v20;\n+      VectorRegister vTmp1   = v22;\n+\n+      Label multi_block_loop;\n+\n+      __ enter();\n+\n+      address constant_table = vset_sew == Assembler::e32 ? (address)round_consts_256 : (address)round_consts_512;\n+      la(consts, ExternalAddress(constant_table));\n+\n+      \/\/ Register use in this function:\n+      \/\/\n+      \/\/ VECTORS\n+      \/\/  vW0 - vW3 (512\/1024-bits \/ 4*128\/256 bits \/ 4*4*32\/65 bits), hold the message\n+      \/\/             schedule words (Wt). They start with the message block\n+      \/\/             content (W0 to W15), then further words in the message\n+      \/\/             schedule generated via vsha2ms from previous Wt.\n+      \/\/   Initially:\n+      \/\/     vW0 = W[  3:0] = { W3,  W2,  W1,  W0}\n+      \/\/     vW1 = W[  7:4] = { W7,  W6,  W5,  W4}\n+      \/\/     vW2 = W[ 11:8] = {W11, W10,  W9,  W8}\n+      \/\/     vW3 = W[15:12] = {W15, W14, W13, W12}\n+      \/\/\n+      \/\/  vState0 - vState1 hold the working state variables (a, b, ..., h)\n+      \/\/    vState0 = {f[t],e[t],b[t],a[t]}\n+      \/\/    vState1 = {h[t],g[t],d[t],c[t]}\n+      \/\/   Initially:\n+      \/\/    vState0 = {H5i-1, H4i-1, H1i-1 , H0i-1}\n+      \/\/    vState1 = {H7i-i, H6i-1, H3i-1 , H2i-1}\n+      \/\/\n+      \/\/  v0 = masks for vrgather\/vmerge. Single value during the 16 rounds.\n+      \/\/\n+      \/\/  vTmp0 = temporary, Wt+Kt\n+      \/\/  vTmp1 = temporary, Kt\n+      \/\/\n+      \/\/  vHash0\/vHash1 = hold the initial values of the hash, byte-swapped.\n+      \/\/\n+      \/\/ During most of the function the vector state is configured so that each\n+      \/\/ vector is interpreted as containing four 32\/64 bits (e32\/e64) elements (128\/256 bits).\n+\n+      \/\/ vsha2ch\/vsha2cl uses EGW of 4*SEW.\n+      \/\/ SHA256 SEW = e32, EGW = 128-bits\n+      \/\/ SHA512 SEW = e64, EGW = 256-bits\n+      \/\/\n+      \/\/ VLEN is required to be at least 128.\n+      \/\/ For the case of VLEN=128 and SHA512 we need LMUL=2 to work with 4*e64 (EGW = 256)\n+      \/\/\n+      \/\/ m1: LMUL=1\/2\n+      \/\/ ta: tail agnostic (don't care about those lanes)\n+      \/\/ ma: mask agnostic (don't care about those lanes)\n+      \/\/ x0 is not written, we known the number of vector elements.\n+\n+      if (vset_sew == Assembler::e64 && MaxVectorSize == 16) { \/\/ SHA512 and VLEN = 128\n+        __ vsetivli(x0, 4, vset_sew, Assembler::m2, Assembler::ma, Assembler::ta);\n+      } else {\n+        __ vsetivli(x0, 4, vset_sew, Assembler::m1, Assembler::ma, Assembler::ta);\n+      }\n+\n+      int64_t indexes = vset_sew == Assembler::e32 ? 0x00041014ul : 0x00082028ul;\n+      __ li(t0, indexes);\n+      __ vmv_v_x(vindex, t0);\n+\n+      \/\/ Step-over a,b, so we are pointing to c.\n+      \/\/ const_add is equal to 4x state variable, div by 2 is thus 2, a,b\n+      __ addi(state_c, state, const_add\/2);\n+\n+      \/\/ Use index-load to get {f,e,b,a},{h,g,d,c}\n+      __ vluxei8_v(vState0, state, vindex);\n+      __ vluxei8_v(vState1, state_c, vindex);\n+\n+      __ bind(multi_block_loop);\n+\n+      \/\/ Capture the initial H values in vHash0 and vHash1 to allow for computing\n+      \/\/ the resulting H', since H' = H+{a',b',c',...,h'}.\n+      __ vmv_v_v(vHash0, vState0);\n+      __ vmv_v_v(vHash1, vState1);\n+\n+      \/\/ Load the 512\/1024-bits of the message block in vW0-vW3 and perform\n+      \/\/ an endian swap on each 4\/8 bytes element.\n+      \/\/\n+      \/\/ If Zvkb is not implemented one can use vrgather\n+      \/\/ with an index sequence to byte-swap.\n+      \/\/  sequence = [3 2 1 0   7 6 5 4  11 10 9 8   15 14 13 12]\n+      \/\/   <https:\/\/oeis.org\/A004444> gives us \"N ^ 3\" as a nice formula to generate\n+      \/\/  this sequence. 'vid' gives us the N.\n+      __ vleXX_v(vset_sew, vW0, buf);\n+      __ vrev8_v(vW0, vW0);\n+      __ addi(buf, buf, const_add);\n+      __ vleXX_v(vset_sew, vW1, buf);\n+      __ vrev8_v(vW1, vW1);\n+      __ addi(buf, buf, const_add);\n+      __ vleXX_v(vset_sew, vW2, buf);\n+      __ vrev8_v(vW2, vW2);\n+      __ addi(buf, buf, const_add);\n+      __ vleXX_v(vset_sew, vW3, buf);\n+      __ vrev8_v(vW3, vW3);\n+      __ addi(buf, buf, const_add);\n+\n+      \/\/ Set v0 up for the vmerge that replaces the first word (idx==0)\n+      __ vid_v(v0);\n+      __ vmseq_vi(v0, v0, 0x0);  \/\/ v0.mask[i] = (i == 0 ? 1 : 0)\n+\n+      VectorRegister rotation_regs[] = {vW0, vW1, vW2, vW3};\n+      int rot_pos = 0;\n+      \/\/ Quad-round #0 (+0, vW0->vW1->vW2->vW3) ... #11 (+3, vW3->vW0->vW1->vW2)\n+      const int qr_end = vset_sew == Assembler::e32 ? 12 : 16;\n+      for (int i = 0; i < qr_end; i++) {\n+        sha2_quad_round(vset_sew,\n+                   rotation_regs[(rot_pos + 0) & 0x3],\n+                   rotation_regs[(rot_pos + 1) & 0x3],\n+                   rotation_regs[(rot_pos + 2) & 0x3],\n+                   rotation_regs[(rot_pos + 3) & 0x3],\n+                   consts,\n+                   vTmp1, vTmp0, vState0, vState1);\n+        ++rot_pos;\n+      }\n+      \/\/ Quad-round #12 (+0, vW0->vW1->vW2->vW3) ... #15 (+3, vW3->vW0->vW1->vW2)\n+      \/\/ Note that we stop generating new message schedule words (Wt, vW0-13)\n+      \/\/ as we already generated all the words we end up consuming (i.e., W[63:60]).\n+      const int qr_c_end = qr_end + 4;\n+      for (int i = qr_end; i < qr_c_end; i++) {\n+        sha2_quad_round(vset_sew,\n+                   rotation_regs[(rot_pos + 0) & 0x3],\n+                   rotation_regs[(rot_pos + 1) & 0x3],\n+                   rotation_regs[(rot_pos + 2) & 0x3],\n+                   rotation_regs[(rot_pos + 3) & 0x3],\n+                   consts,\n+                   vTmp1, vTmp0, vState0, vState1, false, i < (qr_c_end-1));\n+        ++rot_pos;\n+      }\n+\n+      \/\/--------------------------------------------------------------------------------\n+      \/\/ Compute the updated hash value H'\n+      \/\/   H' = H + {h',g',...,b',a'}\n+      \/\/      = {h,g,...,b,a} + {h',g',...,b',a'}\n+      \/\/      = {h+h',g+g',...,b+b',a+a'}\n+\n+      \/\/ H' = H+{a',b',c',...,h'}\n+      __ vadd_vv(vState0, vHash0, vState0);\n+      __ vadd_vv(vState1, vHash1, vState1);\n+\n+      if (multi_block) {\n+        int total_adds = vset_sew == Assembler::e32 ? 240 : 608;\n+        __ addi(consts, consts, -total_adds);\n+        __ add(ofs, ofs, vset_sew == Assembler::e32 ? 64 : 128);\n+        __ ble(ofs, limit, multi_block_loop);\n+        __ mv(c_rarg0, ofs); \/\/ return ofs\n+      }\n+\n+      \/\/ Store H[0..8] = {a,b,c,d,e,f,g,h} from\n+      \/\/  vState0 = {f,e,b,a}\n+      \/\/  vState1 = {h,g,d,c}\n+      __ vsuxei8_v(vState0, state,   vindex);\n+      __ vsuxei8_v(vState1, state_c, vindex);\n+\n+      __ leave();\n+      __ ret();\n+\n+      return start;\n+    }\n+  };\n+#undef __\n+#define __ masm->\n+\n@@ -4865,0 +5251,12 @@\n+    if (UseSHA256Intrinsics) {\n+      Sha2Generator sha2(_masm, this);\n+      StubRoutines::_sha256_implCompress   = sha2.generate_sha256_implCompress(false);\n+      StubRoutines::_sha256_implCompressMB = sha2.generate_sha256_implCompress(true);\n+    }\n+\n+    if (UseSHA512Intrinsics) {\n+      Sha2Generator sha2(_masm, this);\n+      StubRoutines::_sha512_implCompress   = sha2.generate_sha512_implCompress(false);\n+      StubRoutines::_sha512_implCompressMB = sha2.generate_sha512_implCompress(true);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":398,"deletions":0,"binary":false,"changes":398,"status":"modified"},{"patch":"@@ -149,5 +149,0 @@\n-  if (UseSHA) {\n-    warning(\"SHA instructions are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseSHA, false);\n-  }\n-\n@@ -159,10 +154,0 @@\n-  if (UseSHA256Intrinsics) {\n-    warning(\"Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n-  }\n-\n-  if (UseSHA512Intrinsics) {\n-    warning(\"Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);\n-  }\n-\n@@ -275,0 +260,4 @@\n+  if (UseZvkn && !UseRVV) {\n+    FLAG_SET_DEFAULT(UseZvkn, false);\n+    warning(\"Cannot enable Zvkn on cpu without RVV support.\");\n+  }\n@@ -286,0 +275,25 @@\n+\n+  if (!UseZvkn && UseSHA) {\n+    warning(\"SHA instructions are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseSHA, false);\n+  } else if (UseZvkn && FLAG_IS_DEFAULT(UseSHA)) {\n+    FLAG_SET_DEFAULT(UseSHA, true);\n+  }\n+\n+  if (!UseSHA) {\n+    if (UseSHA256Intrinsics) {\n+      warning(\"Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU, UseZvkn needed.\");\n+      FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n+    }\n+    if (UseSHA512Intrinsics) {\n+      warning(\"Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU, UseZvkn needed.\");\n+      FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);\n+    }\n+  } else {\n+    if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {\n+       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);\n+    }\n+    if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -113,0 +113,3 @@\n+  \/\/ Zc  Code Size Reduction - Additional compressed instructions.\n+  \/\/ Zcb Simple code-size saving instructions\n+  \/\/\n@@ -120,0 +123,2 @@\n+ public:\n+\n@@ -140,0 +145,1 @@\n+  decl(ext_Zcb         , \"Zcb\"         , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)              \\\n@@ -212,0 +218,3 @@\n+\n+  \/\/ RISCV64 supports fast class initialization checks\n+  static bool supports_fast_class_init_checks() { return true; }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -468,1 +468,0 @@\n-  const ImmutableOopMap* get_oop_map() const;\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -295,14 +295,0 @@\n-inline const ImmutableOopMap* frame::get_oop_map() const {\n-  if (_cb == nullptr) return nullptr;\n-  if (_cb->oop_maps() != nullptr) {\n-    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n-    if (nop != nullptr && nop->displacement() != 0) {\n-      int slot = ((nop->displacement() >> 24) & 0xff);\n-      return _cb->oop_map_for_slot(slot, _pc);\n-    }\n-    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n-    return oop_map;\n-  }\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+\/\/ The default padding size for data structures to avoid false sharing.\n+#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n+\n","filename":"src\/hotspot\/cpu\/s390\/globalDefinitions_s390.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -660,2 +660,2 @@\n-  int displacement() const { return 0; }\n-  void patch(jint diff) { Unimplemented(); }\n+  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const { return false; }\n+  bool patch(int32_t oopmap_slot, int32_t cb_offset) { Unimplemented(); return false; }\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,2 +152,0 @@\n-  const ImmutableOopMap* get_oop_map() const;\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -346,14 +346,0 @@\n-inline const ImmutableOopMap* frame::get_oop_map() const {\n-  if (_cb == nullptr) return nullptr;\n-  if (_cb->oop_maps() != nullptr) {\n-    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n-    if (nop != nullptr && nop->displacement() != 0) {\n-      int slot = ((nop->displacement() >> 24) & 0xff);\n-      return _cb->oop_map_for_slot(slot, _pc);\n-    }\n-    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n-    return oop_map;\n-  }\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,23 +41,12 @@\n-\/\/ The expected size in bytes of a cache line, used to pad data structures.\n-#if COMPILER1_AND_COMPILER2\n-  #ifdef _LP64\n-    \/\/ tiered, 64-bit, large machine\n-    #define DEFAULT_CACHE_LINE_SIZE 128\n-    #define OM_CACHE_LINE_SIZE 64\n-  #else\n-    \/\/ tiered, 32-bit, medium machine\n-    #define DEFAULT_CACHE_LINE_SIZE 64\n-  #endif\n-#elif defined(COMPILER1)\n-  \/\/ pure C1, 32-bit, small machine\n-  \/\/ i486 was the last Intel chip with 16-byte cache line size\n-  #define DEFAULT_CACHE_LINE_SIZE 32\n-#elif defined(COMPILER2)\n-  #ifdef _LP64\n-    \/\/ pure C2, 64-bit, large machine\n-    #define DEFAULT_CACHE_LINE_SIZE 128\n-    #define OM_CACHE_LINE_SIZE 64\n-  #else\n-    \/\/ pure C2, 32-bit, medium machine\n-    #define DEFAULT_CACHE_LINE_SIZE 64\n-  #endif\n+\/\/ The expected size in bytes of a cache line.\n+#define DEFAULT_CACHE_LINE_SIZE 64\n+\n+\/\/ The default padding size for data structures to avoid false sharing.\n+#ifdef _LP64\n+\/\/ The common wisdom is that adjacent cache line prefetchers on some hardware\n+\/\/ may pull two cache lines on access, so we have to pessimistically assume twice\n+\/\/ the cache line size for padding. TODO: Check if this is still true for modern\n+\/\/ hardware. If not, DEFAULT_CACHE_LINE_SIZE might as well suffice.\n+#define DEFAULT_PADDING_SIZE (DEFAULT_CACHE_LINE_SIZE*2)\n+#else\n+#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1874,86 +1874,0 @@\n-void MacroAssembler::cvtss2sd(XMMRegister dst, XMMRegister src) {\n-  if ((UseAVX > 0) && (dst != src)) {\n-    xorpd(dst, dst);\n-  }\n-  Assembler::cvtss2sd(dst, src);\n-}\n-\n-void MacroAssembler::cvtss2sd(XMMRegister dst, Address src) {\n-  if (UseAVX > 0) {\n-    xorpd(dst, dst);\n-  }\n-  Assembler::cvtss2sd(dst, src);\n-}\n-\n-void MacroAssembler::cvtsd2ss(XMMRegister dst, XMMRegister src) {\n-  if ((UseAVX > 0) && (dst != src)) {\n-    xorps(dst, dst);\n-  }\n-  Assembler::cvtsd2ss(dst, src);\n-}\n-\n-void MacroAssembler::cvtsd2ss(XMMRegister dst, Address src) {\n-  if (UseAVX > 0) {\n-    xorps(dst, dst);\n-  }\n-  Assembler::cvtsd2ss(dst, src);\n-}\n-\n-void MacroAssembler::cvtsi2sdl(XMMRegister dst, Register src) {\n-  if (UseAVX > 0) {\n-    xorpd(dst, dst);\n-  }\n-  Assembler::cvtsi2sdl(dst, src);\n-}\n-\n-void MacroAssembler::cvtsi2sdl(XMMRegister dst, Address src) {\n-  if (UseAVX > 0) {\n-    xorpd(dst, dst);\n-  }\n-  Assembler::cvtsi2sdl(dst, src);\n-}\n-\n-void MacroAssembler::cvtsi2ssl(XMMRegister dst, Register src) {\n-  if (UseAVX > 0) {\n-    xorps(dst, dst);\n-  }\n-  Assembler::cvtsi2ssl(dst, src);\n-}\n-\n-void MacroAssembler::cvtsi2ssl(XMMRegister dst, Address src) {\n-  if (UseAVX > 0) {\n-    xorps(dst, dst);\n-  }\n-  Assembler::cvtsi2ssl(dst, src);\n-}\n-\n-#ifdef _LP64\n-void MacroAssembler::cvtsi2sdq(XMMRegister dst, Register src) {\n-  if (UseAVX > 0) {\n-    xorpd(dst, dst);\n-  }\n-  Assembler::cvtsi2sdq(dst, src);\n-}\n-\n-void MacroAssembler::cvtsi2sdq(XMMRegister dst, Address src) {\n-  if (UseAVX > 0) {\n-    xorpd(dst, dst);\n-  }\n-  Assembler::cvtsi2sdq(dst, src);\n-}\n-\n-void MacroAssembler::cvtsi2ssq(XMMRegister dst, Register src) {\n-  if (UseAVX > 0) {\n-    xorps(dst, dst);\n-  }\n-  Assembler::cvtsi2ssq(dst, src);\n-}\n-\n-void MacroAssembler::cvtsi2ssq(XMMRegister dst, Address src) {\n-  if (UseAVX > 0) {\n-    xorps(dst, dst);\n-  }\n-  Assembler::cvtsi2ssq(dst, src);\n-}\n-#endif  \/\/ _LP64\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -803,17 +803,0 @@\n-\n-  \/\/ cvt instructions\n-  void cvtss2sd(XMMRegister dst, XMMRegister src);\n-  void cvtss2sd(XMMRegister dst, Address src);\n-  void cvtsd2ss(XMMRegister dst, XMMRegister src);\n-  void cvtsd2ss(XMMRegister dst, Address src);\n-  void cvtsi2sdl(XMMRegister dst, Register src);\n-  void cvtsi2sdl(XMMRegister dst, Address src);\n-  void cvtsi2ssl(XMMRegister dst, Register src);\n-  void cvtsi2ssl(XMMRegister dst, Address src);\n-#ifdef _LP64\n-  void cvtsi2sdq(XMMRegister dst, Register src);\n-  void cvtsi2sdq(XMMRegister dst, Address src);\n-  void cvtsi2ssq(XMMRegister dst, Register src);\n-  void cvtsi2ssq(XMMRegister dst, Address src);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -687,2 +687,6 @@\n-void NativePostCallNop::patch(jint diff) {\n-  assert(diff != 0, \"must be\");\n+bool NativePostCallNop::patch(int32_t oopmap_slot, int32_t cb_offset) {\n+  if (((oopmap_slot & 0xff) != oopmap_slot) || ((cb_offset & 0xffffff) != cb_offset)) {\n+    return false; \/\/ cannot encode\n+  }\n+  int32_t data = (oopmap_slot << 24) | cb_offset;\n+  assert(data != 0, \"must be\");\n@@ -690,1 +694,2 @@\n-  *((int32_t *)(code_pos)) = (int32_t) diff;\n+  *((int32_t *)(code_pos)) = (int32_t) data;\n+  return true; \/\/ successfully encoded\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -738,2 +738,10 @@\n-  int displacement() const { return (jint) int_at(displacement_offset); }\n-  void patch(jint diff);\n+  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const {\n+    int32_t data = int_at(displacement_offset);\n+    if (data == 0) {\n+      return false; \/\/ no information encoded\n+    }\n+    cb_offset = (data & 0xffffff);\n+    oopmap_slot = (data >> 24) & 0xff;\n+    return true; \/\/ decoding succeeded\n+  }\n+  bool patch(int32_t oopmap_slot, int32_t cb_offset);\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8968,0 +8968,15 @@\n+instruct verify_vector_alignment(rRegP addr, immL32 mask, rFlagsReg cr) %{\n+  match(Set addr (VerifyVectorAlignment addr mask));\n+  effect(KILL cr);\n+  format %{ \"verify_vector_alignment $addr $mask \\t! verify alignment\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ check if masked bits of addr are zero\n+    __ testq($addr$$Register, $mask$$constant);\n+    __ jccb(Assembler::equal, Lskip);\n+    __ stop(\"verify_vector_alignment found a misaligned vector memory access\");\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -13164,1 +13164,1 @@\n-  predicate( UseSSE<=1 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge );\n+  predicate( UseSSE<=1 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge ));\n@@ -13174,1 +13174,1 @@\n-  predicate( UseSSE>=2 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge );\n+  predicate( UseSSE>=2 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge ));\n@@ -13183,1 +13183,1 @@\n-  predicate( UseSSE==0 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge );\n+  predicate( UseSSE==0 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge ));\n@@ -13192,1 +13192,1 @@\n-  predicate( UseSSE>=1 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge );\n+  predicate( UseSSE>=1 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge ));\n@@ -13355,1 +13355,1 @@\n-  predicate( UseSSE<=1 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::eq || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ne );\n+  predicate( UseSSE<=1 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::eq || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ne ));\n@@ -13365,1 +13365,1 @@\n-  predicate( UseSSE>=2 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::eq || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ne );\n+  predicate( UseSSE>=2 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::eq || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ne ));\n@@ -13374,1 +13374,1 @@\n-  predicate( UseSSE==0 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::eq || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ne );\n+  predicate( UseSSE==0 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::eq || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ne ));\n@@ -13383,1 +13383,1 @@\n-  predicate( UseSSE>=1 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::eq || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ne );\n+  predicate( UseSSE>=1 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::eq || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ne ));\n@@ -13574,1 +13574,1 @@\n-  predicate( UseSSE<=1 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt );\n+  predicate( UseSSE<=1 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt ));\n@@ -13584,1 +13584,1 @@\n-  predicate( UseSSE>=2 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt );\n+  predicate( UseSSE>=2 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt ));\n@@ -13593,1 +13593,1 @@\n-  predicate( UseSSE==0 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt );\n+  predicate( UseSSE==0 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt ));\n@@ -13603,1 +13603,1 @@\n-  predicate( UseSSE>=1 && _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt );\n+  predicate( UseSSE>=1 && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt ));\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -10098,1 +10098,1 @@\n-  effect(TEMP dst);\n+\n@@ -10120,1 +10120,1 @@\n-  effect(TEMP dst);\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n- const ImmutableOopMap* get_oop_map() const;\n-\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,5 +179,0 @@\n-inline const ImmutableOopMap* frame::get_oop_map() const {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+\/\/ The expected size in bytes of a cache line.\n@@ -35,0 +36,3 @@\n+\/\/ The default padding size for data structures to avoid false sharing.\n+#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n+\n","filename":"src\/hotspot\/cpu\/zero\/globalDefinitions_zero.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -217,2 +217,2 @@\n-  int displacement() const { Unimplemented(); return 0; }\n-  void patch(jint diff) { Unimplemented(); }\n+  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const { Unimplemented(); return false; }\n+  bool patch(int32_t oopmap_slot, int32_t cb_offset) { Unimplemented(); return false; }\n","filename":"src\/hotspot\/cpu\/zero\/nativeInst_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -269,0 +269,2 @@\n+    virtual jlong rss_usage_in_bytes() = 0;\n+    virtual jlong cache_usage_in_bytes() = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,0 +217,11 @@\n+jlong CgroupV1Subsystem::rss_usage_in_bytes() {\n+  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n+                          \"rss\", JULONG_FORMAT, JULONG_FORMAT, rss);\n+  return rss;\n+}\n+\n+jlong CgroupV1Subsystem::cache_usage_in_bytes() {\n+  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n+                          \"cache\", JULONG_FORMAT, JULONG_FORMAT, cache);\n+  return cache;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,0 +142,12 @@\n+jlong CgroupV2Subsystem::rss_usage_in_bytes() {\n+  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n+                          \"anon\", JULONG_FORMAT, JULONG_FORMAT, rss);\n+  return rss;\n+}\n+\n+jlong CgroupV2Subsystem::cache_usage_in_bytes() {\n+  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n+                          \"file\", JULONG_FORMAT, JULONG_FORMAT, cache);\n+  return cache;\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,0 +95,10 @@\n+jlong OSContainer::rss_usage_in_bytes() {\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->rss_usage_in_bytes();\n+}\n+\n+jlong OSContainer::cache_usage_in_bytes() {\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cache_usage_in_bytes();\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+  static jlong rss_usage_in_bytes();\n+  static jlong cache_usage_in_bytes();\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2219,1 +2219,1 @@\n-  _print_ascii_file_h(\"\/sys\/kernel\/mm\/transparent_hugepage\/hpage_pdm_size\",\n+  _print_ascii_file_h(\"\/sys\/kernel\/mm\/transparent_hugepage\/hpage_pmd_size\",\n@@ -2401,0 +2401,2 @@\n+  OSContainer::print_container_helper(st, OSContainer::rss_usage_in_bytes(), \"rss_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, OSContainer::cache_usage_in_bytes(), \"cache_usage_in_bytes\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -517,1 +517,33 @@\n-    return 0;\n+    \/\/ We don't use StubRoutines::aarch64::spin_wait stub in order to\n+    \/\/ avoid a costly call to os::current_thread_enable_wx() on MacOS.\n+    \/\/ We should return 1 if SpinPause is implemented, and since there\n+    \/\/ will be a sequence of 11 instructions for NONE and YIELD and 12\n+    \/\/ instructions for NOP and ISB, SpinPause will always return 1.\n+    uint64_t br_dst;\n+    const int instructions_per_case = 2;\n+    int64_t off = VM_Version::spin_wait_desc().inst() * instructions_per_case * Assembler::instruction_size;\n+\n+    assert(VM_Version::spin_wait_desc().inst() >= SpinWait::NONE &&\n+           VM_Version::spin_wait_desc().inst() <= SpinWait::YIELD, \"must be\");\n+    assert(-1 == SpinWait::NONE,  \"must be\");\n+    assert( 0 == SpinWait::NOP,   \"must be\");\n+    assert( 1 == SpinWait::ISB,   \"must be\");\n+    assert( 2 == SpinWait::YIELD, \"must be\");\n+\n+    asm volatile(\n+        \"  adr  %[d], 20          \\n\" \/\/ 20 == PC here + 5 instructions => address\n+                                      \/\/ to entry for case SpinWait::NOP\n+        \"  add  %[d], %[d], %[o]  \\n\"\n+        \"  br   %[d]              \\n\"\n+        \"  b    SpinPause_return  \\n\" \/\/ case SpinWait::NONE  (-1)\n+        \"  nop                    \\n\" \/\/ padding\n+        \"  nop                    \\n\" \/\/ case SpinWait::NOP   ( 0)\n+        \"  b    SpinPause_return  \\n\"\n+        \"  isb                    \\n\" \/\/ case SpinWait::ISB   ( 1)\n+        \"  b    SpinPause_return  \\n\"\n+        \"  yield                  \\n\" \/\/ case SpinWait::YIELD ( 2)\n+        \"SpinPause_return:        \\n\"\n+        : [d]\"=&r\"(br_dst)\n+        : [o]\"r\"(off)\n+        : \"memory\");\n+    return 1;\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -243,0 +243,2 @@\n+  ext_Zcb.enable_feature();\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -797,0 +797,1 @@\n+       !strcmp(_matrule->_rChild->_opType,\"VerifyVectorAlignment\")||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/compilationFailureInfo.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -391,4 +393,0 @@\n-  if (method()->is_synchronized()) {\n-    set_has_monitors(true);\n-  }\n-\n@@ -582,1 +580,1 @@\n-, _has_monitors(false)\n+, _has_monitors(method->is_synchronized() || method->has_monitor_bytecodes())\n@@ -585,0 +583,1 @@\n+, _first_failure_details(nullptr)\n@@ -629,1 +628,1 @@\n-\n+  delete _first_failure_details;\n@@ -655,0 +654,3 @@\n+    if (CaptureBailoutInformation) {\n+      _first_failure_details = new CompilationFailureInfo(msg);\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class CompilationFailureInfo;\n@@ -88,0 +89,1 @@\n+  CompilationFailureInfo* _first_failure_details; \/\/ Details for the first failure happening during compilation\n@@ -215,0 +217,1 @@\n+  const CompilationFailureInfo* first_failure_details() const { return _first_failure_details; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1318,2 +1318,2 @@\n-         (i->as_Goto()->sux_at(0) == tsux  && i->as_Goto()->is_safepoint() == tsux->bci() < stream()->cur_bci()) ||\n-         (i->as_Goto()->sux_at(0) == fsux  && i->as_Goto()->is_safepoint() == fsux->bci() < stream()->cur_bci()),\n+         (i->as_Goto()->sux_at(0) == tsux  && i->as_Goto()->is_safepoint() == (tsux->bci() < stream()->cur_bci())) ||\n+         (i->as_Goto()->sux_at(0) == fsux  && i->as_Goto()->is_safepoint() == (fsux->bci() < stream()->cur_bci())),\n@@ -1454,1 +1454,1 @@\n-          assert(res->as_Goto()->is_safepoint() == sw.dest_offset_at(i) < 0, \"safepoint state of Goto returned by canonicalizer incorrect\");\n+          assert(res->as_Goto()->is_safepoint() == (sw.dest_offset_at(i) < 0), \"safepoint state of Goto returned by canonicalizer incorrect\");\n@@ -1503,1 +1503,1 @@\n-          assert(res->as_Goto()->is_safepoint() == sw.pair_at(i).offset() < 0, \"safepoint state of Goto returned by canonicalizer incorrect\");\n+          assert(res->as_Goto()->is_safepoint() == (sw.pair_at(i).offset() < 0), \"safepoint state of Goto returned by canonicalizer incorrect\");\n@@ -2319,1 +2319,0 @@\n-  compilation()->set_has_monitors(true);\n@@ -3513,0 +3512,9 @@\n+static void set_flags_for_inlined_callee(Compilation* compilation, ciMethod* callee) {\n+  if (callee->has_reserved_stack_access()) {\n+    compilation->set_has_reserved_stack_access(true);\n+  }\n+  if (callee->is_synchronized() || callee->has_monitor_bytecodes()) {\n+    compilation->set_has_monitors(true);\n+  }\n+}\n+\n@@ -3529,3 +3537,1 @@\n-      if (callee->has_reserved_stack_access()) {\n-        compilation()->set_has_reserved_stack_access(true);\n-      }\n+      set_flags_for_inlined_callee(compilation(), callee);\n@@ -3542,3 +3548,1 @@\n-      if (callee->has_reserved_stack_access()) {\n-        compilation()->set_has_reserved_stack_access(true);\n-      }\n+      set_flags_for_inlined_callee(compilation(), callee);\n@@ -3562,3 +3566,1 @@\n-    if (callee->has_reserved_stack_access()) {\n-      compilation()->set_has_reserved_stack_access(true);\n-    }\n+    set_flags_for_inlined_callee(compilation(), callee);\n@@ -4471,1 +4473,3 @@\n-  vmap()->print();\n+  if (UseLocalValueNumbering) {\n+    vmap()->print();\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4860,2 +4860,2 @@\n-    assert (kind == fixedKind && fixed->from() <= any->from() ||\n-            kind == anyKind   && any->from() <= fixed->from(), \"wrong interval!!!\");\n+    assert((kind == fixedKind && fixed->from() <= any->from()) ||\n+           (kind == anyKind   && any->from() <= fixed->from()), \"wrong interval!!!\");\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    assert(tag == t->type()->tag() || tag == objectTag && t->type()->tag() == addressTag, \"types must correspond\");\n+    assert(tag == t->type()->tag() || (tag == objectTag && t->type()->tag() == addressTag), \"types must correspond\");\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -579,6 +579,8 @@\n-    assert(ent->in_named_module(), \"must be\");\n-    bool cond = strcmp(file, ent->name()) == 0;\n-    log_debug(class, path)(\"get_module_shared_path_index (%d) %s : %s = %s\", i,\n-                           location->as_C_string(), ent->name(), cond ? \"same\" : \"different\");\n-    if (cond) {\n-      return i;\n+    if (!ent->is_non_existent()) {\n+      assert(ent->in_named_module(), \"must be\");\n+      bool cond = strcmp(file, ent->name()) == 0;\n+      log_debug(class, path)(\"get_module_shared_path_index (%d) %s : %s = %s\", i,\n+                             location->as_C_string(), ent->name(), cond ? \"same\" : \"different\");\n+      if (cond) {\n+        return i;\n+      }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,1 @@\n+  bool is_non_existent()  const { return _type == non_existent_entry; }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-  CompileTask* task() { return _task; }\n+  CompileTask* task() const { return _task; }\n@@ -447,1 +447,1 @@\n-  void* compiler_data() { return _compiler_data; }\n+  void* compiler_data() const { return _compiler_data; }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-  if (nop != nullptr && nop->displacement() != 0) {\n-    int offset = (nop->displacement() & 0xffffff);\n+  int offset;\n+  if (nop != nullptr && nop->decode(slot, offset)) {\n@@ -43,1 +43,0 @@\n-    slot = ((nop->displacement() >> 24) & 0xff);\n@@ -55,3 +54,6 @@\n-  return (nop != nullptr && nop->displacement() != 0)\n-      ? ((nop->displacement() >> 24) & 0xff)\n-      : -1;\n+  int oopmap_slot;\n+  int cb_offset;\n+  if (nop != nullptr && nop->decode(oopmap_slot, cb_offset)) {\n+    return oopmap_slot;\n+  }\n+  return -1;\n","filename":"src\/hotspot\/share\/code\/codeCache.inline.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+#ifdef ASSERT\n@@ -134,1 +135,0 @@\n-    _call->set_destination_mt_safe(entry_point);\n@@ -136,0 +136,2 @@\n+#endif\n+  _call->set_destination_mt_safe(entry_point);\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1140,4 +1140,1 @@\n-  } else if (((oopmap_slot & 0xff) == oopmap_slot) && ((offset & 0xffffff) == offset)) {\n-    jint value = (oopmap_slot << 24) | (jint) offset;\n-    nop->patch(value);\n-  } else {\n+  } else if (!nop->patch(oopmap_slot, offset)) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,2 +153,2 @@\n-  assert((cs->locs_start() != nullptr) && (cs->locs_end() != nullptr) ||\n-         (cs->locs_start() == nullptr) && (cs->locs_end() == nullptr), \"valid start and end pointer\");\n+  assert(((cs->locs_start() != nullptr) && (cs->locs_end() != nullptr)) ||\n+         ((cs->locs_start() == nullptr) && (cs->locs_end() == nullptr)), \"valid start and end pointer\");\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#if defined(COMPILER1) || defined(COMPILER2)\n+\n+#ifdef COMPILER1\n+#include \"c1\/c1_Compilation.hpp\"\n+#endif\n+#include \"ci\/ciEnv.hpp\"\n+#include \"compiler\/abstractCompiler.hpp\"\n+#include \"compiler\/compilationFailureInfo.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#ifdef COMPILER2\n+#include \"opto\/node.hpp\"\n+#include \"opto\/compile.hpp\"\n+#endif\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+\n+CompilationFailureInfo::CompilationFailureInfo(const char* failure_reason) :\n+  _stack(2),\n+  _failure_reason(os::strdup(failure_reason)),\n+  _elapsed_seconds(os::elapsedTime()),\n+  _compile_id(ciEnv::current()->task()->compile_id())\n+{}\n+\n+CompilationFailureInfo::~CompilationFailureInfo() {\n+  os::free(_failure_reason);\n+}\n+\n+void CompilationFailureInfo::print_on(outputStream* st) const {\n+  st->print(\"  Time: \");\n+  os::print_elapsed_time(st, _elapsed_seconds);\n+  st->print_cr(\"  Compile id: %d\", _compile_id);\n+  st->print_cr(\"  Reason: '%s'\", _failure_reason);\n+  st->print_cr(\"  Callstack: \");\n+  _stack.print_on(st);\n+  st->cr();\n+}\n+\n+\/\/ Convenience function to print current compile failure iff\n+\/\/ current thread is compiler thread and there is a pending failure.\n+\/\/ Otherwise prints nothing.\n+bool CompilationFailureInfo::print_pending_compilation_failure(outputStream* st) {\n+\n+  const CompilationFailureInfo* info = nullptr;\n+\n+  \/\/ Carefully tiptoeing because we are called from the error reporter and\n+  \/\/ nothing is certain.\n+\n+  const Thread* const t = Thread::current();\n+  if (t == nullptr || !t->is_Compiler_thread()) {\n+    return false;\n+  }\n+\n+  const ciEnv* const env = ciEnv::current();\n+  if (env == nullptr) {\n+    return false;\n+  }\n+\n+  const CompileTask* const task = env->task();\n+  if (task == nullptr) {\n+    return false;\n+  }\n+\n+  const AbstractCompiler* const compiler = task->compiler();\n+  if (compiler == nullptr) {\n+    return false;\n+  }\n+\n+#ifdef COMPILER1\n+  if (compiler->type() == compiler_c1) {\n+    const Compilation* const C = (Compilation*)env->compiler_data();\n+    if (C != nullptr) {\n+      info = C->first_failure_details();\n+    }\n+  }\n+#endif\n+#ifdef COMPILER2\n+  if (compiler->type() == compiler_c2) {\n+    const Compile* const C = (Compile*)env->compiler_data();\n+    if (C != nullptr) {\n+      info = C->first_failure_details();\n+    }\n+  }\n+#endif\n+\n+  if (info != nullptr) {\n+    st->print_cr(\"Pending compilation failure details for thread \" PTR_FORMAT \":\", p2i(t));\n+    info->print_on(st);\n+  }\n+\n+  return true;\n+}\n+\n+#endif \/\/ defined(COMPILER1) || defined(COMPILER2)\n","filename":"src\/hotspot\/share\/compiler\/compilationFailureInfo.cpp","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_COMPILER_COMPILATIONFAILUREINFO_HPP\n+#define SHARE_COMPILER_COMPILATIONFAILUREINFO_HPP\n+\n+#if defined(COMPILER1) || defined(COMPILER2)\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+\n+class outputStream;\n+class Symbol;\n+\n+class CompilationFailureInfo : public CHeapObj<mtCompiler> {\n+  NativeCallStack _stack;\n+  char* const _failure_reason;\n+  const double _elapsed_seconds;\n+  const int _compile_id;\n+public:\n+  CompilationFailureInfo(const char* failure_reason);\n+  ~CompilationFailureInfo();\n+  void print_on(outputStream* st) const;\n+\n+  \/\/ Convenience function to print, safely, current compile failure iff\n+  \/\/ current thread is compiler thread and there is an ongoing compilation\n+  \/\/ and a pending failure.\n+  \/\/ Otherwise prints nothing.\n+  static bool print_pending_compilation_failure(outputStream* st);\n+};\n+\n+#endif \/\/ defined(COMPILER1) || defined(COMPILER2)\n+\n+#endif \/\/ SHARE_COMPILER_COMPILATIONFAILUREINFO_HPP\n","filename":"src\/hotspot\/share\/compiler\/compilationFailureInfo.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  assert(is_jvmci_compiler() && is_jvmci() || !is_jvmci_compiler(), \"JVMCI compiler implies enabled JVMCI\");\n+  assert(!is_jvmci_compiler() || is_jvmci(), \"JVMCI compiler implies enabled JVMCI\");\n@@ -117,1 +117,1 @@\n-  assert(is_c1_simple_only() && is_c1_only() || !is_c1_simple_only(), \"c1 simple mode must imply c1-only mode\");\n+  assert(!is_c1_simple_only() || is_c1_only(), \"c1 simple mode must imply c1-only mode\");\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -382,0 +382,4 @@\n+  product(bool, CaptureBailoutInformation, trueInDebug, DIAGNOSTIC,         \\\n+          \"If compilation is stopped with an error, capture diagnostic \"    \\\n+          \"information at the bailout point\")                               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-    char _pad0[DEFAULT_CACHE_LINE_SIZE];\n+    char _pad0[DEFAULT_PADDING_SIZE];\n@@ -172,1 +172,1 @@\n-    char _pad4[DEFAULT_CACHE_LINE_SIZE - sizeof(size_t)];\n+    char _pad4[DEFAULT_PADDING_SIZE - sizeof(size_t)];\n@@ -235,1 +235,1 @@\n-  char _pad0[DEFAULT_CACHE_LINE_SIZE];\n+  char _pad0[DEFAULT_PADDING_SIZE];\n@@ -237,1 +237,1 @@\n-  char _pad1[DEFAULT_CACHE_LINE_SIZE - sizeof(TaskQueueEntryChunk*)];\n+  char _pad1[DEFAULT_PADDING_SIZE - sizeof(TaskQueueEntryChunk*)];\n@@ -240,1 +240,1 @@\n-  char _pad2[DEFAULT_CACHE_LINE_SIZE - sizeof(TaskQueueEntryChunk*) - sizeof(size_t)];\n+  char _pad2[DEFAULT_PADDING_SIZE - sizeof(TaskQueueEntryChunk*) - sizeof(size_t)];\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(PausedList*));\n+    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(PausedList*));\n@@ -160,1 +160,1 @@\n-  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_PADDING_SIZE, 0);\n@@ -163,1 +163,1 @@\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(size_t));\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(size_t));\n@@ -167,1 +167,1 @@\n-  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(size_t));\n+  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_PADDING_SIZE, sizeof(size_t));\n@@ -172,1 +172,1 @@\n-  DEFINE_PAD_MINUS_SIZE(3, DEFAULT_CACHE_LINE_SIZE, sizeof(BufferNode*));\n+  DEFINE_PAD_MINUS_SIZE(3, DEFAULT_PADDING_SIZE, sizeof(BufferNode*));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-struct DetailedUsage : public StackObj {\n+struct G1HeapTransition::DetailedUsage : public StackObj {\n@@ -82,1 +82,1 @@\n-class DetailedUsageClosure: public HeapRegionClosure {\n+class G1HeapTransition::DetailedUsageClosure: public HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+  struct DetailedUsage;\n+  class DetailedUsageClosure;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  static size_t header_size() { return align_up(sizeof(Segment), DEFAULT_CACHE_LINE_SIZE); }\n+  static size_t header_size() { return align_up(sizeof(Segment), DEFAULT_PADDING_SIZE); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArena.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  const size_t padding_elem_num = (DEFAULT_CACHE_LINE_SIZE \/ sizeof(size_t));\n+  const size_t padding_elem_num = (DEFAULT_PADDING_SIZE \/ sizeof(size_t));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, 0);\n@@ -71,1 +71,1 @@\n-  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(size_t));\n+  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_PADDING_SIZE, sizeof(size_t));\n@@ -73,1 +73,1 @@\n-  DEFINE_PAD_MINUS_SIZE(3, DEFAULT_CACHE_LINE_SIZE, sizeof(BufferNode*));\n+  DEFINE_PAD_MINUS_SIZE(3, DEFAULT_PADDING_SIZE, sizeof(BufferNode*));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -418,2 +418,2 @@\n-  _region_start(nullptr),\n-  DEBUG_ONLY(_region_end(nullptr) COMMA)\n+  _heap_start(nullptr),\n+  DEBUG_ONLY(_heap_end(nullptr) COMMA)\n@@ -428,1 +428,1 @@\n-bool ParallelCompactData::initialize(MemRegion covered_region)\n+bool ParallelCompactData::initialize(MemRegion reserved_heap)\n@@ -430,3 +430,3 @@\n-  _region_start = covered_region.start();\n-  const size_t region_size = covered_region.word_size();\n-  DEBUG_ONLY(_region_end = _region_start + region_size;)\n+  _heap_start = reserved_heap.start();\n+  const size_t heap_size = reserved_heap.word_size();\n+  DEBUG_ONLY(_heap_end = _heap_start + heap_size;)\n@@ -434,1 +434,1 @@\n-  assert(region_align_down(_region_start) == _region_start,\n+  assert(region_align_down(_heap_start) == _heap_start,\n@@ -437,1 +437,1 @@\n-  bool result = initialize_region_data(region_size) && initialize_block_data();\n+  bool result = initialize_region_data(heap_size) && initialize_block_data();\n@@ -470,1 +470,1 @@\n-bool ParallelCompactData::initialize_region_data(size_t region_size)\n+bool ParallelCompactData::initialize_region_data(size_t heap_size)\n@@ -472,2 +472,1 @@\n-  assert((region_size & RegionSizeOffsetMask) == 0,\n-         \"region size not a multiple of RegionSize\");\n+  assert(is_aligned(heap_size, RegionSize), \"precondition\");\n@@ -475,1 +474,1 @@\n-  const size_t count = region_size >> Log2RegionSize;\n+  const size_t count = heap_size >> Log2RegionSize;\n@@ -533,1 +532,1 @@\n-  const size_t obj_ofs = pointer_delta(addr, _region_start);\n+  const size_t obj_ofs = pointer_delta(addr, _heap_start);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-  size_t    src_region_idx() const   { return _src_region_idx; }\n@@ -286,3 +285,0 @@\n-    \/\/ The highest address referenced by objects in this region.\n-    inline HeapWord* highest_ref() const;\n-\n@@ -317,1 +313,0 @@\n-    inline void set_highest_ref(HeapWord* addr);\n@@ -402,1 +397,1 @@\n-  bool initialize(MemRegion covered_region);\n+  bool initialize(MemRegion reserved_heap);\n@@ -446,1 +441,0 @@\n-  inline HeapWord*  region_to_addr(size_t region, size_t offset) const;\n@@ -453,2 +447,0 @@\n-  \/\/ Analogous to region_offset() for blocks.\n-  size_t     block_offset(const HeapWord* addr) const;\n@@ -456,3 +448,0 @@\n-  size_t     addr_to_block_idx(const oop obj) const {\n-    return addr_to_block_idx(cast_from_oop<HeapWord*>(obj));\n-  }\n@@ -460,2 +449,0 @@\n-  inline HeapWord*  block_to_addr(size_t block) const;\n-  inline size_t     region_to_block_idx(size_t region) const;\n@@ -464,2 +451,0 @@\n-  inline HeapWord*  block_align_up(HeapWord* addr) const;\n-  inline bool       is_block_aligned(HeapWord* addr) const;\n@@ -484,1 +469,1 @@\n-  bool initialize_region_data(size_t region_size);\n+  bool initialize_region_data(size_t heap_size);\n@@ -487,2 +472,1 @@\n-private:\n-  HeapWord*       _region_start;\n+  HeapWord*       _heap_start;\n@@ -490,1 +474,1 @@\n-  HeapWord*       _region_end;\n+  HeapWord*       _heap_end;\n@@ -567,6 +551,0 @@\n-inline HeapWord* ParallelCompactData::RegionData::highest_ref() const\n-{\n-  DEBUG_ONLY(return _highest_ref;)\n-  NOT_DEBUG(return nullptr;)\n-}\n-\n@@ -601,10 +579,0 @@\n-inline void ParallelCompactData::RegionData::set_highest_ref(HeapWord* addr)\n-{\n-#ifdef ASSERT\n-  HeapWord* tmp = _highest_ref;\n-  while (addr > tmp) {\n-    tmp = Atomic::cmpxchg(&_highest_ref, tmp, addr);\n-  }\n-#endif  \/\/ #ifdef ASSERT\n-}\n-\n@@ -665,1 +633,1 @@\n-  assert(addr >= _region_start, \"bad addr\");\n+  assert(addr >= _heap_start, \"bad addr\");\n@@ -667,1 +635,1 @@\n-  assert(addr < _region_end, \"bad addr\");\n+  assert(addr < _heap_end, \"bad addr\");\n@@ -674,3 +642,3 @@\n-  assert(addr >= _region_start, \"bad addr \" PTR_FORMAT \" _region_start \" PTR_FORMAT, p2i(addr), p2i(_region_start));\n-  assert(addr <= _region_end, \"bad addr \" PTR_FORMAT \" _region_end \" PTR_FORMAT, p2i(addr), p2i(_region_end));\n-  return pointer_delta(addr, _region_start) >> Log2RegionSize;\n+  assert(addr >= _heap_start, \"bad addr \" PTR_FORMAT \" _region_start \" PTR_FORMAT, p2i(addr), p2i(_heap_start));\n+  assert(addr <= _heap_end, \"bad addr \" PTR_FORMAT \" _region_end \" PTR_FORMAT, p2i(addr), p2i(_heap_end));\n+  return pointer_delta(addr, _heap_start) >> Log2RegionSize;\n@@ -689,1 +657,1 @@\n-  return _region_start + (region << Log2RegionSize);\n+  return _heap_start + (region << Log2RegionSize);\n@@ -699,8 +667,0 @@\n-inline HeapWord*\n-ParallelCompactData::region_to_addr(size_t region, size_t offset) const\n-{\n-  assert(region <= _region_count, \"region out of range\");\n-  assert(offset < RegionSize, \"offset too big\");  \/\/ This may be too strict.\n-  return region_to_addr(region) + offset;\n-}\n-\n@@ -710,2 +670,2 @@\n-  assert(addr >= _region_start, \"bad addr\");\n-  assert(addr < _region_end + RegionSize, \"bad addr\");\n+  assert(addr >= _heap_start, \"bad addr\");\n+  assert(addr < _heap_end + RegionSize, \"bad addr\");\n@@ -718,2 +678,2 @@\n-  assert(addr >= _region_start, \"bad addr\");\n-  assert(addr <= _region_end, \"bad addr\");\n+  assert(addr >= _heap_start, \"bad addr\");\n+  assert(addr <= _heap_end, \"bad addr\");\n@@ -729,8 +689,0 @@\n-inline size_t\n-ParallelCompactData::block_offset(const HeapWord* addr) const\n-{\n-  assert(addr >= _region_start, \"bad addr\");\n-  assert(addr <= _region_end, \"bad addr\");\n-  return (size_t(addr) & BlockAddrOffsetMask) >> LogHeapWordSize;\n-}\n-\n@@ -740,3 +692,3 @@\n-  assert(addr >= _region_start, \"bad addr\");\n-  assert(addr <= _region_end, \"bad addr\");\n-  return pointer_delta(addr, _region_start) >> Log2BlockSize;\n+  assert(addr >= _heap_start, \"bad addr\");\n+  assert(addr <= _heap_end, \"bad addr\");\n+  return pointer_delta(addr, _heap_start) >> Log2BlockSize;\n@@ -751,13 +703,0 @@\n-inline HeapWord*\n-ParallelCompactData::block_to_addr(size_t block) const\n-{\n-  assert(block < _block_count, \"block out of range\");\n-  return _region_start + (block << Log2BlockSize);\n-}\n-\n-inline size_t\n-ParallelCompactData::region_to_block_idx(size_t region) const\n-{\n-  return region << Log2BlocksPerRegion;\n-}\n-\n@@ -767,2 +706,2 @@\n-  assert(addr >= _region_start, \"bad addr\");\n-  assert(addr < _region_end + RegionSize, \"bad addr\");\n+  assert(addr >= _heap_start, \"bad addr\");\n+  assert(addr < _heap_end + RegionSize, \"bad addr\");\n@@ -772,14 +711,0 @@\n-inline HeapWord*\n-ParallelCompactData::block_align_up(HeapWord* addr) const\n-{\n-  assert(addr >= _region_start, \"bad addr\");\n-  assert(addr <= _region_end, \"bad addr\");\n-  return block_align_down(addr + BlockSizeOffsetMask);\n-}\n-\n-inline bool\n-ParallelCompactData::is_block_aligned(HeapWord* addr) const\n-{\n-  return block_offset(addr) == 0;\n-}\n-\n@@ -1174,9 +1099,0 @@\n-  \/\/ Process the end of the given region range in the dense prefix.\n-  \/\/ This includes saving any object not updated.\n-  static void dense_prefix_regions_epilogue(ParCompactionManager* cm,\n-                                            size_t region_start_index,\n-                                            size_t region_end_index,\n-                                            idx_t exiting_object_offset,\n-                                            idx_t region_offset_start,\n-                                            idx_t region_offset_end);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":19,"deletions":103,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -176,2 +176,0 @@\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-\n@@ -181,2 +179,0 @@\n-  uint queue_size = claimed_stack_depth()->max_elems();\n-\n@@ -279,3 +275,1 @@\n-    if (PSScavenge::should_scavenge(p)) {\n-      claim_or_forward_depth(p);\n-    }\n+    claim_or_forward_depth(p);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-  assert(should_scavenge(p, true), \"revisiting object?\");\n@@ -61,3 +60,7 @@\n-  oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-  Prefetch::write(obj->mark_addr(), 0);\n-  push_depth(ScannerTask(p));\n+  T heap_oop = RawAccess<>::oop_load(p);\n+  if (PSScavenge::is_obj_in_young(heap_oop)) {\n+    oop obj = CompressedOops::decode_not_null(heap_oop);\n+    assert(!PSScavenge::is_obj_in_to_space(obj), \"revisiting object?\");\n+    Prefetch::write(obj->mark_addr(), 0);\n+    push_depth(ScannerTask(p));\n+  }\n@@ -99,3 +102,1 @@\n-    if (PSScavenge::should_scavenge(p)) {\n-      _pm->claim_or_forward_depth(p);\n-    }\n+    _pm->claim_or_forward_depth(p);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class OopStack;\n@@ -41,1 +40,0 @@\n-class PSRefProcTaskExecutor;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/serial\/markSweep.inline.hpp\"\n@@ -51,1 +52,1 @@\n-#include \"gc\/shared\/space.hpp\"\n+#include \"gc\/shared\/space.inline.hpp\"\n@@ -60,0 +61,1 @@\n+#include \"runtime\/prefetch.inline.hpp\"\n@@ -69,2 +71,4 @@\n-void GenMarkSweep::invoke_at_safepoint(bool clear_all_softrefs) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n+class DeadSpacer : StackObj {\n+  size_t _allowed_deadspace_words;\n+  bool _active;\n+  ContiguousSpace* _space;\n@@ -72,4 +76,16 @@\n-  SerialHeap* gch = SerialHeap::heap();\n-#ifdef ASSERT\n-  if (gch->soft_ref_policy()->should_clear_all_soft_refs()) {\n-    assert(clear_all_softrefs, \"Policy should have been checked earlier\");\n+public:\n+  DeadSpacer(ContiguousSpace* space) : _allowed_deadspace_words(0), _space(space) {\n+    size_t ratio = _space->allowed_dead_ratio();\n+    _active = ratio > 0;\n+\n+    if (_active) {\n+      \/\/ We allow some amount of garbage towards the bottom of the space, so\n+      \/\/ we don't start compacting before there is a significant gain to be made.\n+      \/\/ Occasionally, we want to ensure a full compaction, which is determined\n+      \/\/ by the MarkSweepAlwaysCompactCount parameter.\n+      if ((MarkSweep::total_invocations() % MarkSweepAlwaysCompactCount) != 0) {\n+        _allowed_deadspace_words = (space->capacity() * ratio \/ 100) \/ HeapWordSize;\n+      } else {\n+        _active = false;\n+      }\n+    }\n@@ -77,1 +93,0 @@\n-#endif\n@@ -79,4 +94,4 @@\n-  gch->trace_heap_before_gc(_gc_tracer);\n-\n-  \/\/ Increment the invocation count\n-  _total_invocations++;\n+  bool insert_deadspace(HeapWord* dead_start, HeapWord* dead_end) {\n+    if (!_active) {\n+      return false;\n+    }\n@@ -84,4 +99,18 @@\n-  \/\/ Capture used regions for each generation that will be\n-  \/\/ subject to collection, so that card table adjustments can\n-  \/\/ be made intelligently (see clear \/ invalidate further below).\n-  gch->save_used_regions();\n+    size_t dead_length = pointer_delta(dead_end, dead_start);\n+    if (_allowed_deadspace_words >= dead_length) {\n+      _allowed_deadspace_words -= dead_length;\n+      CollectedHeap::fill_with_object(dead_start, dead_length);\n+      oop obj = cast_to_oop(dead_start);\n+      \/\/ obj->set_mark(obj->mark().set_marked());\n+\n+      assert(dead_length == obj->size(), \"bad filler object size\");\n+      log_develop_trace(gc, compaction)(\"Inserting object to dead space: \" PTR_FORMAT \", \" PTR_FORMAT \", \" SIZE_FORMAT \"b\",\n+                                        p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);\n+\n+      return true;\n+    } else {\n+      _active = false;\n+      return false;\n+    }\n+  }\n+};\n@@ -89,1 +118,20 @@\n-  allocate_stacks();\n+\/\/ Implement the \"compaction\" part of the mark-compact GC algorithm.\n+class Compacter {\n+  \/\/ There are four spaces in total, but only the first three can be used after\n+  \/\/ compact. IOW, old and eden\/from must be enough for all live objs\n+  static constexpr uint max_num_spaces = 4;\n+\n+  struct CompactionSpace {\n+    ContiguousSpace* _space;\n+    \/\/ Will be the new top after compaction is complete.\n+    HeapWord* _compaction_top;\n+    \/\/ The first dead word in this contiguous space. It's an optimization to\n+    \/\/ skip large chunk of live objects at the beginning.\n+    HeapWord* _first_dead;\n+\n+    void init(ContiguousSpace* space) {\n+      _space = space;\n+      _compaction_top = space->bottom();\n+      _first_dead = nullptr;\n+    }\n+  };\n@@ -91,1 +139,3 @@\n-  mark_sweep_phase1(clear_all_softrefs);\n+  CompactionSpace _spaces[max_num_spaces];\n+  \/\/ The num of spaces to be compacted, i.e. containing live objs.\n+  uint _num_spaces;\n@@ -93,1 +143,1 @@\n-  mark_sweep_phase2();\n+  uint _index;\n@@ -95,5 +145,3 @@\n-  \/\/ Don't add any more derived pointers during phase3\n-#if COMPILER2_OR_JVMCI\n-  assert(DerivedPointerTable::is_active(), \"Sanity\");\n-  DerivedPointerTable::set_active(false);\n-#endif\n+  HeapWord* get_compaction_top(uint index) const {\n+    return _spaces[index]._compaction_top;\n+  }\n@@ -101,1 +149,3 @@\n-  mark_sweep_phase3();\n+  HeapWord* get_first_dead(uint index) const {\n+    return _spaces[index]._first_dead;\n+  }\n@@ -103,1 +153,3 @@\n-  mark_sweep_phase4();\n+  ContiguousSpace* get_space(uint index) const {\n+    return _spaces[index]._space;\n+  }\n@@ -105,1 +157,4 @@\n-  restore_marks();\n+  void record_first_dead(uint index, HeapWord* first_dead) {\n+    assert(_spaces[index]._first_dead == nullptr, \"should write only once\");\n+    _spaces[index]._first_dead = first_dead;\n+  }\n@@ -107,3 +162,18 @@\n-  \/\/ Set saved marks for allocation profiler (and other things? -- dld)\n-  \/\/ (Should this be in general part?)\n-  gch->save_marks();\n+  HeapWord* alloc(size_t words) {\n+    while (true) {\n+      if (words <= pointer_delta(_spaces[_index]._space->end(),\n+                                 _spaces[_index]._compaction_top)) {\n+        HeapWord* result = _spaces[_index]._compaction_top;\n+        _spaces[_index]._compaction_top += words;\n+        if (_index == 0) {\n+          \/\/ old-gen requires BOT update\n+          static_cast<TenuredSpace*>(_spaces[0]._space)->update_for_block(result, result + words);\n+        }\n+        return result;\n+      }\n+\n+      \/\/ out-of-memory in this space\n+      _index++;\n+      assert(_index < max_num_spaces - 1, \"the last space should not be used\");\n+    }\n+  }\n@@ -111,1 +181,5 @@\n-  deallocate_stacks();\n+  static void prefetch_read_scan(void* p) {\n+    if (PrefetchScanIntervalInBytes >= 0) {\n+      Prefetch::read(p, PrefetchScanIntervalInBytes);\n+    }\n+  }\n@@ -113,1 +187,5 @@\n-  MarkSweep::_string_dedup_requests->flush();\n+  static void prefetch_write_scan(void* p) {\n+    if (PrefetchScanIntervalInBytes >= 0) {\n+      Prefetch::write(p, PrefetchScanIntervalInBytes);\n+    }\n+  }\n@@ -115,2 +193,5 @@\n-  bool is_young_gen_empty = (gch->young_gen()->used() == 0);\n-  gch->rem_set()->maintain_old_to_young_invariant(gch->old_gen(), is_young_gen_empty);\n+  static void prefetch_write_copy(void* p) {\n+    if (PrefetchCopyIntervalInBytes >= 0) {\n+      Prefetch::write(p, PrefetchCopyIntervalInBytes);\n+    }\n+  }\n@@ -118,1 +199,10 @@\n-  gch->prune_scavengable_nmethods();\n+  static void forward_obj(oop obj, HeapWord* new_addr) {\n+    prefetch_write_scan(obj);\n+    if (cast_from_oop<HeapWord*>(obj) != new_addr) {\n+      obj->forward_to(cast_to_oop(new_addr));\n+    } else {\n+      assert(obj->is_gc_marked(), \"inv\");\n+      \/\/ This obj will stay in-place. Fix the markword.\n+      obj->init_mark();\n+    }\n+  }\n@@ -120,3 +210,11 @@\n-  \/\/ Update heap occupancy information which is used as\n-  \/\/ input to soft ref clearing policy at the next gc.\n-  Universe::heap()->update_capacity_and_used_at_gc();\n+  static HeapWord* find_next_live_addr(HeapWord* start, HeapWord* end) {\n+    for (HeapWord* i_addr = start; i_addr < end; \/* empty *\/) {\n+      prefetch_read_scan(i_addr);\n+      oop obj = cast_to_oop(i_addr);\n+      if (obj->is_gc_marked()) {\n+        return i_addr;\n+      }\n+      i_addr += obj->size();\n+    }\n+    return end;\n+  };\n@@ -124,2 +222,3 @@\n-  \/\/ Signal that we have completed a visit to all live objects.\n-  Universe::heap()->record_whole_heap_examined_timestamp();\n+  static size_t relocate(HeapWord* addr) {\n+    \/\/ Prefetch source and destination\n+    prefetch_read_scan(addr);\n@@ -127,2 +226,5 @@\n-  gch->trace_heap_after_gc(_gc_tracer);\n-}\n+    oop obj = cast_to_oop(addr);\n+    oop new_obj = obj->forwardee();\n+    HeapWord* new_addr = cast_from_oop<HeapWord*>(new_obj);\n+    assert(addr != new_addr, \"inv\");\n+    prefetch_write_copy(new_addr);\n@@ -130,5 +232,3 @@\n-void GenMarkSweep::allocate_stacks() {\n-  void* scratch = nullptr;\n-  size_t num_words;\n-  DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n-  young_gen->contribute_scratch(scratch, num_words);\n+    size_t obj_size = obj->size();\n+    Copy::aligned_conjoint_words(addr, new_addr, obj_size);\n+    new_obj->init_mark();\n@@ -136,4 +236,1 @@\n-  if (scratch != nullptr) {\n-    _preserved_count_max = num_words * HeapWordSize \/ sizeof(PreservedMark);\n-  } else {\n-    _preserved_count_max = 0;\n+    return obj_size;\n@@ -142,5 +239,16 @@\n-  _preserved_marks = (PreservedMark*)scratch;\n-  _preserved_count = 0;\n-\n-  _preserved_overflow_stack_set.init(1);\n-}\n+public:\n+  explicit Compacter(SerialHeap* heap) {\n+    \/\/ In this order so that heap is compacted towards old-gen.\n+    _spaces[0].init(heap->old_gen()->space());\n+    _spaces[1].init(heap->young_gen()->eden());\n+    _spaces[2].init(heap->young_gen()->from());\n+\n+    bool is_promotion_failed = (heap->young_gen()->from()->next_compaction_space() != nullptr);\n+    if (is_promotion_failed) {\n+      _spaces[3].init(heap->young_gen()->to());\n+      _num_spaces = 4;\n+    } else {\n+      _num_spaces = 3;\n+    }\n+    _index = 0;\n+  }\n@@ -148,0 +256,39 @@\n+  void phase2_calculate_new_addr() {\n+    for (uint i = 0; i < _num_spaces; ++i) {\n+      ContiguousSpace* space = get_space(i);\n+      HeapWord* cur_addr = space->bottom();\n+      HeapWord* top = space->top();\n+\n+      bool record_first_dead_done = false;\n+\n+      DeadSpacer dead_spacer(space);\n+\n+      while (cur_addr < top) {\n+        oop obj = cast_to_oop(cur_addr);\n+        size_t obj_size = obj->size();\n+        if (obj->is_gc_marked()) {\n+          HeapWord* new_addr = alloc(obj_size);\n+          forward_obj(obj, new_addr);\n+          cur_addr += obj_size;\n+        } else {\n+          \/\/ Skipping the current known-unmarked obj\n+          HeapWord* next_live_addr = find_next_live_addr(cur_addr + obj_size, top);\n+          if (dead_spacer.insert_deadspace(cur_addr, next_live_addr)) {\n+            \/\/ Register space for the filler obj\n+            alloc(pointer_delta(next_live_addr, cur_addr));\n+          } else {\n+            if (!record_first_dead_done) {\n+              record_first_dead(i, cur_addr);\n+              record_first_dead_done = true;\n+            }\n+            *(HeapWord**)cur_addr = next_live_addr;\n+          }\n+          cur_addr = next_live_addr;\n+        }\n+      }\n+\n+      if (!record_first_dead_done) {\n+        record_first_dead(i, top);\n+      }\n+    }\n+  }\n@@ -149,4 +296,18 @@\n-void GenMarkSweep::deallocate_stacks() {\n-  if (_preserved_count_max != 0) {\n-    DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n-    young_gen->reset_scratch();\n+  void phase3_adjust_pointers() {\n+    for (uint i = 0; i < _num_spaces; ++i) {\n+      ContiguousSpace* space = get_space(i);\n+      HeapWord* cur_addr = space->bottom();\n+      HeapWord* const top = space->top();\n+      HeapWord* const first_dead = get_first_dead(i);\n+\n+      while (cur_addr < top) {\n+        prefetch_write_scan(cur_addr);\n+        if (cur_addr < first_dead || cast_to_oop(cur_addr)->is_gc_marked()) {\n+          size_t size = MarkSweep::adjust_pointers(cast_to_oop(cur_addr));\n+          cur_addr += size;\n+        } else {\n+          assert(*(HeapWord**)cur_addr > cur_addr, \"forward progress\");\n+          cur_addr = *(HeapWord**)cur_addr;\n+        }\n+      }\n+    }\n@@ -155,4 +316,28 @@\n-  _preserved_overflow_stack_set.reclaim();\n-  _marking_stack.clear();\n-  _objarray_stack.clear(true);\n-}\n+  void phase4_compact() {\n+    for (uint i = 0; i < _num_spaces; ++i) {\n+      ContiguousSpace* space = get_space(i);\n+      HeapWord* cur_addr = space->bottom();\n+      HeapWord* top = space->top();\n+\n+      \/\/ Check if the first obj inside this space is forwarded.\n+      if (!cast_to_oop(cur_addr)->is_forwarded()) {\n+        \/\/ Jump over consecutive (in-place) live-objs-chunk\n+        cur_addr = get_first_dead(i);\n+      }\n+\n+      while (cur_addr < top) {\n+        if (!cast_to_oop(cur_addr)->is_forwarded()) {\n+          cur_addr = *(HeapWord**) cur_addr;\n+          continue;\n+        }\n+        cur_addr += relocate(cur_addr);\n+      }\n+\n+      \/\/ Reset top and unused memory\n+      space->set_top(get_compaction_top(i));\n+      if (ZapUnusedHeapArea) {\n+        space->mangle_unused_area();\n+      }\n+    }\n+  }\n+};\n@@ -160,1 +345,1 @@\n-void GenMarkSweep::mark_sweep_phase1(bool clear_all_softrefs) {\n+void GenMarkSweep::phase1_mark(bool clear_all_softrefs) {\n@@ -244,0 +429,2 @@\n+void GenMarkSweep::invoke_at_safepoint(bool clear_all_softrefs) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n@@ -245,3 +432,6 @@\n-void GenMarkSweep::mark_sweep_phase2() {\n-  \/\/ Now all live objects are marked, compute the new object addresses.\n-  GCTraceTime(Info, gc, phases) tm(\"Phase 2: Compute new object addresses\", _gc_timer);\n+  SerialHeap* gch = SerialHeap::heap();\n+#ifdef ASSERT\n+  if (gch->soft_ref_policy()->should_clear_all_soft_refs()) {\n+    assert(clear_all_softrefs, \"Policy should have been checked earlier\");\n+  }\n+#endif\n@@ -249,2 +439,1 @@\n-  SerialHeap::heap()->prepare_for_compaction();\n-}\n+  gch->trace_heap_before_gc(_gc_tracer);\n@@ -252,4 +441,19 @@\n-class GenAdjustPointersClosure: public SerialHeap::GenClosure {\n-public:\n-  void do_generation(Generation* gen) {\n-    gen->adjust_pointers();\n+  \/\/ Increment the invocation count\n+  _total_invocations++;\n+\n+  \/\/ Capture used regions for each generation that will be\n+  \/\/ subject to collection, so that card table adjustments can\n+  \/\/ be made intelligently (see clear \/ invalidate further below).\n+  gch->save_used_regions();\n+\n+  allocate_stacks();\n+\n+  phase1_mark(clear_all_softrefs);\n+\n+  Compacter compacter{gch};\n+\n+  {\n+    \/\/ Now all live objects are marked, compute the new object addresses.\n+    GCTraceTime(Info, gc, phases) tm(\"Phase 2: Compute new object addresses\", _gc_timer);\n+\n+    compacter.phase2_calculate_new_addr();\n@@ -257,1 +461,0 @@\n-};\n@@ -259,2 +462,18 @@\n-void GenMarkSweep::mark_sweep_phase3() {\n-  SerialHeap* gch = SerialHeap::heap();\n+  \/\/ Don't add any more derived pointers during phase3\n+#if COMPILER2_OR_JVMCI\n+  assert(DerivedPointerTable::is_active(), \"Sanity\");\n+  DerivedPointerTable::set_active(false);\n+#endif\n+\n+  {\n+    \/\/ Adjust the pointers to reflect the new locations\n+    GCTraceTime(Info, gc, phases) tm(\"Phase 3: Adjust pointers\", gc_timer());\n+\n+    ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_adjust);\n+\n+    CodeBlobToOopClosure code_closure(&adjust_pointer_closure, CodeBlobToOopClosure::FixRelocations);\n+    gch->process_roots(SerialHeap::SO_AllCodeCache,\n+                       &adjust_pointer_closure,\n+                       &adjust_cld_closure,\n+                       &adjust_cld_closure,\n+                       &code_closure);\n@@ -262,2 +481,1 @@\n-  \/\/ Adjust the pointers to reflect the new locations\n-  GCTraceTime(Info, gc, phases) tm(\"Phase 3: Adjust pointers\", gc_timer());\n+    WeakProcessor::oops_do(&adjust_pointer_closure);\n@@ -265,1 +483,3 @@\n-  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_adjust);\n+    adjust_marks();\n+    compacter.phase3_adjust_pointers();\n+  }\n@@ -267,6 +487,3 @@\n-  CodeBlobToOopClosure code_closure(&adjust_pointer_closure, CodeBlobToOopClosure::FixRelocations);\n-  gch->process_roots(SerialHeap::SO_AllCodeCache,\n-                     &adjust_pointer_closure,\n-                     &adjust_cld_closure,\n-                     &adjust_cld_closure,\n-                     &code_closure);\n+  {\n+    \/\/ All pointers are now adjusted, move objects accordingly\n+    GCTraceTime(Info, gc, phases) tm(\"Phase 4: Move objects\", _gc_timer);\n@@ -274,1 +491,2 @@\n-  gch->gen_process_weak_roots(&adjust_pointer_closure);\n+    compacter.phase4_compact();\n+  }\n@@ -276,3 +494,23 @@\n-  adjust_marks();\n-  GenAdjustPointersClosure blk;\n-  gch->generation_iterate(&blk, true);\n+  restore_marks();\n+\n+  \/\/ Set saved marks for allocation profiler (and other things? -- dld)\n+  \/\/ (Should this be in general part?)\n+  gch->save_marks();\n+\n+  deallocate_stacks();\n+\n+  MarkSweep::_string_dedup_requests->flush();\n+\n+  bool is_young_gen_empty = (gch->young_gen()->used() == 0);\n+  gch->rem_set()->maintain_old_to_young_invariant(gch->old_gen(), is_young_gen_empty);\n+\n+  gch->prune_scavengable_nmethods();\n+\n+  \/\/ Update heap occupancy information which is used as\n+  \/\/ input to soft ref clearing policy at the next gc.\n+  Universe::heap()->update_capacity_and_used_at_gc();\n+\n+  \/\/ Signal that we have completed a visit to all live objects.\n+  Universe::heap()->record_whole_heap_examined_timestamp();\n+\n+  gch->trace_heap_after_gc(_gc_tracer);\n@@ -281,4 +519,10 @@\n-class GenCompactClosure: public SerialHeap::GenClosure {\n-public:\n-  void do_generation(Generation* gen) {\n-    gen->compact();\n+void GenMarkSweep::allocate_stacks() {\n+  void* scratch = nullptr;\n+  size_t num_words;\n+  DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n+  young_gen->contribute_scratch(scratch, num_words);\n+\n+  if (scratch != nullptr) {\n+    _preserved_count_max = num_words * HeapWordSize \/ sizeof(PreservedMark);\n+  } else {\n+    _preserved_count_max = 0;\n@@ -286,1 +530,0 @@\n-};\n@@ -288,3 +531,5 @@\n-void GenMarkSweep::mark_sweep_phase4() {\n-  \/\/ All pointers are now adjusted, move objects accordingly\n-  GCTraceTime(Info, gc, phases) tm(\"Phase 4: Move objects\", _gc_timer);\n+  _preserved_marks = (PreservedMark*)scratch;\n+  _preserved_count = 0;\n+\n+  _preserved_overflow_stack_set.init(1);\n+}\n@@ -292,2 +537,9 @@\n-  GenCompactClosure blk;\n-  SerialHeap::heap()->generation_iterate(&blk, true);\n+void GenMarkSweep::deallocate_stacks() {\n+  if (_preserved_count_max != 0) {\n+    DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n+    young_gen->reset_scratch();\n+  }\n+\n+  _preserved_overflow_stack_set.reclaim();\n+  _marking_stack.clear();\n+  _objarray_stack.clear(true);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":352,"deletions":100,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-\n@@ -37,7 +36,1 @@\n-  static void mark_sweep_phase1(bool clear_all_softrefs);\n-  \/\/ Calculate new addresses\n-  static void mark_sweep_phase2();\n-  \/\/ Update pointers\n-  static void mark_sweep_phase3();\n-  \/\/ Move objects to new positions\n-  static void mark_sweep_phase4();\n+  static void phase1_mark(bool clear_all_softrefs);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -176,12 +176,0 @@\n-class GenerationBlockSizeClosure : public SpaceClosure {\n- public:\n-  const HeapWord* _p;\n-  size_t size;\n-  virtual void do_space(Space* s) {\n-    if (size == 0 && s->is_in_reserved(_p)) {\n-      size = s->block_size(_p);\n-    }\n-  }\n-  GenerationBlockSizeClosure(const HeapWord* p) { _p = p; size = 0; }\n-};\n-\n@@ -221,31 +209,0 @@\n-\n-void Generation::prepare_for_compaction(CompactPoint* cp) {\n-  \/\/ Generic implementation, can be specialized\n-  ContiguousSpace* space = first_compaction_space();\n-  while (space != nullptr) {\n-    space->prepare_for_compaction(cp);\n-    space = space->next_compaction_space();\n-  }\n-}\n-\n-class AdjustPointersClosure: public SpaceClosure {\n- public:\n-  void do_space(Space* sp) {\n-    sp->adjust_pointers();\n-  }\n-};\n-\n-void Generation::adjust_pointers() {\n-  \/\/ Note that this is done over all spaces, not just the compactible\n-  \/\/ ones.\n-  AdjustPointersClosure blk;\n-  space_iterate(&blk, true);\n-}\n-\n-void Generation::compact() {\n-  ContiguousSpace* sp = first_compaction_space();\n-  while (sp != nullptr) {\n-    sp->compact();\n-    sp = sp->next_compaction_space();\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-class CompactPoint;\n+\n@@ -289,7 +289,0 @@\n-  \/\/ Mark sweep support phase2\n-  virtual void prepare_for_compaction(CompactPoint* cp);\n-  \/\/ Mark sweep support phase3\n-  virtual void adjust_pointers();\n-  \/\/ Mark sweep support phase4\n-  virtual void compact();\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-  \/\/ Accessing spaces\n-  TenuredSpace* space() const { return _the_space; }\n@@ -88,0 +86,2 @@\n+  TenuredSpace* space() const { return _the_space; }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -561,0 +561,1 @@\n+  static uint count = 0;\n@@ -562,2 +563,5 @@\n-    GCTraceTime(Info, gc) tm(before ? \"Heap Dump (before full gc)\" : \"Heap Dump (after full gc)\", timer);\n-    HeapDumper::dump_heap();\n+    if (FullGCHeapDumpLimit == 0 || count < FullGCHeapDumpLimit) {\n+      GCTraceTime(Info, gc) tm(before ? \"Heap Dump (before full gc)\" : \"Heap Dump (after full gc)\", timer);\n+      HeapDumper::dump_heap();\n+      count++;\n+    }\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  char _name[DEFAULT_CACHE_LINE_SIZE - sizeof(FreeListConfig*)];  \/\/ Use name as padding.\n+  char _name[DEFAULT_PADDING_SIZE - sizeof(FreeListConfig*)];  \/\/ Use name as padding.\n@@ -115,1 +115,1 @@\n-  Type Name; DEFINE_PAD_MINUS_SIZE(Id, DEFAULT_CACHE_LINE_SIZE, sizeof(Type))\n+  Type Name; DEFINE_PAD_MINUS_SIZE(Id, DEFAULT_PADDING_SIZE, sizeof(Type))\n","filename":"src\/hotspot\/share\/gc\/shared\/freeListAllocator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -411,5 +411,0 @@\n-  product(uint, AdaptiveSizePolicyCollectionCostMargin, 50,                 \\\n-          \"If collection costs are within margin, reduce both by full \"     \\\n-          \"delta\")                                                          \\\n-          range(0, 100)                                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -716,4 +716,0 @@\n-void GenCollectedHeap::gen_process_weak_roots(OopClosure* root_closure) {\n-  WeakProcessor::oops_do(root_closure);\n-}\n-\n@@ -914,9 +910,0 @@\n-#if INCLUDE_SERIALGC\n-void GenCollectedHeap::prepare_for_compaction() {\n-  \/\/ Start by compacting into same gen.\n-  CompactPoint cp(_old_gen);\n-  _old_gen->prepare_for_compaction(&cp);\n-  _young_gen->prepare_for_compaction(&cp);\n-}\n-#endif \/\/ INCLUDE_SERIALGC\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -295,5 +295,0 @@\n-  \/\/ Apply \"root_closure\" to all the weak roots of the system.\n-  \/\/ These include JNI weak roots, string table,\n-  \/\/ and referents of reachable weak refs.\n-  void gen_process_weak_roots(OopClosure* root_closure);\n-\n@@ -343,7 +338,0 @@\n-#if INCLUDE_SERIALGC\n-  \/\/ For use by mark-sweep.  As implemented, mark-sweep-compact is global\n-  \/\/ in an essential way: compaction is performed across generations, by\n-  \/\/ iterating over spaces.\n-  void prepare_for_compaction();\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -96,7 +96,1 @@\n-  JVMFlag::Error status = JVMFlag::SUCCESS;\n-\n-  {\n-    status = MinMaxPLABSizeBounds(\"OldPLABSize\", value, verbose);\n-  }\n-\n-  return status;\n+  return MinMaxPLABSizeBounds(\"OldPLABSize\", value, verbose);\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, 0);\n@@ -96,1 +96,1 @@\n-  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, 4 * sizeof(size_t));\n+  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_PADDING_SIZE, 4 * sizeof(size_t));\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/prefetch.inline.hpp\"\n@@ -44,4 +43,0 @@\n-#if INCLUDE_SERIALGC\n-#include \"gc\/serial\/serialBlockOffsetTable.inline.hpp\"\n-#include \"gc\/serial\/defNewGeneration.hpp\"\n-#endif\n@@ -50,1 +45,0 @@\n-  _compaction_top(nullptr),\n@@ -62,2 +56,1 @@\n-                                 bool mangle_space)\n-{\n+                                 bool mangle_space) {\n@@ -73,1 +66,0 @@\n-  set_compaction_top(bottom);\n@@ -83,5 +75,0 @@\n-  _compaction_top = bottom();\n-}\n-\n-bool ContiguousSpace::is_free_block(const HeapWord* p) const {\n-  return p >= _top;\n@@ -118,224 +105,0 @@\n-HeapWord* ContiguousSpace::forward(oop q, size_t size,\n-                                    CompactPoint* cp, HeapWord* compact_top) {\n-  \/\/ q is alive\n-  \/\/ First check if we should switch compaction space\n-  assert(this == cp->space, \"'this' should be current compaction space.\");\n-  size_t compaction_max_size = pointer_delta(end(), compact_top);\n-  while (size > compaction_max_size) {\n-    \/\/ switch to next compaction space\n-    cp->space->set_compaction_top(compact_top);\n-    cp->space = cp->space->next_compaction_space();\n-    if (cp->space == nullptr) {\n-      cp->gen = GenCollectedHeap::heap()->young_gen();\n-      assert(cp->gen != nullptr, \"compaction must succeed\");\n-      cp->space = cp->gen->first_compaction_space();\n-      assert(cp->space != nullptr, \"generation must have a first compaction space\");\n-    }\n-    compact_top = cp->space->bottom();\n-    cp->space->set_compaction_top(compact_top);\n-    compaction_max_size = pointer_delta(cp->space->end(), compact_top);\n-  }\n-\n-  \/\/ store the forwarding pointer into the mark word\n-  if (cast_from_oop<HeapWord*>(q) != compact_top) {\n-    q->forward_to(cast_to_oop(compact_top));\n-    assert(q->is_gc_marked(), \"encoding the pointer should preserve the mark\");\n-  } else {\n-    \/\/ if the object isn't moving we can just set the mark to the default\n-    \/\/ mark and handle it specially later on.\n-    q->init_mark();\n-    assert(!q->is_forwarded(), \"should not be forwarded\");\n-  }\n-\n-  compact_top += size;\n-\n-  \/\/ We need to update the offset table so that the beginnings of objects can be\n-  \/\/ found during scavenge.  Note that we are updating the offset table based on\n-  \/\/ where the object will be once the compaction phase finishes.\n-  cp->space->update_for_block(compact_top - size, compact_top);\n-  return compact_top;\n-}\n-\n-#if INCLUDE_SERIALGC\n-\n-void ContiguousSpace::prepare_for_compaction(CompactPoint* cp) {\n-  \/\/ Compute the new addresses for the live objects and store it in the mark\n-  \/\/ Used by universe::mark_sweep_phase2()\n-\n-  \/\/ We're sure to be here before any objects are compacted into this\n-  \/\/ space, so this is a good time to initialize this:\n-  set_compaction_top(bottom());\n-\n-  if (cp->space == nullptr) {\n-    assert(cp->gen != nullptr, \"need a generation\");\n-    assert(cp->gen->first_compaction_space() == this, \"just checking\");\n-    cp->space = cp->gen->first_compaction_space();\n-    cp->space->set_compaction_top(cp->space->bottom());\n-  }\n-\n-  HeapWord* compact_top = cp->space->compaction_top(); \/\/ This is where we are currently compacting to.\n-\n-  DeadSpacer dead_spacer(this);\n-\n-  HeapWord*  end_of_live = bottom();  \/\/ One byte beyond the last byte of the last live object.\n-  HeapWord*  first_dead = nullptr; \/\/ The first dead object.\n-\n-  const intx interval = PrefetchScanIntervalInBytes;\n-\n-  HeapWord* cur_obj = bottom();\n-  HeapWord* scan_limit = top();\n-\n-  while (cur_obj < scan_limit) {\n-    if (cast_to_oop(cur_obj)->is_gc_marked()) {\n-      \/\/ prefetch beyond cur_obj\n-      Prefetch::write(cur_obj, interval);\n-      size_t size = cast_to_oop(cur_obj)->size();\n-      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top);\n-      cur_obj += size;\n-      end_of_live = cur_obj;\n-    } else {\n-      \/\/ run over all the contiguous dead objects\n-      HeapWord* end = cur_obj;\n-      do {\n-        \/\/ prefetch beyond end\n-        Prefetch::write(end, interval);\n-        end += cast_to_oop(end)->size();\n-      } while (end < scan_limit && !cast_to_oop(end)->is_gc_marked());\n-\n-      \/\/ see if we might want to pretend this object is alive so that\n-      \/\/ we don't have to compact quite as often.\n-      if (cur_obj == compact_top && dead_spacer.insert_deadspace(cur_obj, end)) {\n-        oop obj = cast_to_oop(cur_obj);\n-        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top);\n-        end_of_live = end;\n-      } else {\n-        \/\/ otherwise, it really is a free region.\n-\n-        \/\/ cur_obj is a pointer to a dead object. Use this dead memory to store a pointer to the next live object.\n-        *(HeapWord**)cur_obj = end;\n-\n-        \/\/ see if this is the first dead region.\n-        if (first_dead == nullptr) {\n-          first_dead = cur_obj;\n-        }\n-      }\n-\n-      \/\/ move on to the next object\n-      cur_obj = end;\n-    }\n-  }\n-\n-  assert(cur_obj == scan_limit, \"just checking\");\n-  _end_of_live = end_of_live;\n-  if (first_dead != nullptr) {\n-    _first_dead = first_dead;\n-  } else {\n-    _first_dead = end_of_live;\n-  }\n-\n-  \/\/ save the compaction_top of the compaction space.\n-  cp->space->set_compaction_top(compact_top);\n-}\n-\n-void ContiguousSpace::adjust_pointers() {\n-  \/\/ Check first is there is any work to do.\n-  if (used() == 0) {\n-    return;   \/\/ Nothing to do.\n-  }\n-\n-  \/\/ adjust all the interior pointers to point at the new locations of objects\n-  \/\/ Used by MarkSweep::mark_sweep_phase3()\n-\n-  HeapWord* cur_obj = bottom();\n-  HeapWord* const end_of_live = _end_of_live;  \/\/ Established by prepare_for_compaction().\n-  HeapWord* const first_dead = _first_dead;    \/\/ Established by prepare_for_compaction().\n-\n-  assert(first_dead <= end_of_live, \"Stands to reason, no?\");\n-\n-  const intx interval = PrefetchScanIntervalInBytes;\n-\n-  debug_only(HeapWord* prev_obj = nullptr);\n-  while (cur_obj < end_of_live) {\n-    Prefetch::write(cur_obj, interval);\n-    if (cur_obj < first_dead || cast_to_oop(cur_obj)->is_gc_marked()) {\n-      \/\/ cur_obj is alive\n-      \/\/ point all the oops to the new location\n-      size_t size = MarkSweep::adjust_pointers(cast_to_oop(cur_obj));\n-      debug_only(prev_obj = cur_obj);\n-      cur_obj += size;\n-    } else {\n-      debug_only(prev_obj = cur_obj);\n-      \/\/ cur_obj is not a live object, instead it points at the next live object\n-      cur_obj = *(HeapWord**)cur_obj;\n-      assert(cur_obj > prev_obj, \"we should be moving forward through memory, cur_obj: \" PTR_FORMAT \", prev_obj: \" PTR_FORMAT, p2i(cur_obj), p2i(prev_obj));\n-    }\n-  }\n-\n-  assert(cur_obj == end_of_live, \"just checking\");\n-}\n-\n-void ContiguousSpace::compact() {\n-  \/\/ Copy all live objects to their new location\n-  \/\/ Used by MarkSweep::mark_sweep_phase4()\n-\n-  verify_up_to_first_dead(this);\n-\n-  HeapWord* const start = bottom();\n-  HeapWord* const end_of_live = _end_of_live;\n-\n-  assert(_first_dead <= end_of_live, \"Invariant. _first_dead: \" PTR_FORMAT \" <= end_of_live: \" PTR_FORMAT, p2i(_first_dead), p2i(end_of_live));\n-  if (_first_dead == end_of_live && (start == end_of_live || !cast_to_oop(start)->is_gc_marked())) {\n-    \/\/ Nothing to compact. The space is either empty or all live object should be left in place.\n-    clear_empty_region(this);\n-    return;\n-  }\n-\n-  const intx scan_interval = PrefetchScanIntervalInBytes;\n-  const intx copy_interval = PrefetchCopyIntervalInBytes;\n-\n-  assert(start < end_of_live, \"bottom: \" PTR_FORMAT \" should be < end_of_live: \" PTR_FORMAT, p2i(start), p2i(end_of_live));\n-  HeapWord* cur_obj = start;\n-  if (_first_dead > cur_obj && !cast_to_oop(cur_obj)->is_gc_marked()) {\n-    \/\/ All object before _first_dead can be skipped. They should not be moved.\n-    \/\/ A pointer to the first live object is stored at the memory location for _first_dead.\n-    cur_obj = *(HeapWord**)(_first_dead);\n-  }\n-\n-  debug_only(HeapWord* prev_obj = nullptr);\n-  while (cur_obj < end_of_live) {\n-    if (!cast_to_oop(cur_obj)->is_forwarded()) {\n-      debug_only(prev_obj = cur_obj);\n-      \/\/ The first word of the dead object contains a pointer to the next live object or end of space.\n-      cur_obj = *(HeapWord**)cur_obj;\n-      assert(cur_obj > prev_obj, \"we should be moving forward through memory\");\n-    } else {\n-      \/\/ prefetch beyond q\n-      Prefetch::read(cur_obj, scan_interval);\n-\n-      \/\/ size and destination\n-      size_t size = cast_to_oop(cur_obj)->size();\n-      HeapWord* compaction_top = cast_from_oop<HeapWord*>(cast_to_oop(cur_obj)->forwardee());\n-\n-      \/\/ prefetch beyond compaction_top\n-      Prefetch::write(compaction_top, copy_interval);\n-\n-      \/\/ copy object and reinit its mark\n-      assert(cur_obj != compaction_top, \"everything in this pass should be moving\");\n-      Copy::aligned_conjoint_words(cur_obj, compaction_top, size);\n-      oop new_obj = cast_to_oop(compaction_top);\n-\n-      ContinuationGCSupport::transform_stack_chunk(new_obj);\n-\n-      new_obj->init_mark();\n-      assert(new_obj->klass() != nullptr, \"should have a class\");\n-\n-      debug_only(prev_obj = cur_obj);\n-      cur_obj += size;\n-    }\n-  }\n-\n-  clear_empty_region(this);\n-}\n-\n-#endif \/\/ INCLUDE_SERIALGC\n-\n@@ -484,4 +247,0 @@\n-void TenuredSpace::update_for_block(HeapWord* start, HeapWord* end) {\n-  _offsets.update_for_block(start, end);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":1,"deletions":242,"binary":false,"changes":243,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-class FilteringClosure;\n@@ -88,6 +87,0 @@\n-  \/\/ Returns true if this object has been allocated since a\n-  \/\/ generation's \"save_marks\" call.\n-  bool obj_allocated_since_save_marks(const oop obj) const {\n-    return cast_from_oop<HeapWord*>(obj) >= saved_mark_word();\n-  }\n-\n@@ -137,3 +130,0 @@\n-  \/\/ Returns true iff the given block is not allocated.\n-  virtual bool is_free_block(const HeapWord* p) const = 0;\n-\n@@ -187,6 +177,0 @@\n-#if INCLUDE_SERIALGC\n-  \/\/ Mark-sweep-compact support: all spaces can update pointers to objects\n-  \/\/ moving as a part of compaction.\n-  virtual void adjust_pointers() = 0;\n-#endif\n-\n@@ -199,11 +183,0 @@\n-\/\/ A structure to represent a point at which objects are being copied\n-\/\/ during compaction.\n-class CompactPoint : public StackObj {\n-public:\n-  Generation* gen;\n-  ContiguousSpace* space;\n-\n-  CompactPoint(Generation* g = nullptr) :\n-    gen(g), space(nullptr) {}\n-};\n-\n@@ -218,1 +191,0 @@\n-  HeapWord* _compaction_top;\n@@ -221,5 +193,1 @@\n-  static inline void verify_up_to_first_dead(ContiguousSpace* space) NOT_DEBUG_RETURN;\n-\n-  static inline void clear_empty_region(ContiguousSpace* space);\n-\n- protected:\n+protected:\n@@ -230,8 +198,0 @@\n-  \/\/ Used during compaction.\n-  HeapWord* _first_dead;\n-  HeapWord* _end_of_live;\n-\n-  \/\/ This the function to invoke when an allocation of an object covering\n-  \/\/ \"start\" to \"end\" occurs to update other internal data structures.\n-  virtual void update_for_block(HeapWord* start, HeapWord* the_end) { }\n-\n@@ -257,11 +217,1 @@\n-  virtual void clear(bool mangle_space);\n-\n-  \/\/ Used temporarily during a compaction phase to hold the value\n-  \/\/ top should have when compaction is complete.\n-  HeapWord* compaction_top() const { return _compaction_top;    }\n-\n-  void set_compaction_top(HeapWord* value) {\n-    assert(value == nullptr || (value >= bottom() && value <= end()),\n-      \"should point inside space\");\n-    _compaction_top = value;\n-  }\n+  void clear(bool mangle_space);\n@@ -273,1 +223,1 @@\n-  virtual ContiguousSpace* next_compaction_space() const {\n+  ContiguousSpace* next_compaction_space() const {\n@@ -281,18 +231,0 @@\n-#if INCLUDE_SERIALGC\n-  \/\/ MarkSweep support phase2\n-\n-  \/\/ Start the process of compaction of the current space: compute\n-  \/\/ post-compaction addresses, and insert forwarding pointers.  The fields\n-  \/\/ \"cp->gen\" and \"cp->compaction_space\" are the generation and space into\n-  \/\/ which we are currently compacting.  This call updates \"cp\" as necessary,\n-  \/\/ and leaves the \"compaction_top\" of the final value of\n-  \/\/ \"cp->compaction_space\" up-to-date.  Offset tables may be updated in\n-  \/\/ this phase as if the final copy had occurred; if so, \"cp->threshold\"\n-  \/\/ indicates when the next such action should be taken.\n-  void prepare_for_compaction(CompactPoint* cp);\n-  \/\/ MarkSweep support phase3\n-  void adjust_pointers() override;\n-  \/\/ MarkSweep support phase4\n-  virtual void compact();\n-#endif \/\/ INCLUDE_SERIALGC\n-\n@@ -303,14 +235,0 @@\n-  \/\/ \"q\" is an object of the given \"size\" that should be forwarded;\n-  \/\/ \"cp\" names the generation (\"gen\") and containing \"this\" (which must\n-  \/\/ also equal \"cp->space\").  \"compact_top\" is where in \"this\" the\n-  \/\/ next object should be forwarded to.  If there is room in \"this\" for\n-  \/\/ the object, insert an appropriate forwarding pointer in \"q\".\n-  \/\/ If not, go to the next compaction space (there must\n-  \/\/ be one, since compaction must succeed -- we go to the first space of\n-  \/\/ the previous generation if necessary, updating \"cp\"), reset compact_top\n-  \/\/ and then forward.  In either case, returns the new value of \"compact_top\".\n-  \/\/ Invokes the \"update_for_block\" function of the then-current compaction\n-  \/\/ space.\n-  virtual HeapWord* forward(oop q, size_t size, CompactPoint* cp,\n-                    HeapWord* compact_top);\n-\n@@ -349,2 +267,0 @@\n-  bool is_free_block(const HeapWord* p) const override;\n-\n@@ -362,6 +278,0 @@\n-  \/\/ Compaction support\n-  void reset_after_compaction() {\n-    assert(compaction_top() >= bottom() && compaction_top() <= end(), \"should point inside space\");\n-    set_top(compaction_top());\n-  }\n-\n@@ -391,1 +301,0 @@\n-  HeapWord** end_addr() { return &_end; }\n@@ -422,2 +331,1 @@\n-  \/\/ MarkSweep support phase3\n-  void update_for_block(HeapWord* start, HeapWord* end) override;\n+  inline void update_for_block(HeapWord* start, HeapWord* end);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":4,"deletions":96,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/serial\/generation.hpp\"\n@@ -37,4 +36,0 @@\n-#if INCLUDE_SERIALGC\n-#include \"gc\/serial\/serialBlockOffsetTable.inline.hpp\"\n-#include \"gc\/serial\/markSweep.inline.hpp\"\n-#endif\n@@ -63,84 +58,2 @@\n-class DeadSpacer : StackObj {\n-  size_t _allowed_deadspace_words;\n-  bool _active;\n-  ContiguousSpace* _space;\n-\n-public:\n-  DeadSpacer(ContiguousSpace* space) : _allowed_deadspace_words(0), _space(space) {\n-    size_t ratio = _space->allowed_dead_ratio();\n-    _active = ratio > 0;\n-\n-    if (_active) {\n-      assert(!UseG1GC, \"G1 should not be using dead space\");\n-\n-      \/\/ We allow some amount of garbage towards the bottom of the space, so\n-      \/\/ we don't start compacting before there is a significant gain to be made.\n-      \/\/ Occasionally, we want to ensure a full compaction, which is determined\n-      \/\/ by the MarkSweepAlwaysCompactCount parameter.\n-      if ((MarkSweep::total_invocations() % MarkSweepAlwaysCompactCount) != 0) {\n-        _allowed_deadspace_words = (space->capacity() * ratio \/ 100) \/ HeapWordSize;\n-      } else {\n-        _active = false;\n-      }\n-    }\n-  }\n-\n-  bool insert_deadspace(HeapWord* dead_start, HeapWord* dead_end) {\n-    if (!_active) {\n-      return false;\n-    }\n-\n-    size_t dead_length = pointer_delta(dead_end, dead_start);\n-    if (_allowed_deadspace_words >= dead_length) {\n-      _allowed_deadspace_words -= dead_length;\n-      CollectedHeap::fill_with_object(dead_start, dead_length);\n-      oop obj = cast_to_oop(dead_start);\n-      obj->set_mark(obj->mark().set_marked());\n-\n-      assert(dead_length == obj->size(), \"bad filler object size\");\n-      log_develop_trace(gc, compaction)(\"Inserting object to dead space: \" PTR_FORMAT \", \" PTR_FORMAT \", \" SIZE_FORMAT \"b\",\n-          p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);\n-\n-      return true;\n-    } else {\n-      _active = false;\n-      return false;\n-    }\n-  }\n-};\n-\n-#ifdef ASSERT\n-inline void ContiguousSpace::verify_up_to_first_dead(ContiguousSpace* space) {\n-  HeapWord* cur_obj = space->bottom();\n-\n-  if (cur_obj < space->_end_of_live && space->_first_dead > cur_obj && !cast_to_oop(cur_obj)->is_gc_marked()) {\n-     \/\/ we have a chunk of the space which hasn't moved and we've reinitialized\n-     \/\/ the mark word during the previous pass, so we can't use is_gc_marked for\n-     \/\/ the traversal.\n-     HeapWord* prev_obj = nullptr;\n-\n-     while (cur_obj < space->_first_dead) {\n-       size_t size = cast_to_oop(cur_obj)->size();\n-       assert(!cast_to_oop(cur_obj)->is_gc_marked(), \"should be unmarked (special dense prefix handling)\");\n-       prev_obj = cur_obj;\n-       cur_obj += size;\n-     }\n-  }\n-}\n-#endif\n-\n-inline void ContiguousSpace::clear_empty_region(ContiguousSpace* space) {\n-  \/\/ Let's remember if we were empty before we did the compaction.\n-  bool was_empty = space->used_region().is_empty();\n-  \/\/ Reset space after compaction is complete\n-  space->reset_after_compaction();\n-  \/\/ We do this clear, below, since it has overloaded meanings for some\n-  \/\/ space subtypes.  For example, TenuredSpace's that were\n-  \/\/ compacted into will have had their offset table thresholds updated\n-  \/\/ continuously, but those that weren't need to have their thresholds\n-  \/\/ re-initialized.  Also mangles unused area for debugging.\n-  if (space->used_region().is_empty()) {\n-    if (!was_empty) space->clear(SpaceDecorator::Mangle);\n-  } else {\n-    if (ZapUnusedHeapArea) space->mangle_unused_area();\n-  }\n+inline void TenuredSpace::update_for_block(HeapWord* start, HeapWord* end) {\n+  _offsets.update_for_block(start, end);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":2,"deletions":89,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_PADDING_SIZE, 0);\n@@ -77,1 +77,1 @@\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile uint));\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(volatile uint));\n","filename":"src\/hotspot\/share\/gc\/shared\/taskTerminator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_PADDING_SIZE, 0);\n@@ -240,1 +240,1 @@\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(uint));\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(uint));\n@@ -248,1 +248,1 @@\n-  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(Age));\n+  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_PADDING_SIZE, sizeof(Age));\n@@ -399,1 +399,1 @@\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(E*));\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(E*));\n@@ -407,1 +407,1 @@\n-  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(uint) + sizeof(int));\n+  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_PADDING_SIZE, sizeof(uint) + sizeof(int));\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -102,4 +102,0 @@\n-  nonstatic_field(ContiguousSpace,            _compaction_top,                               HeapWord*)                             \\\n-  nonstatic_field(ContiguousSpace,            _first_dead,                                   HeapWord*)                             \\\n-  nonstatic_field(ContiguousSpace,            _end_of_live,                                  HeapWord*)                             \\\n-                                                                                                                                     \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2162,1 +2162,1 @@\n-              assert(c->is_Loop() && j == LoopNode::LoopBackControl || _phase->C->has_irreducible_loop() || has_never_branch(_phase->C->root()), \"\");\n+              assert((c->is_Loop() && j == LoopNode::LoopBackControl) || _phase->C->has_irreducible_loop() || has_never_branch(_phase->C->root()), \"\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -405,1 +405,1 @@\n-        assert(obj != fwd || _heap->cancelled_gc(), \"must be forwarded\");\n+        shenandoah_assert_forwarded_except(elem_ptr, obj, _heap->cancelled_gc());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        assert(obj != fwd || _heap->cancelled_gc(), \"must be forwarded\");\n+        shenandoah_assert_forwarded_except(p, obj, _heap->cancelled_gc());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetClone.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -962,0 +962,1 @@\n+      shenandoah_assert_not_in_cset_except(p, resolved, _heap->cancelled_gc());\n@@ -963,3 +964,0 @@\n-      assert(_heap->cancelled_gc() ||\n-             _mark_context->is_marked(resolved) && !_heap->in_collection_set(resolved),\n-             \"Sanity\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1361,0 +1361,3 @@\n+      if (ZapUnusedHeapArea) {\n+        SpaceMangler::mangle_region(MemRegion(r->top(), r->end()));\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-  _ref_proc_thread_locals->inc_encountered(type);\n+  _ref_proc_thread_locals[worker_id].inc_encountered(type);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-  \/\/ Use per-CPU shared small pages only if these pages occupy at most 3.125%\n-  \/\/ of the max heap size. Otherwise fall back to using a single shared small\n+  \/\/ Use per-CPU shared small pages only if these pages don't have a significant\n+  \/\/ heap overhead. Otherwise fall back to using a single shared small\n","filename":"src\/hotspot\/share\/gc\/z\/zHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+    _clear_all_soft_refs(false),\n@@ -127,0 +128,2 @@\n+  _clear_all_soft_refs = clear;\n+\n@@ -128,1 +131,0 @@\n-    log_info(gc, ref)(\"Clearing All SoftReferences\");\n@@ -441,0 +443,4 @@\n+  if (_clear_all_soft_refs) {\n+    log_info(gc, ref)(\"Clearing All SoftReferences\");\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  bool                 _clear_all_soft_refs;\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,1 +70,3 @@\n-  JfrCheckpointManager::on_unloading_classes();\n+  if (JfrRecorder::is_created() || JfrRecorder::is_started_on_commandline()) {\n+    JfrCheckpointManager::on_unloading_classes();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-                                                                        thread_local_buffer_prealloc_count,\n-                                                                        thread_local_buffer_prealloc_count)) {\n+                                                                           thread_local_buffer_prealloc_count,\n+                                                                           thread_local_buffer_prealloc_count)) {\n@@ -128,2 +128,2 @@\n-                                                                                        JFR_MSPACE_UNLIMITED_CACHE_SIZE,\n-                                                                                        virtual_thread_local_buffer_prealloc_count)) {\n+                                                                                           JFR_MSPACE_UNLIMITED_CACHE_SIZE,\n+                                                                                           virtual_thread_local_buffer_prealloc_count)) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  friend class JfrDeprecationManager;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-static bool current_epoch() {\n-  return _class_unload || _flushpoint;\n+static inline bool flushpoint() {\n+  return _flushpoint;\n@@ -73,1 +73,9 @@\n-static bool previous_epoch() {\n+static inline bool unloading() {\n+  return _class_unload;\n+}\n+\n+static inline bool current_epoch() {\n+  return flushpoint() || unloading();\n+}\n+\n+static inline bool previous_epoch() {\n@@ -77,2 +85,9 @@\n-static bool is_initial_typeset_for_chunk() {\n-  return _initial_type_set && !_class_unload;\n+template <typename T>\n+static inline bool used(const T* ptr) {\n+  assert(ptr != nullptr, \"invariant\");\n+  return current_epoch() ? USED_THIS_EPOCH(ptr) : USED_PREVIOUS_EPOCH(ptr);\n+}\n+\n+template <typename T>\n+static inline bool not_used(const T* ptr) {\n+  return !used(ptr);\n@@ -81,2 +96,5 @@\n-static bool is_complete() {\n-  return !_artifacts->has_klass_entries() && current_epoch();\n+template <typename T>\n+static void do_artifact(const T* ptr) {\n+  if (used(ptr)) {\n+    _subsystem_callback->do_artifact(ptr);\n+  }\n@@ -97,10 +115,15 @@\n-static const char* primitive_name(KlassPtr type_array_klass) {\n-  switch (type_array_klass->name()->base()[1]) {\n-    case JVM_SIGNATURE_BOOLEAN: return \"boolean\";\n-    case JVM_SIGNATURE_BYTE: return \"byte\";\n-    case JVM_SIGNATURE_CHAR: return \"char\";\n-    case JVM_SIGNATURE_SHORT: return \"short\";\n-    case JVM_SIGNATURE_INT: return \"int\";\n-    case JVM_SIGNATURE_LONG: return \"long\";\n-    case JVM_SIGNATURE_FLOAT: return \"float\";\n-    case JVM_SIGNATURE_DOUBLE: return \"double\";\n+template <typename T>\n+static traceid artifact_id(const T* ptr) {\n+  assert(ptr != nullptr, \"invariant\");\n+  return JfrTraceId::load_raw(ptr);\n+}\n+\n+template <typename T>\n+static traceid artifact_tag(const T* ptr, bool leakp) {\n+  assert(ptr != nullptr, \"invariant\");\n+  if (leakp) {\n+    if (IS_NOT_LEAKP(ptr)) {\n+      SET_LEAKP(ptr);\n+    }\n+    assert(IS_LEAKP(ptr), \"invariant\");\n+    return artifact_id(ptr);\n@@ -108,2 +131,5 @@\n-  assert(false, \"invalid type array klass\");\n-  return nullptr;\n+  if (not_used(ptr)) {\n+    SET_TRANSIENT(ptr);\n+  }\n+  assert(used(ptr), \"invariant\");\n+  return artifact_id(ptr);\n@@ -112,6 +138,7 @@\n-static Symbol* primitive_symbol(KlassPtr type_array_klass) {\n-  if (type_array_klass == nullptr) {\n-    \/\/ void.class\n-    static Symbol* const void_class_name = SymbolTable::probe(\"void\", 4);\n-    assert(void_class_name != nullptr, \"invariant\");\n-    return void_class_name;\n+static inline bool should_do_cld_klass(const Klass* klass, bool leakp) {\n+  return klass != nullptr && _artifacts->should_do_cld_klass(klass, leakp);\n+}\n+\n+static inline KlassPtr get_cld_klass(CldPtr cld, bool leakp) {\n+  if (cld == nullptr) {\n+    return nullptr;\n@@ -119,5 +146,16 @@\n-  const char* const primitive_type_str = primitive_name(type_array_klass);\n-  assert(primitive_type_str != nullptr, \"invariant\");\n-  Symbol* const primitive_type_sym = SymbolTable::probe(primitive_type_str, (int)strlen(primitive_type_str));\n-  assert(primitive_type_sym != nullptr, \"invariant\");\n-  return primitive_type_sym;\n+  assert(leakp ? IS_LEAKP(cld) : used(cld), \"invariant\");\n+  KlassPtr cld_klass = cld->class_loader_klass();\n+  if (cld_klass == nullptr) {\n+    return nullptr;\n+  }\n+  if (should_do_cld_klass(cld_klass, leakp)) {\n+    if (current_epoch()) {\n+      \/\/ This will enqueue the klass, which is important for\n+      \/\/ reachability when doing clear and reset at rotation.\n+      JfrTraceId::load(cld_klass);\n+    } else {\n+      artifact_tag(cld_klass, leakp);\n+    }\n+    return cld_klass;\n+  }\n+  return nullptr;\n@@ -126,4 +164,2 @@\n-template <typename T>\n-static traceid artifact_id(const T* ptr) {\n-  assert(ptr != nullptr, \"invariant\");\n-  return JfrTraceId::load_raw(ptr);\n+static inline CldPtr get_cld(ModPtr mod) {\n+  return mod != nullptr ? mod->loader_data() : nullptr;\n@@ -132,1 +168,1 @@\n-static traceid package_id(KlassPtr klass, bool leakp) {\n+static ClassLoaderData* get_cld(const Klass* klass) {\n@@ -134,6 +170,2 @@\n-  PkgPtr pkg_entry = klass->package();\n-  if (pkg_entry == nullptr) {\n-    return 0;\n-  }\n-  if (leakp) {\n-    SET_LEAKP(pkg_entry);\n+  if (klass->is_objArray_klass()) {\n+    klass = ObjArrayKlass::cast(klass)->bottom_klass();\n@@ -141,2 +173,19 @@\n-  \/\/ package implicitly tagged already\n-  return artifact_id(pkg_entry);\n+  return klass->is_non_strong_hidden() ? nullptr : klass->class_loader_data();\n+}\n+\n+static inline ModPtr get_module(PkgPtr pkg) {\n+  return pkg != nullptr ? pkg->module() : nullptr;\n+}\n+\n+static inline PkgPtr get_package(KlassPtr klass) {\n+  return klass != nullptr ? klass->package() : nullptr;\n+}\n+\n+static inline KlassPtr get_module_cld_klass(KlassPtr klass, bool leakp) {\n+  assert(klass != nullptr, \"invariant\");\n+  return get_cld_klass(get_cld(get_module(get_package(klass))), leakp);\n+}\n+\n+static traceid cld_id(CldPtr cld, bool leakp) {\n+  assert(cld != nullptr, \"invariant\");\n+  return artifact_tag(cld, leakp);\n@@ -147,2 +196,2 @@\n-  ModPtr module_entry = pkg->module();\n-  if (module_entry == nullptr) {\n+  ModPtr mod = get_module(pkg);\n+  if (mod == nullptr) {\n@@ -151,4 +200,3 @@\n-  if (leakp) {\n-    SET_LEAKP(module_entry);\n-  } else {\n-    SET_TRANSIENT(module_entry);\n+  CldPtr cld = get_cld(mod);\n+  if (cld != nullptr) {\n+    cld_id(cld, leakp);\n@@ -156,1 +204,12 @@\n-  return artifact_id(module_entry);\n+  return artifact_tag(mod, leakp);\n+}\n+\n+static traceid package_id(KlassPtr klass, bool leakp) {\n+  assert(klass != nullptr, \"invariant\");\n+  PkgPtr pkg = get_package(klass);\n+  if (pkg == nullptr) {\n+    return 0;\n+  }\n+  \/\/ Ensure module and its CLD gets tagged.\n+  module_id(pkg, leakp);\n+  return artifact_tag(pkg, leakp);\n@@ -165,10 +224,0 @@\n-static traceid cld_id(CldPtr cld, bool leakp) {\n-  assert(cld != nullptr, \"invariant\");\n-  if (leakp) {\n-    SET_LEAKP(cld);\n-  } else {\n-    SET_TRANSIENT(cld);\n-  }\n-  return artifact_id(cld);\n-}\n-\n@@ -186,4 +235,6 @@\n-static ClassLoaderData* get_cld(const Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  if (klass->is_objArray_klass()) {\n-    klass = ObjArrayKlass::cast(klass)->bottom_klass();\n+class PackageFieldSelector {\n+ public:\n+  typedef PkgPtr TypePtr;\n+  static TypePtr select(KlassPtr klass) {\n+    assert(klass != nullptr, \"invariant\");\n+    return klass->package();\n@@ -191,3 +242,63 @@\n-  if (klass->is_non_strong_hidden()) return nullptr;\n-  return klass->class_loader_data();\n-}\n+};\n+\n+class ModuleFieldSelector {\n+ public:\n+  typedef ModPtr TypePtr;\n+  static TypePtr select(KlassPtr klass) {\n+    assert(klass != nullptr, \"invariant\");\n+    PkgPtr pkg = klass->package();\n+    return pkg != nullptr ? pkg->module() : nullptr;\n+  }\n+};\n+\n+class KlassCldFieldSelector {\n+ public:\n+  typedef CldPtr TypePtr;\n+  static TypePtr select(KlassPtr klass) {\n+    assert(klass != nullptr, \"invariant\");\n+    return get_cld(klass);\n+  }\n+};\n+\n+class ModuleCldFieldSelector {\n+ public:\n+  typedef CldPtr TypePtr;\n+  static TypePtr select(KlassPtr klass) {\n+    assert(klass != nullptr, \"invariant\");\n+    ModPtr mod = ModuleFieldSelector::select(klass);\n+    return mod != nullptr ? mod->loader_data() : nullptr;\n+  }\n+};\n+\n+template <typename T>\n+class SerializePredicate {\n+  bool _class_unload;\n+ public:\n+  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n+  bool operator()(T const& value) {\n+    assert(value != nullptr, \"invariant\");\n+    return _class_unload ? _artifacts->should_do_unloading_artifact(value) : IS_NOT_SERIALIZED(value);\n+  }\n+};\n+\n+template <>\n+class SerializePredicate<const Klass*> {\n+  bool _class_unload;\n+public:\n+  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n+  bool operator()(const Klass* klass) {\n+    assert(klass != nullptr, \"invariant\");\n+    return _class_unload ? true : IS_NOT_SERIALIZED(klass);\n+  }\n+};\n+\n+template <>\n+class SerializePredicate<const Method*> {\n+  bool _class_unload;\n+public:\n+  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n+  bool operator()(const Method* method) {\n+    assert(method != nullptr, \"invariant\");\n+    return _class_unload ? true : METHOD_IS_NOT_SERIALIZED(method);\n+  }\n+};\n@@ -198,2 +309,0 @@\n-  SET_SERIALIZED(ptr);\n-  assert(IS_SERIALIZED(ptr), \"invariant\");\n@@ -203,0 +312,2 @@\n+  SET_SERIALIZED(ptr);\n+  assert(IS_SERIALIZED(ptr), \"invariant\");\n@@ -206,3 +317,19 @@\n- * In C++03, functions used as template parameters must have external linkage;\n- * this restriction was removed in C++11. Change back to \"static\" and\n- * rename functions when C++11 becomes available.\n+ ***********************    Klasses    *************************\n+ *\n+ * When we process a Klass, we need to process its transitive closure.\n+ *\n+ * This includes two branches:\n+ *\n+ * [1] Klass -> CLD -> class_loader_Klass\n+ * [2] Klass -> PackageEntry -> ModuleEntry -> CLD -> class_loader_Klass\n+ *\n+ *    A Klass viewed as this closure becomes a node in a binary tree:\n+ *\n+ *                           Klass\n+ *                             O\n+ *                            \/ \\\n+ *                           \/   \\\n+ *                      [1] O     O [2]\n+ *\n+ * We write the Klass and tag the artifacts in its closure (subtree)\n+ * using preorder traversal by recursing the class_loader_Klass(es).\n@@ -210,1 +337,0 @@\n- * The weird naming is an effort to decrease the risk of name clashes.\n@@ -213,1 +339,1 @@\n-static int write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp) {\n+static void do_write_klass(JfrCheckpointWriter* writer, CldPtr cld, KlassPtr klass, bool leakp) {\n@@ -218,1 +344,0 @@\n-  ClassLoaderData* cld = get_cld(klass);\n@@ -224,1 +349,26 @@\n-  return 1;\n+  if (!leakp) {\n+    set_serialized(klass);\n+  }\n+}\n+\n+static inline bool should_write_cld_klass(KlassPtr klass, bool leakp) {\n+  return klass != nullptr && (leakp || IS_NOT_SERIALIZED(klass));\n+}\n+\n+static void write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp, int& elements) {\n+  assert(elements >= 0, \"invariant\");\n+  ClassLoaderData* cld = get_cld(klass);\n+  do_write_klass(writer, cld, klass, leakp);\n+  ++elements;\n+  if (cld != nullptr) {\n+    \/\/ Write the klass for the direct cld.\n+    KlassPtr cld_klass = get_cld_klass(cld, leakp);\n+    if (should_write_cld_klass(cld_klass, leakp)) {\n+      write_klass(writer, cld_klass, leakp, elements);\n+    }\n+  }\n+  KlassPtr mod_klass = get_module_cld_klass(klass, leakp);\n+  if (should_write_cld_klass(mod_klass, leakp)) {\n+    \/\/ Write the klass for the module cld.\n+    write_klass(writer, mod_klass, leakp, elements);\n+  }\n@@ -227,0 +377,7 @@\n+\/*\n+ * In C++03, functions used as template parameters must have external linkage;\n+ * this restriction was removed in C++11. Change back to \"static\" and\n+ * rename functions when C++11 becomes available.\n+ *\n+ * The weird naming is an effort to decrease the risk of name clashes.\n+ *\/\n@@ -229,3 +386,4 @@\n-  KlassPtr klass = (KlassPtr)k;\n-  set_serialized(klass);\n-  return write_klass(writer, klass, false);\n+  KlassPtr klass = static_cast<KlassPtr>(k);\n+  int elements = 0;\n+  write_klass(writer, klass, false, elements);\n+  return elements;\n@@ -236,1 +394,1 @@\n-  KlassPtr klass = (KlassPtr)k;\n+  KlassPtr klass = static_cast<KlassPtr>(k);\n@@ -238,1 +396,3 @@\n-  return write_klass(writer, klass, true);\n+  int elements = 0;\n+  write_klass(writer, klass, true, elements);\n+  return elements;\n@@ -241,4 +401,1 @@\n-static bool is_implied(const Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  return klass->is_subclass_of(vmClasses::ClassLoader_klass()) || klass == vmClasses::Object_klass();\n-}\n+static int primitives_count = 9;\n@@ -246,5 +403,13 @@\n-static void do_klass(Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  assert(_flushpoint ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass), \"invariant\");\n-  assert(_subsystem_callback != nullptr, \"invariant\");\n-  _subsystem_callback->do_artifact(klass);\n+static const char* primitive_name(KlassPtr type_array_klass) {\n+  switch (type_array_klass->name()->base()[1]) {\n+    case JVM_SIGNATURE_BOOLEAN: return \"boolean\";\n+    case JVM_SIGNATURE_BYTE: return \"byte\";\n+    case JVM_SIGNATURE_CHAR: return \"char\";\n+    case JVM_SIGNATURE_SHORT: return \"short\";\n+    case JVM_SIGNATURE_INT: return \"int\";\n+    case JVM_SIGNATURE_LONG: return \"long\";\n+    case JVM_SIGNATURE_FLOAT: return \"float\";\n+    case JVM_SIGNATURE_DOUBLE: return \"double\";\n+  }\n+  assert(false, \"invalid type array klass\");\n+  return nullptr;\n@@ -253,0 +418,14 @@\n+static Symbol* primitive_symbol(KlassPtr type_array_klass) {\n+  if (type_array_klass == nullptr) {\n+    \/\/ void.class\n+    static Symbol* const void_class_name = SymbolTable::probe(\"void\", 4);\n+    assert(void_class_name != nullptr, \"invariant\");\n+    return void_class_name;\n+  }\n+  const char* const primitive_type_str = primitive_name(type_array_klass);\n+  assert(primitive_type_str != nullptr, \"invariant\");\n+  Symbol* const primitive_type_sym = SymbolTable::probe(primitive_type_str,\n+                                                        (int)strlen(primitive_type_str));\n+  assert(primitive_type_sym != nullptr, \"invariant\");\n+  return primitive_type_sym;\n+}\n@@ -274,42 +453,2 @@\n-static void do_loader_klass(const Klass* klass) {\n-  if (klass != nullptr && _artifacts->should_do_loader_klass(klass)) {\n-    if (_leakp_writer != nullptr) {\n-      SET_LEAKP(klass);\n-    }\n-    SET_TRANSIENT(klass);\n-    _subsystem_callback->do_artifact(klass);\n-  }\n-}\n-\n-static bool register_klass_unload(Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  return JfrKlassUnloading::on_unload(klass);\n-}\n-\n-static void do_unloading_klass(Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  assert(_subsystem_callback != nullptr, \"invariant\");\n-  if (register_klass_unload(klass)) {\n-    _subsystem_callback->do_artifact(klass);\n-    do_loader_klass(klass->class_loader_data()->class_loader_klass());\n-  }\n-}\n-\n-\/*\n- * Abstract klasses are filtered out unconditionally.\n- * If a klass is not yet initialized, i.e yet to run its <clinit>\n- * it is also filtered out so we don't accidentally\n- * trigger initialization.\n- *\/\n-static bool is_classloader_klass_allowed(const Klass* k) {\n-  assert(k != nullptr, \"invariant\");\n-  return !(k->is_abstract() || k->should_be_initialized());\n-}\n-\n-static void do_classloaders() {\n-  for (ClassHierarchyIterator iter(vmClasses::ClassLoader_klass()); !iter.done(); iter.next()) {\n-    Klass* subk = iter.klass();\n-    if (is_classloader_klass_allowed(subk)) {\n-      do_loader_klass(subk);\n-    }\n-  }\n+static bool is_initial_typeset_for_chunk() {\n+  return _initial_type_set && !unloading();\n@@ -318,2 +457,0 @@\n-static int primitives_count = 9;\n-\n@@ -326,12 +463,10 @@\n-  \/\/ Only write the primitive classes once per chunk.\n-  if (is_initial_typeset_for_chunk()) {\n-    write_primitive(_writer, Universe::boolArrayKlassObj());\n-    write_primitive(_writer, Universe::byteArrayKlassObj());\n-    write_primitive(_writer, Universe::charArrayKlassObj());\n-    write_primitive(_writer, Universe::shortArrayKlassObj());\n-    write_primitive(_writer, Universe::intArrayKlassObj());\n-    write_primitive(_writer, Universe::longArrayKlassObj());\n-    write_primitive(_writer, Universe::floatArrayKlassObj());\n-    write_primitive(_writer, Universe::doubleArrayKlassObj());\n-    write_primitive(_writer, nullptr); \/\/ void.class\n-  }\n+  assert(is_initial_typeset_for_chunk(), \"invariant\");\n+  write_primitive(_writer, Universe::boolArrayKlassObj());\n+  write_primitive(_writer, Universe::byteArrayKlassObj());\n+  write_primitive(_writer, Universe::charArrayKlassObj());\n+  write_primitive(_writer, Universe::shortArrayKlassObj());\n+  write_primitive(_writer, Universe::intArrayKlassObj());\n+  write_primitive(_writer, Universe::longArrayKlassObj());\n+  write_primitive(_writer, Universe::floatArrayKlassObj());\n+  write_primitive(_writer, Universe::doubleArrayKlassObj());\n+  write_primitive(_writer, nullptr); \/\/ void.class\n@@ -340,34 +475,5 @@\n-static void do_object() {\n-  SET_TRANSIENT(vmClasses::Object_klass());\n-  do_klass(vmClasses::Object_klass());\n-}\n-\n-static void do_klasses() {\n-  if (_class_unload) {\n-    ClassLoaderDataGraph::classes_unloading_do(&do_unloading_klass);\n-    return;\n-  }\n-  JfrTraceIdLoadBarrier::do_klasses(&do_klass, previous_epoch());\n-  do_classloaders();\n-  do_primitives();\n-  do_object();\n-}\n-\n-template <typename T>\n-static void do_previous_epoch_artifact(JfrArtifactClosure* callback, T* value) {\n-  assert(callback != nullptr, \"invariant\");\n-  assert(value != nullptr, \"invariant\");\n-  if (USED_PREVIOUS_EPOCH(value)) {\n-    callback->do_artifact(value);\n-  }\n-  if (IS_SERIALIZED(value)) {\n-    CLEAR_SERIALIZED(value);\n-  }\n-  assert(IS_NOT_SERIALIZED(value), \"invariant\");\n-}\n-\n-static void do_previous_epoch_klass(JfrArtifactClosure* callback, const Klass* value) {\n-  assert(callback != nullptr, \"invariant\");\n-  assert(value != nullptr, \"invariant\");\n-  if (USED_PREVIOUS_EPOCH(value)) {\n-    callback->do_artifact(value);\n+static void do_unloading_klass(Klass* klass) {\n+  assert(klass != nullptr, \"invariant\");\n+  assert(_subsystem_callback != nullptr, \"invariant\");\n+  if (JfrKlassUnloading::on_unload(klass)) {\n+    _subsystem_callback->do_artifact(klass);\n@@ -377,1 +483,1 @@\n-static void do_klass_on_clear(Klass* klass) {\n+static void do_klass(Klass* klass) {\n@@ -379,0 +485,1 @@\n+  assert(used(klass), \"invariant\");\n@@ -380,1 +487,1 @@\n-  do_previous_epoch_klass(_subsystem_callback, klass);\n+  _subsystem_callback->do_artifact(klass);\n@@ -383,7 +490,4 @@\n-static void do_loader_klass_on_clear(const Klass* klass) {\n-  if (klass != nullptr && _artifacts->should_do_loader_klass(klass)) {\n-    if (_leakp_writer != nullptr) {\n-      SET_LEAKP(klass);\n-    }\n-    SET_TRANSIENT(klass);\n-    do_previous_epoch_klass(_subsystem_callback, klass);\n+static void do_klasses() {\n+  if (unloading()) {\n+    ClassLoaderDataGraph::classes_unloading_do(&do_unloading_klass);\n+    return;\n@@ -391,8 +495,3 @@\n-}\n-\n-static void do_classloaders_on_clear() {\n-  for (ClassHierarchyIterator iter(vmClasses::ClassLoader_klass()); !iter.done(); iter.next()) {\n-    Klass* subk = iter.klass();\n-    if (is_classloader_klass_allowed(subk)) {\n-      do_loader_klass_on_clear(subk);\n-    }\n+  if (is_initial_typeset_for_chunk()) {\n+    \/\/ Only write the primitive classes once per chunk.\n+    do_primitives();\n@@ -400,0 +499,1 @@\n+  JfrTraceIdLoadBarrier::do_klasses(&do_klass, previous_epoch());\n@@ -402,3 +502,2 @@\n-static void do_object_on_clear() {\n-  SET_TRANSIENT(vmClasses::Object_klass());\n-  do_klass_on_clear(vmClasses::Object_klass());\n+static void do_klass_on_clear(Klass* klass) {\n+  do_artifact(klass);\n@@ -409,2 +508,0 @@\n-  do_classloaders_on_clear();\n-  do_object_on_clear();\n@@ -413,0 +510,1 @@\n+\/\/ KlassWriter.\n@@ -416,0 +514,2 @@\n+\n+\/\/ Klass registration.\n@@ -425,1 +525,1 @@\n-    return IS_LEAKP(klass) || is_implied(klass);\n+    return IS_LEAKP(klass);\n@@ -429,0 +529,1 @@\n+\/\/ KlassWriter for leakp. Only used during start or rotation, i.e. the previous epoch.\n@@ -433,0 +534,1 @@\n+\/\/ Composite KlassWriter with registration.\n@@ -437,1 +539,1 @@\n-static bool write_klasses() {\n+static void write_klasses() {\n@@ -441,1 +543,1 @@\n-  KlassWriter kw(_writer, _class_unload);\n+  KlassWriter kw(_writer, unloading());\n@@ -447,1 +549,1 @@\n-    LeakKlassWriter lkw(_leakp_writer, _class_unload);\n+    LeakKlassWriter lkw(_leakp_writer, unloading());\n@@ -458,3 +560,0 @@\n-  if (is_complete()) {\n-    return false;\n-  }\n@@ -462,1 +561,0 @@\n-  return true;\n@@ -465,1 +563,1 @@\n-static bool write_klasses_on_clear() {\n+static void write_klasses_on_clear() {\n@@ -470,1 +568,1 @@\n-  KlassWriter kw(_writer, _class_unload);\n+  KlassWriter kw(_writer, unloading());\n@@ -472,1 +570,1 @@\n-  LeakKlassWriter lkw(_leakp_writer, _class_unload);\n+  LeakKlassWriter lkw(_leakp_writer, unloading());\n@@ -477,3 +575,0 @@\n-  if (is_complete()) {\n-    return false;\n-  }\n@@ -481,1 +576,0 @@\n-  return true;\n@@ -484,0 +578,2 @@\n+\/***** Packages *****\/\n+\n@@ -497,1 +593,1 @@\n-  PkgPtr pkg = (PkgPtr)p;\n+  PkgPtr pkg = static_cast<PkgPtr>(p);\n@@ -504,1 +600,1 @@\n-  PkgPtr pkg = (PkgPtr)p;\n+  PkgPtr pkg = static_cast<PkgPtr>(p);\n@@ -509,16 +605,0 @@\n-static void do_package(PackageEntry* entry) {\n-  do_previous_epoch_artifact(_subsystem_callback, entry);\n-}\n-\n-static void do_packages() {\n-  ClassLoaderDataGraph::packages_do(&do_package);\n-}\n-\n-class PackageFieldSelector {\n- public:\n-  typedef PkgPtr TypePtr;\n-  static TypePtr select(KlassPtr klass) {\n-    assert(klass != nullptr, \"invariant\");\n-    return klass->package();\n-  }\n-};\n@@ -526,0 +606,1 @@\n+\/\/ PackageWriter.\n@@ -529,1 +610,3 @@\n-typedef CompositeFunctor<PkgPtr, PackageWriter, ClearArtifact<PkgPtr> > PackageWriterWithClear;\n+typedef JfrArtifactCallbackHost<PkgPtr, PackageWriter> PackageCallback;\n+\n+\/\/ PackageWriter used during flush or unloading i.e. the current epoch.\n@@ -531,1 +614,0 @@\n-typedef JfrArtifactCallbackHost<PkgPtr, PackageWriterWithClear> PackageCallback;\n@@ -533,0 +615,5 @@\n+\/\/ PackageWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n+typedef CompositeFunctor<PkgPtr, PackageWriter, ClearArtifact<PkgPtr> > PackageWriterWithClear;\n+typedef JfrArtifactCallbackHost<PkgPtr, PackageWriterWithClear> PackageClearCallback;\n+\n+\/\/ PackageWriter for leakp. Only used during start or rotation, i.e. the previous epoch.\n@@ -537,0 +624,1 @@\n+\/\/ Composite PackageWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n@@ -538,2 +626,0 @@\n-typedef KlassToFieldEnvelope<PackageFieldSelector, CompositePackageWriter> KlassCompositePackageWriter;\n-typedef KlassToFieldEnvelope<PackageFieldSelector, PackageWriterWithClear> KlassPackageWriterWithClear;\n@@ -541,1 +627,32 @@\n-typedef JfrArtifactCallbackHost<PkgPtr, CompositePackageWriterWithClear> CompositePackageCallback;\n+typedef JfrArtifactCallbackHost<PkgPtr, CompositePackageWriterWithClear> CompositePackageClearCallback;\n+\n+static void do_package(PackageEntry* pkg) {\n+  do_artifact(pkg);\n+}\n+\n+static void do_all_packages() {\n+  ClassLoaderDataGraph::packages_do(&do_package);\n+}\n+\n+static void do_all_packages(PackageWriter& pw) {\n+  do_all_packages();\n+  _artifacts->tally(pw);\n+}\n+\n+static void do_packages(PackageWriter& pw) {\n+  KlassPackageWriter kpw(&pw);\n+  _artifacts->iterate_klasses(kpw);\n+  _artifacts->tally(pw);\n+}\n+\n+static void write_packages_with_leakp(PackageWriter& pw) {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  LeakPackageWriter lpw(_leakp_writer, unloading());\n+  CompositePackageWriter cpw(&lpw, &pw);\n+  ClearArtifact<PkgPtr> clear;\n+  CompositePackageWriterWithClear cpwwc(&cpw, &clear);\n+  CompositePackageClearCallback callback(&_subsystem_callback, &cpwwc);\n+  do_all_packages(pw);\n+}\n@@ -545,2 +662,1 @@\n-  PackageWriter pw(_writer, _class_unload);\n-  KlassPackageWriter kpw(&pw);\n+  PackageWriter pw(_writer, unloading());\n@@ -548,2 +664,1 @@\n-    _artifacts->iterate_klasses(kpw);\n-    _artifacts->tally(pw);\n+    do_packages(pw);\n@@ -554,1 +669,0 @@\n-    _artifacts->iterate_klasses(kpw);\n@@ -557,11 +671,3 @@\n-    PackageCallback callback(&_subsystem_callback, &pwwc);\n-    do_packages();\n-  } else {\n-    LeakPackageWriter lpw(_leakp_writer, _class_unload);\n-    CompositePackageWriter cpw(&lpw, &pw);\n-    KlassCompositePackageWriter kcpw(&cpw);\n-    _artifacts->iterate_klasses(kcpw);\n-    ClearArtifact<PkgPtr> clear;\n-    CompositePackageWriterWithClear cpwwc(&cpw, &clear);\n-    CompositePackageCallback callback(&_subsystem_callback, &cpwwc);\n-    do_packages();\n+    PackageClearCallback callback(&_subsystem_callback, &pwwc);\n+    do_all_packages(pw);\n+    return;\n@@ -569,1 +675,1 @@\n-  _artifacts->tally(pw);\n+  write_packages_with_leakp(pw);\n@@ -576,11 +682,2 @@\n-  PackageWriter pw(_writer, _class_unload);\n-  KlassPackageWriter kpw(&pw);\n-  LeakPackageWriter lpw(_leakp_writer, _class_unload);\n-  CompositePackageWriter cpw(&lpw, &pw);\n-  KlassCompositePackageWriter kcpw(&cpw);\n-  _artifacts->iterate_klasses(kcpw);\n-  ClearArtifact<PkgPtr> clear;\n-  CompositePackageWriterWithClear cpwwc(&cpw, &clear);\n-  CompositePackageCallback callback(&_subsystem_callback, &cpwwc);\n-  do_packages();\n-  _artifacts->tally(pw);\n+  PackageWriter pw(_writer, unloading());\n+  write_packages_with_leakp(pw);\n@@ -589,0 +686,2 @@\n+\/***** Modules *****\/\n+\n@@ -602,1 +701,1 @@\n-  ModPtr mod = (ModPtr)m;\n+  ModPtr mod = static_cast<ModPtr>(m);\n@@ -609,1 +708,1 @@\n-  ModPtr mod = (ModPtr)m;\n+  ModPtr mod = static_cast<ModPtr>(m);\n@@ -614,18 +713,1 @@\n-static void do_module(ModuleEntry* entry) {\n-  do_previous_epoch_artifact(_subsystem_callback, entry);\n-}\n-\n-static void do_modules() {\n-  ClassLoaderDataGraph::modules_do(&do_module);\n-}\n-\n-class ModuleFieldSelector {\n- public:\n-  typedef ModPtr TypePtr;\n-  static TypePtr select(KlassPtr klass) {\n-    assert(klass != nullptr, \"invariant\");\n-    PkgPtr pkg = klass->package();\n-    return pkg != nullptr ? pkg->module() : nullptr;\n-  }\n-};\n-\n+\/\/ ModuleWriter.\n@@ -635,2 +717,3 @@\n-typedef CompositeFunctor<ModPtr, ModuleWriter, ClearArtifact<ModPtr> > ModuleWriterWithClear;\n-typedef JfrArtifactCallbackHost<ModPtr, ModuleWriterWithClear> ModuleCallback;\n+typedef JfrArtifactCallbackHost<ModPtr, ModuleWriter> ModuleCallback;\n+\n+\/\/ ModuleWriter used during flush or unloading i.e. the current epoch.\n@@ -639,0 +722,5 @@\n+\/\/ ModuleWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n+typedef CompositeFunctor<ModPtr, ModuleWriter, ClearArtifact<ModPtr> > ModuleWriterWithClear;\n+typedef JfrArtifactCallbackHost<ModPtr, ModuleWriterWithClear> ModuleClearCallback;\n+\n+\/\/ ModuleWriter for leakp. Only used during start or rotation, i.e. the previous epoch.\n@@ -643,0 +731,1 @@\n+\/\/ Composite ModuleWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n@@ -644,1 +733,0 @@\n-typedef KlassToFieldEnvelope<ModuleFieldSelector, CompositeModuleWriter> KlassCompositeModuleWriter;\n@@ -646,1 +734,32 @@\n-typedef JfrArtifactCallbackHost<ModPtr, CompositeModuleWriterWithClear> CompositeModuleCallback;\n+typedef JfrArtifactCallbackHost<ModPtr, CompositeModuleWriterWithClear> CompositeModuleClearCallback;\n+\n+static void do_module(ModuleEntry* mod) {\n+  do_artifact(mod);\n+}\n+\n+static void do_all_modules() {\n+  ClassLoaderDataGraph::modules_do(&do_module);\n+}\n+\n+static void do_all_modules(ModuleWriter& mw) {\n+  do_all_modules();\n+  _artifacts->tally(mw);\n+}\n+\n+static void do_modules(ModuleWriter& mw) {\n+  KlassModuleWriter kmw(&mw);\n+  _artifacts->iterate_klasses(kmw);\n+  _artifacts->tally(mw);\n+}\n+\n+static void write_modules_with_leakp(ModuleWriter& mw) {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  LeakModuleWriter lmw(_leakp_writer, unloading());\n+  CompositeModuleWriter cmw(&lmw, &mw);\n+  ClearArtifact<ModPtr> clear;\n+  CompositeModuleWriterWithClear cmwwc(&cmw, &clear);\n+  CompositeModuleClearCallback callback(&_subsystem_callback, &cmwwc);\n+  do_all_modules(mw);\n+}\n@@ -650,2 +769,1 @@\n-  ModuleWriter mw(_writer, _class_unload);\n-  KlassModuleWriter kmw(&mw);\n+  ModuleWriter mw(_writer, unloading());\n@@ -653,2 +771,1 @@\n-    _artifacts->iterate_klasses(kmw);\n-    _artifacts->tally(mw);\n+    do_modules(mw);\n@@ -659,1 +776,0 @@\n-    _artifacts->iterate_klasses(kmw);\n@@ -662,11 +778,3 @@\n-    ModuleCallback callback(&_subsystem_callback, &mwwc);\n-    do_modules();\n-  } else {\n-    LeakModuleWriter lmw(_leakp_writer, _class_unload);\n-    CompositeModuleWriter cmw(&lmw, &mw);\n-    KlassCompositeModuleWriter kcpw(&cmw);\n-    _artifacts->iterate_klasses(kcpw);\n-    ClearArtifact<ModPtr> clear;\n-    CompositeModuleWriterWithClear cmwwc(&cmw, &clear);\n-    CompositeModuleCallback callback(&_subsystem_callback, &cmwwc);\n-    do_modules();\n+    ModuleClearCallback callback(&_subsystem_callback, &mwwc);\n+    do_all_modules(mw);\n+    return;\n@@ -674,1 +782,1 @@\n-  _artifacts->tally(mw);\n+  write_modules_with_leakp(mw);\n@@ -681,11 +789,2 @@\n-  ModuleWriter mw(_writer, _class_unload);\n-  KlassModuleWriter kmw(&mw);\n-  LeakModuleWriter lmw(_leakp_writer, _class_unload);\n-  CompositeModuleWriter cmw(&lmw, &mw);\n-  KlassCompositeModuleWriter kcpw(&cmw);\n-  _artifacts->iterate_klasses(kcpw);\n-  ClearArtifact<ModPtr> clear;\n-  CompositeModuleWriterWithClear cmwwc(&cmw, &clear);\n-  CompositeModuleCallback callback(&_subsystem_callback, &cmwwc);\n-  do_modules();\n-  _artifacts->tally(mw);\n+  ModuleWriter mw(_writer, unloading());\n+  write_modules_with_leakp(mw);\n@@ -694,1 +793,3 @@\n-static int write_classloader(JfrCheckpointWriter* writer, CldPtr cld, bool leakp) {\n+\/***** ClassLoaderData - CLD *****\/\n+\n+static int write_cld(JfrCheckpointWriter* writer, CldPtr cld, bool leakp) {\n@@ -704,1 +805,1 @@\n-    assert(_class_unload ? true : IS_SERIALIZED(class_loader_klass), \"invariant\");\n+    assert(IS_SERIALIZED(class_loader_klass), \"invariant\");\n@@ -712,1 +813,1 @@\n-int write__classloader(JfrCheckpointWriter* writer, const void* c) {\n+int write__cld(JfrCheckpointWriter* writer, const void* c) {\n@@ -714,1 +815,1 @@\n-  CldPtr cld = (CldPtr)c;\n+  CldPtr cld = static_cast<CldPtr>(c);\n@@ -716,1 +817,1 @@\n-  return write_classloader(writer, cld, false);\n+  return write_cld(writer, cld, false);\n@@ -719,1 +820,1 @@\n-int write__classloader__leakp(JfrCheckpointWriter* writer, const void* c) {\n+int write__cld__leakp(JfrCheckpointWriter* writer, const void* c) {\n@@ -721,1 +822,1 @@\n-  CldPtr cld = (CldPtr)c;\n+  CldPtr cld = static_cast<CldPtr>(c);\n@@ -723,1 +824,1 @@\n-  return write_classloader(writer, cld, true);\n+  return write_cld(writer, cld, true);\n@@ -726,3 +827,5 @@\n-static void do_class_loader_data(ClassLoaderData* cld) {\n-  do_previous_epoch_artifact(_subsystem_callback, cld);\n-}\n+\/\/ CldWriter.\n+typedef SerializePredicate<CldPtr> CldPredicate;\n+typedef JfrPredicatedTypeWriterImplHost<CldPtr, CldPredicate, write__cld> CldWriterImpl;\n+typedef JfrTypeWriterHost<CldWriterImpl, TYPE_CLASSLOADER> CldWriter;\n+typedef JfrArtifactCallbackHost<CldPtr, CldWriter> CldCallback;\n@@ -730,8 +833,4 @@\n-class KlassCldFieldSelector {\n- public:\n-  typedef CldPtr TypePtr;\n-  static TypePtr select(KlassPtr klass) {\n-    assert(klass != nullptr, \"invariant\");\n-    return get_cld(klass);\n-  }\n-};\n+\/\/ CldWriter used during flush or unloading i.e. the current epoch.\n+typedef KlassToFieldEnvelope<KlassCldFieldSelector, CldWriter> KlassCldWriter;\n+typedef KlassToFieldEnvelope<ModuleCldFieldSelector, CldWriter> ModuleCldWriter;\n+typedef CompositeFunctor<KlassPtr, KlassCldWriter, ModuleCldWriter> KlassAndModuleCldWriter;\n@@ -739,9 +838,13 @@\n-class ModuleCldFieldSelector {\n-public:\n-  typedef CldPtr TypePtr;\n-  static TypePtr select(KlassPtr klass) {\n-    assert(klass != nullptr, \"invariant\");\n-    ModPtr mod = ModuleFieldSelector::select(klass);\n-    return mod != nullptr ? mod->loader_data() : nullptr;\n-  }\n-};\n+\/\/ CldWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n+typedef CompositeFunctor<CldPtr, CldWriter, ClearArtifact<CldPtr> > CldWriterWithClear;\n+typedef JfrArtifactCallbackHost<CldPtr, CldWriterWithClear> CldClearCallback;\n+\n+\/\/ CldWriter for leakp. Only used during start or rotation, i.e. the previous epoch.\n+typedef LeakPredicate<CldPtr> LeakCldPredicate;\n+typedef JfrPredicatedTypeWriterImplHost<CldPtr, LeakCldPredicate, write__cld__leakp> LeakCldWriterImpl;\n+typedef JfrTypeWriterHost<LeakCldWriterImpl, TYPE_CLASSLOADER> LeakCldWriter;\n+\n+\/\/ Composite CldWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n+typedef CompositeFunctor<CldPtr, LeakCldWriter, CldWriter> CompositeCldWriter;\n+typedef CompositeFunctor<CldPtr, CompositeCldWriter, ClearArtifact<CldPtr> > CompositeCldWriterWithClear;\n+typedef JfrArtifactCallbackHost<CldPtr, CompositeCldWriterWithClear> CompositeCldClearCallback;\n@@ -751,1 +854,0 @@\n-  CLDCallback() {}\n@@ -754,2 +856,2 @@\n-    if (cld->has_class_mirror_holder()) {\n-      return;\n+    if (!cld->has_class_mirror_holder()) {\n+      do_artifact(cld);\n@@ -757,1 +859,0 @@\n-    do_class_loader_data(cld);\n@@ -761,1 +862,1 @@\n-static void do_class_loaders() {\n+static void do_all_clds() {\n@@ -766,19 +867,4 @@\n-typedef SerializePredicate<CldPtr> CldPredicate;\n-typedef JfrPredicatedTypeWriterImplHost<CldPtr, CldPredicate, write__classloader> CldWriterImpl;\n-typedef JfrTypeWriterHost<CldWriterImpl, TYPE_CLASSLOADER> CldWriter;\n-typedef CompositeFunctor<CldPtr, CldWriter, ClearArtifact<CldPtr> > CldWriterWithClear;\n-typedef JfrArtifactCallbackHost<CldPtr, CldWriterWithClear> CldCallback;\n-typedef KlassToFieldEnvelope<KlassCldFieldSelector, CldWriter> KlassCldWriter;\n-typedef KlassToFieldEnvelope<ModuleCldFieldSelector, CldWriter> ModuleCldWriter;\n-typedef CompositeFunctor<KlassPtr, KlassCldWriter, ModuleCldWriter> KlassAndModuleCldWriter;\n-\n-typedef LeakPredicate<CldPtr> LeakCldPredicate;\n-typedef JfrPredicatedTypeWriterImplHost<CldPtr, LeakCldPredicate, write__classloader__leakp> LeakCldWriterImpl;\n-typedef JfrTypeWriterHost<LeakCldWriterImpl, TYPE_CLASSLOADER> LeakCldWriter;\n-\n-typedef CompositeFunctor<CldPtr, LeakCldWriter, CldWriter> CompositeCldWriter;\n-typedef KlassToFieldEnvelope<KlassCldFieldSelector, CompositeCldWriter> KlassCompositeCldWriter;\n-typedef KlassToFieldEnvelope<ModuleCldFieldSelector, CompositeCldWriter> ModuleCompositeCldWriter;\n-typedef CompositeFunctor<KlassPtr, KlassCompositeCldWriter, ModuleCompositeCldWriter> KlassAndModuleCompositeCldWriter;\n-typedef CompositeFunctor<CldPtr, CompositeCldWriter, ClearArtifact<CldPtr> > CompositeCldWriterWithClear;\n-typedef JfrArtifactCallbackHost<CldPtr, CompositeCldWriterWithClear> CompositeCldCallback;\n+static void do_all_clds(CldWriter& cldw) {\n+  do_all_clds();\n+  _artifacts->tally(cldw);\n+}\n@@ -786,3 +872,1 @@\n-static void write_classloaders() {\n-  assert(_writer != nullptr, \"invariant\");\n-  CldWriter cldw(_writer, _class_unload);\n+static void do_clds(CldWriter& cldw) {\n@@ -792,0 +876,19 @@\n+  _artifacts->iterate_klasses(kmcw);\n+  _artifacts->tally(cldw);\n+}\n+\n+static void write_clds_with_leakp(CldWriter& cldw) {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  LeakCldWriter lcldw(_leakp_writer, unloading());\n+  CompositeCldWriter ccldw(&lcldw, &cldw);\n+  ClearArtifact<CldPtr> clear;\n+  CompositeCldWriterWithClear ccldwwc(&ccldw, &clear);\n+  CompositeCldClearCallback callback(&_subsystem_callback, &ccldwwc);\n+  do_all_clds(cldw);\n+}\n+\n+static void write_clds() {\n+  assert(_writer != nullptr, \"invariant\");\n+  CldWriter cldw(_writer, unloading());\n@@ -793,2 +896,1 @@\n-    _artifacts->iterate_klasses(kmcw);\n-    _artifacts->tally(cldw);\n+    do_clds(cldw);\n@@ -799,1 +901,0 @@\n-    _artifacts->iterate_klasses(kmcw);\n@@ -802,13 +903,3 @@\n-    CldCallback callback(&_subsystem_callback, &cldwwc);\n-    do_class_loaders();\n-  } else {\n-    LeakCldWriter lcldw(_leakp_writer, _class_unload);\n-    CompositeCldWriter ccldw(&lcldw, &cldw);\n-    KlassCompositeCldWriter kccldw(&ccldw);\n-    ModuleCompositeCldWriter mccldw(&ccldw);\n-    KlassAndModuleCompositeCldWriter kmccldw(&kccldw, &mccldw);\n-    _artifacts->iterate_klasses(kmccldw);\n-    ClearArtifact<CldPtr> clear;\n-    CompositeCldWriterWithClear ccldwwc(&ccldw, &clear);\n-    CompositeCldCallback callback(&_subsystem_callback, &ccldwwc);\n-    do_class_loaders();\n+    CldClearCallback callback(&_subsystem_callback, &cldwwc);\n+    do_all_clds(cldw);\n+    return;\n@@ -816,1 +907,1 @@\n-  _artifacts->tally(cldw);\n+  write_clds_with_leakp(cldw);\n@@ -819,1 +910,1 @@\n-static void write_classloaders_on_clear() {\n+static void write_clds_on_clear() {\n@@ -822,15 +913,3 @@\n-  CldWriter cldw(_writer, _class_unload);\n-  KlassCldWriter kcw(&cldw);\n-  ModuleCldWriter mcw(&cldw);\n-  KlassAndModuleCldWriter kmcw(&kcw, &mcw);\n-  LeakCldWriter lcldw(_leakp_writer, _class_unload);\n-  CompositeCldWriter ccldw(&lcldw, &cldw);\n-  KlassCompositeCldWriter kccldw(&ccldw);\n-  ModuleCompositeCldWriter mccldw(&ccldw);\n-  KlassAndModuleCompositeCldWriter kmccldw(&kccldw, &mccldw);\n-  _artifacts->iterate_klasses(kmccldw);\n-  ClearArtifact<CldPtr> clear;\n-  CompositeCldWriterWithClear ccldwwc(&ccldw, &clear);\n-  CompositeCldCallback callback(&_subsystem_callback, &ccldwwc);\n-  do_class_loaders();\n-  _artifacts->tally(cldw);\n+  assert(previous_epoch(), \"invariant\");\n+  CldWriter cldw(_writer, unloading());\n+  write_clds_with_leakp(cldw);\n@@ -839,4 +918,1 @@\n-static u1 get_visibility(MethodPtr method) {\n-  assert(method != nullptr, \"invariant\");\n-  return const_cast<Method*>(method)->is_hidden() ? (u1)1 : (u1)0;\n-}\n+\/***** Methods *****\/\n@@ -847,2 +923,0 @@\n-  SET_METHOD_SERIALIZED(method);\n-  assert(METHOD_IS_SERIALIZED(method), \"invariant\");\n@@ -852,0 +926,8 @@\n+  assert(unloading() ? true : METHOD_IS_NOT_SERIALIZED(method), \"invariant\");\n+  SET_METHOD_SERIALIZED(method);\n+  assert(METHOD_IS_SERIALIZED(method), \"invariant\");\n+}\n+\n+static inline u1 get_visibility(MethodPtr method) {\n+  assert(method != nullptr, \"invariant\");\n+  return const_cast<Method*>(method)->is_hidden() ? (u1)1 : (u1)0;\n@@ -860,0 +942,2 @@\n+  assert(used(klass), \"invariant\");\n+  assert(IS_SERIALIZED(klass), \"invariant\");\n@@ -864,1 +948,1 @@\n-  writer->write((u2)get_flags(method));\n+  writer->write(static_cast<u2>(get_flags(method)));\n@@ -871,1 +955,1 @@\n-  MethodPtr method = (MethodPtr)m;\n+  MethodPtr method = static_cast<MethodPtr>(m);\n@@ -878,1 +962,1 @@\n-  MethodPtr method = (MethodPtr)m;\n+  MethodPtr method = static_cast<MethodPtr>(m);\n@@ -882,26 +966,1 @@\n-\n-class BitMapFilter {\n-  ResourceBitMap _bitmap;\n- public:\n-  explicit BitMapFilter(int length = 0) : _bitmap((size_t)length) {}\n-  bool operator()(size_t idx) {\n-    if (_bitmap.size() == 0) {\n-      return true;\n-    }\n-    if (_bitmap.at(idx)) {\n-      return false;\n-    }\n-    _bitmap.set_bit(idx);\n-    return true;\n-  }\n-};\n-\n-class AlwaysTrue {\n- public:\n-  explicit AlwaysTrue(int length = 0) {}\n-  bool operator()(size_t idx) {\n-    return true;\n-  }\n-};\n-\n-template <typename MethodCallback, typename KlassCallback, class Filter, bool leakp>\n+template <typename MethodCallback, typename KlassCallback, bool leakp>\n@@ -912,0 +971,1 @@\n+  KlassUsedPredicate _klass_used_predicate;\n@@ -921,0 +981,1 @@\n+    _klass_used_predicate(current_epoch),\n@@ -940,1 +1001,1 @@\n-    return _klass_cb(klass);\n+    return _klass_used_predicate(klass) ? _klass_cb(klass) : true;\n@@ -967,1 +1028,1 @@\n-typedef MethodIteratorHost<MethodWriterImpl, KlassCallbackStub, BitMapFilter, false> MethodWriter;\n+typedef MethodIteratorHost<MethodWriterImpl, KlassCallbackStub, false> MethodWriter;\n@@ -972,2 +1033,2 @@\n-typedef MethodIteratorHost<LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true> LeakMethodWriter;\n-typedef MethodIteratorHost<LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true> LeakMethodWriter;\n+typedef MethodIteratorHost<LeakMethodWriterImpl, KlassCallbackStub, true> LeakMethodWriter;\n+typedef MethodIteratorHost<LeakMethodWriterImpl, KlassCallbackStub, true> LeakMethodWriter;\n@@ -976,0 +1037,10 @@\n+static void write_methods_with_leakp(MethodWriter& mw) {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  LeakMethodWriter lpmw(_leakp_writer, current_epoch(), unloading());\n+  CompositeMethodWriter cmw(&lpmw, &mw);\n+  _artifacts->iterate_klasses(cmw);\n+  _artifacts->tally(mw);\n+}\n+\n@@ -978,1 +1049,1 @@\n-  MethodWriter mw(_writer, current_epoch(), _class_unload);\n+  MethodWriter mw(_writer, current_epoch(), unloading());\n@@ -981,4 +1052,2 @@\n-  } else {\n-    LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);\n-    CompositeMethodWriter cmw(&lpmw, &mw);\n-    _artifacts->iterate_klasses(cmw);\n+    _artifacts->tally(mw);\n+    return;\n@@ -986,1 +1055,1 @@\n-  _artifacts->tally(mw);\n+  write_methods_with_leakp(mw);\n@@ -993,5 +1062,2 @@\n-  MethodWriter mw(_writer, current_epoch(), _class_unload);\n-  LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);\n-  CompositeMethodWriter cmw(&lpmw, &mw);\n-  _artifacts->iterate_klasses(cmw);\n-  _artifacts->tally(mw);\n+  MethodWriter mw(_writer, current_epoch(), unloading());\n+  write_methods_with_leakp(mw);\n@@ -1025,1 +1091,1 @@\n-  SymbolEntryPtr entry = (SymbolEntryPtr)e;\n+  SymbolEntryPtr entry = static_cast<SymbolEntryPtr>(e);\n@@ -1032,1 +1098,1 @@\n-  SymbolEntryPtr entry = (SymbolEntryPtr)e;\n+  SymbolEntryPtr entry = static_cast<SymbolEntryPtr>(e);\n@@ -1046,1 +1112,1 @@\n-  StringEntryPtr entry = (StringEntryPtr)e;\n+  StringEntryPtr entry = static_cast<StringEntryPtr>(e);\n@@ -1053,1 +1119,1 @@\n-  StringEntryPtr entry = (StringEntryPtr)e;\n+  StringEntryPtr entry = static_cast<StringEntryPtr>(e);\n@@ -1074,15 +1140,0 @@\n-  assert(_leakp_writer != nullptr, \"invariant\");\n-  SymbolEntryWriter sw(_writer, _class_unload);\n-  LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);\n-  CompositeSymbolWriter csw(&lsw, &sw);\n-  _artifacts->iterate_symbols(csw);\n-  StringEntryWriter sew(_writer, _class_unload, true); \/\/ skip header\n-  LeakStringEntryWriter lsew(_leakp_writer, _class_unload, true); \/\/ skip header\n-  CompositeStringWriter csew(&lsew, &sew);\n-  _artifacts->iterate_strings(csew);\n-  sw.add(sew.count());\n-  lsw.add(lsew.count());\n-  _artifacts->tally(sw);\n-}\n-\n-static void write_symbols_on_clear() {\n@@ -1092,2 +1143,2 @@\n-  SymbolEntryWriter sw(_writer, _class_unload);\n-  LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);\n+  SymbolEntryWriter sw(_writer, unloading());\n+  LeakSymbolEntryWriter lsw(_leakp_writer, unloading());\n@@ -1096,2 +1147,2 @@\n-  StringEntryWriter sew(_writer, _class_unload, true); \/\/ skip header\n-  LeakStringEntryWriter lsew(_leakp_writer, _class_unload, true); \/\/ skip header\n+  StringEntryWriter sew(_writer, unloading(), true); \/\/ skip header\n+  LeakStringEntryWriter lsew(_leakp_writer, unloading(), true); \/\/ skip header\n@@ -1111,1 +1162,1 @@\n-  SymbolEntryWriter sw(_writer, _class_unload);\n+  SymbolEntryWriter sw(_writer, unloading());\n@@ -1113,1 +1164,1 @@\n-  StringEntryWriter sew(_writer, _class_unload, true); \/\/ skip header\n+  StringEntryWriter sew(_writer, unloading(), true); \/\/ skip header\n@@ -1119,0 +1170,7 @@\n+static void write_symbols_on_clear() {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  write_symbols_with_leakp();\n+}\n+\n@@ -1121,1 +1179,1 @@\n-typedef MethodIteratorHost<ClearMethodFlag, ClearKlassBits, AlwaysTrue, false> ClearKlassAndMethods;\n+typedef MethodIteratorHost<ClearMethodFlag, ClearKlassBits, false> ClearKlassAndMethods;\n@@ -1168,3 +1226,1 @@\n-  if (!write_klasses()) {\n-    return 0;\n-  }\n+  write_klasses();\n@@ -1173,1 +1229,1 @@\n-  write_classloaders();\n+  write_clds();\n@@ -1180,1 +1236,1 @@\n- * Clear all tags from the previous epoch.\n+ * Clear all tags from the previous epoch. Reset support structures.\n@@ -1188,1 +1244,1 @@\n-  write_classloaders_on_clear();\n+  write_clds_on_clear();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":546,"deletions":490,"binary":false,"changes":1036,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-                                                    _total_count(0) {\n+                                                    _total_count(0),\n+                                                    _class_unload(class_unload) {\n@@ -44,0 +45,1 @@\n+  _class_unload = class_unload;\n@@ -54,0 +56,5 @@\n+  _klass_loader_leakp_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n+\n+  if (class_unload) {\n+    _unloading_set = new GrowableArray<const Klass*>(initial_klass_list_size);\n+  }\n@@ -100,1 +107,7 @@\n-bool JfrArtifactSet::should_do_loader_klass(const Klass* k) {\n+static inline bool not_in_set(GrowableArray<const Klass*>* set, const Klass* k) {\n+  assert(set != nullptr, \"invariant\");\n+  assert(k != nullptr, \"invariant\");\n+  return !JfrMutablePredicate<const Klass*, compare_klasses>::test(set, k);\n+}\n+\n+bool JfrArtifactSet::should_do_cld_klass(const Klass* k, bool leakp) {\n@@ -103,1 +116,12 @@\n-  return !JfrMutablePredicate<const Klass*, compare_klasses>::test(_klass_loader_set, k);\n+  assert(_klass_loader_leakp_set != nullptr, \"invariant\");\n+  return not_in_set(leakp ? _klass_loader_leakp_set : _klass_loader_set, k);\n+}\n+\n+bool JfrArtifactSet::should_do_unloading_artifact(const void* ptr) {\n+  assert(ptr != nullptr, \"invariant\");\n+  assert(_class_unload, \"invariant\");\n+  assert(_unloading_set != nullptr, \"invariant\");\n+  \/\/ The incoming pointers are of all kinds of different types.\n+  \/\/ However, we are only interested in set membership.\n+  \/\/ Treat them uniformly as const Klass* for simplicity and code reuse.\n+  return not_in_set(_unloading_set, static_cast<const Klass*>(ptr));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -117,22 +117,0 @@\n-template <typename T>\n-class SerializePredicate {\n-  bool _class_unload;\n- public:\n-  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n-  bool operator()(T const& value) {\n-    assert(value != nullptr, \"invariant\");\n-    return _class_unload ? true : IS_NOT_SERIALIZED(value);\n-  }\n-};\n-\n-template <>\n-class SerializePredicate<const Method*> {\n-  bool _class_unload;\n- public:\n-  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n-  bool operator()(const Method* method) {\n-    assert(method != nullptr, \"invariant\");\n-    return _class_unload ? true : METHOD_IS_NOT_SERIALIZED(method);\n-  }\n-};\n-\n@@ -153,0 +131,9 @@\n+class KlassUsedPredicate {\n+  bool _current_epoch;\n+public:\n+  KlassUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n+  bool operator()(const Klass* klass) {\n+    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n+  }\n+};\n+\n@@ -158,0 +145,3 @@\n+    if (!klass->is_instance_klass()) {\n+      return false;\n+    }\n@@ -213,0 +203,2 @@\n+  GrowableArray<const Klass*>* _klass_loader_leakp_set;\n+  GrowableArray<const Klass*>* _unloading_set;\n@@ -214,0 +206,1 @@\n+  bool _class_unload;\n@@ -238,1 +231,2 @@\n-  bool should_do_loader_klass(const Klass* k);\n+  bool should_do_cld_klass(const Klass* k, bool leakp);\n+  bool should_do_unloading_artifact(const void* ptr);\n@@ -245,1 +239,6 @@\n-        break;\n+        return;\n+      }\n+    }\n+    for (int i = 0; i < _klass_loader_set->length(); ++i) {\n+      if (!functor(_klass_loader_set->at(i))) {\n+        return;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"jfr\/support\/jfrKlassExtension.hpp\"\n@@ -69,0 +70,3 @@\n+\/\/ We set the 'method_and_class' bits to have a consistent\n+\/\/ bit pattern set always. This is because the tag is non-atomic,\n+\/\/ hence, we always need the same bit pattern in an epoch to avoid losing information.\n@@ -70,3 +74,4 @@\n-    SET_USED_THIS_EPOCH(klass);\n-    enqueue(klass);\n-    JfrTraceIdEpoch::set_changed_tag_state();\n+  SET_METHOD_AND_CLASS_USED_THIS_EPOCH(klass);\n+  assert(METHOD_AND_CLASS_USED_THIS_EPOCH(klass), \"invariant\");\n+  enqueue(klass);\n+  JfrTraceIdEpoch::set_changed_tag_state();\n@@ -116,8 +121,0 @@\n-inline traceid JfrTraceIdLoadBarrier::load(const ModuleEntry* module) {\n-  return set_used_and_get(module);\n-}\n-\n-inline traceid JfrTraceIdLoadBarrier::load(const PackageEntry* package) {\n-  return set_used_and_get(package);\n-}\n-\n@@ -130,2 +127,2 @@\n-  if (class_loader_klass != nullptr && should_tag(class_loader_klass)) {\n-    load_barrier(class_loader_klass);\n+  if (class_loader_klass != nullptr) {\n+    load(class_loader_klass);\n@@ -136,0 +133,18 @@\n+inline traceid JfrTraceIdLoadBarrier::load(const ModuleEntry* module) {\n+  assert(module != nullptr, \"invariant\");\n+  const ClassLoaderData* cld = module->loader_data();\n+  if (cld != nullptr) {\n+    load(cld);\n+  }\n+  return set_used_and_get(module);\n+}\n+\n+inline traceid JfrTraceIdLoadBarrier::load(const PackageEntry* package) {\n+  assert(package != nullptr, \"invariant\");\n+  const ModuleEntry* const module_entry = package->module();\n+  if (module_entry != nullptr) {\n+    load(module_entry);\n+  }\n+  return set_used_and_get(package);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -89,3 +89,0 @@\n-\/\/ Subsystem\n-static JfrCheckpointManager* _checkpoint_manager = nullptr;\n-\n@@ -102,3 +99,4 @@\n-  _checkpoint_manager = JfrCheckpointManager::create();\n-  if (_checkpoint_manager == nullptr || !_checkpoint_manager->initialize_early()) {\n-    return false;\n+  if (is_started_on_commandline()) {\n+    if (!create_checkpoint_manager()) {\n+      return false;\n+    }\n@@ -295,1 +293,1 @@\n-  if (!create_checkpoint_manager()) {\n+  if (!initialize_checkpoint_manager()) {\n@@ -324,0 +322,1 @@\n+static JfrCheckpointManager* _checkpoint_manager = nullptr;\n@@ -360,0 +359,11 @@\n+  assert(_checkpoint_manager == nullptr, \"invariant\");\n+  _checkpoint_manager = JfrCheckpointManager::create();\n+  return _checkpoint_manager != nullptr && _checkpoint_manager->initialize_early();\n+}\n+\n+bool JfrRecorder::initialize_checkpoint_manager() {\n+  if (_checkpoint_manager == nullptr) {\n+    if (!create_checkpoint_manager()) {\n+      return false;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  static bool initialize_checkpoint_manager();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -629,1 +629,0 @@\n-  assert(!node->retired(), \"invariant\");\n@@ -631,0 +630,1 @@\n+    assert(!node->retired(), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrMemorySpace.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-  if (writer.has_data() && _pending_head != nullptr) {\n+  if (_pending_head != nullptr) {\n@@ -376,0 +376,2 @@\n+  } else {\n+    writer.cancel();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_PADDING_SIZE, 0);\n@@ -110,1 +110,1 @@\n-    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile Type));\n+    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(volatile Type));\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrVersionSystem.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-template <class T, size_t alignment = DEFAULT_CACHE_LINE_SIZE>\n+template <class T, size_t alignment = DEFAULT_PADDING_SIZE>\n@@ -50,1 +50,1 @@\n-template <class T, typename Arg1T, size_t alignment = DEFAULT_CACHE_LINE_SIZE>\n+template <class T, typename Arg1T, size_t alignment = DEFAULT_PADDING_SIZE>\n@@ -78,1 +78,1 @@\n-template <class T, size_t alignment = DEFAULT_CACHE_LINE_SIZE>\n+template <class T, size_t alignment = DEFAULT_PADDING_SIZE>\n@@ -92,1 +92,1 @@\n-template <class T, MEMFLAGS flags, size_t alignment = DEFAULT_CACHE_LINE_SIZE>\n+template <class T, MEMFLAGS flags, size_t alignment = DEFAULT_PADDING_SIZE>\n@@ -103,1 +103,1 @@\n-template <class T, MEMFLAGS flags, size_t alignment = DEFAULT_CACHE_LINE_SIZE>\n+template <class T, MEMFLAGS flags, size_t alignment = DEFAULT_PADDING_SIZE>\n@@ -115,1 +115,1 @@\n-template <class T, MEMFLAGS flags, size_t alignment = DEFAULT_CACHE_LINE_SIZE>\n+template <class T, MEMFLAGS flags, size_t alignment = DEFAULT_PADDING_SIZE>\n","filename":"src\/hotspot\/share\/memory\/padded.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,2 +48,0 @@\n-class FilteringClosure;\n-\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -256,0 +256,16 @@\n+bool AddNode::is_not(PhaseGVN* phase, Node* n, BasicType bt) {\n+  return n->Opcode() == Op_Xor(bt) && phase->type(n->in(2)) == TypeInteger::minus_1(bt);\n+}\n+\n+AddNode* AddNode::make_not(PhaseGVN* phase, Node* n, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new XorINode(n, phase->intcon(-1));\n+    case T_LONG:\n+      return new XorLNode(n, phase->longcon(-1L));\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,7 @@\n+\n+  \/\/ Utility function to check if the given node is a NOT operation,\n+  \/\/ i.e., n == m ^ (-1).\n+  static bool is_not(PhaseGVN* phase, Node* n, BasicType bt);\n+\n+  \/\/ Utility function to make a NOT operation, i.e., returning n ^ (-1).\n+  static AddNode* make_not(PhaseGVN* phase, Node* n, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,4 @@\n+  develop(bool, VerifyAlignVector, false,                                   \\\n+          \"Check that vector stores\/loads are aligned if AlignVector\"       \\\n+          \"is enabled.\")                                                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -67,0 +68,7 @@\n+#ifdef ASSERT\n+  if (!AlignVector && VerifyAlignVector) {\n+    warning(\"VerifyAlignVector disabled because AlignVector is not enabled.\");\n+    FLAG_SET_CMDLINE(VerifyAlignVector, false);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2173,1 +2173,1 @@\n-            cast = new CheckCastPPNode(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CheckCastPPNode(r, n, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1792,1 +1792,1 @@\n-Node *PhaseChaitin::find_base_for_derived( Node **derived_base_map, Node *derived, uint &maxlrg ) {\n+Node* PhaseChaitin::find_base_for_derived(Node** derived_base_map, Node* derived, uint& maxlrg) {\n@@ -1794,1 +1794,1 @@\n-  if( derived_base_map[derived->_idx] )\n+  if (derived_base_map[derived->_idx]) {\n@@ -1796,0 +1796,10 @@\n+  }\n+\n+#ifdef ASSERT\n+  if (derived->is_Mach() && derived->as_Mach()->ideal_Opcode() == Op_VerifyVectorAlignment) {\n+    \/\/ Bypass the verification node\n+    Node* base = find_base_for_derived(derived_base_map, derived->in(1), maxlrg);\n+    derived_base_map[derived->_idx] = base;\n+    return base;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -452,0 +452,1 @@\n+macro(VerifyVectorAlignment)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/compilationFailureInfo.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -640,0 +642,1 @@\n+                  _first_failure_details(nullptr),\n@@ -929,0 +932,1 @@\n+    _first_failure_details(nullptr),\n@@ -992,0 +996,5 @@\n+Compile::~Compile() {\n+  delete _print_inlining_stream;\n+  delete _first_failure_details;\n+};\n+\n@@ -1059,1 +1068,1 @@\n-    if (has_method() && (_directive->VectorizeOption || _directive->VectorizeDebugOption)) {\n+    if (has_method() && _directive->VectorizeOption) {\n@@ -3701,0 +3710,25 @@\n+#ifdef ASSERT\n+    \/\/ Add VerifyVectorAlignment node between adr and load \/ store.\n+    if (VerifyAlignVector && Matcher::has_match_rule(Op_VerifyVectorAlignment)) {\n+      bool must_verify_alignment = n->is_LoadVector() ? n->as_LoadVector()->must_verify_alignment() :\n+                                                        n->as_StoreVector()->must_verify_alignment();\n+      if (must_verify_alignment) {\n+        jlong vector_width = n->is_LoadVector() ? n->as_LoadVector()->memory_size() :\n+                                                  n->as_StoreVector()->memory_size();\n+        \/\/ The memory access should be aligned to the vector width in bytes.\n+        \/\/ However, the underlying array is possibly less well aligned, but at least\n+        \/\/ to ObjectAlignmentInBytes. Hence, even if multiple arrays are accessed in\n+        \/\/ a loop we can expect at least the following alignment:\n+        jlong guaranteed_alignment = MIN2(vector_width, (jlong)ObjectAlignmentInBytes);\n+        assert(2 <= guaranteed_alignment && guaranteed_alignment <= 64, \"alignment must be in range\");\n+        assert(is_power_of_2(guaranteed_alignment), \"alignment must be power of 2\");\n+        \/\/ Create mask from alignment. e.g. 0b1000 -> 0b0111\n+        jlong mask = guaranteed_alignment - 1;\n+        Node* mask_con = ConLNode::make(mask);\n+        VerifyVectorAlignmentNode* va = new VerifyVectorAlignmentNode(n->in(MemNode::Address), mask_con);\n+        n->set_req(MemNode::Address, va);\n+      }\n+    }\n+#endif\n+    break;\n+\n@@ -4361,0 +4395,3 @@\n+    if (CaptureBailoutInformation) {\n+      _first_failure_details = new CompilationFailureInfo(reason);\n+    }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+class CompilationFailureInfo;\n@@ -366,0 +367,1 @@\n+  CompilationFailureInfo* _first_failure_details; \/\/ Details for the first failure happening during compilation\n@@ -812,0 +814,1 @@\n+  const CompilationFailureInfo* first_failure_details() const { return _first_failure_details; }\n@@ -1128,3 +1131,1 @@\n-  ~Compile() {\n-    delete _print_inlining_stream;\n-  };\n+  ~Compile();\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -182,2 +182,0 @@\n-  C->set_has_monitors(true);\n-\n@@ -201,4 +199,0 @@\n-  \/\/ need to set it for monitor exit as well.\n-  \/\/ OSR compiled methods can start with lock taken\n-  C->set_has_monitors(true);\n-\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,7 @@\n+#ifdef ASSERT\n+  if (base != nullptr && base->is_Mach() && base->as_Mach()->ideal_Opcode() == Op_VerifyVectorAlignment) {\n+    \/\/ For VerifyVectorAlignment we just pass the type through\n+    return base->bottom_type()->is_ptr();\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -613,0 +613,7 @@\n+  \/\/ Convert \"(~a) & (~b)\" into \"~(a | b)\"\n+  if (AddNode::is_not(phase, in(1), T_INT) && AddNode::is_not(phase, in(2), T_INT)) {\n+    Node* or_a_b = new OrINode(in(1)->in(1), in(2)->in(1));\n+    Node* tn = phase->transform(or_a_b);\n+    return AddNode::make_not(phase, tn, T_INT);\n+  }\n+\n@@ -753,0 +760,7 @@\n+  \/\/ Convert \"(~a) & (~b)\" into \"~(a | b)\"\n+  if (AddNode::is_not(phase, in(1), T_LONG) && AddNode::is_not(phase, in(2), T_LONG)) {\n+    Node* or_a_b = new OrLNode(in(1)->in(1), in(2)->in(1));\n+    Node* tn = phase->transform(or_a_b);\n+    return AddNode::make_not(phase, tn, T_LONG);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+class VerifyVectorAlignmentNode;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -419,2 +419,5 @@\n-  bool is_normal_parse() const  { return _entry_bci == InvocationEntryBci; }\n-  bool is_osr_parse() const     { return _entry_bci != InvocationEntryBci; }\n+  bool is_osr_parse() const {\n+    assert(_entry_bci != UnknownBci, \"uninitialized _entry_bci\");\n+    return _entry_bci != InvocationEntryBci;\n+  }\n+  bool is_normal_parse() const  { return !is_osr_parse(); }\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -404,2 +404,0 @@\n-  _entry_bci = InvocationEntryBci;\n-  _tf = nullptr;\n@@ -410,2 +408,3 @@\n-  debug_only(_block_count = -1);\n-  debug_only(_blocks = (Block*)-1);\n+  DEBUG_ONLY(_entry_bci = UnknownBci);\n+  DEBUG_ONLY(_block_count = -1);\n+  DEBUG_ONLY(_blocks = (Block*)-1);\n@@ -415,2 +414,1 @@\n-    JVMState* ilt_caller = is_osr_parse() ? caller->caller() : caller;\n-    InlineTree::find_subtree_from_root(C->ilt(), ilt_caller, parse_method);\n+    InlineTree::find_subtree_from_root(C->ilt(), caller, parse_method);\n@@ -426,1 +424,1 @@\n-  if (parse_method->is_synchronized()) {\n+  if (parse_method->is_synchronized() || parse_method->has_monitor_bytecodes()) {\n@@ -430,1 +428,0 @@\n-  _tf = TypeFunc::make(method());\n@@ -432,11 +429,0 @@\n-  _flow = method()->get_flow_analysis();\n-  if (_flow->failing()) {\n-    assert(false, \"type flow failed during parsing\");\n-    C->record_method_not_compilable(_flow->failure_reason());\n-  }\n-\n-#ifndef PRODUCT\n-  if (_flow->has_irreducible_entry()) {\n-    C->set_parsed_irreducible_loop(true);\n-  }\n-#endif\n@@ -510,0 +496,1 @@\n+    _tf = C->tf();     \/\/ the OSR entry type is different\n@@ -512,3 +499,9 @@\n-    if (_flow->failing()) {\n-      assert(false, \"type flow analysis failed for OSR compilation\");\n-      C->record_method_not_compilable(_flow->failure_reason());\n+  } else {\n+    _tf = TypeFunc::make(method());\n+    _entry_bci = InvocationEntryBci;\n+    _flow = method()->get_flow_analysis();\n+  }\n+\n+  if (_flow->failing()) {\n+    assert(false, \"type flow analysis failed during parsing\");\n+    C->record_method_not_compilable(_flow->failure_reason());\n@@ -517,1 +510,5 @@\n-        tty->print_cr(\"OSR @%d type flow bailout: %s\", _entry_bci, _flow->failure_reason());\n+        if (is_osr_parse()) {\n+          tty->print_cr(\"OSR @%d type flow bailout: %s\", _entry_bci, _flow->failure_reason());\n+        } else {\n+          tty->print_cr(\"type flow bailout: %s\", _flow->failure_reason());\n+        }\n@@ -525,2 +522,0 @@\n-    }\n-    _tf = C->tf();     \/\/ the OSR entry type is different\n@@ -538,0 +533,4 @@\n+  if (_flow->has_irreducible_entry()) {\n+    C->set_parsed_irreducible_loop(true);\n+  }\n+\n@@ -1515,1 +1514,1 @@\n-    tty->print(\"Parsing block #%d at bci [%d,%d), successors: \",\n+    tty->print(\"Parsing block #%d at bci [%d,%d), successors:\",\n@@ -1518,1 +1517,1 @@\n-      tty->print((( i < ns) ? \" %d\" : \" %d(e)\"), b->successor_at(i)->rpo());\n+      tty->print((( i < ns) ? \" %d\" : \" %d(exception block)\"), b->successor_at(i)->rpo());\n@@ -1521,1 +1520,1 @@\n-      tty->print(\"  lphd\");\n+      tty->print(\"  loop head\");\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":27,"deletions":28,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -688,1 +688,1 @@\n-      dump_infinite_loop_info(i, \"PhaseGVN::transform_no_reclaim\");\n+      dump_infinite_loop_info(i, \"PhaseGVN::transform\");\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -560,2 +560,8 @@\n-  if (align_to_ref() == nullptr) {\n-    return false; \/\/ Did not find memory reference to align vectors\n+  if (_packset.length() == 0) {\n+#ifndef PRODUCT\n+    if (TraceSuperWord) {\n+      tty->print_cr(\"\\nNo pair packs generated, abort SuperWord.\");\n+      tty->cr();\n+    }\n+#endif\n+    return false;\n@@ -568,0 +574,2 @@\n+  filter_packs_for_alignment();\n+\n@@ -581,3 +589,3 @@\n-\/\/ This is the initial set of packs that will then be extended by\n-\/\/ following use->def and def->use links.  The align positions are\n-\/\/ assigned relative to the reference \"align_to_ref\"\n+\/\/ We can find adjacent memory references by comparing their relative\n+\/\/ alignment. Whether the final vectors can be aligned is determined later\n+\/\/ once all vectors are extended and combined.\n@@ -601,1 +609,0 @@\n-  Node_List align_to_refs;\n@@ -603,2 +610,5 @@\n-  int best_iv_adjustment = 0;\n-  MemNode* best_align_to_mem_ref = nullptr;\n+\n+  \/\/ Take the first mem_ref as the reference to align to. The pre-loop trip count is\n+  \/\/ modified to align this reference to a vector-aligned address. If strict alignment\n+  \/\/ is required, we may change the reference later (see filter_packs_for_alignment()).\n+  MemNode* align_to_mem_ref = nullptr;\n@@ -610,1 +620,0 @@\n-    align_to_refs.push(mem_ref);\n@@ -613,7 +622,3 @@\n-    if (best_align_to_mem_ref == nullptr) {\n-      \/\/ Set memory reference which is the best from all memory operations\n-      \/\/ to be used for alignment. The pre-loop trip count is modified to align\n-      \/\/ this reference to a vector-aligned address.\n-      best_align_to_mem_ref = mem_ref;\n-      best_iv_adjustment = iv_adjustment;\n-      NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)\n+    if (align_to_mem_ref == nullptr) {\n+      align_to_mem_ref = mem_ref;\n+      set_align_to_ref(align_to_mem_ref);\n@@ -636,72 +641,15 @@\n-    if (mem_ref_has_no_alignment_violation(mem_ref, iv_adjustment, align_to_ref_p,\n-                                           best_align_to_mem_ref, best_iv_adjustment,\n-                                           align_to_refs)) {\n-      \/\/ Create initial pack pairs of memory operations for which alignment was set.\n-      for (uint i = 0; i < memops.size(); i++) {\n-        Node* s1 = memops.at(i);\n-        int align = alignment(s1);\n-        if (align == top_align) continue;\n-        for (uint j = 0; j < memops.size(); j++) {\n-          Node* s2 = memops.at(j);\n-          if (alignment(s2) == top_align) continue;\n-          if (s1 != s2 && are_adjacent_refs(s1, s2)) {\n-            if (stmts_can_pack(s1, s2, align)) {\n-              Node_List* pair = new Node_List();\n-              pair->push(s1);\n-              pair->push(s2);\n-              if (!_do_vector_loop || same_origin_idx(s1, s2)) {\n-                _packset.append(pair);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    } else {\n-      \/\/ Cannot create pairs for mem_ref. Reject all related memops forever.\n-\n-      \/\/ First, remove remaining memory ops of the same memory slice from the list.\n-      for (int i = memops.size() - 1; i >= 0; i--) {\n-        MemNode* s = memops.at(i)->as_Mem();\n-        if (same_memory_slice(s, mem_ref) || same_velt_type(s, mem_ref)) {\n-          memops.remove(i);\n-        }\n-      }\n-\n-      \/\/ Second, remove already constructed packs of the same memory slice.\n-      for (int i = _packset.length() - 1; i >= 0; i--) {\n-        Node_List* p = _packset.at(i);\n-        MemNode* s = p->at(0)->as_Mem();\n-        if (same_memory_slice(s, mem_ref) || same_velt_type(s, mem_ref)) {\n-          remove_pack_at(i);\n-        }\n-      }\n-\n-      \/\/ If needed find the best memory reference for loop alignment again.\n-      if (same_memory_slice(mem_ref, best_align_to_mem_ref) || same_velt_type(mem_ref, best_align_to_mem_ref)) {\n-        \/\/ Put memory ops from remaining packs back on memops list for\n-        \/\/ the best alignment search.\n-        uint orig_msize = memops.size();\n-        for (int i = 0; i < _packset.length(); i++) {\n-          Node_List* p = _packset.at(i);\n-          MemNode* s = p->at(0)->as_Mem();\n-          assert(!same_velt_type(s, mem_ref), \"sanity\");\n-          memops.push(s);\n-        }\n-        best_align_to_mem_ref = find_align_to_ref(memops, max_idx);\n-        if (best_align_to_mem_ref == nullptr) {\n-          if (TraceSuperWord) {\n-            tty->print_cr(\"SuperWord::find_adjacent_refs(): best_align_to_mem_ref == nullptr\");\n-          }\n-          \/\/ best_align_to_mem_ref will be used for adjusting the pre-loop limit in\n-          \/\/ SuperWord::align_initial_loop_index. Find one with the biggest vector size,\n-          \/\/ smallest data size and smallest iv offset from memory ops from remaining packs.\n-          if (_packset.length() > 0) {\n-            if (orig_msize == 0) {\n-              best_align_to_mem_ref = memops.at(max_idx)->as_Mem();\n-            } else {\n-              for (uint i = 0; i < orig_msize; i++) {\n-                memops.remove(0);\n-              }\n-              best_align_to_mem_ref = find_align_to_ref(memops, max_idx);\n-              assert(best_align_to_mem_ref == nullptr, \"sanity\");\n-              best_align_to_mem_ref = memops.at(max_idx)->as_Mem();\n+    \/\/ Create initial pack pairs of memory operations for which alignment was set.\n+    for (uint i = 0; i < memops.size(); i++) {\n+      Node* s1 = memops.at(i);\n+      int align = alignment(s1);\n+      if (align == top_align) continue;\n+      for (uint j = 0; j < memops.size(); j++) {\n+        Node* s2 = memops.at(j);\n+        if (alignment(s2) == top_align) continue;\n+        if (s1 != s2 && are_adjacent_refs(s1, s2)) {\n+          if (stmts_can_pack(s1, s2, align)) {\n+            Node_List* pair = new Node_List();\n+            pair->push(s1);\n+            pair->push(s2);\n+            if (!_do_vector_loop || same_origin_idx(s1, s2)) {\n+              _packset.append(pair);\n@@ -709,1 +657,0 @@\n-            assert(best_align_to_mem_ref != nullptr, \"sanity\");\n@@ -711,1 +658,0 @@\n-          break;\n@@ -713,5 +659,0 @@\n-        best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);\n-        NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)\n-        \/\/ Restore list.\n-        while (memops.size() > orig_msize)\n-          (void)memops.pop();\n@@ -719,1 +660,1 @@\n-    } \/\/ unaligned memory accesses\n+    }\n@@ -728,0 +669,1 @@\n+  } \/\/ while (memops.size() != 0)\n@@ -729,2 +671,2 @@\n-  } \/\/ while (memops.size() != 0\n-  set_align_to_ref(best_align_to_mem_ref);\n+  assert(_packset.is_empty() || align_to_mem_ref != nullptr,\n+         \"packset empty or we find the alignment reference\");\n@@ -732,0 +674,1 @@\n+#ifndef PRODUCT\n@@ -736,10 +679,0 @@\n-}\n-\n-#ifndef PRODUCT\n-void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {\n-  if (is_trace_adjacent()) {\n-    tty->print(\"SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d\",\n-       best_align_to_mem_ref->_idx, best_iv_adjustment);\n-       best_align_to_mem_ref->dump();\n-  }\n-}\n@@ -747,41 +680,0 @@\n-\n-\/\/ If strict memory alignment is required (vectors_should_be_aligned), then check if\n-\/\/ mem_ref is aligned with best_align_to_mem_ref.\n-bool SuperWord::mem_ref_has_no_alignment_violation(MemNode* mem_ref, int iv_adjustment, VPointer& align_to_ref_p,\n-                                                   MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n-                                                   Node_List &align_to_refs) {\n-  if (!vectors_should_be_aligned()) {\n-    \/\/ Alignment is not required by the hardware. No violation possible.\n-    return true;\n-  }\n-\n-  \/\/ All vectors need to be memory aligned, modulo their vector_width. This is more strict\n-  \/\/ than the hardware probably requires. Most hardware at most requires 4-byte alignment.\n-  \/\/\n-  \/\/ In the pre-loop, we align best_align_to_mem_ref to its vector_length. To ensure that\n-  \/\/ all mem_ref's are memory aligned modulo their vector_width, we only need to check that\n-  \/\/ they are all aligned to best_align_to_mem_ref, modulo their vector_width. For that,\n-  \/\/ we check the following 3 conditions.\n-\n-  \/\/ (1) All packs are aligned with best_align_to_mem_ref.\n-  if (memory_alignment(mem_ref, best_iv_adjustment) != 0) {\n-    return false;\n-  }\n-  \/\/ (2) All other vectors have vector_size less or equal to that of best_align_to_mem_ref.\n-  int vw = vector_width(mem_ref);\n-  int vw_best = vector_width(best_align_to_mem_ref);\n-  if (vw > vw_best) {\n-    \/\/ We only align to vector_width of best_align_to_mem_ref during pre-loop.\n-    \/\/ A mem_ref with a larger vector_width might thus not be vector_width aligned.\n-    return false;\n-  }\n-  \/\/ (3) Ensure that all vectors have the same invariant. We model memory accesses like this\n-  \/\/     address = base + k*iv + constant [+ invar]\n-  \/\/     memory_alignment ignores the invariant.\n-  VPointer p2(best_align_to_mem_ref, phase(), lpt(), nullptr, false);\n-  if (!align_to_ref_p.invar_equals(p2)) {\n-    \/\/ Do not vectorize memory accesses with different invariants\n-    \/\/ if unaligned memory accesses are not allowed.\n-    return false;\n-  }\n-  return true;\n@@ -801,6 +693,0 @@\n-    \/\/ Only discard unalignable memory references if vector memory references\n-    \/\/ should be aligned on this platform.\n-    if (vectors_should_be_aligned() && !ref_is_alignable(p1)) {\n-      *cmp_ct.adr_at(i) = 0;\n-      continue;\n-    }\n@@ -895,89 +781,0 @@\n-\/\/------------------span_works_for_memory_size-----------------------------\n-static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {\n-  bool span_matches_memory = false;\n-  if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))\n-    && ABS(span) == type2aelembytes(T_INT)) {\n-    \/\/ There is a mismatch on span size compared to memory.\n-    for (DUIterator_Fast jmax, j = mem->fast_outs(jmax); j < jmax; j++) {\n-      Node* use = mem->fast_out(j);\n-      if (!VectorNode::is_type_transition_to_int(use)) {\n-        return false;\n-      }\n-    }\n-    \/\/ If all uses transition to integer, it means that we can successfully align even on mismatch.\n-    return true;\n-  }\n-  else {\n-    span_matches_memory = ABS(span) == mem_size;\n-  }\n-  return span_matches_memory && (ABS(offset) % mem_size) == 0;\n-}\n-\n-\/\/------------------------------ref_is_alignable---------------------------\n-\/\/ Can the preloop align the reference to position zero in the vector?\n-bool SuperWord::ref_is_alignable(VPointer& p) {\n-  if (!p.has_iv()) {\n-    return true;   \/\/ no induction variable\n-  }\n-  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n-  assert(pre_end->stride_is_con(), \"pre loop stride is constant\");\n-  int preloop_stride = pre_end->stride_con();\n-\n-  int span = preloop_stride * p.scale_in_bytes();\n-  int mem_size = p.memory_size();\n-  int offset   = p.offset_in_bytes();\n-  \/\/ Stride one accesses are alignable if offset is aligned to memory operation size.\n-  \/\/ Offset can be unaligned when UseUnalignedAccesses is used.\n-  if (span_works_for_memory_size(p.mem(), span, mem_size, offset)) {\n-    return true;\n-  }\n-  \/\/ If the initial offset from start of the object is computable,\n-  \/\/ check if the pre-loop can align the final offset accordingly.\n-  \/\/\n-  \/\/ In other words: Can we find an i such that the offset\n-  \/\/ after i pre-loop iterations is aligned to vw?\n-  \/\/   (init_offset + pre_loop) % vw == 0              (1)\n-  \/\/ where\n-  \/\/   pre_loop = i * span\n-  \/\/ is the number of bytes added to the offset by i pre-loop iterations.\n-  \/\/\n-  \/\/ For this to hold we need pre_loop to increase init_offset by\n-  \/\/   pre_loop = vw - (init_offset % vw)\n-  \/\/\n-  \/\/ This is only possible if pre_loop is divisible by span because each\n-  \/\/ pre-loop iteration increases the initial offset by 'span' bytes:\n-  \/\/   (vw - (init_offset % vw)) % span == 0\n-  \/\/\n-  int vw = vector_width_in_bytes(p.mem());\n-  assert(vw > 1, \"sanity\");\n-  Node* init_nd = pre_end->init_trip();\n-  if (init_nd->is_Con() && p.invar() == nullptr) {\n-    int init = init_nd->bottom_type()->is_int()->get_con();\n-    int init_offset = init * p.scale_in_bytes() + offset;\n-    if (init_offset < 0) { \/\/ negative offset from object start?\n-      return false;        \/\/ may happen in dead loop\n-    }\n-    if (vw % span == 0) {\n-      \/\/ If vm is a multiple of span, we use formula (1).\n-      if (span > 0) {\n-        return (vw - (init_offset % vw)) % span == 0;\n-      } else {\n-        assert(span < 0, \"nonzero stride * scale\");\n-        return (init_offset % vw) % -span == 0;\n-      }\n-    } else if (span % vw == 0) {\n-      \/\/ If span is a multiple of vw, we can simplify formula (1) to:\n-      \/\/   (init_offset + i * span) % vw == 0\n-      \/\/     =>\n-      \/\/   (init_offset % vw) + ((i * span) % vw) == 0\n-      \/\/     =>\n-      \/\/   init_offset % vw == 0\n-      \/\/\n-      \/\/ Because we add a multiple of vw to the initial offset, the final\n-      \/\/ offset is a multiple of vw if and only if init_offset is a multiple.\n-      \/\/\n-      return (init_offset % vw) == 0;\n-    }\n-  }\n-  return false;\n-}\n@@ -1029,4 +826,0 @@\n-    \/\/ iv_adjustment_in_bytes must be a multiple of elt_size if vector memory\n-    \/\/ references should be aligned on this platform.\n-    assert((ABS(iv_adjustment_in_bytes) % elt_size) == 0 || !vectors_should_be_aligned(),\n-           \"(%d) should be divisible by (%d)\", iv_adjustment_in_bytes, elt_size);\n@@ -1710,0 +1503,6 @@\n+#ifdef ASSERT\n+  for (int i = 0; i < _packset.length(); i++) {\n+    assert(_packset.at(i) != nullptr, \"no nullptr in packset\");\n+  }\n+#endif\n+\n@@ -1805,7 +1604,2 @@\n-  \/\/ Compress list.\n-  for (int i = _packset.length() - 1; i >= 0; i--) {\n-    Node_List* p1 = _packset.at(i);\n-    if (p1 == nullptr) {\n-      _packset.remove_at(i);\n-    }\n-  }\n+  \/\/ Remove all nullptr from packset\n+  compress_packset();\n@@ -1813,0 +1607,1 @@\n+#ifndef PRODUCT\n@@ -1817,0 +1612,109 @@\n+#endif\n+}\n+\n+\/\/ Find the set of alignment solutions for load\/store pack.\n+const AlignmentSolution* SuperWord::pack_alignment_solution(Node_List* pack) {\n+  assert(pack != nullptr && (pack->at(0)->is_Load() || pack->at(0)->is_Store()), \"only load\/store packs\");\n+\n+  const MemNode* mem_ref = pack->at(0)->as_Mem();\n+  VPointer mem_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n+  const CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n+  assert(pre_end->stride_is_con(), \"pre loop stride is constant\");\n+\n+  AlignmentSolver solver(pack->at(0)->as_Mem(),\n+                         pack->size(),\n+                         mem_ref_p.base(),\n+                         mem_ref_p.offset_in_bytes(),\n+                         mem_ref_p.invar(),\n+                         mem_ref_p.invar_factor(),\n+                         mem_ref_p.scale_in_bytes(),\n+                         pre_end->init_trip(),\n+                         pre_end->stride_con(),\n+                         iv_stride()\n+                         DEBUG_ONLY(COMMA is_trace_align_vector()));\n+  return solver.solve();\n+}\n+\n+\/\/ Ensure all packs are aligned, if AlignVector is on.\n+\/\/ Find an alignment solution: find the set of pre_iter that memory align all packs.\n+\/\/ Start with the maximal set (pre_iter >= 0) and filter it with the constraints\n+\/\/ that the packs impose. Remove packs that do not have a compatible solution.\n+void SuperWord::filter_packs_for_alignment() {\n+  \/\/ We do not need to filter if no alignment is required.\n+  if (!vectors_should_be_aligned()) {\n+    return;\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceSuperWord || is_trace_align_vector()) {\n+    tty->print_cr(\"\\nfilter_packs_for_alignment:\");\n+  }\n+#endif\n+\n+  ResourceMark rm;\n+\n+  \/\/ Start with trivial (unconstrained) solution space\n+  AlignmentSolution const* current = new TrivialAlignmentSolution();\n+  int mem_ops_count = 0;\n+  int mem_ops_rejected = 0;\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    if (p != nullptr) {\n+      if (p->at(0)->is_Load() || p->at(0)->is_Store()) {\n+        mem_ops_count++;\n+        \/\/ Find solution for pack p, and filter with current solution.\n+        const AlignmentSolution* s = pack_alignment_solution(p);\n+        const AlignmentSolution* intersect = current->filter(s);\n+\n+#ifndef PRODUCT\n+        if (is_trace_align_vector()) {\n+          tty->print(\"  solution for pack:         \");\n+          s->print();\n+          tty->print(\"  intersection with current: \");\n+          intersect->print();\n+        }\n+#endif\n+\n+        if (intersect->is_empty()) {\n+          \/\/ Solution failed or is not compatible, remove pack i.\n+          _packset.at_put(i, nullptr);\n+          mem_ops_rejected++;\n+        } else {\n+          \/\/ Solution is compatible.\n+          current = intersect;\n+        }\n+      }\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceSuperWord || is_trace_align_vector()) {\n+    tty->print(\"\\n final solution: \");\n+    current->print();\n+    tty->print_cr(\" rejected mem_ops packs: %d of %d\", mem_ops_rejected, mem_ops_count);\n+    tty->cr();\n+  }\n+#endif\n+\n+  assert(!current->is_empty(), \"solution must be non-empty\");\n+  if (current->is_constrained()) {\n+    \/\/ Solution is constrained (not trivial)\n+    \/\/ -> must change pre-limit to achieve alignment\n+    set_align_to_ref(current->as_constrained()->mem_ref());\n+  }\n+\n+  \/\/ Remove all nullptr from packset\n+  compress_packset();\n+}\n+\n+\/\/ Compress packset, such that it has no nullptr entries\n+void SuperWord::compress_packset() {\n+  int j = 0;\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    if (p != nullptr) {\n+      _packset.at_put(j, p);\n+      j++;\n+    }\n+  }\n+  _packset.trunc_to(j);\n@@ -2496,3 +2400,1 @@\n-  \/\/ Ensure main loop's initial value is properly aligned\n-  \/\/  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0\n-  align_initial_loop_index(align_to_ref());\n+  adjust_pre_loop_limit_to_align_main_loop_vectors();\n@@ -2771,0 +2673,11 @@\n+#ifdef ASSERT\n+      \/\/ Mark Load\/Store Vector for alignment verification\n+      if (VerifyAlignVector) {\n+        if (vn->Opcode() == Op_LoadVector) {\n+          vn->as_LoadVector()->set_must_verify_alignment();\n+        } else if (vn->Opcode() == Op_StoreVector) {\n+          vn->as_StoreVector()->set_must_verify_alignment();\n+        }\n+      }\n+#endif\n+\n@@ -3556,0 +3469,16 @@\n+#define TRACE_ALIGN_VECTOR_NODE(node) { \\\n+  DEBUG_ONLY(                           \\\n+    if (is_trace_align_vector()) {      \\\n+      tty->print(\"  \" #node \": \");      \\\n+      node->dump();                     \\\n+    }                                   \\\n+  )                                     \\\n+}                                       \\\n+\n+\/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit. We memory-align\n+\/\/ the address of \"align_to_ref\" to the maximal possible vector width. We adjust the pre-loop\n+\/\/ iteration count by adjusting the pre-loop limit.\n+void SuperWord::adjust_pre_loop_limit_to_align_main_loop_vectors() {\n+  const MemNode* align_to_ref = _align_to_ref;\n+  assert(align_to_ref != nullptr, \"align_to_ref must be set\");\n+  assert(lp()->is_main_loop(), \"can only do alignment for main loop\");\n@@ -3557,11 +3486,2 @@\n-\/\/----------------------------align_initial_loop_index---------------------------\n-\/\/ Adjust pre-loop limit so that in main loop, a load\/store reference\n-\/\/ to align_to_ref will be a position zero in the vector.\n-\/\/   (iv + k) mod vector_align == 0\n-void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {\n-  assert(lp()->is_main_loop(), \"\");\n-  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n-  Node* pre_opaq1 = pre_end->limit();\n-  assert(pre_opaq1->Opcode() == Op_Opaque1, \"\");\n-  Opaque1Node* pre_opaq = (Opaque1Node*)pre_opaq1;\n-  Node* lim0 = pre_opaq->in(1);\n+  \/\/ The opaque node for the limit, where we adjust the input\n+  Opaque1Node* pre_opaq = lp()->pre_loop_end()->limit()->as_Opaque1();\n@@ -3569,1 +3489,4 @@\n-  \/\/ Where we put new limit calculations\n+  \/\/ Current pre-loop limit.\n+  Node* old_limit = pre_opaq->in(1);\n+\n+  \/\/ Where we put new limit calculations.\n@@ -3572,2 +3495,1 @@\n-  \/\/ Ensure the original loop limit is available from the\n-  \/\/ pre-loop Opaque1 node.\n+  \/\/ Ensure the original loop limit is available from the pre-loop Opaque1 node.\n@@ -3580,5 +3502,5 @@\n-  \/\/ Given:\n-  \/\/     lim0 == original pre loop limit\n-  \/\/     V == v_align (power of 2)\n-  \/\/     invar == extra invariant piece of the address expression\n-  \/\/     e == offset [ +\/- invar ]\n+  \/\/ For the main-loop, we want the address of align_to_ref to be memory aligned\n+  \/\/ with some alignment width (aw, a power of 2). When we enter the main-loop,\n+  \/\/ we know that iv is equal to the pre-loop limit. If we adjust the pre-loop\n+  \/\/ limit by executing adjust_pre_iter many extra iterations, we can change the\n+  \/\/ alignment of the address.\n@@ -3586,4 +3508,2 @@\n-  \/\/ When reassociating expressions involving '%' the basic rules are:\n-  \/\/     (a - b) % k == 0   =>  a % k == b % k\n-  \/\/ and:\n-  \/\/     (a + b) % k == 0   =>  a % k == (k - b) % k\n+  \/\/   adr = base + offset + invar + scale * iv                               (1)\n+  \/\/   adr % aw = 0                                                           (2)\n@@ -3591,5 +3511,4 @@\n-  \/\/ For stride > 0 && scale > 0,\n-  \/\/   Derive the new pre-loop limit \"lim\" such that the two constraints:\n-  \/\/     (1) lim = lim0 + N           (where N is some positive integer < V)\n-  \/\/     (2) (e + lim) % V == 0\n-  \/\/   are true.\n+  \/\/ Note, that we are defining the modulo operator \"%\" such that the remainder is\n+  \/\/ always positive, see AlignmentSolution::mod(i, q). Since we are only computing\n+  \/\/ modulo with powers of 2, we can instead simply use the last log2(q) bits of\n+  \/\/ a number i, to get \"i % q\". This is performed with a bitmask.\n@@ -3597,6 +3516,1 @@\n-  \/\/   Substituting (1) into (2),\n-  \/\/     (e + lim0 + N) % V == 0\n-  \/\/   solve for N:\n-  \/\/     N = (V - (e + lim0)) % V\n-  \/\/   substitute back into (1), so that new limit\n-  \/\/     lim = lim0 + (V - (e + lim0)) % V\n+  \/\/ The limit of the pre-loop needs to be adjusted:\n@@ -3604,8 +3518,3 @@\n-  \/\/ For stride > 0 && scale < 0\n-  \/\/   Constraints:\n-  \/\/     lim = lim0 + N\n-  \/\/     (e - lim) % V == 0\n-  \/\/   Solving for lim:\n-  \/\/     (e - lim0 - N) % V == 0\n-  \/\/     N = (e - lim0) % V\n-  \/\/     lim = lim0 + (e - lim0) % V\n+  \/\/   old_limit:       current pre-loop limit\n+  \/\/   new_limit:       new pre-loop limit\n+  \/\/   adjust_pre_iter: additional pre-loop iterations for alignment adjustment\n@@ -3613,8 +3522,2 @@\n-  \/\/ For stride < 0 && scale > 0\n-  \/\/   Constraints:\n-  \/\/     lim = lim0 - N\n-  \/\/     (e + lim) % V == 0\n-  \/\/   Solving for lim:\n-  \/\/     (e + lim0 - N) % V == 0\n-  \/\/     N = (e + lim0) % V\n-  \/\/     lim = lim0 - (e + lim0) % V\n+  \/\/ We want to find adjust_pre_iter, such that the address is aligned when entering\n+  \/\/ the main-loop:\n@@ -3622,23 +3525,173 @@\n-  \/\/ For stride < 0 && scale < 0\n-  \/\/   Constraints:\n-  \/\/     lim = lim0 - N\n-  \/\/     (e - lim) % V == 0\n-  \/\/   Solving for lim:\n-  \/\/     (e - lim0 + N) % V == 0\n-  \/\/     N = (V - (e - lim0)) % V\n-  \/\/     lim = lim0 - (V - (e - lim0)) % V\n-\n-  int vw = vector_width_in_bytes(align_to_ref);\n-  int stride   = iv_stride();\n-  int scale    = align_to_ref_p.scale_in_bytes();\n-  int elt_size = align_to_ref_p.memory_size();\n-  int v_align  = vw \/ elt_size;\n-  assert(v_align > 1, \"sanity\");\n-  int offset   = align_to_ref_p.offset_in_bytes() \/ elt_size;\n-  Node *offsn  = _igvn.intcon(offset);\n-\n-  Node *e = offsn;\n-  if (align_to_ref_p.invar() != nullptr) {\n-    \/\/ incorporate any extra invariant piece producing (offset +\/- invar) >>> log2(elt)\n-    Node* log2_elt = _igvn.intcon(exact_log2(elt_size));\n-    Node* invar = align_to_ref_p.invar();\n+  \/\/   iv = new_limit = old_limit + adjust_pre_iter                           (3a, stride > 0)\n+  \/\/   iv = new_limit = old_limit - adjust_pre_iter                           (3b, stride < 0)\n+  \/\/\n+  \/\/ We define boi as:\n+  \/\/\n+  \/\/   boi = base + offset + invar                                            (4)\n+  \/\/\n+  \/\/ And now we can simplify the address using (1), (3), and (4):\n+  \/\/\n+  \/\/   adr = boi + scale * new_limit\n+  \/\/   adr = boi + scale * (old_limit + adjust_pre_iter)                      (5a, stride > 0)\n+  \/\/   adr = boi + scale * (old_limit - adjust_pre_iter)                      (5b, stride < 0)\n+  \/\/\n+  \/\/ And hence we can restate (2) with (5), and solve the equation for adjust_pre_iter:\n+  \/\/\n+  \/\/   (boi + scale * (old_limit + adjust_pre_iter) % aw = 0                  (6a, stride > 0)\n+  \/\/   (boi + scale * (old_limit - adjust_pre_iter) % aw = 0                  (6b, stride < 0)\n+  \/\/\n+  \/\/ In most cases, scale is the element size, for example:\n+  \/\/\n+  \/\/   for (i = 0; i < a.length; i++) { a[i] = ...; }\n+  \/\/\n+  \/\/ It is thus reasonable to assume that both abs(scale) and abs(stride) are\n+  \/\/ strictly positive powers of 2. Further, they can be assumed to be non-zero,\n+  \/\/ otherwise the address does not depend on iv, and the alignment cannot be\n+  \/\/ affected by adjusting the pre-loop limit.\n+  \/\/\n+  \/\/ Further, if abs(scale) >= aw, then adjust_pre_iter has no effect on alignment, and\n+  \/\/ we are not able to affect the alignment at all. Hence, we require abs(scale) < aw.\n+  \/\/\n+  \/\/ Moreover, for alignment to be achievable, boi must be a multiple of scale. If strict\n+  \/\/ alignment is required (i.e. -XX:+AlignVector), this is guaranteed by the filtering\n+  \/\/ done with the AlignmentSolver \/ AlignmentSolution. If strict alignment is not\n+  \/\/ required, then alignment is still preferable for performance, but not necessary.\n+  \/\/ In many cases boi will be a multiple of scale, but if it is not, then the adjustment\n+  \/\/ does not guarantee alignment, but the code is still correct.\n+  \/\/\n+  \/\/ Hence, in what follows we assume that boi is a multiple of scale, and in fact all\n+  \/\/ terms in (6) are multiples of scale. Therefore we divide all terms by scale:\n+  \/\/\n+  \/\/   AW = aw \/ abs(scale)            (power of 2)                           (7)\n+  \/\/   BOI = boi \/ abs(scale)                                                 (8)\n+  \/\/\n+  \/\/ and restate (6), using (7) and (8), i.e. we divide (6) by abs(scale):\n+  \/\/\n+  \/\/   (BOI + sign(scale) * (old_limit + adjust_pre_iter) % AW = 0           (9a, stride > 0)\n+  \/\/   (BOI + sign(scale) * (old_limit - adjust_pre_iter) % AW = 0           (9b, stride < 0)\n+  \/\/\n+  \/\/   where: sign(scale) = scale \/ abs(scale) = (scale > 0 ? 1 : -1)\n+  \/\/\n+  \/\/ Note, (9) allows for periodic solutions of adjust_pre_iter, with periodicity AW.\n+  \/\/ But we would like to spend as few iterations in the pre-loop as possible,\n+  \/\/ hence we want the smallest adjust_pre_iter, and so:\n+  \/\/\n+  \/\/   0 <= adjust_pre_iter < AW                                              (10)\n+  \/\/\n+  \/\/ We solve (9) for adjust_pre_iter, in the following 4 cases:\n+  \/\/\n+  \/\/ Case A: scale > 0 && stride > 0 (i.e. sign(scale) =  1)\n+  \/\/   (BOI + old_limit + adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (-BOI - old_limit) % AW                              (11a)\n+  \/\/\n+  \/\/ Case B: scale < 0 && stride > 0 (i.e. sign(scale) = -1)\n+  \/\/   (BOI - old_limit - adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (BOI - old_limit) % AW                               (11b)\n+  \/\/\n+  \/\/ Case C: scale > 0 && stride < 0 (i.e. sign(scale) =  1)\n+  \/\/   (BOI + old_limit - adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (BOI + old_limit) % AW                               (11c)\n+  \/\/\n+  \/\/ Case D: scale < 0 && stride < 0 (i.e. sign(scale) = -1)\n+  \/\/   (BOI - old_limit + adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (-BOI + old_limit) % AW                              (11d)\n+  \/\/\n+  \/\/ We now generalize the equations (11*) by using:\n+  \/\/\n+  \/\/   OP:   (stride         > 0) ? SUB   : ADD\n+  \/\/   XBOI: (stride * scale > 0) ? -BOI  : BOI\n+  \/\/\n+  \/\/ which gives us the final pre-loop limit adjustment:\n+  \/\/\n+  \/\/   adjust_pre_iter = (XBOI OP old_limit) % AW                             (12)\n+  \/\/\n+  \/\/ We can construct XBOI by additionally defining:\n+  \/\/\n+  \/\/   xboi = (stride * scale > 0) ? -boi              : boi                  (13)\n+  \/\/\n+  \/\/ which gives us:\n+  \/\/\n+  \/\/   XBOI = (stride * scale > 0) ? -BOI              : BOI\n+  \/\/        = (stride * scale > 0) ? -boi \/ abs(scale) : boi \/ abs(scale)\n+  \/\/        = xboi \/ abs(scale)                                               (14)\n+  \/\/\n+  \/\/ When we have computed adjust_pre_iter, we update the pre-loop limit\n+  \/\/ with (3a, b). However, we have to make sure that the adjust_pre_iter\n+  \/\/ additional pre-loop iterations do not lead the pre-loop to execute\n+  \/\/ iterations that would step over the original limit (orig_limit) of\n+  \/\/ the loop. Hence, we must constrain the updated limit as follows:\n+  \/\/\n+  \/\/ constrained_limit = MIN(old_limit + adjust_pre_iter, orig_limit)\n+  \/\/                   = MIN(new_limit,                   orig_limit)         (15a, stride > 0)\n+  \/\/ constrained_limit = MAX(old_limit - adjust_pre_iter, orig_limit)\n+  \/\/                   = MAX(new_limit,                   orig_limit)         (15a, stride < 0)\n+\n+  \/\/ We chose an aw that is the maximal possible vector width for the type of\n+  \/\/ align_to_ref.\n+  const int aw       = vector_width_in_bytes(align_to_ref);\n+  const int stride   = iv_stride();\n+  const int scale    = align_to_ref_p.scale_in_bytes();\n+  const int offset   = align_to_ref_p.offset_in_bytes();\n+  Node* base         = align_to_ref_p.adr();\n+  Node* invar        = align_to_ref_p.invar();\n+\n+#ifdef ASSERT\n+  if (is_trace_align_vector()) {\n+    tty->print_cr(\"\\nadjust_pre_loop_limit_to_align_main_loop_vectors:\");\n+    tty->print(\"  align_to_ref:\");\n+    align_to_ref->dump();\n+    tty->print_cr(\"  aw:       %d\", aw);\n+    tty->print_cr(\"  stride:   %d\", stride);\n+    tty->print_cr(\"  scale:    %d\", scale);\n+    tty->print_cr(\"  offset:   %d\", offset);\n+    tty->print(\"  base:\");\n+    base->dump();\n+    if (invar == nullptr) {\n+      tty->print_cr(\"  invar:     null\");\n+    } else {\n+      tty->print(\"  invar:\");\n+      invar->dump();\n+    }\n+    tty->print(\"  old_limit: \");\n+    old_limit->dump();\n+    tty->print(\"  orig_limit: \");\n+    orig_limit->dump();\n+  }\n+#endif\n+\n+  if (stride == 0 || !is_power_of_2(abs(stride)) ||\n+      scale  == 0 || !is_power_of_2(abs(scale))  ||\n+      abs(scale) >= aw) {\n+#ifdef ASSERT\n+    if (is_trace_align_vector()) {\n+      tty->print_cr(\" Alignment cannot be affected by changing pre-loop limit because\");\n+      tty->print_cr(\" stride or scale are not power of 2, or abs(scale) >= aw.\");\n+    }\n+#endif\n+    \/\/ Cannot affect alignment, abort.\n+    return;\n+  }\n+\n+  assert(stride != 0 && is_power_of_2(abs(stride)) &&\n+         scale  != 0 && is_power_of_2(abs(scale))  &&\n+         abs(scale) < aw, \"otherwise we cannot affect alignment with pre-loop\");\n+\n+  const int AW = aw \/ abs(scale);\n+\n+#ifdef ASSERT\n+  if (is_trace_align_vector()) {\n+    tty->print_cr(\"  AW = aw(%d) \/ abs(scale(%d)) = %d\", aw, scale, AW);\n+  }\n+#endif\n+\n+  \/\/ 1: Compute (13a, b):\n+  \/\/    xboi = -boi = (-base - offset - invar)         (stride * scale > 0)\n+  \/\/    xboi = +boi = (+base + offset + invar)         (stride * scale < 0)\n+  const bool is_sub = scale * stride > 0;\n+\n+  \/\/ 1.1: offset\n+  Node* xboi = _igvn.intcon(is_sub ? -offset : offset);\n+  TRACE_ALIGN_VECTOR_NODE(xboi);\n+\n+  \/\/ 1.2: invar (if it exists)\n+  if (invar != nullptr) {\n@@ -3651,0 +3704,6 @@\n+      TRACE_ALIGN_VECTOR_NODE(invar);\n+   }\n+    if (is_sub) {\n+      xboi = new SubINode(xboi, invar);\n+    } else {\n+      xboi = new AddINode(xboi, invar);\n@@ -3652,6 +3711,3 @@\n-    Node* aref = new URShiftINode(invar, log2_elt);\n-    _igvn.register_new_node_with_optimizer(aref);\n-    _phase->set_ctrl(aref, pre_ctrl);\n-    e =  new AddINode(e, aref);\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n+    _igvn.register_new_node_with_optimizer(xboi);\n+    _phase->set_ctrl(xboi, pre_ctrl);\n+    TRACE_ALIGN_VECTOR_NODE(xboi);\n@@ -3659,3 +3715,7 @@\n-  if (vw > ObjectAlignmentInBytes || align_to_ref_p.base()->is_top()) {\n-    \/\/ incorporate base e +\/- base && Mask >>> log2(elt)\n-    Node* xbase = new CastP2XNode(nullptr, align_to_ref_p.adr());\n+\n+  \/\/ 1.3: base (unless base is guaranteed aw aligned)\n+  if (aw > ObjectAlignmentInBytes || align_to_ref_p.base()->is_top()) {\n+    \/\/ The base is only aligned with ObjectAlignmentInBytes with arrays.\n+    \/\/ When the base() is top, we have no alignment guarantee at all.\n+    \/\/ Hence, we must now take the base into account for the calculation.\n+    Node* xbase = new CastP2XNode(nullptr, base);\n@@ -3663,0 +3723,1 @@\n+    TRACE_ALIGN_VECTOR_NODE(xbase);\n@@ -3666,0 +3727,1 @@\n+    TRACE_ALIGN_VECTOR_NODE(xbase);\n@@ -3667,15 +3729,27 @@\n-    Node* mask = _igvn.intcon(vw-1);\n-    Node* masked_xbase  = new AndINode(xbase, mask);\n-    _igvn.register_new_node_with_optimizer(masked_xbase);\n-    Node* log2_elt = _igvn.intcon(exact_log2(elt_size));\n-    Node* bref     = new URShiftINode(masked_xbase, log2_elt);\n-    _igvn.register_new_node_with_optimizer(bref);\n-    _phase->set_ctrl(bref, pre_ctrl);\n-    e = new AddINode(e, bref);\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n-  }\n-\n-  \/\/ compute e +\/- lim0\n-  if (scale < 0) {\n-    e = new SubINode(e, lim0);\n+    if (is_sub) {\n+      xboi = new SubINode(xboi, xbase);\n+    } else {\n+      xboi = new AddINode(xboi, xbase);\n+    }\n+    _igvn.register_new_node_with_optimizer(xboi);\n+    _phase->set_ctrl(xboi, pre_ctrl);\n+    TRACE_ALIGN_VECTOR_NODE(xboi);\n+  }\n+\n+  \/\/ 2: Compute (14):\n+  \/\/    XBOI = xboi \/ abs(scale)\n+  \/\/    The division is executed as shift\n+  Node* log2_abs_scale = _igvn.intcon(exact_log2(abs(scale)));\n+  Node* XBOI = new URShiftINode(xboi, log2_abs_scale);\n+  _igvn.register_new_node_with_optimizer(XBOI);\n+  _phase->set_ctrl(XBOI, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(log2_abs_scale);\n+  TRACE_ALIGN_VECTOR_NODE(XBOI);\n+\n+  \/\/ 3: Compute (12):\n+  \/\/    adjust_pre_iter = (XBOI OP old_limit) % AW\n+  \/\/\n+  \/\/ 3.1: XBOI_OP_old_limit = XBOI OP old_limit\n+  Node* XBOI_OP_old_limit = nullptr;\n+  if (stride > 0) {\n+    XBOI_OP_old_limit = new SubINode(XBOI, old_limit);\n@@ -3683,21 +3757,23 @@\n-    e = new AddINode(e, lim0);\n-  }\n-  _igvn.register_new_node_with_optimizer(e);\n-  _phase->set_ctrl(e, pre_ctrl);\n-\n-  if (stride * scale > 0) {\n-    \/\/ compute V - (e +\/- lim0)\n-    Node* va  = _igvn.intcon(v_align);\n-    e = new SubINode(va, e);\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n-  }\n-  \/\/ compute N = (exp) % V\n-  Node* va_msk = _igvn.intcon(v_align - 1);\n-  Node* N = new AndINode(e, va_msk);\n-  _igvn.register_new_node_with_optimizer(N);\n-  _phase->set_ctrl(N, pre_ctrl);\n-\n-  \/\/   substitute back into (1), so that new limit\n-  \/\/     lim = lim0 + N\n-  Node* lim;\n+    XBOI_OP_old_limit = new AddINode(XBOI, old_limit);\n+  }\n+  _igvn.register_new_node_with_optimizer(XBOI_OP_old_limit);\n+  _phase->set_ctrl(XBOI_OP_old_limit, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(XBOI_OP_old_limit);\n+\n+  \/\/ 3.2: Compute:\n+  \/\/    adjust_pre_iter = (XBOI OP old_limit) % AW\n+  \/\/                    = XBOI_OP_old_limit % AW\n+  \/\/                    = XBOI_OP_old_limit AND (AW - 1)\n+  \/\/    Since AW is a power of 2, the modulo operation can be replaced with\n+  \/\/    a bitmask operation.\n+  Node* mask_AW = _igvn.intcon(AW-1);\n+  Node* adjust_pre_iter = new AndINode(XBOI_OP_old_limit, mask_AW);\n+  _igvn.register_new_node_with_optimizer(adjust_pre_iter);\n+  _phase->set_ctrl(adjust_pre_iter, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(mask_AW);\n+  TRACE_ALIGN_VECTOR_NODE(adjust_pre_iter);\n+\n+  \/\/ 4: Compute (3a, b):\n+  \/\/    new_limit = old_limit + adjust_pre_iter     (stride > 0)\n+  \/\/    new_limit = old_limit - adjust_pre_iter     (stride < 0)\n+  Node* new_limit = nullptr;\n@@ -3705,1 +3781,1 @@\n-    lim = new SubINode(lim0, N);\n+    new_limit = new SubINode(old_limit, adjust_pre_iter);\n@@ -3707,10 +3783,17 @@\n-    lim = new AddINode(lim0, N);\n-  }\n-  _igvn.register_new_node_with_optimizer(lim);\n-  _phase->set_ctrl(lim, pre_ctrl);\n-  Node* constrained =\n-    (stride > 0) ? (Node*) new MinINode(lim, orig_limit)\n-                 : (Node*) new MaxINode(lim, orig_limit);\n-  _igvn.register_new_node_with_optimizer(constrained);\n-  _phase->set_ctrl(constrained, pre_ctrl);\n-  _igvn.replace_input_of(pre_opaq, 1, constrained);\n+    new_limit = new AddINode(old_limit, adjust_pre_iter);\n+  }\n+  _igvn.register_new_node_with_optimizer(new_limit);\n+  _phase->set_ctrl(new_limit, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(new_limit);\n+\n+  \/\/ 5: Compute (15a, b):\n+  \/\/    Prevent pre-loop from going past the original limit of the loop.\n+  Node* constrained_limit =\n+    (stride > 0) ? (Node*) new MinINode(new_limit, orig_limit)\n+                 : (Node*) new MaxINode(new_limit, orig_limit);\n+  _igvn.register_new_node_with_optimizer(constrained_limit);\n+  _phase->set_ctrl(constrained_limit, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(constrained_limit);\n+\n+  \/\/ 6: Hack the pre-loop limit\n+  _igvn.replace_input_of(pre_opaq, 1, constrained_limit);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":471,"deletions":388,"binary":false,"changes":859,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -250,1 +250,1 @@\n-  MemNode* _align_to_ref;                \/\/ Memory reference that pre-loop will align to\n+  MemNode const* _align_to_ref;          \/\/ Memory reference that pre-loop will align to\n@@ -284,0 +284,1 @@\n+  bool     is_trace_align_vector() { return (_vector_loop_debug & 128) > 0; }\n@@ -318,1 +319,1 @@\n-  int vector_width(Node* n) {\n+  int vector_width(const Node* n) const {\n@@ -322,1 +323,1 @@\n-  int vector_width_in_bytes(Node* n) {\n+  int vector_width_in_bytes(const Node* n) const {\n@@ -327,2 +328,2 @@\n-  MemNode* align_to_ref()            { return _align_to_ref; }\n-  void  set_align_to_ref(MemNode* m) { _align_to_ref = m; }\n+  const MemNode* align_to_ref() const { return _align_to_ref; }\n+  void set_align_to_ref(const MemNode* m) { _align_to_ref = m; }\n@@ -363,2 +364,2 @@\n-  const Type* velt_type(Node* n)             { return _node_info.adr_at(bb_idx(n))->_velt_type; }\n-  BasicType velt_basic_type(Node* n)         { return velt_type(n)->array_element_basic_type(); }\n+  const Type* velt_type(const Node* n) const { return _node_info.adr_at(bb_idx(n))->_velt_type; }\n+  BasicType velt_basic_type(const Node* n) const { return velt_type(n)->array_element_basic_type(); }\n@@ -444,9 +445,0 @@\n-  \/\/ Tracing support\n-  #ifndef PRODUCT\n-  void find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment);\n-  #endif\n-  \/\/ If strict memory alignment is required (vectors_should_be_aligned), then check if\n-  \/\/ mem_ref is aligned with best_align_to_mem_ref.\n-  bool mem_ref_has_no_alignment_violation(MemNode* mem_ref, int iv_adjustment, VPointer& align_to_ref_p,\n-                                          MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n-                                          Node_List &align_to_refs);\n@@ -457,2 +449,0 @@\n-  \/\/ Can the preloop align the reference to position zero in the vector?\n-  bool ref_is_alignable(VPointer& p);\n@@ -500,0 +490,6 @@\n+  \/\/ Ensure all packs are aligned, if AlignVector is on.\n+  void filter_packs_for_alignment();\n+  \/\/ Find the set of alignment solutions for load\/store pack.\n+  const AlignmentSolution* pack_alignment_solution(Node_List* pack);\n+  \/\/ Compress packset, such that it has no nullptr entries.\n+  void compress_packset();\n@@ -547,3 +543,2 @@\n-  \/\/ Adjust pre-loop limit so that in main loop, a load\/store reference\n-  \/\/ to align_to_ref will be a position zero in the vector.\n-  void align_initial_loop_index(MemNode* align_to_ref);\n+  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n+  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,2 @@\n-VPointer::VPointer(MemNode* mem, PhaseIdealLoop* phase, IdealLoopTree* lpt,\n+VPointer::VPointer(const MemNode* mem,\n+                   PhaseIdealLoop* phase, IdealLoopTree* lpt,\n@@ -122,0 +123,16 @@\n+\/\/ Biggest detectable factor of the invariant.\n+int VPointer::invar_factor() const {\n+  Node* n = invar();\n+  if (n == nullptr) {\n+    return 0;\n+  }\n+  int opc = n->Opcode();\n+  if (opc == Op_LShiftI && n->in(2)->is_Con()) {\n+    return 1 << n->in(2)->get_int();\n+  } else if (opc == Op_LShiftL && n->in(2)->is_Con()) {\n+    return 1 << n->in(2)->get_int();\n+  }\n+  \/\/ All our best-effort has failed.\n+  return 1;\n+}\n+\n@@ -420,1 +437,1 @@\n-void VPointer::Tracer::ctor_1(Node* mem) {\n+void VPointer::Tracer::ctor_1(const Node* mem) {\n@@ -462,1 +479,1 @@\n-void VPointer::Tracer::ctor_6(Node* mem) {\n+void VPointer::Tracer::ctor_6(const Node* mem) {\n@@ -688,0 +705,487 @@\n+#endif\n+\n+\n+AlignmentSolution* AlignmentSolver::solve() const {\n+  DEBUG_ONLY( trace_start_solve(); )\n+\n+  \/\/ Out of simplicity: non power-of-2 stride not supported.\n+  if (!is_power_of_2(abs(_pre_stride))) {\n+    return new EmptyAlignmentSolution(\"non power-of-2 stride not supported\");\n+  }\n+  assert(is_power_of_2(abs(_main_stride)), \"main_stride is power of 2\");\n+  assert(_aw > 0 && is_power_of_2(_aw), \"aw must be power of 2\");\n+\n+  \/\/ Out of simplicity: non power-of-2 scale not supported.\n+  if (abs(_scale) == 0 || !is_power_of_2(abs(_scale))) {\n+    return new EmptyAlignmentSolution(\"non power-of-2 scale not supported\");\n+  }\n+\n+  \/\/ We analyze the address of mem_ref. The idea is to disassemble it into a linear\n+  \/\/ expression, where we can use the constant factors as the basis for ensuring the\n+  \/\/ alignment of vector memory accesses.\n+  \/\/\n+  \/\/ The Simple form of the address is disassembled by VPointer into:\n+  \/\/\n+  \/\/   adr = base + offset + invar + scale * iv\n+  \/\/\n+  \/\/ Where the iv can be written as:\n+  \/\/\n+  \/\/   iv = init + pre_stride * pre_iter + main_stride * main_iter\n+  \/\/\n+  \/\/ init:        value before pre-loop\n+  \/\/ pre_stride:  increment per pre-loop iteration\n+  \/\/ pre_iter:    number of pre-loop iterations (adjustable via pre-loop limit)\n+  \/\/ main_stride: increment per main-loop iteration (= pre_stride * unroll_factor)\n+  \/\/ main_iter:   number of main-loop iterations (main_iter >= 0)\n+  \/\/\n+  \/\/ In the following, we restate the Simple form of the address expression, by first\n+  \/\/ expanding the iv variable. In a second step, we reshape the expression again, and\n+  \/\/ state it as a linear expression, consisting of 6 terms.\n+  \/\/\n+  \/\/          Simple form           Expansion of iv variable                  Reshaped with constants   Comments for terms\n+  \/\/          -----------           ------------------------                  -----------------------   ------------------\n+  \/\/   adr =  base               =  base                                   =  base                      (base % aw = 0)\n+  \/\/        + offset              + offset                                  + C_const                   (sum of constant terms)\n+  \/\/        + invar               + invar_factor * var_invar                + C_invar * var_invar       (term for invariant)\n+  \/\/                          \/   + scale * init                            + C_init  * var_init        (term for variable init)\n+  \/\/        + scale * iv   -> |   + scale * pre_stride * pre_iter           + C_pre   * pre_iter        (adjustable pre-loop term)\n+  \/\/                          \\   + scale * main_stride * main_iter         + C_main  * main_iter       (main-loop term)\n+  \/\/\n+  \/\/ We describe the 6 terms:\n+  \/\/   1) The \"base\" of the address is the address of a Java object (e.g. array),\n+  \/\/      and as such ObjectAlignmentInBytes (a power of 2) aligned. We have\n+  \/\/      defined aw = MIN(vector_width, ObjectAlignmentInBytes), which is also\n+  \/\/      a power of 2. And hence we know that \"base\" is thus also aw-aligned:\n+  \/\/\n+  \/\/        base % ObjectAlignmentInBytes = 0     ==>    base % aw = 0\n+  \/\/\n+  \/\/   2) The \"C_const\" term is the sum of all constant terms. This is \"offset\",\n+  \/\/      plus \"scale * init\" if it is constant.\n+  \/\/   3) The \"C_invar * var_invar\" is the factorization of \"invar\" into a constant\n+  \/\/      and variable term. If there is no invariant, then \"C_invar\" is zero.\n+  \/\/\n+  \/\/        invar = C_invar * var_invar                                             (FAC_INVAR)\n+  \/\/\n+  \/\/   4) The \"C_init * var_init\" is the factorization of \"scale * init\" into a\n+  \/\/      constant and a variable term. If \"init\" is constant, then \"C_init\" is\n+  \/\/      zero, and \"C_const\" accounts for \"init\" instead.\n+  \/\/\n+  \/\/        scale * init = C_init * var_init + scale * C_const_init                 (FAC_INIT)\n+  \/\/        C_init       = (init is constant) ? 0    : scale\n+  \/\/        C_const_init = (init is constant) ? init : 0\n+  \/\/\n+  \/\/   5) The \"C_pre * pre_iter\" term represents how much the iv is incremented\n+  \/\/      during the \"pre_iter\" pre-loop iterations. This term can be adjusted\n+  \/\/      by changing the pre-loop limit, which defines how many pre-loop iterations\n+  \/\/      are executed. This allows us to adjust the alignment of the main-loop\n+  \/\/      memory reference.\n+  \/\/   6) The \"C_main * main_iter\" term represents how much the iv is increased\n+  \/\/      during \"main_iter\" main-loop iterations.\n+\n+  \/\/ Attribute init (i.e. _init_node) either to C_const or to C_init term.\n+  const int C_const_init = _init_node->is_ConI() ? _init_node->as_ConI()->get_int() : 0;\n+  const int C_const =      _offset + C_const_init * _scale;\n+\n+  \/\/ Set C_invar depending on if invar is present\n+  const int C_invar = (_invar == nullptr) ? 0 : abs(_invar_factor);\n+\n+  const int C_init = _init_node->is_ConI() ? 0 : _scale;\n+  const int C_pre =  _scale * _pre_stride;\n+  const int C_main = _scale * _main_stride;\n+\n+  DEBUG_ONLY( trace_reshaped_form(C_const, C_const_init, C_invar, C_init, C_pre, C_main); )\n+\n+  \/\/ We must find a pre_iter, such that adr is aw aligned: adr % aw = 0. Note, that we are defining the\n+  \/\/ modulo operator \"%\" such that the remainder is always positive, see AlignmentSolution::mod(i, q).\n+  \/\/\n+  \/\/ Since \"base % aw = 0\", we only need to ensure alignment of the other 5 terms:\n+  \/\/\n+  \/\/   (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter + C_main * main_iter) % aw = 0      (1)\n+  \/\/\n+  \/\/ Alignment must be maintained over all main-loop iterations, i.e. for any main_iter >= 0, we require:\n+  \/\/\n+  \/\/   C_main % aw = 0                                                                                           (2)\n+  \/\/\n+  const int C_main_mod_aw = AlignmentSolution::mod(C_main, _aw);\n+\n+  DEBUG_ONLY( trace_main_iteration_alignment(C_const, C_invar, C_init, C_pre, C_main, C_main_mod_aw); )\n+\n+  if (C_main_mod_aw != 0) {\n+    return new EmptyAlignmentSolution(\"EQ(2) not satisfied (cannot align across main-loop iterations)\");\n+  }\n+\n+  \/\/ In what follows, we need to show that the C_const, init and invar terms can be aligned by\n+  \/\/ adjusting the pre-loop iteration count (pre_iter), which is controlled by the pre-loop\n+  \/\/ limit.\n+  \/\/\n+  \/\/     (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw = 0                         (3)\n+  \/\/\n+  \/\/ We strengthen the constraints by splitting the equation into 3 equations, where we\n+  \/\/ want to find integer solutions for pre_iter_C_const, pre_iter_C_invar, and\n+  \/\/ pre_iter_C_init, which means that the C_const, init and invar terms can be aligned\n+  \/\/ independently:\n+  \/\/\n+  \/\/   (C_const             + C_pre * pre_iter_C_const) % aw = 0                 (4a)\n+  \/\/   (C_invar * var_invar + C_pre * pre_iter_C_invar) % aw = 0                 (4b)\n+  \/\/   (C_init  * var_init  + C_pre * pre_iter_C_init ) % aw = 0                 (4c)\n+  \/\/\n+  \/\/ We now prove that (4a, b, c) are sufficient as well as necessary to guarantee (3)\n+  \/\/ for any runtime value of var_invar and var_init (i.e. for any invar and init).\n+  \/\/ This tells us that the \"strengthening\" does not restrict the algorithm more than\n+  \/\/ necessary.\n+  \/\/\n+  \/\/ Sufficient (i.e (4a, b, c) imply (3)):\n+  \/\/\n+  \/\/   pre_iter = pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n+  \/\/\n+  \/\/ Adding up (4a, b, c):\n+  \/\/\n+  \/\/   0 = (  C_const             + C_pre * pre_iter_C_const\n+  \/\/        + C_invar * var_invar + C_pre * pre_iter_C_invar\n+  \/\/        + C_init  * var_init  + C_pre * pre_iter_C_init  ) % aw\n+  \/\/\n+  \/\/     = (  C_const + C_invar * var_invar + C_init * var_init\n+  \/\/        + C_pre * (pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init)) % aw\n+  \/\/\n+  \/\/     = (  C_const + C_invar * var_invar + C_init * var_init\n+  \/\/        + C_pre * pre_iter) % aw\n+  \/\/\n+  \/\/ Necessary (i.e. (3) implies (4a, b, c)):\n+  \/\/  (4a): Set var_invar = var_init = 0 at runtime. Applying this to (3), we get:\n+  \/\/\n+  \/\/        0 =\n+  \/\/          = (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n+  \/\/          = (C_const + C_invar * 0         + C_init * 0        + C_pre * pre_iter) % aw\n+  \/\/          = (C_const                                           + C_pre * pre_iter) % aw\n+  \/\/\n+  \/\/        This is of the same form as (4a), and we have a solution:\n+  \/\/        pre_iter_C_const = pre_iter\n+  \/\/\n+  \/\/  (4b): Set var_init = 0, and assume (4a), which we just proved is implied by (3).\n+  \/\/        Subtract (4a) from (3):\n+  \/\/\n+  \/\/        0 =\n+  \/\/          =  (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n+  \/\/           - (C_const + C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * var_invar + C_init * var_init + C_pre * pre_iter - C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * var_invar + C_init * 0        + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/          =  (C_invar * var_invar +                   + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/\n+  \/\/        This is of the same form as (4b), and we have a solution:\n+  \/\/        pre_iter_C_invar = pre_iter - pre_iter_C_const\n+  \/\/\n+  \/\/  (4c): Set var_invar = 0, and assume (4a), which we just proved is implied by (3).\n+  \/\/        Subtract (4a) from (3):\n+  \/\/\n+  \/\/        0 =\n+  \/\/          =  (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n+  \/\/           - (C_const + C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * var_invar + C_init * var_init + C_pre * pre_iter - C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * 0         + C_init * var_init + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/          =  (                    + C_init * var_init + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/\n+  \/\/        This is of the same form as (4c), and we have a solution:\n+  \/\/        pre_iter_C_invar = pre_iter - pre_iter_C_const\n+  \/\/\n+  \/\/ The solutions of Equations (4a, b, c) for pre_iter_C_const, pre_iter_C_invar, and pre_iter_C_init\n+  \/\/ respectively, can have one of these states:\n+  \/\/\n+  \/\/   trivial:     The solution can be any integer.\n+  \/\/   constrained: There is a (periodic) solution, but it is not trivial.\n+  \/\/   empty:       Statically we cannot guarantee a solution for all var_invar and var_init.\n+  \/\/\n+  \/\/ We look at (4a):\n+  \/\/\n+  \/\/   abs(C_pre) >= aw\n+  \/\/   -> Since abs(C_pre) is a power of two, we have C_pre % aw = 0. Therefore:\n+  \/\/\n+  \/\/        For any pre_iter_C_const: (C_pre * pre_iter_C_const) % aw = 0\n+  \/\/\n+  \/\/        (C_const + C_pre * pre_iter_C_const) % aw = 0\n+  \/\/         C_const                             % aw = 0\n+  \/\/\n+  \/\/      Hence, we can only satisfy (4a) if C_Const is aw aligned:\n+  \/\/\n+  \/\/      C_const % aw == 0:\n+  \/\/      -> (4a) has a trivial solution since we can choose any value for pre_iter_C_const.\n+  \/\/\n+  \/\/      C_const % aw != 0:\n+  \/\/      -> (4a) has an empty solution since no pre_iter_C_const can achieve aw alignment.\n+  \/\/\n+  \/\/   abs(C_pre) < aw:\n+  \/\/   -> Since both abs(C_pre) and aw are powers of two, we know:\n+  \/\/\n+  \/\/        There exists integer x > 1: aw = abs(C_pre) * x\n+  \/\/\n+  \/\/      C_const % abs(C_pre) == 0:\n+  \/\/      -> There exists integer z: C_const = C_pre * z\n+  \/\/\n+  \/\/          (C_const   + C_pre * pre_iter_C_const) % aw               = 0\n+  \/\/          ==>\n+  \/\/          (C_pre * z + C_pre * pre_iter_C_const) % aw               = 0\n+  \/\/          ==>\n+  \/\/          (C_pre * z + C_pre * pre_iter_C_const) % (abs(C_pre) * x) = 0\n+  \/\/          ==>\n+  \/\/          (        z +         pre_iter_C_const) %               x  = 0\n+  \/\/          ==>\n+  \/\/          for any m: pre_iter_C_const = m * x - z\n+  \/\/\n+  \/\/        Hence, pre_iter_C_const has a non-trivial (because x > 1) periodic (periodicity x)\n+  \/\/        solution, i.e. it has a constrained solution.\n+  \/\/\n+  \/\/      C_const % abs(C_pre) != 0:\n+  \/\/        There exists integer x > 1: aw = abs(C_pre) * x\n+  \/\/\n+  \/\/           C_const                             %  abs(C_pre)      != 0\n+  \/\/          ==>\n+  \/\/          (C_const + C_pre * pre_iter_C_const) %  abs(C_pre)      != 0\n+  \/\/          ==>\n+  \/\/          (C_const + C_pre * pre_iter_C_const) % (abs(C_pre) * x) != 0\n+  \/\/          ==>\n+  \/\/          (C_const + C_pre * pre_iter_C_const) % aw               != 0\n+  \/\/\n+  \/\/        This is in contradiction with (4a), and therefore there cannot be any solution,\n+  \/\/        i.e. we have an empty solution.\n+  \/\/\n+  \/\/ In summary, for (4a):\n+  \/\/\n+  \/\/   abs(C_pre) >= aw  AND  C_const % aw == 0          -> trivial\n+  \/\/   abs(C_pre) >= aw  AND  C_const % aw != 0          -> empty\n+  \/\/   abs(C_pre) <  aw  AND  C_const % abs(C_pre) == 0  -> constrained\n+  \/\/   abs(C_pre) <  aw  AND  C_const % abs(C_pre) != 0  -> empty\n+  \/\/\n+  \/\/ With analogue argumentation for (4b):\n+  \/\/\n+  \/\/   abs(C_pre) >= aw  AND  C_invar % aw == 0           -> trivial\n+  \/\/   abs(C_pre) >= aw  AND  C_invar % aw != 0           -> empty\n+  \/\/   abs(C_pre) <  aw  AND  C_invar % abs(C_pre) == 0   -> constrained\n+  \/\/   abs(C_pre) <  aw  AND  C_invar % abs(C_pre) != 0   -> empty\n+  \/\/\n+  \/\/ With analogue argumentation for (4c):\n+  \/\/\n+  \/\/   abs(C_pre) >= aw  AND  C_init  % aw == 0           -> trivial\n+  \/\/   abs(C_pre) >= aw  AND  C_init  % aw != 0           -> empty\n+  \/\/   abs(C_pre) <  aw  AND  C_init  % abs(C_pre) == 0   -> constrained\n+  \/\/   abs(C_pre) <  aw  AND  C_init  % abs(C_pre) != 0   -> empty\n+  \/\/\n+  \/\/ Out of these states follows the state for the solution of pre_iter:\n+  \/\/\n+  \/\/   Trivial:     If (4a, b, c) are all trivial.\n+  \/\/   Empty:       If any of (4a, b, c) is empty, because then we cannot guarantee a solution\n+  \/\/                for pre_iter, for all possible invar and init values.\n+  \/\/   Constrained: Else. Incidentally, (4a, b, c) are all constrained themselves, as we argue below.\n+\n+  const EQ4 eq4(C_const, C_invar, C_init, C_pre, _aw);\n+  const EQ4::State eq4a_state = eq4.eq4a_state();\n+  const EQ4::State eq4b_state = eq4.eq4b_state();\n+  const EQ4::State eq4c_state = eq4.eq4c_state();\n+\n+#ifdef ASSERT\n+  if (is_trace()) {\n+    eq4.trace();\n+  }\n+#endif\n+\n+  \/\/ If (4a, b, c) are all trivial, then also the solution for pre_iter is trivial:\n+  if (eq4a_state == EQ4::State::TRIVIAL &&\n+      eq4b_state == EQ4::State::TRIVIAL &&\n+      eq4c_state == EQ4::State::TRIVIAL) {\n+    return new TrivialAlignmentSolution();\n+  }\n+\n+  \/\/ If any of (4a, b, c) is empty, then we also cannot guarantee a solution for pre_iter, for\n+  \/\/ any init and invar, hence the solution for pre_iter is empty:\n+  if (eq4a_state == EQ4::State::EMPTY ||\n+      eq4b_state == EQ4::State::EMPTY ||\n+      eq4c_state == EQ4::State::EMPTY) {\n+    return new EmptyAlignmentSolution(\"EQ(4a, b, c) not all non-empty: cannot align const, invar and init terms individually\");\n+  }\n+\n+  \/\/ If abs(C_pre) >= aw, then the solutions to (4a, b, c) are all either trivial or empty, and\n+  \/\/ hence we would have found the solution to pre_iter above as either trivial or empty. Thus\n+  \/\/ we now know that:\n+  \/\/\n+  \/\/   abs(C_pre) < aw\n+  \/\/\n+  assert(abs(C_pre) < _aw, \"implied by constrained case\");\n+\n+  \/\/ And since abs(C_pre) < aw, the solutions of (4a, b, c) can now only be constrained or empty.\n+  \/\/ But since we already handled the empty case, the solutions are now all constrained.\n+  assert(eq4a_state == EQ4::State::CONSTRAINED &&\n+         eq4a_state == EQ4::State::CONSTRAINED &&\n+         eq4a_state == EQ4::State::CONSTRAINED, \"all must be constrained now\");\n+\n+  \/\/ And since they are all constrained, we must have:\n+  \/\/\n+  \/\/   C_const % abs(C_pre) = 0                                                  (5a)\n+  \/\/   C_invar % abs(C_pre) = 0                                                  (5b)\n+  \/\/   C_init  % abs(C_pre) = 0                                                  (5c)\n+  \/\/\n+  assert(AlignmentSolution::mod(C_const, abs(C_pre)) == 0, \"EQ(5a): C_const must be alignable\");\n+  assert(AlignmentSolution::mod(C_invar, abs(C_pre)) == 0, \"EQ(5b): C_invar must be alignable\");\n+  assert(AlignmentSolution::mod(C_init,  abs(C_pre)) == 0, \"EQ(5c): C_init  must be alignable\");\n+\n+  \/\/ With (5a, b, c), we know that there are integers X, Y, Z:\n+  \/\/\n+  \/\/   C_const = X * abs(C_pre)   ==>   X = C_const \/ abs(C_pre)                 (6a)\n+  \/\/   C_invar = Y * abs(C_pre)   ==>   Y = C_invar \/ abs(C_pre)                 (6b)\n+  \/\/   C_init  = Z * abs(C_pre)   ==>   Z = C_init  \/ abs(C_pre)                 (6c)\n+  \/\/\n+  \/\/ Further, we define:\n+  \/\/\n+  \/\/   sign(C_pre) = C_pre \/ abs(C_pre) = (C_pre > 0) ? 1 : -1,                  (7)\n+  \/\/\n+  \/\/ We know that abs(C_pre) as well as aw are powers of 2, and since (5) we can define integer q:\n+  \/\/\n+  \/\/   q = aw \/ abs(C_pre)                                                       (8)\n+  \/\/\n+  const int q = _aw \/ abs(C_pre);\n+\n+  assert(q >= 2, \"implied by constrained solution\");\n+\n+  \/\/ We now know that all terms in (4a, b, c) are divisible by abs(C_pre):\n+  \/\/\n+  \/\/   (C_const                    \/ abs(C_pre) + C_pre * pre_iter_C_const \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (X * abs(C_pre)             \/ abs(C_pre) + C_pre * pre_iter_C_const \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (X                                       +         pre_iter_C_const * sign(C_pre)) % q                 = 0  (9a)\n+  \/\/\n+  \/\/   -> pre_iter_C_const * sign(C_pre) = mx1 * q -               X\n+  \/\/   -> pre_iter_C_const               = mx2 * q - sign(C_pre) * X                                               (10a)\n+  \/\/      (for any integers mx1, mx2)\n+  \/\/\n+  \/\/   (C_invar        * var_invar \/ abs(C_pre) + C_pre * pre_iter_C_invar \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Y * abs(C_pre) * var_invar \/ abs(C_pre) + C_pre * pre_iter_C_invar \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Y              * var_invar              +         pre_iter_C_invar * sign(C_pre)) % q                 = 0  (9b)\n+  \/\/\n+  \/\/   -> pre_iter_C_invar * sign(C_pre) = my1 * q -               Y * var_invar\n+  \/\/   -> pre_iter_C_invar               = my2 * q - sign(C_pre) * Y * var_invar                                   (10b)\n+  \/\/      (for any integers my1, my2)\n+  \/\/\n+  \/\/   (C_init          * var_init  \/ abs(C_pre) + C_pre * pre_iter_C_init \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Z * abs(C_pre)  * var_init  \/ abs(C_pre) + C_pre * pre_iter_C_init \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Z * var_init                             +         pre_iter_C_init * sign(C_pre)) % q                 = 0  (9c)\n+  \/\/\n+  \/\/   -> pre_iter_C_init  * sign(C_pre) = mz1 * q -               Z * var_init\n+  \/\/   -> pre_iter_C_init                = mz2 * q - sign(C_pre) * Z * var_init                                    (10c)\n+  \/\/      (for any integers mz1, mz2)\n+  \/\/\n+  \/\/\n+  \/\/ Having solved the equations using the division, we can re-substitute X, Y, and Z, and apply (FAC_INVAR) as\n+  \/\/ well as (FAC_INIT). We use the fact that sign(x) == 1 \/ sign(x) and sign(x) * abs(x) == x:\n+  \/\/\n+  \/\/   pre_iter_C_const = mx2 * q - sign(C_pre) * X\n+  \/\/                    = mx2 * q - sign(C_pre) * C_const             \/ abs(C_pre)\n+  \/\/                    = mx2 * q - C_const \/ C_pre\n+  \/\/                    = mx2 * q - C_const \/ (scale * pre_stride)                                  (11a)\n+  \/\/\n+  \/\/ If there is an invariant:\n+  \/\/\n+  \/\/   pre_iter_C_invar = my2 * q - sign(C_pre) * Y       * var_invar\n+  \/\/                    = my2 * q - sign(C_pre) * C_invar * var_invar \/ abs(C_pre)\n+  \/\/                    = my2 * q - sign(C_pre) * invar               \/ abs(C_pre)\n+  \/\/                    = my2 * q - invar \/ C_pre\n+  \/\/                    = my2 * q - invar \/ (scale * pre_stride)                                    (11b, with invar)\n+  \/\/\n+  \/\/ If there is no invariant (i.e. C_invar = 0 ==> Y = 0):\n+  \/\/\n+  \/\/   pre_iter_C_invar = my2 * q                                                                   (11b, no invar)\n+  \/\/\n+  \/\/ If init is variable (i.e. C_init = scale, init = var_init):\n+  \/\/\n+  \/\/   pre_iter_C_init  = mz2 * q - sign(C_pre) * Z       * var_init\n+  \/\/                    = mz2 * q - sign(C_pre) * C_init  * var_init  \/ abs(C_pre)\n+  \/\/                    = mz2 * q - sign(C_pre) * scale   * init      \/ abs(C_pre)\n+  \/\/                    = mz2 * q - scale * init \/ C_pre\n+  \/\/                    = mz2 * q - scale * init \/ (scale * pre_stride)\n+  \/\/                    = mz2 * q - init \/ pre_stride                                               (11c, variable init)\n+  \/\/\n+  \/\/ If init is constant (i.e. C_init = 0 ==> Z = 0):\n+  \/\/\n+  \/\/   pre_iter_C_init  = mz2 * q                                                                   (11c, constant init)\n+  \/\/\n+  \/\/ Note, that the solutions found by (11a, b, c) are all periodic with periodicity q. We combine them,\n+  \/\/ with m = mx2 + my2 + mz2:\n+  \/\/\n+  \/\/   pre_iter =   pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n+  \/\/            =   mx2 * q  - C_const \/ (scale * pre_stride)\n+  \/\/              + my2 * q [- invar \/ (scale * pre_stride) ]\n+  \/\/              + mz2 * q [- init \/ pre_stride            ]\n+  \/\/\n+  \/\/            =   m * q                                 (periodic part)\n+  \/\/              - C_const \/ (scale * pre_stride)        (align constant term)\n+  \/\/             [- invar \/ (scale * pre_stride)   ]      (align invariant term, if present)\n+  \/\/             [- init \/ pre_stride              ]      (align variable init term, if present)    (12)\n+  \/\/\n+  \/\/ We can further simplify this solution by introducing integer 0 <= r < q:\n+  \/\/\n+  \/\/   r = (-C_const \/ (scale * pre_stride)) % q                                                    (13)\n+  \/\/\n+  const int r = AlignmentSolution::mod(-C_const \/ (_scale * _pre_stride), q);\n+  \/\/\n+  \/\/   pre_iter = m * q + r\n+  \/\/                   [- invar \/ (scale * pre_stride)  ]\n+  \/\/                   [- init \/ pre_stride             ]                                           (14)\n+  \/\/\n+  \/\/ We thus get a solution that can be stated in terms of:\n+  \/\/\n+  \/\/   q (periodicity), r (constant alignment), invar, scale, pre_stride, init\n+  \/\/\n+  \/\/ However, pre_stride and init are shared by all mem_ref in the loop, hence we do not need to provide\n+  \/\/ them in the solution description.\n+\n+  DEBUG_ONLY( trace_constrained_solution(C_const, C_invar, C_init, C_pre, q, r); )\n+\n+  return new ConstrainedAlignmentSolution(_mem_ref, q, r, _invar, _scale);\n+\n+  \/\/ APPENDIX:\n+  \/\/ We can now verify the success of the solution given by (12):\n+  \/\/\n+  \/\/   adr % aw =\n+  \/\/\n+  \/\/   -> Simple form\n+  \/\/   (base + offset + invar + scale * iv) % aw =\n+  \/\/\n+  \/\/   -> Expand iv\n+  \/\/   (base + offset + invar + scale * (init + pre_stride * pre_iter + main_stride * main_iter)) % aw =\n+  \/\/\n+  \/\/   -> Reshape\n+  \/\/   (base + offset + invar\n+  \/\/         + scale * init\n+  \/\/         + scale * pre_stride * pre_iter\n+  \/\/         + scale * main_stride * main_iter)) % aw =\n+  \/\/\n+  \/\/   -> base aligned: base % aw = 0\n+  \/\/   -> main-loop iterations aligned (2): C_main % aw = (scale * main_stride) % aw = 0\n+  \/\/   (offset + invar + scale * init + scale * pre_stride * pre_iter) % aw =\n+  \/\/\n+  \/\/   -> apply (12)\n+  \/\/   (offset + invar + scale * init\n+  \/\/           + scale * pre_stride * (m * q - C_const \/ (scale * pre_stride)\n+  \/\/                                        [- invar \/ (scale * pre_stride) ]\n+  \/\/                                        [- init \/ pre_stride            ]\n+  \/\/                                  )\n+  \/\/   ) % aw =\n+  \/\/\n+  \/\/   -> expand C_const = offset [+ init * scale]  (if init const)\n+  \/\/   (offset + invar + scale * init\n+  \/\/           + scale * pre_stride * (m * q - offset \/ (scale * pre_stride)\n+  \/\/                                        [- init \/ pre_stride            ]             (if init constant)\n+  \/\/                                        [- invar \/ (scale * pre_stride) ]             (if invar present)\n+  \/\/                                        [- init \/ pre_stride            ]             (if init variable)\n+  \/\/                                  )\n+  \/\/   ) % aw =\n+  \/\/\n+  \/\/   -> assuming invar = 0 if it is not present\n+  \/\/   -> merge the two init terms (variable or constant)\n+  \/\/   -> apply (8): q = aw \/ (abs(C_pre)) = aw \/ abs(scale * pre_stride)\n+  \/\/   -> and hence: (scale * pre_stride * q) % aw = 0\n+  \/\/   -> all terms are canceled out\n+  \/\/   (offset + invar + scale * init\n+  \/\/           + scale * pre_stride * m * q                             -> aw aligned\n+  \/\/           - scale * pre_stride * offset \/ (scale * pre_stride)     -> = offset\n+  \/\/           - scale * pre_stride * init \/ pre_stride                 -> = scale * init\n+  \/\/           - scale * pre_stride * invar \/ (scale * pre_stride)      -> = invar\n+  \/\/   ) % aw = 0\n+  \/\/\n+  \/\/ The solution given by (12) does indeed guarantee alignment.\n+}\n@@ -689,0 +1193,163 @@\n+#ifdef ASSERT\n+void print_con_or_idx(const Node* n) {\n+  if (n == nullptr) {\n+    tty->print(\"(0)\");\n+  } else if (n->is_ConI()) {\n+    jint val = n->as_ConI()->get_int();\n+    tty->print(\"(%d)\", val);\n+  } else {\n+    tty->print(\"[%d]\", n->_idx);\n+  }\n+}\n+\n+void AlignmentSolver::trace_start_solve() const {\n+  if (is_trace()) {\n+    tty->print(\" vector mem_ref:\");\n+    _mem_ref->dump();\n+    tty->print_cr(\"  vector_width = vector_length(%d) * element_size(%d) = %d\",\n+                  _vector_length, _element_size, _vector_width);\n+    tty->print_cr(\"  aw = alignment_width = min(vector_width(%d), ObjectAlignmentInBytes(%d)) = %d\",\n+                  _vector_width, ObjectAlignmentInBytes, _aw);\n+\n+    if (!_init_node->is_ConI()) {\n+      tty->print(\"  init:\");\n+      _init_node->dump();\n+    }\n+\n+    if (_invar != nullptr) {\n+      tty->print(\"  invar:\");\n+      _invar->dump();\n+    }\n+\n+    tty->print_cr(\"  invar_factor = %d\", _invar_factor);\n+\n+    \/\/ iv = init + pre_iter * pre_stride + main_iter * main_stride\n+    tty->print(\"  iv = init\");\n+    print_con_or_idx(_init_node);\n+    tty->print_cr(\" + pre_iter * pre_stride(%d) + main_iter * main_stride(%d)\",\n+                  _pre_stride, _main_stride);\n+\n+    \/\/ adr = base + offset + invar + scale * iv\n+    tty->print(\"  adr = base\");\n+    print_con_or_idx(_base);\n+    tty->print(\" + offset(%d) + invar\", _offset);\n+    print_con_or_idx(_invar);\n+    tty->print_cr(\" + scale(%d) * iv\", _scale);\n+  }\n+}\n+\n+void AlignmentSolver::trace_reshaped_form(const int C_const,\n+                                          const int C_const_init,\n+                                          const int C_invar,\n+                                          const int C_init,\n+                                          const int C_pre,\n+                                          const int C_main) const\n+{\n+  if (is_trace()) {\n+    tty->print(\"      = base[%d] + \", _base->_idx);\n+    tty->print_cr(\"C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init + C_pre(%d) * pre_iter + C_main(%d) * main_iter\",\n+                  C_const, C_invar, C_init,  C_pre, C_main);\n+    if (_init_node->is_ConI()) {\n+      tty->print_cr(\"  init is constant:\");\n+      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n+      tty->print_cr(\"    C_init = %d\", C_init);\n+    } else {\n+      tty->print_cr(\"  init is variable:\");\n+      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n+      tty->print_cr(\"    C_init = abs(scale)= %d\", C_init);\n+    }\n+    if (_invar != nullptr) {\n+      tty->print_cr(\"  invariant present:\");\n+      tty->print_cr(\"    C_invar = abs(invar_factor) = %d\", C_invar);\n+    } else {\n+      tty->print_cr(\"  no invariant:\");\n+      tty->print_cr(\"    C_invar = %d\", C_invar);\n+    }\n+    tty->print_cr(\"  C_const = offset(%d) + scale(%d) * C_const_init(%d) = %d\",\n+                  _offset, _scale, C_const_init, C_const);\n+    tty->print_cr(\"  C_pre   = scale(%d) * pre_stride(%d) = %d\",\n+                  _scale, _pre_stride, C_pre);\n+    tty->print_cr(\"  C_main  = scale(%d) * main_stride(%d) = %d\",\n+                  _scale, _main_stride, C_main);\n+  }\n+}\n+\n+void AlignmentSolver::trace_main_iteration_alignment(const int C_const,\n+                                                     const int C_invar,\n+                                                     const int C_init,\n+                                                     const int C_pre,\n+                                                     const int C_main,\n+                                                     const int C_main_mod_aw) const\n+{\n+  if (is_trace()) {\n+    tty->print(\"  EQ(1 ): (C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init\",\n+                  C_const, C_invar, C_init);\n+    tty->print(\" + C_pre(%d) * pre_iter + C_main(%d) * main_iter) %% aw(%d) = 0\",\n+                  C_pre, C_main, _aw);\n+    tty->print_cr(\" (given base aligned -> align rest)\");\n+    tty->print(\"  EQ(2 ): C_main(%d) %% aw(%d) = %d = 0\",\n+               C_main, _aw, C_main_mod_aw);\n+    tty->print_cr(\" (alignment across iterations)\");\n+  }\n+}\n+\n+void AlignmentSolver::EQ4::trace() const {\n+  tty->print_cr(\"  EQ(4a): (C_const(%3d)             + C_pre(%d) * pre_iter_C_const) %% aw(%d) = 0  (align const term individually)\",\n+                _C_const, _C_pre, _aw);\n+  tty->print_cr(\"          -> %s\", state_to_str(eq4a_state()));\n+\n+  tty->print_cr(\"  EQ(4b): (C_invar(%3d) * var_invar + C_pre(%d) * pre_iter_C_invar) %% aw(%d) = 0  (align invar term individually)\",\n+                _C_invar, _C_pre, _aw);\n+  tty->print_cr(\"          -> %s\", state_to_str(eq4b_state()));\n+\n+  tty->print_cr(\"  EQ(4c): (C_init( %3d) * var_init  + C_pre(%d) * pre_iter_C_init ) %% aw(%d) = 0  (align init term individually)\",\n+                _C_init, _C_pre, _aw);\n+  tty->print_cr(\"          -> %s\", state_to_str(eq4c_state()));\n+}\n+\n+void AlignmentSolver::trace_constrained_solution(const int C_const,\n+                                                 const int C_invar,\n+                                                 const int C_init,\n+                                                 const int C_pre,\n+                                                 const int q,\n+                                                 const int r) const\n+{\n+  if (is_trace()) {\n+    tty->print_cr(\"  EQ(4a, b, c) all constrained, hence:\");\n+    tty->print_cr(\"  EQ(5a): C_const(%3d) %% abs(C_pre(%d)) = 0\", C_const, C_pre);\n+    tty->print_cr(\"  EQ(5b): C_invar(%3d) %% abs(C_pre(%d)) = 0\", C_invar, C_pre);\n+    tty->print_cr(\"  EQ(5c): C_init( %3d) %% abs(C_pre(%d)) = 0\", C_init,  C_pre);\n+\n+    tty->print_cr(\"  All terms in EQ(4a, b, c) are divisible by abs(C_pre(%d)).\", C_pre);\n+    const int X    = C_const \/ abs(C_pre);\n+    const int Y    = C_invar \/ abs(C_pre);\n+    const int Z    = C_init  \/ abs(C_pre);\n+    const int sign = (C_pre > 0) ? 1 : -1;\n+    tty->print_cr(\"  X = C_const(%3d) \/ abs(C_pre(%d)) = %d       (6a)\", C_const, C_pre, X);\n+    tty->print_cr(\"  Y = C_invar(%3d) \/ abs(C_pre(%d)) = %d       (6b)\", C_invar, C_pre, Y);\n+    tty->print_cr(\"  Z = C_init( %3d) \/ abs(C_pre(%d)) = %d       (6c)\", C_init , C_pre, Z);\n+    tty->print_cr(\"  q = aw(     %3d) \/ abs(C_pre(%d)) = %d       (8)\",  _aw,     C_pre, q);\n+    tty->print_cr(\"  sign(C_pre) = (C_pre(%d) > 0) ? 1 : -1 = %d  (7)\",  C_pre,   sign);\n+\n+    tty->print_cr(\"  EQ(9a): (X(%3d)             + pre_iter_C_const * sign(C_pre)) %% q(%d) = 0\", X, q);\n+    tty->print_cr(\"  EQ(9b): (Y(%3d) * var_invar + pre_iter_C_invar * sign(C_pre)) %% q(%d) = 0\", Y, q);\n+    tty->print_cr(\"  EQ(9c): (Z(%3d) * var_init  + pre_iter_C_init  * sign(C_pre)) %% q(%d) = 0\", Z, q);\n+\n+    tty->print_cr(\"  EQ(10a): pre_iter_C_const = mx2 * q(%d) - sign(C_pre) * X(%d)\",             q, X);\n+    tty->print_cr(\"  EQ(10b): pre_iter_C_invar = my2 * q(%d) - sign(C_pre) * Y(%d) * var_invar\", q, Y);\n+    tty->print_cr(\"  EQ(10c): pre_iter_C_init  = mz2 * q(%d) - sign(C_pre) * Z(%d) * var_init \", q, Z);\n+\n+    tty->print_cr(\"  r = (-C_const(%d) \/ (scale(%d) * pre_stride(%d)) %% q(%d) = %d\",\n+                  C_const, _scale, _pre_stride, q, r);\n+\n+    tty->print_cr(\"  EQ(14):  pre_iter = m * q(%3d) - r(%d)\", q, r);\n+    if (_invar != nullptr) {\n+      tty->print_cr(\"                                 - invar \/ (scale(%d) * pre_stride(%d))\",\n+                    _scale, _pre_stride);\n+    }\n+    if (!_init_node->is_ConI()) {\n+      tty->print_cr(\"                                 - init \/ pre_stride(%d)\",\n+                    _pre_stride);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":671,"deletions":4,"binary":false,"changes":675,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  MemNode*        _mem;      \/\/ My memory reference node\n+  const MemNode*  _mem;      \/\/ My memory reference node\n@@ -83,2 +83,3 @@\n-  VPointer(MemNode* mem, PhaseIdealLoop* phase, IdealLoopTree* lpt,\n-            Node_Stack* nstack, bool analyze_only);\n+  VPointer(const MemNode* mem,\n+           PhaseIdealLoop* phase, IdealLoopTree* lpt,\n+           Node_Stack* nstack, bool analyze_only);\n@@ -89,2 +90,2 @@\n-  bool valid()  { return _adr != nullptr; }\n-  bool has_iv() { return _scale != 0; }\n+  bool valid()             const { return _adr != nullptr; }\n+  bool has_iv()            const { return _scale != 0; }\n@@ -92,8 +93,11 @@\n-  Node* base()             { return _base; }\n-  Node* adr()              { return _adr; }\n-  MemNode* mem()           { return _mem; }\n-  int   scale_in_bytes()   { return _scale; }\n-  Node* invar()            { return _invar; }\n-  int   offset_in_bytes()  { return _offset; }\n-  int   memory_size()      { return _mem->memory_size(); }\n-  Node_Stack* node_stack() { return _nstack; }\n+  Node* base()             const { return _base; }\n+  Node* adr()              const { return _adr; }\n+  const MemNode* mem()     const { return _mem; }\n+  int   scale_in_bytes()   const { return _scale; }\n+  Node* invar()            const { return _invar; }\n+  int   offset_in_bytes()  const { return _offset; }\n+  int   memory_size()      const { return _mem->memory_size(); }\n+  Node_Stack* node_stack() const { return _nstack; }\n+\n+  \/\/ Biggest detectable factor of the invariant.\n+  int   invar_factor() const;\n@@ -168,1 +172,1 @@\n-    void ctor_1(Node* mem);\n+    void ctor_1(const Node* mem);\n@@ -173,1 +177,1 @@\n-    void ctor_6(Node* mem);\n+    void ctor_6(const Node* mem);\n@@ -262,0 +266,415 @@\n+\/\/ When alignment is required, we must adjust the pre-loop iteration count pre_iter,\n+\/\/ such that the address is aligned for any main_iter >= 0:\n+\/\/\n+\/\/   adr = base + offset + invar + scale * init\n+\/\/                               + scale * pre_stride * pre_iter\n+\/\/                               + scale * main_stride * main_iter\n+\/\/\n+\/\/ The AlignmentSolver generates solutions of the following forms:\n+\/\/   1. Empty:       No pre_iter guarantees alignment.\n+\/\/   2. Trivial:     Any pre_iter guarantees alignment.\n+\/\/   3. Constrained: There is a periodic solution, but it is not trivial.\n+\/\/\n+\/\/ The Constrained solution is of the following form:\n+\/\/\n+\/\/   pre_iter = m * q + r                                    (for any integer m)\n+\/\/                   [- invar \/ (scale * pre_stride)  ]      (if there is an invariant)\n+\/\/                   [- init \/ pre_stride             ]      (if init is variable)\n+\/\/\n+\/\/ The solution is periodic with periodicity q, which is guaranteed to be a power of 2.\n+\/\/ This periodic solution is \"rotated\" by three alignment terms: one for constants (r),\n+\/\/ one for the invariant (if present), and one for init (if it is variable).\n+\/\/\n+\/\/ The \"filter\" method combines the solutions of two mem_refs, such that the new set of\n+\/\/ values for pre_iter guarantees alignment for both mem_refs.\n+\/\/\n+class EmptyAlignmentSolution;\n+class TrivialAlignmentSolution;\n+class ConstrainedAlignmentSolution;\n+\n+class AlignmentSolution : public ResourceObj {\n+public:\n+  virtual bool is_empty() const = 0;\n+  virtual bool is_trivial() const = 0;\n+  virtual bool is_constrained() const = 0;\n+\n+  virtual const ConstrainedAlignmentSolution* as_constrained() const {\n+    assert(is_constrained(), \"must be constrained\");\n+    return nullptr;\n+  }\n+\n+  \/\/ Implemented by each subclass\n+  virtual const AlignmentSolution* filter(const AlignmentSolution* other) const = 0;\n+  virtual void print() const = 0;\n+\n+  \/\/ Compute modulo and ensure that we get a positive remainder\n+  static int mod(int i, int q) {\n+    assert(q >= 1, \"modulo value must be large enough\");\n+\n+    \/\/ Modulo operator: Get positive 0 <= r < q  for positive i, but\n+    \/\/                  get negative 0 >= r > -q for negative i.\n+    int r = i % q;\n+\n+    \/\/ Make negative r into positive ones:\n+    r = (r >= 0) ? r : r + q;\n+\n+    assert(0 <= r && r < q, \"remainder must fit in modulo space\");\n+    return r;\n+  }\n+};\n+\n+class EmptyAlignmentSolution : public AlignmentSolution {\n+private:\n+  const char* _reason;\n+public:\n+  EmptyAlignmentSolution(const char* reason) :  _reason(reason) {}\n+  virtual bool is_empty() const override final       { return true; }\n+  virtual bool is_trivial() const override final     { return false; }\n+  virtual bool is_constrained() const override final { return false; }\n+  const char* reason() const { return _reason; }\n+\n+  virtual const AlignmentSolution* filter(const AlignmentSolution* other) const override final {\n+    \/\/ If \"this\" cannot be guaranteed to be aligned, then we also cannot guarantee to align\n+    \/\/ \"this\" and \"other\" together.\n+    return new EmptyAlignmentSolution(\"empty solution input to filter\");\n+  }\n+\n+  virtual void print() const override final {\n+    tty->print_cr(\"empty solution: %s\", reason());\n+  };\n+};\n+\n+class TrivialAlignmentSolution : public AlignmentSolution {\n+public:\n+  TrivialAlignmentSolution() {}\n+  virtual bool is_empty() const override final       { return false; }\n+  virtual bool is_trivial() const override final     { return true; }\n+  virtual bool is_constrained() const override final { return false; }\n+\n+  virtual const AlignmentSolution* filter(const AlignmentSolution* other) const override final {\n+    if (other->is_empty()) {\n+      \/\/ If \"other\" cannot be guaranteed to be aligned, then we also cannot guarantee to align\n+      \/\/ \"this\" and \"other\".\n+      return new EmptyAlignmentSolution(\"empty solution input to filter\");\n+    }\n+    \/\/ Since \"this\" is trivial (no constraints), the solution of \"other\" guarantees alignment\n+    \/\/ of both.\n+    return other;\n+  }\n+\n+  virtual void print() const override final {\n+    tty->print_cr(\"pre_iter >= 0 (trivial)\");\n+  };\n+};\n+\n+class ConstrainedAlignmentSolution : public AlignmentSolution {\n+private:\n+  const MemNode* _mem_ref;\n+  const int _q;\n+  const int _r;\n+  const Node* _invar;\n+  const int _scale;\n+public:\n+  ConstrainedAlignmentSolution(const MemNode* mem_ref,\n+                               const int q,\n+                               const int r,\n+                               const Node* invar,\n+                               int scale) :\n+      _mem_ref(mem_ref),\n+      _q(q),\n+      _r(r),\n+      _invar(invar),\n+      _scale(scale) {\n+    assert(q > 1 && is_power_of_2(q), \"q must be power of 2\");\n+    assert(0 <= r && r < q, \"r must be in modulo space of q\");\n+    assert(_mem_ref != nullptr, \"must have mem_ref\");\n+  }\n+\n+  virtual bool is_empty() const override final       { return false; }\n+  virtual bool is_trivial() const override final     { return false; }\n+  virtual bool is_constrained() const override final { return true; }\n+\n+  const MemNode* mem_ref() const        { return _mem_ref; }\n+\n+  virtual const ConstrainedAlignmentSolution* as_constrained() const override final { return this; }\n+\n+  virtual const AlignmentSolution* filter(const AlignmentSolution* other) const override final {\n+    if (other->is_empty()) {\n+      \/\/ If \"other\" cannot be guaranteed to be aligned, then we also cannot guarantee to align\n+      \/\/ \"this\" and \"other\" together.\n+      return new EmptyAlignmentSolution(\"empty solution input to filter\");\n+    }\n+    \/\/ Since \"other\" is trivial (no constraints), the solution of \"this\" guarantees alignment\n+    \/\/ of both.\n+    if (other->is_trivial()) {\n+      return this;\n+    }\n+\n+    \/\/ Both solutions are constrained:\n+    ConstrainedAlignmentSolution const* s1 = this;\n+    ConstrainedAlignmentSolution const* s2 = other->as_constrained();\n+\n+    \/\/ Thus, pre_iter is the intersection of two sets, i.e. constrained by these two equations,\n+    \/\/ for any integers m1 and m2:\n+    \/\/\n+    \/\/   pre_iter = m1 * q1 + r1\n+    \/\/                     [- invar1 \/ (scale1 * pre_stride)  ]\n+    \/\/                     [- init \/ pre_stride               ]\n+    \/\/\n+    \/\/   pre_iter = m2 * q2 + r2\n+    \/\/                     [- invar2 \/ (scale2 * pre_stride)  ]\n+    \/\/                     [- init \/ pre_stride               ]\n+    \/\/\n+    \/\/ Note: pre_stride and init are identical for all mem_refs in the loop.\n+    \/\/\n+    \/\/ The init alignment term either does not exist for both mem_refs, or exists identically\n+    \/\/ for both. The init alignment term is thus trivially identical.\n+    \/\/\n+    \/\/ The invar alignment term is identical if either:\n+    \/\/   - both mem_refs have no invariant.\n+    \/\/   - both mem_refs have the same invariant and the same scale.\n+    \/\/\n+    if (s1->_invar != s2->_invar) {\n+      return new EmptyAlignmentSolution(\"invar not identical\");\n+    }\n+    if (s1->_invar != nullptr && s1->_scale != s2->_scale) {\n+      return new EmptyAlignmentSolution(\"has invar with different scale\");\n+    }\n+\n+    \/\/ Now, we have reduced the problem to:\n+    \/\/\n+    \/\/   pre_iter = m1 * q1 + r1 [- x]       (S1)\n+    \/\/   pre_iter = m2 * q2 + r2 [- x]       (S2)\n+    \/\/\n+\n+    \/\/ Make s2 the bigger modulo space, i.e. has larger periodicity q.\n+    \/\/ This guarantees that S2 is either identical to, a subset of,\n+    \/\/ or disjunct from S1 (but cannot be a strict superset of S1).\n+    if (s1->_q > s2->_q) {\n+      swap(s1, s2);\n+    }\n+    assert(s1->_q <= s2->_q, \"s1 is a smaller modulo space than s2\");\n+\n+    \/\/ Is S2 subset of (or equal to) S1?\n+    \/\/\n+    \/\/ for any m2, there are integers a, b, m1: m2 * q2     + r2          =\n+    \/\/                                          m2 * a * q1 + b * q1 + r1 =\n+    \/\/                                          (m2 * a + b) * q1 + r1\n+    \/\/\n+    \/\/ Since q1 and q2 are both powers of 2, and q1 <= q2, we know there\n+    \/\/ is an integer a: a * q1 = q2. Thus, it remains to check if there\n+    \/\/ is an integer b: b * q1 + r1 = r2. This is equivalent to checking:\n+    \/\/\n+    \/\/   r1 = r1 % q1 = r2 % q1\n+    \/\/\n+    if (mod(s2->_r, s1->_q) != s1->_r) {\n+      \/\/ Neither is subset of the other -> no intersection\n+      return new EmptyAlignmentSolution(\"empty intersection (r and q)\");\n+    }\n+\n+    \/\/ Now we know: \"s1 = m1 * q1 + r1\" is a superset of \"s2 = m2 * q2 + r2\"\n+    \/\/ Hence, any solution of S2 guarantees alignment for both mem_refs.\n+    return s2; \/\/ return the subset\n+  }\n+\n+  virtual void print() const override final {\n+    tty->print(\"m * q(%d) + r(%d)\", _q, _r);\n+    if (_invar != nullptr) {\n+      tty->print(\" - invar[%d] \/ (scale(%d) * pre_stride)\", _invar->_idx, _scale);\n+    }\n+    tty->print_cr(\" [- init \/ pre_stride], mem_ref[%d]\", mem_ref()->_idx);\n+  };\n+};\n+\n+\/\/ When strict alignment is required (e.g. -XX:+AlignVector), then we must ensure\n+\/\/ that all vector memory accesses can be aligned. We achieve this alignment by\n+\/\/ adjusting the pre-loop limit, which adjusts the number of iterations executed\n+\/\/ in the pre-loop.\n+\/\/\n+\/\/ This is how the pre-loop and unrolled main-loop look like for a memref (adr):\n+\/\/\n+\/\/ iv = init\n+\/\/ i = 0 \/\/ single-iteration counter\n+\/\/\n+\/\/ pre-loop:\n+\/\/   iv = init + i * pre_stride\n+\/\/   adr = base + offset + invar + scale * iv\n+\/\/   adr = base + offset + invar + scale * (init + i * pre_stride)\n+\/\/   iv += pre_stride\n+\/\/   i++\n+\/\/\n+\/\/ pre_iter = i \/\/ number of iterations in the pre-loop\n+\/\/ iv = init + pre_iter * pre_stride\n+\/\/\n+\/\/ main_iter = 0 \/\/ main-loop iteration counter\n+\/\/ main_stride = unroll_factor * pre_stride\n+\/\/\n+\/\/ main-loop:\n+\/\/   i = pre_iter + main_iter * unroll_factor\n+\/\/   iv = init + i * pre_stride = init + pre_iter * pre_stride + main_iter * unroll_factor * pre_stride\n+\/\/                              = init + pre_iter * pre_stride + main_iter * main_stride\n+\/\/   adr = base + offset + invar + scale * iv \/\/ must be aligned\n+\/\/   iv += main_stride\n+\/\/   i  += unroll_factor\n+\/\/   main_iter++\n+\/\/\n+\/\/ For each vector memory access, we can find the set of pre_iter (number of pre-loop\n+\/\/ iterations) which would align its address. The AlignmentSolver finds such an\n+\/\/ AlignmentSolution. We can then check which solutions are compatible, and thus\n+\/\/ decide if we have to (partially) reject vectorization if not all vectors have\n+\/\/ a compatible solutions.\n+class AlignmentSolver {\n+private:\n+  const MemNode* _mem_ref;       \/\/ first element\n+  const uint     _vector_length; \/\/ number of elements in vector\n+  const int      _element_size;\n+  const int      _vector_width;  \/\/ in bytes\n+\n+  \/\/ All vector loads and stores need to be memory aligned. The alignment width (aw) in\n+  \/\/ principle is the vector_width. But when vector_width > ObjectAlignmentInBytes this is\n+  \/\/ too strict, since any memory object is only guaranteed to be ObjectAlignmentInBytes\n+  \/\/ aligned. For example, the relative offset between two arrays is only guaranteed to\n+  \/\/ be divisible by ObjectAlignmentInBytes.\n+  const int      _aw;\n+\n+  \/\/ We analyze the address of mem_ref. The idea is to disassemble it into a linear\n+  \/\/ expression, where we can use the constant factors as the basis for ensuring the\n+  \/\/ alignment of vector memory accesses.\n+  \/\/\n+  \/\/ The Simple form of the address is disassembled by VPointer into:\n+  \/\/\n+  \/\/   adr = base + offset + invar + scale * iv\n+  \/\/\n+  \/\/ Where the iv can be written as:\n+  \/\/\n+  \/\/   iv = init + pre_stride * pre_iter + main_stride * main_iter\n+  \/\/\n+  \/\/ pre_iter:    number of pre-loop iterations (adjustable via pre-loop limit)\n+  \/\/ main_iter:   number of main-loop iterations (main_iter >= 0)\n+  \/\/\n+  const Node*    _base;           \/\/ base of address (e.g. Java array object, aw-aligned)\n+  const int      _offset;\n+  const Node*    _invar;\n+  const int      _invar_factor;   \/\/ known constant factor of invar\n+  const int      _scale;\n+  const Node*    _init_node;      \/\/ value of iv before pre-loop\n+  const int      _pre_stride;     \/\/ address increment per pre-loop iteration\n+  const int      _main_stride;    \/\/ address increment per main-loop iteration\n+\n+  DEBUG_ONLY( const bool _is_trace; );\n+\n+  static const MemNode* mem_ref_not_null(const MemNode* mem_ref) {\n+    assert(mem_ref != nullptr, \"not nullptr\");\n+    return mem_ref;\n+  }\n+\n+public:\n+  AlignmentSolver(const MemNode* mem_ref,\n+                  const uint vector_length,\n+                  const Node* base,\n+                  const int offset,\n+                  const Node* invar,\n+                  const int invar_factor,\n+                  const int scale,\n+                  const Node* init_node,\n+                  const int pre_stride,\n+                  const int main_stride\n+                  DEBUG_ONLY( COMMA const bool is_trace)\n+                  ) :\n+      _mem_ref(           mem_ref_not_null(mem_ref)),\n+      _vector_length(     vector_length),\n+      _element_size(      _mem_ref->memory_size()),\n+      _vector_width(      _vector_length * _element_size),\n+      _aw(                MIN2(_vector_width, ObjectAlignmentInBytes)),\n+      _base(              base),\n+      _offset(            offset),\n+      _invar(             invar),\n+      _invar_factor(      invar_factor),\n+      _scale(             scale),\n+      _init_node(         init_node),\n+      _pre_stride(        pre_stride),\n+      _main_stride(       main_stride)\n+      DEBUG_ONLY( COMMA _is_trace(is_trace) )\n+  {\n+    assert(_mem_ref != nullptr &&\n+           (_mem_ref->is_Load() || _mem_ref->is_Store()),\n+           \"only load or store vectors allowed\");\n+  }\n+\n+  AlignmentSolution* solve() const;\n+\n+private:\n+  class EQ4 {\n+   private:\n+    const int _C_const;\n+    const int _C_invar;\n+    const int _C_init;\n+    const int _C_pre;\n+    const int _aw;\n+\n+   public:\n+    EQ4(const int C_const, const int C_invar, const int C_init, const int C_pre, const int aw) :\n+    _C_const(C_const), _C_invar(C_invar), _C_init(C_init), _C_pre(C_pre), _aw(aw) {}\n+\n+    enum State { TRIVIAL, CONSTRAINED, EMPTY };\n+\n+    State eq4a_state() const {\n+      return (abs(_C_pre) >= _aw) ? ( (C_const_mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n+                                  : ( (C_const_mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n+    }\n+\n+    State eq4b_state() const {\n+      return (abs(_C_pre) >= _aw) ? ( (C_invar_mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n+                                  : ( (C_invar_mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n+    }\n+\n+    State eq4c_state() const {\n+      return (abs(_C_pre) >= _aw) ? ( (C_init_mod_aw() == 0       )  ? TRIVIAL     : EMPTY)\n+                                  : ( (C_init_mod_abs_C_pre() == 0)  ? CONSTRAINED : EMPTY);\n+    }\n+\n+   private:\n+    int C_const_mod_aw() const        { return AlignmentSolution::mod(_C_const, _aw); }\n+    int C_invar_mod_aw() const        { return AlignmentSolution::mod(_C_invar, _aw); }\n+    int C_init_mod_aw() const         { return AlignmentSolution::mod(_C_init,  _aw); }\n+    int C_const_mod_abs_C_pre() const { return AlignmentSolution::mod(_C_const, abs(_C_pre)); }\n+    int C_invar_mod_abs_C_pre() const { return AlignmentSolution::mod(_C_invar, abs(_C_pre)); }\n+    int C_init_mod_abs_C_pre() const  { return AlignmentSolution::mod(_C_init,  abs(_C_pre)); }\n+\n+#ifdef ASSERT\n+   public:\n+    void trace() const;\n+\n+   private:\n+    static const char* state_to_str(State s) {\n+      if (s == TRIVIAL)     { return \"trivial\"; }\n+      if (s == CONSTRAINED) { return \"constrained\"; }\n+      return \"empty\";\n+    }\n+#endif\n+  };\n+\n+#ifdef ASSERT\n+  bool is_trace() const { return _is_trace; }\n+  void trace_start_solve() const;\n+  void trace_reshaped_form(const int C_const,\n+                           const int C_const_init,\n+                           const int C_invar,\n+                           const int C_init,\n+                           const int C_pre,\n+                           const int C_main) const;\n+  void trace_main_iteration_alignment(const int C_const,\n+                                      const int C_invar,\n+                                      const int C_init,\n+                                      const int C_pre,\n+                                      const int C_main,\n+                                      const int C_main_mod_aw) const;\n+  void trace_constrained_solution(const int C_const,\n+                                  const int C_invar,\n+                                  const int C_init,\n+                                  const int C_pre,\n+                                  const int q,\n+                                  const int r) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":435,"deletions":16,"binary":false,"changes":451,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -850,0 +850,2 @@\n+ private:\n+  DEBUG_ONLY( bool _must_verify_alignment = false; );\n@@ -874,0 +876,11 @@\n+\n+  \/\/ Needed for proper cloning.\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+#ifdef ASSERT\n+  \/\/ When AlignVector is enabled, SuperWord only creates aligned vector loads and stores.\n+  \/\/ VerifyAlignVector verifies this. We need to mark the nodes created in SuperWord,\n+  \/\/ because nodes created elsewhere (i.e. VectorAPI) may still be misaligned.\n+  bool must_verify_alignment() const { return _must_verify_alignment; }\n+  void set_must_verify_alignment() { _must_verify_alignment = true; }\n+#endif\n@@ -897,0 +910,1 @@\n+  DEBUG_ONLY( bool _must_verify_alignment = false; );\n@@ -921,0 +935,8 @@\n+\n+#ifdef ASSERT\n+  \/\/ When AlignVector is enabled, SuperWord only creates aligned vector loads and stores.\n+  \/\/ VerifyAlignVector verifies this. We need to mark the nodes created in SuperWord,\n+  \/\/ because nodes created elsewhere (i.e. VectorAPI) may still be misaligned.\n+  bool must_verify_alignment() const { return _must_verify_alignment; }\n+  void set_must_verify_alignment() { _must_verify_alignment = true; }\n+#endif\n@@ -1020,0 +1042,19 @@\n+\/\/ Verify that memory address (adr) is aligned. The mask specifies the\n+\/\/ least significant bits which have to be zero in the address.\n+\/\/\n+\/\/ if (adr & mask == 0) {\n+\/\/   return adr\n+\/\/ } else {\n+\/\/   stop(\"verify_vector_alignment found a misaligned vector memory access\")\n+\/\/ }\n+\/\/\n+\/\/ This node is used just before a vector load\/store with -XX:+VerifyAlignVector\n+class VerifyVectorAlignmentNode : public Node {\n+  virtual uint hash() const { return NO_HASH; };\n+public:\n+  VerifyVectorAlignmentNode(Node* adr, Node* mask) : Node(nullptr, adr, mask) {}\n+  virtual int Opcode() const;\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual const Type *bottom_type() const { return in(1)->bottom_type(); }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2410,0 +2410,1 @@\n+  ResourceMark rm(current); \/\/ vframes are resource allocated\n@@ -2436,0 +2437,3 @@\n+  Thread* current = Thread::current();\n+  ResourceMark rm(current); \/\/ vframes are resource allocated\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+  { \"AdaptiveSizePolicyCollectionCostMargin\",   JDK_Version::undefined(), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n@@ -2217,4 +2218,0 @@\n-#if INCLUDE_CDS\n-      MetaspaceShared::disable_optimized_module_handling();\n-      log_info(cds)(\"optimized module handling: disabled because bootclasspath was appended\");\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1501,15 +1501,15 @@\n-\/\/ static bool monitors_on_stack(JavaThread* thread) {\n-\/\/   ContinuationEntry* ce = thread->last_continuation();\n-\/\/   RegisterMap map(thread,\n-\/\/                   RegisterMap::UpdateMap::include,\n-\/\/                   RegisterMap::ProcessFrames::include,\n-\/\/                   RegisterMap::WalkContinuation::skip);\n-\/\/   map.set_include_argument_oops(false);\n-\/\/   for (frame f = thread->last_frame(); Continuation::is_frame_in_continuation(ce, f); f = f.sender(&map)) {\n-\/\/     if ((f.is_interpreted_frame() && ContinuationHelper::InterpretedFrame::is_owning_locks(f)) ||\n-\/\/         (f.is_compiled_frame() && ContinuationHelper::CompiledFrame::is_owning_locks(map.thread(), &map, f))) {\n-\/\/       return true;\n-\/\/     }\n-\/\/   }\n-\/\/   return false;\n-\/\/ }\n+static bool monitors_on_stack(JavaThread* thread) {\n+  ContinuationEntry* ce = thread->last_continuation();\n+  RegisterMap map(thread,\n+                  RegisterMap::UpdateMap::include,\n+                  RegisterMap::ProcessFrames::include,\n+                  RegisterMap::WalkContinuation::skip);\n+  map.set_include_argument_oops(false);\n+  for (frame f = thread->last_frame(); Continuation::is_frame_in_continuation(ce, f); f = f.sender(&map)) {\n+    if ((f.is_interpreted_frame() && ContinuationHelper::InterpretedFrame::is_owning_locks(f)) ||\n+        (f.is_compiled_frame() && ContinuationHelper::CompiledFrame::is_owning_locks(map.thread(), &map, f))) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n@@ -1578,2 +1578,2 @@\n-  \/\/ assert(monitors_on_stack(current) == ((current->held_monitor_count() - current->jni_monitor_count()) > 0),\n-  \/\/        \"Held monitor count and locks on stack invariant: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n+  assert(monitors_on_stack(current) == ((current->held_monitor_count() - current->jni_monitor_count()) > 0),\n+         \"Held monitor count and locks on stack invariant: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -93,0 +93,2 @@\n+  const ImmutableOopMap* get_oop_map() const;\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,13 @@\n+inline const ImmutableOopMap* frame::get_oop_map() const {\n+  if (_cb == nullptr || _cb->oop_maps() == nullptr) return nullptr;\n+\n+  NativePostCallNop* nop = nativePostCallNop_at(_pc);\n+  int oopmap_slot;\n+  int cb_offset;\n+  if (nop != nullptr && nop->decode(oopmap_slot, cb_offset)) {\n+    return _cb->oop_map_for_slot(oopmap_slot, _pc);\n+  }\n+  const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n+  return oop_map;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -549,1 +549,2 @@\n-          \"Dump heap to file before any major stop-the-world GC\")           \\\n+          \"Dump heap to file before any major stop-the-world GC \"           \\\n+          \"(also see FullGCHeapDumpLimit)\")                                 \\\n@@ -552,1 +553,7 @@\n-          \"Dump heap to file after any major stop-the-world GC\")            \\\n+          \"Dump heap to file after any major stop-the-world GC \"            \\\n+          \"(also see FullGCHeapDumpLimit)\")                                 \\\n+                                                                            \\\n+  product(uint, FullGCHeapDumpLimit, 0, MANAGEABLE,                         \\\n+          \"Limit the number of heap dumps triggered by \"                    \\\n+          \"HeapDumpBeforeFullGC or HeapDumpAfterFullGC \"                    \\\n+          \"(0 means no limit)\")                                             \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-    CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Mutex),\n+    CACHE_LINE_PADDING = (int)DEFAULT_PADDING_SIZE - (int)sizeof(Mutex),\n@@ -235,1 +235,1 @@\n-    CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Monitor),\n+    CACHE_LINE_PADDING = (int)DEFAULT_PADDING_SIZE - (int)sizeof(Monitor),\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1847,4 +1847,0 @@\n-  if (NotRunnable(current, static_cast<JavaThread*>(owner_raw()))) {\n-    return 0;\n-  }\n-\n@@ -1936,7 +1932,0 @@\n-    \/\/ Abort the spin if the owner is not executing.\n-    \/\/ The owner must be executing in order to drop the lock.\n-    \/\/ Spinning while the owner is OFFPROC is idiocy.\n-    \/\/ Consider: ctr -= RunnablePenalty ;\n-    if (NotRunnable(current, ox)) {\n-      goto Abort;\n-    }\n@@ -1975,56 +1964,0 @@\n-\/\/ NotRunnable() -- informed spinning\n-\/\/\n-\/\/ Don't bother spinning if the owner is not eligible to drop the lock.\n-\/\/ Spin only if the owner thread is _thread_in_Java or _thread_in_vm.\n-\/\/ The thread must be runnable in order to drop the lock in timely fashion.\n-\/\/ If the _owner is not runnable then spinning will not likely be\n-\/\/ successful (profitable).\n-\/\/\n-\/\/ Beware -- the thread referenced by _owner could have died\n-\/\/ so a simply fetch from _owner->_thread_state might trap.\n-\/\/ Instead, we use SafeFetchXX() to safely LD _owner->_thread_state.\n-\/\/ Because of the lifecycle issues, the _thread_state values\n-\/\/ observed by NotRunnable() might be garbage.  NotRunnable must\n-\/\/ tolerate this and consider the observed _thread_state value\n-\/\/ as advisory.\n-\/\/\n-\/\/ Beware too, that _owner is sometimes a BasicLock address and sometimes\n-\/\/ a thread pointer.\n-\/\/ Alternately, we might tag the type (thread pointer vs basiclock pointer)\n-\/\/ with the LSB of _owner.  Another option would be to probabilistically probe\n-\/\/ the putative _owner->TypeTag value.\n-\/\/\n-\/\/ Checking _thread_state isn't perfect.  Even if the thread is\n-\/\/ in_java it might be blocked on a page-fault or have been preempted\n-\/\/ and sitting on a ready\/dispatch queue.\n-\/\/\n-\/\/ The return value from NotRunnable() is *advisory* -- the\n-\/\/ result is based on sampling and is not necessarily coherent.\n-\/\/ The caller must tolerate false-negative and false-positive errors.\n-\/\/ Spinning, in general, is probabilistic anyway.\n-\n-\n-int ObjectMonitor::NotRunnable(JavaThread* current, JavaThread* ox) {\n-  \/\/ Check ox->TypeTag == 2BAD.\n-  if (ox == nullptr) return 0;\n-\n-  \/\/ Avoid transitive spinning ...\n-  \/\/ Say T1 spins or blocks trying to acquire L.  T1._Stalled is set to L.\n-  \/\/ Immediately after T1 acquires L it's possible that T2, also\n-  \/\/ spinning on L, will see L.Owner=T1 and T1._Stalled=L.\n-  \/\/ This occurs transiently after T1 acquired L but before\n-  \/\/ T1 managed to clear T1.Stalled.  T2 does not need to abort\n-  \/\/ its spin in this circumstance.\n-  intptr_t BlockedOn = SafeFetchN((intptr_t *) &ox->_Stalled, intptr_t(1));\n-\n-  if (BlockedOn == 1) return 1;\n-  if (BlockedOn != 0) {\n-    return BlockedOn != intptr_t(this) && owner_raw() == ox;\n-  }\n-\n-  assert(sizeof(ox->_thread_state == sizeof(int)), \"invariant\");\n-  int jst = SafeFetch32((int *) &ox->_thread_state, -1);;\n-  \/\/ consider also: jst != _thread_in_Java -- but that's overspecific.\n-  return jst == _thread_blocked || jst == _thread_in_native;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":67,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -124,3 +124,0 @@\n-#ifndef OM_CACHE_LINE_SIZE\n-\/\/ Use DEFAULT_CACHE_LINE_SIZE if not already specified for\n-\/\/ the current build platform.\n@@ -128,1 +125,0 @@\n-#endif\n@@ -360,1 +356,0 @@\n-  int       NotRunnable(JavaThread* current, JavaThread* Owner);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1108,0 +1108,4 @@\n+static constexpr int secs_per_day  = 86400;\n+static constexpr int secs_per_hour = 3600;\n+static constexpr int secs_per_min  = 60;\n+\n@@ -1109,3 +1113,0 @@\n-  const int secs_per_day  = 86400;\n-  const int secs_per_hour = 3600;\n-  const int secs_per_min  = 60;\n@@ -1137,0 +1138,6 @@\n+  st->print(\" elapsed time: \");\n+  print_elapsed_time(st, t);\n+  st->cr();\n+}\n+\n+void os::print_elapsed_time(outputStream* st, double time) {\n@@ -1138,2 +1145,2 @@\n-  int eltime = (int)t;  \/\/ elapsed time in seconds\n-  int eltimeFraction = (int) ((t - eltime) * 1000000);\n+  int eltime = (int)time;  \/\/ elapsed time in seconds\n+  int eltimeFraction = (int) ((time - eltime) * 1000000);\n@@ -1149,1 +1156,1 @@\n-  st->print_cr(\" elapsed time: %d.%06d seconds (%dd %dh %dm %ds)\", eltime, eltimeFraction, eldays, elhours, elmins, elsecs);\n+  st->print(\"%d.%06d seconds (%dd %dh %dm %ds)\", eltime, eltimeFraction, eldays, elhours, elmins, elsecs);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -792,0 +792,1 @@\n+  static void print_elapsed_time(outputStream* st, double time);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1644,0 +1644,13 @@\n+  static bool is_vthread_mounted(oop vt) {\n+    \/\/ The code should be consistent with the \"mounted virtual thread\" case\n+    \/\/ (VM_HeapDumper::dump_stack_traces(), ThreadDumper::get_top_frame()).\n+    \/\/ I.e. virtual thread is mounted if its carrierThread is not null\n+    \/\/ and is_vthread_mounted() for the carrier thread returns true.\n+    oop carrier_thread = java_lang_VirtualThread::carrier_thread(vt);\n+    if (carrier_thread == nullptr) {\n+      return false;\n+    }\n+    JavaThread* java_thread = java_lang_Thread::thread(carrier_thread);\n+    return java_thread->is_vthread_mounted();\n+  }\n+\n@@ -1921,1 +1934,4 @@\n-    if (java_lang_VirtualThread::is_instance(o) && ThreadDumper::should_dump_vthread(o)) {\n+    \/\/ If we encounter an unmounted virtual thread it needs to be dumped explicitly\n+    \/\/ (mounted virtual threads are dumped with their carriers).\n+    if (java_lang_VirtualThread::is_instance(o)\n+        && ThreadDumper::should_dump_vthread(o) && !ThreadDumper::is_vthread_mounted(o)) {\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_PADDING_SIZE, 0);\n@@ -51,1 +51,1 @@\n-    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile uintx));\n+    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(volatile uintx));\n","filename":"src\/hotspot\/share\/utilities\/globalCounter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-\/\/ The expected size in bytes of a cache line, used to pad data structures.\n+\/\/ The expected size in bytes of a cache line.\n@@ -610,0 +610,5 @@\n+\/\/ The default padding size for data structures to avoid false sharing.\n+#ifndef DEFAULT_PADDING_SIZE\n+#error \"Platform should define DEFAULT_PADDING_SIZE\"\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(T*));\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(T*));\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"compiler\/compilationFailureInfo.hpp\"\n@@ -1056,0 +1057,6 @@\n+#if defined(COMPILER1) || defined(COMPILER2)\n+  STEP_IF(\"printing pending compilation failure\",\n+          _verbose && _thread != nullptr && _thread->is_Compiler_thread())\n+    CompilationFailureInfo::print_pending_compilation_failure(st);\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_PADDING_SIZE, 0);\n@@ -84,1 +84,1 @@\n-  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_PADDING_SIZE, 0);\n@@ -91,1 +91,1 @@\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, 0);\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-                () -> java.util.Arrays.fill(k, (byte)0x00));\n+                () -> Arrays.fill(k, (byte)0x00));\n@@ -139,1 +139,1 @@\n-            java.util.Arrays.fill(thatKey, (byte)0x00);\n+            Arrays.fill(thatKey, (byte)0x00);\n@@ -171,1 +171,1 @@\n-                () -> java.util.Arrays.fill(k, (byte)0x00));\n+                () -> Arrays.fill(k, (byte)0x00));\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESKey.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-                () -> java.util.Arrays.fill(k, (byte)0x00));\n+                () -> Arrays.fill(k, (byte)0x00));\n@@ -140,1 +140,1 @@\n-            java.util.Arrays.fill(thatKey, (byte)0x00);\n+            Arrays.fill(thatKey, (byte)0x00);\n@@ -165,1 +165,1 @@\n-        java.util.Arrays.fill(temp, (byte)0x00);\n+        Arrays.fill(temp, (byte)0x00);\n@@ -174,1 +174,1 @@\n-                () -> java.util.Arrays.fill(k, (byte)0x00));\n+                () -> Arrays.fill(k, (byte)0x00));\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKey.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-                () -> java.util.Arrays.fill(k, (byte)0x00));\n+                () -> Arrays.fill(k, (byte)0x00));\n@@ -199,1 +199,1 @@\n-                () -> java.util.Arrays.fill(k, (byte)0x00));\n+                () -> Arrays.fill(k, (byte)0x00));\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKey.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,1 +264,2 @@\n-     * information about modifiers and type parameters.\n+     * information about modifiers, {@link #isSealed() sealed}\/{@code\n+     * non-sealed} status, and type parameters.\n@@ -317,0 +318,5 @@\n+                \/\/ A class cannot be strictfp and sealed\/non-sealed so\n+                \/\/ it is sufficient to check for sealed-ness after all\n+                \/\/ modifiers are printed.\n+                addSealingInfo(modifiers, sb);\n+\n@@ -347,0 +353,43 @@\n+    private void addSealingInfo(int modifiers, StringBuilder sb) {\n+        \/\/ A class can be final XOR sealed XOR non-sealed.\n+        if (Modifier.isFinal(modifiers)) {\n+            return; \/\/ no-op\n+        } else {\n+            if (isSealed()) {\n+                sb.append(\"sealed \");\n+                return;\n+            } else {\n+                \/\/ Check for sealed ancestor, which implies this class\n+                \/\/ is non-sealed.\n+                if (hasSealedAncestor(this)) {\n+                    sb.append(\"non-sealed \");\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean hasSealedAncestor(Class<?> clazz) {\n+        \/\/ From JLS 8.1.1.2:\n+        \/\/ \"It is a compile-time error if a class has a sealed direct\n+        \/\/ superclass or a sealed direct superinterface, and is not\n+        \/\/ declared final, sealed, or non-sealed either explicitly or\n+        \/\/ implicitly.\n+        \/\/ Thus, an effect of the sealed keyword is to force all\n+        \/\/ direct subclasses to explicitly declare whether they are\n+        \/\/ final, sealed, or non-sealed. This avoids accidentally\n+        \/\/ exposing a sealed class hierarchy to unwanted subclassing.\"\n+\n+        \/\/ Therefore, will just check direct superclass and\n+        \/\/ superinterfaces.\n+        var superclass = clazz.getSuperclass();\n+        if (superclass != null && superclass.isSealed()) {\n+            return true;\n+        }\n+        for (var superinterface : clazz.getInterfaces()) {\n+            if (superinterface.isSealed()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,4 @@\n+import jdk.internal.access.JavaIOPrintStreamAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.InternalLock;\n+import jdk.internal.vm.Continuation;\n@@ -45,1 +49,2 @@\n-    static final StackWalker STACK_WALKER;\n+    private static final JavaIOPrintStreamAccess JIOPSA = SharedSecrets.getJavaIOPrintStreamAccess();\n+    private static final StackWalker STACK_WALKER;\n@@ -89,1 +94,10 @@\n-     * Prints the continuation stack trace.\n+     * Returns true if the frame is native, a class initializer, or holds monitors.\n+     *\/\n+    private static boolean isInterestingFrame(LiveStackFrame f) {\n+        return f.isNativeMethod()\n+                || \"<clinit>\".equals(f.getMethodName())\n+                || (f.getMonitors().length > 0);\n+    }\n+\n+    \/**\n+     * Prints the current thread's stack trace.\n@@ -94,1 +108,1 @@\n-    static void printStackTrace(PrintStream out, boolean printAll) {\n+    static void printStackTrace(PrintStream out, Continuation.Pinned reason, boolean printAll) {\n@@ -100,0 +114,15 @@\n+        Object lockObj = JIOPSA.lock(out);\n+        if (lockObj instanceof InternalLock lock && lock.tryLock()) {\n+            try {\n+                \/\/ find the closest frame that is causing the thread to be pinned\n+                stack.stream()\n+                    .filter(f -> isInterestingFrame(f))\n+                    .map(LiveStackFrame::getDeclaringClass)\n+                    .findFirst()\n+                    .ifPresentOrElse(klass -> {\n+                        \/\/ print the stack trace if not already seen\n+                        int hash = hash(stack);\n+                        if (HASHES.get(klass).add(hash)) {\n+                            printStackTrace(out, reason, stack, printAll);\n+                        }\n+                    }, () -> printStackTrace(out, reason, stack, true));  \/\/ not found\n@@ -101,15 +130,4 @@\n-        \/\/ find the closest frame that is causing the thread to be pinned\n-        stack.stream()\n-            .filter(f -> (f.isNativeMethod() || f.getMonitors().length > 0))\n-            .map(LiveStackFrame::getDeclaringClass)\n-            .findFirst()\n-            .ifPresentOrElse(klass -> {\n-                int hash = hash(stack);\n-                Hashes hashes = HASHES.get(klass);\n-                synchronized (hashes) {\n-                    \/\/ print the stack trace if not already seen\n-                    if (hashes.add(hash)) {\n-                        printStackTrace(stack, out, printAll);\n-                    }\n-                }\n-            }, () -> printStackTrace(stack, out, true));  \/\/ not found\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n@@ -118,2 +136,3 @@\n-    private static void printStackTrace(List<LiveStackFrame> stack,\n-                                        PrintStream out,\n+    private static void printStackTrace(PrintStream out,\n+                                        Continuation.Pinned reason,\n+                                        List<LiveStackFrame> stack,\n@@ -121,1 +140,1 @@\n-        out.println(Thread.currentThread());\n+        out.format(\"%s reason:%s%n\", Thread.currentThread(), reason);\n@@ -127,1 +146,1 @@\n-            } else if (frame.isNativeMethod() || printAll) {\n+            } else if (printAll || isInterestingFrame(frame)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/PinnedThreadPrinter.java","additions":42,"deletions":23,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -718,0 +718,1 @@\n+        toStringCache = null;\n@@ -729,0 +730,1 @@\n+        toStringCache = null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringBuffer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+import java.util.Locale;\n@@ -816,0 +817,4 @@\n+     * <p>\n+     * Additional locale-related system properties defined by the\n+     * {@link Locale##default_locale Default Locale} section in the {@code Locale}\n+     * class description may also be obtained with this method.\n@@ -2377,1 +2382,1 @@\n-                Thread.blockedOn(b);\n+                Thread.currentThread().blockedOn(b);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -348,1 +348,6 @@\n-    volatile Interruptible nioBlocker;\n+    private Interruptible nioBlocker;\n+\n+    Interruptible nioBlocker() {\n+        \/\/assert Thread.holdsLock(interruptLock);\n+        return nioBlocker;\n+    }\n@@ -353,4 +358,4 @@\n-    static void blockedOn(Interruptible b) {\n-        Thread me = Thread.currentThread();\n-        synchronized (me.interruptLock) {\n-            me.nioBlocker = b;\n+    void blockedOn(Interruptible b) {\n+        \/\/assert Thread.currentThread() == this;\n+        synchronized (interruptLock) {\n+            nioBlocker = b;\n@@ -1702,0 +1707,1 @@\n+            Interruptible blocker;\n@@ -1703,2 +1709,2 @@\n-                Interruptible b = nioBlocker;\n-                if (b != null) {\n+                blocker = nioBlocker;\n+                if (blocker != null) {\n@@ -1707,2 +1713,1 @@\n-                    b.interrupt(this);\n-                    return;\n+                    blocker.interrupt(this);\n@@ -1711,0 +1716,4 @@\n+            if (blocker != null) {\n+                blocker.postInterrupt();\n+                return;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,1 +194,9 @@\n-                PinnedThreadPrinter.printStackTrace(System.out, printAll);\n+                VirtualThread vthread = (VirtualThread) Thread.currentThread();\n+                int oldState = vthread.state();\n+                try {\n+                    \/\/ avoid printing when in transition states\n+                    vthread.setState(RUNNING);\n+                    PinnedThreadPrinter.printStackTrace(System.out, reason, printAll);\n+                } finally {\n+                    vthread.setState(oldState);\n+                }\n@@ -847,0 +855,10 @@\n+    @Override\n+    void blockedOn(Interruptible b) {\n+        notifyJvmtiDisableSuspend(true);\n+        try {\n+            super.blockedOn(b);\n+        } finally {\n+            notifyJvmtiDisableSuspend(false);\n+        }\n+    }\n+\n@@ -852,0 +870,4 @@\n+\n+            \/\/ if current thread is a virtual thread then prevent it from being\n+            \/\/ suspended when entering or holding interruptLock\n+            Interruptible blocker;\n@@ -856,3 +878,3 @@\n-                    Interruptible b = nioBlocker;\n-                    if (b != null) {\n-                        b.interrupt(this);\n+                    blocker = nioBlocker();\n+                    if (blocker != null) {\n+                        blocker.interrupt(this);\n@@ -868,0 +890,5 @@\n+\n+            \/\/ notify blocker after releasing interruptLock\n+            if (blocker != null) {\n+                blocker.postInterrupt();\n+            }\n@@ -978,1 +1005,1 @@\n-        int initialState = state();\n+        int initialState = state() & ~SUSPENDED;\n@@ -983,1 +1010,1 @@\n-            case RUNNING, PINNED -> {\n+            case RUNNING, PINNED, TIMED_PINNED -> {\n@@ -995,1 +1022,1 @@\n-            default -> throw new InternalError();\n+            default -> throw new InternalError(\"\" + initialState);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1019,1 +1019,1 @@\n-        MemoryLayoutUtil.requireNonNegative(elementCount);\n+        Utils.checkNonNegativeArgument(elementCount, \"elementCount\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -1594,0 +1595,1 @@\n+     *         or {@code offset < 0}\n@@ -1612,0 +1614,1 @@\n+     *         or {@code offset < 0}\n@@ -1632,0 +1635,1 @@\n+     *         or {@code offset < 0}\n@@ -1650,0 +1654,1 @@\n+     *         or {@code offset < 0}\n@@ -1670,0 +1675,1 @@\n+     *         or {@code offset < 0}\n@@ -1688,0 +1694,1 @@\n+     *         or {@code offset < 0}\n@@ -1708,0 +1715,1 @@\n+     *         or {@code offset < 0}\n@@ -1726,0 +1734,1 @@\n+     *         or {@code offset < 0}\n@@ -1746,0 +1755,1 @@\n+     *         or {@code offset < 0}\n@@ -1764,0 +1774,1 @@\n+     *         or {@code offset < 0}\n@@ -1784,0 +1795,1 @@\n+     *         or {@code offset < 0}\n@@ -1802,0 +1814,1 @@\n+     *         or {@code offset < 0}\n@@ -1822,0 +1835,1 @@\n+     *         or {@code offset < 0}\n@@ -1840,0 +1854,1 @@\n+     *         or {@code offset < 0}\n@@ -1860,0 +1875,1 @@\n+     *         or {@code offset < 0}\n@@ -1878,0 +1894,1 @@\n+     *         or {@code offset < 0}\n@@ -1908,0 +1925,1 @@\n+     *         or {@code offset < 0}\n@@ -1926,2 +1944,1 @@\n-     * @throws UnsupportedOperationException if this segment is\n-     *         {@linkplain #isReadOnly() read-only}\n+     *         or {@code offset < 0}\n@@ -1954,0 +1971,1 @@\n+     *         or {@code index < 0}\n@@ -1976,0 +1994,1 @@\n+     *         or {@code index < 0}\n@@ -1998,0 +2017,1 @@\n+     *         or {@code index < 0}\n@@ -2020,1 +2040,2 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     *         or {@code index < 0}\n+     * @throws IllegalArgumentException if this segment is {@linkplain #isReadOnly() read-only}\n@@ -2043,0 +2064,1 @@\n+     *         or {@code index < 0}\n@@ -2064,0 +2086,1 @@\n+     *         or {@code index < 0}\n@@ -2087,0 +2110,1 @@\n+     *         or {@code index < 0}\n@@ -2110,0 +2134,1 @@\n+     *         or {@code index < 0}\n@@ -2133,0 +2158,1 @@\n+     *         or {@code index < 0}\n@@ -2155,0 +2181,1 @@\n+     *         or {@code index < 0}\n@@ -2178,0 +2205,1 @@\n+     *         or {@code index < 0}\n@@ -2200,0 +2228,1 @@\n+     *         or {@code index < 0}\n@@ -2223,0 +2252,1 @@\n+     *         or {@code index < 0}\n@@ -2245,0 +2275,1 @@\n+     *         or {@code index < 0}\n@@ -2268,0 +2299,1 @@\n+     *         or {@code index < 0}\n@@ -2290,0 +2322,1 @@\n+     *         or {@code index < 0}\n@@ -2322,0 +2355,1 @@\n+     *         or {@code index < 0}\n@@ -2344,1 +2378,1 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     *         or {@code index < 0}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -393,1 +394,2 @@\n-     * @throws IndexOutOfBoundsException if {@code elementCount * sourceElementLayout.byteSize()} overflows\n+     * @throws IllegalArgumentException if {@code elementCount * sourceElementLayout.byteSize()} overflows\n+     * @throws IllegalArgumentException if {@code elementCount < 0}\n@@ -395,1 +397,1 @@\n-     * @throws IndexOutOfBoundsException if either {@code sourceOffset} or {@code elementCount} are {@code < 0}\n+     * @throws IndexOutOfBoundsException if {@code sourceOffset < 0}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,1 @@\n-                : java.util.Arrays.asList(targetType, targetType.invokerType(), invoker);\n+                : Arrays.asList(targetType, targetType.invokerType(), invoker);\n@@ -203,1 +203,1 @@\n-                : java.util.Arrays.asList(targetType, invokerType, invoker);\n+                : Arrays.asList(targetType, invokerType, invoker);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1777,1 +1777,1 @@\n-            rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);\n+            rmag = Arrays.copyOfRange(rmag, 1, rmag.length);\n@@ -1822,1 +1822,1 @@\n-            rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);\n+            rmag = Arrays.copyOfRange(rmag, 1, rmag.length);\n@@ -4596,1 +4596,1 @@\n-        return java.util.Arrays.copyOfRange(val, keep, vlen);\n+        return Arrays.copyOfRange(val, keep, vlen);\n@@ -4610,1 +4610,1 @@\n-        return keep == 0 ? val : java.util.Arrays.copyOfRange(val, keep, vlen);\n+        return keep == 0 ? val : Arrays.copyOfRange(val, keep, vlen);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -37,1 +38,0 @@\n-\n@@ -92,0 +92,3 @@\n+    \/\/ invoked if a Thread is interrupted when blocked in an I\/O op\n+    private final Interruptible interruptor;\n+\n@@ -95,1 +98,14 @@\n-    protected AbstractInterruptibleChannel() { }\n+    protected AbstractInterruptibleChannel() {\n+        this.interruptor = new Interruptible() {\n+            @Override\n+            public void interrupt(Thread target) {\n+                AbstractInterruptibleChannel.this.trySetTarget(target);\n+            }\n+            @Override\n+            public void postInterrupt() {\n+                try {\n+                    AbstractInterruptibleChannel.this.close();\n+                } catch (IOException x) { }\n+            }\n+        };\n+    }\n@@ -142,2 +158,9 @@\n-    private Interruptible interruptor;\n-    private volatile Thread interrupted;\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final long INTERRUPTED_TARGET =\n+        U.objectFieldOffset(AbstractInterruptibleChannel.class, \"interruptedTarget\");\n+    private volatile Object interruptedTarget;  \/\/ Thread or placeholder object\n+\n+    private void trySetTarget(Thread target) {\n+        \/\/ can't use VarHandle here as CAS may park on first usage\n+        U.compareAndSetReference(this, INTERRUPTED_TARGET, null, target);\n+    }\n@@ -154,14 +177,0 @@\n-        if (interruptor == null) {\n-            interruptor = new Interruptible() {\n-                    public void interrupt(Thread target) {\n-                        synchronized (closeLock) {\n-                            if (closed)\n-                                return;\n-                            closed = true;\n-                            interrupted = target;\n-                            try {\n-                                AbstractInterruptibleChannel.this.implCloseChannel();\n-                            } catch (IOException x) { }\n-                        }\n-                    }};\n-        }\n@@ -170,1 +179,1 @@\n-        if (me.isInterrupted())\n+        if (me.isInterrupted()) {\n@@ -172,0 +181,2 @@\n+            interruptor.postInterrupt();\n+        }\n@@ -197,4 +208,8 @@\n-        Thread interrupted = this.interrupted;\n-        if (interrupted != null && interrupted == Thread.currentThread()) {\n-            this.interrupted = null;\n-            throw new ClosedByInterruptException();\n+        Object interruptedTarget = this.interruptedTarget;\n+        if (interruptedTarget != null) {\n+            interruptor.postInterrupt();\n+            if (interruptedTarget == Thread.currentThread()) {\n+                \/\/ replace with dummy object to avoid retaining reference to this thread\n+                this.interruptedTarget = new Object();\n+                throw new ClosedByInterruptException();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractInterruptibleChannel.java","additions":39,"deletions":24,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,3 @@\n+    \/\/ invoked if a Thread is interrupted when blocked on a selection op\n+    private final Interruptible interruptor;\n+\n@@ -106,0 +109,9 @@\n+        this.interruptor = new Interruptible() {\n+            @Override\n+            public void interrupt(Thread ignore) {\n+            }\n+            @Override\n+            public void postInterrupt() {\n+                AbstractSelector.this.wakeup();\n+            }\n+        };\n@@ -212,2 +224,0 @@\n-    private Interruptible interruptor = null;\n-\n@@ -228,6 +238,0 @@\n-        if (interruptor == null) {\n-            interruptor = new Interruptible() {\n-                    public void interrupt(Thread ignore) {\n-                        AbstractSelector.this.wakeup();\n-                    }};\n-        }\n@@ -236,2 +240,3 @@\n-        if (me.isInterrupted())\n-            interruptor.interrupt(me);\n+        if (me.isInterrupted()) {\n+            interruptor.postInterrupt();\n+        }\n@@ -251,1 +256,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelector.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-     * after the space attributes are obtained. It is likely to be made inaccurate\n+     * after this method returns. It is likely to be made inaccurate\n@@ -110,1 +110,1 @@\n-     * @return  the number of bytes available\n+     * @return  the current number of usable bytes\n@@ -125,1 +125,1 @@\n-     * after the space attributes are obtained. It is likely to be\n+     * after this method returns. It is likely to be\n@@ -129,1 +129,1 @@\n-     * @return  the number of unallocated bytes\n+     * @return  the current number of unallocated bytes\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/FileStore.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.text.DateFormat;\n@@ -261,0 +262,68 @@\n+ * <h3><a id=\"default_locale\">Default Locale<\/a><\/h3>\n+ *\n+ * <p>The default Locale is provided for any locale-sensitive methods if no\n+ * {@code Locale} is explicitly specified as an argument, such as\n+ * {@link DateFormat#getInstance()}. The default Locale is determined at startup\n+ * of the Java runtime and established in the following three phases:\n+ * <ol>\n+ * <li>The locale-related system properties listed below are established from the\n+ * host environment. Some system properties (except for {@code user.language}) may\n+ * not have values from the host environment.\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Shows property keys and associated values<\/caption>\n+ * <thead>\n+ * <tr><th scope=\"col\">Locale-related System Properties Key<\/th>\n+ *     <th scope=\"col\">Description<\/th><\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><th scope=\"row\">{@systemProperty user.language}<\/th>\n+ *     <td>{@link ##def_language language} for the default Locale,\n+ *     such as \"en\" (English)<\/td><\/tr>\n+ * <tr><th scope=\"row\">{@systemProperty user.script}<\/th>\n+ *     <td>{@link ##def_script script} for the default Locale,\n+ *     such as \"Latn\" (Latin)<\/td><\/tr>\n+ * <tr><th scope=\"row\">{@systemProperty user.country}<\/th>\n+ *     <td>{@link ##def_region country} for the default Locale,\n+ *     such as \"US\" (United States)<\/td><\/tr>\n+ * <tr><th scope=\"row\">{@systemProperty user.variant}<\/th>\n+ *     <td>{@link ##def_variant variant} for the default Locale,\n+ *     such as \"POSIX\"<\/td><\/tr>\n+ * <tr><th scope=\"row\">{@systemProperty user.extensions}<\/th>\n+ *     <td>{@link ##def_extensions extensions} for the default Locale,\n+ *     such as \"u-ca-japanese\" (Japanese Calendar)<\/td><\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ * <\/li>\n+ * <li>The values of these system properties can be overridden by values designated\n+ * at startup time. If the overriding value of the {@code user.extensions} property\n+ * is unparsable, it is ignored. The overriding values of other properties are not\n+ * checked for syntax or validity and are used directly in the default Locale.\n+ * (Typically, system property values can be provided using the {@code -D} command-line\n+ * option of a launcher. For example, specifying {@code -Duser.extensions=foobarbaz}\n+ * results in a default Locale with no extensions, while specifying\n+ * {@code -Duser.language=foobarbaz} results in a default Locale whose language is\n+ * \"foobarbaz\".)\n+ * <\/li>\n+ * <li>The default {@code Locale} instance is constructed from the values of these\n+ * system properties.\n+ * <\/li>\n+ * <\/ol>\n+ * <p>Altering the system property values with {@link System#setProperties(Properties)}\/\n+ * {@link System#setProperty(String, String)} has no effect on the default Locale.\n+ * <p>Once the default Locale is established, applications can query the default\n+ * Locale with {@link #getDefault()} and change it with {@link #setDefault(Locale)}.\n+ * If the default Locale is changed with {@link #setDefault(Locale)}, the corresponding\n+ * system properties are not altered. It is not recommended that applications read\n+ * these system properties and parse or interpret them as their values may be out of date.\n+ *\n+ * <p>There are finer-grained default Locales specific for each {@link Locale.Category}.\n+ * These category specific default Locales can be queried by {@link #getDefault(Category)},\n+ * and set by {@link #setDefault(Category, Locale)}. Construction of these category\n+ * specific default Locales are determined by the corresponding system properties,\n+ * which consist of the base system properties as listed above, suffixed by either\n+ * {@code \".display\"} or {@code \".format\"} depending on the category. For example,\n+ * the value of the {@code user.language.display} system property will be used in the\n+ * {@code language} part of the default Locale for the {@link Locale.Category#DISPLAY}\n+ * category. In the absence of category specific system properties, the \"category-less\"\n+ * system properties are used, such as {@code user.language} in the previous example.\n+ *\n@@ -987,2 +1056,2 @@\n-     * Gets the current value of the default locale for this instance\n-     * of the Java Virtual Machine.\n+     * Gets the current value of the {@link ##default_locale default locale} for\n+     * this instance of the Java Virtual Machine.\n@@ -994,1 +1063,1 @@\n-     * {@link #setDefault(java.util.Locale) setDefault} method.\n+     * {@link #setDefault(Locale)} method.\n@@ -1004,2 +1073,2 @@\n-     * Gets the current value of the default locale for the specified Category\n-     * for this instance of the Java Virtual Machine.\n+     * Gets the current value of the {@link ##default_locale default locale} for\n+     * the specified Category for this instance of the Java Virtual Machine.\n@@ -1010,1 +1079,1 @@\n-     * setDefault(Locale.Category, Locale) method.\n+     * {@link #setDefault(Locale.Category, Locale)} method.\n@@ -1111,2 +1180,3 @@\n-     * Sets the default locale for this instance of the Java Virtual Machine.\n-     * This does not affect the host locale.\n+     * Sets the {@link ##default_locale default locale} for\n+     * this instance of the Java Virtual Machine. This does not affect the\n+     * host locale.\n@@ -1145,2 +1215,3 @@\n-     * Sets the default locale for the specified Category for this instance\n-     * of the Java Virtual Machine. This does not affect the host locale.\n+     * Sets the {@link ##default_locale default locale} for the specified\n+     * Category for this instance of the Java Virtual Machine. This does\n+     * not affect the host locale.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":81,"deletions":10,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -98,1 +98,2 @@\n-    private final String name;     \/\/ zip file name\n+    private final String filePath;     \/\/ zip file path\n+    private final String fileName;     \/\/ name of the file\n@@ -248,1 +249,2 @@\n-        this.name = name;\n+        this.filePath = name;\n+        this.fileName = file.getName();\n@@ -486,1 +488,10 @@\n-        return name;\n+        return filePath;\n+    }\n+\n+    \/**\n+     * {@return a string identifying this {@code ZipFile}, for debugging}\n+     *\/\n+    @Override\n+    public String toString() {\n+        return this.fileName\n+                + \"@\" + Integer.toHexString(System.identityHashCode(this));\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -156,3 +156,1 @@\n-        if (newSize < 0) {\n-            throw new IllegalArgumentException(\"newSize < 0\");\n-        }\n+        Utils.checkNonNegativeArgument(newSize, \"newSize\");\n@@ -597,0 +595,1 @@\n+        Utils.checkNonNegativeIndex(elementCount, \"elementCount\");\n@@ -628,1 +627,1 @@\n-\n+        Utils.checkNonNegativeIndex(elementCount, \"elementCount\");\n@@ -655,1 +654,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -203,5 +203,2 @@\n-        \/\/ size should be >= 0\n-        if (byteSize < 0) {\n-            throw new IllegalArgumentException(\"Invalid allocation size : \" + byteSize);\n-        }\n-\n+        \/\/ byteSize should be >= 0\n+        Utils.checkNonNegativeArgument(byteSize, \"allocation size\");\n@@ -219,0 +216,14 @@\n+    @ForceInline\n+    public static void checkNonNegativeArgument(long value, String name) {\n+        if (value < 0) {\n+            throw new IllegalArgumentException(\"The provided \" + name + \" is negative: \" + value);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void checkNonNegativeIndex(long value, String name) {\n+        if (value < 0) {\n+            throw new IndexOutOfBoundsException(\"The provided \" + name + \" is negative: \" + value);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -154,7 +154,2 @@\n-        if (offset < 0) {\n-            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n-        }\n-        if (index < 0) {\n-            throw new IllegalArgumentException(\"Negative index: \" + index);\n-        }\n-\n+        Utils.checkNonNegativeArgument(offset, \"offset\");\n+        Utils.checkNonNegativeArgument(index, \"index\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,7 +33,0 @@\n-    public static long requireNonNegative(long value) {\n-        if (value < 0) {\n-            throw new IllegalArgumentException(\"The provided value was negative: \" + value);\n-        }\n-        return value;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/MemoryLayoutUtil.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,0 +67,5 @@\n+        \/\/ -Xbootclasspath\/a or -javaagent with Boot-Class-Path attribute\n+        String append = VM.getSavedProperty(\"jdk.boot.class.path.append\");\n+        URLClassPath bootUcp = (append != null && !append.isEmpty())\n+                ? new URLClassPath(append, true)\n+                : null;\n@@ -68,1 +73,0 @@\n-            \/\/ assert VM.getSavedProperty(\"jdk.boot.class.path.append\") == null\n@@ -70,0 +74,1 @@\n+            BOOT_LOADER.setClassPath(bootUcp);\n@@ -74,6 +79,1 @@\n-            \/\/ -Xbootclasspath\/a or -javaagent with Boot-Class-Path attribute\n-            String append = VM.getSavedProperty(\"jdk.boot.class.path.append\");\n-            URLClassPath ucp = (append != null && !append.isEmpty())\n-                    ? new URLClassPath(append, true)\n-                    : null;\n-            BOOT_LOADER = new BootClassLoader(ucp);\n+            BOOT_LOADER = new BootClassLoader(bootUcp);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/ClassLoaders.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,1 @@\n-        return java.util.Arrays.equals(b, chkB);\n+        return Arrays.equals(b, chkB);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ftp\/impl\/FtpClient.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,18 @@\n-    public void interrupt(Thread t);\n+    \/**\n+     * Invoked by Thread.interrupt when the given Thread is interrupted. Thread.interrupt\n+     * invokes this method while holding the given Thread's interrupt lock. This method\n+     * is also invoked by AbstractInterruptibleChannel when beginning an I\/O operation\n+     * with the current thread's interrupt status set. This method must not block.\n+     *\/\n+    void interrupt(Thread target);\n+\n+    \/**\n+     * Invoked by Thread.interrupt after releasing the Thread's interrupt lock.\n+     * It may also be invoked by AbstractInterruptibleChannel or AbstractSelector when\n+     * beginning an I\/O operation with the current thread's interrupt status set, or at\n+     * the end of an I\/O operation when any thread doing I\/O on the channel (or selector)\n+     * has been interrupted. This method closes the channel (or wakes up the Selector) to\n+     * ensure that AsynchronousCloseException or ClosedByInterruptException is thrown.\n+     * This method is required to be idempotent.\n+     *\/\n+    void postInterrupt();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Interruptible.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2023c\n+tzdata2023d\n","filename":"src\/java.base\/share\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,7 +311,0 @@\n-# From Paul Eggert (2014-06-04):\n-# Sarah El Deeb and Lee Keath of AP report that the Egyptian government says\n-# the change is because of blackouts in Cairo, even though Ahram Online (cited\n-# above) says DST had no affect on electricity consumption.  There is\n-# no information about when DST will end this fall.  See:\n-# http:\/\/abcnews.go.com\/International\/wireStory\/el-sissi-pushes-egyptians-line-23614833\n-\n","filename":"src\/java.base\/share\/data\/tzdata\/africa","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -106,0 +106,5 @@\n+# From Paul Eggert (2023-12-20):\n+# Transitions from 2021 on are taken from:\n+# https:\/\/www.timeanddate.com\/time\/zone\/antarctica\/casey\n+# retrieved at various dates.\n+\n@@ -119,1 +124,6 @@\n-\t\t\t11:00\t-\t+11\n+\t\t\t11:00\t-\t+11\t2021 Mar 14  0:00\n+\t\t\t 8:00\t-\t+08\t2021 Oct  3  0:01\n+\t\t\t11:00\t-\t+11\t2022 Mar 13  0:00\n+\t\t\t 8:00\t-\t+08\t2022 Oct  2  0:01\n+\t\t\t11:00\t-\t+11\t2023 Mar  9  3:00\n+\t\t\t 8:00\t-\t+08\n@@ -266,1 +276,44 @@\n-# See Asia\/Urumqi.\n+# From Craig Mundell (1994-12-15):\n+# http:\/\/quest.arc.nasa.gov\/antarctica\/QA\/computers\/Directions,Time,ZIP\n+# Vostok, which is one of the Russian stations, is set on the same\n+# time as Moscow, Russia.\n+#\n+# From Lee Hotz (2001-03-08):\n+# I queried the folks at Columbia who spent the summer at Vostok and this is\n+# what they had to say about time there:\n+# \"in the US Camp (East Camp) we have been on New Zealand (McMurdo)\n+# time, which is 12 hours ahead of GMT. The Russian Station Vostok was\n+# 6 hours behind that (although only 2 miles away, i.e. 6 hours ahead\n+# of GMT). This is a time zone I think two hours east of Moscow. The\n+# natural time zone is in between the two: 8 hours ahead of GMT.\"\n+#\n+# From Paul Eggert (2001-05-04):\n+# This seems to be hopelessly confusing, so I asked Lee Hotz about it\n+# in person.  He said that some Antarctic locations set their local\n+# time so that noon is the warmest part of the day, and that this\n+# changes during the year and does not necessarily correspond to mean\n+# solar noon.  So the Vostok time might have been whatever the clocks\n+# happened to be during their visit.  So we still don't really know what time\n+# it is at Vostok.\n+#\n+# From Zakhary V. Akulov (2023-12-17 22:00:48 +0700):\n+# ... from December, 18, 2023 00:00 by my decision the local time of\n+# the Antarctic research base Vostok will correspond to UTC+5.\n+# (2023-12-19): We constantly interact with Progress base, with company who\n+# builds new wintering station, with sledge convoys, with aviation - they all\n+# use UTC+5. Besides, difference between Moscow time is just 2 hours now, not 4.\n+# (2023-12-19, in response to the question \"Has local time at Vostok\n+# been UTC+6 ever since 1957, or has it changed before?\"): No. At least\n+# since my antarctic career start, 10 years ago, Vostok base has UTC+7.\n+# (In response to a 2023-12-18 question \"from 02:00 to 00:00 today\"): This.\n+#\n+# From Paul Eggert (2023-12-18):\n+# For lack of better info, guess Vostok was at +07 from founding through today,\n+# except when closed.\n+\n+# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n+Zone Antarctica\/Vostok\t0\t-\t-00\t1957 Dec 16\n+\t\t\t7:00\t-\t+07\t1994 Feb\n+\t\t\t0\t-\t-00\t1994 Nov\n+\t\t\t7:00\t-\t+07\t2023 Dec 18  2:00\n+\t\t\t5:00\t-\t+05\n","filename":"src\/java.base\/share\/data\/tzdata\/antarctica","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -681,1 +681,0 @@\n-# Vostok base in Antarctica matches this since 1970.\n@@ -3453,0 +3452,3 @@\n+# From Heba Hemad (2023-10-09):\n+# ... winter time will begin in Palestine from Saturday 10-28-2023,\n+# 02:00 AM by 60 minutes back.\n@@ -3574,0 +3576,1 @@\n+Rule Palestine\t2072\tmax\t-\tOct\tSat<=30\t2:00\t0\t-\n@@ -3580,1 +3583,0 @@\n-Rule Palestine\t2075\tmax\t-\tOct\tSat<=30\t2:00\t0\t-\n","filename":"src\/java.base\/share\/data\/tzdata\/asia","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -417,0 +417,6 @@\n+\n+# From Almaz Mingaleev (2023-10-06):\n+# Cabinet approved the suspension of Daylight Saving and appropriate\n+# legislative changes will be considered including the repeal of the\n+# Daylight Saving Act 1998\n+# https:\/\/www.fiji.gov.fj\/Media-Centre\/Speeches\/English\/CABINET-DECISIONS-3-OCTOBER-2023\n@@ -418,1 +424,1 @@\n-# From Paul Eggert (2022-10-27):\n+# From Paul Eggert (2023-10-06):\n","filename":"src\/java.base\/share\/data\/tzdata\/australasia","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-Link\tAsia\/Urumqi\t\tAntarctica\/Vostok\n","filename":"src\/java.base\/share\/data\/tzdata\/backward","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1149,0 +1149,17 @@\n+#\n+# From Múte Bourup Egede via Jógvan Svabo Samuelsen (2023-03-15):\n+# Greenland will not switch to Daylight Saving Time this year, 2023,\n+# because the standard time for Greenland will change from UTC -3 to UTC -2.\n+# However, Greenland will change to Daylight Saving Time again in 2024\n+# and onwards.\n+\n+# From a contributor who wishes to remain anonymous for now (2023-10-29):\n+# https:\/\/www.dr.dk\/nyheder\/seneste\/i-nat-skal-uret-stilles-en-time-tilbage-men-foerste-gang-sker-det-ikke-i-groenland\n+# with a link to that page:\n+# https:\/\/naalakkersuisut.gl\/Nyheder\/2023\/10\/2710_sommertid\n+# ... Ittoqqortoormiit joins the time of Nuuk at March 2024.\n+# What would mean that America\/Scoresbysund would either be in -01 year round\n+# or in -02\/-01 like America\/Nuuk, but no longer in -01\/+00.\n+#\n+# From Paul Eggert (2023-10-29):\n+# For now, assume it will be like America\/Nuuk.\n@@ -1169,1 +1186,2 @@\n-\t\t\t-1:00\tEU\t-01\/+00\n+\t\t\t-1:00\tEU\t-01\/+00 2024 Mar 31\n+\t\t\t-2:00\tEU\t-02\/-01\n@@ -1172,1 +1190,2 @@\n-\t\t\t-3:00\tEU\t-03\/-02\t2023 Oct 29  1:00u\n+\t\t\t-3:00\tEU\t-03\/-02\t2023 Mar 26  1:00u\n+\t\t\t-2:00\t-\t-02\t2023 Oct 29  1:00u\n@@ -3737,5 +3756,1 @@\n-# The next change in October 1996 happened under EU rules....\n-# TZ database holds three other zones for Ukraine.... I have not yet\n-# worked out the consequences for these three zones, as we (me and my\n-# US colleague David Cochrane) are still trying to get more\n-# information upon these local deviations from Kiev rules.\n+# The next change in October 1996 happened under EU rules.\n","filename":"src\/java.base\/share\/data\/tzdata\/europe","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-# From Paul Eggert (2022-11-18):\n+# From Paul Eggert (2023-09-06):\n@@ -35,5 +35,10 @@\n-#     ISO 3166-1 N1087 (2022-09-02).  See: Updates on ISO 3166-1\n-#     https:\/\/isotc.iso.org\/livelink\/livelink\/Open\/16944257\n-# 2.  The usual English name for the coded region,\n-#     chosen so that alphabetic sorting of subsets produces helpful lists.\n-#     This is not the same as the English name in the ISO 3166 tables.\n+#     ISO\/TC 46 N1108 (2023-04-05).  See: ISO\/TC 46 Documents\n+#     https:\/\/www.iso.org\/committee\/48750.html?view=documents\n+# 2.  The usual English name for the coded region.  This sometimes\n+#     departs from ISO-listed names, sometimes so that sorted subsets\n+#     of names are useful (e.g., \"Samoa (American)\" and \"Samoa\n+#     (western)\" rather than \"American Samoa\" and \"Samoa\"),\n+#     sometimes to avoid confusion among non-experts (e.g.,\n+#     \"Czech Republic\" and \"Turkey\" rather than \"Czechia\" and \"Türkiye\"),\n+#     and sometimes to omit needless detail or churn (e.g., \"Netherlands\"\n+#     rather than \"Netherlands (the)\" or \"Netherlands (Kingdom of the)\").\n","filename":"src\/java.base\/share\/data\/tzdata\/iso3166.tab","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-#Expires 2023\tDec\t28\t00:00:00\n+#Expires 2024\tJun\t28\t00:00:00\n@@ -102,1 +102,1 @@\n-#expires 1703721600 (2023-12-28 00:00:00 UTC)\n+#expires 1719532800 (2024-06-28 00:00:00 UTC)\n@@ -104,2 +104,2 @@\n-#\tUpdated through IERS Bulletin C65\n-#\tFile expires on:  28 December 2023\n+#\tUpdated through IERS Bulletin C66\n+#\tFile expires on:  28 June 2024\n","filename":"src\/java.base\/share\/data\/tzdata\/leapseconds","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+#\n@@ -1478,1 +1479,1 @@\n-# St John's has an apostrophe, but Posix file names can't have apostrophes.\n+# St John's has an apostrophe, but POSIX file names can't have apostrophes.\n","filename":"src\/java.base\/share\/data\/tzdata\/northamerica","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1723,0 +1723,6 @@\n+#\n+# From Paul Eggert (2023-07-26):\n+# Transition dates are now set by Law No. 7115, not by presidential decree.\n+# https:\/\/www.abc.com.py\/politica\/2023\/07\/12\/promulgacion-el-cambio-de-hora-sera-por-ley\/\n+# From Carlos Raúl Perasso (2023-07-27):\n+# http:\/\/silpy.congreso.gov.py\/descarga\/ley-144138\n","filename":"src\/java.base\/share\/data\/tzdata\/southamerica","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-AR\t-2828-06547\tAmerica\/Argentina\/Catamarca\tCatamarca (CT); Chubut (CH)\n+AR\t-2828-06547\tAmerica\/Argentina\/Catamarca\tCatamarca (CT), Chubut (CH)\n@@ -113,1 +113,1 @@\n-BR\t-0127-04829\tAmerica\/Belem\tPara (east); Amapa\n+BR\t-0127-04829\tAmerica\/Belem\tPara (east), Amapa\n@@ -133,2 +133,2 @@\n-CA\t+4734-05243\tAmerica\/St_Johns\tNewfoundland; Labrador (southeast)\n-CA\t+4439-06336\tAmerica\/Halifax\tAtlantic - NS (most areas); PE\n+CA\t+4734-05243\tAmerica\/St_Johns\tNewfoundland, Labrador (SE)\n+CA\t+4439-06336\tAmerica\/Halifax\tAtlantic - NS (most areas), PE\n@@ -139,1 +139,1 @@\n-CA\t+4339-07923\tAmerica\/Toronto\tEastern - ON, QC (most areas)\n+CA\t+4339-07923\tAmerica\/Toronto\tEastern - ON & QC (most areas)\n@@ -141,2 +141,2 @@\n-CA\t+484531-0913718\tAmerica\/Atikokan\tEST - ON (Atikokan); NU (Coral H)\n-CA\t+4953-09709\tAmerica\/Winnipeg\tCentral - ON (west); Manitoba\n+CA\t+484531-0913718\tAmerica\/Atikokan\tEST - ON (Atikokan), NU (Coral H)\n+CA\t+4953-09709\tAmerica\/Winnipeg\tCentral - ON (west), Manitoba\n@@ -147,1 +147,1 @@\n-CA\t+5333-11328\tAmerica\/Edmonton\tMountain - AB; BC (E); NT (E); SK (W)\n+CA\t+5333-11328\tAmerica\/Edmonton\tMountain - AB, BC(E), NT(E), SK(W)\n@@ -233,2 +233,2 @@\n-ID\t-0507+11924\tAsia\/Makassar\tBorneo (east, south); Sulawesi\/Celebes, Bali, Nusa Tengarra; Timor (west)\n-ID\t-0232+14042\tAsia\/Jayapura\tNew Guinea (West Papua \/ Irian Jaya); Malukus\/Moluccas\n+ID\t-0507+11924\tAsia\/Makassar\tBorneo (east, south), Sulawesi\/Celebes, Bali, Nusa Tengarra, Timor (west)\n+ID\t-0232+14042\tAsia\/Jayapura\tNew Guinea (West Papua \/ Irian Jaya), Malukus\/Moluccas\n@@ -381,1 +381,1 @@\n-RU\t+6728+15343\tAsia\/Srednekolymsk\tMSK+08 - Sakha (E); N Kuril Is\n+RU\t+6728+15343\tAsia\/Srednekolymsk\tMSK+08 - Sakha (E), N Kuril Is\n@@ -444,1 +444,1 @@\n-US\t+433649-1161209\tAmerica\/Boise\tMountain - ID (south); OR (east)\n+US\t+433649-1161209\tAmerica\/Boise\tMountain - ID (south), OR (east)\n","filename":"src\/java.base\/share\/data\/tzdata\/zone.tab","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -595,1 +595,1 @@\n-        java.util.Arrays.fill(valid, (byte)0xff);\n+        Arrays.fill(valid, (byte)0xff);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/IndexColorModel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -924,1 +924,1 @@\n-            if (!SwingUtilities.isLeftMouseButton(e) || !comboBox.isEnabled())\n+            if (!SwingUtilities.isLeftMouseButton(e) || !comboBox.isEnabled() || !comboBox.isShowing())\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicComboPopup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,0 +180,5 @@\n+    cmsUInt32Number dwFlags = 0;\n+    if (T_EXTRA(inFormatter) > 0 && T_EXTRA(outFormatter) > 0) {\n+        dwFlags |= cmsFLAGS_COPY_ALPHA;\n+    }\n+\n@@ -181,1 +186,1 @@\n-        inFormatter, outFormatter, renderingIntent, cmsFLAGS_COPY_ALPHA);\n+        inFormatter, outFormatter, renderingIntent, dwFlags);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/LCMS.c","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -495,1 +495,1 @@\n-jobject newInsets(JNIEnv *env, jint top, jint left, jint bottom, jint right) {\n+static jobject newInsets(JNIEnv *env, jint top, jint left, jint bottom, jint right) {\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/ThemeReader.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,2 @@\n-    JNU_CallStaticMethodByName(env, NULL,\n+    jboolean hasException;\n+    JNU_CallStaticMethodByName(env, &hasException,\n@@ -132,0 +133,5 @@\n+    if (hasException) {\n+        J2dTraceLn(J2D_TRACE_INFO, \"Exception occurred in DWMIsCompositionEnabled\");\n+        env->ExceptionDescribe();\n+        env->ExceptionClear();\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsEnv.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,1 @@\n-        java.util.Arrays.fill(times, -1);\n+        Arrays.fill(times, -1);\n@@ -309,1 +309,1 @@\n-        java.util.Arrays.fill(times, -1);\n+        Arrays.fill(times, -1);\n@@ -393,1 +393,1 @@\n-        java.util.Arrays.fill(sizes, -1);\n+        Arrays.fill(sizes, -1);\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ThreadImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @LastModified: Nov 2023\n+ * @LastModified: Jan 2024\n@@ -187,0 +187,3 @@\n+        if (XMLInputFactory.SUPPORT_DTD.equals(property)) {\n+            return fSecurityManager.is(XMLSecurityManager.Limit.STAX_SUPPORT_DTD);\n+        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/PropertyManager.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n- * @LastModified: July 2023\n+ * @LastModified: Jan 2024\n@@ -1834,0 +1834,5 @@\n+            \/\/ Handle properties managed by XMLSecurityManager\n+            if (featureId.equals(XMLSecurityManager.DISALLOW_DTD)) {\n+                return securityManager.is(XMLSecurityManager.Limit.XERCES_DISALLOW_DTD);\n+            }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/parsers\/AbstractSAXParser.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -1306,1 +1307,1 @@\n-        public List<Symbol> permitted;\n+        private java.util.List<PermittedClassWithPos> permitted;\n@@ -1310,0 +1311,2 @@\n+        private record PermittedClassWithPos(Symbol permittedClass, int pos) {}\n+\n@@ -1318,1 +1321,1 @@\n-            this.permitted = List.nil();\n+            this.permitted = new ArrayList<>();\n@@ -1330,0 +1333,31 @@\n+        public void addPermittedSubclass(ClassSymbol csym, int pos) {\n+            Assert.check(!isPermittedExplicit);\n+            \/\/ we need to insert at the right pos\n+            PermittedClassWithPos element = new PermittedClassWithPos(csym, pos);\n+            int index = Collections.binarySearch(permitted, element, java.util.Comparator.comparing(PermittedClassWithPos::pos));\n+            if (index < 0) {\n+                index = -index - 1;\n+            }\n+            permitted.add(index, element);\n+        }\n+\n+        public boolean isPermittedSubclass(Symbol csym) {\n+            for (PermittedClassWithPos permittedClassWithPos : permitted) {\n+                if (permittedClassWithPos.permittedClass.equals(csym)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public void clearPermittedSubclasses() {\n+            permitted.clear();\n+        }\n+\n+        public void setPermittedSubclasses(List<Symbol> permittedSubs) {\n+            permitted.clear();\n+            for (Symbol csym : permittedSubs) {\n+                permitted.add(new PermittedClassWithPos(csym, 0));\n+            }\n+        }\n+\n@@ -1646,1 +1680,1 @@\n-            return permitted.map(s -> s.type);\n+            return permitted.stream().map(s -> s.permittedClass().type).collect(List.collector());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1704,1 +1704,1 @@\n-                    return sealedOne.permitted.stream().allMatch(sym -> areDisjoint((ClassSymbol)sym, other));\n+                    return sealedOne.getPermittedSubclasses().stream().allMatch(type -> areDisjoint((ClassSymbol)type.tsym, other));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5386,1 +5386,1 @@\n-                        c.permitted.isEmpty()) {\n+                        c.getPermittedSubclasses().isEmpty()) {\n@@ -5393,1 +5393,1 @@\n-                    for (Symbol subTypeSym : c.permitted) {\n+                    for (Type subType : c.getPermittedSubclasses()) {\n@@ -5395,1 +5395,1 @@\n-                        if (subTypeSym.type.getTag() == TYPEVAR) {\n+                        if (subType.getTag() == TYPEVAR) {\n@@ -5397,2 +5397,2 @@\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                    Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                    Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subType)));\n@@ -5400,2 +5400,2 @@\n-                        if (subTypeSym.isAnonymous() && !c.isEnum()) {\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n+                        if (subType.tsym.isAnonymous() && !c.isEnum()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n@@ -5403,1 +5403,1 @@\n-                        if (permittedTypes.contains(subTypeSym)) {\n+                        if (permittedTypes.contains(subType.tsym)) {\n@@ -5406,1 +5406,1 @@\n-                                            .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n+                                            .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subType.tsym, permittedExpr, true) != null)\n@@ -5408,1 +5408,1 @@\n-                            log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n+                            log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subType)));\n@@ -5410,1 +5410,1 @@\n-                            permittedTypes.add(subTypeSym);\n+                            permittedTypes.add(subType.tsym);\n@@ -5413,2 +5413,2 @@\n-                            if (subTypeSym.packge() != c.packge()) {\n-                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                            if (subType.tsym.packge() != c.packge()) {\n+                                log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n@@ -5418,2 +5418,2 @@\n-                        } else if (subTypeSym.packge().modle != c.packge().modle) {\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                        } else if (subType.tsym.packge().modle != c.packge().modle) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n@@ -5423,2 +5423,2 @@\n-                        if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n+                        if (subType.tsym == c.type.tsym || types.isSuperType(subType, c.type)) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, ((JCClassDecl)env.tree).permitting),\n@@ -5426,1 +5426,1 @@\n-                                            subTypeSym == c.type.tsym ?\n+                                            subType.tsym == c.type.tsym ?\n@@ -5428,1 +5428,1 @@\n-                                                    Fragments.MustNotBeSupertype(subTypeSym.type)\n+                                                    Fragments.MustNotBeSupertype(subType)\n@@ -5432,1 +5432,1 @@\n-                            boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n+                            boolean thisIsASuper = types.directSupertypes(subType)\n@@ -5436,2 +5436,2 @@\n-                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                        Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                                log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                        Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subType)));\n@@ -5472,1 +5472,1 @@\n-                            if (!supertypeSym.permitted.contains(c.type.tsym)) {\n+                            if (!supertypeSym.isPermittedSubclass(c.type.tsym)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -948,2 +948,2 @@\n-                    for (Symbol sym : current.permitted) {\n-                        ClassSymbol csym = (ClassSymbol) sym;\n+                    for (Type t : current.getPermittedSubclasses()) {\n+                        ClassSymbol csym = (ClassSymbol) t.tsym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-                            supClass.permitted = supClass.permitted.append(sym);\n+                            supClass.addPermittedSubclass(sym, tree.pos);\n@@ -935,1 +935,1 @@\n-                sym.permitted = permittedSubtypeSymbols.toList();\n+                sym.setPermittedSubclasses(permittedSubtypeSymbols.toList());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1301,1 +1301,1 @@\n-                        ((ClassSymbol)sym).permitted = subtypes.toList();\n+                        ((ClassSymbol)sym).setPermittedSubclasses(subtypes.toList());\n@@ -2933,1 +2933,1 @@\n-        if (c.permitted != null && !c.permitted.isEmpty()) {\n+        if (!c.getPermittedSubclasses().isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -925,1 +925,1 @@\n-        if (csym.permitted.nonEmpty()) {\n+        if (csym.getPermittedSubclasses().nonEmpty()) {\n@@ -927,3 +927,3 @@\n-            databuf.appendChar(csym.permitted.size());\n-            for (Symbol c : csym.permitted) {\n-                databuf.appendChar(poolWriter.putClass((ClassSymbol) c));\n+            databuf.appendChar(csym.getPermittedSubclasses().size());\n+            for (Type t : csym.getPermittedSubclasses()) {\n+                databuf.appendChar(poolWriter.putClass((ClassSymbol) t.tsym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -970,0 +970,14 @@\n+    protected JCExpression parseIntersectionType(int pos, JCExpression firstType) {\n+        JCExpression t = firstType;\n+        int pos1 = pos;\n+        List<JCExpression> targets = List.of(t);\n+        while (token.kind == AMP) {\n+            accept(AMP);\n+            targets = targets.prepend(parseType());\n+        }\n+        if (targets.length() > 1) {\n+            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));\n+        }\n+        return t;\n+    }\n+\n@@ -1340,9 +1354,1 @@\n-                       int pos1 = pos;\n-                       List<JCExpression> targets = List.of(t = parseType());\n-                       while (token.kind == AMP) {\n-                           accept(AMP);\n-                           targets = targets.prepend(parseType());\n-                       }\n-                       if (targets.length() > 1) {\n-                           t = toP(F.at(pos1).TypeIntersection(targets.reverse()));\n-                       }\n+                       t = parseIntersectionType(pos, parseType());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1646,1 +1646,1 @@\n-                    node.sym.permitted = List.nil();\n+                    node.sym.clearPermittedSubclasses();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/CallSiteDescriptor.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/DynamicLinker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/DynamicLinkerFactory.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/NamedOperation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/Namespace.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/NamespaceOperation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/NoSuchDynamicMethodException.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/Operation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/RelinkableCallSite.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/SecureLookupSupplier.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/StandardNamespace.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/StandardOperation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/BeansLinker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/MissingMemberHandlerFactory.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/StaticClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+ * @since 9\n@@ -77,0 +78,1 @@\n+     * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/ConversionComparator.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/GuardedInvocation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/GuardedInvocationTransformer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/GuardingDynamicLinker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/GuardingDynamicLinkerExporter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/GuardingTypeConverterFactory.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/LinkRequest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/LinkerServices.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/MethodHandleTransformer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/MethodTypeConversionStrategy.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/TypeBasedGuardingDynamicLinker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/support\/CompositeGuardingDynamicLinker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/support\/CompositeTypeBasedGuardingDynamicLinker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/support\/DefaultInternalObjectFilter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/support\/Guards.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/support\/Lookup.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/support\/SimpleLinkRequest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/support\/TypeUtilities.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/package-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/support\/AbstractRelinkableCallSite.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/support\/ChainedCallSite.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+ * @since 9\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/support\/SimpleRelinkableCallSite.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -210,0 +210,6 @@\n+    \/**\n+     * @return {@code true} if the given speculation can be performed, i.e., it never failed so far, otherwise\n+     * return {@code false}. Note, that this method returns consistent results for any given speculation for the\n+     * entire lifetime of the enclosing SpeculationLog object. This means that speculations failed during a\n+     * compilation will not be updated.\n+     *\/\n@@ -212,3 +218,0 @@\n-        if (failedSpeculations == null) {\n-            collectFailedSpeculations();\n-        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationLog.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -295,0 +295,3 @@\n+                if (!ok) {\n+                    return false;\n+                }\n@@ -341,0 +344,3 @@\n+                if (!ok) {\n+                    return false;\n+                }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.util.stream.Stream;\n@@ -460,0 +461,1 @@\n+            log.flush();\n@@ -660,1 +662,1 @@\n-            throw new OptionException(ERROR, this::showUsage, text);\n+            throw new OptionException(ERROR, () -> reportBadOption(arg), text);\n@@ -665,0 +667,33 @@\n+    private void reportBadOption(String name) {\n+        var allOptionNames = Stream.concat(\n+                getToolOptions().getSupportedOptions().stream()\n+                        .flatMap(o -> o.getNames().stream()),\n+                docletOptions.stream()\n+                        .flatMap(o -> o.getNames().stream()));\n+        record Pair(String word, double similarity) { }\n+        final double MIN_SIMILARITY = 0.7;\n+        var suggestions = allOptionNames\n+                .map(t -> new Pair(t, similarity(t, name)))\n+                .sorted(Comparator.comparingDouble(Pair::similarity).reversed() \/* more similar first *\/)\n+                \/\/ .peek(p -> System.out.printf(\"%.3f, (%s ~ %s)%n\", p.similarity, p.word, name)) \/\/ debug\n+                .takeWhile(p -> Double.compare(p.similarity, MIN_SIMILARITY) >= 0)\n+                .map(Pair::word)\n+                .toList();\n+        switch (suggestions.size()) {\n+            case 0 -> { }\n+            case 1 -> showLinesUsingKey(\"main.did-you-mean\", suggestions.getFirst());\n+            default -> showLinesUsingKey(\"main.did-you-mean-one-of\", String.join(\" \", suggestions));\n+        }\n+        showLinesUsingKey(\"main.for-more-details-see-usage\");\n+    }\n+\n+    \/\/ a value in [0, 1] range: the closer the value is to 1, the more similar\n+    \/\/ the strings are\n+    private static double similarity(String a, String b) {\n+        \/\/ Normalize the distance so that similarity between \"x\" and \"y\" is\n+        \/\/ less than that of \"ax\" and \"ay\". Use the greater of two lengths\n+        \/\/ as normalizer, as it's an upper bound for the distance.\n+        return 1.0 - ((double) StringUtils.DamerauLevenshteinDistance.of(a, b))\n+                \/ Math.max(a.length(), b.length());\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/Start.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,9 @@\n+main.did-you-mean=\\\n+    Did you mean: {0}\n+\n+main.did-you-mean-one-of=\\\n+    Did you mean one of: {0}\n+\n+main.for-more-details-see-usage=\\\n+    For more details on available options, use --help or --help-extra\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc.properties","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-.PP\n+.IP \\[bu] 2\n@@ -179,1 +179,1 @@\n-.PP\n+.IP \\[bu] 2\n@@ -205,1 +205,1 @@\n-.PP\n+.IP \\[bu] 2\n@@ -256,1 +256,1 @@\n-.PP\n+.IP \\[bu] 2\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-            throw new IOException(x.getMessage());\n+            throw new IOException(x);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ProcessAttachingConnector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-            throw new IOException(e.getMessage());\n+            throw new IOException(e);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/VirtualMachineManagerImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -755,1 +755,1 @@\n-                if (isEqualIPv6Addr(listenAddr, in6addr_any)) {\n+                if (isEqualIPv6Addr(ai, in6addr_any)) {\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libdt_socket\/socketTransport.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2626,0 +2626,32 @@\n+#ifdef DEBUG_THREADNAME\n+static void\n+setThreadName(ThreadNode *node)\n+{\n+    \/*\n+     * Sometimes the debuggee changes the thread name, so we need to fetch\n+     * and set it again.\n+     *\/\n+    jvmtiThreadInfo info;\n+    jvmtiError error;\n+\n+    memset(&info, 0, sizeof(info));\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n+        (gdata->jvmti, node->thread, &info);\n+    if (info.name != NULL) {\n+        strncpy(node->name, info.name, sizeof(node->name) - 1);\n+        jvmtiDeallocate(info.name);\n+    }\n+}\n+#endif\n+\n+#if 0\n+static jint\n+getThreadState(ThreadNode *node)\n+{\n+    jint state = 0;\n+    jvmtiError error = FUNC_PTR(gdata->jvmti,GetThreadState)\n+        (gdata->jvmti, node->thread, &state);\n+    return state;\n+}\n+#endif\n+\n@@ -2628,1 +2660,1 @@\n-    tty_message(\"  Thread: node = %p, jthread = %p\", node, node->thread);\n+    tty_message(\"Thread: node = %p, jthread = %p\", node, node->thread);\n@@ -2630,0 +2662,1 @@\n+    setThreadName(node);\n@@ -2635,0 +2668,10 @@\n+#if 0\n+    tty_message(\"\\tsuspendAllCount: %d\", suspendAllCount);\n+    tty_message(\"\\tthreadState: 0x%x\", getThreadState(node));\n+    tty_message(\"\\ttoBeResumed: %d\", node->toBeResumed);\n+    tty_message(\"\\tis_vthread: %d\", node->is_vthread);\n+    tty_message(\"\\tcurrentInvoke.pending: %d\", node->currentInvoke.pending);\n+    tty_message(\"\\tcurrentInvoke.started: %d\", node->currentInvoke.started);\n+    tty_message(\"\\tcurrentInvoke.available: %d\", node->currentInvoke.available);\n+    tty_message(\"\\tobjID: %d\", commonRef_refToID(getEnv(), node->thread));\n+#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1076,17 +1076,0 @@\n-void\n-debugMonitorTimedWait(jrawMonitorID monitor, jlong millis)\n-{\n-    jvmtiError error;\n-    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorWait)\n-        (gdata->jvmti, monitor, millis);\n-    if (error == JVMTI_ERROR_INTERRUPT) {\n-        \/* See comment above *\/\n-        handleInterrupt();\n-        error = JVMTI_ERROR_NONE;\n-    }\n-    error = ignore_vm_death(error);\n-    if (error != JVMTI_ERROR_NONE) {\n-        EXIT_ERROR(error, \"on raw monitor timed wait\");\n-    }\n-}\n-\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -357,1 +357,0 @@\n-void debugMonitorTimedWait(jrawMonitorID theLock, jlong millis);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1830,0 +1830,3 @@\n+        \/\/ sort the map of module name to the class name of the generated SystemModules class\n+        List<Map.Entry<String, String>> systemModulesMap = map.entrySet()\n+                .stream().sorted(Map.Entry.comparingByKey()).toList();\n@@ -1880,1 +1883,1 @@\n-                                      for (String moduleName : sorted(map.keySet())) {\n+                                      for (Map.Entry<String,String> entry : systemModulesMap) {\n@@ -1883,1 +1886,1 @@\n-                                             .constantInstruction(moduleName)\n+                                             .constantInstruction(entry.getKey())\n@@ -1901,1 +1904,1 @@\n-                                      for (String className : sorted(map.values())) {\n+                                      for (Map.Entry<String,String> entry : systemModulesMap) {\n@@ -1904,1 +1907,1 @@\n-                                             .constantInstruction(className.replace('\/', '.'))\n+                                             .constantInstruction(entry.getValue().replace('\/', '.'))\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-        UNDERSCORE(TokenKind.UNDERSCORE, XDECL1),  \/\/  _\n+        UNDERSCORE(TokenKind.UNDERSCORE, XDECL1|XEXPR),  \/\/  _\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+import com.sun.tools.javac.parser.JavacParser;\n+import com.sun.tools.javac.parser.Lexer;\n@@ -85,0 +87,3 @@\n+import com.sun.tools.javac.parser.ScannerFactory;\n+import static com.sun.tools.javac.parser.Tokens.TokenKind.AMP;\n+import com.sun.tools.javac.tree.JCTree;\n@@ -366,1 +371,1 @@\n-            super(sh, task, diagnostics);\n+            super(sh, task, diagnostics, false);\n@@ -405,1 +410,1 @@\n-            super(sh, task, diagnostics);\n+            super(sh, task, diagnostics, true);\n@@ -443,1 +448,1 @@\n-            super(sh, jti, diagnostics);\n+            super(sh, jti, diagnostics, true);\n@@ -507,1 +512,2 @@\n-                            DiagnosticCollector<JavaFileObject> diagnostics) {\n+                            DiagnosticCollector<JavaFileObject> diagnostics,\n+                            boolean analyzeParserFactory) {\n@@ -512,0 +518,3 @@\n+            if (analyzeParserFactory) {\n+                JShellAnalyzeParserFactory.preRegister(context);\n+            }\n@@ -696,1 +705,1 @@\n-            ParserFactory parserFactory = ParserFactory.instance(context);\n+            JShellAnalyzeParserFactory parserFactory = (JShellAnalyzeParserFactory) ParserFactory.instance(context);\n@@ -712,15 +721,20 @@\n-                try {\n-                    \/\/parse the type as a cast, i.e. \"(<typeName>) x\". This is to support\n-                    \/\/intersection types:\n-                    CharBuffer buf = CharBuffer.wrap((\"(\" + typeName +\")x\\u0000\").toCharArray(), 0, typeName.length() + 3);\n-                    Parser parser = parserFactory.newParser(buf, false, false, false);\n-                    JCExpression expr = parser.parseExpression();\n-                    if (expr.hasTag(Tag.TYPECAST)) {\n-                        \/\/if parsed OK, attribute and set the type:\n-                        var2OriginalType.put(field, field.type);\n-\n-                        JCTypeCast tree = (JCTypeCast) expr;\n-                        rs.runWithoutAccessChecks(() -> {\n-                            field.type = attr.attribType(tree.clazz,\n-                                                         enter.getEnvs().iterator().next().enclClass.sym);\n-                        });\n+                parserFactory.runPermitIntersectionTypes(() -> {\n+                    try {\n+                        \/\/parse the type as a cast, i.e. \"(<typeName>) x\". This is to support\n+                        \/\/intersection types:\n+                        CharBuffer buf = CharBuffer.wrap((\"(\" + typeName +\")x\\u0000\").toCharArray(), 0, typeName.length() + 3);\n+                        Parser parser = parserFactory.newParser(buf, false, false, false);\n+                        JCExpression expr = parser.parseExpression();\n+                        if (expr.hasTag(Tag.TYPECAST)) {\n+                            \/\/if parsed OK, attribute and set the type:\n+                            var2OriginalType.put(field, field.type);\n+\n+                            JCTypeCast tree = (JCTypeCast) expr;\n+                            rs.runWithoutAccessChecks(() -> {\n+                                field.type = attr.attribType(tree.clazz,\n+                                                             enter.getEnvs().iterator().next().enclClass.sym);\n+                            });\n+                        }\n+                    } finally {\n+                        log.popDiagnosticHandler(h);\n+                        log.useSource(prev);\n@@ -728,4 +742,1 @@\n-                } finally {\n-                    log.popDiagnosticHandler(h);\n-                    log.useSource(prev);\n-                }\n+                });\n@@ -780,0 +791,48 @@\n+    private static final class JShellAnalyzeParserFactory extends ParserFactory {\n+        public static void preRegister(Context context) {\n+            if (context.get(Marker.class) == null) {\n+                context.put(parserFactoryKey, ((Factory<ParserFactory>) c -> new JShellAnalyzeParserFactory(c)));\n+                context.put(Marker.class, new Marker());\n+            }\n+        }\n+\n+        private final ScannerFactory scannerFactory;\n+        private boolean permitIntersectionTypes;\n+\n+        public JShellAnalyzeParserFactory(Context context) {\n+            super(context);\n+            this.scannerFactory = ScannerFactory.instance(context);\n+        }\n+\n+        \/**Run the given Runnable with intersection type permitted.\n+         *\n+         * @param r Runnnable to run\n+         *\/\n+        public void runPermitIntersectionTypes(Runnable r) {\n+            boolean prevPermitIntersectionTypes = permitIntersectionTypes;\n+            try {\n+                permitIntersectionTypes = true;\n+                r.run();\n+            } finally {\n+                permitIntersectionTypes = prevPermitIntersectionTypes;\n+            }\n+        }\n+\n+        @Override\n+        public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap, boolean parseModuleInfo) {\n+            com.sun.tools.javac.parser.Lexer lexer = scannerFactory.newScanner(input, keepDocComments);\n+            return new JavacParser(this, lexer, keepDocComments, keepLineMap, keepEndPos, parseModuleInfo) {\n+                @Override\n+                public JCExpression parseType(boolean allowVar, com.sun.tools.javac.util.List<JCTree.JCAnnotation> annotations) {\n+                    int pos = token.pos;\n+                    JCExpression t = super.parseType(allowVar, annotations);\n+                    if (permitIntersectionTypes) {\n+                        t = parseIntersectionType(pos, t);\n+                    }\n+                    return t;\n+                }\n+            };\n+        }\n+\n+        private static final class Marker {}\n+    }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TaskFactory.java","additions":83,"deletions":24,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -647,1 +647,6 @@\n-            e.posixPerms = perms == null ? -1 : ZipUtils.permsToFlags(perms);\n+            if (perms == null) {\n+                e.posixPerms = -1;\n+            } else {\n+                e.posixPerms = ZipUtils.permsToFlags(perms) |\n+                        (e.posixPerms & 0xFE00); \/\/ Preserve unrelated bits\n+            }\n@@ -3011,1 +3016,1 @@\n-                posixPerms = CENATX_PERMS(cen, pos) & 0xFFF; \/\/ 12 bits for setuid, setgid, sticky + perms\n+                posixPerms = (CENATX_PERMS(cen, pos) & 0xFFFF); \/\/ 16 bits for file type, setuid, setgid, sticky + perms\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE settings PUBLIC \"-\/\/NetBeans\/\/DTD Session settings 1.0\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/sessionsettings-1_0.dtd\">\n+<!DOCTYPE settings PUBLIC \"-\/\/NetBeans\/\/DTD Session settings 1.0\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/sessionsettings-1_0.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/resources\/com\/sun\/hotspot\/igv\/bytecodes\/BytecodeViewTopComponentSettings.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE tc-ref PUBLIC \"-\/\/NetBeans\/\/DTD Top Component in Mode Properties 2.0\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n+<!DOCTYPE tc-ref PUBLIC \"-\/\/NetBeans\/\/DTD Top Component in Mode Properties 2.0\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/resources\/com\/sun\/hotspot\/igv\/bytecodes\/BytecodeViewTopComponentWstcref.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n+<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/resources\/com\/sun\/hotspot\/igv\/bytecodes\/layer.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE settings PUBLIC \"-\/\/NetBeans\/\/DTD Session settings 1.0\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/sessionsettings-1_0.dtd\">\n+<!DOCTYPE settings PUBLIC \"-\/\/NetBeans\/\/DTD Session settings 1.0\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/sessionsettings-1_0.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowTopComponentSettings.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE tc-ref PUBLIC \"-\/\/NetBeans\/\/DTD Top Component in Mode Properties 2.0\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n+<!DOCTYPE tc-ref PUBLIC \"-\/\/NetBeans\/\/DTD Top Component in Mode Properties 2.0\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowTopComponentWstcref.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n+<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/layer.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE settings PUBLIC \"-\/\/NetBeans\/\/DTD Session settings 1.0\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/sessionsettings-1_0.dtd\">\n+<!DOCTYPE settings PUBLIC \"-\/\/NetBeans\/\/DTD Session settings 1.0\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/sessionsettings-1_0.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponentSettings.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE tc-ref PUBLIC \"-\/\/NetBeans\/\/DTD Top Component in Mode Properties 2.0\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n+<!DOCTYPE tc-ref PUBLIC \"-\/\/NetBeans\/\/DTD Top Component in Mode Properties 2.0\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponentWstcref.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE Configuration PUBLIC \"-\/\/NetBeans IDE\/\/DTD toolbar\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/toolbar.dtd\">\n+<!DOCTYPE Configuration PUBLIC \"-\/\/NetBeans IDE\/\/DTD toolbar\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/toolbar.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/StandardConfiguration.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.2\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/filesystem-1_2.dtd\">\n+<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.2\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/filesystem-1_2.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/layer.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-<xsd:schema xmlns:xsd=\"http:\/\/www.w3.org\/2001\/XMLSchema\" elementFormDefault=\"qualified\">\n@@ -4,0 +3,1 @@\n+<xsd:schema xmlns:xsd=\"https:\/\/www.w3.org\/2001\/XMLSchema\" elementFormDefault=\"qualified\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/resources\/com\/sun\/hotspot\/igv\/data\/serialization\/graphdocument.xsd","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Difference\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n+<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filter\/layer.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE settings PUBLIC \"-\/\/NetBeans\/\/DTD Session settings 1.0\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/sessionsettings-1_0.dtd\">\n+<!DOCTYPE settings PUBLIC \"-\/\/NetBeans\/\/DTD Session settings 1.0\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/sessionsettings-1_0.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filterwindow\/FilterTopComponentSettings.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE tc-ref PUBLIC \"-\/\/NetBeans\/\/DTD Top Component in Mode Properties 2.0\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n+<!DOCTYPE tc-ref PUBLIC \"-\/\/NetBeans\/\/DTD Top Component in Mode Properties 2.0\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filterwindow\/FilterTopComponentWstcref.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n+<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filterwindow\/layer.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/SelectionCoordinator\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n+<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/layer.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n+<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/resources\/com\/sun\/hotspot\/igv\/settings\/layer.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"http:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n+<!DOCTYPE filesystem PUBLIC \"-\/\/NetBeans\/\/DTD Filesystem 1.1\/\/EN\" \"https:\/\/www.netbeans.org\/dtds\/filesystem-1_1.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/layer.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-          \"http:\/\/www.netbeans.org\/dtds\/mode-properties2_0.dtd\">\n+          \"https:\/\/www.netbeans.org\/dtds\/mode-properties2_0.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/propertiesWsmode.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-          \"http:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n+          \"https:\/\/www.netbeans.org\/dtds\/tc-ref2_0.dtd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/propertiesWstcref.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/application\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/branding\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n","filename":"src\/utils\/IdealGraphVisualizer\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n-  xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/maven-v4_0_0.xsd\">\n+<project xmlns=\"https:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"https:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+  xsi:schemaLocation=\"https:\/\/maven.apache.org\/POM\/4.0.0 https:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n@@ -40,1 +40,1 @@\n-  <url>http:\/\/maven.apache.org<\/url>\n+  <url>https:\/\/maven.apache.org<\/url>\n","filename":"src\/utils\/LogCompilation\/pom.xml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-  const size_t buffer_capacity = DEFAULT_CACHE_LINE_SIZE \/ sizeof(void*);\n+  const size_t buffer_capacity = DEFAULT_PADDING_SIZE \/ sizeof(void*);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_bufferNodeAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,3 +92,0 @@\n-gc\/stress\/gclocker\/TestGCLockerWithParallel.java 8180622 generic-all\n-gc\/stress\/gclocker\/TestGCLockerWithSerial.java 8180622 generic-all\n-gc\/stress\/gclocker\/TestGCLockerWithShenandoah.java 8180622 generic-all\n@@ -110,0 +107,1 @@\n+runtime\/CompressedOops\/CompressedClassPointers.java 8322943 aix-ppc64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -359,1 +359,0 @@\n-  gc\/stress\/gclocker\/TestGCLockerWithShenandoah.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,0 +60,11 @@\n+\/**\n+ * @test\n+ * @bug 8322781\n+ * @requires vm.debug\n+ * @summary Test flag with c1 value numbering\n+ *\n+ * @run main\/othervm -XX:+PrintValueNumbering -XX:+Verbose -XX:-UseLocalValueNumbering\n+ *                   -Xcomp -XX:TieredStopAtLevel=1\n+ *                   compiler.arguments.TestC1Globals\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestC1Globals.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8310844\n+ * @summary Verify that monitors with large offset in the OSR buffer are handled properly.\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,TestLargeMonitorOffset::* TestLargeMonitorOffset\n+ *\/\n+\n+public class TestLargeMonitorOffset {\n+\n+    public static void test() {\n+        long l1,   l2,   l3,   l4,   l5,   l6,   l7,   l8,   l9,   l10,\n+             l11,  l12,  l13,  l14,  l15,  l16,  l17,  l18,  l19,  l20,\n+             l21,  l22,  l23,  l24,  l25,  l26,  l27,  l28,  l29,  l30,\n+             l31,  l32,  l33,  l34,  l35,  l36,  l37,  l38,  l39,  l40,\n+             l41,  l42,  l43,  l44,  l45,  l46,  l47,  l48,  l49,  l50,\n+             l51,  l52,  l53,  l54,  l55,  l56,  l57,  l58,  l59,  l60,\n+             l61,  l62,  l63,  l64,  l65,  l66,  l67,  l68,  l69,  l70,\n+             l71,  l72,  l73,  l74,  l75,  l76,  l77,  l78,  l79,  l80,\n+             l81,  l82,  l83,  l84,  l85,  l86,  l87,  l88,  l89,  l90,\n+             l91,  l92,  l93,  l94,  l95,  l96,  l97,  l98,  l99,  l100,\n+             l101, l102, l103, l104, l105, l106, l107, l108, l109, l110,\n+             l111, l112, l113, l114, l115, l116, l117, l118, l119, l120,\n+             l121, l122, l123, l124, l125, l126, l127, l128, l129, l130,\n+             l131, l132, l133, l134, l135, l136, l137, l138, l139, l140,\n+             l141, l142, l143, l144, l145, l146, l147, l148, l149, l150,\n+             l151, l152, l153, l154, l155, l156, l157, l158, l159, l160,\n+             l161, l162, l163, l164, l165, l166, l167, l168, l169, l170,\n+             l171, l172, l173, l174, l175, l176, l177, l178, l179, l180,\n+             l181, l182, l183, l184, l185, l186, l187, l188, l189, l190,\n+             l191, l192, l193, l194, l195, l196, l197, l198, l199, l200,\n+             l201, l202, l203, l204, l205, l206, l207, l208, l209, l210,\n+             l211, l212, l213, l214, l215, l216, l217, l218, l219, l220,\n+             l221, l222, l223, l224, l225, l226, l227, l228, l229, l230,\n+             l231, l232, l233, l234, l235, l236, l237, l238, l239, l240,\n+             l241, l242, l243, l244, l245, l246, l247, l248, l249, l250,\n+             l251, l252, l253, l254, l255, l256, l257, l258, l259, l260,\n+             l261, l262, l263, l264, l265, l266, l267, l268, l269, l270,\n+             l271, l272, l273, l274, l275, l276, l277, l278, l279, l280,\n+             l281, l282, l283, l284, l285, l286, l287, l288, l289, l290,\n+             l291, l292, l293, l294, l295, l296, l297, l298, l299, l300,\n+             l301, l302, l303, l304, l305, l306, l307, l308, l309, l310,\n+             l311, l312, l313, l314, l315, l316, l317, l318, l319, l320,\n+             l321, l322, l323, l324, l325, l326, l327, l328, l329, l330,\n+             l331, l332, l333, l334, l335, l336, l337, l338, l339, l340,\n+             l341, l342, l343, l344, l345, l346, l347, l348, l349, l350,\n+             l351, l352, l353, l354, l355, l356, l357, l358, l359, l360,\n+             l361, l362, l363, l364, l365, l366, l367, l368, l369, l370,\n+             l371, l372, l373, l374, l375, l376, l377, l378, l379, l380,\n+             l381, l382, l383, l384, l385, l386, l387, l388, l389, l390,\n+             l391, l392, l393, l394, l395, l396, l397, l398, l399, l400,\n+             l401, l402, l403, l404, l405, l406, l407, l408, l409, l410,\n+             l411, l412, l413, l414, l415, l416, l417, l418, l419, l420,\n+             l421, l422, l423, l424, l425, l426, l427, l428, l429, l430,\n+             l431, l432, l433, l434, l435, l436, l437, l438, l439, l440,\n+             l441, l442, l443, l444, l445, l446, l447, l448, l449, l450,\n+             l451, l452, l453, l454, l455, l456, l457, l458, l459, l460,\n+             l461, l462, l463, l464, l465, l466, l467, l468, l469, l470,\n+             l471, l472, l473, l474, l475, l476, l477, l478, l479, l480,\n+             l481, l482, l483, l484, l485, l486, l487, l488, l489, l490,\n+             l491, l492, l493, l494, l495, l496, l497, l498, l499, l500,\n+             l501, l502, l503, l504, l505, l506, l507, l508, l509, l510,\n+             l511, l512, l513, l514, l515, l516, l517, l518, l519, l520,\n+             l521, l522, l523, l524, l525, l526, l527, l528, l529, l530,\n+             l531, l532, l533, l534, l535, l536, l537, l538, l539, l540,\n+             l541, l542, l543, l544, l545, l546, l547, l548, l549, l550,\n+             l551, l552, l553, l554, l555, l556, l557, l558, l559, l560,\n+             l561, l562, l563, l564, l565, l566, l567, l568, l569, l570,\n+             l571, l572, l573, l574, l575, l576, l577, l578, l579, l580,\n+             l581, l582, l583, l584, l585, l586, l587, l588, l589, l590,\n+             l591, l592, l593, l594, l595, l596, l597, l598, l599, l600,\n+             l601, l602, l603, l604, l605, l606, l607, l608, l609, l610,\n+             l611, l612, l613, l614, l615, l616, l617, l618, l619, l620,\n+             l621, l622, l623, l624, l625, l626, l627, l628, l629, l630,\n+             l631, l632, l633, l634, l635, l636, l637, l638, l639, l640,\n+             l641, l642, l643, l644, l645, l646, l647, l648, l649, l650,\n+             l651, l652, l653, l654, l655, l656, l657, l658, l659, l660,\n+             l661, l662, l663, l664, l665, l666, l667, l668, l669, l670,\n+             l671, l672, l673, l674, l675, l676, l677, l678, l679, l680,\n+             l681, l682, l683, l684, l685, l686, l687, l688, l689, l690,\n+             l691, l692, l693, l694, l695, l696, l697, l698, l699, l700,\n+             l701, l702, l703, l704, l705, l706, l707, l708, l709, l710,\n+             l711, l712, l713, l714, l715, l716, l717, l718, l719, l720,\n+             l721, l722, l723, l724, l725, l726, l727, l728, l729, l730,\n+             l731, l732, l733, l734, l735, l736, l737, l738, l739, l740,\n+             l741, l742, l743, l744, l745, l746, l747, l748, l749, l750,\n+             l751, l752, l753, l754, l755, l756, l757, l758, l759, l760,\n+             l761, l762, l763, l764, l765, l766, l767, l768, l769, l770,\n+             l771, l772, l773, l774, l775, l776, l777, l778, l779, l780,\n+             l781, l782, l783, l784, l785, l786, l787, l788, l789, l790,\n+             l791, l792, l793, l794, l795, l796, l797, l798, l799, l800,\n+             l801, l802, l803, l804, l805, l806, l807, l808, l809, l810,\n+             l811, l812, l813, l814, l815, l816, l817, l818, l819, l820,\n+             l821, l822, l823, l824, l825, l826, l827, l828, l829, l830,\n+             l831, l832, l833, l834, l835, l836, l837, l838, l839, l840,\n+             l841, l842, l843, l844, l845, l846, l847, l848, l849, l850,\n+             l851, l852, l853, l854, l855, l856, l857, l858, l859, l860,\n+             l861, l862, l863, l864, l865, l866, l867, l868, l869, l870,\n+             l871, l872, l873, l874, l875, l876, l877, l878, l879, l880,\n+             l881, l882, l883, l884, l885, l886, l887, l888, l889, l890,\n+             l891, l892, l893, l894, l895, l896, l897, l898, l899, l900,\n+             l901, l902, l903, l904, l905, l906, l907, l908, l909, l910,\n+             l911, l912, l913, l914, l915, l916, l917, l918, l919, l920,\n+             l921, l922, l923, l924, l925, l926, l927, l928, l929, l930,\n+             l931, l932, l933, l934, l935, l936, l937, l938, l939, l940,\n+             l941, l942, l943, l944, l945, l946, l947, l948, l949, l950,\n+             l951, l952, l953, l954, l955, l956, l957, l958, l959, l960,\n+             l961, l962, l963, l964, l965, l966, l967, l968, l969, l970,\n+             l971, l972, l973, l974, l975, l976, l977, l978, l979, l980,\n+             l981, l982, l983, l984, l985, l986, l987, l988, l989, l990,\n+             l991, l992, l993, l994, l995, l996, l997, l998, l999, l1000;\n+\n+        synchronized (TestLargeMonitorOffset.class) {\n+            \/\/ Trigger OSR compilation with monitor in the OSR buffer\n+            for (int i = 0; i < 1_000_000; ++i) {\n+\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestLargeMonitorOffset.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * Copyright (c) 2024, BELLSOFT. All rights reserved.\n@@ -92,1 +92,0 @@\n-            \"-XX:CompileOnly=\" + className + \"::main\",\n@@ -95,1 +94,1 @@\n-            \"-XX:+PrintAssembly\",\n+            \"-XX:CompileCommand=option,\" + className + \"::main,bool,PrintAssembly,true\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestFarJump.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    @Run(test = { \"test1\" })\n+    @Run(test = { \"test1\", \"test2\" })\n@@ -44,0 +44,1 @@\n+        int b = RunInfo.getRandom().nextInt();\n@@ -48,4 +49,4 @@\n-        assertResult(0);\n-        assertResult(a);\n-        assertResult(min);\n-        assertResult(max);\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n@@ -55,1 +56,1 @@\n-    public void assertResult(int a) {\n+    public void assertResult(int a, int b) {\n@@ -57,0 +58,1 @@\n+        Asserts.assertEQ((~a) & (~b), test2(a, b));\n@@ -66,0 +68,9 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    @IR(counts = { IRNode.OR, \"1\",\n+                   IRNode.XOR, \"1\" })\n+    \/\/ Checks (~a) & (~b) => ~(a | b)\n+    public int test2(int a, int b) {\n+        return (~a) & (~b);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndINodeIdealizationTests.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8322589\n+ * @summary Test that Ideal transformations of AndLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.AndLNodeIdealizationTests\n+ *\/\n+public class AndLNodeIdealizationTests {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = { \"test1\" })\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEQ((~a) & (~b), test1(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    @IR(counts = { IRNode.OR, \"1\",\n+                   IRNode.XOR, \"1\" })\n+    \/\/ Checks (~a) & (~b) => ~(a | b)\n+    public long test1(long a, long b) {\n+        return (~a) & (~b);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndLNodeIdealizationTests.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -53,6 +53,2 @@\n-        Object alignVector = wb.getVMFlag(\"AlignVector\");\n-        if (alignVector != null && !((Boolean)alignVector)) {\n-            if (ByteOrder.nativeOrder() != ByteOrder.LITTLE_ENDIAN) {\n-                throw new RuntimeException(\"fix test that was written for a little endian platform\");\n-            }\n-            TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        if (ByteOrder.nativeOrder() != ByteOrder.LITTLE_ENDIAN) {\n+            throw new RuntimeException(\"fix test that was written for a little endian platform\");\n@@ -60,0 +56,1 @@\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n@@ -192,1 +189,3 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIf = {\"AlignVector\", \"false\"})\n+    \/\/ AlignVector cannot guarantee that invar is aligned.\n@@ -326,1 +325,3 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIf = {\"AlignVector\", \"false\"})\n+    \/\/ AlignVector cannot guarantee that invar is aligned.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -301,0 +301,5 @@\n+    public static final String OR = PREFIX + \"OR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(OR, \"Or(I|L)\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,1 @@\n+                    \"AlignVector\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-    public static final String SAFEPOINT_WHILE_PRINTING_MESSAGE = \"<!-- safepoint while printing -->\";\n@@ -41,5 +40,0 @@\n-    \/**\n-     * Stores an incomplete line that was interrupted by a safepoint.\n-     * Needs to be merged with the immediately following line.\n-     *\/\n-    private String incompleteLine = \"\";\n@@ -95,16 +89,1 @@\n-        line = mergeWithIncompleteLine(line);\n-        if (line.endsWith(SAFEPOINT_WHILE_PRINTING_MESSAGE)) {\n-            line = removeSafepointMessage(line);\n-            incompleteLine = line;\n-        } else {\n-            appendLine(line);\n-        }\n-    }\n-\n-    private String mergeWithIncompleteLine(String line) {\n-        if (!incompleteLine.isEmpty()) {\n-            line = incompleteLine + line;\n-            incompleteLine = \"\";\n-        }\n-        return line;\n-    }\n+        builder.append(escapeXML(line)).append(System.lineSeparator());\n@@ -112,2 +91,0 @@\n-    private static String removeSafepointMessage(String line) {\n-        return line.substring(0, line.lastIndexOf(SAFEPOINT_WHILE_PRINTING_MESSAGE));\n@@ -120,4 +97,0 @@\n-    private void appendLine(String line) {\n-        builder.append(escapeXML(line)).append(System.lineSeparator());\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/CompilePhaseBlock.java","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-    private final WriterThreads writerThreads;\n-    private WriterThread writerThread;\n@@ -41,1 +39,0 @@\n-        this.writerThreads = new WriterThreads();\n@@ -49,3 +46,1 @@\n-        if (WriterThread.isWriterThreadLine(line)) {\n-            processWriterThreadLine(line);\n-        } else if (compileQueueMessages.isTestMethodQueuedLine(line)) {\n+        if (compileQueueMessages.isTestMethodQueuedLine(line)) {\n@@ -62,9 +57,0 @@\n-    private void processWriterThreadLine(String line) {\n-        if (loggedMethod.hasActiveBlock()) {\n-            \/\/ The current compile phase block was interrupted due to a safepoint. Save and restore later.\n-            writerThread.saveLoggedMethod(loggedMethod);\n-        }\n-        writerThread = writerThreads.parse(line);\n-        loggedMethod = writerThread.restoreLoggedMethod();\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/State.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser.hotspot;\n-\n-\/**\n- * This class represents a writer thread that emits log messages with LogCompilation. It saves and restores a currently\n- * parsed {@link LoggedMethod} if a {@link CompilePhaseBlock} was interrupted before reaching the block end tag.\n- *\n- * @see LoggedMethod\n- * @see CompilePhaseBlock\n- *\/\n-class WriterThread {\n-    private LoggedMethod loggedMethod = LoggedMethod.DONT_CARE;\n-\n-    public static boolean isWriterThreadLine(String line) {\n-        return line.startsWith(\"<writer\");\n-    }\n-\n-    public void saveLoggedMethod(LoggedMethod loggedMethod) {\n-        this.loggedMethod = loggedMethod;\n-    }\n-\n-    public LoggedMethod restoreLoggedMethod() {\n-        LoggedMethod restoredLoggedMethod = loggedMethod;\n-        if (restoredLoggedMethod != LoggedMethod.DONT_CARE) {\n-            loggedMethod = LoggedMethod.DONT_CARE;\n-        }\n-        return restoredLoggedMethod;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/WriterThread.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser.hotspot;\n-\n-import compiler.lib.ir_framework.TestFramework;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * This class keeps track of all {@link WriterThread} instances.\n- *\/\n-class WriterThreads {\n-    private final Map<Integer, WriterThread> mapIdToThread = new HashMap<>();\n-\n-    WriterThread parse(String line) {\n-        int writerThreadId = parseWriterThreadId(line);\n-        return mapIdToThread.computeIfAbsent(writerThreadId, c -> new WriterThread());\n-    }\n-\n-    private static int parseWriterThreadId(String line) {\n-        Pattern pattern = Pattern.compile(\"='(\\\\d+)'\");\n-        Matcher matcher = pattern.matcher(line);\n-        TestFramework.check(matcher.find(), \"should find writer thread id\");\n-        return Integer.parseInt(matcher.group(1));\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/WriterThreads.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -0,0 +1,1479 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.nio.ByteOrder;\n+\n+\/*\n+ * @test id=NoAlignVector\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.superword.TestAlignVector NoAlignVector\n+ *\/\n+\n+\/*\n+ * @test id=AlignVector\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.superword.TestAlignVector AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.superword.TestAlignVector VerifyAlignVector\n+ *\/\n+\n+public class TestAlignVector {\n+    static int RANGE = 1024*8;\n+    static int RANGE_FINAL = 1024*8;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/\/ Inputs\n+    byte[] aB;\n+    byte[] bB;\n+    byte mB = (byte)31;\n+    short[] aS;\n+    short[] bS;\n+    short mS = (short)0xF0F0;\n+    int[] aI;\n+    int[] bI;\n+    int mI = 0xF0F0F0F0;\n+    long[] aL;\n+    long[] bL;\n+    long mL = 0xF0F0F0F0F0F0F0F0L;\n+\n+    \/\/ List of tests\n+    Map<String,TestFunction> tests = new HashMap<String,TestFunction>();\n+\n+    \/\/ List of gold, the results from the first run before compilation\n+    Map<String,Object[]> golds = new HashMap<String,Object[]>();\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestAlignVector.class);\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                           \"-XX:LoopUnrollLimit=250\");\n+\n+        switch (args[0]) {\n+            case \"NoAlignVector\"     -> { framework.addFlags(\"-XX:-AlignVector\"); }\n+            case \"AlignVector\"       -> { framework.addFlags(\"-XX:+AlignVector\"); }\n+            case \"VerifyAlignVector\" -> { framework.addFlags(\"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        }\n+        framework.start();\n+    }\n+\n+    public TestAlignVector() {\n+        \/\/ Generate input once\n+        aB = generateB();\n+        bB = generateB();\n+        aS = generateS();\n+        bS = generateS();\n+        aI = generateI();\n+        bI = generateI();\n+        aL = generateL();\n+        bL = generateL();\n+\n+        \/\/ Add all tests to list\n+        tests.put(\"test0\",       () -> { return test0(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test1\",       () -> { return test1(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test2\",       () -> { return test2(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test3\",       () -> { return test3(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test4\",       () -> { return test4(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test5\",       () -> { return test5(aB.clone(), bB.clone(), mB, 0); });\n+        tests.put(\"test6\",       () -> { return test6(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test7\",       () -> { return test7(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test8\",       () -> { return test8(aB.clone(), bB.clone(), mB, 0); });\n+        tests.put(\"test8\",       () -> { return test8(aB.clone(), bB.clone(), mB, 1); });\n+        tests.put(\"test9\",       () -> { return test9(aB.clone(), bB.clone(), mB); });\n+\n+        tests.put(\"test10a\",     () -> { return test10a(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test10b\",     () -> { return test10b(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test10c\",     () -> { return test10c(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test10d\",     () -> { return test10d(aS.clone(), bS.clone(), mS); });\n+\n+        tests.put(\"test11aB\",    () -> { return test11aB(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test11aS\",    () -> { return test11aS(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test11aI\",    () -> { return test11aI(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test11aL\",    () -> { return test11aL(aL.clone(), bL.clone(), mL); });\n+\n+        tests.put(\"test11bB\",    () -> { return test11bB(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test11bS\",    () -> { return test11bS(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test11bI\",    () -> { return test11bI(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test11bL\",    () -> { return test11bL(aL.clone(), bL.clone(), mL); });\n+\n+        tests.put(\"test11cB\",    () -> { return test11cB(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test11cS\",    () -> { return test11cS(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test11cI\",    () -> { return test11cI(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test11cL\",    () -> { return test11cL(aL.clone(), bL.clone(), mL); });\n+\n+        tests.put(\"test11dB\",    () -> { return test11dB(aB.clone(), bB.clone(), mB, 0); });\n+        tests.put(\"test11dS\",    () -> { return test11dS(aS.clone(), bS.clone(), mS, 0); });\n+        tests.put(\"test11dI\",    () -> { return test11dI(aI.clone(), bI.clone(), mI, 0); });\n+        tests.put(\"test11dL\",    () -> { return test11dL(aL.clone(), bL.clone(), mL, 0); });\n+\n+        tests.put(\"test12\",      () -> { return test12(aB.clone(), bB.clone(), mB); });\n+\n+        tests.put(\"test13aIL\",   () -> { return test13aIL(aI.clone(), aL.clone()); });\n+        tests.put(\"test13aIB\",   () -> { return test13aIB(aI.clone(), aB.clone()); });\n+        tests.put(\"test13aIS\",   () -> { return test13aIS(aI.clone(), aS.clone()); });\n+        tests.put(\"test13aBSIL\", () -> { return test13aBSIL(aB.clone(), aS.clone(), aI.clone(), aL.clone()); });\n+\n+        tests.put(\"test13bIL\",   () -> { return test13bIL(aI.clone(), aL.clone()); });\n+        tests.put(\"test13bIB\",   () -> { return test13bIB(aI.clone(), aB.clone()); });\n+        tests.put(\"test13bIS\",   () -> { return test13bIS(aI.clone(), aS.clone()); });\n+        tests.put(\"test13bBSIL\", () -> { return test13bBSIL(aB.clone(), aS.clone(), aI.clone(), aL.clone()); });\n+\n+        tests.put(\"test14aB\",    () -> { return test14aB(aB.clone()); });\n+        tests.put(\"test14bB\",    () -> { return test14bB(aB.clone()); });\n+        tests.put(\"test14cB\",    () -> { return test14cB(aB.clone()); });\n+\n+        tests.put(\"test15aB\",    () -> { return test15aB(aB.clone()); });\n+        tests.put(\"test15bB\",    () -> { return test15bB(aB.clone()); });\n+        tests.put(\"test15cB\",    () -> { return test15cB(aB.clone()); });\n+\n+        tests.put(\"test16a\",     () -> { return test16a(aB.clone(), aS.clone()); });\n+        tests.put(\"test16b\",     () -> { return test16b(aB.clone()); });\n+\n+        tests.put(\"test17a\",     () -> { return test17a(aL.clone()); });\n+        tests.put(\"test17b\",     () -> { return test17b(aL.clone()); });\n+        tests.put(\"test17c\",     () -> { return test17c(aL.clone()); });\n+        tests.put(\"test17d\",     () -> { return test17d(aL.clone()); });\n+\n+        tests.put(\"test18a\",     () -> { return test18a(aB.clone(), aI.clone()); });\n+        tests.put(\"test18b\",     () -> { return test18b(aB.clone(), aI.clone()); });\n+\n+        tests.put(\"test19\",      () -> { return test19(aI.clone(), bI.clone()); });\n+        tests.put(\"test20\",      () -> { return test20(aB.clone()); });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            Object[] gold = test.run();\n+            golds.put(name, gold);\n+        }\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"test0\",\n+                 \"test1\",\n+                 \"test2\",\n+                 \"test3\",\n+                 \"test4\",\n+                 \"test5\",\n+                 \"test6\",\n+                 \"test7\",\n+                 \"test8\",\n+                 \"test9\",\n+                 \"test10a\",\n+                 \"test10b\",\n+                 \"test10c\",\n+                 \"test10d\",\n+                 \"test11aB\",\n+                 \"test11aS\",\n+                 \"test11aI\",\n+                 \"test11aL\",\n+                 \"test11bB\",\n+                 \"test11bS\",\n+                 \"test11bI\",\n+                 \"test11bL\",\n+                 \"test11cB\",\n+                 \"test11cS\",\n+                 \"test11cI\",\n+                 \"test11cL\",\n+                 \"test11dB\",\n+                 \"test11dS\",\n+                 \"test11dI\",\n+                 \"test11dL\",\n+                 \"test12\",\n+                 \"test13aIL\",\n+                 \"test13aIB\",\n+                 \"test13aIS\",\n+                 \"test13aBSIL\",\n+                 \"test13bIL\",\n+                 \"test13bIB\",\n+                 \"test13bIS\",\n+                 \"test13bBSIL\",\n+                 \"test14aB\",\n+                 \"test14bB\",\n+                 \"test14cB\",\n+                 \"test15aB\",\n+                 \"test15bB\",\n+                 \"test15cB\",\n+                 \"test16a\",\n+                 \"test16b\",\n+                 \"test17a\",\n+                 \"test17b\",\n+                 \"test17c\",\n+                 \"test17d\",\n+                 \"test18a\",\n+                 \"test18b\",\n+                 \"test19\",\n+                 \"test20\"})\n+    public void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object[] gold = golds.get(name);\n+            \/\/ Compute new result\n+            Object[] result = test.run();\n+            \/\/ Compare gold and new result\n+            verify(name, gold, result);\n+        }\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static short[] generateS() {\n+        short[] a = new short[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static int[] generateI() {\n+        int[] a = new int[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static long[] generateL() {\n+        long[] a = new long[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+        return a;\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test0(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Safe to vectorize with AlignVector\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ offset 0, align 0\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test1(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Safe to vectorize with AlignVector\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ offset 0, align 0\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+            b[i+7] = (byte)(a[i+7] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test2(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector: 3 + x * 8 % 8 = 3\n+            b[i+3] = (byte)(a[i+3] & mask); \/\/ at alignment 3\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test3(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector: 3 + x * 8 % 8 = 3\n+\n+            \/\/ Problematic for AlignVector\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ best_memref, align 0\n+\n+            b[i+3] = (byte)(a[i+3] & mask); \/\/ pack at offset 3 bytes\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_8, \"= 0\",\/\/ unaligned\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_8, \"= 0\",\/\/ unaligned\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">=16\"})\n+    static Object[] test4(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE\/16; i++) {\n+            \/\/ Problematic for AlignVector\n+            b[i*16 + 0 ] = (byte)(a[i*16 + 0 ] & mask); \/\/ 4 pack, 0 aligned\n+            b[i*16 + 1 ] = (byte)(a[i*16 + 1 ] & mask);\n+            b[i*16 + 2 ] = (byte)(a[i*16 + 2 ] & mask);\n+            b[i*16 + 3 ] = (byte)(a[i*16 + 3 ] & mask);\n+\n+            b[i*16 + 5 ] = (byte)(a[i*16 + 5 ] & mask); \/\/ 8 pack, 5 aligned\n+            b[i*16 + 6 ] = (byte)(a[i*16 + 6 ] & mask);\n+            b[i*16 + 7 ] = (byte)(a[i*16 + 7 ] & mask);\n+            b[i*16 + 8 ] = (byte)(a[i*16 + 8 ] & mask);\n+            b[i*16 + 9 ] = (byte)(a[i*16 + 9 ] & mask);\n+            b[i*16 + 10] = (byte)(a[i*16 + 10] & mask);\n+            b[i*16 + 11] = (byte)(a[i*16 + 11] & mask);\n+            b[i*16 + 12] = (byte)(a[i*16 + 12] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test5(byte[] a, byte[] b, byte mask, int inv) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector because of invariant\n+            b[i+inv+0] = (byte)(a[i+inv+0] & mask);\n+\n+            b[i+inv+3] = (byte)(a[i+inv+3] & mask);\n+            b[i+inv+4] = (byte)(a[i+inv+4] & mask);\n+            b[i+inv+5] = (byte)(a[i+inv+5] & mask);\n+            b[i+inv+6] = (byte)(a[i+inv+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test6(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE\/8; i+=2) {\n+            \/\/ Cannot align with AlignVector because offset is odd\n+            b[i*4+0] = (byte)(a[i*4+0] & mask);\n+\n+            b[i*4+3] = (byte)(a[i*4+3] & mask);\n+            b[i*4+4] = (byte)(a[i*4+4] & mask);\n+            b[i*4+5] = (byte)(a[i*4+5] & mask);\n+            b[i*4+6] = (byte)(a[i*4+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=16\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"= 0\",\n+                  IRNode.AND_VS, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test7(short[] a, short[] b, short mask) {\n+        for (int i = 0; i < RANGE\/8; i+=2) {\n+            \/\/ Cannot align with AlignVector because offset is odd\n+            b[i*4+0] = (short)(a[i*4+0] & mask);\n+\n+            b[i*4+3] = (short)(a[i*4+3] & mask);\n+            b[i*4+4] = (short)(a[i*4+4] & mask);\n+            b[i*4+5] = (short)(a[i*4+5] & mask);\n+            b[i*4+6] = (short)(a[i*4+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test8(byte[] a, byte[] b, byte mask, int init) {\n+        for (int i = init; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector because of invariant (variable init becomes invar)\n+            b[i+0] = (byte)(a[i+0] & mask);\n+\n+            b[i+3] = (byte)(a[i+3] & mask);\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test9(byte[] a, byte[] b, byte mask) {\n+        \/\/ known non-zero init value does not affect offset, but has implicit effect on iv\n+        for (int i = 13; i < RANGE-8; i+=8) {\n+            b[i+0] = (byte)(a[i+0] & mask);\n+\n+            b[i+3] = (byte)(a[i+3] & mask);\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test10a(byte[] a, byte[] b, byte mask) {\n+        \/\/ This is not alignable with pre-loop, because of odd init.\n+        for (int i = 3; i < RANGE-8; i+=8) {\n+            b[i+0] = (byte)(a[i+0] & mask);\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test10b(byte[] a, byte[] b, byte mask) {\n+        \/\/ This is not alignable with pre-loop, because of odd init.\n+        \/\/ Seems not correctly handled.\n+        for (int i = 13; i < RANGE-8; i+=8) {\n+            b[i+0] = (byte)(a[i+0] & mask);\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"= 0\",\n+                  IRNode.AND_VS, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test10c(short[] a, short[] b, short mask) {\n+        \/\/ This is not alignable with pre-loop, because of odd init.\n+        \/\/ Seems not correctly handled with MaxVectorSize >= 32.\n+        for (int i = 13; i < RANGE-8; i+=8) {\n+            b[i+0] = (short)(a[i+0] & mask);\n+            b[i+1] = (short)(a[i+1] & mask);\n+            b[i+2] = (short)(a[i+2] & mask);\n+            b[i+3] = (short)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test10d(short[] a, short[] b, short mask) {\n+        for (int i = 13; i < RANGE-16; i+=8) {\n+            \/\/ init + offset -> aligned\n+            b[i+0+3] = (short)(a[i+0+3] & mask);\n+            b[i+1+3] = (short)(a[i+1+3] & mask);\n+            b[i+2+3] = (short)(a[i+2+3] & mask);\n+            b[i+3+3] = (short)(a[i+3+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aB(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (byte)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aS(short[] a, short[] b, short mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (short)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aI(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (int)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aL(long[] a, long[] b, long mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (long)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bB(byte[] a, byte[] b, byte mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (byte)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bS(short[] a, short[] b, short mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (short)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bI(int[] a, int[] b, int mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (int)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bL(long[] a, long[] b, long mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (long)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test11cB(byte[] a, byte[] b, byte mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ 1 byte offset -> not alignable with AlignVector\n+            b[i+0] = (byte)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"= 0\",\n+                  IRNode.AND_VS, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test11cS(short[] a, short[] b, short mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ 2 byte offset -> not alignable with AlignVector\n+            b[i+0] = (short)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.AND_VI, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test11cI(int[] a, int[] b, int mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ 4 byte offset -> not alignable with AlignVector\n+            b[i+0] = (int)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11cL(long[] a, long[] b, long mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ always alignable (8 byte offset)\n+            b[i+0] = (long)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dB(byte[] a, byte[] b, byte mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (byte)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dS(short[] a, short[] b, short mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (short)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dI(int[] a, int[] b, int mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (int)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dL(long[] a, long[] b, long mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (long)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test12(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE\/16; i++) {\n+            \/\/ Currently does not vectorize at all\n+            b[i*6 + 0 ] = (byte)(a[i*6 + 0 ] & mask);\n+            b[i*6 + 1 ] = (byte)(a[i*6 + 1 ] & mask);\n+            b[i*6 + 2 ] = (byte)(a[i*6 + 2 ] & mask);\n+            b[i*6 + 3 ] = (byte)(a[i*6 + 3 ] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VL, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+    \/\/ require avx to ensure vectors are larger than what unrolling produces\n+    static Object[] test13aIL(int[] a, long[] b) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13aIB(int[] a, byte[] b) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13aIS(int[] a, short[] b) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13aBSIL(byte[] a, short[] b, int[] c, long[] d) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+            c[i]++;\n+            d[i]++;\n+        }\n+        return new Object[]{ a, b, c, d };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VL, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+    \/\/ require avx to ensure vectors are larger than what unrolling produces\n+    static Object[] test13bIL(int[] a, long[] b) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13bIB(int[] a, byte[] b) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13bIS(int[] a, short[] b) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13bBSIL(byte[] a, short[] b, int[] c, long[] d) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+            c[i]++;\n+            d[i]++;\n+        }\n+        return new Object[]{ a, b, c, d };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14aB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-20; i+=9) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+            a[i+8]++;\n+            a[i+9]++;\n+            a[i+10]++;\n+            a[i+11]++;\n+            a[i+12]++;\n+            a[i+13]++;\n+            a[i+14]++;\n+            a[i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14bB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-20; i+=3) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+            a[i+8]++;\n+            a[i+9]++;\n+            a[i+10]++;\n+            a[i+11]++;\n+            a[i+12]++;\n+            a[i+13]++;\n+            a[i+14]++;\n+            a[i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14cB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-20; i+=5) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+            a[i+8]++;\n+            a[i+9]++;\n+            a[i+10]++;\n+            a[i+11]++;\n+            a[i+12]++;\n+            a[i+13]++;\n+            a[i+14]++;\n+            a[i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ IR rules difficult because of modulo wrapping with offset after peeling.\n+    static Object[] test15aB(byte[] a) {\n+        \/\/ non-power-of-2 scale\n+        for (int i = 0; i < RANGE\/64-20; i++) {\n+            a[53*i+0]++;\n+            a[53*i+1]++;\n+            a[53*i+2]++;\n+            a[53*i+3]++;\n+            a[53*i+4]++;\n+            a[53*i+5]++;\n+            a[53*i+6]++;\n+            a[53*i+7]++;\n+            a[53*i+8]++;\n+            a[53*i+9]++;\n+            a[53*i+10]++;\n+            a[53*i+11]++;\n+            a[53*i+12]++;\n+            a[53*i+13]++;\n+            a[53*i+14]++;\n+            a[53*i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ IR rules difficult because of modulo wrapping with offset after peeling.\n+    static Object[] test15bB(byte[] a) {\n+        \/\/ non-power-of-2 scale\n+        for (int i = 0; i < RANGE\/64-20; i++) {\n+            a[25*i+0]++;\n+            a[25*i+1]++;\n+            a[25*i+2]++;\n+            a[25*i+3]++;\n+            a[25*i+4]++;\n+            a[25*i+5]++;\n+            a[25*i+6]++;\n+            a[25*i+7]++;\n+            a[25*i+8]++;\n+            a[25*i+9]++;\n+            a[25*i+10]++;\n+            a[25*i+11]++;\n+            a[25*i+12]++;\n+            a[25*i+13]++;\n+            a[25*i+14]++;\n+            a[25*i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ IR rules difficult because of modulo wrapping with offset after peeling.\n+    static Object[] test15cB(byte[] a) {\n+        \/\/ non-power-of-2 scale\n+        for (int i = 0; i < RANGE\/64-20; i++) {\n+            a[19*i+0]++;\n+            a[19*i+1]++;\n+            a[19*i+2]++;\n+            a[19*i+3]++;\n+            a[19*i+4]++;\n+            a[19*i+5]++;\n+            a[19*i+6]++;\n+            a[19*i+7]++;\n+            a[19*i+8]++;\n+            a[19*i+9]++;\n+            a[19*i+10]++;\n+            a[19*i+11]++;\n+            a[19*i+12]++;\n+            a[19*i+13]++;\n+            a[19*i+14]++;\n+            a[19*i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    static Object[] test16a(byte[] a, short[] b) {\n+        \/\/ infinite loop issues\n+        for (int i = 0; i < RANGE\/2-20; i++) {\n+            a[2*i+0]++;\n+            a[2*i+1]++;\n+            a[2*i+2]++;\n+            a[2*i+3]++;\n+            a[2*i+4]++;\n+            a[2*i+5]++;\n+            a[2*i+6]++;\n+            a[2*i+7]++;\n+            a[2*i+8]++;\n+            a[2*i+9]++;\n+            a[2*i+10]++;\n+            a[2*i+11]++;\n+            a[2*i+12]++;\n+            a[2*i+13]++;\n+            a[2*i+14]++;\n+\n+            b[2*i+0]++;\n+            b[2*i+1]++;\n+            b[2*i+2]++;\n+            b[2*i+3]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test16b(byte[] a) {\n+        \/\/ infinite loop issues\n+        for (int i = 0; i < RANGE\/2-20; i++) {\n+            a[2*i+0]++;\n+            a[2*i+1]++;\n+            a[2*i+2]++;\n+            a[2*i+3]++;\n+            a[2*i+4]++;\n+            a[2*i+5]++;\n+            a[2*i+6]++;\n+            a[2*i+7]++;\n+            a[2*i+8]++;\n+            a[2*i+9]++;\n+            a[2*i+10]++;\n+            a[2*i+11]++;\n+            a[2*i+12]++;\n+            a[2*i+13]++;\n+            a[2*i+14]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test17a(long[] a) {\n+        \/\/ Unsafe: vectorizes with profiling (not xcomp)\n+        for (int i = 0; i < RANGE; i++) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i;\n+            long v = UNSAFE.getLongUnaligned(a, adr);\n+            UNSAFE.putLongUnaligned(a, adr, v + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ Difficult to write good IR rule. Modulo calculus overflow can create non-power-of-2 packs.\n+    static Object[] test17b(long[] a) {\n+        \/\/ Not alignable\n+        for (int i = 0; i < RANGE-1; i++) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i + 1;\n+            long v = UNSAFE.getLongUnaligned(a, adr);\n+            UNSAFE.putLongUnaligned(a, adr, v + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.ADD_VL,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test17c(long[] a) {\n+        \/\/ Unsafe: aligned vectorizes\n+        for (int i = 0; i < RANGE-1; i+=4) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i;\n+            long v0 = UNSAFE.getLongUnaligned(a, adr + 0);\n+            long v1 = UNSAFE.getLongUnaligned(a, adr + 8);\n+            UNSAFE.putLongUnaligned(a, adr + 0, v0 + 1);\n+            UNSAFE.putLongUnaligned(a, adr + 8, v1 + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.ADD_VL,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx512\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=64\"})\n+    \/\/ Ensure vector width is large enough to fit 64 byte for longs:\n+    \/\/ The offsets are: 25, 33, 57, 65\n+    \/\/ In modulo 32:    25,  1, 25,  1  -> does not vectorize\n+    \/\/ In modulo 64:    25, 33, 57,  1  -> at least first pair vectorizes\n+    \/\/ This problem is because we compute modulo vector width in memory_alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 0\",\n+                  IRNode.ADD_VL, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test17d(long[] a) {\n+        \/\/ Not alignable\n+        for (int i = 0; i < RANGE-1; i+=4) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i + 1;\n+            long v0 = UNSAFE.getLongUnaligned(a, adr + 0);\n+            long v1 = UNSAFE.getLongUnaligned(a, adr + 8);\n+            UNSAFE.putLongUnaligned(a, adr + 0, v0 + 1);\n+            UNSAFE.putLongUnaligned(a, adr + 8, v1 + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    static Object[] test18a(byte[] a, int[] b) {\n+        \/\/ scale = 0  -->  no iv\n+        for (int i = 0; i < RANGE; i++) {\n+            a[0] = 1;\n+            b[i] = 2;\n+            a[1] = 1;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test18b(byte[] a, int[] b) {\n+        \/\/ scale = 0  -->  no iv\n+        for (int i = 0; i < RANGE; i++) {\n+            a[1] = 1;\n+            b[i] = 2;\n+            a[2] = 1;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test19(int[] a, int[] b) {\n+        for (int i = 5000; i > 0; i--) {\n+            a[RANGE_FINAL - i] = b[RANGE_FINAL - i];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test20(byte[] a) {\n+        \/\/ Example where it is easy to pass alignment check,\n+        \/\/ but used to fail the alignment calculation\n+        for (int i = 1; i < RANGE\/2-50; i++) {\n+            a[2*i+0+30]++;\n+            a[2*i+1+30]++;\n+            a[2*i+2+30]++;\n+            a[2*i+3+30]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":1479,"deletions":0,"binary":false,"changes":1479,"status":"added"},{"patch":"@@ -0,0 +1,1353 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Vanilla\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Do not force alignment.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Verify AlignVector.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:+AlignVector -XX:+VerifyAlignVector\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector-Align16\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Verify AlignVector.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.bits == 64\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:+AlignVector -XX:+VerifyAlignVector\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 -XX:ObjectAlignmentInBytes=16\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector-NoTieredCompilation-Xbatch\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Verify AlignVector.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:+AlignVector -XX:+VerifyAlignVector\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 -XX:-TieredCompilation -Xbatch\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.lang.invoke.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestAlignVectorFuzzer {\n+    static final int ITERATIONS_MAX = 5; \/\/ time allowance may lead to fewer iterations\n+    static final int RANGE_CON = 1024 * 8;\n+    static int ZERO = 0;\n+\n+    private static final Random random = Utils.getRandomInstance();\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    \/\/ Setup for variable compile-time constants:\n+    private static final CallSite INIT_CS    = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite LIMIT_CS   = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite STRIDE_CS  = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite SCALE_CS   = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite OFFSET1_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite OFFSET2_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite OFFSET3_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final MethodHandle INIT_MH    = INIT_CS.dynamicInvoker();\n+    private static final MethodHandle LIMIT_MH   = LIMIT_CS.dynamicInvoker();\n+    private static final MethodHandle STRIDE_MH  = STRIDE_CS.dynamicInvoker();\n+    private static final MethodHandle SCALE_MH   = SCALE_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET1_MH = OFFSET1_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET2_MH = OFFSET2_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET3_MH = OFFSET3_CS.dynamicInvoker();\n+\n+    \/\/ Toggle if init, limit and offset are constants or variables\n+    private static final CallSite INIT_IS_CON_CS   = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite LIMIT_IS_CON_CS  = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite OFFSET1_IS_CON_CS = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite OFFSET2_IS_CON_CS = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite OFFSET3_IS_CON_CS = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final MethodHandle INIT_IS_CON_MH    = INIT_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle LIMIT_IS_CON_MH   = LIMIT_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET1_IS_CON_MH = OFFSET1_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET2_IS_CON_MH = OFFSET2_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET3_IS_CON_MH = OFFSET3_IS_CON_CS.dynamicInvoker();\n+\n+    \/\/ Hand-Unrolling compile-constants\n+    private static final CallSite HAND_UNROLLING1_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite HAND_UNROLLING2_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite HAND_UNROLLING3_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final MethodHandle HAND_UNROLLING1_MH = HAND_UNROLLING1_CS.dynamicInvoker();\n+    private static final MethodHandle HAND_UNROLLING2_MH = HAND_UNROLLING2_CS.dynamicInvoker();\n+    private static final MethodHandle HAND_UNROLLING3_MH = HAND_UNROLLING3_CS.dynamicInvoker();\n+\n+    static void setConstant(CallSite cs, int value) {\n+        MethodHandle constant = MethodHandles.constant(int.class, value);\n+        cs.setTarget(constant);\n+    }\n+\n+    static void setConstant(CallSite cs, boolean value) {\n+        MethodHandle constant = MethodHandles.constant(boolean.class, value);\n+        cs.setTarget(constant);\n+    }\n+\n+    static int init_con() { \/\/ compile-time constant\n+        try {\n+            return (int) INIT_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean init_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) INIT_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int init_con_or_var() {\n+        int init = init_con();\n+        if (!init_is_con()) { \/\/ branch constant folds to true or false\n+            init += ZERO; \/\/ LoadI\n+        }\n+        return init;\n+    }\n+\n+    static int limit_con() { \/\/ compile-time constant\n+        try {\n+            return (int) LIMIT_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean limit_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) LIMIT_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int limit_con_or_var() {\n+        int limit = limit_con();\n+        if (!limit_is_con()) { \/\/ branch constant folds to true or false\n+            limit -= ZERO; \/\/ LoadI\n+        }\n+        return limit;\n+    }\n+\n+    static int stride_con() { \/\/ compile-time constant\n+        try {\n+            return (int) STRIDE_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int scale_con() { \/\/ compile-time constant\n+        try {\n+            return (int) SCALE_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset1_con() { \/\/ compile-time constant\n+        try {\n+            return (int) OFFSET1_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset2_con() { \/\/ compile-time constant\n+        try {\n+            return (int) OFFSET2_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset3_con() { \/\/ compile-time constant\n+        try {\n+            return (int) OFFSET3_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean offset1_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) OFFSET1_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean offset2_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) OFFSET2_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean offset3_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) OFFSET3_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset1_con_or_var() {\n+        int offset = offset1_con();\n+        if (!offset1_is_con()) { \/\/ branch constant folds to true or false\n+            offset += ZERO; \/\/ LoadI\n+        }\n+        return offset;\n+    }\n+\n+    static int offset2_con_or_var() {\n+        int offset = offset2_con();\n+        if (!offset2_is_con()) { \/\/ branch constant folds to true or false\n+            offset += ZERO; \/\/ LoadI\n+        }\n+        return offset;\n+    }\n+\n+    static int offset3_con_or_var() {\n+        int offset = offset3_con();\n+        if (!offset3_is_con()) { \/\/ branch constant folds to true or false\n+            offset += ZERO; \/\/ LoadI\n+        }\n+        return offset;\n+    }\n+\n+    static int opposite_direction_offset1_con_or_var() {\n+        \/\/ When indexing in the opposite direction to i, we Want to have:\n+        \/\/\n+        \/\/   a[x - i * scale]\n+        \/\/\n+        \/\/ So we want to fulfill these constraints:\n+        \/\/\n+        \/\/   x - init * scale  = offset + limit * scale\n+        \/\/   x - limit * scale = offset + init * scale\n+        \/\/\n+        \/\/ Hence:\n+        \/\/\n+        \/\/   x = offset + limit * scale + init * scale;\n+\n+        int offset = offset1_con_or_var();\n+        int init = init_con();\n+        int limit = limit_con();\n+        int scale = scale_con();\n+        return offset + limit * scale + init * scale;\n+    }\n+\n+    static int opposite_direction_offset2_con_or_var() {\n+        int offset = offset2_con_or_var();\n+        int init = init_con();\n+        int limit = limit_con();\n+        int scale = scale_con();\n+        return offset + limit * scale + init * scale;\n+    }\n+\n+    static int opposite_direction_offset3_con_or_var() {\n+        int offset = offset3_con_or_var();\n+        int init = init_con();\n+        int limit = limit_con();\n+        int scale = scale_con();\n+        return offset + limit * scale + init * scale;\n+    }\n+\n+    static int hand_unrolling1_con() { \/\/ compile-time constant\n+        try {\n+            return (int) HAND_UNROLLING1_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int hand_unrolling2_con() { \/\/ compile-time constant\n+        try {\n+            return (int) HAND_UNROLLING2_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int hand_unrolling3_con() { \/\/ compile-time constant\n+        try {\n+            return (int) HAND_UNROLLING3_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int randomStride() {\n+        return switch (random.nextInt(6)) {\n+            case 0       -> random.nextInt(64) + 1; \/\/ [1..64]\n+            case 1, 2, 3 -> 1;\n+            default      -> 1 << random.nextInt(7); \/\/ powers of 2: 1..64\n+        };\n+    }\n+\n+    static int randomScale() {\n+        return switch (random.nextInt(6)) {\n+            case 0       -> random.nextInt(64) + 1; \/\/ [1..64]\n+            case 1, 2, 3 -> 1;\n+            default      -> 1 << random.nextInt(7); \/\/ powers of 2: 1..64\n+        };\n+    }\n+\n+    static int randomOffsetDiff() {\n+        return switch (random.nextInt(6)) {\n+            case 0       -> random.nextInt(256) + 128;\n+            case 1, 2, 3 -> 0;\n+            case 4       -> +(1 << random.nextInt(8)); \/\/ powers of 2: 1..128\n+            default      -> -(1 << random.nextInt(8)); \/\/ powers of 2: -1..-128\n+        };\n+    }\n+\n+    static int randomHandUnrolling() {\n+        return switch (random.nextInt(2)) {\n+            case 0       -> random.nextInt(16) + 1; \/\/ [1..16]\n+            default      -> 1 << random.nextInt(5); \/\/ powers of 2: 1..16\n+        };\n+    }\n+\n+    static void setRandomConstants() {\n+        \/\/ We want to create random constants for a loop, but they should never go out of bounds.\n+        \/\/ We constrain i to be in the range [init..limit], with init < limit. For simplicity, we\n+        \/\/ always generate:\n+        \/\/\n+        \/\/   1 <= scale  <= 64\n+        \/\/   1 <= stride <= 64\n+        \/\/\n+        \/\/ We work with this reference memory access:\n+        \/\/\n+        \/\/   a[offset + i * scale]\n+        \/\/\n+        \/\/ It is up to the test function to re-arrange the the given terms to iterate upward or\n+        \/\/ downward, to hand-unroll etc.\n+        \/\/\n+        \/\/ We must ensure that the first and last indices are in range:\n+        \/\/\n+        \/\/   0 + error <= offset + init * scale\n+        \/\/   offset + limit * scale < range - error\n+        \/\/\n+        \/\/ The \"error\" term is there such that the test functions have the freedom to slightly\n+        \/\/ diverge from the reference memory access pattern (for example modify the offset).\n+        \/\/\n+        \/\/ The values for scale and range are already fixed. We now want to generate values for\n+        \/\/ offset, init and limit.\n+        \/\/\n+        \/\/ (1) Fix offset:\n+        \/\/\n+        \/\/     init >= (error - offset) \/ scale\n+        \/\/     limit < (range - error - offset) \/ scale\n+        \/\/\n+        \/\/ (2) Fix init:\n+        \/\/\n+        \/\/     offset >= error - init * scale\n+        \/\/     limit < (range - error - offset) \/ scale\n+        \/\/\n+        \/\/ (3) Fix limit:\n+        \/\/\n+        \/\/     offset < range - error - limit * scale\n+        \/\/     init >= (error - offset) \/ scale\n+        \/\/\n+        \/\/ We can still slightly perturb the results in the direction permitted by the inequality.\n+\n+        int stride = randomStride();\n+        int scale = randomScale();\n+        int range = RANGE_CON;\n+        int error = 1024; \/\/ generous\n+        int init;\n+        int limit;\n+        int offset1;\n+        switch(random.nextInt(3)) {\n+            case 0 -> {\n+                offset1 = random.nextInt(2_000_000) - 1_000_000;\n+                init = (error - offset1) \/ scale + random.nextInt(64);\n+                limit = (range - error - offset1) \/ scale - random.nextInt(64);\n+            }\n+            case 1 -> {\n+                init = random.nextInt(2_000_000) - 1_000_000;\n+                offset1 = error - init * scale + random.nextInt(64);\n+                limit = (range - error - offset1) \/ scale - random.nextInt(64);\n+            }\n+            default -> {\n+                limit = random.nextInt(2_000_000) - 1_000_000;\n+                offset1 = range - error - limit * scale - random.nextInt(64);\n+                init = (error - offset1) \/ scale + random.nextInt(64);\n+            }\n+        }\n+\n+        int offset2 = offset1 + randomOffsetDiff();\n+        int offset3 = offset1 + randomOffsetDiff();\n+\n+        \/\/ We can toggle the init, limit and offset to either be constant or variable:\n+        boolean init_is_con   = random.nextInt(3) != 0;\n+        boolean limit_is_con  = random.nextInt(3) != 0;\n+        boolean offset1_is_con = random.nextInt(3) != 0;\n+        boolean offset2_is_con = random.nextInt(3) != 0;\n+        boolean offset3_is_con = random.nextInt(3) != 0;\n+\n+        int hand_unrolling1 = randomHandUnrolling();\n+        int hand_unrolling2 = randomHandUnrolling();\n+        int hand_unrolling3 = randomHandUnrolling();\n+\n+\/\/      Overwrite the fuzzed values below to reproduce a specific failure:\n+\/\/\n+\/\/        init = 1;\n+\/\/        limit = init + 3000;\n+\/\/        offset1 = 0;\n+\/\/        offset2 = 0;\n+\/\/        offset3 = 32 - 2*init;\n+\/\/        stride =  1;\n+\/\/        scale =   2;\n+\/\/        hand_unrolling1 = 0;\n+\/\/        hand_unrolling2 = 0;\n+\/\/        hand_unrolling3 = 4;\n+\/\/\n+\/\/        init_is_con    = true;\n+\/\/        limit_is_con   = true;\n+\/\/        offset1_is_con = true;\n+\/\/        offset2_is_con = true;\n+\/\/        offset3_is_con = true;\n+\n+        System.out.println(\"  init:    \" + init    + \" (con: \" + init_is_con + \")\");\n+        System.out.println(\"  limit:   \" + limit   + \" (con: \" + limit_is_con + \")\");\n+        System.out.println(\"  offset1: \" + offset1 + \" (con: \" + offset1_is_con + \")\");\n+        System.out.println(\"  offset2: \" + offset2 + \" (con: \" + offset2_is_con + \")\");\n+        System.out.println(\"  offset3: \" + offset3 + \" (con: \" + offset3_is_con + \")\");\n+        System.out.println(\"  stride:  \" + stride);\n+        System.out.println(\"  scale:   \" + scale);\n+        System.out.println(\"  hand_unrolling1: \" + hand_unrolling1);\n+        System.out.println(\"  hand_unrolling2: \" + hand_unrolling2);\n+        System.out.println(\"  hand_unrolling3: \" + hand_unrolling3);\n+        setConstant(INIT_CS,   init);\n+        setConstant(LIMIT_CS,  limit);\n+        setConstant(STRIDE_CS, stride);\n+        setConstant(SCALE_CS,  scale);\n+        setConstant(OFFSET1_CS, offset1);\n+        setConstant(OFFSET2_CS, offset2);\n+        setConstant(OFFSET3_CS, offset3);\n+        setConstant(INIT_IS_CON_CS,   init_is_con);\n+        setConstant(LIMIT_IS_CON_CS,  limit_is_con);\n+        setConstant(OFFSET1_IS_CON_CS, offset1_is_con);\n+        setConstant(OFFSET2_IS_CON_CS, offset2_is_con);\n+        setConstant(OFFSET3_IS_CON_CS, offset3_is_con);\n+        setConstant(HAND_UNROLLING1_CS, hand_unrolling1);\n+        setConstant(HAND_UNROLLING2_CS, hand_unrolling2);\n+        setConstant(HAND_UNROLLING3_CS, hand_unrolling3);\n+    }\n+\n+    public static void main(String[] args) {\n+        byte[] aB = generateB();\n+        byte[] bB = generateB();\n+        byte[] cB = generateB();\n+        short[] aS = generateS();\n+        short[] bS = generateS();\n+        short[] cS = generateS();\n+        char[] aC = generateC();\n+        char[] bC = generateC();\n+        char[] cC = generateC();\n+        int[] aI = generateI();\n+        int[] bI = generateI();\n+        int[] cI = generateI();\n+        long[] aL = generateL();\n+        long[] bL = generateL();\n+        long[] cL = generateL();\n+        float[] aF = generateF();\n+        float[] bF = generateF();\n+        float[] cF = generateF();\n+        double[] aD = generateD();\n+        double[] bD = generateD();\n+        double[] cD = generateD();\n+\n+        \/\/ Add all tests to list\n+        Map<String,TestFunction> tests = new HashMap<String,TestFunction>();\n+        tests.put(\"testUUB\", () -> { return testUUB(aB.clone()); });\n+        tests.put(\"testDDB\", () -> { return testDDB(aB.clone()); });\n+        tests.put(\"testUDB\", () -> { return testUDB(aB.clone()); });\n+        tests.put(\"testDUB\", () -> { return testDUB(aB.clone()); });\n+\n+        tests.put(\"testUUBH\", () -> { return testUUBH(aB.clone()); });\n+\n+        tests.put(\"testUUBBB\", () -> { return testUUBBB(aB.clone(), bB.clone(), cB.clone()); });\n+        tests.put(\"testUUBSI\", () -> { return testUUBSI(aB.clone(), bS.clone(), cI.clone()); });\n+\n+        tests.put(\"testUUBBBH\", () -> { return testUUBBBH(aB.clone(), bB.clone(), cB.clone()); });\n+\n+        tests.put(\"testUUBCFH\", () -> { return testUUBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+        tests.put(\"testDDBCFH\", () -> { return testDDBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+        tests.put(\"testUDBCFH\", () -> { return testUDBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+        tests.put(\"testDUBCFH\", () -> { return testDUBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+\n+        tests.put(\"testMMSFD\", () -> { return testMMSFD(aS.clone(), bF.clone(), cD.clone()); });\n+\n+        tests.put(\"testUU_unsafe_BasI\", () -> { return testUU_unsafe_BasI(aB.clone()); });\n+        tests.put(\"testUU_unsafe_BasIH\", () -> { return testUU_unsafe_BasIH(aB.clone(), bB.clone(), cB.clone()); });\n+\n+\n+        \/\/ Only run for 90% of the time, and subtract some margin. This ensures the shutdown has sufficient time,\n+        \/\/ even for very slow runs.\n+        long test_time_allowance = System.currentTimeMillis() +\n+                                   (long)(Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) * 0.9) -\n+                                   20_000;\n+        long test_hard_timeout = System.currentTimeMillis() +\n+                                Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT);\n+\n+        for (int i = 1; i <= ITERATIONS_MAX; i++) {\n+            setRandomConstants();\n+            for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+                String name = entry.getKey();\n+                TestFunction test = entry.getValue();\n+                long allowance = test_time_allowance - System.currentTimeMillis();\n+                long until_timeout = test_hard_timeout - System.currentTimeMillis();\n+                System.out.println(\"ITERATION \" + i + \" of \" + ITERATIONS_MAX + \". Test \" + name +\n+                                   \", time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+\n+                \/\/ Compute gold value, probably deopt first if constants have changed.\n+                Object[] gold = test.run();\n+\n+                \/\/ Have enough iterations to (re)compile\n+                for (int j = 0; j < 10_000; j++) {\n+                    Object[] result = test.run();\n+                    verify(name, gold, result);\n+                }\n+\n+                if (System.currentTimeMillis() > test_time_allowance) {\n+                    allowance = test_time_allowance - System.currentTimeMillis();\n+                    until_timeout = test_hard_timeout - System.currentTimeMillis();\n+                    System.out.println(\"TEST PASSED: hit maximal time allownance during iteration \" + i +\n+                                       \", time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+                    return;\n+                }\n+            }\n+        }\n+        long allowance = test_time_allowance - System.currentTimeMillis();\n+        long until_timeout = test_hard_timeout - System.currentTimeMillis();\n+        System.out.println(\"TEST PASSED, time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+    }\n+\n+    \/\/ Test names:\n+    \/\/ test\n+    \/\/ {U: i goes up, D: i goes down, M: mixed}\n+    \/\/ {U: indexing goes up, D: indexing goes down, M: mixed}\n+    \/\/ BSCILFD (types used)\n+\n+    \/\/ -------------------- BASIC SINGLE --------------------\n+\n+    static Object[] testUUB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset + i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testDDB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+            a[offset + i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testUDB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x = opposite_direction_offset1_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+           a[x - i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testDUB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x = opposite_direction_offset1_con_or_var();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+           a[x - i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    \/\/ -------------------- BASIC HAND UNROLL --------------------\n+\n+    static Object[] testUUBH(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        \/\/ All if statements with constant h fold to true or false\n+        int h = hand_unrolling1_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h >=  1) { a[offset + i * scale +  0]++; }\n+            if (h >=  2) { a[offset + i * scale +  1]++; }\n+            if (h >=  3) { a[offset + i * scale +  2]++; }\n+            if (h >=  4) { a[offset + i * scale +  3]++; }\n+            if (h >=  5) { a[offset + i * scale +  4]++; }\n+            if (h >=  6) { a[offset + i * scale +  5]++; }\n+            if (h >=  7) { a[offset + i * scale +  6]++; }\n+            if (h >=  8) { a[offset + i * scale +  7]++; }\n+            if (h >=  9) { a[offset + i * scale +  8]++; }\n+            if (h >= 10) { a[offset + i * scale +  9]++; }\n+            if (h >= 11) { a[offset + i * scale + 10]++; }\n+            if (h >= 12) { a[offset + i * scale + 11]++; }\n+            if (h >= 13) { a[offset + i * scale + 12]++; }\n+            if (h >= 14) { a[offset + i * scale + 13]++; }\n+            if (h >= 15) { a[offset + i * scale + 14]++; }\n+            if (h >= 16) { a[offset + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    \/\/ -------------------- BASIC TRIPPLE --------------------\n+\n+    static Object[] testUUBBB(byte[] a, byte[] b, byte[] c) {\n+        int init    = init_con_or_var();\n+        int limit   = limit_con_or_var();\n+        int stride  = stride_con();\n+        int scale   = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset1 + i * scale]++;\n+            b[offset2 + i * scale]++;\n+            c[offset3 + i * scale]++;\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testUUBSI(byte[] a, short[] b, int[] c) {\n+        int init    = init_con_or_var();\n+        int limit   = limit_con_or_var();\n+        int stride  = stride_con();\n+        int scale   = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset1 + i * scale]++;\n+            b[offset2 + i * scale]++;\n+            c[offset3 + i * scale]++;\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    \/\/ -------------------- HAND UNROLL TRIPPLE --------------------\n+\n+    static Object[] testUUBBBH(byte[] a, byte[] b, byte[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testUUBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testDDBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testUDBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x1 = opposite_direction_offset1_con_or_var();\n+        int x2 = opposite_direction_offset2_con_or_var();\n+        int x3 = opposite_direction_offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[x1 - i * scale +  0]++; }\n+            if (h1 >=  2) { a[x1 - i * scale +  1]++; }\n+            if (h1 >=  3) { a[x1 - i * scale +  2]++; }\n+            if (h1 >=  4) { a[x1 - i * scale +  3]++; }\n+            if (h1 >=  5) { a[x1 - i * scale +  4]++; }\n+            if (h1 >=  6) { a[x1 - i * scale +  5]++; }\n+            if (h1 >=  7) { a[x1 - i * scale +  6]++; }\n+            if (h1 >=  8) { a[x1 - i * scale +  7]++; }\n+            if (h1 >=  9) { a[x1 - i * scale +  8]++; }\n+            if (h1 >= 10) { a[x1 - i * scale +  9]++; }\n+            if (h1 >= 11) { a[x1 - i * scale + 10]++; }\n+            if (h1 >= 12) { a[x1 - i * scale + 11]++; }\n+            if (h1 >= 13) { a[x1 - i * scale + 12]++; }\n+            if (h1 >= 14) { a[x1 - i * scale + 13]++; }\n+            if (h1 >= 15) { a[x1 - i * scale + 14]++; }\n+            if (h1 >= 16) { a[x1 - i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[x2 - i * scale +  0]++; }\n+            if (h2 >=  2) { b[x2 - i * scale +  1]++; }\n+            if (h2 >=  3) { b[x2 - i * scale +  2]++; }\n+            if (h2 >=  4) { b[x2 - i * scale +  3]++; }\n+            if (h2 >=  5) { b[x2 - i * scale +  4]++; }\n+            if (h2 >=  6) { b[x2 - i * scale +  5]++; }\n+            if (h2 >=  7) { b[x2 - i * scale +  6]++; }\n+            if (h2 >=  8) { b[x2 - i * scale +  7]++; }\n+            if (h2 >=  9) { b[x2 - i * scale +  8]++; }\n+            if (h2 >= 10) { b[x2 - i * scale +  9]++; }\n+            if (h2 >= 11) { b[x2 - i * scale + 10]++; }\n+            if (h2 >= 12) { b[x2 - i * scale + 11]++; }\n+            if (h2 >= 13) { b[x2 - i * scale + 12]++; }\n+            if (h2 >= 14) { b[x2 - i * scale + 13]++; }\n+            if (h2 >= 15) { b[x2 - i * scale + 14]++; }\n+            if (h2 >= 16) { b[x2 - i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[x3 - i * scale +  0]++; }\n+            if (h3 >=  2) { c[x3 - i * scale +  1]++; }\n+            if (h3 >=  3) { c[x3 - i * scale +  2]++; }\n+            if (h3 >=  4) { c[x3 - i * scale +  3]++; }\n+            if (h3 >=  5) { c[x3 - i * scale +  4]++; }\n+            if (h3 >=  6) { c[x3 - i * scale +  5]++; }\n+            if (h3 >=  7) { c[x3 - i * scale +  6]++; }\n+            if (h3 >=  8) { c[x3 - i * scale +  7]++; }\n+            if (h3 >=  9) { c[x3 - i * scale +  8]++; }\n+            if (h3 >= 10) { c[x3 - i * scale +  9]++; }\n+            if (h3 >= 11) { c[x3 - i * scale + 10]++; }\n+            if (h3 >= 12) { c[x3 - i * scale + 11]++; }\n+            if (h3 >= 13) { c[x3 - i * scale + 12]++; }\n+            if (h3 >= 14) { c[x3 - i * scale + 13]++; }\n+            if (h3 >= 15) { c[x3 - i * scale + 14]++; }\n+            if (h3 >= 16) { c[x3 - i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testDUBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x1 = opposite_direction_offset1_con_or_var();\n+        int x2 = opposite_direction_offset2_con_or_var();\n+        int x3 = opposite_direction_offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+            if (h1 >=  1) { a[x1 - i * scale +  0]++; }\n+            if (h1 >=  2) { a[x1 - i * scale +  1]++; }\n+            if (h1 >=  3) { a[x1 - i * scale +  2]++; }\n+            if (h1 >=  4) { a[x1 - i * scale +  3]++; }\n+            if (h1 >=  5) { a[x1 - i * scale +  4]++; }\n+            if (h1 >=  6) { a[x1 - i * scale +  5]++; }\n+            if (h1 >=  7) { a[x1 - i * scale +  6]++; }\n+            if (h1 >=  8) { a[x1 - i * scale +  7]++; }\n+            if (h1 >=  9) { a[x1 - i * scale +  8]++; }\n+            if (h1 >= 10) { a[x1 - i * scale +  9]++; }\n+            if (h1 >= 11) { a[x1 - i * scale + 10]++; }\n+            if (h1 >= 12) { a[x1 - i * scale + 11]++; }\n+            if (h1 >= 13) { a[x1 - i * scale + 12]++; }\n+            if (h1 >= 14) { a[x1 - i * scale + 13]++; }\n+            if (h1 >= 15) { a[x1 - i * scale + 14]++; }\n+            if (h1 >= 16) { a[x1 - i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[x2 - i * scale +  0]++; }\n+            if (h2 >=  2) { b[x2 - i * scale +  1]++; }\n+            if (h2 >=  3) { b[x2 - i * scale +  2]++; }\n+            if (h2 >=  4) { b[x2 - i * scale +  3]++; }\n+            if (h2 >=  5) { b[x2 - i * scale +  4]++; }\n+            if (h2 >=  6) { b[x2 - i * scale +  5]++; }\n+            if (h2 >=  7) { b[x2 - i * scale +  6]++; }\n+            if (h2 >=  8) { b[x2 - i * scale +  7]++; }\n+            if (h2 >=  9) { b[x2 - i * scale +  8]++; }\n+            if (h2 >= 10) { b[x2 - i * scale +  9]++; }\n+            if (h2 >= 11) { b[x2 - i * scale + 10]++; }\n+            if (h2 >= 12) { b[x2 - i * scale + 11]++; }\n+            if (h2 >= 13) { b[x2 - i * scale + 12]++; }\n+            if (h2 >= 14) { b[x2 - i * scale + 13]++; }\n+            if (h2 >= 15) { b[x2 - i * scale + 14]++; }\n+            if (h2 >= 16) { b[x2 - i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[x3 - i * scale +  0]++; }\n+            if (h3 >=  2) { c[x3 - i * scale +  1]++; }\n+            if (h3 >=  3) { c[x3 - i * scale +  2]++; }\n+            if (h3 >=  4) { c[x3 - i * scale +  3]++; }\n+            if (h3 >=  5) { c[x3 - i * scale +  4]++; }\n+            if (h3 >=  6) { c[x3 - i * scale +  5]++; }\n+            if (h3 >=  7) { c[x3 - i * scale +  6]++; }\n+            if (h3 >=  8) { c[x3 - i * scale +  7]++; }\n+            if (h3 >=  9) { c[x3 - i * scale +  8]++; }\n+            if (h3 >= 10) { c[x3 - i * scale +  9]++; }\n+            if (h3 >= 11) { c[x3 - i * scale + 10]++; }\n+            if (h3 >= 12) { c[x3 - i * scale + 11]++; }\n+            if (h3 >= 13) { c[x3 - i * scale + 12]++; }\n+            if (h3 >= 14) { c[x3 - i * scale + 13]++; }\n+            if (h3 >= 15) { c[x3 - i * scale + 14]++; }\n+            if (h3 >= 16) { c[x3 - i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    \/\/ -------------------- MIXED DIRECTION TRIPPLE --------------------\n+\n+    static Object[] testMMSFD(short[] a, float[] b, double[] c) {\n+        int init    = init_con_or_var();\n+        int limit   = limit_con_or_var();\n+        int stride  = stride_con();\n+        int scale   = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = opposite_direction_offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset1 + i * scale]++;\n+            b[offset2 - i * scale]++;\n+            c[offset3 + i * scale]++;\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    \/\/ -------------------- UNSAFE --------------------\n+\n+    static Object[] testUU_unsafe_BasI(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            int adr = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset + i * scale;\n+            int v = UNSAFE.getIntUnaligned(a, adr);\n+            UNSAFE.putIntUnaligned(a, adr, v + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testUU_unsafe_BasIH(byte[] a, byte[] b, byte[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            int adr1 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset1 + i * scale;\n+            int adr2 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset2 + i * scale;\n+            int adr3 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset3 + i * scale;\n+\n+            if (h1 >=  1) { UNSAFE.putIntUnaligned(a, adr1 +  0*4, UNSAFE.getIntUnaligned(a, adr1 +  0*4) + 1); }\n+            if (h1 >=  2) { UNSAFE.putIntUnaligned(a, adr1 +  1*4, UNSAFE.getIntUnaligned(a, adr1 +  1*4) + 1); }\n+            if (h1 >=  3) { UNSAFE.putIntUnaligned(a, adr1 +  2*4, UNSAFE.getIntUnaligned(a, adr1 +  2*4) + 1); }\n+            if (h1 >=  4) { UNSAFE.putIntUnaligned(a, adr1 +  3*4, UNSAFE.getIntUnaligned(a, adr1 +  3*4) + 1); }\n+            if (h1 >=  5) { UNSAFE.putIntUnaligned(a, adr1 +  4*4, UNSAFE.getIntUnaligned(a, adr1 +  4*4) + 1); }\n+            if (h1 >=  6) { UNSAFE.putIntUnaligned(a, adr1 +  5*4, UNSAFE.getIntUnaligned(a, adr1 +  5*4) + 1); }\n+            if (h1 >=  7) { UNSAFE.putIntUnaligned(a, adr1 +  6*4, UNSAFE.getIntUnaligned(a, adr1 +  6*4) + 1); }\n+            if (h1 >=  8) { UNSAFE.putIntUnaligned(a, adr1 +  7*4, UNSAFE.getIntUnaligned(a, adr1 +  7*4) + 1); }\n+            if (h1 >=  9) { UNSAFE.putIntUnaligned(a, adr1 +  8*4, UNSAFE.getIntUnaligned(a, adr1 +  8*4) + 1); }\n+            if (h1 >= 10) { UNSAFE.putIntUnaligned(a, adr1 +  9*4, UNSAFE.getIntUnaligned(a, adr1 +  9*4) + 1); }\n+            if (h1 >= 11) { UNSAFE.putIntUnaligned(a, adr1 + 10*4, UNSAFE.getIntUnaligned(a, adr1 + 10*4) + 1); }\n+            if (h1 >= 12) { UNSAFE.putIntUnaligned(a, adr1 + 11*4, UNSAFE.getIntUnaligned(a, adr1 + 11*4) + 1); }\n+            if (h1 >= 13) { UNSAFE.putIntUnaligned(a, adr1 + 12*4, UNSAFE.getIntUnaligned(a, adr1 + 12*4) + 1); }\n+            if (h1 >= 14) { UNSAFE.putIntUnaligned(a, adr1 + 13*4, UNSAFE.getIntUnaligned(a, adr1 + 13*4) + 1); }\n+            if (h1 >= 15) { UNSAFE.putIntUnaligned(a, adr1 + 14*4, UNSAFE.getIntUnaligned(a, adr1 + 14*4) + 1); }\n+            if (h1 >= 16) { UNSAFE.putIntUnaligned(a, adr1 + 15*4, UNSAFE.getIntUnaligned(a, adr1 + 15*4) + 1); }\n+\n+            if (h2 >=  1) { UNSAFE.putIntUnaligned(b, adr2 +  0*4, UNSAFE.getIntUnaligned(b, adr2 +  0*4) + 1); }\n+            if (h2 >=  2) { UNSAFE.putIntUnaligned(b, adr2 +  1*4, UNSAFE.getIntUnaligned(b, adr2 +  1*4) + 1); }\n+            if (h2 >=  3) { UNSAFE.putIntUnaligned(b, adr2 +  2*4, UNSAFE.getIntUnaligned(b, adr2 +  2*4) + 1); }\n+            if (h2 >=  4) { UNSAFE.putIntUnaligned(b, adr2 +  3*4, UNSAFE.getIntUnaligned(b, adr2 +  3*4) + 1); }\n+            if (h2 >=  5) { UNSAFE.putIntUnaligned(b, adr2 +  4*4, UNSAFE.getIntUnaligned(b, adr2 +  4*4) + 1); }\n+            if (h2 >=  6) { UNSAFE.putIntUnaligned(b, adr2 +  5*4, UNSAFE.getIntUnaligned(b, adr2 +  5*4) + 1); }\n+            if (h2 >=  7) { UNSAFE.putIntUnaligned(b, adr2 +  6*4, UNSAFE.getIntUnaligned(b, adr2 +  6*4) + 1); }\n+            if (h2 >=  8) { UNSAFE.putIntUnaligned(b, adr2 +  7*4, UNSAFE.getIntUnaligned(b, adr2 +  7*4) + 1); }\n+            if (h2 >=  9) { UNSAFE.putIntUnaligned(b, adr2 +  8*4, UNSAFE.getIntUnaligned(b, adr2 +  8*4) + 1); }\n+            if (h2 >= 10) { UNSAFE.putIntUnaligned(b, adr2 +  9*4, UNSAFE.getIntUnaligned(b, adr2 +  9*4) + 1); }\n+            if (h2 >= 11) { UNSAFE.putIntUnaligned(b, adr2 + 10*4, UNSAFE.getIntUnaligned(b, adr2 + 10*4) + 1); }\n+            if (h2 >= 12) { UNSAFE.putIntUnaligned(b, adr2 + 11*4, UNSAFE.getIntUnaligned(b, adr2 + 11*4) + 1); }\n+            if (h2 >= 13) { UNSAFE.putIntUnaligned(b, adr2 + 12*4, UNSAFE.getIntUnaligned(b, adr2 + 12*4) + 1); }\n+            if (h2 >= 14) { UNSAFE.putIntUnaligned(b, adr2 + 13*4, UNSAFE.getIntUnaligned(b, adr2 + 13*4) + 1); }\n+            if (h2 >= 15) { UNSAFE.putIntUnaligned(b, adr2 + 14*4, UNSAFE.getIntUnaligned(b, adr2 + 14*4) + 1); }\n+            if (h2 >= 16) { UNSAFE.putIntUnaligned(b, adr2 + 15*4, UNSAFE.getIntUnaligned(b, adr2 + 15*4) + 1); }\n+\n+            if (h3 >=  1) { UNSAFE.putIntUnaligned(c, adr3 +  0*4, UNSAFE.getIntUnaligned(c, adr3 +  0*4) + 1); }\n+            if (h3 >=  2) { UNSAFE.putIntUnaligned(c, adr3 +  1*4, UNSAFE.getIntUnaligned(c, adr3 +  1*4) + 1); }\n+            if (h3 >=  3) { UNSAFE.putIntUnaligned(c, adr3 +  2*4, UNSAFE.getIntUnaligned(c, adr3 +  2*4) + 1); }\n+            if (h3 >=  4) { UNSAFE.putIntUnaligned(c, adr3 +  3*4, UNSAFE.getIntUnaligned(c, adr3 +  3*4) + 1); }\n+            if (h3 >=  5) { UNSAFE.putIntUnaligned(c, adr3 +  4*4, UNSAFE.getIntUnaligned(c, adr3 +  4*4) + 1); }\n+            if (h3 >=  6) { UNSAFE.putIntUnaligned(c, adr3 +  5*4, UNSAFE.getIntUnaligned(c, adr3 +  5*4) + 1); }\n+            if (h3 >=  7) { UNSAFE.putIntUnaligned(c, adr3 +  6*4, UNSAFE.getIntUnaligned(c, adr3 +  6*4) + 1); }\n+            if (h3 >=  8) { UNSAFE.putIntUnaligned(c, adr3 +  7*4, UNSAFE.getIntUnaligned(c, adr3 +  7*4) + 1); }\n+            if (h3 >=  9) { UNSAFE.putIntUnaligned(c, adr3 +  8*4, UNSAFE.getIntUnaligned(c, adr3 +  8*4) + 1); }\n+            if (h3 >= 10) { UNSAFE.putIntUnaligned(c, adr3 +  9*4, UNSAFE.getIntUnaligned(c, adr3 +  9*4) + 1); }\n+            if (h3 >= 11) { UNSAFE.putIntUnaligned(c, adr3 + 10*4, UNSAFE.getIntUnaligned(c, adr3 + 10*4) + 1); }\n+            if (h3 >= 12) { UNSAFE.putIntUnaligned(c, adr3 + 11*4, UNSAFE.getIntUnaligned(c, adr3 + 11*4) + 1); }\n+            if (h3 >= 13) { UNSAFE.putIntUnaligned(c, adr3 + 12*4, UNSAFE.getIntUnaligned(c, adr3 + 12*4) + 1); }\n+            if (h3 >= 14) { UNSAFE.putIntUnaligned(c, adr3 + 13*4, UNSAFE.getIntUnaligned(c, adr3 + 13*4) + 1); }\n+            if (h3 >= 15) { UNSAFE.putIntUnaligned(c, adr3 + 14*4, UNSAFE.getIntUnaligned(c, adr3 + 14*4) + 1); }\n+            if (h3 >= 16) { UNSAFE.putIntUnaligned(c, adr3 + 15*4, UNSAFE.getIntUnaligned(c, adr3 + 15*4) + 1); }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static char[] generateC() {\n+        char[] a = new char[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (char)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static short[] generateS() {\n+        short[] a = new short[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static int[] generateI() {\n+        int[] a = new int[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static long[] generateL() {\n+        long[] a = new long[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = random.nextLong();\n+        }\n+        return a;\n+    }\n+\n+    static float[] generateF() {\n+        float[] a = new float[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Float.intBitsToFloat(random.nextInt());\n+        }\n+        return a;\n+    }\n+\n+    static double[] generateD() {\n+        double[] a = new double[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Double.longBitsToDouble(random.nextLong());\n+        }\n+        return a;\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == char.class) {\n+                verifyC(name, i, (char[])g, (char[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else if (c == float.class) {\n+                verifyF(name, i, (float[])g, (float[])r);\n+            } else if (c == double.class) {\n+                verifyD(name, i, (double[])g, (double[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyB \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyC(String name, int i, char[] g, char[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyC \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyS \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyI \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyL \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyF(String name, int i, float[] g, float[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            int gv = UNSAFE.getInt(g, UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4 * j);\n+            int rv = UNSAFE.getInt(r, UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4 * j);\n+            if (gv != rv) {\n+                throw new RuntimeException(\"verifyF \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + gv +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + rv);\n+            }\n+        }\n+    }\n+\n+    static void verifyD(String name, int i, double[] g, double[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            long gv = UNSAFE.getLong(g, UNSAFE.ARRAY_DOUBLE_BASE_OFFSET + 8 * j);\n+            long rv = UNSAFE.getLong(r, UNSAFE.ARRAY_DOUBLE_BASE_OFFSET + 8 * j);\n+            if (gv != rv) {\n+                throw new RuntimeException(\"verifyF \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + gv +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + rv);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVectorFuzzer.java","additions":1353,"deletions":0,"binary":false,"changes":1353,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- *       https:\/\/bugs.openjdk.org\/browse\/JDK-8312570\n+ *       https:\/\/bugs.openjdk.org\/browse\/JDK-8310190\n@@ -52,2 +52,1 @@\n- * the CPU-features. Thus, we have a positive and negative IR rule per\n- * CPU-feature for each test.\n+ * the CPU-features.\n@@ -69,5 +68,1 @@\n- * With '-XX:+AlignVector', we would like to check that we vectorize exactly iff:\n- *     byte_offset % actual_vector_width == 0\n- * Because all vector_widths are powers of 2, this is equivalent to:\n- *     pow2_factor(byte_offset) >= actual_vector_width\n- * where pow2_factor computes the largest power of 2 that is a factor of the number.\n+ * With '-XX:+AlignVector' we do the following:\n@@ -75,2 +70,32 @@\n- * Under these assumptions, we know there must be vectorization:\n- *     pow2_factor(byte_offset) >= vector_width\n+ * Must vectorize cleanly if:\n+ *   1) guaranteed no misalignment AND\n+ *   2) guaratneed no cyclic dependency\n+ *\n+ * Must not vectorize at all if:\n+ *   1) guaranteed misalignment AND\n+ *   2) guaranteed no cyclic dependency\n+ *\n+ * We could imagine a case with cyclic dependency, where C2 detects\n+ * that only the first load is needed, and so no vectorization is\n+ * required for it, and hence the store vector can be aligned.\n+ *\n+ * The alignment criteria is\n+ *     byte_offset % aw == 0\n+ * where align width (aw) is\n+ *     aw = min(actual_vector_width, ObjectAlignmentInBytes)\n+ * For simplicity, we assume that ObjectAlignmentInBytes == 8,\n+ * which currently can only be changed manually and then no IR\n+ * rule is run.\n+ * This allows us to do the computation statically.\n+ * Further, we define:\n+ *     aw_min = min(min_vector_width, ObjectAlignmentInBytes)\n+ *     aw_max = min(vector_width, ObjectAlignmentInBytes)\n+ *     aw_min <= aw <= aw_max\n+ *\n+ * Again, we have no cyclic dependency, except when:\n+ *     byte_offset > 0 and p.vector_width > byte_offset\n+ * Here we must ensure that:\n+ *     byte_offset >= MaxVectorSize\n+ *\n+ * Guaranteed no misalignment:\n+ *     byte_offset % aw_max == 0\n@@ -78,3 +103,1 @@\n- *         pow2_factor(byte_offset) >= actual_vector_width\n- *     MaxVectorSize >= min_vector_size\n- *       else any vectorization is impossible.\n+ *         byte_offset % aw == 0\n@@ -82,4 +105,2 @@\n- * And under the following conditions no vectorization is possible:\n- *     byte_offset < 0: No cyclic dependency.\n- *       Cyclic dependency could lead to Load removals, then only the store is vectorized.\n- *     byte_offset % min_vector_width != 0\n+ * Guaranteed misalignment:\n+ *     byte_offset % aw_min != 0\n@@ -87,1 +108,1 @@\n- *         byte_offset % actual_vector_width != 0\n+ *         byte_offset % aw != 0\n@@ -93,1 +114,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -102,1 +123,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -111,1 +132,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -122,1 +143,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -133,1 +154,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -144,1 +165,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -155,1 +176,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -166,1 +187,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -177,1 +198,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -188,1 +209,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -199,1 +220,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -210,1 +231,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -221,1 +242,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -232,1 +253,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -243,1 +264,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -254,1 +275,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -265,1 +286,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -276,1 +297,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -287,1 +308,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -298,1 +319,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -309,1 +330,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -320,1 +341,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -331,1 +352,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -342,1 +363,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -353,1 +374,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -364,1 +385,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -375,1 +396,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -385,1 +406,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -395,1 +416,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -405,1 +426,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -415,1 +436,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -425,1 +446,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -435,1 +456,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -445,1 +466,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -455,1 +476,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -465,1 +486,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -1395,0 +1416,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1399,0 +1424,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1403,0 +1432,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1407,0 +1440,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1411,0 +1448,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1431,1 +1472,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1439,1 +1480,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1447,1 +1488,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1455,1 +1496,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1463,1 +1504,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1486,0 +1527,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1489,0 +1534,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1492,0 +1541,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1495,0 +1548,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1498,0 +1555,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1518,0 +1579,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1522,0 +1587,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1526,0 +1595,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1530,0 +1603,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1534,0 +1611,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1553,1 +1634,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1558,1 +1643,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1563,1 +1652,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1568,1 +1661,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1573,1 +1670,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1595,1 +1696,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1603,1 +1704,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1611,1 +1712,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1619,1 +1720,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1627,1 +1728,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1652,0 +1753,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1657,0 +1762,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1662,0 +1771,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1667,0 +1780,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1672,0 +1789,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1692,0 +1813,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1696,0 +1821,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1700,0 +1829,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1704,0 +1837,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1708,0 +1845,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1728,1 +1869,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1737,0 +1878,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1742,0 +1887,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1746,1 +1895,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1755,0 +1904,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1775,1 +1928,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1783,1 +1936,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1791,1 +1944,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1799,1 +1952,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1807,1 +1960,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1831,0 +1984,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1836,0 +1993,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1841,0 +2002,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1845,0 +2010,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1850,0 +2019,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1870,0 +2043,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1874,0 +2051,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1878,0 +2059,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1882,0 +2067,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1886,0 +2075,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1906,1 +2099,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1914,1 +2107,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1923,0 +2116,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1927,1 +2124,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1936,0 +2133,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1956,0 +2157,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1960,0 +2165,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1964,0 +2173,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1968,0 +2181,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1972,0 +2189,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1992,0 +2213,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1996,0 +2221,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2001,0 +2230,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2005,0 +2238,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2010,0 +2247,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2030,0 +2271,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2034,0 +2279,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2038,0 +2287,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2042,0 +2295,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2046,0 +2303,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2066,1 +2327,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2074,1 +2335,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2082,1 +2343,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2090,1 +2351,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2099,0 +2360,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2119,0 +2384,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2123,0 +2392,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2127,0 +2400,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2131,0 +2408,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2135,0 +2416,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2155,0 +2440,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2159,0 +2448,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2163,0 +2456,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2167,0 +2464,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2172,0 +2473,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2192,0 +2497,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2196,0 +2505,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2200,0 +2513,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2204,0 +2521,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2208,0 +2529,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2228,1 +2553,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2236,0 +2561,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2240,0 +2569,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2244,1 +2577,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2253,0 +2586,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2273,1 +2610,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2281,1 +2618,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2289,1 +2626,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2297,1 +2634,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2305,1 +2642,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2329,0 +2666,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2333,0 +2674,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2337,0 +2682,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2341,0 +2690,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2346,0 +2699,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 124\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2366,0 +2723,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2370,0 +2731,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2374,0 +2739,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2378,0 +2747,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2382,0 +2755,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2402,1 +2779,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2410,1 +2787,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2418,1 +2795,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2426,1 +2803,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2435,0 +2812,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2455,1 +2836,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2463,1 +2844,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2471,1 +2852,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2479,1 +2860,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2487,1 +2868,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2511,0 +2892,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2515,0 +2900,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2519,0 +2908,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2523,2 +2916,6 @@\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 252 can lead to cyclic dependency\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n+    \/\/   positive byte_offset 252 can lead to cyclic dependency\n@@ -2528,0 +2925,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 252\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2548,0 +2949,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2552,0 +2957,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2556,0 +2965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2560,0 +2973,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2564,0 +2981,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2584,1 +3005,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2592,1 +3013,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2600,1 +3021,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2608,1 +3029,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2616,1 +3037,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2640,1 +3061,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2648,1 +3069,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2656,1 +3077,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2664,1 +3085,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2672,1 +3093,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2696,0 +3117,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2700,0 +3125,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2704,0 +3133,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2708,0 +3141,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2712,0 +3149,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2732,0 +3173,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2736,0 +3181,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2740,0 +3189,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2744,0 +3197,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2748,0 +3205,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2768,1 +3229,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2776,1 +3237,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2784,1 +3245,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2792,1 +3253,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2800,1 +3261,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2824,1 +3285,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2832,1 +3293,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2840,1 +3301,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2848,1 +3309,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2856,1 +3317,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2880,0 +3341,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2884,0 +3349,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2888,0 +3357,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2892,0 +3365,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2896,0 +3373,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2916,0 +3397,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2920,0 +3405,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2924,0 +3413,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2928,0 +3421,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2932,0 +3429,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2952,1 +3453,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2960,1 +3461,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2968,1 +3469,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2976,1 +3477,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2984,1 +3485,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3008,0 +3509,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3012,0 +3517,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3016,0 +3525,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3020,0 +3533,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3024,0 +3541,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3044,3 +3565,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3052,3 +3573,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3060,3 +3581,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3068,3 +3589,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3076,3 +3597,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3099,0 +3620,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3102,0 +3625,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3105,0 +3630,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3108,0 +3635,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3111,0 +3640,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3131,0 +3662,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3135,0 +3670,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3139,0 +3678,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3143,0 +3686,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3147,0 +3694,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3167,1 +3718,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3174,1 +3725,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -3179,1 +3734,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -3185,1 +3744,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3192,1 +3751,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -3214,3 +3777,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3222,3 +3785,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3230,3 +3793,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3238,3 +3801,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3246,3 +3809,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3270,0 +3833,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3275,0 +3842,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3280,0 +3851,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3284,0 +3859,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3289,0 +3868,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3309,0 +3892,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3313,0 +3900,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3317,0 +3908,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3321,0 +3916,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3325,0 +3924,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3345,1 +3948,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3353,1 +3956,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3362,0 +3965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3366,1 +3973,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3375,0 +3982,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3395,3 +4006,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3403,3 +4014,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3411,3 +4022,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3419,3 +4030,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3427,3 +4038,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3451,0 +4062,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3455,0 +4070,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3460,0 +4079,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3464,0 +4087,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3469,0 +4096,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3489,0 +4120,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3493,0 +4128,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3497,0 +4136,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3501,0 +4144,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3505,0 +4152,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3525,1 +4176,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3533,1 +4184,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3541,1 +4192,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3549,1 +4200,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3558,0 +4209,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3578,0 +4233,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3582,0 +4241,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3586,0 +4249,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3590,0 +4257,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3594,0 +4265,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3614,1 +4289,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3622,0 +4297,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3626,0 +4305,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3630,1 +4313,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3639,0 +4322,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3659,0 +4346,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3663,1 +4354,5 @@\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n@@ -3667,0 +4362,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3671,0 +4370,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3675,0 +4378,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3695,1 +4402,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3703,1 +4410,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3711,1 +4418,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3719,1 +4426,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3728,0 +4435,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3748,0 +4459,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3752,0 +4467,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3756,0 +4475,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3760,0 +4483,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3764,0 +4491,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3784,1 +4515,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3792,0 +4523,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3796,0 +4531,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3800,1 +4539,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3809,0 +4548,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3829,0 +4572,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3833,0 +4580,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3837,0 +4588,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3841,0 +4596,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3845,0 +4604,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3865,1 +4628,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3873,1 +4636,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3881,0 +4644,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3885,1 +4652,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3894,0 +4661,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3914,3 +4685,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3922,3 +4693,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3930,3 +4701,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3938,3 +4709,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3946,3 +4717,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3970,0 +4741,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3974,0 +4749,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3978,0 +4757,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3982,0 +4765,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3987,0 +4774,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4007,0 +4798,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4011,0 +4806,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4015,0 +4814,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4019,0 +4822,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4023,0 +4830,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4043,1 +4854,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4051,1 +4862,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4059,1 +4870,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4067,1 +4878,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4075,1 +4886,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4099,3 +4910,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4107,3 +4918,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4115,3 +4926,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4123,3 +4934,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4131,3 +4942,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4155,0 +4966,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4159,0 +4974,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4163,0 +4982,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4167,0 +4990,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4171,0 +4998,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4191,0 +5022,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4195,0 +5030,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4199,0 +5038,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4203,0 +5046,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4207,0 +5054,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4227,1 +5078,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4235,1 +5086,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4243,1 +5094,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4251,1 +5102,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4259,1 +5110,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4283,3 +5134,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4291,3 +5142,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4299,3 +5150,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4307,3 +5158,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4315,3 +5166,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4339,0 +5190,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4343,0 +5198,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4347,0 +5206,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4351,0 +5214,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4355,0 +5222,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4375,0 +5246,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4379,0 +5254,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4383,0 +5262,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4387,0 +5270,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4391,0 +5278,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4411,1 +5302,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4419,1 +5310,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4427,1 +5318,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4435,1 +5326,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4443,1 +5334,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4467,3 +5358,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4475,3 +5366,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4483,3 +5374,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4491,3 +5382,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4499,3 +5390,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4523,0 +5414,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4527,0 +5422,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4531,0 +5430,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4535,0 +5438,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4539,0 +5446,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4559,0 +5470,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4563,0 +5478,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4567,0 +5486,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4571,0 +5494,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4575,0 +5502,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4595,1 +5526,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4603,1 +5534,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4611,1 +5542,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4619,1 +5550,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4627,1 +5558,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4651,0 +5582,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4655,0 +5590,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4659,0 +5598,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4663,0 +5606,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4667,0 +5614,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4687,1 +5638,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4695,1 +5646,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4703,1 +5654,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4711,1 +5662,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4719,1 +5670,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4742,0 +5693,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4745,0 +5700,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4748,0 +5707,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4751,0 +5714,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4754,0 +5721,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4774,0 +5745,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4778,0 +5750,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4782,0 +5755,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4786,0 +5760,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4790,0 +5765,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4809,1 +5785,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4811,0 +5787,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4814,1 +5791,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4816,0 +5793,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4819,1 +5797,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4821,0 +5799,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4824,1 +5803,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4826,0 +5805,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4829,1 +5809,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4831,0 +5811,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4851,1 +5832,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4859,1 +5840,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4867,1 +5848,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4875,1 +5856,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4883,1 +5864,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4908,0 +5889,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4913,0 +5898,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4918,0 +5907,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4923,0 +5916,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4928,0 +5925,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4948,0 +5949,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4952,0 +5957,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4956,0 +5965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4960,0 +5973,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4964,0 +5981,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4985,0 +6006,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4990,0 +6015,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4995,0 +6024,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5000,0 +6033,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5005,0 +6042,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5025,1 +6066,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5033,1 +6074,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5041,1 +6082,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5049,1 +6090,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5057,1 +6098,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5082,0 +6123,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5087,0 +6132,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5092,0 +6141,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5097,0 +6150,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5102,0 +6159,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5122,0 +6183,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5126,0 +6191,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5130,0 +6199,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5134,0 +6207,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5138,0 +6215,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5158,1 +6239,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5167,0 +6248,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5172,0 +6257,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5176,1 +6265,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5185,0 +6274,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5205,0 +6298,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5209,0 +6303,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5213,0 +6308,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5217,0 +6313,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5221,0 +6318,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5241,0 +6339,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5246,0 +6345,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5251,0 +6351,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5255,0 +6356,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5260,0 +6362,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5280,0 +6383,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5284,0 +6391,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5288,0 +6399,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5292,0 +6407,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5296,0 +6415,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5316,1 +6439,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5324,1 +6447,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5333,0 +6456,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5337,1 +6464,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5346,0 +6473,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5366,0 +6497,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5370,0 +6502,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5374,0 +6507,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5378,0 +6512,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5382,0 +6517,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5402,0 +6538,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5406,0 +6543,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5411,0 +6549,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5415,0 +6554,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5420,0 +6560,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5440,0 +6581,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5444,0 +6589,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5448,0 +6597,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5452,0 +6605,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5456,0 +6613,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5476,0 +6637,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5480,0 +6645,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5485,0 +6654,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5489,0 +6662,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5494,0 +6671,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5514,1 +6695,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5522,1 +6703,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5530,1 +6711,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5538,1 +6719,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5546,1 +6727,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5570,0 +6751,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5574,0 +6759,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5579,0 +6768,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5583,0 +6776,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5588,0 +6785,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5608,0 +6809,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5612,0 +6817,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5616,0 +6825,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5620,0 +6833,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5624,0 +6841,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5644,1 +6865,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5652,1 +6873,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5660,1 +6881,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5668,1 +6889,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5677,0 +6898,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5697,1 +6922,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5705,1 +6930,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5713,1 +6938,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5721,1 +6946,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5729,1 +6954,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5753,0 +6978,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5757,0 +6986,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5761,0 +6994,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5765,0 +7002,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5770,0 +7011,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 126\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5790,0 +7035,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5794,0 +7043,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5798,0 +7051,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5802,0 +7059,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5806,0 +7067,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5826,1 +7091,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5834,1 +7099,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5842,1 +7107,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5850,1 +7115,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5859,0 +7124,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5879,1 +7148,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5887,1 +7156,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5895,1 +7164,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5903,1 +7172,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5911,1 +7180,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5935,0 +7204,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5939,0 +7212,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5943,0 +7220,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5947,0 +7228,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5952,0 +7237,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 130\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5972,0 +7261,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5976,0 +7269,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5980,0 +7277,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5984,0 +7285,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5988,0 +7293,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6008,1 +7317,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6016,1 +7325,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6024,1 +7333,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6032,1 +7341,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6040,1 +7349,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6064,1 +7373,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6072,1 +7381,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6080,1 +7389,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6088,1 +7397,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6096,1 +7405,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6120,0 +7429,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6124,0 +7437,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6128,0 +7445,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6132,0 +7453,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6136,0 +7461,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6156,0 +7485,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6160,0 +7493,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6164,0 +7501,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6168,0 +7509,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6172,0 +7517,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6192,1 +7541,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6200,1 +7549,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6208,1 +7557,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6216,1 +7565,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6224,0 +7573,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6244,0 +7597,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6248,0 +7605,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6252,0 +7613,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6256,0 +7621,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6260,2 +7629,6 @@\n-    public static void testCharP0(char[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public static void testCharP0(char[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n@@ -6280,1 +7653,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6288,1 +7661,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6296,1 +7669,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6304,1 +7677,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6312,1 +7685,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6335,0 +7708,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6338,0 +7715,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6341,0 +7722,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6344,0 +7729,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6347,0 +7736,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6367,0 +7760,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6371,0 +7765,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6375,0 +7770,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6379,0 +7775,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6383,0 +7780,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6402,1 +7800,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6404,0 +7802,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6407,1 +7806,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6409,0 +7808,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6412,1 +7812,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6414,0 +7814,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6417,1 +7818,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6419,0 +7820,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6422,1 +7824,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6424,0 +7826,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6444,1 +7847,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6452,1 +7855,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6460,1 +7863,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6468,1 +7871,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6476,1 +7879,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6501,0 +7904,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6506,0 +7913,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6511,0 +7922,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6516,0 +7931,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6521,0 +7940,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6541,0 +7964,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6545,0 +7972,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6549,0 +7980,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6553,0 +7988,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6557,0 +7996,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6578,0 +8021,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6583,0 +8030,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6588,0 +8039,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6593,0 +8048,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6598,0 +8057,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6618,1 +8081,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6626,1 +8089,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6634,1 +8097,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6642,1 +8105,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6650,1 +8113,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6675,0 +8138,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6680,0 +8147,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6685,0 +8156,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6690,0 +8165,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6695,0 +8174,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6715,0 +8198,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6719,0 +8206,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6723,0 +8214,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6727,0 +8222,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6731,0 +8230,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6751,1 +8254,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6760,0 +8263,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6765,0 +8272,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6769,1 +8280,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6778,0 +8289,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6798,0 +8313,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6802,0 +8318,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6806,0 +8323,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6810,0 +8328,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6814,0 +8333,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6834,0 +8354,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6839,0 +8360,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6844,0 +8366,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6848,0 +8371,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6853,0 +8377,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6873,0 +8398,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6877,0 +8406,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6881,0 +8414,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6885,0 +8422,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6889,0 +8430,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6909,1 +8454,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6917,1 +8462,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6926,0 +8471,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6930,1 +8479,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6939,0 +8488,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6959,0 +8512,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6963,0 +8517,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6967,0 +8522,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6971,0 +8527,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6975,0 +8532,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6995,0 +8553,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6999,0 +8558,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7004,0 +8564,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7008,0 +8569,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7013,0 +8575,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7033,0 +8596,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7037,0 +8604,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7041,0 +8612,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7045,0 +8620,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7049,0 +8628,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7069,0 +8652,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7073,0 +8660,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7078,0 +8669,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7082,0 +8677,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7087,0 +8686,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7107,1 +8710,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7115,1 +8718,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7123,1 +8726,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7131,1 +8734,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7139,1 +8742,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7163,0 +8766,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7167,0 +8774,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7172,0 +8783,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7176,0 +8791,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7181,0 +8800,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7201,0 +8824,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7205,0 +8832,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7209,0 +8840,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7213,0 +8848,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7217,0 +8856,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7237,1 +8880,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7245,1 +8888,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7253,1 +8896,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7261,1 +8904,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7270,0 +8913,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7290,1 +8937,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7298,1 +8945,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7306,1 +8953,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7314,1 +8961,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7322,1 +8969,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7346,0 +8993,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7350,0 +9001,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7354,0 +9009,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7358,0 +9017,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7363,0 +9026,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 126\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7383,0 +9050,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7387,0 +9058,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7391,0 +9066,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7395,0 +9074,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7399,0 +9082,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7419,1 +9106,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7427,1 +9114,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7435,1 +9122,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7443,1 +9130,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7452,0 +9139,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7472,1 +9163,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7480,1 +9171,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7488,1 +9179,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7496,1 +9187,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7504,1 +9195,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7528,0 +9219,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7532,0 +9227,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7536,0 +9235,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7540,0 +9243,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7545,0 +9252,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 130\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7565,0 +9276,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7569,0 +9284,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7573,0 +9292,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7577,0 +9300,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7581,0 +9308,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7601,1 +9332,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7609,1 +9340,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7617,1 +9348,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7625,1 +9356,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7633,1 +9364,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7657,1 +9388,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7665,1 +9396,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7673,1 +9404,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7681,1 +9412,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7689,1 +9420,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7713,0 +9444,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7717,0 +9452,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7721,0 +9460,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7725,0 +9468,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7729,0 +9476,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7749,0 +9500,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7753,0 +9508,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7757,0 +9516,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7761,0 +9524,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7765,0 +9532,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7785,1 +9556,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7793,1 +9564,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7801,1 +9572,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7809,1 +9580,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7817,0 +9588,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7837,0 +9612,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7841,1 +9620,1 @@\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   Expect alignment.\n@@ -7843,1 +9622,9 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n@@ -7849,0 +9636,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7853,0 +9644,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7873,1 +9668,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7881,1 +9676,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7889,1 +9684,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7897,1 +9692,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7905,1 +9700,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7928,0 +9723,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7931,0 +9730,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7934,0 +9737,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7937,0 +9744,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7940,0 +9751,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7960,1 +9775,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7968,1 +9783,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7976,1 +9791,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7984,1 +9799,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7992,1 +9807,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8015,0 +9830,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8018,0 +9837,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8021,0 +9844,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8024,0 +9851,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8027,0 +9858,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8047,1 +9882,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8055,1 +9890,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8063,1 +9898,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8071,1 +9906,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8079,1 +9914,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8102,0 +9937,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8105,0 +9944,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8108,0 +9951,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8111,0 +9958,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8114,0 +9965,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8134,0 +9989,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8138,0 +9994,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8142,0 +9999,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8146,0 +10004,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8150,0 +10009,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8169,1 +10029,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8171,0 +10031,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8174,1 +10035,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8176,0 +10037,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8179,1 +10041,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8181,0 +10043,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8184,1 +10047,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8186,0 +10049,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8189,1 +10053,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8191,0 +10055,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8211,1 +10076,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8219,1 +10084,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8227,1 +10092,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8235,1 +10100,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8243,1 +10108,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8268,0 +10133,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8273,0 +10142,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8278,0 +10151,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8283,0 +10160,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8288,0 +10169,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8308,0 +10193,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8312,0 +10201,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8316,0 +10209,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8320,0 +10217,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8324,0 +10225,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8345,0 +10250,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8350,0 +10259,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8355,0 +10268,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8360,0 +10277,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8365,0 +10286,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8385,1 +10310,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8393,1 +10318,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8401,1 +10326,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8409,1 +10334,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8417,1 +10342,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8442,0 +10367,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8447,0 +10376,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8452,0 +10385,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8457,0 +10394,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8462,0 +10403,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8482,0 +10427,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8486,0 +10435,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8490,0 +10443,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8494,0 +10451,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8498,0 +10459,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8518,1 +10483,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8527,0 +10492,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8532,0 +10501,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8536,1 +10509,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8545,0 +10518,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8565,1 +10542,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8573,1 +10550,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8581,1 +10558,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8589,1 +10566,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8597,1 +10574,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8621,0 +10598,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8626,0 +10607,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8631,0 +10616,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8635,0 +10624,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8640,0 +10633,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8660,0 +10657,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8664,0 +10662,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8668,0 +10667,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8672,0 +10672,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8676,0 +10677,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8696,0 +10698,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8701,0 +10704,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8706,0 +10710,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8710,0 +10715,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8715,0 +10721,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8735,1 +10742,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8743,1 +10750,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8751,1 +10758,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8759,1 +10766,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8767,1 +10774,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8791,0 +10798,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8796,0 +10807,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8801,0 +10816,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8805,0 +10824,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8810,0 +10833,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8830,0 +10857,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8834,0 +10865,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8838,0 +10873,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8842,0 +10881,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8846,0 +10889,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8866,1 +10913,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8874,1 +10921,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8883,0 +10930,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8887,1 +10938,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8896,0 +10947,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8916,1 +10971,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8924,1 +10979,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8932,1 +10987,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8940,1 +10995,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8948,1 +11003,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8972,0 +11027,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8976,0 +11035,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8981,0 +11044,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 63\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8985,0 +11052,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8990,0 +11061,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 63\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9010,0 +11085,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9014,0 +11093,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9018,0 +11101,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9022,0 +11109,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9026,0 +11117,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9046,1 +11141,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9054,1 +11149,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9062,1 +11157,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9070,1 +11165,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9079,0 +11174,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9099,1 +11198,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9107,1 +11206,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9115,1 +11214,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9123,1 +11222,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9131,1 +11230,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9155,0 +11254,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9159,0 +11262,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9163,0 +11270,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9167,0 +11278,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9172,0 +11287,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 65\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9192,0 +11311,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9196,0 +11319,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9200,0 +11327,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9204,0 +11335,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9208,0 +11343,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9228,1 +11367,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9236,1 +11375,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9244,1 +11383,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9252,1 +11391,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9261,0 +11400,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9281,1 +11424,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9289,1 +11432,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9297,1 +11440,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9305,1 +11448,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9313,1 +11456,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9337,0 +11480,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9341,0 +11488,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9345,0 +11496,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9349,0 +11504,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9354,0 +11513,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 129\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9374,0 +11537,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9378,0 +11545,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9382,0 +11553,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9386,0 +11561,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9390,0 +11569,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9410,1 +11593,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9418,1 +11601,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9426,1 +11609,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9434,1 +11617,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9443,0 +11626,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 192\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9463,0 +11650,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9467,0 +11658,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9471,0 +11666,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9475,1 +11674,1 @@\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n+    \/\/   Expect alignment.\n@@ -9477,1 +11676,9 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n@@ -9499,1 +11706,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9507,1 +11714,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9515,1 +11722,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9523,1 +11730,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9531,1 +11738,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9554,0 +11761,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9557,0 +11768,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9560,0 +11775,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9563,0 +11782,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9566,0 +11789,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9586,0 +11813,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9590,0 +11821,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9594,0 +11829,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9598,0 +11837,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9602,0 +11845,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9621,1 +11868,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9626,1 +11877,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9631,1 +11886,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9636,1 +11895,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9641,1 +11904,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9663,1 +11930,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9671,1 +11938,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9679,1 +11946,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9687,1 +11954,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9695,1 +11962,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9720,0 +11987,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9725,0 +11996,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9730,0 +12005,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9735,0 +12014,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9740,0 +12023,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9760,0 +12047,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9764,0 +12055,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9768,0 +12063,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9772,0 +12071,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9776,0 +12079,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9796,1 +12103,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9805,0 +12112,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9810,0 +12121,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9814,1 +12129,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9823,0 +12138,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9843,1 +12162,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9851,1 +12170,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9859,1 +12178,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9867,1 +12186,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9875,1 +12194,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9899,0 +12218,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9904,0 +12227,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9909,0 +12236,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9913,0 +12244,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9918,0 +12253,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9938,0 +12277,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9942,0 +12285,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9946,0 +12293,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9950,0 +12301,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9954,0 +12309,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9974,1 +12333,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9982,1 +12341,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9991,0 +12350,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9995,1 +12358,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10004,0 +12367,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10024,0 +12391,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10028,0 +12399,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10032,0 +12407,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10036,0 +12415,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10040,0 +12423,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10060,0 +12447,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10064,0 +12455,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10069,0 +12464,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10073,0 +12472,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10078,0 +12481,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10098,0 +12505,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10102,0 +12513,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10106,0 +12521,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10110,0 +12529,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10114,0 +12537,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10134,1 +12561,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10142,1 +12569,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10150,1 +12577,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10158,1 +12585,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10167,0 +12594,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10187,0 +12618,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10191,0 +12626,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10195,0 +12634,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10199,0 +12642,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10203,0 +12650,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10223,0 +12674,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10227,0 +12682,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10231,0 +12690,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10235,0 +12698,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10240,0 +12707,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10260,0 +12731,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10264,0 +12739,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10268,0 +12747,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10272,0 +12755,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10276,0 +12763,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10296,1 +12787,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10304,0 +12795,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10308,0 +12803,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10312,1 +12811,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10321,0 +12820,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10341,1 +12844,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10349,1 +12852,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10357,1 +12860,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10365,1 +12868,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10373,1 +12876,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10397,0 +12900,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10401,0 +12908,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10405,0 +12916,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10409,0 +12924,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10414,0 +12933,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 124\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10434,0 +12957,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10438,0 +12965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10442,0 +12973,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10446,0 +12981,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10450,0 +12989,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10470,1 +13013,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10478,1 +13021,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10486,1 +13029,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10494,1 +13037,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10503,0 +13046,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10523,1 +13070,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10531,1 +13078,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10539,1 +13086,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10547,1 +13094,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10555,1 +13102,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10579,0 +13126,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10583,0 +13134,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10587,0 +13142,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10591,0 +13150,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10596,0 +13159,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 252\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10616,0 +13183,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10620,0 +13191,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10624,0 +13199,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10628,0 +13207,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10632,0 +13215,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10652,1 +13239,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10660,1 +13247,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10668,1 +13255,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10676,1 +13263,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10684,1 +13271,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10708,1 +13295,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10716,1 +13303,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10724,1 +13311,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10732,1 +13319,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10740,1 +13327,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10764,0 +13351,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10768,0 +13359,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10772,0 +13367,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10776,0 +13375,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10780,0 +13383,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10800,0 +13407,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10804,0 +13415,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10808,0 +13423,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10812,0 +13431,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10816,0 +13439,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10836,1 +13463,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10844,1 +13471,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10852,1 +13479,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10860,1 +13487,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10868,1 +13495,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10892,1 +13519,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10900,1 +13527,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10908,1 +13535,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10916,1 +13543,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10924,1 +13551,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10948,0 +13575,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10952,0 +13583,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10956,0 +13591,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10960,0 +13599,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10964,0 +13607,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10984,0 +13631,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10988,0 +13639,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10992,0 +13647,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10996,0 +13655,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11000,0 +13663,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11020,1 +13687,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11028,1 +13695,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11036,1 +13703,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11044,1 +13711,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11052,1 +13719,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11076,0 +13743,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11080,0 +13751,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11084,0 +13759,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11088,0 +13767,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11092,0 +13775,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11112,3 +13799,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11120,3 +13807,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11128,3 +13815,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11136,3 +13823,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11144,3 +13831,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11167,0 +13854,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11170,0 +13859,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11173,0 +13864,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11176,0 +13869,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11179,0 +13874,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11199,0 +13896,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11203,0 +13904,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11207,0 +13912,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11211,0 +13920,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11215,0 +13928,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11235,1 +13952,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11242,1 +13959,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -11247,1 +13968,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -11253,1 +13978,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11260,1 +13985,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -11282,3 +14011,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11290,3 +14019,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11298,3 +14027,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11306,3 +14035,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11314,3 +14043,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11338,0 +14067,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11343,0 +14076,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11348,0 +14085,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11352,0 +14093,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11357,0 +14102,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11377,0 +14126,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11381,0 +14134,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11385,0 +14142,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11389,0 +14150,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11393,0 +14158,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11413,1 +14182,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11421,1 +14190,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11430,0 +14199,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11434,1 +14207,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11443,0 +14216,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11463,3 +14240,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11471,3 +14248,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11479,3 +14256,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11487,3 +14264,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11495,3 +14272,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11519,0 +14296,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11523,0 +14304,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11528,0 +14313,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11532,0 +14321,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11537,0 +14330,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11557,0 +14354,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11561,0 +14362,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11565,0 +14370,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11569,0 +14378,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11573,0 +14386,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11593,1 +14410,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11601,1 +14418,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11609,1 +14426,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11617,1 +14434,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11626,0 +14443,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11646,0 +14467,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11650,0 +14475,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11654,0 +14483,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11658,0 +14491,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11662,0 +14499,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11682,1 +14523,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11690,0 +14531,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11694,0 +14539,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11698,1 +14547,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11707,0 +14556,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11727,0 +14580,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11731,0 +14588,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11735,0 +14596,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11739,0 +14604,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11743,0 +14612,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11763,1 +14636,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11771,1 +14644,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11779,1 +14652,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11787,1 +14660,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11796,0 +14669,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11816,0 +14693,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11820,0 +14701,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11824,0 +14709,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11828,0 +14717,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11832,0 +14725,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11852,1 +14749,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11860,0 +14757,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11864,0 +14765,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11868,1 +14773,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11877,0 +14782,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11897,0 +14806,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11901,0 +14814,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11905,0 +14822,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11909,0 +14830,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11913,0 +14838,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11933,1 +14862,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11941,1 +14870,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11949,0 +14878,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11953,1 +14886,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11962,0 +14895,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11982,3 +14919,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11990,3 +14927,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11998,3 +14935,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12006,3 +14943,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12014,3 +14951,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12038,0 +14975,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12042,0 +14983,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12046,0 +14991,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12050,0 +14999,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12055,0 +15008,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12075,0 +15032,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12079,0 +15040,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12083,0 +15048,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12087,0 +15056,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12091,0 +15064,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12111,1 +15088,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12119,1 +15096,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12127,1 +15104,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12135,1 +15112,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12143,1 +15120,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12167,3 +15144,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12175,3 +15152,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12183,3 +15160,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12191,3 +15168,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12199,3 +15176,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12223,0 +15200,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12227,0 +15208,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12231,0 +15216,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12235,0 +15224,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12239,0 +15232,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12259,0 +15256,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12263,0 +15264,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12267,0 +15272,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12271,0 +15280,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12275,0 +15288,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12295,1 +15312,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12303,1 +15320,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12311,1 +15328,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12319,1 +15336,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12327,1 +15344,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12351,3 +15368,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12359,3 +15376,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12367,3 +15384,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12375,3 +15392,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12383,3 +15400,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12407,0 +15424,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12411,0 +15432,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12415,0 +15440,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12419,0 +15448,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12423,0 +15456,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12443,0 +15480,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12447,0 +15488,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12451,0 +15496,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12455,0 +15504,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12459,0 +15512,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12479,1 +15536,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12487,1 +15544,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12495,1 +15552,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12503,1 +15560,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12511,1 +15568,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12535,3 +15592,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12543,3 +15600,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12551,3 +15608,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12559,3 +15616,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12567,3 +15624,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12591,0 +15648,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12595,0 +15656,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12599,0 +15664,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12603,0 +15672,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12607,0 +15680,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12627,0 +15704,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12631,0 +15712,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12635,0 +15720,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12639,0 +15728,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12643,0 +15736,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12663,1 +15760,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12671,1 +15768,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12679,1 +15776,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12687,1 +15784,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12695,1 +15792,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":3793,"deletions":696,"binary":false,"changes":4489,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @requires vm.cpu.features ~= \".*avx2.*\"\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMovingLoadBeforeStore.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\"\n@@ -78,1 +77,2 @@\n-    @IR(applyIfCPUFeature = {\"sse2\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"true\"},\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -80,7 +80,5 @@\n-    @IR(applyIfCPUFeature = {\"sse2\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"false\"},\n-        failOn = {IRNode.MUL_ADD_VS2VI}, \/\/ Can only pack LoadS if UseUnalignedLoadStores is true (default if sse4.2)\n-        counts = {IRNode.MUL_ADD_S2I, \"> 0\"})\n-    @IR(applyIfCPUFeature = {\"asimd\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n-            counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n-    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"true\"},\n-            counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8257531\n+ * @bug 8257531 8310190\n@@ -29,11 +29,2 @@\n- *\n- * @requires vm.flagless\n- * @requires vm.compiler2.enabled & vm.debug == true\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n- *\n- * @run driver compiler.vectorization.TestBufferVectorization array\n- * @run driver compiler.vectorization.TestBufferVectorization arrayOffset\n- * @run driver compiler.vectorization.TestBufferVectorization buffer\n- * @run driver compiler.vectorization.TestBufferVectorization bufferHeap\n- * @run driver compiler.vectorization.TestBufferVectorization bufferDirect\n- * @run driver compiler.vectorization.TestBufferVectorization arrayView\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.vectorization.TestBufferVectorization\n@@ -44,0 +35,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -51,4 +44,0 @@\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n@@ -56,6 +45,2 @@\n-    final static int N = 500;\n-    final static int ITER = 1000;\n-    final static IntBuffer buffer = IntBuffer.allocate(N);\n-    final static int offset = buffer.arrayOffset();\n-    final static IntBuffer heap_buffer_byte_to_int = ByteBuffer.allocate(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n-    final static IntBuffer direct_buffer_byte_to_int = ByteBuffer.allocateDirect(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+    final static int N = 1024*16;\n+    static int offset = 0;\n@@ -63,1 +48,0 @@\n-    final static String arch = System.getProperty(\"os.arch\");\n@@ -65,4 +49,2 @@\n-    interface Test {\n-        void init();\n-        void run();\n-        void verify();\n+    public static void main(String[] args) {\n+        TestFramework.run();\n@@ -71,2 +53,3 @@\n-    static class TestArray implements Test {\n-        final int[] array = new int[N];\n+    @Run(test = \"testArray\")\n+    public static void runArray() {\n+        int[] array = new int[N];\n@@ -74,4 +57,2 @@\n-        public void init() {\n-            for (int k = 0; k < array.length; k++) {\n-                array[k] = k;\n-            }\n+        for (int k = 0; k < array.length; k++) {\n+            array[k] = k;\n@@ -80,3 +61,5 @@\n-        public void run() {\n-            for(int k = 0; k < array.length; k++) {\n-                array[k] += 1;\n+        testArray(array);\n+\n+        for(int k = 0; k < array.length; k++) {\n+            if (array[k] != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: array[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n@@ -85,0 +68,1 @@\n+    }\n@@ -86,8 +70,9 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            for(int k = 0; k < array.length; k++) {\n-                if (array[k] != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: array[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n-                }\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArray(int[] array) {\n+        for(int k = 0; k < array.length; k++) {\n+            array[k] += 1;\n@@ -97,3 +82,4 @@\n-    static class TestArrayOffset implements Test {\n-        final int offset;\n-        final int[] array = new int[N];\n+    @Run(test = \"testArrayOffset\")\n+    public static void runArrayOffset() {\n+        \/\/ Moving offset between 0..255\n+        offset = (offset + 1) % 256;\n@@ -101,3 +87,1 @@\n-        public TestArrayOffset(int off) {\n-            offset = off;\n-        }\n+        int[] array = new int[N];\n@@ -105,4 +89,2 @@\n-        public void init() {\n-            for (int k = 0; k < array.length; k++) {\n-                array[k] = k;\n-            }\n+        for (int k = 0; k < array.length; k++) {\n+            array[k] = k;\n@@ -111,6 +93,1 @@\n-        public void run() {\n-            int l = array.length - offset;\n-            for(int k = 0; k < l; k++) {\n-                array[k + offset] += 1;\n-            }\n-        }\n+        testArrayOffset(array, offset);\n@@ -118,8 +95,4 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            int l = array.length - offset;\n-            for(int k = 0; k < l; k++) {\n-                if (array[k] != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n-                }\n+        int l = array.length - offset;\n+        for(int k = 0; k < offset; k++) {\n+            if (array[k] != k) {\n+                throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n@@ -127,4 +100,4 @@\n-            for(int k = l; k < array.length; k++) {\n-                if (array[k] != k) {\n-                    throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + k);\n-                }\n+        }\n+        for(int k = offset; k < array.length; k++) {\n+            if (array[k] != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + k);\n@@ -135,11 +108,10 @@\n-    static class TestBuffer implements Test {\n-        final IntBuffer buffer;\n-\n-        public TestBuffer(IntBuffer buf) {\n-            buffer = buf;\n-        }\n-\n-        public void init() {\n-            for (int k = 0; k < buffer.limit(); k++) {\n-                buffer.put(k, k);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArrayOffset(int[] array, int offset) {\n+        int l = array.length - offset;\n+        for(int k = 0; k < l; k++) {\n+            array[k + offset] += 1;\n@@ -147,0 +119,1 @@\n+    }\n@@ -148,5 +121,7 @@\n-        public void run() {\n-            for (int k = 0; k < buffer.limit(); k++) {\n-                buffer.put(k, buffer.get(k) + 1);\n-            }\n-        }\n+    @Run(test = \"testBuffer\")\n+    public static void runBuffer() {\n+        IntBuffer buffer = IntBuffer.allocate(N);\n+        initBuffer(buffer);\n+        testBuffer(buffer);\n+        verifyBuffer(buffer);\n+    }\n@@ -154,8 +129,9 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            for(int k = 0; k < buffer.limit(); k++) {\n-                if (buffer.get(k) != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: buffer.get(\" + k + \"): \" + buffer.get(k) + \" != \" + (k + 1));\n-                }\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testBuffer(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -165,2 +141,7 @@\n-    static class TestArrayView implements Test {\n-        final byte[] b_arr = new byte[N * Integer.BYTES];\n+    @Run(test = \"testBufferHeap\")\n+    public static void runBufferHeap() {\n+        IntBuffer buffer = ByteBuffer.allocate(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+        initBuffer(buffer);\n+        testBufferHeap(buffer);\n+        verifyBuffer(buffer);\n+    }\n@@ -168,4 +149,18 @@\n-        public void init() {\n-            for (int k = 0; k < N; k++) {\n-                VH_arr_view.set(b_arr, k, k);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.STORE_VECTOR,                          \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ VECTOR_SIZE_ANY: Unrolling does not always seem to go far enough to reach maximum vector size.\n+    \/\/                  This looks like a BUG.\n+    \/\/ AlignVector: Buffer get\/put have an invariant that is in bytes (LoadL in ByteBufferAsIntBufferL::byteOffset).\n+    \/\/              This makes sense: we are accessing a byte buffer. But to be able to align the 4 byte ints,\n+    \/\/              we would require to know that the invariant is a multiple of 4. Without that, we cannot\n+    \/\/              guarantee alignment by adjusting the limit of the pre-loop with a stride of 4 bytes.\n+    \/\/ 64-bit: bufferHeap uses Long type for memory accesses which are not vectorized in 32-bit VM\n+    public static void testBufferHeap(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -173,0 +168,1 @@\n+    }\n@@ -174,5 +170,14 @@\n-        public void run() {\n-            for (int k = 0; k < b_arr.length; k += 4) {\n-                int v = (int) VH_arr_view.get(b_arr, k);\n-                VH_arr_view.set(b_arr, k, v + 1);\n-            }\n+    @Run(test = \"testBufferDirect\")\n+    public static void runBufferDirect() {\n+        IntBuffer buffer = ByteBuffer.allocateDirect(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+        initBuffer(buffer);\n+        testBufferDirect(buffer);\n+        verifyBuffer(buffer);\n+    }\n+\n+    @Test\n+    \/\/ bufferDirect uses Unsafe memory accesses which are not vectorized currently\n+    \/\/ We find a CastX2P in pointer analysis (VPointer)\n+    public static void testBufferDirect(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -180,0 +185,1 @@\n+    }\n@@ -181,14 +187,3 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            \/\/ Save initial INT values\n-            final int[] i_arr = new int[N];\n-            for (int k = 0; k < i_arr.length; k++) {\n-                i_arr[k] = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n-            }\n-            run();  \/\/ run compiled code\n-            for (int k = 0; k < i_arr.length; k++) {\n-                int v = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n-                if (v != (i_arr[k] + 1)) {\n-                    throw new RuntimeException(\" Invalid result: VH_arr_view.get(b_arr, \" + (k * Integer.BYTES) + \"): \" + v + \" != \" + (i_arr[k] + 1));\n-                }\n-            }\n+    public static void initBuffer(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, k);\n@@ -198,19 +193,4 @@\n-    public static void main(String[] args) {\n-        if (args.length == 0) {\n-            throw new RuntimeException(\" Missing test name: array, arrayOffset, buffer, bufferHeap, bufferDirect, arrayView\");\n-        } else if (args.length == 1) {\n-            verify_vectors(args[0]);\n-        } else {\n-            Test te = switch (args[0]) {\n-                case \"array\" -> new TestArray();\n-                case \"arrayOffset\" -> new TestArrayOffset(offset);\n-                case \"buffer\" -> new TestBuffer(buffer);\n-                case \"bufferHeap\" -> new TestBuffer(heap_buffer_byte_to_int);\n-                case \"bufferDirect\" -> new TestBuffer(direct_buffer_byte_to_int);\n-                case \"arrayView\" -> new TestArrayView();\n-                default -> throw new RuntimeException(\" Unknown test: \" + args[0]);\n-            };\n-\n-            te.init();\n-            for (int i = 0; i < ITER; i++) {\n-                te.run();\n+    public static void verifyBuffer(IntBuffer buffer) {\n+        for(int k = 0; k < buffer.limit(); k++) {\n+            if (buffer.get(k) != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: buffer.get(\" + k + \"): \" + buffer.get(k) + \" != \" + (k + 1));\n@@ -218,1 +198,0 @@\n-            te.verify();\n@@ -220,1 +199,0 @@\n-\n@@ -223,13 +201,3 @@\n-    static void verify_vectors(String testName) {\n-        ProcessBuilder pb;\n-        OutputAnalyzer out;\n-        try {\n-            pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:-BackgroundCompilation\",\n-                                                                  \"-XX:+TraceNewVectors\",\n-                                                                  \"compiler.vectorization.TestBufferVectorization\",\n-                                                                  testName,\n-                                                                  \"run\");\n-            out = new OutputAnalyzer(pb.start());\n-        } catch (Exception e) {\n-            throw new RuntimeException(\" Exception launching Java process: \" + e);\n-        }\n+    @Run(test = \"testArrayView\")\n+    public static void runArrayView() {\n+        byte[] b_arr = new byte[N * Integer.BYTES];\n@@ -237,1 +205,3 @@\n-        out.shouldHaveExitValue(0);\n+        for (int k = 0; k < N; k++) {\n+            VH_arr_view.set(b_arr, k, k);\n+        }\n@@ -239,2 +209,4 @@\n-        if (testName.equals(\"bufferDirect\")) {\n-            return; \/\/ bufferDirect uses Unsafe memory accesses which are not vectorized currently\n+        \/\/ Save initial INT values\n+        int[] i_arr = new int[N];\n+        for (int k = 0; k < i_arr.length; k++) {\n+            i_arr[k] = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n@@ -242,0 +214,1 @@\n+        testArrayView(b_arr);\n@@ -243,2 +216,5 @@\n-        if (testName.equals(\"bufferHeap\") && (Platform.is32bit())) {\n-            return; \/\/ bufferHeap uses Long type for memory accesses which are not vectorized in 32-bit VM\n+        for (int k = 0; k < i_arr.length; k++) {\n+            int v = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n+            if (v != (i_arr[k] + 1)) {\n+                throw new RuntimeException(\" Invalid result: VH_arr_view.get(b_arr, \" + (k * Integer.BYTES) + \"): \" + v + \" != \" + (i_arr[k] + 1));\n+            }\n@@ -246,0 +222,1 @@\n+    }\n@@ -247,4 +224,11 @@\n-        out.shouldContain(\"Replicate\");\n-        out.shouldContain(\"LoadVector\");\n-        out.shouldContain(\"AddVI\");\n-        out.shouldContain(\"StoreVector\");\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArrayView(byte[] b_arr) {\n+        for (int k = 0; k < b_arr.length; k += 4) {\n+            int v = (int) VH_arr_view.get(b_arr, k);\n+            VH_arr_view.set(b_arr, k, v + 1);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestBufferVectorization.java","additions":149,"deletions":165,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -120,1 +120,3 @@\n-            \"current number of tasks\"\n+            \"current number of tasks\",\n+            \"rss_usage_in_bytes\",\n+            \"cache_usage_in_bytes\"\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMisc.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -78,1 +78,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/TestAgeOutput.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+    OutputAnalyzer output = ProcessTools.executeTestJava(\n@@ -45,1 +45,0 @@\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocateHeapAt.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+    OutputAnalyzer output = ProcessTools.executeTestJava(\n@@ -54,1 +54,0 @@\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocateHeapAtError.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,2 +63,1 @@\n-      ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(flags);\n-      OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+      OutputAnalyzer output = ProcessTools.executeTestJava(flags);\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocateHeapAtMultiple.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -50,1 +50,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/TestCardTablePageCommits.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -70,1 +70,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/TestNumWorkerOutput.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,3 +51,1 @@\n-        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(testArguments);\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeTestJava(testArguments);\n","filename":"test\/hotspot\/jtreg\/gc\/TestPLABAdaptToMinTLABSize.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer analyzer = ProcessTools.executeLimitedTestJava(\n@@ -104,1 +104,0 @@\n-        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/TestSmallHeap.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+    OutputAnalyzer output = ProcessTools.executeTestJava(\n@@ -46,1 +46,0 @@\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/TestVerifyDuringStartup.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,2 +60,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(vmOpts);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/TestVerifySilently.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(vmOpts);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/TestVerifySubSet.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -84,0 +85,16 @@\n+\n+    static public OutputAnalyzer executeLimitedTestJava(List<String> arguments) throws Exception {\n+        return executeLimitedTestJava(arguments.toArray(String[]::new));\n+    }\n+\n+    static public OutputAnalyzer executeLimitedTestJava(String... arguments) throws Exception {\n+        return ProcessTools.executeLimitedTestJava(withDefaults(arguments));\n+    }\n+\n+    static public OutputAnalyzer executeTestJava(List<String> arguments) throws Exception {\n+        return executeTestJava(arguments.toArray(String[]::new));\n+    }\n+\n+    static public OutputAnalyzer executeTestJava(String... arguments) throws Exception {\n+        return ProcessTools.executeTestJava(withDefaults(arguments));\n+    }\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/GCArguments.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(\n+        OutputAnalyzer output = GCArguments.executeTestJava(\n@@ -71,2 +71,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestAggressiveHeap.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,3 +44,4 @@\n-            OutputAnalyzer output = runJava(\"-XX:CompressedClassSpaceSize=1g\",\n-                                            \"-XX:-UseCompressedClassPointers\",\n-                                            \"-version\");\n+            OutputAnalyzer output = GCArguments.executeTestJava(\n+                \"-XX:CompressedClassSpaceSize=1g\",\n+                \"-XX:-UseCompressedClassPointers\",\n+                \"-version\");\n@@ -52,5 +53,0 @@\n-\n-    private static OutputAnalyzer runJava(String ... args) throws Exception {\n-        ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(args);\n-        return new OutputAnalyzer(pb.start());\n-    }\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestCompressedClassFlags.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,8 +43,7 @@\n-        ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(\"-XX:-UseSerialGC\",\n-                                                                     \"-XX:-UseParallelGC\",\n-                                                                     \"-XX:-UseG1GC\",\n-                                                                     \"-XX:-UseZGC\",\n-                                                                     \"-XX:+UnlockExperimentalVMOptions\",\n-                                                                     \"-XX:-UseShenandoahGC\",\n-                                                                     \"-version\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = GCArguments.executeTestJava(\"-XX:-UseSerialGC\",\n+                                                            \"-XX:-UseParallelGC\",\n+                                                            \"-XX:-UseG1GC\",\n+                                                            \"-XX:-UseZGC\",\n+                                                            \"-XX:+UnlockExperimentalVMOptions\",\n+                                                            \"-XX:-UseShenandoahGC\",\n+                                                            \"-version\");\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestDisableDefaultGC.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -81,2 +81,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(vmOpts);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeTestJava(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1ConcMarkStepDurationMillis.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(vmOpts);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeTestJava(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1ConcRefinementThreads.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,2 +56,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(flagList);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeTestJava(flagList);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1HeapRegionSize.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,2 +66,1 @@\n-        ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(\"-XX:+UseG1GC\", flag, \"-version\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = GCArguments.executeTestJava(\"-XX:+UseG1GC\", flag, \"-version\");\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1PercentageOptions.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,2 +51,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(flagList);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeTestJava(flagList);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1RemSetFlags.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(\n+    OutputAnalyzer output = GCArguments.executeTestJava(\n@@ -55,1 +55,0 @@\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestHeapFreeRatio.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(\n+    OutputAnalyzer output = GCArguments.executeTestJava(\n@@ -51,1 +51,0 @@\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -61,1 +60,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(\n+    OutputAnalyzer output = GCArguments.executeTestJava(\n@@ -68,1 +67,0 @@\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestInitialTenuringThreshold.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(gcflag,\n+    OutputAnalyzer output = GCArguments.executeTestJava(gcflag,\n@@ -120,1 +120,0 @@\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -211,2 +210,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(finalargs.toArray(String[]::new));\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeTestJava(finalargs.toArray(String[]::new));\n@@ -311,2 +309,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(flags);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeTestJava(flags);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMaxHeapSizeTools.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -101,2 +101,1 @@\n-        ProcessBuilder procBuilder = GCArguments.createLimitedTestJavaProcessBuilder(vmOptions);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());\n+        OutputAnalyzer analyzer = GCArguments.executeLimitedTestJava(vmOptions);\n@@ -126,2 +125,1 @@\n-        ProcessBuilder procBuilder = GCArguments.createLimitedTestJavaProcessBuilder(vmOptions);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());\n+        OutputAnalyzer analyzer = GCArguments.executeLimitedTestJava(vmOptions);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMaxMinHeapFreeRatioFlags.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -98,2 +98,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(finalargs);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeTestJava(finalargs);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMaxNewSize.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-    ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(args);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeLimitedTestJava(args);\n@@ -87,2 +86,1 @@\n-    ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(args);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeLimitedTestJava(args);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMaxRAMFlags.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,2 +105,1 @@\n-        ProcessBuilder procBuilder = GCArguments.createLimitedTestJavaProcessBuilder(vmOptions);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());\n+        OutputAnalyzer analyzer = GCArguments.executeLimitedTestJava(vmOptions);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMinAndInitialSurvivorRatioFlags.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,2 +85,1 @@\n-        ProcessBuilder procBuilder = GCArguments.createLimitedTestJavaProcessBuilder(vmOptions);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());\n+        OutputAnalyzer analyzer = GCArguments.executeLimitedTestJava(vmOptions);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestNewRatioFlag.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-        OutputAnalyzer analyzer = startVM(options, newSize, maxNewSize, heapSize, maxHeapSize, expectedNewSize, expectedMaxNewSize);\n+        OutputAnalyzer analyzer = executeLimitedTestJava(options, newSize, maxNewSize, heapSize, maxHeapSize, expectedNewSize, expectedMaxNewSize);\n@@ -147,1 +147,1 @@\n-    private static OutputAnalyzer startVM(LinkedList<String> options,\n+    private static OutputAnalyzer executeLimitedTestJava(LinkedList<String> options,\n@@ -169,3 +169,1 @@\n-        ProcessBuilder procBuilder = GCArguments.createLimitedTestJavaProcessBuilder(vmOptions);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());\n-        return analyzer;\n+        return GCArguments.executeLimitedTestJava(vmOptions);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestNewSizeFlags.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -68,8 +68,7 @@\n-    ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(\"-XX:+UseSerialGC\",\n-                                                                        \"-Xms96M\",\n-                                                                        \"-Xmx128M\",\n-                                                                        \"-XX:NewRatio=2\",\n-                                                                        \"-Xlog:gc+heap+ergo=debug\",\n-                                                                        \"-XX:NewSizeThreadIncrease=\"+expectedValue,\n-                                                                        GCTest.class.getName());\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeLimitedTestJava(\"-XX:+UseSerialGC\",\n+                                                               \"-Xms96M\",\n+                                                               \"-Xmx128M\",\n+                                                               \"-XX:NewRatio=2\",\n+                                                               \"-Xlog:gc+heap+ergo=debug\",\n+                                                               \"-XX:NewSizeThreadIncrease=\"+expectedValue,\n+                                                               GCTest.class.getName());\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestNewSizeThreadIncrease.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -164,2 +164,1 @@\n-    ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(vmOpts);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeLimitedTestJava(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestObjectTenuringFlags.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(\n+    OutputAnalyzer output = GCArguments.executeLimitedTestJava(\n@@ -62,1 +62,0 @@\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -97,1 +96,1 @@\n-      ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(\n+      OutputAnalyzer output = GCArguments.executeLimitedTestJava(\n@@ -102,1 +101,0 @@\n-      OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -127,2 +125,1 @@\n-    ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(flags);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeLimitedTestJava(flags);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelGCThreads.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -80,3 +80,1 @@\n-        ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(result);\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = GCArguments.executeLimitedTestJava(result);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelRefProc.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = GCArguments.executeLimitedTestJava(\n@@ -52,1 +52,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSelectDefaultGC.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    ProcessBuilder pb_enabled = GCArguments.createLimitedTestJavaProcessBuilder(\n+    OutputAnalyzer analyzer = GCArguments.executeLimitedTestJava(\n@@ -70,1 +70,0 @@\n-    OutputAnalyzer analyzer = new OutputAnalyzer(pb_enabled.start());\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSmallInitialHeapWithLargePageAndNUMA.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,2 +90,1 @@\n-        ProcessBuilder procBuilder = GCArguments.createLimitedTestJavaProcessBuilder(vmOptions);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());\n+        OutputAnalyzer analyzer = GCArguments.executeLimitedTestJava(vmOptions);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSurvivorRatioFlag.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -119,2 +119,1 @@\n-        ProcessBuilder procBuilder = GCArguments.createLimitedTestJavaProcessBuilder(vmOptions);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());\n+        OutputAnalyzer analyzer = GCArguments.executeLimitedTestJava(vmOptions);\n@@ -154,2 +153,1 @@\n-        ProcessBuilder procBuilder = GCArguments.createLimitedTestJavaProcessBuilder(vmOptions);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());\n+        OutputAnalyzer analyzer = GCArguments.executeLimitedTestJava(vmOptions);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestTargetSurvivorRatioFlag.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(\n+    OutputAnalyzer outputWithError = GCArguments.executeLimitedTestJava(\n@@ -47,1 +47,0 @@\n-    OutputAnalyzer outputWithError = new OutputAnalyzer(pb.start());\n@@ -53,1 +52,1 @@\n-    pb = GCArguments.createLimitedTestJavaProcessBuilder(\n+    outputWithError = GCArguments.executeLimitedTestJava(\n@@ -57,1 +56,0 @@\n-    outputWithError = new OutputAnalyzer(pb.start());\n@@ -64,1 +62,1 @@\n-    pb = GCArguments.createLimitedTestJavaProcessBuilder(\n+    OutputAnalyzer outputWithNoError = GCArguments.executeLimitedTestJava(\n@@ -68,1 +66,0 @@\n-    OutputAnalyzer outputWithNoError = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUnrecognizedVMOptionsHandling.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -96,2 +96,1 @@\n-    ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(finalargs);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeLimitedTestJava(finalargs);\n@@ -160,2 +159,1 @@\n-    ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(flags);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = GCArguments.executeLimitedTestJava(flags);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsErgoTools.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,3 +62,2 @@\n-    String cmd = ProcessTools.getCommandLine(ProcessTools.createTestJavaProcessBuilder(args.toArray(String[]::new)));\n-    ProcessBuilder pb = new ProcessBuilder(\"sh\", \"-c\", ulimit_prefix + \";\" + cmd);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    String cmd = ProcessTools.getCommandLine(ProcessTools.createTestJavaProcessBuilder(args));\n+    OutputAnalyzer output = ProcessTools.executeProcess(\"sh\", \"-c\", ulimit_prefix + \";\" + cmd);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsFlagsWithUlimit.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(\n+        OutputAnalyzer output = GCArguments.executeTestJava(\n@@ -46,1 +46,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseNUMAInterleaving.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -102,2 +102,1 @@\n-        ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(vmOpts);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer analyzer = GCArguments.executeLimitedTestJava(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestVerifyBeforeAndAfterGCFlags.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+    return ProcessTools.executeLimitedTestJava(\n@@ -60,1 +60,0 @@\n-    return new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/class_unloading\/TestG1ClassUnloadingHWM.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n-    OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer out = ProcessTools.executeLimitedTestJava(args);\n@@ -47,2 +46,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n-    OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer out = ProcessTools.executeLimitedTestJava(args);\n","filename":"test\/hotspot\/jtreg\/gc\/epsilon\/TestDieDefault.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n-    OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer out = ProcessTools.executeLimitedTestJava(args);\n","filename":"test\/hotspot\/jtreg\/gc\/epsilon\/TestDieWithHeapDump.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,2 +42,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n-    OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer out = ProcessTools.executeLimitedTestJava(args);\n@@ -50,2 +49,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n-    OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer out = ProcessTools.executeLimitedTestJava(args);\n","filename":"test\/hotspot\/jtreg\/gc\/epsilon\/TestDieWithOnError.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-    ProcessBuilder pb_enabled = ProcessTools.createLimitedTestJavaProcessBuilder(baseArgs);\n-    verifyDynamicNumberOfGCThreads(new OutputAnalyzer(pb_enabled.start()));\n+    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(baseArgs);\n+    verifyDynamicNumberOfGCThreads(output);\n@@ -79,2 +79,2 @@\n-    pb_enabled = ProcessTools.createLimitedTestJavaProcessBuilder(parRefArgs);\n-    verifyDynamicNumberOfGCThreads(new OutputAnalyzer(pb_enabled.start()));\n+    output = ProcessTools.executeLimitedTestJava(parRefArgs);\n+    verifyDynamicNumberOfGCThreads(output);\n","filename":"test\/hotspot\/jtreg\/gc\/ergonomics\/TestDynamicNumberOfGCThreads.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    ProcessBuilder pb_enabled = ProcessTools.createLimitedTestJavaProcessBuilder(\n+    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -80,1 +80,1 @@\n-    verifyDynamicNumberOfGCThreads(new OutputAnalyzer(pb_enabled.start()), threadName);\n+    verifyDynamicNumberOfGCThreads(output, threadName);\n","filename":"test\/hotspot\/jtreg\/gc\/ergonomics\/TestInitialGCThreadLogging.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(testArguments);\n+    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(testArguments);\n@@ -54,1 +54,0 @@\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/Test2GbHeap.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,9 +46,9 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-Xmx32M\",\n-                                                                             \"-Xmn16M\",\n-                                                                             \"-XX:+G1GCAllocationFailureALot\",\n-                                                                             \"-XX:G1GCAllocationFailureALotCount=100\",\n-                                                                             \"-XX:G1GCAllocationFailureALotInterval=1\",\n-                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                             \"-Xlog:gc\",\n-                                                                             GCTestWithAllocationFailure.class.getName());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-Xmx32M\",\n+                                                                    \"-Xmn16M\",\n+                                                                    \"-XX:+G1GCAllocationFailureALot\",\n+                                                                    \"-XX:G1GCAllocationFailureALotCount=100\",\n+                                                                    \"-XX:G1GCAllocationFailureALotInterval=1\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-Xlog:gc\",\n+                                                                    GCTestWithAllocationFailure.class.getName());\n@@ -56,1 +56,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestAllocationFailure.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -93,2 +93,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegions.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -135,1 +135,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegionsClearMarkBits.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -68,1 +68,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegionsLog.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -105,2 +105,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegionsWithRefs.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(arguments);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(arguments);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1SkipCompaction.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,10 +44,8 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                         \"-Xms128M\",\n-                                                                         \"-Xmx128M\",\n-                                                                         \"-Xmn16M\",\n-                                                                         \"-XX:G1HeapRegionSize=1M\",\n-                                                                         \"-Xlog:gc+phases=trace,gc+humongous=trace\",\n-                                                                         \"-XX:+UnlockExperimentalVMOptions\",\n-                                                                         GCWithHumongousObjectTest.class.getName());\n-\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                \"-Xms128M\",\n+                                                                \"-Xmx128M\",\n+                                                                \"-Xmn16M\",\n+                                                                \"-XX:G1HeapRegionSize=1M\",\n+                                                                \"-Xlog:gc+phases=trace,gc+humongous=trace\",\n+                                                                \"-XX:+UnlockExperimentalVMOptions\",\n+                                                                GCWithHumongousObjectTest.class.getName());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1TraceEagerReclaimHumongousObjects.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -221,3 +221,3 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-Xmx10M\",\n-                                                                             GCTest.class.getName());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-Xmx10M\",\n+                                                                    GCTest.class.getName());\n@@ -225,1 +225,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -229,4 +228,4 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                              \"-Xmx10M\",\n-                                                              \"-Xlog:gc+phases=debug\",\n-                                                              GCTest.class.getName());\n+        output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                     \"-Xmx10M\",\n+                                                     \"-Xlog:gc+phases=debug\",\n+                                                     GCTest.class.getName());\n@@ -234,1 +233,0 @@\n-        output = new OutputAnalyzer(pb.start());\n@@ -237,4 +235,4 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                              \"-Xmx10M\",\n-                                                              \"-Xlog:gc+phases=trace\",\n-                                                              GCTest.class.getName());\n+        output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                     \"-Xmx10M\",\n+                                                     \"-Xlog:gc+phases=trace\",\n+                                                     GCTest.class.getName());\n@@ -242,1 +240,0 @@\n-        output = new OutputAnalyzer(pb.start());\n@@ -256,5 +253,4 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-Xmx10M\",\n-                                                                             \"-Xlog:gc+refine+stats=debug\",\n-                                                                             GCTest.class.getName());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-Xmx10M\",\n+                                                                    \"-Xlog:gc+refine+stats=debug\",\n+                                                                    GCTest.class.getName());\n@@ -275,11 +271,10 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-Xmx32M\",\n-                                                                             \"-Xmn16M\",\n-                                                                             \"-XX:+G1GCAllocationFailureALot\",\n-                                                                             \"-XX:G1GCAllocationFailureALotCount=100\",\n-                                                                             \"-XX:G1GCAllocationFailureALotInterval=1\",\n-                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                             \"-Xlog:gc+phases=debug\",\n-                                                                             GCTestWithAllocationFailure.class.getName());\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-Xmx32M\",\n+                                                                    \"-Xmn16M\",\n+                                                                    \"-XX:+G1GCAllocationFailureALot\",\n+                                                                    \"-XX:G1GCAllocationFailureALotCount=100\",\n+                                                                    \"-XX:G1GCAllocationFailureALotInterval=1\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-Xlog:gc+phases=debug\",\n+                                                                    GCTestWithAllocationFailure.class.getName());\n+\n@@ -289,7 +284,7 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                              \"-Xmx32M\",\n-                                                              \"-Xmn16M\",\n-                                                              \"-Xms32M\",\n-                                                              \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                              \"-Xlog:gc+phases=trace\",\n-                                                              GCTestWithAllocationFailure.class.getName());\n+        output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                     \"-Xmx32M\",\n+                                                     \"-Xmn16M\",\n+                                                     \"-Xms32M\",\n+                                                     \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                     \"-Xlog:gc+phases=trace\",\n+                                                     GCTestWithAllocationFailure.class.getName());\n@@ -297,1 +292,0 @@\n-        output = new OutputAnalyzer(pb.start());\n@@ -308,9 +302,8 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-Xmx10M\",\n-                                                                             \"-Xbootclasspath\/a:.\",\n-                                                                             \"-Xlog:gc*=debug\",\n-                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                             \"-XX:+WhiteBoxAPI\",\n-                                                                             GCTestWithConcurrentStart.class.getName());\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-Xmx10M\",\n+                                                                    \"-Xbootclasspath\/a:.\",\n+                                                                    \"-Xlog:gc*=debug\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                    GCTestWithConcurrentStart.class.getName());\n+\n@@ -322,9 +315,8 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-Xmx10M\",\n-                                                                             \"-Xbootclasspath\/a:.\",\n-                                                                             \"-Xlog:gc+ergo+heap=debug\",\n-                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                             \"-XX:+WhiteBoxAPI\",\n-                                                                             GCTest.class.getName());\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-Xmx10M\",\n+                                                                    \"-Xbootclasspath\/a:.\",\n+                                                                    \"-Xlog:gc+ergo+heap=debug\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                    GCTest.class.getName());\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":48,"deletions":56,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeTestJava(\n@@ -57,1 +57,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousAllocConcurrentStart.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -58,1 +58,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousAllocNearlyFullRegion.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -109,2 +109,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(finalargs);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(finalargs);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousCodeCacheRoots.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -73,1 +73,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousConcurrentStartUndo.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-        ProcessBuilder pb;\n@@ -126,3 +125,1 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(getOpts(heapsize, true));\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(getOpts(heapsize, true));\n@@ -141,1 +138,1 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(getOpts(heapsize, false));\n+        output = ProcessTools.executeLimitedTestJava(getOpts(heapsize, false));\n@@ -143,1 +140,0 @@\n-        output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestLargePageUseForAuxMemory.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-        ProcessBuilder pb;\n@@ -90,6 +89,6 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                              \"-XX:G1HeapRegionSize=\" + regionSize,\n-                                                              \"-Xmx128m\",\n-                                                              \"-Xlog:gc+init,pagesize,gc+heap+coops=debug\",\n-                                                              \"-XX:+UseLargePages\",\n-                                                              \"-version\");\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-XX:G1HeapRegionSize=\" + regionSize,\n+                                                                    \"-Xmx128m\",\n+                                                                    \"-Xlog:gc+init,pagesize,gc+heap+coops=debug\",\n+                                                                    \"-XX:+UseLargePages\",\n+                                                                    \"-version\");\n@@ -97,1 +96,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -103,6 +101,6 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                              \"-XX:G1HeapRegionSize=\" + regionSize,\n-                                                              \"-Xmx128m\",\n-                                                              \"-Xlog:gc+init,pagesize,gc+heap+coops=debug\",\n-                                                              \"-XX:-UseLargePages\",\n-                                                              \"-version\");\n+        output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                     \"-XX:G1HeapRegionSize=\" + regionSize,\n+                                                     \"-Xmx128m\",\n+                                                     \"-Xlog:gc+init,pagesize,gc+heap+coops=debug\",\n+                                                     \"-XX:-UseLargePages\",\n+                                                     \"-version\");\n@@ -110,1 +108,0 @@\n-        output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestLargePageUseForHeap.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -53,3 +53,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(testArguments);\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(testArguments);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestMarkStackSizes.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,3 +112,1 @@\n-        ProcessBuilder procBuilder =  ProcessTools.createLimitedTestJavaProcessBuilder(basicOpts);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());\n-        return analyzer;\n+        return ProcessTools.executeLimitedTestJava(basicOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestMixedGCLiveThreshold.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+    return ProcessTools.executeLimitedTestJava(\n@@ -53,1 +53,0 @@\n-    return new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestOneEdenRegionAfterGC.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(arguments);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(arguments);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestPLABOutput.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,2 +65,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(testArguments);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(testArguments);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestPLABSizeBounds.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,5 +43,5 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-XX:G1PeriodicGCInterval=0\",\n-                                                                             \"-Xlog:gc+init,gc+periodic=debug\",\n-                                                                             \"-Xmx10M\",\n-                                                                             GCTest.class.getName());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-XX:G1PeriodicGCInterval=0\",\n+                                                                    \"-Xlog:gc+init,gc+periodic=debug\",\n+                                                                    \"-Xmx10M\",\n+                                                                    GCTest.class.getName());\n@@ -49,1 +49,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -54,5 +53,5 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                              \"-XX:G1PeriodicGCInterval=100\",\n-                                                              \"-Xlog:gc+init,gc+periodic=debug\",\n-                                                              \"-Xmx10M\",\n-                                                              GCTest.class.getName());\n+        output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                     \"-XX:G1PeriodicGCInterval=100\",\n+                                                     \"-Xlog:gc+init,gc+periodic=debug\",\n+                                                     \"-Xmx10M\",\n+                                                     GCTest.class.getName());\n@@ -60,1 +59,0 @@\n-        output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestPeriodicLogMessages.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(finalargs);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(finalargs);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestPrintRegionRememberedSetInfo.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,8 +47,6 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                         \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                         \"-Xlog:gc+remset+exit=trace\",\n-                                                                         \"-XX:G1ConcRefinementThreads=\" + refinementThreads,\n-                                                                         \"-XX:ParallelGCThreads=\" + workerThreads,\n-                                                                         \"-version\");\n-\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                \"-Xlog:gc+remset+exit=trace\",\n+                                                                \"-XX:G1ConcRefinementThreads=\" + refinementThreads,\n+                                                                \"-XX:ParallelGCThreads=\" + workerThreads,\n+                                                                \"-version\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestRemsetLoggingThreads.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -80,2 +80,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(finalargs);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(finalargs);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestRemsetLoggingTools.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-        ProcessBuilder pb;\n-\n@@ -62,2 +60,2 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(dump_args);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(dump_args);\n+\n@@ -75,2 +73,1 @@\n-            pb = ProcessTools.createLimitedTestJavaProcessBuilder(load_args.toArray(new String[0]));\n-            output = new OutputAnalyzer(pb.start());\n+            output = ProcessTools.executeLimitedTestJava(load_args.toArray(new String[0]));\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestSharedArchiveWithPreTouch.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(opts);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(opts);\n@@ -93,1 +93,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -77,1 +77,0 @@\n-        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkDefragmentedHeap.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,11 +43,10 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xbootclasspath\/a:.\",\n-                                                                             \"-XX:+UseG1GC\",\n-                                                                             \"-XX:+UnlockExperimentalVMOptions\",\n-                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                             \"-XX:+WhiteBoxAPI\",\n-                                                                             \"-XX:G1MixedGCLiveThresholdPercent=20\",\n-                                                                             \"-Xlog:gc+marking=debug,gc+phases=debug,gc+remset+tracking=trace\",\n-                                                                             \"-Xms10M\",\n-                                                                             \"-Xmx10M\",\n-                                                                             GCTest.class.getName());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-Xbootclasspath\/a:.\",\n+                                                                    \"-XX:+UseG1GC\",\n+                                                                    \"-XX:+UnlockExperimentalVMOptions\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                    \"-XX:G1MixedGCLiveThresholdPercent=0\",\n+                                                                    \"-Xlog:gc+marking=debug,gc+phases=debug,gc+remset+tracking=trace\",\n+                                                                    \"-Xms10M\",\n+                                                                    \"-Xmx10M\",\n+                                                                    GCTest.class.getName());\n@@ -62,2 +61,3 @@\n-            \/\/ Allocate some memory less than region size.\n-            Object used = alloc();\n+            \/\/ Allocate some memory less than region size. Any object is just fine as we set\n+            \/\/ G1MixedGCLiveThresholdPercent to zero (and no region should be selected).\n+            Object used = new byte[2000];\n@@ -65,2 +65,3 @@\n-            \/\/ Trigger the full GC using the WhiteBox API.\n-            wb.fullGC();  \/\/ full\n+            \/\/ Trigger the full GC using the WhiteBox API to make sure that at least \"used\"\n+            \/\/ has been promoted to old gen.\n+            wb.fullGC();\n@@ -69,1 +70,2 @@\n-            \/\/ Concurrent cycle should not select any regions for rebuilding\n+            \/\/ Concurrent cycle should not select any regions for rebuilding and print the\n+            \/\/ appropriate message.\n@@ -73,8 +75,0 @@\n-\n-        private static Object alloc() {\n-            \/\/ Since G1MixedGCLiveThresholdPercent is 20%, make sure to allocate object larger than that\n-            \/\/ so that it will not be collected and the expected message printed.\n-            final int objectSize = WhiteBox.getWhiteBox().g1RegionSize() \/ 3;\n-            Object ret = new byte[objectSize];\n-            return ret;\n-        }\n@@ -83,0 +77,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestSkipRebuildRemsetPhase.java","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -181,4 +181,1 @@\n-        ProcessBuilder procBuilder =  ProcessTools.createLimitedTestJavaProcessBuilder(basicOpts);\n-        OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());\n-\n-        return analyzer;\n+        return ProcessTools.executeLimitedTestJava(basicOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    public static void main(String[] args) throws IOException {\n+    public static void main(String[] args) throws Exception {\n@@ -50,1 +50,1 @@\n-    public static void generateClassLoader(long regionSize, Path wrkDir) throws IOException {\n+    public static void generateClassLoader(long regionSize, Path wrkDir) throws Exception {\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/ClassLoaderGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,2 +78,1 @@\n-     * @throws IOException\n-     * @throws ClassNotFoundException\n+     * @throws Exception\n@@ -83,1 +82,1 @@\n-            throws IOException, ClassNotFoundException {\n+            throws Exception {\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/G1SampleClass.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -143,3 +143,1 @@\n-    public static void main(String[] args) throws ClassNotFoundException, InstantiationException,\n-            IllegalAccessException, IOException, NoSuchMethodException, InvocationTargetException {\n-\n+    public static void main(String[] args) throws Exception {\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestHumongousClassLoader.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,2 +85,1 @@\n-    public static void main(String[] args) throws ClassNotFoundException, InstantiationException,\n-            IllegalAccessException, IOException {\n+    public static void main(String[] args) throws Exception {\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestHumongousNonArrayAllocation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,2 +93,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(testOpts);\n-        return new OutputAnalyzer(pb.start());\n+        return ProcessTools.executeLimitedTestJava(testOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/mixedgc\/TestLogging.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-        ProcessBuilder pb_enabled = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -198,1 +198,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb_enabled.start());\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/numa\/TestG1NUMATouchRegions.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,10 +51,10 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                             \"-XX:+WhiteBoxAPI\",\n-                                                                             \"-Xbootclasspath\/a:.\",\n-                                                                             \"-XX:-CreateCoredumpOnCrash\",\n-                                                                             \"-Xmx32M\",\n-                                                                             \"-Xmn16M\",\n-                                                                             \"-Xlog:gc\",\n-                                                                             TestObjectPin.class.getName(),\n-                                                                             type);\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                    \"-Xbootclasspath\/a:.\",\n+                                                                    \"-XX:-CreateCoredumpOnCrash\",\n+                                                                    \"-Xmx32M\",\n+                                                                    \"-Xmn16M\",\n+                                                                    \"-Xlog:gc\",\n+                                                                    TestObjectPin.class.getName(),\n+                                                                    type);\n@@ -62,1 +62,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -87,1 +86,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedObjectTypes.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -67,13 +67,12 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                             \"-XX:+WhiteBoxAPI\",\n-                                                                             \"-Xbootclasspath\/a:.\",\n-                                                                             \"-Xmx32M\",\n-                                                                             \"-Xmn16M\",\n-                                                                             \"-XX:G1NumCollectionsKeepPinned=2\",\n-                                                                             \"-XX:+VerifyAfterGC\",\n-                                                                             \"-Xlog:gc,gc+ergo+cset=trace\",\n-                                                                             TestObjectPin.class.getName(),\n-                                                                             String.valueOf(younGCsBeforeUnpin));\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                    \"-Xbootclasspath\/a:.\",\n+                                                                    \"-Xmx32M\",\n+                                                                    \"-Xmn16M\",\n+                                                                    \"-XX:G1NumCollectionsKeepPinned=2\",\n+                                                                    \"-XX:+VerifyAfterGC\",\n+                                                                    \"-Xlog:gc,gc+ergo+cset=trace\",\n+                                                                    TestObjectPin.class.getName(),\n+                                                                    String.valueOf(younGCsBeforeUnpin));\n+\n@@ -131,1 +130,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedObjectsEvacuation.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -260,18 +260,17 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                             \"-XX:+WhiteBoxAPI\",\n-                                                                             \"-Xbootclasspath\/a:.\",\n-                                                                             \"-Xmx32M\",\n-                                                                             \"-Xmn16M\",\n-                                                                             \"-XX:MarkSweepDeadRatio=0\",\n-                                                                             \"-XX:G1NumCollectionsKeepPinned=3\",\n-                                                                             \"-XX:+UnlockExperimentalVMOptions\",\n-                                                                             \/\/ Take all old regions to make sure that the pinned one is included in the collection set.\n-                                                                             \"-XX:G1MixedGCLiveThresholdPercent=100\",\n-                                                                             \"-XX:G1HeapWastePercent=0\",\n-                                                                             \"-XX:+VerifyAfterGC\",\n-                                                                             \"-Xlog:gc,gc+ergo+cset=trace\",\n-                                                                             TestObjectPin.class.getName(),\n-                                                                             String.valueOf(youngGCsBeforeUnpin));\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                    \"-Xbootclasspath\/a:.\",\n+                                                                    \"-Xmx32M\",\n+                                                                    \"-Xmn16M\",\n+                                                                    \"-XX:MarkSweepDeadRatio=0\",\n+                                                                    \"-XX:G1NumCollectionsKeepPinned=3\",\n+                                                                    \"-XX:+UnlockExperimentalVMOptions\",\n+                                                                    \/\/ Take all old regions to make sure that the pinned one is included in the collection set.\n+                                                                    \"-XX:G1MixedGCLiveThresholdPercent=100\",\n+                                                                    \"-XX:G1HeapWastePercent=0\",\n+                                                                    \"-XX:+VerifyAfterGC\",\n+                                                                    \"-Xlog:gc,gc+ergo+cset=trace\",\n+                                                                    TestObjectPin.class.getName(),\n+                                                                    String.valueOf(youngGCsBeforeUnpin));\n+\n@@ -337,1 +336,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedOldObjectsEvacuation.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -45,2 +45,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+PrintGC\", DoGC.class.getName());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+PrintGC\", DoGC.class.getName());\n@@ -55,2 +54,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+PrintGCDetails\", DoGC.class.getName());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+PrintGCDetails\", DoGC.class.getName());\n@@ -66,2 +64,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xloggc:\" + fileName, DoGC.class.getName());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-Xloggc:\" + fileName, DoGC.class.getName());\n@@ -83,2 +80,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+PrintGCDetails\", \"-Xloggc:\" + fileName, DoGC.class.getName());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+PrintGCDetails\", \"-Xloggc:\" + fileName, DoGC.class.getName());\n","filename":"test\/hotspot\/jtreg\/gc\/logging\/TestDeprecatedPrintFlags.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -76,3 +76,3 @@\n-    ProcessBuilder pb_default =\n-      ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+\" + gcFlag, \"-Xlog:gc\", \"-Xmx10M\", GCTest.class.getName());\n-    verifyContainsGCIDs(new OutputAnalyzer(pb_default.start()));\n+    OutputAnalyzer output =\n+      ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+\" + gcFlag, \"-Xlog:gc\", \"-Xmx10M\", GCTest.class.getName());\n+    verifyContainsGCIDs(output);\n","filename":"test\/hotspot\/jtreg\/gc\/logging\/TestGCId.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -96,10 +96,0 @@\n-    ProcessBuilder pb =\n-      ProcessTools.createTestJavaProcessBuilder(\n-          \"-Xlog:gc*\",\n-          \"-Xbootclasspath\/a:.\",\n-          \"-XX:+UnlockDiagnosticVMOptions\",\n-          \"-XX:+WhiteBoxAPI\",\n-          \"-Xmx1000M\",\n-          \"-Xms1000M\",\n-          StressMetaSpace.class.getName());\n-\n@@ -108,1 +98,9 @@\n-      output = new OutputAnalyzer(pb.start());\n+      output = ProcessTools.executeTestJava(\n+            \"-Xlog:gc*\",\n+            \"-Xbootclasspath\/a:.\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xmx1000M\",\n+            \"-Xms1000M\",\n+            StressMetaSpace.class.getName());\n+\n@@ -113,1 +111,3 @@\n-      output.reportDiagnosticSummary();\n+      if (output != null) {\n+        output.reportDiagnosticSummary();\n+      }\n","filename":"test\/hotspot\/jtreg\/gc\/logging\/TestMetaSpaceLog.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -70,5 +70,4 @@\n-        ProcessBuilder pb_enabled = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:gc+ref+phases=debug\",\n-                                                                                     \"-XX:+UseG1GC\",\n-                                                                                     \"-Xmx32M\",\n-                                                                                     GCTest.class.getName());\n-        OutputAnalyzer output = new OutputAnalyzer(pb_enabled.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-Xlog:gc+ref+phases=debug\",\n+                                                                    \"-XX:+UseG1GC\",\n+                                                                    \"-Xmx32M\",\n+                                                                    GCTest.class.getName());\n@@ -98,8 +97,7 @@\n-        ProcessBuilder pb_enabled = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:gc+phases+ref=debug\",\n-                                                                                     \"-XX:+UseG1GC\",\n-                                                                                     \"-Xmx32M\",\n-                                                                                     \"-XX:\" + (parallelRefProcEnabled ? \"+\" : \"-\") + \"ParallelRefProcEnabled\",\n-                                                                                     \"-XX:-UseDynamicNumberOfGCThreads\",\n-                                                                                     \"-XX:ParallelGCThreads=2\",\n-                                                                                     GCTest.class.getName());\n-        OutputAnalyzer output = new OutputAnalyzer(pb_enabled.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-Xlog:gc+phases+ref=debug\",\n+                                                                    \"-XX:+UseG1GC\",\n+                                                                    \"-Xmx32M\",\n+                                                                    \"-XX:\" + (parallelRefProcEnabled ? \"+\" : \"-\") + \"ParallelRefProcEnabled\",\n+                                                                    \"-XX:-UseDynamicNumberOfGCThreads\",\n+                                                                    \"-XX:ParallelGCThreads=2\",\n+                                                                    GCTest.class.getName());\n","filename":"test\/hotspot\/jtreg\/gc\/logging\/TestPrintReferences.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -80,3 +80,2 @@\n-        Process p = pb.start();\n-        p.waitFor();\n-        int exitValue = p.exitValue();\n+        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+        int exitValue = output.getExitValue();\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+    return ProcessTools.executeLimitedTestJava(\n@@ -93,1 +93,0 @@\n-    return new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/TestMetaspaceSizeFlags.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,2 +122,1 @@\n-    final ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(jvmArgs);\n-    final OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    final OutputAnalyzer output = ProcessTools.executeLimitedTestJava(jvmArgs);\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/TestSizeTransitions.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xmx128m\", \"-Xmn100m\", \"-XX:+UseSerialGC\", \"-Xlog:gc\", HeapFiller.class.getName());\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-Xmx128m\", \"-Xmn100m\", \"-XX:+UseSerialGC\", \"-Xlog:gc\", HeapFiller.class.getName());\n","filename":"test\/hotspot\/jtreg\/gc\/serial\/HeapChangeLogging.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-                    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xms128m\",\n+                    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-Xms128m\",\n@@ -78,1 +78,0 @@\n-                    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestEvilSyncBug.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -157,5 +158,1 @@\n-            ProcessBuilder pb = new ProcessBuilder(jcmd.getCommand());\n-            Process jcmdProc = pb.start();\n-\n-            OutputAnalyzer output = new OutputAnalyzer(jcmdProc);\n-            jcmdProc.waitFor();\n+            OutputAnalyzer output = ProcessTools.executeProcess(jcmd.getCommand());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestJcmdHeapDump.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(cmds);\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(cmds);\n@@ -47,1 +47,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestObjItrWithHeapDump.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(cmds);\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(cmds);\n@@ -48,1 +48,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestPeriodicGC.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,3 +103,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(pbArgs.toArray(new String[0]));\n-\n-        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer analyzer = ProcessTools.executeLimitedTestJava(pbArgs.toArray(new String[0]));\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestClassLoaderLeak.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer analyzer = ProcessTools.executeLimitedTestJava(\n@@ -73,1 +73,0 @@\n-            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestThreadFailure.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -56,1 +56,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -60,1 +59,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -67,1 +66,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -71,1 +69,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -78,1 +76,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -86,1 +83,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -93,1 +90,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -97,1 +93,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -104,1 +100,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -108,1 +103,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -115,1 +110,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -119,1 +113,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -126,1 +120,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestArgumentRanges.java","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(cmds);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(cmds);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestClassUnloadingArguments.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -70,1 +70,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -80,1 +79,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -88,1 +87,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -98,1 +96,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -106,1 +104,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -116,1 +113,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -124,1 +121,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -134,1 +130,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -143,1 +139,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestExplicitGC.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -73,1 +73,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestExplicitGCNoConcurrent.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -63,1 +63,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -76,1 +75,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -84,1 +83,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -97,1 +95,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -105,1 +103,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestHeuristicsUnlock.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -46,1 +46,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -54,1 +53,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -60,1 +59,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -65,1 +63,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -71,1 +69,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestHumongousThresholdArgs.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,2 +47,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(cmds);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(cmds);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestLoopMiningArguments.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -64,1 +64,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -77,1 +76,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -85,1 +84,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -98,1 +96,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -106,1 +104,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestModeUnlock.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -53,1 +53,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -58,1 +57,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -63,1 +62,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -68,1 +66,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -74,1 +72,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -80,1 +77,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -86,1 +83,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -91,1 +87,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -97,1 +93,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -103,1 +98,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -109,1 +104,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -114,1 +108,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -120,1 +114,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -125,1 +118,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -131,1 +124,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -137,1 +129,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -143,1 +135,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -148,1 +139,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -154,1 +145,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -163,1 +153,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -169,1 +159,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -175,1 +164,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -182,1 +171,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -187,1 +175,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -193,1 +181,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -199,1 +186,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -205,1 +192,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -214,1 +200,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -220,1 +206,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -226,1 +211,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -233,1 +218,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestRegionSizeArgs.java","additions":16,"deletions":32,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -92,2 +92,1 @@\n-                    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(conf.toArray(new String[0]));\n-                    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+                    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(conf.toArray(new String[0]));\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestSelectiveBarrierFlags.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -47,1 +47,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -52,1 +51,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -58,1 +57,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -63,1 +61,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UnlockExperimentalVMOptions\",\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n@@ -69,1 +67,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestSoftMaxHeapSize.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -56,1 +56,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestThreadCounts.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -49,1 +49,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -56,1 +55,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -64,1 +63,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestThreadCountsOverride.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -75,1 +75,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -84,1 +83,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -93,1 +92,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestWrongBarrierDisable.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -67,1 +67,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n@@ -76,1 +75,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n@@ -85,1 +84,0 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestWrongBarrierEnable.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,2 +64,2 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(baseargs);\n-        verifySymbolMemoryUsageNotTooHigh(new OutputAnalyzer(pb.start()));\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(baseargs);\n+        verifySymbolMemoryUsageNotTooHigh(output);\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestReclaimStringsLeaksMemory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,2 +104,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(options);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(options);\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressG1Humongous.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(options);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(options);\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressG1Uncommit.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package gc.stress.gclocker;\n-\n-\/\/ Stress the GC locker by calling GetPrimitiveArrayCritical while\n-\/\/ concurrently filling up old gen.\n-\n-import java.lang.management.MemoryPoolMXBean;\n-import java.lang.management.ManagementFactory;\n-import java.lang.management.MemoryUsage;\n-import java.util.ArrayDeque;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Queue;\n-\n-final class ThreadUtils {\n-    public static void sleep(long durationMS) {\n-        try {\n-            Thread.sleep(durationMS);\n-        } catch (Exception e) {\n-        }\n-    }\n-}\n-\n-class Filler {\n-    private static final int SIZE = 250000;\n-\n-    private int[] i1 = new int[SIZE];\n-    private int[] i2 = new int[SIZE];\n-    private short[] s1 = new short[SIZE];\n-    private short[] s2 = new short[SIZE];\n-\n-    private Map<Object, Object> map = new HashMap<>();\n-\n-    public Filler() {\n-        for (int i = 0; i < 10000; i++) {\n-            map.put(new Object(), new Object());\n-        }\n-    }\n-}\n-\n-class Exitable {\n-    private volatile boolean shouldExit = false;\n-\n-    protected boolean shouldExit() {\n-        return shouldExit;\n-    }\n-\n-    public void exit() {\n-        shouldExit = true;\n-    }\n-}\n-\n-class MemoryWatcher {\n-    private MemoryPoolMXBean bean;\n-    private final int thresholdPromille = 750;\n-    private final int criticalThresholdPromille = 800;\n-    private final long minGCWaitNanos = 1_000_000_000L;\n-    private final long minFreeWaitElapsedNanos = 30L * 1_000_000_000L;\n-    private final long minFreeCriticalWaitNanos;\n-\n-    private int lastUsage = 0;\n-    private long lastGCDetectedNanos = System.nanoTime();\n-    private long lastFreeNanos = System.nanoTime();\n-\n-    public MemoryWatcher(String mxBeanName, long minFreeCriticalWaitNanos) {\n-        this.minFreeCriticalWaitNanos = minFreeCriticalWaitNanos;\n-        List<MemoryPoolMXBean> memoryBeans = ManagementFactory.getMemoryPoolMXBeans();\n-        for (MemoryPoolMXBean bean : memoryBeans) {\n-            if (bean.getName().equals(mxBeanName)) {\n-                this.bean = bean;\n-                break;\n-            }\n-        }\n-    }\n-\n-    private int getMemoryUsage() {\n-        if (bean == null) {\n-            Runtime r = Runtime.getRuntime();\n-            float free = (float) r.freeMemory() \/ r.maxMemory();\n-            return Math.round((1 - free) * 1000);\n-        } else {\n-            MemoryUsage usage = bean.getUsage();\n-            float used = (float) usage.getUsed() \/ usage.getCommitted();\n-            return Math.round(used * 1000);\n-        }\n-    }\n-\n-    public synchronized boolean shouldFreeUpSpace() {\n-        int usage = getMemoryUsage();\n-        long nowNanos = System.nanoTime();\n-\n-        boolean detectedGC = false;\n-        if (usage < lastUsage) {\n-            lastGCDetectedNanos = nowNanos;\n-            detectedGC = true;\n-        }\n-\n-        lastUsage = usage;\n-\n-        long elapsedNanos = nowNanos - lastFreeNanos;\n-        long timeSinceLastGCNanos = nowNanos - lastGCDetectedNanos;\n-\n-        if (usage > criticalThresholdPromille && elapsedNanos > minFreeCriticalWaitNanos) {\n-            lastFreeNanos = nowNanos;\n-            return true;\n-        } else if (usage > thresholdPromille && !detectedGC) {\n-            if (elapsedNanos > minFreeWaitElapsedNanos || timeSinceLastGCNanos > minGCWaitNanos) {\n-                lastFreeNanos = nowNanos;\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-}\n-\n-class MemoryUser extends Exitable implements Runnable {\n-    private final Queue<Filler> cache = new ArrayDeque<Filler>();\n-    private final MemoryWatcher watcher;\n-\n-    private void load() {\n-        if (watcher.shouldFreeUpSpace()) {\n-            int toRemove = cache.size() \/ 5;\n-            for (int i = 0; i < toRemove; i++) {\n-                cache.remove();\n-            }\n-        }\n-        cache.add(new Filler());\n-    }\n-\n-    public MemoryUser(String mxBeanName, long minFreeCriticalWaitNanos) {\n-        watcher = new MemoryWatcher(mxBeanName, minFreeCriticalWaitNanos);\n-    }\n-\n-    @Override\n-    public void run() {\n-        for (int i = 0; i < 200; i++) {\n-            load();\n-        }\n-\n-        while (!shouldExit()) {\n-            load();\n-        }\n-    }\n-}\n-\n-class GCLockerStresser extends Exitable implements Runnable {\n-    static native void fillWithRandomValues(byte[] array);\n-\n-    @Override\n-    public void run() {\n-        byte[] array = new byte[1024 * 1024];\n-        while (!shouldExit()) {\n-            fillWithRandomValues(array);\n-        }\n-    }\n-}\n-\n-public class TestGCLocker {\n-    private static Exitable startGCLockerStresser(String name) {\n-        GCLockerStresser task = new GCLockerStresser();\n-\n-        Thread thread = new Thread(task);\n-        thread.setName(name);\n-        thread.setPriority(Thread.MIN_PRIORITY);\n-        thread.start();\n-\n-        return task;\n-    }\n-\n-    private static Exitable startMemoryUser(String mxBeanName, long minFreeCriticalWaitNanos) {\n-        MemoryUser task = new MemoryUser(mxBeanName, minFreeCriticalWaitNanos);\n-\n-        Thread thread = new Thread(task);\n-        thread.setName(\"Memory User\");\n-        thread.start();\n-\n-        return task;\n-    }\n-\n-    public static void main(String[] args) {\n-        System.loadLibrary(\"TestGCLocker\");\n-\n-        long durationMinutes = args.length > 0 ? Long.parseLong(args[0]) : 5;\n-        String mxBeanName = args.length > 1 ? args[1] : null;\n-        long minFreeCriticalWaitNanos = args.length > 2\n-            ? Integer.parseInt(args[2]) * 1_000_000L\n-            : 500_000_000L;\n-\n-        Exitable stresser1 = startGCLockerStresser(\"GCLockerStresser1\");\n-        Exitable stresser2 = startGCLockerStresser(\"GCLockerStresser2\");\n-        Exitable memoryUser = startMemoryUser(mxBeanName, minFreeCriticalWaitNanos);\n-\n-        try {\n-            Thread.sleep(durationMinutes * 60_000L);\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\"Test Failure, did not except an InterruptedException\", e);\n-        }\n-\n-        stresser1.exit();\n-        stresser2.exit();\n-        memoryUser.exit();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestGCLocker.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package gc.stress.gclocker;\n-\n-\/*\n- * @test TestGCLockerWithG1\n- * @library \/\n- * @requires vm.gc.G1\n- * @summary Stress G1's GC locker by calling GetPrimitiveArrayCritical while concurrently filling up old gen.\n- * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UseG1GC gc.stress.gclocker.TestGCLockerWithG1\n- *\/\n-public class TestGCLockerWithG1 {\n-    public static void main(String[] args) {\n-        String[] testArgs = {\"2\", \"G1 Old Gen\"};\n-        TestGCLocker.main(testArgs);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestGCLockerWithG1.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package gc.stress.gclocker;\n-\n-\/*\n- * @test TestGCLockerWithParallel\n- * @library \/\n- * @requires vm.gc.Parallel\n- * @summary Stress Parallel's GC locker by calling GetPrimitiveArrayCritical while concurrently filling up old gen.\n- * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UseParallelGC gc.stress.gclocker.TestGCLockerWithParallel\n- *\/\n-public class TestGCLockerWithParallel {\n-    public static void main(String[] args) {\n-        String[] testArgs = {\"2\", \"PS Old Gen\"};\n-        TestGCLocker.main(testArgs);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestGCLockerWithParallel.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package gc.stress.gclocker;\n-\n-\/*\n- * @test TestGCLockerWithSerial\n- * @library \/\n- * @requires vm.gc.Serial\n- * @requires vm.flavor != \"minimal\"\n- * @summary Stress Serial's GC locker by calling GetPrimitiveArrayCritical while concurrently filling up old gen.\n- * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UseSerialGC gc.stress.gclocker.TestGCLockerWithSerial\n- *\/\n-public class TestGCLockerWithSerial {\n-    public static void main(String[] args) {\n-        String[] testArgs = {\"2\", \"Tenured Gen\"};\n-        TestGCLocker.main(testArgs);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestGCLockerWithSerial.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package gc.stress.gclocker;\n-\n-\/*\n- * @test id=default\n- * @library \/\n- * @requires vm.gc.Shenandoah\n- * @summary Stress Shenandoah's JNI handling by calling GetPrimitiveArrayCritical while concurrently filling up old gen.\n- *\n- * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+UseShenandoahGC\n- *      -XX:+ShenandoahVerify\n- *      gc.stress.gclocker.TestGCLockerWithShenandoah\n- *\n- * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+UseShenandoahGC\n- *      gc.stress.gclocker.TestGCLockerWithShenandoah\n- *\/\n-\n-\/*\n- * @test id=generational\n- * @library \/\n- * @requires vm.gc.Shenandoah\n- * @summary Stress Shenandoah's JNI handling by calling GetPrimitiveArrayCritical while concurrently filling up old gen.\n- *\n- * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n- *      -XX:+ShenandoahVerify\n- *      gc.stress.gclocker.TestGCLockerWithShenandoah\n- *\n- * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n- *      gc.stress.gclocker.TestGCLockerWithShenandoah\n- *\/\n-\n-\/*\n- * @test id=aggressive\n- * @library \/\n- * @requires vm.gc.Shenandoah\n- * @summary Stress Shenandoah's JNI handling by calling GetPrimitiveArrayCritical while concurrently filling up old gen.\n- *\n- * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      gc.stress.gclocker.TestGCLockerWithShenandoah\n- *\n- * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      gc.stress.gclocker.TestGCLockerWithShenandoah\n- *\/\n-public class TestGCLockerWithShenandoah {\n-    public static void main(String[] args) {\n-        String[] testArgs = {\"2\", \"Shenandoah\", \"0\"};\n-        TestGCLocker.main(testArgs);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestGCLockerWithShenandoah.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-\n-JNIEXPORT void JNICALL\n-Java_gc_stress_gclocker_GCLockerStresser_fillWithRandomValues(JNIEnv* env, jclass clz, jbyteArray arr) {\n-  jsize size = (*env)->GetArrayLength(env, arr);\n-  jbyte* p = (*env)->GetPrimitiveArrayCritical(env, arr, NULL);\n-  jsize i;\n-  for (i = 0; i < size; i++) {\n-    p[i] = i % 128;\n-  }\n-  (*env)->ReleasePrimitiveArrayCritical(env, arr, p, 0);\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/libTestGCLocker.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -302,2 +302,1 @@\n-        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(args);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeTestJava(args);\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationTools.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -92,1 +93,1 @@\n-    public static void compileClass(String className, Path root, String source) throws IOException {\n+    public static void compileClass(String className, Path root, String source) throws Exception {\n@@ -103,2 +104,1 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n@@ -202,2 +202,1 @@\n-     * @throws IOException\n-     * @throws ClassNotFoundException\n+     * @throws Exception\n@@ -207,1 +206,1 @@\n-            throws IOException, ClassNotFoundException {\n+            throws Exception {\n@@ -246,1 +245,1 @@\n-     * @throws IOException if cannot write or read to workDir\n+     * @throws Exception if cannot write or read to workDir\n@@ -250,1 +249,1 @@\n-                                                    String prefix) throws IOException {\n+                                                    String prefix) throws Exception {\n","filename":"test\/hotspot\/jtreg\/gc\/testlibrary\/Helpers.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+        OutputAnalyzer output = ProcessTools.executeTestJava(\n@@ -54,1 +54,0 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/gc\/whitebox\/TestWBGC.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,11 +44,11 @@\n-        ProcessTools.executeProcess(ProcessTools.createLimitedTestJavaProcessBuilder(\n-                \"-XX:+UseZGC\",\n-                \"-XX:-ZGenerational\",\n-                \"-Xlog:gc*\",\n-                \"-Xms32M\",\n-                \"-Xmx32M\",\n-                \"-XX:AllocateHeapAt=\" + directory,\n-                \"-version\"))\n-            .shouldContain(exists ? heapBackingFile : failedToCreateFile)\n-            .shouldNotContain(exists ? failedToCreateFile : heapBackingFile)\n-            .shouldHaveExitValue(exists ? 0 : 1);\n+        ProcessTools.executeLimitedTestJava(\n+            \"-XX:+UseZGC\",\n+            \"-XX:-ZGenerational\",\n+            \"-Xlog:gc*\",\n+            \"-Xms32M\",\n+            \"-Xmx32M\",\n+            \"-XX:AllocateHeapAt=\" + directory,\n+            \"-version\")\n+                .shouldContain(exists ? heapBackingFile : failedToCreateFile)\n+                .shouldNotContain(exists ? failedToCreateFile : heapBackingFile)\n+                .shouldHaveExitValue(exists ? 0 : 1);\n","filename":"test\/hotspot\/jtreg\/gc\/x\/TestAllocateHeapAt.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -71,11 +71,11 @@\n-        ProcessTools.executeProcess(ProcessTools.createLimitedTestJavaProcessBuilder(\n-                                    \"-XX:+UseZGC\",\n-                                    \"-XX:-ZGenerational\",\n-                                    \"-Xms128M\",\n-                                    \"-Xmx128M\",\n-                                    \"-Xlog:gc,gc+init,gc+heap=debug\",\n-                                    Test.class.getName()))\n-                    .outputTo(System.out)\n-                    .errorTo(System.out)\n-                    .shouldContain(\"Page Cache Flushed:\")\n-                    .shouldHaveExitValue(0);\n+        ProcessTools.executeLimitedTestJava(\n+            \"-XX:+UseZGC\",\n+            \"-XX:-ZGenerational\",\n+            \"-Xms128M\",\n+            \"-Xmx128M\",\n+            \"-Xlog:gc,gc+init,gc+heap=debug\",\n+            Test.class.getName())\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .shouldContain(\"Page Cache Flushed:\")\n+                .shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/gc\/x\/TestPageCacheFlush.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -56,10 +56,10 @@\n-            ProcessTools.executeProcess(ProcessTools.createLimitedTestJavaProcessBuilder(\n-                                        \"-XX:+UseZGC\",\n-                                        \"-XX:-ZGenerational\",\n-                                        \"-Xlog:gc,gc+init,gc+reloc,gc+heap\",\n-                                        \"-Xmx\" + maxCapacity,\n-                                        Test.class.getName()))\n-                .outputTo(System.out)\n-                .errorTo(System.out)\n-                .shouldContain(\"Success\")\n-                .shouldHaveExitValue(0);\n+            ProcessTools.executeLimitedTestJava(\n+                \"-XX:+UseZGC\",\n+                \"-XX:-ZGenerational\",\n+                \"-Xlog:gc,gc+init,gc+reloc,gc+heap\",\n+                \"-Xmx\" + maxCapacity,\n+                Test.class.getName())\n+                    .outputTo(System.out)\n+                    .errorTo(System.out)\n+                    .shouldContain(\"Success\")\n+                    .shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/gc\/x\/TestSmallHeap.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,11 +44,11 @@\n-        ProcessTools.executeProcess(ProcessTools.createLimitedTestJavaProcessBuilder(\n-                \"-XX:+UseZGC\",\n-                \"-XX:+ZGenerational\",\n-                \"-Xlog:gc*\",\n-                \"-Xms32M\",\n-                \"-Xmx32M\",\n-                \"-XX:AllocateHeapAt=\" + directory,\n-                \"-version\"))\n-            .shouldContain(exists ? heapBackingFile : failedToCreateFile)\n-            .shouldNotContain(exists ? failedToCreateFile : heapBackingFile)\n-            .shouldHaveExitValue(exists ? 0 : 1);\n+        ProcessTools.executeLimitedTestJava(\n+            \"-XX:+UseZGC\",\n+            \"-XX:+ZGenerational\",\n+            \"-Xlog:gc*\",\n+            \"-Xms32M\",\n+            \"-Xmx32M\",\n+            \"-XX:AllocateHeapAt=\" + directory,\n+            \"-version\")\n+                .shouldContain(exists ? heapBackingFile : failedToCreateFile)\n+                .shouldNotContain(exists ? failedToCreateFile : heapBackingFile)\n+                .shouldHaveExitValue(exists ? 0 : 1);\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestAllocateHeapAt.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -71,11 +71,11 @@\n-        ProcessTools.executeProcess(ProcessTools.createLimitedTestJavaProcessBuilder(\n-                                    \"-XX:+UseZGC\",\n-                                    \"-XX:+ZGenerational\",\n-                                    \"-Xms128M\",\n-                                    \"-Xmx128M\",\n-                                    \"-Xlog:gc,gc+init,gc+heap=debug\",\n-                                    Test.class.getName()))\n-                    .outputTo(System.out)\n-                    .errorTo(System.out)\n-                    .shouldContain(\"Page Cache Flushed:\")\n-                    .shouldHaveExitValue(0);\n+        ProcessTools.executeLimitedTestJava(\n+            \"-XX:+UseZGC\",\n+            \"-XX:+ZGenerational\",\n+            \"-Xms128M\",\n+            \"-Xmx128M\",\n+            \"-Xlog:gc,gc+init,gc+heap=debug\",\n+            Test.class.getName())\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .shouldContain(\"Page Cache Flushed:\")\n+                .shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestPageCacheFlush.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -56,10 +56,10 @@\n-            ProcessTools.executeProcess(ProcessTools.createLimitedTestJavaProcessBuilder(\n-                                        \"-XX:+UseZGC\",\n-                                        \"-XX:+ZGenerational\",\n-                                        \"-Xlog:gc,gc+init,gc+reloc,gc+heap\",\n-                                        \"-Xmx\" + maxCapacity,\n-                                        Test.class.getName()))\n-                .outputTo(System.out)\n-                .errorTo(System.out)\n-                .shouldContain(\"Success\")\n-                .shouldHaveExitValue(0);\n+            ProcessTools.executeLimitedTestJava(\n+                \"-XX:+UseZGC\",\n+                \"-XX:+ZGenerational\",\n+                \"-Xlog:gc,gc+init,gc+reloc,gc+heap\",\n+                \"-Xmx\" + maxCapacity,\n+                Test.class.getName())\n+                    .outputTo(System.out)\n+                    .errorTo(System.out)\n+                    .shouldContain(\"Success\")\n+                    .shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestSmallHeap.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -48,11 +48,11 @@\n-        OutputAnalyzer oa = ProcessTools.executeProcess(ProcessTools.createTestJavaProcessBuilder(\n-                                                        \"-XX:+UseZGC\",\n-                                                        \"-XX:+ZGenerational\",\n-                                                        \"-Xms\" + XmsInM + \"M\",\n-                                                        \"-Xmx\" + XmxInM + \"M\",\n-                                                        \"-Xlog:gc,gc+init\",\n-                                                        \"-XX:ZForceDiscontiguousHeapReservations=\" + n,\n-                                                        \"-version\"))\n-                                        .outputTo(System.out)\n-                                        .errorTo(System.out)\n-                                        .shouldHaveExitValue(0);\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\n+            \"-XX:+UseZGC\",\n+            \"-XX:+ZGenerational\",\n+            \"-Xms\" + XmsInM + \"M\",\n+            \"-Xmx\" + XmxInM + \"M\",\n+            \"-Xlog:gc,gc+init\",\n+            \"-XX:ZForceDiscontiguousHeapReservations=\" + n,\n+            \"-version\")\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestZForceDiscontiguousHeapReservations.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -71,15 +71,15 @@\n-        OutputAnalyzer oa = ProcessTools.executeProcess(ProcessTools.createTestJavaProcessBuilder(\n-                                                        \"-XX:+UseZGC\",\n-                                                        \"-XX:+ZGenerational\",\n-                                                        \"-Xms\" + XmsInM + \"M\",\n-                                                        \"-Xmx\" + XmxInM + \"M\",\n-                                                        \"-Xlog:gc,gc+init\",\n-                                                        \"-XX:ZForceDiscontiguousHeapReservations=\" + zForceDiscontiguousHeapReservations,\n-                                                        \"-XX:NativeMemoryTracking=detail\",\n-                                                        \"-XX:+PrintNMTStatistics\",\n-                                                        Test.class.getName(),\n-                                                        Integer.toString(zForceDiscontiguousHeapReservations),\n-                                                        Integer.toString(XmxInM)))\n-                                        .outputTo(System.out)\n-                                        .errorTo(System.out)\n-                                        .shouldHaveExitValue(0);\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\n+            \"-XX:+UseZGC\",\n+            \"-XX:+ZGenerational\",\n+            \"-Xms\" + XmsInM + \"M\",\n+            \"-Xmx\" + XmxInM + \"M\",\n+            \"-Xlog:gc,gc+init\",\n+            \"-XX:ZForceDiscontiguousHeapReservations=\" + zForceDiscontiguousHeapReservations,\n+            \"-XX:NativeMemoryTracking=detail\",\n+            \"-XX:+PrintNMTStatistics\",\n+            Test.class.getName(),\n+            Integer.toString(zForceDiscontiguousHeapReservations),\n+            Integer.toString(XmxInM))\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestZNMT.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -202,0 +202,17 @@\n+    public static void createModularJarWithManifest(String jarPath,\n+                                                    String classesDir,\n+                                                    String mainClass,\n+                                                    String manifest) throws Exception {\n+        ArrayList<String> argList = new ArrayList<String>();\n+        argList.add(\"--create\");\n+        argList.add(\"--file=\" + jarPath);\n+        if (mainClass != null) {\n+            argList.add(\"--main-class=\" + mainClass);\n+        }\n+        argList.add(\"--manifest=\" + manifest);\n+        argList.add(\"-C\");\n+        argList.add(classesDir);\n+        argList.add(\".\");\n+        createJar(argList);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/JarBuilder.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8322657\n+ * @summary This test defines an application module using the DefineModuleApp.\n+ *          When performing dynamic dump, the modular jar containing the module\n+ *          is in the -cp. The jar listed in the \"Class-Path\" attribute of the modular\n+ *          jar doesn't exist. VM should not crash during dynamic dump under this scenario.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build jdk.test.whitebox.WhiteBox DefineModuleApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar define_module_app.jar DefineModuleApp\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. ModularJarWithNonExistentJar\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class ModularJarWithNonExistentJar extends DynamicArchiveTestBase {\n+    private static final Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n+\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+\n+    private static final Path SRC_DIR = Paths.get(TEST_SRC, \"..\/jigsaw\/modulepath\/src\");\n+    private static final Path MODS_DIR = Paths.get(\"mods\");\n+    private static final Path MANIFEST_PATH = Paths.get(TEST_SRC, \"test-classes\/manifest-with-non-existent-jar.txt\");\n+\n+    \/\/ the module name of the test module\n+    private static final String TEST_MODULE = \"com.simple\";\n+\n+    \/\/ the module main class\n+    private static final String MAIN_CLASS = \"com.simple.Main\";\n+\n+    private static Path moduleDir = null;\n+    private static Path modularJar = null;\n+\n+    public static void buildTestModule() throws Exception {\n+\n+        \/\/ javac -d mods\/$TESTMODULE --module-path MOD_DIR src\/$TESTMODULE\/**\n+        JarBuilder.compileModule(SRC_DIR.resolve(TEST_MODULE),\n+                                 MODS_DIR.resolve(TEST_MODULE),\n+                                 MODS_DIR.toString());\n+\n+\n+        moduleDir = Files.createTempDirectory(USER_DIR, \"mlib\");\n+\n+        modularJar = moduleDir.resolve(TEST_MODULE + \".jar\");\n+        String classes = MODS_DIR.resolve(TEST_MODULE).toString();\n+        JarBuilder.createModularJarWithManifest(modularJar.toString(), classes,\n+                                                MAIN_CLASS, MANIFEST_PATH.toString());\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        runTest(ModularJarWithNonExistentJar::testDefaultBase);\n+    }\n+\n+    static void testDefaultBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        doTest(topArchiveName);\n+    }\n+\n+    private static void doTest(String topArchiveName) throws Exception {\n+        \/\/ compile the module and create the modular jar file\n+        buildTestModule();\n+        String appJar = ClassFileInstaller.getJarPath(\"define_module_app.jar\");\n+        dump(topArchiveName,\n+             \"-Xlog:cds,class+path=info\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\", appJar + File.pathSeparator + modularJar.toString(),\n+             \"DefineModuleApp\", moduleDir.toString(), TEST_MODULE)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ModularJarWithNonExistentJar.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * This app defines a module using the ModuleLayer.defineModulesWithOneLoader API\n+ * which calls the JVM_DefineModule.\n+ **\/\n+\n+import java.nio.file.Path;\n+import java.lang.ModuleLayer.Controller;\n+import java.lang.module.*;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class DefineModuleApp {\n+    public static void main(String[] args) throws Throwable {\n+        if (args.length != 2) {\n+            throw new RuntimeException(\"DefineModuleApp expects 2 args but saw \" + args.length);\n+        }\n+        final Path MODS = Path.of(args[0]);\n+        final String MODULE_NAME = args[1];\n+        Configuration cf = ModuleLayer.boot()\n+                .configuration()\n+                .resolve(ModuleFinder.of(), ModuleFinder.of(MODS), Set.of(MODULE_NAME));\n+        ResolvedModule m = cf.findModule(MODULE_NAME).orElseThrow();\n+        ModuleLayer bootLayer = ModuleLayer.boot();\n+        ClassLoader scl = ClassLoader.getSystemClassLoader();\n+        Controller controller = ModuleLayer.defineModulesWithOneLoader(cf, List.of(bootLayer), scl);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/DefineModuleApp.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+Manifest-Version: 1.0\n+Class-Path: NonExistent.jar\n+Created-By: 23-internal (Oracle Corporation)\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/manifest-with-non-existent-jar.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -309,1 +309,1 @@\n-        tty(\"10. run with CDS on,  with main\/test jars on classpath also with -Xbootclasspath\/a:  should not pass\");\n+        tty(\"10. run with CDS on,  with main\/test jars on classpath also with -Xbootclasspath\/a:  should pass\");\n@@ -317,1 +317,0 @@\n-                   .shouldContain(OPTIMIZE_DISABLED)\n@@ -321,0 +320,49 @@\n+\n+        \/\/ Dump an archive with -Xbootclasspath\/a\n+        output = TestCommon.createArchive(\n+                                testJar.toString(),\n+                                appClasses,\n+                                \"-Xbootclasspath\/a:\" + mainJar.toString());\n+        TestCommon.checkDump(output);\n+        tty(\"11. run with CDS on,  with test jar on classpath and with main jar on -Xbootclasspath\/a:  should pass\");\n+        TestCommon.run(\"-Xlog:cds\",\n+                       \"-cp\", testJar.toString(),\n+                       \"-Xbootclasspath\/a:\" + mainJar.toString(),\n+                       MAIN_CLASS)\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(CLASS_FOUND_MESSAGE)\n+                   .shouldNotContain(CLASS_NOT_FOUND_MESSAGE)\n+                   .shouldContain(OPTIMIZE_ENABLED);\n+            });\n+        tty(\"12. run with CDS on,  with main jar on classpath and with test jar on -Xbootclasspath\/a:  should not pass due to class paths mismatch\");\n+        TestCommon.run(\"-Xlog:cds\",\n+                       \"-cp\", mainJar.toString(),\n+                       \"-Xbootclasspath\/a:\" + testJar.toString(),\n+                       MAIN_CLASS)\n+            .assertAbnormalExit(out -> {\n+                out.shouldNotContain(CLASS_FOUND_MESSAGE)\n+                   .shouldNotContain(CLASS_NOT_FOUND_MESSAGE)\n+                   .shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(MAP_FAILED);\n+            });\n+\n+        \/\/ Skip the following test for dynamic CDS archive because the current\n+        \/\/ dynamic dump test utililty does not support empty -cp with a classlist.\n+        \/\/ (see createArchive(CDSOptions opts) in TestCommon.java)\n+        if (!CDSTestUtils.isDynamicArchive()) {\n+            \/\/ Dump an archive with only -Xbootclasspath\/a\n+            output = TestCommon.createArchive(\n+                                    null,\n+                                    appClasses,\n+                                    \"-Xbootclasspath\/a:\" + mainJar.toString());\n+            TestCommon.checkDump(output);\n+            tty(\"13. run with CDS on,  with the same -Xbootclasspath\/a as dump time and adding a -cp with test.jar:  should pass\");\n+            TestCommon.run(\"-Xlog:cds,class+load\",\n+                           \"-cp\", testJar.toString(),\n+                           \"-Xbootclasspath\/a:\" + mainJar.toString(),\n+                           MAIN_CLASS)\n+                .assertNormalExit(out -> {\n+                    out.shouldMatch(MAIN_FROM_CDS)\n+                       .shouldContain(OPTIMIZE_ENABLED);\n+            });\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-            \"-subgraph java\/lang\/module\/ResolvedModule jdk.internal.module.ArchivedModuleGraph\",\n+            \"-subgraph java\/lang\/module\/Configuration java.lang.module.Configuration\",\n+            \"-subgraph java\/lang\/ModuleLayer java.lang.ModuleLayer\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/serviceability\/ReplaceCriticalClassesForSubgraphs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, 2024 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.gc.Serial & (vm.opt.DisableExplicitGC != \"true\")\n+ * @summary Test of option -XX:FullGCHeapDumpLimit\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseSerialGC -XX:+HeapDumpBeforeFullGC -XX:+HeapDumpAfterFullGC -XX:HeapDumpPath=test.hprof -XX:FullGCHeapDumpLimit=1 FullGCHeapDumpLimitTest\n+ *\/\n+\n+import java.io.File;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class FullGCHeapDumpLimitTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.gc();\n+        Asserts.assertTrue(new File(\"test.hprof\").exists());\n+        Asserts.assertFalse(new File(\"test.hprof.1\").exists());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/FullGCHeapDumpLimitTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.HashSet;\n@@ -30,0 +31,1 @@\n+import java.util.Set;\n@@ -226,0 +228,3 @@\n+            \/\/ And detect thread object duplicates.\n+            Set<Long> uniqueThreads = new HashSet<>();\n+\n@@ -228,0 +233,2 @@\n+                JavaHeapObject threadObj = snapshot.findThing(thread.getId());\n+                JavaClass threadClass = threadObj.getClazz();\n@@ -230,1 +237,7 @@\n-                log(\"thread \" + thread.getIdString() + \", \" + frames.length + \" frames\");\n+                log(\"thread \" + thread.getIdString() + \" (\" + threadClass.getName() + \"), \" + frames.length + \" frames\");\n+\n+                if (uniqueThreads.contains(thread.getId())) {\n+                    log(\" - ERROR: duplicate\");\n+                } else {\n+                    uniqueThreads.add(thread.getId());\n+                }\n@@ -253,0 +266,4 @@\n+            if (threads.size() != uniqueThreads.size()) {\n+                throw new RuntimeException(\"Thread duplicates detected (\" + (threads.size() - uniqueThreads.size()) + \")\");\n+            }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/HeapDump\/VThreadInHeapDump.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,2 @@\n-LIB_FILES = $(shell find $(TESTLIBRARY_DIR)\/jdk\/test\/lib\/ \\\n+# Exclude files that need '--enable-preview' to compile.\n+LIB_FILES = $(filter-out %ModuleInfoWriter.java, $(shell find $(TESTLIBRARY_DIR)\/jdk\/test\/lib\/ \\\n@@ -49,1 +50,1 @@\n-    -maxdepth 1 -name '*.java')\n+    -maxdepth 1 -name '*.java'))\n@@ -55,1 +56,0 @@\n-\t--add-exports java.base\/jdk.internal.module=ALL-UNNAMED \\\n@@ -57,3 +57,0 @@\n-\t--add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED \\\n-\t--add-exports java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED \\\n-\t--add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED \\\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/Makefile","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary_tests.ir_framework.tests;\n-\n-import compiler.lib.ir_framework.CompilePhase;\n-import compiler.lib.ir_framework.IR;\n-import compiler.lib.ir_framework.IRNode;\n-import compiler.lib.ir_framework.Test;\n-import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n-import compiler.lib.ir_framework.driver.irmatching.Matchable;\n-import compiler.lib.ir_framework.driver.irmatching.parser.TestClassParser;\n-import jdk.test.lib.Utils;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardCopyOption;\n-\n-\/*\n- * @test\n- * @bug 8300273\n- * @requires vm.debug == true & vm.flagless\n- * @summary Test TestClassParser such that it correctly parses the hotspot_pid* files with safepoint interruption messages\n- * @library \/test\/lib \/testlibrary_tests \/\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run junit\/othervm -Xbootclasspath\/a:. -DSkipWhiteBoxInstall=true -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                    -XX:+WhiteBoxAPI compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting\n- *\/\n-public class TestSafepointWhilePrinting {\n-    static int iFld;\n-\n-    @org.junit.Test\n-    public void test() throws IOException {\n-        String hotspotPidFileName = \"safepoint_while_printing_hotspot_pid.log\";\n-        Path hotspotPidFilePath = Paths.get(Utils.TEST_SRC).resolve(hotspotPidFileName);\n-        \/\/ Copy file to current workdir\n-        Files.copy(hotspotPidFilePath, Paths.get(\"\").resolve(hotspotPidFileName),\n-                   StandardCopyOption.REPLACE_EXISTING);\n-\n-        String irEncoding =\n-                \"\"\"\n-                ##### IRMatchRulesEncoding - used by TestFramework #####\n-                <method>,{comma separated applied @IR rule ids}\n-                test1,1\n-                test2,1\n-                testSafepointInBlock,1\n-                testQueueInBlock1,1\n-                testQueueInBlock2,1\n-                testDoubleInterruptOuter,1\n-                testDoubleInterruptMiddle,1\n-                testDoubleInterruptInner,1\n-                testCompilePhaseBackToBackFirst,1\n-                testCompilePhaseBackToBackLast,1\n-                ----- END -----\n-                ##### IRMatchingVMInfo - used by TestFramework #####\n-                <key>:<value>\n-                cpuFeatures:empty_cpu_info\n-                MaxVectorSize:64\n-                MaxVectorSizeIsDefault:1\n-                LoopMaxUnroll:64\n-                UseAVX:1\n-                UseAVXIsDefault:1\n-                ----- END VMInfo -----\n-                \"\"\";\n-        TestClassParser testClassParser = new TestClassParser(TestSafepointWhilePrinting.class);\n-        Matchable testClassMatchable = testClassParser.parse(hotspotPidFileName, irEncoding);\n-        IRMatcher matcher = new IRMatcher(testClassMatchable);\n-        matcher.match();\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CMP_UL3, \"1\"})\n-    public void test1() {\n-        iFld = 34;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CMP_UL3, \"1\"})\n-    public void test2() {\n-        iFld = 34;\n-    }\n-\n-    @Test\n-    @IR(counts = {\"testSafepointInBlock @ bci:-1\", \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n-    public void testSafepointInBlock() {\n-        iFld = 34;\n-    }\n-\n-    @Test\n-    @IR(counts = {\"testQueueInBlock1 @ bci:-1\", \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n-    public void testQueueInBlock1() {\n-        iFld = 34;\n-    }\n-\n-    @Test\n-    @IR(counts = {\"testQueueInBlock2 @ bci:-1\", \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n-    public void testQueueInBlock2() {\n-        iFld = 34;\n-    }\n-    @Test\n-    @IR(counts = {\"!jvms: TestSafepointWhilePrinting::testDoubleInterruptOuter\", \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n-    public void testDoubleInterruptOuter() {\n-        iFld = 34;\n-    }\n-\n-    @Test\n-    @IR(counts = {\"testDoubleInterruptMiddle @ bci:-1\", \"1\", IRNode.CMP_UL3, \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n-    public void testDoubleInterruptMiddle() {\n-        iFld = 34;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CON_L, \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n-    public void testDoubleInterruptInner() {\n-        iFld = 34;\n-    }\n-\n-    @Test\n-    @IR(counts = {\"(line 115)\", \"1\", IRNode.CMP_UL3, \"1\"}, phase = {CompilePhase.AFTER_PARSING, CompilePhase.BEFORE_MATCHING})\n-    public void testCompilePhaseBackToBackFirst() {\n-        iFld = 34;\n-    }\n-\n-    @Test\n-    @IR(counts = {\"(line 115)\", \"1\", IRNode.CMP_UL3, \"1\"}, phase = {CompilePhase.AFTER_PARSING, CompilePhase.BEFORE_MATCHING})\n-    public void testCompilePhaseBackToBackLast() {\n-        iFld = 34;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestSafepointWhilePrinting.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -1,163 +0,0 @@\n-<writer thread='1683653'\/>\n-   1682  967    b  3       jdk.test.lib.Asserts::assertEquals (7 bytes)\n-<nmethod compile_id='967' compiler='c1' level='3' entry='0x00007f29791d6440' size='912' address='0x00007f29791d6290' relocation_offset='352' insts_offset='432' stub_offset='648' scopes_data_offset='768' scopes_pcs_offset='808' dependencies_offset='904' oops_offset='752' metadata_offset='760' method='jdk.test.lib.Asserts assertEquals (Ljava\/lang\/Object;Ljava\/lang\/Object;)V' bytes='7' count='256' iicount='256' stamp='1.683'\/>\n-<writer thread='1683665'\/>\n-<task_queued compile_id='1013' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting test2 (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<writer thread='1683661'\/>\n-<task_queued compile_id='1008' method='java.util.Arrays copyOfRange ([Ljava\/lang\/Object;IILjava\/lang\/Class;)[Ljava\/lang\/Object;' bytes='90' count='257' iicount='257' level='3' blocking='1' stamp='1.714' comment='tiered' hot_count='256'\/>\n-<writer thread='1683666'\/>\n-<task_queued compile_id='1018' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting test1 (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<writer thread='1683670'\/>\n-<make_not_entrant thread='1683670' compile_id='995' compiler='c1' level='3' stamp='1.716'\/>\n-   1716  995       3       compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting::compareLongWithImm5 (8 bytes)   made not entrant\n-<writer thread='1683652'\/>\n-   1716 1018    b  4       compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting::test1 (8 bytes)\n-<writer thread='1683665'\/>\n-<task_queued compile_id='53' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testSafepointInBlock (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<writer thread='1683653'\/>\n-   1716 1008    b  3       java.util.Arrays::copyOfRange (90 bytes)\n-<writer thread='1683670'\/>\n-   1716 1013    b  4       compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting::test2 (8 bytes)\n-<writer thread='1683663'\/>\n-<task_queued compile_id='1019' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting notATest (I)I' bytes='7' count='1000' iicount='1000' blocking='1' stamp='1.716' comment='whitebox' hot_count='1000'\/>\n-<writer thread='1683652'\/>\n-<ideal compile_id='1018' compile_phase='print_ideal'>\n-AFTER: print_ideal\n-  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n-  3  Start  === 3 0  [[ 3 5 6 7 8 9 11 ]]  #{0:control, 1:abIO, 2:memory, 3:rawptr:BotPTR, 4:return_address, 5:compiler\/intrinsics\/TestSafepointWhilePrinting:NotNull *, 6:long, 7:half}\n-  5  Parm  === 3  [[ 26 ]] Control !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n-  6  Parm  === 3  [[ 26 ]] I_O !jvms:<!-- safepoint while printing -->\n-<writer thread='1683670'\/>\n-<ideal compile_id='1013' compile_phase='print_ideal'>\n-AFTER: print_ideal\n-  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n-  3  Start  === 3 0  [[ 3 5 6 7 8 9 11 ]]  #{0:control, 1:abIO, 2:memory, 3:rawptr:BotPTR, 4:return_address, 5:compiler\/intrinsics\/TestSafepointWhilePrinting:NotNull *, 6:long, 7:half}\n-  5  Parm  === 3  [[ 26 ]] Control !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n-  6  Parm  === 3  [[ 26 ]] I_O !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n-  7  Parm  === 3  [[ 26 ]] Memory  Memory: @BotPTR *+bot, idx=Bot; !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n-  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n-  9  Parm  === 3  [[ 26 ]] ReturnAdr !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n- 11  Parm  === 3  [[ 25 ]] Parm1: long !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n- 24  ConL  === 0  [[ 25 ]]  #long:42\n- 25  CmpUL3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test2 @ bci:4 (line 109)\n- 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n-<\/ideal>\n-<writer thread='1683652'\/>\n- TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n-  7  Parm  === 3  [[ 26 ]] Memory  Memory: @BotPTR *+bot, idx=Bot; !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n-  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n-  9  Parm  === 3  [[ 26 ]] ReturnAdr !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n- 11  Parm  === 3  [[ 25 ]] Parm1: long !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n- 24  ConL  === 0  [[ 25 ]]  #long:172032\n- 25  CmpUL3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (line 115)\n- 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n-<\/ideal>\n-<writer thread='1875264'\/>\n-<nmethod compile_id='1017' compiler='c2' level='4' entry='0x00007fa74cc08ea0' size='664' address='0x00007fa74cc08d10' relocation_offset='352' insts_offset='400' stub_offset='536' scopes_data_offset='576'\n- scopes_pcs_offset='592' dependencies_offset='656' oops_offset='560' metadata_offset='568' method='compiler.intrinsics.TestCompareUnsigned compareLongWithImm3 (J)I' bytes='8' count='1000' iicount='1000'\n-stamp='1.785'\/>\n-<make_not_entrant thread='1875264' compile_id='993' compiler='c1' level='3' stamp='1.785'\/>\n-   1784  993       3       compiler.intrinsics.TestCompareUnsigned::compareLongWithImm3 (8 bytes)   made not entrant\n-   1784 1013    b  4       compiler.intrinsics.TestCompareUnsigned::compareLongWithImm1 (8 bytes)\n-<ideal compile_id='53' compile_phase='print_ideal'>\n-AFTER: print_ideal\n-  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n-  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::testSafepointInBlock<!-- safepoint while printing -->\n- @ bci:-1 (line 109)\n- 24  ConL  === 0  [[ 25 ]]  #long:42\n- 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n-<\/ideal>\n-<writer thread='5165446'\/>\n-<task_queued compile_id='54' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testQueueInBlock1 (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<writer thread='234'\/>\n-<ideal compile_id='54' compile_phase='print_ideal'>\n-AFTER: print_ideal\n-  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n-  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::testQueueInBlock1<!-- safepoint while printing -->\n-<writer thread='235'\/>\n-<task_queued compile_id='55' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testQueueInBlock2 (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<writer thread='234'\/>\n- @ bci:-1 (line 109)\n- 24  ConL  === 0  [[ 25 ]]  #long:42\n- 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n-<\/ideal>\n-<ideal compile_id='55' compile_phase='print_ideal'>\n-AFTER: print_ideal\n-  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n-  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::testQueueInBlock2<!-- safepoint while printing -->\n- @ bci:-1 (line 109)\n- 24  ConL  === 0  [[ 25 ]]  #long:42\n- 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n-<\/ideal>\n-<writer thread='343523525'\/>\n-<task_queued compile_id='61' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testDoubleInterruptOuter (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<writer thread='343523525'\/>\n-<task_queued compile_id='62' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testDoubleInterruptMiddle (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<writer thread='1001'\/>\n-<ideal compile_id='61' compile_phase='print_ideal'>\n-AFTER: print_ideal\n-  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n-  3  Start  === 3 0  [[ 3 5 6 7 8 9 11 ]]  #{0:control, 1:abIO, 2:memory, 3:rawptr:BotPTR, 4:return_address, 5:compiler\/intrinsics\/TestSafepointWhilePrinting:NotNull *, 6:long, 7:half}\n-  6  Parm  === 3  [[ 26 ]] I_O !jvms:<!-- safepoint while printing -->\n-<writer thread='1002'\/>\n-<ideal compile_id='62' compile_phase='print_ideal'>\n-AFTER: print_ideal\n-  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n-  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::testDoubleInterruptMiddle<!-- safepoint while printing -->\n- @ bci:-1 (line 109)\n- 25  Cmp<!-- safepoint while printing -->\n-<writer thread='9999'\/>\n-<task_queued compile_id='63' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testDoubleInterruptInner (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<writer thread='1003'\/>\n-<ideal compile_id='63' compile_phase='print_ideal'>\n-  24  ConL  === 0  [[ 25 ]]  #long:42\n-  26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n-<\/ideal>\n-<writer thread='1002'\/>\n-UL3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test2 @ bci:4 (line 109)\n- 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n-<\/ideal>\n-<writer thread='1001'\/>\n- TestSafepointWhilePrinting::testDoubleInterruptOuter @ bci:-1 (line 115)\n-  7  Parm  === 3  [[ 26 ]] Memory  Memory: @BotPTR *+bot, idx=Bot; !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n-  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n-  9  Parm  === 3  [[ 26 ]] ReturnAdr !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n- 11  Parm  === 3  [[ 25 ]] Parm1: long !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n- 24  ConL  === 0  [[ 25 ]]  #long:172032\n- 25  CmpUL3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (line 115)\n- 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n-<\/ideal>\n-<writer thread='100000'\/>\n-<task_queued compile_id='72' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testCompilePhaseBackToBackFirst (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<writer thread='72'\/>\n-<ideal compile_id='72' compile_phase='AFTER_PARSING'>\n- 24  ConL  === 0  [[ 25 ]]  #long:172032\n- 25  CmpUL<!-- safepoint while printing -->\n-<writer thread='71'\/>\n-<task_queued compile_id='71' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testCompilePhaseBackToBackLast (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<ideal compile_id='71' compile_phase='AFTER_PARSING'>\n- 24  ConL  === 0  [[ 25 ]]  #long:172032\n- 25  CmpUL3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (line 115)\n-<\/ideal>\n-<ideal compile_id='71' compile_phase='BEFORE_MATCHING'>\n- 24  ConL  === 0  [[ 25 ]]  #long:172032\n- 25  CmpU<!-- safepoint while printing -->\n-<writer thread='72'\/>\n-3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (<!-- safepoint while printing -->\n-<writer thread='71'\/>\n-L3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (line <!-- safepoint while printing -->\n-<writer thread='72'\/>\n-line 115)\n-<\/ideal>\n-<writer thread='9999'\/>\n-<task_queued compile_id='3333' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting asdf (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n-<writer thread='72'\/>\n-<ideal compile_id='72' compile_phase='BEFORE_MATCHING'>\n- 24  ConL  === 0  [[ 25 ]]  #long:172032\n- 25  CmpU<!-- safepoint while printing -->\n-<writer thread='71'\/>\n-115)\n-<\/ideal>\n-<writer thread='72'\/>\n-L3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (line 115)\n-<\/ideal>\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/safepoint_while_printing_hotspot_pid.log","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package common.dtd;\n+\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.stream.XMLInputFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.xml.sax.XMLReader;\n+\n+\/*\n+ * @test\n+ * @bug 8322214\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @run testng common.dtd.DTDPropertiesTest\n+ * @summary Verifies the getProperty function on DTD properties works the same\n+ * as before the property 'jdk.xml.dtd.support' was introduced.\n+ *\/\n+public class DTDPropertiesTest {\n+    \/\/ Xerces Property\n+    public static final String DISALLOW_DTD = \"http:\/\/apache.org\/xml\/features\/disallow-doctype-decl\";\n+\n+    \/*\n+     * DataProvider for verifying Xerces' disallow-DTD feature\n+     * Fields: property name, setting (null indicates not specified), expected\n+     *\/\n+    @DataProvider(name = \"XercesProperty\")\n+    public Object[][] getXercesProperty() throws Exception {\n+        return new Object[][] {\n+            { DISALLOW_DTD, null, false},\n+            { DISALLOW_DTD, true, true},\n+            { DISALLOW_DTD, false, false},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for verifying StAX's supportDTD feature\n+     * Fields: property name, setting (null indicates not specified), expected\n+     *\/\n+    @DataProvider(name = \"StAXProperty\")\n+    public Object[][] getStAXProperty() throws Exception {\n+        return new Object[][] {\n+            { XMLInputFactory.SUPPORT_DTD, null, true},\n+            { XMLInputFactory.SUPPORT_DTD, true, true},\n+            { XMLInputFactory.SUPPORT_DTD, false, false},\n+        };\n+    }\n+\n+    \/**\n+     * Verifies the disallow DTD feature with SAX.\n+     *\n+     * @param name the name of the property\n+     * @param setting the setting of the property, null means not specified\n+     * @param expected the expected value\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"XercesProperty\")\n+    public void testSAX(String name, Boolean setting, Boolean expected) throws Exception {\n+        SAXParserFactory spf = SAXParserFactory.newDefaultInstance();\n+        if (setting != null) {\n+            spf.setFeature(name, setting);\n+        }\n+        Assert.assertEquals((Boolean)spf.getFeature(name), expected);\n+        System.out.println(spf.getFeature(name));\n+\n+\n+        SAXParser saxParser = spf.newSAXParser();\n+        XMLReader reader = saxParser.getXMLReader();\n+        Assert.assertEquals((Boolean)reader.getFeature(name), expected);\n+        System.out.println(reader.getFeature(name));\n+    }\n+\n+    \/**\n+     * Verifies the disallow DTD feature with DOM.\n+     *\n+     * @param name the name of the property\n+     * @param setting the setting of the property, null means not specified\n+     * @param expected the expected value\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"XercesProperty\")\n+    public void testDOM(String name, Boolean setting, Boolean expected) throws Exception {\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newDefaultInstance();\n+        if (setting != null) {\n+            dbf.setFeature(name, setting);\n+        }\n+        Assert.assertEquals((Boolean)dbf.getFeature(name), expected);\n+        System.out.println(dbf.getFeature(name));\n+    }\n+\n+    \/**\n+     * Verifies the StAX's supportDTD feature.\n+     *\n+     * @param name the name of the property\n+     * @param setting the setting of the property, null means not specified\n+     * @param expected the expected value\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"StAXProperty\")\n+    public void testStAX(String name, Boolean setting, Boolean expected) throws Exception {\n+        XMLInputFactory xif = XMLInputFactory.newInstance();\n+        if (setting != null) {\n+            xif.setProperty(name, setting);\n+        }\n+        Assert.assertEquals((Boolean)xif.getProperty(name), expected);\n+        System.out.println((Boolean)xif.getProperty(name));\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/dtd\/DTDPropertiesTest.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 8309218 generic-all\n","filename":"test\/jdk\/ProblemList-generational-zgc.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 8309218 generic-all\n-\n","filename":"test\/jdk\/ProblemList-zgc.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-        expectedExceptionsMessageRegExp=\".*Negative offset.*\")\n+        expectedExceptionsMessageRegExp=\".*offset is negative.*\")\n@@ -380,1 +380,1 @@\n-        expectedExceptionsMessageRegExp=\".*Negative index.*\")\n+        expectedExceptionsMessageRegExp=\".*index is negative.*\")\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,0 +167,7 @@\n+    @Test(dataProvider = \"segmentAccessors\")\n+    public <X, L extends ValueLayout> void negativeOffset(String testName, Accessor<X, L> accessor) {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[100]);\n+        assertThrows(IndexOutOfBoundsException.class, () -> accessor.get(segment, -ValueLayout.JAVA_LONG.byteSize()));\n+        assertThrows(IndexOutOfBoundsException.class, () -> accessor.set(segment, -ValueLayout.JAVA_LONG.byteSize(), accessor.value));\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -138,0 +139,2 @@\n+        var source = MemorySegment.ofArray(new byte[]{});\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_INT, source, JAVA_BYTE, 0, 1), \"Arena::allocateFrom\/5arg\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n@@ -192,0 +194,75 @@\n+    \/\/ Invariant checking tests for the SegmentAllocator method:\n+    \/\/ MemorySegment allocateFrom(ValueLayout elementLayout,\n+    \/\/                            MemorySegment source,\n+    \/\/                            ValueLayout sourceElementLayout,\n+    \/\/                            long sourceOffset,\n+    \/\/                            long elementCount) {\n+    @Test\n+    public void testAllocatorAllocateFromArguments() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            var sourceElements = 2;\n+            var source = arena.allocate(ValueLayout.JAVA_LONG, sourceElements);\n+            var elementLayout = ValueLayout.JAVA_INT;\n+            var sourceElementLayout = ValueLayout.JAVA_INT;\n+\n+            \/\/ IllegalArgumentException if {@code elementLayout.byteSize() != sourceElementLayout.byteSize()}\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    arena.allocateFrom(elementLayout, source, ValueLayout.JAVA_BYTE, 0, 1)\n+            );\n+\n+            \/\/ IllegalArgumentException if source segment\/offset\n+            \/\/ are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+            \/\/ in the source element layout\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    arena.allocateFrom(elementLayout, source.asSlice(1), sourceElementLayout, 0, 1)\n+            );\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    arena.allocateFrom(elementLayout, source, sourceElementLayout, 1, 1)\n+            );\n+\n+            \/\/ IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    arena.allocateFrom(elementLayout.withByteAlignment(elementLayout.byteAlignment() * 2), source, sourceElementLayout, 1, 1)\n+            );\n+\n+            \/\/ IllegalStateException if the {@linkplain MemorySegment#scope() scope} associated\n+            \/\/ with {@code source} is not {@linkplain MemorySegment.Scope#isAlive() alive}\n+            \/\/ This is tested in TestScopedOperations\n+\n+            \/\/ WrongThreadException if this method is called from a thread {@code T},\n+            \/\/ such that {@code source.isAccessibleBy(T) == false}\n+            CompletableFuture<Arena> future = CompletableFuture.supplyAsync(Arena::ofConfined);\n+            try {\n+                Arena otherThreadArena = future.get();\n+                assertThrows(WrongThreadException.class, () ->\n+                        otherThreadArena.allocateFrom(elementLayout, source, sourceElementLayout, 0, 1)\n+                );\n+            } catch (ExecutionException | InterruptedException e) {\n+                fail(\"Unable to create arena\", e);\n+            }\n+\n+            \/\/ IllegalArgumentException if {@code elementCount * sourceElementLayout.byteSize()} overflows\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    arena.allocateFrom(elementLayout, source, sourceElementLayout, 0, Long.MAX_VALUE)\n+            );\n+\n+            \/\/ IndexOutOfBoundsException if {@code sourceOffset > source.byteSize() - (elementCount * sourceElementLayout.byteSize())}\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(elementLayout, source, sourceElementLayout, source.byteSize() - (1 * sourceElementLayout.byteAlignment()) + elementLayout.byteSize(), 1)\n+            );\n+\n+            \/\/ IndexOutOfBoundsException if {@code sourceOffset < 0}\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(elementLayout, source, sourceElementLayout, -elementLayout.byteSize(), 1)\n+            );\n+\n+            \/\/ IllegalArgumentException if {@code elementCount < 0}\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    arena.allocateFrom(elementLayout, source, sourceElementLayout, 0, -1)\n+            );\n+\n+\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -148,0 +148,60 @@\n+    @Test\n+    public void testCopy5ArgWithNegativeValues() {\n+        MemorySegment src = MemorySegment.ofArray(new byte[] {1, 2, 3, 4});\n+        MemorySegment dst = MemorySegment.ofArray(new byte[] {1, 2, 3, 4});\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, -1, dst, 0, 4)\n+        );\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, 0, dst, -1, 4)\n+        );\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, 0, dst, 0, -1)\n+        );\n+    }\n+\n+    @Test\n+    public void testCopy7ArgWithNegativeValues() {\n+        MemorySegment src = MemorySegment.ofArray(new byte[] {1, 2, 3, 4});\n+        MemorySegment dst = MemorySegment.ofArray(new byte[] {1, 2, 3, 4});\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, JAVA_BYTE, -1, dst, JAVA_BYTE, 0, 4)\n+        );\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, JAVA_BYTE, 0, dst, JAVA_BYTE, -1, 4)\n+        );\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, JAVA_BYTE, 0, dst, JAVA_BYTE, 0, -1)\n+        );\n+    }\n+\n+    @Test\n+    public void testCopyFromArrayWithNegativeValues() {\n+        MemorySegment src = MemorySegment.ofArray(new byte[] {1, 2, 3, 4});\n+        byte[] dst = new byte[] {1, 2, 3, 4};\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, JAVA_BYTE, -1, dst, 0, 4)\n+        );\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, JAVA_BYTE, 0, dst, -1, 4)\n+        );\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, JAVA_BYTE, 0, dst, 0, -1)\n+        );\n+    }\n+\n+    @Test\n+    public void testCopyToArrayWithNegativeValues() {\n+        byte[] src = new byte[] {1, 2, 3, 4};\n+        MemorySegment dst = MemorySegment.ofArray(new byte[] {1, 2, 3, 4});\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, -1, dst, JAVA_BYTE, 0, 4)\n+        );\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, 0, dst, JAVA_BYTE, -1, 4)\n+        );\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                MemorySegment.copy(src, 0, dst, JAVA_BYTE, 0, -1)\n+        );\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -58,2 +59,1 @@\n-            Arena session = arena;\n-            var segment = session.allocate(0, 1);\n+            var segment = arena.allocate(0, 1);\n@@ -62,1 +62,1 @@\n-            segment = session.allocate(seq);\n+            segment = arena.allocate(seq);\n@@ -65,1 +65,1 @@\n-            segment = session.allocate(0, 4);\n+            segment = arena.allocate(0, 4);\n@@ -136,2 +136,1 @@\n-            Arena scope1 = arena;\n-            MemorySegment segment = scope1.allocate(100, 1);\n+            MemorySegment segment = arena.allocate(100, 1);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.concurrent.TimeoutException;\n@@ -33,1 +34,1 @@\n-import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n@@ -53,11 +54,13 @@\n-        Process process = ProcessTools.createTestJavaProcessBuilder(command).start();\n-\n-        long timeOut = (long) (Utils.TIMEOUT_FACTOR * 1L);\n-        boolean completed = process.waitFor(timeOut, TimeUnit.MINUTES);\n-        assertTrue(completed, \"Time out while waiting for process\");\n-\n-        OutputAnalyzer output = new OutputAnalyzer(process);\n-        output.outputTo(System.out);\n-        output.errorTo(System.err);\n-\n-        return output;\n+        try {\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+            \/\/ note that it's important to use ProcessTools.startProcess here since this makes sure output streams of the\n+            \/\/ fork don't fill up, which could make the process stall while writing to stdout\/stderr\n+            Process process = ProcessTools.startProcess(target.getName(), pb, null, null, 1L, TimeUnit.MINUTES);\n+            OutputAnalyzer output = new OutputAnalyzer(process);\n+            output.outputTo(System.out);\n+            output.errorTo(System.err);\n+            return output;\n+        } catch (TimeoutException e) {\n+            fail(\"Timeout while waiting for forked process\");\n+            return null;\n+        }\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6298888 6992705 8161500 6304578\n+ * @bug 6298888 6992705 8161500 6304578 8322878\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n@@ -40,0 +39,2 @@\n+    private static record PlatformTestCase(Class<?> clazz, String expected) {}\n+\n@@ -46,13 +47,27 @@\n-        Map<Class<?>, String> testCases =\n-            Map.of(int.class,                          \"int\",\n-                   void.class,                         \"void\",\n-                   args.getClass(),                    \"java.lang.String[]\",\n-                   nested.getClass(),                  \"java.lang.String[][]\",\n-                   intArray.getClass(),                \"int[][]\",\n-                   java.lang.Enum.class,               \"public abstract class java.lang.Enum<E extends java.lang.Enum<E>>\",\n-                   java.util.Map.class,                \"public abstract interface java.util.Map<K,V>\",\n-                   java.util.EnumMap.class,            \"public class java.util.EnumMap<K extends java.lang.Enum<K>,V>\",\n-                   java.util.EventListenerProxy.class, \"public abstract class java.util.EventListenerProxy<T extends java.util.EventListener>\");\n-\n-        for (Map.Entry<Class<?>, String> testCase : testCases.entrySet()) {\n-            failures += checkToGenericString(testCase.getKey(), testCase.getValue());\n+       List<PlatformTestCase> platformTestCases =\n+           List.of(new PlatformTestCase(int.class,           \"int\"),\n+                   new PlatformTestCase(void.class,          \"void\"),\n+                   new PlatformTestCase(args.getClass(),     \"java.lang.String[]\"),\n+                   new PlatformTestCase(nested.getClass(),   \"java.lang.String[][]\"),\n+                   new PlatformTestCase(intArray.getClass(), \"int[][]\"),\n+\n+                   new PlatformTestCase(java.lang.Enum.class,\n+                                        \"public abstract class java.lang.Enum<E extends java.lang.Enum<E>>\"),\n+                   new PlatformTestCase(java.util.Map.class,\n+                                        \"public abstract interface java.util.Map<K,V>\"),\n+                   new PlatformTestCase(java.util.EnumMap.class,\n+                                        \"public class java.util.EnumMap<K extends java.lang.Enum<K>,V>\"),\n+                   new PlatformTestCase(java.util.EventListenerProxy.class,\n+                                        \"public abstract class java.util.EventListenerProxy<T extends java.util.EventListener>\"),\n+\n+                   \/\/ Sealed class\n+                   new PlatformTestCase(java.lang.ref.Reference.class,\n+                                     \"public abstract sealed class java.lang.ref.Reference<T>\"),\n+                   \/\/ non-sealed class\n+                   new PlatformTestCase(java.lang.ref.WeakReference.class,\n+                                     \"public non-sealed class java.lang.ref.WeakReference<T>\")\n+                   );\n+\n+        for (PlatformTestCase platformTestCase : platformTestCases) {\n+            failures += checkToGenericString(platformTestCase.clazz,\n+                                             platformTestCase.expected);\n@@ -73,1 +88,27 @@\n-                                     AnotherEnum.class)) {\n+                                     AnotherEnum.class,\n+\n+                                     SealedRootClass.class,\n+                                     SealedRootClass.ChildA.class,\n+                                     SealedRootClass.ChildB.class,\n+                                     SealedRootClass.ChildB.GrandChildAB.class,\n+                                     SealedRootClass.ChildC.class,\n+                                     SealedRootClass.ChildC.GrandChildACA.class,\n+                                     SealedRootClass.ChildC.GrandChildACB.class,\n+                                     SealedRootClass.ChildC.GrandChildACC.class,\n+                                     SealedRootClass.ChildC.GrandChildACC.GreatGrandChildACCA.class,\n+                                     SealedRootClass.ChildC.GrandChildACC.GreatGrandChildACCB.class,\n+\n+                                     SealedRootIntf.class,\n+                                     SealedRootIntf.ChildA.class,\n+                                     SealedRootIntf.ChildB.class,\n+                                     SealedRootIntf.ChildB.GrandChildAB.class,\n+                                     SealedRootIntf.ChildC.class,\n+                                     SealedRootIntf.ChildC.GrandChildACA.class,\n+                                     SealedRootIntf.ChildC.GrandChildACB.class,\n+                                     SealedRootIntf.ChildC.GrandChildACC.class,\n+                                     SealedRootIntf.ChildC.GrandChildACC.GreatGrandChildACCA.class,\n+                                     SealedRootIntf.ChildC.GrandChildACC.GreatGrandChildACCB.class,\n+                                     SealedRootIntf.IntfA.class,\n+                                     SealedRootIntf.IntfA.IntfAImpl.class,\n+                                     SealedRootIntf.IntfB.class,\n+                                     SealedRootIntf.IntfB.IntfAImpl.class)) {\n@@ -110,1 +151,4 @@\n-@ExpectedGenericString(\"enum AnotherEnum\")\n+\/\/ If an enum class has a specialized enum constant, that is compiled\n+\/\/ by having the enum class as being sealed rather than final. See JLS\n+\/\/ 8.9 Enum Classes.\n+@ExpectedGenericString(\"sealed enum AnotherEnum\")\n@@ -114,0 +158,92 @@\n+\n+\/\/ Test cases for sealed\/non-sealed _class_ hierarchy.\n+@ExpectedGenericString(\"sealed class SealedRootClass\")\n+sealed class SealedRootClass\n+    permits\n+    SealedRootClass.ChildA,\n+    SealedRootClass.ChildB,\n+    SealedRootClass.ChildC {\n+\n+    @ExpectedGenericString(\"final class SealedRootClass$ChildA\")\n+    final class ChildA extends SealedRootClass {}\n+\n+    @ExpectedGenericString(\"sealed class SealedRootClass$ChildB\")\n+    sealed class ChildB extends SealedRootClass permits SealedRootClass.ChildB.GrandChildAB {\n+        @ExpectedGenericString(\"final class SealedRootClass$ChildB$GrandChildAB\")\n+        final class GrandChildAB extends ChildB {}\n+    }\n+\n+    @ExpectedGenericString(\"non-sealed class SealedRootClass$ChildC\")\n+    non-sealed class ChildC extends SealedRootClass {\n+        \/\/ The subclasses of ChildC do not themselves have to be\n+        \/\/ sealed, non-sealed, or final.\n+        @ExpectedGenericString(\"class SealedRootClass$ChildC$GrandChildACA\")\n+        class GrandChildACA extends ChildC {}\n+\n+        @ExpectedGenericString(\"final class SealedRootClass$ChildC$GrandChildACB\")\n+        final class GrandChildACB extends ChildC {}\n+\n+        @ExpectedGenericString(\"sealed class SealedRootClass$ChildC$GrandChildACC\")\n+        sealed class GrandChildACC extends ChildC {\n+            @ExpectedGenericString(\"final class SealedRootClass$ChildC$GrandChildACC$GreatGrandChildACCA\")\n+            final class GreatGrandChildACCA extends GrandChildACC {}\n+\n+            @ExpectedGenericString(\"non-sealed class SealedRootClass$ChildC$GrandChildACC$GreatGrandChildACCB\")\n+            non-sealed class GreatGrandChildACCB extends GrandChildACC {}\n+        }\n+    }\n+}\n+\n+\/\/ Test cases for sealed\/non-sealed _interface_ hierarchy.\n+@ExpectedGenericString(\"abstract sealed interface SealedRootIntf\")\n+sealed interface SealedRootIntf\n+    permits\n+    SealedRootIntf.ChildA,\n+    SealedRootIntf.ChildB,\n+    SealedRootIntf.ChildC,\n+\n+    SealedRootIntf.IntfA,\n+    SealedRootIntf.IntfB {\n+\n+    @ExpectedGenericString(\"public static final class SealedRootIntf$ChildA\")\n+    final class ChildA implements SealedRootIntf {}\n+\n+    @ExpectedGenericString(\"public static sealed class SealedRootIntf$ChildB\")\n+    sealed class ChildB implements SealedRootIntf permits SealedRootIntf.ChildB.GrandChildAB {\n+        @ExpectedGenericString(\"final class SealedRootIntf$ChildB$GrandChildAB\")\n+        final class GrandChildAB extends ChildB {}\n+    }\n+\n+    @ExpectedGenericString(\"public static non-sealed class SealedRootIntf$ChildC\")\n+    non-sealed class ChildC implements SealedRootIntf {\n+        \/\/ The subclasses of ChildC do not themselves have to be\n+        \/\/ sealed, non-sealed, or final.\n+        @ExpectedGenericString(\"class SealedRootIntf$ChildC$GrandChildACA\")\n+        class GrandChildACA extends ChildC {}\n+\n+        @ExpectedGenericString(\"final class SealedRootIntf$ChildC$GrandChildACB\")\n+        final class GrandChildACB extends ChildC {}\n+\n+        @ExpectedGenericString(\"sealed class SealedRootIntf$ChildC$GrandChildACC\")\n+        sealed class GrandChildACC extends ChildC {\n+            @ExpectedGenericString(\"final class SealedRootIntf$ChildC$GrandChildACC$GreatGrandChildACCA\")\n+            final class GreatGrandChildACCA extends GrandChildACC {}\n+\n+            @ExpectedGenericString(\"non-sealed class SealedRootIntf$ChildC$GrandChildACC$GreatGrandChildACCB\")\n+            non-sealed class GreatGrandChildACCB extends GrandChildACC {}\n+        }\n+    }\n+\n+    @ExpectedGenericString(\"public abstract static sealed interface SealedRootIntf$IntfA\")\n+    sealed interface IntfA extends  SealedRootIntf {\n+        @ExpectedGenericString(\"public static non-sealed class SealedRootIntf$IntfA$IntfAImpl\")\n+        non-sealed class IntfAImpl implements IntfA {}\n+    }\n+\n+    @ExpectedGenericString(\"public abstract static non-sealed interface SealedRootIntf$IntfB\")\n+    non-sealed interface IntfB extends  SealedRootIntf {\n+        \/\/ Check that non-sealing can be allowed with a second superinterface being sealed.\n+        @ExpectedGenericString(\"public static non-sealed class SealedRootIntf$IntfB$IntfAImpl\")\n+        non-sealed class IntfAImpl implements IntfB, IntfA  {}\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Class\/GenericStringTest.java","additions":154,"deletions":18,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @bug 8302323\n+ * @bug 8302323 8322512\n@@ -132,0 +132,13 @@\n+        \/\/ toStringCache\n+\n+        sb.setLength(0);\n+        sb.toString();\n+        sb.repeat('*', 5);\n+        expected = \"*****\";\n+        assertEquals(sb.toString(), expected);\n+        sb.setLength(0);\n+        sb.toString();\n+        sb.repeat(\"*\", 5);\n+        assertEquals(sb.toString(), expected);\n+\n+\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/StringBufferRepeat.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8284161 8289284\n+ * @bug 8284161 8289284 8322846\n@@ -37,0 +37,1 @@\n+import java.util.concurrent.Executors;\n@@ -70,0 +71,1 @@\n+        assertContains(output, \"reason:MONITOR\");\n@@ -71,1 +73,0 @@\n-        assertDoesNotContain(output, \"(Native Method)\");\n@@ -81,0 +82,1 @@\n+        assertContains(output, \"reason:NATIVE\");\n@@ -82,1 +84,60 @@\n-        assertDoesNotContain(output, \"<== monitors\");\n+    }\n+\n+    \/**\n+     * Test parking in class initializer.\n+     *\/\n+    @Test\n+    void testPinnedCausedByClassInitializer() throws Exception {\n+        class C {\n+            static {\n+                park();\n+            }\n+        }\n+        String output = run(C::new);\n+        assertContains(output, \"reason:NATIVE\");\n+        assertContains(output, \"<clinit>\");\n+    }\n+\n+    \/**\n+     * Test contention writing to System.out when pinned. The test creates four threads\n+     * that write to System.out when pinned, this is enough to potentially deadlock\n+     * without the changes in JDK-8322846.\n+     *\/\n+    @Test\n+    void testContention() throws Exception {\n+        \/\/ use several classes to avoid duplicate stack traces\n+        class C1 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+        class C2 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+        class C3 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+        class C4 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            executor.submit(() -> {\n+                new C1().print();\n+            });\n+            executor.submit(() -> {\n+                new C2().print();\n+            });\n+            executor.submit(() -> {\n+                new C3().print();\n+            });\n+            executor.submit(() -> {\n+                new C4().print();\n+            });\n+        }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/TracePinnedThreads.java","additions":65,"deletions":4,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8322818\n+ * @summary Stress test Thread.getStackTrace on a virtual thread that is pinned\n+ * @requires vm.debug != true\n+ * @run main GetStackTraceALotWhenPinned 25000\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true\n+ * @run main\/timeout=300 GetStackTraceALotWhenPinned 10000\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class GetStackTraceALotWhenPinned {\n+\n+    public static void main(String[] args) throws Exception {\n+        var counter = new AtomicInteger(Integer.parseInt(args[0]));\n+\n+        \/\/ Start a virtual thread that loops doing Thread.yield and parking while pinned.\n+        \/\/ This loop creates the conditions for the main thread to sample the stack trace\n+        \/\/ as it transitions from being unmounted to parking while pinned.\n+        var thread = Thread.startVirtualThread(() -> {\n+            boolean timed = false;\n+            while (counter.decrementAndGet() > 0) {\n+                Thread.yield();\n+                synchronized (GetStackTraceALotWhenPinned.class) {\n+                    if (timed) {\n+                        LockSupport.parkNanos(Long.MAX_VALUE);\n+                    } else {\n+                        LockSupport.park();\n+                    }\n+                }\n+                timed = !timed;\n+            }\n+        });\n+\n+        long lastTimestamp = System.currentTimeMillis();\n+        while (thread.isAlive()) {\n+            thread.getStackTrace();\n+            LockSupport.unpark(thread);\n+            long currentTime = System.currentTimeMillis();\n+            if ((currentTime - lastTimestamp) > 500) {\n+                System.out.format(\"%s %d remaining ...%n\", Instant.now(), counter.get());\n+                lastTimestamp = currentTime;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenPinned.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng InterruptibleOrNot\n+ * @run junit InterruptibleOrNot\n@@ -43,4 +43,1 @@\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n+import java.util.Arrays;\n@@ -49,2 +46,4 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.function.Executable;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -52,1 +51,0 @@\n-@Test\n@@ -54,0 +52,2 @@\n+    \/\/ DatagramChannel implementation class\n+    private static String dcImplClassName;\n@@ -55,18 +55,5 @@\n-    public void testInterruptBeforeInterruptibleReceive() throws Exception {\n-        testInterruptBeforeReceive(true);\n-    }\n-\n-    public void testInterruptDuringInterruptibleReceive() throws Exception {\n-        testInterruptDuringReceive(true);\n-    }\n-\n-    public void testInterruptBeforeUninterruptibleReceive() throws Exception {\n-        testInterruptBeforeReceive(false);\n-    }\n-\n-    public void testInterruptDuringUninterruptibleReceive() throws Exception {\n-        testInterruptDuringReceive(false);\n-    }\n-\n-    public void testInterruptBeforeInterruptibleSend() throws Exception {\n-        testInterruptBeforeSend(true);\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            dcImplClassName = dc.getClass().getName();\n+        }\n@@ -75,2 +62,14 @@\n-    public void testInterruptBeforeUninterruptibleSend() throws Exception {\n-        testInterruptBeforeSend(false);\n+    \/**\n+     * Call DatagramChannel.receive with the interrupt status set, the DatagramChannel\n+     * is interruptible.\n+     *\/\n+    @Test\n+    public void testInterruptBeforeInterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            Thread.currentThread().interrupt();\n+            assertThrows(ClosedByInterruptException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n+        } finally {\n+            Thread.interrupted();  \/\/ clear interrupt status\n+        }\n@@ -80,1 +79,2 @@\n-     * Test invoking DatagramChannel receive with interrupt status set\n+     * Test interrupting a thread blocked in DatagramChannel.receive, the DatagramChannel\n+     * is interruptible.\n@@ -82,13 +82,8 @@\n-    static void testInterruptBeforeReceive(boolean interruptible)\n-        throws Exception\n-    {\n-        try (DatagramChannel dc = openDatagramChannel(interruptible)) {\n-            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n-            Future<?> timeout = scheduleClose(dc, Duration.ofSeconds(2));\n-            try {\n-                ByteBuffer buf = ByteBuffer.allocate(100);\n-                Thread.currentThread().interrupt();\n-                assertThrows(expectedException(interruptible), () -> dc.receive(buf));\n-            } finally {\n-                timeout.cancel(false);\n-            }\n+    @Test\n+    public void testInterruptDuringInterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            Thread thread = Thread.currentThread();\n+            onReceive(thread::interrupt);\n+            assertThrows(ClosedByInterruptException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n@@ -96,1 +91,1 @@\n-            Thread.interrupted();  \/\/ clear interrupt\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -101,1 +96,2 @@\n-     * Test Thread.interrupt when target thread is blocked in DatagramChannel receive\n+     * Call DatagramChannel.receive with the interrupt status set, the DatagramChannel\n+     * is not interruptible.\n@@ -103,14 +99,12 @@\n-    static void testInterruptDuringReceive(boolean interruptible)\n-        throws Exception\n-    {\n-        try (DatagramChannel dc = openDatagramChannel(interruptible)) {\n-            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n-            Future<?> timerTask = scheduleClose(dc, Duration.ofSeconds(5));\n-            Future<?> interruptTask = scheduleInterrupt(Thread.currentThread(), Duration.ofSeconds(1));\n-            try {\n-                ByteBuffer buf = ByteBuffer.allocate(100);\n-                assertThrows(expectedException(interruptible), () -> dc.receive(buf));\n-            } finally {\n-                timerTask.cancel(false);\n-                interruptTask.cancel(false);\n-            }\n+    @Test\n+    public void testInterruptBeforeUninterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(false)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            onReceive(() -> {\n+                \/\/ close the channel after a delay to ensure receive wakes up\n+                Thread.sleep(1000);\n+                dc.close();\n+            });\n+            Thread.currentThread().interrupt();\n+            assertThrows(AsynchronousCloseException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n@@ -118,1 +112,1 @@\n-            Thread.interrupted();  \/\/ clear interrupt\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -123,1 +117,2 @@\n-     * Test invoking DatagramChannel send with interrupt status set\n+     * Test interrupting a thread blocked in DatagramChannel.receive, the DatagramChannel\n+     * is not interruptible.\n@@ -125,19 +120,16 @@\n-    static void testInterruptBeforeSend(boolean interruptible)\n-        throws Exception\n-    {\n-        try (DatagramChannel dc = openDatagramChannel(interruptible)) {\n-            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n-            Future<?> timeout = scheduleClose(dc, Duration.ofSeconds(2));\n-            try {\n-                ByteBuffer buf = ByteBuffer.allocate(100);\n-                SocketAddress target = dc.getLocalAddress();\n-                Thread.currentThread().interrupt();\n-                if (interruptible) {\n-                    assertThrows(ClosedByInterruptException.class, () -> dc.send(buf, target));\n-                } else {\n-                    int n = dc.send(buf, target);\n-                    assertTrue(n == 100);\n-                }\n-            } finally {\n-                timeout.cancel(false);\n-            }\n+    @Test\n+    public void testInterruptDuringUninterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+\n+            Thread thread = Thread.currentThread();\n+            onReceive(() -> {\n+                \/\/ interrupt should not cause the receive to wakeup\n+                thread.interrupt();\n+\n+                \/\/ close the channel after a delay to ensure receive wakes up\n+                Thread.sleep(1000);\n+                dc.close();\n+            });\n+            assertThrows(AsynchronousCloseException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n@@ -145,1 +137,1 @@\n-            Thread.interrupted();  \/\/ clear interrupt\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -150,1 +142,2 @@\n-     * Creates a DatagramChannel that is interruptible or not.\n+     * Call DatagramChannel.send with the interrupt status set, the DatagramChannel\n+     * is interruptible.\n@@ -152,5 +145,10 @@\n-    static DatagramChannel openDatagramChannel(boolean interruptible) throws IOException {\n-        if (interruptible) {\n-            return DatagramChannel.open();\n-        } else {\n-            return DefaultSelectorProvider.get().openUninterruptibleDatagramChannel();\n+    @Test\n+    public void testInterruptBeforeInterruptibleSend() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            SocketAddress target = dc.getLocalAddress();\n+            Thread.currentThread().interrupt();\n+            assertThrows(ClosedByInterruptException.class, () -> dc.send(buf, target));\n+            assertFalse(dc.isOpen());\n+        } finally {\n+            Thread.interrupted();  \/\/ clear interrupt\n@@ -161,1 +159,2 @@\n-     * Expect ClosedByInterruptException if interruptible.\n+     * Call DatagramChannel.send with the interrupt status set, the DatagramChannel\n+     * is not interruptible.\n@@ -163,5 +162,11 @@\n-    static Class<? extends Exception> expectedException(boolean expectInterrupt) {\n-        if (expectInterrupt) {\n-            return ClosedByInterruptException.class;\n-        } else {\n-            return AsynchronousCloseException.class;\n+    @Test\n+    public void testInterruptBeforeUninterruptibleSend() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(false)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            SocketAddress target = dc.getLocalAddress();\n+            Thread.currentThread().interrupt();\n+            int n = dc.send(buf, target);\n+            assertEquals(100, n);\n+            assertTrue(dc.isOpen());\n+        } finally {\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -172,1 +177,2 @@\n-     * Schedule the given object to be closed.\n+     * Creates a DatagramChannel that is interruptible or not, and bound to the loopback\n+     * address.\n@@ -174,6 +180,14 @@\n-    static Future<?> scheduleClose(Closeable c, Duration timeout) {\n-        long nanos = TimeUnit.NANOSECONDS.convert(timeout);\n-        return STPE.schedule(() -> {\n-            c.close();\n-            return null;\n-        }, nanos, TimeUnit.NANOSECONDS);\n+    static DatagramChannel boundDatagramChannel(boolean interruptible) throws IOException {\n+        DatagramChannel dc;\n+        if (interruptible) {\n+            dc = DatagramChannel.open();\n+        } else {\n+            dc = DefaultSelectorProvider.get().openUninterruptibleDatagramChannel();\n+        }\n+        try {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        } catch (IOException ioe) {\n+            dc.close();\n+            throw ioe;\n+        }\n+        return dc;\n@@ -183,1 +197,1 @@\n-     * Schedule the given thread to be interrupted.\n+     * Runs the given action when the current thread is sampled in DatagramChannel.receive.\n@@ -185,3 +199,17 @@\n-    static Future<?> scheduleInterrupt(Thread t, Duration timeout) {\n-        long nanos = TimeUnit.NANOSECONDS.convert(timeout);\n-        return STPE.schedule(t::interrupt, nanos, TimeUnit.NANOSECONDS);\n+    static void onReceive(Executable action) {\n+        Thread target = Thread.currentThread();\n+        Thread.ofPlatform().daemon().start(() -> {\n+            try {\n+                boolean found = false;\n+                while (!found) {\n+                    Thread.sleep(20);\n+                    StackTraceElement[] stack = target.getStackTrace();\n+                    found = Arrays.stream(stack)\n+                            .anyMatch(e -> dcImplClassName.equals(e.getClassName())\n+                                    && \"receive\".equals(e.getMethodName()));\n+                }\n+                action.execute();\n+            } catch (Throwable ex) {\n+                ex.printStackTrace();\n+            }\n+        });\n@@ -189,2 +217,0 @@\n-\n-    static final ScheduledExecutorService STPE = Executors.newScheduledThreadPool(0);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/InterruptibleOrNot.java","additions":132,"deletions":106,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8303440 8317979\n+ * @bug 8303440 8317979 8322647\n@@ -46,2 +46,2 @@\n-        \/\/ Assuming CLDR's SHORT name for \"America\/Juneau\"\n-        \/\/ produces \"UTC\\u212209:00\"\n+        \/\/ Assuming CLDR's SHORT name for \"America\/Manaus\"\n+        \/\/ produces \"UTC\\u221204:00\"\n@@ -63,1 +63,1 @@\n-        var zdt = ZonedDateTime.of(2023, 3, 3, 0, 0, 0, 0, ZoneId.of(\"America\/Juneau\"));\n+        var zdt = ZonedDateTime.of(2023, 3, 3, 0, 0, 0, 0, ZoneId.of(\"America\/Manaus\"));\n@@ -65,1 +65,1 @@\n-        assertEquals(formatted, \"UTC\\u221209:00\");\n+        assertEquals(formatted, \"UTC\\u221204:00\");\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestUTCParse.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-tzdata2023c\n+tzdata2023d\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,0 @@\n-Link\tAsia\/Urumqi\t\tAntarctica\/Vostok\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/aliases.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,2 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit -Xmx48M -XX:-UseTLAB OOMEInAQS\n+ * @requires vm.gc.G1\n+ * @run main\/othervm -XX:+UseG1GC -XX:-UseGCOverheadLimit -Xmx48M -XX:-UseTLAB OOMEInAQS\n","filename":"test\/jdk\/java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8253952\n@@ -27,1 +28,1 @@\n- * @run main\/othervm CopyZipFile\n+ * @run junit CopyZipFile\n@@ -30,5 +31,5 @@\n-import java.io.File;\n-import java.io.ByteArrayOutputStream;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n@@ -37,0 +38,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -40,7 +44,3 @@\n-import java.util.zip.CRC32;\n-import java.util.zip.Deflater;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipException;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipInputStream;\n-import java.util.zip.ZipOutputStream;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -49,2 +49,4 @@\n-    private static final String ZIP_FILE = \"first.zip\";\n-    private static final String TEST_STRING = \"TestTestTest\";\n+    \/\/ ZIP file created in this test\n+    private Path zip = Path.of(\"first.zip\");\n+    \/\/ The content to put in each entry\n+    private static final byte[] TEST_STRING = \"TestTestTest\".getBytes(StandardCharsets.UTF_8);\n@@ -52,4 +54,14 @@\n-    private static void createZip(String zipFile) throws Exception {\n-        File f = new File(zipFile);\n-        f.deleteOnExit();\n-        try (OutputStream os = new FileOutputStream(f);\n+    \/**\n+     * Create the sample ZIP file used in this test, including a STORED entry\n+     * and DEFLATE entries with various compression levels.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void createZip() throws IOException {\n+        \/\/ By default, ZipOutputStream creates zip files with Local File Headers\n+        \/\/ without size, compressed size and crc values and an extra Data\n+        \/\/ Descriptor (see https:\/\/en.wikipedia.org\/wiki\/Zip_(file_format)\n+        \/\/ after the data belonging to that entry with these values if in the\n+        \/\/ corresponding ZipEntry one of the size, compressedSize or crc fields is\n+        \/\/ equal to '-1' (which is the default for newly created ZipEntries).\n+        try (OutputStream os = Files.newOutputStream(zip) ;\n@@ -58,3 +70,4 @@\n-            zos.putNextEntry(new ZipEntry(\"test1.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n-            zos.closeEntry();\n+            zos.setLevel(Deflater.DEFAULT_COMPRESSION);\n+            zos.putNextEntry(new ZipEntry(\"DEFAULT_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -63,4 +76,3 @@\n-            ZipEntry ze = new ZipEntry(\"test2.txt\");\n-            int length = TEST_STRING.length();\n-            ze.setSize(length);\n-            ze.setCompressedSize(length);\n+            ZipEntry ze = new ZipEntry(\"STORED.txt\");\n+            ze.setSize(TEST_STRING.length);\n+            ze.setCompressedSize(TEST_STRING.length);\n@@ -68,1 +80,1 @@\n-            crc.update(TEST_STRING.getBytes(\"utf8\"), 0, length);\n+            crc.update(TEST_STRING);\n@@ -71,1 +83,2 @@\n-            zos.write(TEST_STRING.getBytes());\n+            zos.write(TEST_STRING);\n+\n@@ -75,2 +88,3 @@\n-            zos.putNextEntry(new ZipEntry(\"test3.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"NO_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -79,2 +93,3 @@\n-            zos.putNextEntry(new ZipEntry(\"test4.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"BEST_SPEED.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -83,2 +98,2 @@\n-            zos.putNextEntry(new ZipEntry(\"test5.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"BEST_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n@@ -88,22 +103,26 @@\n-    public static void main(String args[]) throws Exception {\n-        \/\/ By default, ZipOutputStream creates zip files with Local File Headers\n-        \/\/ without size, compressedSize and crc values and an extra Data\n-        \/\/ Descriptor (see https:\/\/en.wikipedia.org\/wiki\/Zip_(file_format)\n-        \/\/ after the data belonging to that entry with these values if in the\n-        \/\/ corresponding ZipEntry one of the size, compressedSize or crc fields is\n-        \/\/ equal to '-1' (which is the default for newly created ZipEntries).\n-        createZip(ZIP_FILE);\n-\n-        \/\/ Now read all the entries of the newly generated zip file with a ZipInputStream\n-        \/\/ and copy them to a new zip file with the help of a ZipOutputStream.\n-        \/\/ This only works reliably because the generated zip file has no values for the\n-        \/\/ size, compressedSize and crc values of a zip entry in the local file header and\n-        \/\/ therefore the ZipEntry objects created by ZipOutputStream.getNextEntry() will have\n-        \/\/ all these fields set to '-1'.\n-        ZipEntry entry;\n-        byte[] buf = new byte[512];\n-        try (InputStream is = new FileInputStream(ZIP_FILE);\n-             ZipInputStream zis = new ZipInputStream(is);\n-             OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os)) {\n-            while((entry = zis.getNextEntry())!=null) {\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Read all entries using ZipInputStream.getNextEntry and copy them\n+     * to a new zip file using ZipOutputStream.putNextEntry. This only works\n+     * reliably because the input zip file has no values for the size, compressedSize\n+     * and crc values of streamed zip entries in the local file header and\n+     * therefore the ZipEntry objects created by ZipOutputStream.getNextEntry\n+     * will have all these fields set to '-1'.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void copyFromZipInputStreamToZipOutputStream() throws IOException {\n+\n+        try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zip));\n+             ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream())) {\n+            ZipEntry entry;\n+            while ((entry = zis.getNextEntry()) != null) {\n@@ -114,5 +133,7 @@\n-                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n-                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n-                if (entry.getMethod() == ZipEntry.DEFLATED &&\n-                    (entry.getCompressedSize() != -1 || entry.getSize() != -1 || entry.getCrc() != -1)) {\n-                    throw new Exception(\"'size', 'compressedSize' and 'crc' shouldn't be initialized at this point.\");\n+                        String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n+                                entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                if (entry.getMethod() == ZipEntry.DEFLATED) {\n+                    \/\/ Expect size, compressed size and crc to not be initialized at this point\n+                    assertEquals(-1, entry.getCompressedSize());\n+                    assertEquals(-1, entry.getSize());\n+                    assertEquals(-1, entry.getCrc());\n@@ -127,5 +148,6 @@\n-                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n-                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n-                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n-                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n-                }\n+                        String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n+                                entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                \/\/ Expect size, compressed size and crc to be initialized at this point\n+                assertNotEquals(-1, entry.getCompressedSize());\n+                assertNotEquals(-1, entry.getSize());\n+                assertNotEquals(-1, entry.getCrc());\n@@ -134,0 +156,1 @@\n+    }\n@@ -135,15 +158,21 @@\n-        \/\/ Now we read all the entries of the initially generated zip file with the help\n-        \/\/ of the ZipFile class. The ZipFile class reads all the zip entries from the Central\n-        \/\/ Directory which must have accurate information for size, compressedSize and crc.\n-        \/\/ This means that all ZipEntry objects returned from ZipFile will have correct\n-        \/\/ settings for these fields.\n-        \/\/ If the compression level was different in the initial zip file (which we can't find\n-        \/\/ out any more now because the zip file format doesn't record this information) the\n-        \/\/ size of the re-compressed entry we are writing to the ZipOutputStream might differ\n-        \/\/ from the original compressed size recorded in the ZipEntry. This would result in an\n-        \/\/ \"invalid entry compressed size\" ZipException if ZipOutputStream wouldn't ignore\n-        \/\/ the implicitely set compressed size attribute of ZipEntries read from a ZipFile\n-        \/\/ or ZipInputStream.\n-        try (OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os);\n-             ZipFile zf = new ZipFile(ZIP_FILE)) {\n+    \/**\n+     * Read all entries using the ZipFile class and copy them to a new zip file\n+     * using ZipOutputStream.putNextEntry.\n+     * The ZipFile class reads all the zip entries from the Central\n+     * Directory, which has accurate information for size, compressedSize and crc.\n+     * This means that all ZipEntry objects returned from ZipFile will have correct\n+     * settings for these fields.\n+     * If the compression level was different in the input zip file (which we can't know\n+     * because the zip file format doesn't record this information), the\n+     * size of the re-compressed entry we are writing to the ZipOutputStream might differ\n+     * from the original compressed size recorded in the ZipEntry. This would result in an\n+     * \"invalid entry compressed size\" ZipException if ZipOutputStream wouldn't ignore\n+     * the implicitely set compressed size attribute of ZipEntries read from a ZipFile\n+     * or ZipInputStream.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void copyFromZipFileToZipOutputStream() throws IOException {\n+        try (ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream());\n+             ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry entry;\n@@ -157,4 +186,5 @@\n-                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n-                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n-                }\n-                InputStream is = zf.getInputStream(entry);\n+                \/\/ Expect size, compressed size and crc to be initialized at this point\n+                assertNotEquals(-1, entry.getCompressedSize());\n+                assertNotEquals(-1, entry.getSize());\n+                assertNotEquals(-1, entry.getCrc());\n+\n@@ -162,1 +192,3 @@\n-                is.transferTo(zos);\n+                try (InputStream is = zf.getInputStream(entry)) {\n+                    is.transferTo(zos);\n+                }\n@@ -166,0 +198,17 @@\n+    }\n+\n+    \/**\n+     * If the compressed size is set explicitly using ZipEntry.setCompressedSize(),\n+     * then the entry will be restreamed with a data descriptor and the compressed size\n+     * recomputed. If the source compression level was different from the target compression\n+     * level, the compressed sizes may differ and a ZipException will be thrown\n+     * when the entry is closed in ZipOutputStream.closeEntry\n+     *\n+     * @throws IOException if an unexpected IOException is thrown\n+     *\/\n+    @Test\n+    public void explicitCompressedSizeWithDifferentCompressionLevels() throws IOException {\n+        try (ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream());\n+             ZipFile zf = new ZipFile(zip.toFile())) {\n+            \/\/ Be explicit about the default compression level\n+            zos.setLevel(Deflater.DEFAULT_COMPRESSION);\n@@ -167,5 +216,0 @@\n-        \/\/ The compressed size attribute of a ZipEntry shouldn't be ignored if it was set\n-        \/\/ explicitely by calling ZipEntry.setCpompressedSize()\n-        try (OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os);\n-             ZipFile zf = new ZipFile(ZIP_FILE)) {\n@@ -174,4 +218,8 @@\n-                try {\n-                    entry = entries.nextElement();\n-                    entry.setCompressedSize(entry.getCompressedSize());\n-                    InputStream is = zf.getInputStream(entry);\n+                ZipEntry entry = entries.nextElement();\n+\n+                \/\/ Explicitly setting the compressed size will disable data descriptors\n+                \/\/ and enable validation that the compressed size in the ZipEntry matches the\n+                \/\/ actual compressed size written by ZipOutputStream\n+                entry.setCompressedSize(entry.getCompressedSize());\n+\n+                try (InputStream is = zf.getInputStream(entry)) {\n@@ -180,9 +228,35 @@\n-                    zos.closeEntry();\n-                    if (\"test3.txt\".equals(entry.getName())) {\n-                        throw new Exception(\n-                            \"Should throw a ZipException if ZipEntry.setCpompressedSize() was called.\");\n-                    }\n-                } catch (ZipException ze) {\n-                    if (\"test1.txt\".equals(entry.getName()) || \"test2.txt\".equals(entry.getName())) {\n-                        throw new Exception(\n-                            \"Shouldn't throw a ZipExcpetion for STORED files or files compressed with DEFAULT_COMPRESSION\");\n+                    \/\/ Some compression levels lead to unexpected recompressed sizes when closing the entry\n+                    switch (entry.getName()) {\n+                        case \"DEFAULT_COMPRESSION.txt\" -> {\n+                            \/\/ DEFAULT_COMPRESSION matches expected size\n+                            zos.closeEntry();\n+                        }\n+                        case \"STORED.txt\" -> {\n+                            \/\/ STORED should not throw\n+                            zos.closeEntry();\n+                        }\n+                        case \"NO_COMPRESSION.txt\", \"BEST_SPEED.txt\" -> {\n+                            \/\/ NO_COMPRESSION and BEST_SPEED should lead to an unexpected recompressed size\n+                            ZipException ze = assertThrows(ZipException.class, () -> {\n+                                zos.closeEntry();\n+                            });\n+\n+                            \/\/ Hack to fix and close the offending zip entry with the correct recompressed size.\n+                            \/\/ The exception message is something like:\n+                            \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n+                            \/\/ and we need to extract the second integer.\n+                            Pattern cSize = Pattern.compile(\"\\\\d+\");\n+                            Matcher m = cSize.matcher(ze.getMessage());\n+                            m.find();\n+                            m.find();\n+                            entry.setCompressedSize(Integer.parseInt(m.group()));\n+                            zos.closeEntry();\n+                        }\n+                        case \"BEST_COMPRESSION.txt\" -> {\n+                            \/\/ BEST_COMPRESSION produces the same compressed\n+                            \/\/ size as DEFAULT_COMPRESSION for sample content\n+                            zos.closeEntry();\n+                        }\n+                        default -> {\n+                            throw new IllegalArgumentException(\"Unexpected entry \" + entry.getName());\n+                        }\n@@ -190,9 +264,0 @@\n-                    \/\/ Hack to fix and close the offending zip entry with the correct compressed size.\n-                    \/\/ The exception message is something like:\n-                    \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n-                    \/\/ and we need to extract the second integer.\n-                    Pattern cSize = Pattern.compile(\"\\\\d+\");\n-                    Matcher m = cSize.matcher(ze.getMessage());\n-                    m.find();\n-                    m.find();\n-                    entry.setCompressedSize(Integer.parseInt(m.group()));\n","filename":"test\/jdk\/java\/util\/zip\/CopyZipFile.java","additions":178,"deletions":113,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.zip.*;\n-import java.io.File;\n-\n-public class Available\n-{\n-    public static void main (String argv[]) throws Exception {\n-        ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\"),\n-                                          \"input.jar\"));\n-        ZipEntry e = zf.getEntry(\"ReleaseInflater.java\");\n-        if (e.getSize() != zf.getInputStream(e).available()) {\n-            throw new Exception(\"wrong return value of available\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/Available.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test 1.1 99\/06\/01\n-   @bug 4239446\n-   @summary Make sure the ZipEntry fields are correct.\n- *\/\n-\n-import java.io.*;\n-import java.util.zip.*;\n-\n-public class CopyJar {\n-    public static void main(String args[]) throws Exception {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.jar\"))) {\n-            ZipEntry ze = zf.getEntry(\"ReleaseInflater.java\");\n-            ZipOutputStream zos = new ZipOutputStream(new ByteArrayOutputStream());\n-            InputStream in = zf.getInputStream(ze);\n-            byte[] b = new byte[128];\n-            int n;\n-            zos.putNextEntry(ze);\n-            while((n = in.read(b)) != -1) {\n-                zos.write(b, 0, n);\n-            }\n-            zos.close();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CopyJar.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4290060\n-   @summary Check if the zip file is closed before access any\n-            elements in the Enumeration.\n- *\/\n-\n-import java.io.*;\n-import java.util.zip.*;\n-import java.util.Enumeration;\n-\n-public class EnumAfterClose {\n-    public static void main(String args[]) throws Exception {\n-        Enumeration e;\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.zip\"))) {\n-            e = zf.entries();\n-        }\n-        \/\/ ensure that the ZipFile is closed before checking the Enumeration\n-        try {\n-            if (e.hasMoreElements()) {\n-                ZipEntry ze = (ZipEntry)e.nextElement();\n-            }\n-        } catch (IllegalStateException ie) {\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/EnumAfterClose.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 4290060\n+   @summary Check if the zip file is closed before access any\n+            elements in the Enumeration.\n+   @run junit EnumerateAfterClose\n+ *\/\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Enumeration;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class EnumerateAfterClose {\n+\n+    \/\/ ZIP file used in this test\n+    private Path zip = Path.of(\"enum-after-close.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Attempting to using a ZipEntry Enumeration after its backing\n+     * ZipFile is closed should throw IllegalStateException.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void enumeratingAfterCloseShouldThrowISE() throws IOException {\n+        \/\/ Retain a reference to an enumeration backed by a closed ZipFile\n+        Enumeration e;\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            e = zf.entries();\n+        }\n+        \/\/ Using the enumeration after the ZipFile is closed should throw ISE\n+        assertThrows(IllegalStateException.class, () -> {\n+            if (e.hasMoreElements()) {\n+                ZipEntry ze = (ZipEntry)e.nextElement();\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/EnumerateAfterClose.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+   @run junit FinalizeInflater\n@@ -29,2 +30,4 @@\n-import java.io.File;\n-import java.io.InputStream;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -32,0 +35,5 @@\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +42,1 @@\n+import java.util.zip.ZipOutputStream;\n@@ -37,4 +46,39 @@\n-    public static void main(String[] args) throws Throwable {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"), \"input.zip\")))\n-        {\n-            ZipEntry ze = zf.getEntry(\"ReadZip.java\");\n+    \/\/ ZIP file produced by this test\n+    private Path zip = Path.of(\"finalize-inflater.zip\");\n+\n+    \/**\n+     * Create the sample ZIP used in this test\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            byte[] hello = \"hello\".getBytes(StandardCharsets.UTF_8);\n+            for (int i = 0; i < 100; i++) {\n+                zo.write(hello);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * A cached Inflater should not be made invalid by finalization\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void shouldNotFinalizeInflaterInPool() throws IOException {\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry ze = zf.getEntry(\"file.txt\");\n@@ -54,6 +98,1 @@\n-        byte[] buffer = new byte[32];\n-        try {\n-            while(is.read(buffer)>0){}\n-        } catch (IOException ioe) {\n-            ioe.printStackTrace();\n-        }\n+        is.readAllBytes();\n@@ -62,1 +101,1 @@\n-    static class Wrapper{\n+    static class Wrapper {\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/FinalizeInflater.java","additions":53,"deletions":14,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4206838\n-   @summary getEntry() will search for a directory\n-            even without an ending '\/'.\n- *\/\n-\n-import java.io.*;\n-import java.util.zip.*;\n-\n-public class GetDirEntry {\n-    public static void main(String args[]) throws Exception {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.jar\"))) {\n-            ZipEntry ze = zf.getEntry(\"META-INF\");\n-            if (ze == null) {\n-                throw new Exception(\"failed to find a directory entry\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/GetDirEntry.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4528128 6846616\n-   @summary Test if reading InputStream of a closed ZipFile crashes VM\n-   @author kladko\n-   *\/\n-\n-\n-import java.util.zip.*;\n-import java.io.*;\n-import java.util.*;\n-\n-public class ReadAfterClose {\n-    public static void main(String[] argv) throws Exception {\n-        InputStream in;\n-        try (ZipFile zf = new ZipFile(\n-                 new File(System.getProperty(\"test.src\",\".\"),\"crash.jar\"))) {\n-            ZipEntry zent = zf.getEntry(\"Test.java\");\n-            in = zf.getInputStream(zent);\n-        }\n-        \/\/ ensure zf is closed at this point\n-        try {\n-            in.read();\n-        } catch (IOException e) {\n-            return;\n-        }\n-        throw new Exception(\"Test failed.\");\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadAfterClose.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-   @bug 4241361 4842702 4985614 6646605 5032358 6923692 6233323 8144977 8186464\n+   @bug 4241361 4842702 4985614 6646605 5032358 6923692 6233323 8144977 8186464 4401122 8322830\n@@ -27,1 +27,0 @@\n-   @key randomness\n@@ -29,0 +28,1 @@\n+   @run junit ReadZip\n@@ -31,1 +31,7 @@\n-import java.io.*;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n@@ -33,9 +39,4 @@\n-import java.nio.file.Files;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.NoSuchFileException;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n-import java.util.List;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.*;\n+import java.util.Collections;\n+import java.util.HexFormat;\n@@ -43,1 +44,4 @@\n-import java.util.zip.*;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n@@ -46,0 +50,1 @@\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -48,5 +53,20 @@\n-    private static void unreached (Object o)\n-        throws Exception\n-    {\n-        \/\/ Should never get here\n-        throw new Exception (\"Expected exception was not thrown\");\n+\n+    \/\/ ZIP file produced during tests\n+    private Path zip = Path.of(\"read-zip.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by tests\n+     * @param name name of the ZIP file to create\n+     * @return a sample ZIP file\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    private Path createZip(String name) throws IOException {\n+        Path zip = Path.of(name);\n+\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        return zip;\n@@ -55,6 +75,8 @@\n-    public static void main(String args[]) throws Exception {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.zip\"))) {\n-            \/\/ Make sure we throw NPE on null objects\n-            try { unreached (zf.getEntry(null)); }\n-            catch (NullPointerException e) {}\n+    \/**\n+     * Delete the ZIP file produced after each test method\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n@@ -62,2 +84,9 @@\n-            try { unreached (zf.getInputStream(null)); }\n-            catch (NullPointerException e) {}\n+    \/**\n+     * Make sure we throw NPE when calling getEntry or getInputStream with null params\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void nullPointerExceptionOnNullParams() throws IOException {\n+        zip = createZip(\"null-params.zip\");\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n@@ -65,4 +94,6 @@\n-            ZipEntry ze = zf.getEntry(\"ReadZip.java\");\n-            if (ze == null) {\n-                throw new Exception(\"cannot read from zip file\");\n-            }\n+            assertThrows(NullPointerException.class, () -> zf.getEntry(null));\n+            assertThrows(NullPointerException.class, () -> zf.getInputStream(null));\n+\n+            \/\/ Sanity check that we can still read an entry\n+            ZipEntry ze = zf.getEntry(\"file.txt\");\n+            assertNotNull(ze, \"cannot read from zip file\");\n@@ -70,0 +101,1 @@\n+    }\n@@ -71,5 +103,6 @@\n-        \/\/ Make sure we can read the zip file that has some garbage\n-        \/\/ bytes padded at the end.\n-        File newZip = new File(System.getProperty(\"test.dir\", \".\"), \"input2.zip\");\n-        Files.copy(Paths.get(System.getProperty(\"test.src\", \"\"), \"input.zip\"),\n-                   newZip.toPath(), StandardCopyOption.REPLACE_EXISTING);\n+    \/**\n+     * Read the zip file that has some garbage bytes padded at the end\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void bytesPaddedAtEnd() throws IOException {\n@@ -77,1 +110,1 @@\n-        newZip.setWritable(true);\n+        zip = createZip(\"bytes-padded.zip\");\n@@ -80,3 +113,6 @@\n-        try (OutputStream os = Files.newOutputStream(newZip.toPath(),\n-                                                     StandardOpenOption.APPEND)) {\n-            os.write(1); os.write(3); os.write(5); os.write(7);\n+        try (OutputStream os = Files.newOutputStream(zip,\n+                StandardOpenOption.APPEND)) {\n+            os.write(1);\n+            os.write(3);\n+            os.write(5);\n+            os.write(7);\n@@ -85,7 +121,25 @@\n-        try (ZipFile zf = new ZipFile(newZip)) {\n-            ZipEntry ze = zf.getEntry(\"ReadZip.java\");\n-            if (ze == null) {\n-                throw new Exception(\"cannot read from zip file\");\n-            }\n-        } finally {\n-            newZip.delete();\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry ze = zf.getEntry(\"file.txt\");\n+            assertNotNull(ze, \"cannot read from zip file\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify that we can read a comment from the ZIP\n+     * file's 'End of Central Directory' header\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readZipFileComment() throws IOException {\n+\n+        \/\/ Create a zip file with a comment in the 'End of Central Directory' header\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zos = new ZipOutputStream(out)) {\n+            ZipEntry ze = new ZipEntry(\"ZipEntry\");\n+            zos.putNextEntry(ze);\n+            zos.write(1);\n+            zos.write(2);\n+            zos.write(3);\n+            zos.write(4);\n+            zos.closeEntry();\n+            zos.setComment(\"This is the comment for testing\");\n@@ -95,10 +149,6 @@\n-        try {\n-            try (FileOutputStream fos = new FileOutputStream(newZip);\n-                 ZipOutputStream zos = new ZipOutputStream(fos))\n-            {\n-                ZipEntry ze = new ZipEntry(\"ZipEntry\");\n-                zos.putNextEntry(ze);\n-                zos.write(1); zos.write(2); zos.write(3); zos.write(4);\n-                zos.closeEntry();\n-                zos.setComment(\"This is the comment for testing\");\n-            }\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry ze = zf.getEntry(\"ZipEntry\");\n+            assertNotNull(ze, \"cannot read entry from zip file\");\n+            assertEquals(\"This is the comment for testing\", zf.getComment());\n+        }\n+    }\n@@ -106,38 +156,37 @@\n-            try (ZipFile zf = new ZipFile(newZip)) {\n-                ZipEntry ze = zf.getEntry(\"ZipEntry\");\n-                if (ze == null)\n-                    throw new Exception(\"cannot read entry from zip file\");\n-                if (!\"This is the comment for testing\".equals(zf.getComment()))\n-                    throw new Exception(\"cannot read comment from zip file\");\n-            }\n-        } finally {\n-            newZip.delete();\n-        }\n-\n-        \/\/ Read directory entry\n-        try {\n-            try (FileOutputStream fos = new FileOutputStream(newZip);\n-                 ZipOutputStream zos = new ZipOutputStream(fos))\n-            {\n-                ZipEntry ze = new ZipEntry(\"directory\/\");\n-                zos.putNextEntry(ze);\n-                zos.closeEntry();\n-            }\n-            try (ZipFile zf = new ZipFile(newZip)) {\n-                ZipEntry ze = zf.getEntry(\"directory\/\");\n-                if (ze == null || !ze.isDirectory())\n-                    throw new RuntimeException(\"read entry \\\"directory\/\\\" failed\");\n-                try (InputStream is = zf.getInputStream(ze)) {\n-                    is.available();\n-                } catch (Exception x) {\n-                    x.printStackTrace();\n-                }\n-\n-                ze = zf.getEntry(\"directory\");\n-                if (ze == null || !ze.isDirectory())\n-                    throw new RuntimeException(\"read entry \\\"directory\\\" failed\");\n-                try (InputStream is = zf.getInputStream(ze)) {\n-                    is.available();\n-                } catch (Exception x) {\n-                    x.printStackTrace();\n-                }\n+    \/**\n+     * Verify that a directory entry can be found using the\n+     * name 'directory\/' as well as 'directory\/'\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readDirectoryEntries() throws IOException {\n+\n+        \/\/ Create a ZIP containing some directory entries\n+        try (OutputStream fos = Files.newOutputStream(zip);\n+             ZipOutputStream zos = new ZipOutputStream(fos)) {\n+            \/\/ Add a META-INF directory with STORED compression type\n+            ZipEntry metaInf = new ZipEntry(\"META-INF\/\");\n+            metaInf.setMethod(ZipEntry.STORED);\n+            metaInf.setSize(0);\n+            metaInf.setCrc(0);\n+            zos.putNextEntry(metaInf);\n+\n+            \/\/ Add a regular directory\n+            ZipEntry dir = new ZipEntry(\"directory\/\");\n+            zos.putNextEntry(dir);\n+            zos.closeEntry();\n+        }\n+\n+        \/\/ Verify directory lookups\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            \/\/ Look up 'directory\/' using the full name\n+            ZipEntry ze = zf.getEntry(\"directory\/\");\n+            assertNotNull(ze, \"read entry \\\"directory\/\\\" failed\");\n+            assertTrue(ze.isDirectory(), \"read entry \\\"directory\/\\\" failed\");\n+            assertEquals(\"directory\/\", ze.getName());\n+\n+            try (InputStream is = zf.getInputStream(ze)) {\n+                is.available();\n+            } catch (Exception x) {\n+                x.printStackTrace();\n@@ -145,19 +194,11 @@\n-        } finally {\n-            newZip.delete();\n-        }\n-\n-        \/\/ Throw a FNF exception when read a non-existing zip file\n-        try { unreached (new ZipFile(\n-                             new File(System.getProperty(\"test.src\", \".\"),\n-                                     \"input\"\n-                                      + String.valueOf(new java.util.Random().nextInt())\n-                                      + \".zip\")));\n-        } catch (NoSuchFileException nsfe) {}\n-\n-        \/\/ read a zip file with ZIP64 end\n-        Path path = Paths.get(System.getProperty(\"test.dir\", \"\"), \"end64.zip\");\n-        try {\n-            URI uri = URI.create(\"jar:\" + path.toUri());\n-            Map<String, Object> env = Map.of(\"create\", \"true\", \"forceZIP64End\", \"true\");\n-            try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {\n-                Files.write(fs.getPath(\"hello\"), \"hello\".getBytes());\n+\n+            \/\/ Look up 'directory\/' without the trailing slash\n+            ze = zf.getEntry(\"directory\");\n+            assertNotNull(ze, \"read entry \\\"directory\\\" failed\");\n+            assertTrue(ze.isDirectory(), \"read entry \\\"directory\\\" failed\");\n+            assertEquals(\"directory\/\", ze.getName());\n+\n+            try (InputStream is = zf.getInputStream(ze)) {\n+                is.available();\n+            } catch (Exception x) {\n+                x.printStackTrace();\n@@ -165,7 +206,35 @@\n-            try (ZipFile zf = new ZipFile(path.toFile())) {\n-                if (!\"hello\".equals(new String(zf.getInputStream(new ZipEntry(\"hello\"))\n-                                               .readAllBytes(),\n-                                               US_ASCII)))\n-                    throw new RuntimeException(\"zipfile: read entry failed\");\n-            } catch (IOException x) {\n-                throw new RuntimeException(\"zipfile: zip64 end failed\");\n+            \/\/ Sanity check that also META-INF\/ can be looked up with or without the trailing slash\n+            assertNotNull(zf.getEntry(\"META-INF\"));\n+            assertNotNull(zf.getEntry(\"META-INF\/\"));\n+            assertEquals(zf.getEntry(\"META-INF\").getName(),\n+                    zf.getEntry(\"META-INF\/\").getName());\n+        }\n+    }\n+\n+    \/**\n+     * Throw a NoSuchFileException exception when reading a non-existing zip file\n+     *\/\n+    @Test\n+    public void nonExistingFile() {\n+        File nonExistingFile = new File(\"non-existing-file-f6804460f.zip\");\n+        assertThrows(NoSuchFileException.class, () ->\n+                new ZipFile(nonExistingFile));\n+    }\n+\n+    \/**\n+     * Read a Zip file with a 'Zip64 End of Central Directory header' which was created\n+     * using ZipFileSystem with the 'forceZIP64End' option.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readZip64EndZipFs() throws IOException {\n+\n+        \/\/ Create zip file with Zip64 end\n+        Map<String, Object> env = Map.of(\"create\", \"true\", \"forceZIP64End\", \"true\");\n+        try (FileSystem fs = FileSystems.newFileSystem(zip, env)) {\n+            Files.write(fs.getPath(\"hello\"), \"hello\".getBytes());\n+        }\n+        \/\/ Read using ZipFile\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            try (InputStream in = zf.getInputStream(zf.getEntry(\"hello\"))) {\n+                assertEquals(\"hello\", new String(in.readAllBytes(), StandardCharsets.US_ASCII));\n@@ -173,5 +242,35 @@\n-            try (FileSystem fs = FileSystems.newFileSystem(uri, Map.of())) {\n-                if (!\"hello\".equals(new String(Files.readAllBytes(fs.getPath(\"hello\")))))\n-                    throw new RuntimeException(\"zipfs: read entry failed\");\n-            } catch (IOException x) {\n-                throw new RuntimeException(\"zipfile: zip64 end failed\");\n+        }\n+        \/\/ Read using ZipFileSystem\n+        try (FileSystem fs = FileSystems.newFileSystem(zip, Map.of())) {\n+            assertEquals(\"hello\", new String(Files.readAllBytes(fs.getPath(\"hello\"))));\n+        }\n+    }\n+\n+    \/**\n+     * Read a zip file created via Info-ZIP in streaming mode,\n+     * which includes a 'Zip64 End of Central Directory header'.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     * @throws InterruptedException if an unexpected InterruptedException occurs\n+     *\/\n+    @Test\n+    public void readZip64EndInfoZIPStreaming() throws IOException, InterruptedException {\n+        \/\/ ZIP created using: \"echo -n hello | zip zip64.zip -\"\n+        \/\/ Hex encoded using: \"cat zip64.zip | xxd -ps\"\n+        byte[] zipBytes = HexFormat.of().parseHex(\"\"\"\n+                  504b03042d0000000000c441295886a61036ffffffffffffffff01001400\n+                  2d010010000500000000000000050000000000000068656c6c6f504b0102\n+                  1e032d0000000000c441295886a610360500000005000000010000000000\n+                  000001000000b011000000002d504b06062c000000000000001e032d0000\n+                  00000000000000010000000000000001000000000000002f000000000000\n+                  003800000000000000504b06070000000067000000000000000100000050\n+                  4b050600000000010001002f000000380000000000\n+                  \"\"\".replaceAll(\"\\n\",\"\")\n+        );\n+\n+        Files.write(zip, zipBytes);\n+\n+        try (ZipFile zf = new ZipFile(this.zip.toFile())) {\n+            try (InputStream in = zf.getInputStream(zf.getEntry(\"-\"))) {\n+                String contents = new String(in.readAllBytes(), StandardCharsets.US_ASCII);\n+                assertEquals(\"hello\", contents);\n@@ -179,22 +278,40 @@\n-        } finally {\n-            Files.deleteIfExists(path);\n-        }\n-\n-        \/\/ read a zip file created via \"echo hello | zip dst.zip -\", which uses\n-        \/\/ ZIP64 end record\n-        if (Files.notExists(Paths.get(\"\/usr\/bin\/zip\")))\n-            return;\n-        try {\n-            Process zip = new ProcessBuilder(\"zip\", path.toString().toString(), \"-\").start();\n-            OutputStream os = zip.getOutputStream();\n-            os.write(\"hello\".getBytes(US_ASCII));\n-            os.close();\n-            zip.waitFor();\n-            if (zip.exitValue() == 0 && Files.exists(path)) {\n-                try (ZipFile zf = new ZipFile(path.toFile())) {\n-                    if (!\"hello\".equals(new String(zf.getInputStream(new ZipEntry(\"-\"))\n-                                                       .readAllBytes())))\n-                        throw new RuntimeException(\"zipfile: read entry failed\");\n-                } catch (IOException x) {\n-                    throw new RuntimeException(\"zipfile: zip64 end failed\");\n-                }\n+        }\n+    }\n+\n+    \/**\n+     * Check that the available() method overriden by the input stream returned by\n+     * ZipFile.getInputStream correctly returns the number of remaining uncompressed bytes\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void availableShouldReturnRemainingUncompressedBytes() throws IOException {\n+        \/\/ The number of uncompressed bytes to write to the sample ZIP entry\n+        final int expectedBytes = 512;\n+\n+        \/\/ Create a sample ZIP with deflated entry of a known uncompressed size\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(new byte[expectedBytes]);\n+        }\n+\n+        \/\/ Verify the behavior of ZipFileInflaterInputStream.available()\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry e = zf.getEntry(\"file.txt\");\n+            try (InputStream in = zf.getInputStream(e)) {\n+                \/\/ Initially, available() should return the full uncompressed size of the entry\n+                assertEquals(expectedBytes, in.available(),\n+                        \"wrong initial return value of available\");\n+\n+                \/\/ Reading a few bytes should reduce the number of available bytes accordingly\n+                int bytesToRead = 10;\n+                in.read(new byte[bytesToRead]);\n+                assertEquals(expectedBytes - bytesToRead, in.available());\n+\n+                \/\/ Reading all remaining bytes should reduce the number of available bytes to zero\n+                in.transferTo(OutputStream.nullOutputStream());\n+                assertEquals(0, in.available());\n+\n+                \/\/ available on a closed input stream should return zero\n+                in.close();\n+                assertEquals(0, in.available());\n@@ -202,2 +319,0 @@\n-        } finally {\n-            Files.deleteIfExists(path);\n@@ -206,1 +321,60 @@\n-}\n+\n+    \/**\n+     * Verify that reading an InputStream from a closed ZipFile\n+     * throws IOException as expected and does not crash the VM.\n+     * See bugs: 4528128 6846616\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readAfterClose() throws IOException {\n+        zip = createZip(\"read-after-close.zip\");\n+        InputStream in;\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry zent = zf.getEntry(\"file.txt\");\n+            in = zf.getInputStream(zent);\n+        }\n+\n+        \/\/ zf is closed at this point\n+        assertThrows(IOException.class,  () -> {\n+            in.read();\n+        });\n+        assertThrows(IOException.class,  () -> {\n+            in.read(new byte[10]);\n+        });\n+        assertThrows(IOException.class,  () -> {\n+            byte[] buf = new byte[10];\n+            in.read(buf, 0, buf.length);\n+        });\n+        assertThrows(IOException.class,  () -> {\n+            in.readAllBytes();\n+        });\n+    }\n+\n+    \/**\n+     * Verify that ZipFile can open a ZIP file with zero entries\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void noEntries() throws IOException {\n+        \/\/ Create a ZIP file with no entries\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+        }\n+\n+        \/\/ Open the \"empty\" ZIP file\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            \/\/ Verify size\n+            assertEquals(0, zf.size());\n+\n+            \/\/ Verify entry lookup using ZipFile.getEntry()\n+            assertNull(zf.getEntry(\"file.txt\"));\n+\n+            \/\/ Verify iteration using ZipFile.entries()\n+            assertEquals(Collections.emptyList(), Collections.list(zf.entries()));\n+\n+            \/\/ Verify iteration using ZipFile.stream()\n+            assertEquals(Collections.emptyList(), zf.stream().toList());\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadZip.java","additions":325,"deletions":151,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit ReleaseInflater\n@@ -30,2 +31,14 @@\n-import java.io.*;\n-import java.util.zip.*;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -35,4 +48,35 @@\n-    public static void main(String[] args) throws Exception {\n-        ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\"),\n-                                          \"input.jar\"));\n-        ZipEntry e = zf.getEntry(\"ReleaseInflater.java\");\n+    \/\/ ZIP file produced in this test\n+    private Path zip = Path.of(\"release-inflater.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by tests\n+     * @param name name of the ZIP file to create\n+     * @return a sample ZIP file\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(\"helloworld\".getBytes(StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP and JAR files produced after each test method\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Verify that the same Inflater is not recycled across input streams\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void recycleInflaterOnlyOnce() throws IOException {\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry e = zf.getEntry(\"file.txt\");\n@@ -40,5 +84,5 @@\n-        InputStream in1 = zf.getInputStream(e);\n-        \/\/ close the stream, the inflater will be released\n-        in1.close();\n-        \/\/ close the stream again, should be no-op\n-        in1.close();\n+            InputStream in1 = zf.getInputStream(e);\n+            \/\/ close the stream, the inflater will be released\n+            in1.close();\n+            \/\/ close the stream again, should be no-op\n+            in1.close();\n@@ -46,3 +90,3 @@\n-        \/\/ create two new streams, allocating inflaters\n-        InputStream in2 = zf.getInputStream(e);\n-        InputStream in3 = zf.getInputStream(e);\n+            \/\/ create two new streams, allocating inflaters\n+            InputStream in2 = zf.getInputStream(e);\n+            InputStream in3 = zf.getInputStream(e);\n@@ -50,3 +94,2 @@\n-        \/\/ check to see if they influence each other\n-        if (in2.read() != in3.read()) {\n-            throw new Exception(\"Stream is corrupted!\");\n+            \/\/ check to see if they influence each other\n+            assertEquals(in2.read(), in3.read(), \"Stream is corrupted!\");\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReleaseInflater.java","additions":61,"deletions":18,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @run testng StreamZipEntriesTest\n+ * @run junit StreamZipEntriesTest\n@@ -30,1 +30,4 @@\n-import java.io.File;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -32,3 +35,6 @@\n-import java.lang.Object;\n-import java.lang.System;\n-import java.util.jar.JarFile;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -36,0 +42,3 @@\n+import java.util.jar.JarFile;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n@@ -39,0 +48,1 @@\n+import java.util.zip.ZipOutputStream;\n@@ -40,1 +50,1 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -42,3 +52,0 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n@@ -48,0 +55,50 @@\n+    \/\/ ZIP file produced in this test\n+    private Path zip = Path.of(\"stream.zip\");\n+    \/\/ JAR file produced in this test\n+    private Path jar = Path.of(\"stream.jar\");\n+\n+    \/**\n+     * Create sample ZIP and JAR files used in in this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+            zo.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        try (OutputStream out = Files.newOutputStream(jar);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            \/\/ A JAR file may start with a META-INF\/ directory before the manifest\n+            zo.putNextEntry(new ZipEntry(\"META-INF\/\"));\n+            \/\/ Write the manifest\n+            zo.putNextEntry(new ZipEntry(\"META-INF\/MANIFEST.MF\"));\n+            new Manifest().write(zo);\n+\n+            \/\/ Write two regular entries\n+            zo.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+            zo.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced after each test method\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+        Files.deleteIfExists(jar);\n+    }\n+\n+    \/**\n+     * Verify that ZipFile.stream() produces the expected entries\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -50,3 +107,13 @@\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"), \"input.zip\"))) {\n-            zf.stream().forEach(e -> assertTrue(e instanceof ZipEntry));\n-            zf.stream().forEach(e -> assertEquals(e.toString(), \"ReadZip.java\"));\n+        Set<String> names = new HashSet<>(Set.of(\"entry1.txt\", \"entry2.txt\"));\n+\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            zf.stream().forEach(e -> {\n+                assertTrue(e instanceof ZipEntry);\n+                String name = e.getName();\n+                assertNotNull(names.remove(name));\n+                String toString = e.toString();\n+                assertEquals(name, toString);\n+            });\n+\n+            \/\/ Check that all expected names were processed\n+            assertTrue(names.isEmpty());\n@@ -54,0 +121,1 @@\n+            \/\/ Check that Stream.toArray produces the expected result\n@@ -55,2 +123,3 @@\n-            assertEquals(1, elements.length);\n-            assertEquals(elements[0].toString(), \"ReadZip.java\");\n+            assertEquals(2, elements.length);\n+            assertEquals(elements[0].toString(), \"entry1.txt\");\n+            assertEquals(elements[1].toString(), \"entry2.txt\");\n@@ -60,0 +129,4 @@\n+    \/**\n+     * Verify that JarFile.stream() produces the expected entries\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -62,2 +135,7 @@\n-        try (JarFile jf = new JarFile(new File(System.getProperty(\"test.src\", \".\"), \"input.jar\"))) {\n-            jf.stream().forEach(e -> assertTrue(e instanceof JarEntry));\n+        try (JarFile jf = new JarFile(jar.toFile())) {\n+            Set<String> names = new HashSet<>(Set.of(\n+                    \"META-INF\/\",\n+                    \"META-INF\/MANIFEST.MF\",\n+                    \"entry1.txt\",\n+                    \"entry2.txt\"\n+            ));\n@@ -65,0 +143,14 @@\n+            jf.stream().forEach(e -> {\n+                        assertTrue(e instanceof JarEntry);\n+                        String name = e.getName();\n+                        assertNotNull(names.remove(name));\n+                        String toString = e.toString();\n+                        assertEquals(name, toString);\n+                    }\n+            );\n+\n+            \/\/ Check that all expected names were processed\n+            assertTrue(names.isEmpty(), \"Unprocessed entries: \" + names);\n+\n+\n+            \/\/ Check that Stream.toArray produces the expected result\n@@ -66,1 +158,1 @@\n-            assertEquals(3, elements.length);\n+            assertEquals(4, elements.length);\n@@ -69,1 +161,2 @@\n-            assertEquals(elements[2].toString(), \"ReleaseInflater.java\");\n+            assertEquals(elements[2].toString(), \"entry1.txt\");\n+            assertEquals(elements[3].toString(), \"entry2.txt\");\n@@ -73,0 +166,4 @@\n+    \/**\n+     * Calling ZipFile.stream() on a closed ZipFile should throw ISE\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -75,1 +172,1 @@\n-        ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"), \"input.zip\"));\n+        ZipFile zf = new ZipFile(zip.toFile());\n@@ -77,1 +174,1 @@\n-        try {\n+        assertThrows(IllegalStateException.class, () -> {\n@@ -79,4 +176,1 @@\n-            fail(\"Should have thrown IllegalStateException\");\n-        } catch (IllegalStateException e) {\n-            \/\/ expected;\n-        }\n+        });\n@@ -85,0 +179,4 @@\n+    \/**\n+     * Calling JarFile.stream() on a closed JarFile should throw ISE\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -87,1 +185,1 @@\n-        JarFile jf = new JarFile(new File(System.getProperty(\"test.src\", \".\"), \"input.jar\"));\n+        JarFile jf = new JarFile(jar.toFile());\n@@ -89,1 +187,1 @@\n-        try {\n+        assertThrows(IllegalStateException.class, () -> {\n@@ -91,4 +189,1 @@\n-            fail(\"Should have thrown IllegalStateException\");\n-        } catch (IllegalStateException e) {\n-            \/\/ expected;\n-        }\n+        });\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/StreamZipEntriesTest.java","additions":126,"deletions":31,"binary":false,"changes":157,"status":"modified"},{"filename":"test\/jdk\/java\/util\/zip\/ZipFile\/crash.jar","binary":true,"status":"deleted"},{"filename":"test\/jdk\/java\/util\/zip\/ZipFile\/input.jar","binary":true,"status":"deleted"},{"filename":"test\/jdk\/java\/util\/zip\/ZipFile\/input.zip","binary":true,"status":"deleted"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.JButton;\n+import javax.swing.JComboBox;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8322754\n+ * @summary Verifies clicking JComboBox during frame closure causes Exception\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ComboPopupBug\n+ *\/\n+\n+public class ComboPopupBug {\n+    private static final String instructionsText = \"\"\"\n+            This test is used to verify that clicking on JComboBox\n+            when frame containing it is about to close should not\n+            cause IllegalStateException.\n+\n+            A JComboBox is shown with Close button at the bottom.\n+            Click on Close and then click on JComboBox arrow button\n+            to try to show combobox popup.\n+            If IllegalStateException is thrown, test will automatically Fail\n+            otherwise click Pass.  \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n+                .title(\"ComboPopup Instructions\")\n+                .instructions(instructionsText)\n+                .testTimeOut(5)\n+                .rows(10)\n+                .columns(35)\n+                .build();\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            JFrame frame = new JFrame(\"ComboPopup\");\n+\n+            JComboBox cb = new JComboBox();\n+            cb.setEditable(true);\n+            cb.addItem(\"test\");\n+            cb.addItem(\"test2\");\n+            cb.addItem(\"test3\");\n+            frame.getContentPane().add(cb, \"North\");\n+\n+            JButton b = new JButton(\"Close\");\n+            b.addActionListener(\n+                (e)->{\n+                    try {\n+                        Thread.sleep(3000);\n+                    }\n+                    catch (Exception ex) {\n+                    }\n+                    frame.setVisible(false);\n+\n+                });\n+            frame.getContentPane().add(b, \"South\");\n+            frame.setSize(200, 200);\n+\n+            PassFailJFrame.addTestWindow(frame);\n+            PassFailJFrame.positionTestWindow(frame,\n+                    PassFailJFrame.Position.HORIZONTAL);\n+\n+            frame.setVisible(true);\n+        });\n+\n+        passFailJFrame.awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/ComboPopupBug.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, SAP SE. All rights reserved.\n+ * Copyright (c) 2019, 2024, SAP SE. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n@@ -29,7 +31,1 @@\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.GroupPrincipal;\n-import java.nio.file.attribute.PosixFileAttributeView;\n-import java.nio.file.attribute.PosixFileAttributes;\n-import java.nio.file.attribute.PosixFilePermission;\n-import java.nio.file.attribute.PosixFilePermissions;\n-import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.*;\n@@ -40,5 +36,2 @@\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Set;\n+import java.time.Instant;\n+import java.util.*;\n@@ -52,1 +45,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -63,5 +56,5 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNotNull;\n-import static org.testng.Assert.assertNull;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -75,2 +68,2 @@\n- * @run testng TestPosix\n- * @run testng\/othervm\/java.security.policy=test.policy.posix TestPosix\n+ * @run junit TestPosix\n+ * @run junit\/othervm\/java.security.policy=test.policy.posix TestPosix\n@@ -367,1 +360,1 @@\n-        assertEquals(Files.isDirectory(file), ei.isDir, \"Unexpected directory attribute for:\" + System.lineSeparator() + attrs);\n+        assertEquals(ei.isDir, Files.isDirectory(file), \"Unexpected directory attribute for:\" + System.lineSeparator() + attrs);\n@@ -405,1 +398,1 @@\n-        assertEquals(entries.get(), entriesCreated, \"File contained wrong number of entries.\");\n+        assertEquals(entriesCreated, entries.get(), \"File contained wrong number of entries.\");\n@@ -432,1 +425,1 @@\n-            assertEquals(actual.size(), expected.size(), \"Unexpected number of permissions (\" +\n+            assertEquals(expected.size(), actual.size(), \"Unexpected number of permissions (\" +\n@@ -612,1 +605,1 @@\n-                assertEquals(owner.getName(), defaultOwner);\n+                assertEquals(defaultOwner, owner.getName());\n@@ -615,1 +608,1 @@\n-            assertEquals(Files.getOwner(entry), DUMMY_USER);\n+            assertEquals(DUMMY_USER, Files.getOwner(entry));\n@@ -620,1 +613,1 @@\n-                assertEquals(group.getName(), defaultGroup);\n+                assertEquals(defaultGroup, group.getName());\n@@ -623,1 +616,1 @@\n-            assertEquals(view.readAttributes().group(), DUMMY_GROUP);\n+            assertEquals(DUMMY_GROUP, view.readAttributes().group());\n@@ -635,1 +628,1 @@\n-            assertEquals(Files.getOwner(entry).getName(), \"auser\");\n+            assertEquals(\"auser\", Files.getOwner(entry).getName());\n@@ -637,1 +630,1 @@\n-            assertEquals(view.readAttributes().group().getName(), \"agroup\");\n+            assertEquals(\"agroup\", view.readAttributes().group().getName());\n@@ -648,1 +641,1 @@\n-            assertEquals(Files.getOwner(entry), DUMMY_USER);\n+            assertEquals(DUMMY_USER, Files.getOwner(entry));\n@@ -650,1 +643,1 @@\n-            assertEquals(view.readAttributes().group(), DUMMY_GROUP);\n+            assertEquals(DUMMY_GROUP, view.readAttributes().group());\n@@ -725,1 +718,103 @@\n-        assertEquals(rc, 0, \"Return code of jar call is \" + rc + \" but expected 0\");\n+        assertEquals(0, rc, \"Return code of jar call is \" + rc + \" but expected 0\");\n+    }\n+\n+    \/**\n+     * Verify that calling Files.setPosixPermissions with the current\n+     * permission set does not change the 'external file attributes' field.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void setPermissionsShouldPreserveRemainingBits() throws IOException {\n+        assertExternalFileAttributeUnchanged(fs -> {\n+            Path path = fs.getPath(\"hello.txt\");\n+            \/\/ Set permissions to their current value\n+            Files.setPosixFilePermissions(path, Files.getPosixFilePermissions(path));\n+        });\n+    }\n+\n+    \/**\n+     * Verify that a non-POSIX operation such as Files.setLastModifiedTime\n+     * does not change the 'external file attributes' field.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void setLastModifiedTimeShouldNotChangeExternalFileAttribute() throws IOException {\n+        assertExternalFileAttributeUnchanged(fs -> {\n+            Path path = fs.getPath(\"hello.txt\");\n+            Files.setLastModifiedTime(path, FileTime.from(Instant.now()));\n+        });\n+    }\n+\n+    \/\/ Represents an operation performed on a FileSystem\n+    static interface FileSystemOperation {\n+        void accept(FileSystem fileSystem) throws IOException;\n+    }\n+\n+    \/**\n+     * Assert that running the given operation on a ZipFileSystem does not\n+     * change the 'external file attributes' value of the 'hello.txt' entry\n+     * @param action the action to run on the file system\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    private void assertExternalFileAttributeUnchanged(FileSystemOperation action) throws IOException {\n+        \/*\n+         * The ZIP test vector used here is created using:\n+         * % touch hello.txt\n+         * % chmod u+s hello.txt     # setuid\n+         * % chmod g+s hello.txt     # setgid\n+         * % chmod +t hello.txt      # sticky\n+         * % zip hello.zip hello.txt\n+         * % cat hello.zip | xxd -ps\n+         *\/\n+        byte[] zip = HexFormat.of().parseHex(\"\"\"\n+                504b03040a0000000000d994945700000000000000000000000009001c00\n+                68656c6c6f2e7478745554090003aa268365aa26836575780b000104f501\n+                00000414000000504b01021e030a0000000000d994945700000000000000\n+                0000000000090018000000000000000000a48f0000000068656c6c6f2e74\n+                78745554050003aa26836575780b000104f50100000414000000504b0506\n+                00000000010001004f000000430000000000\n+                \"\"\".replaceAll(\"\\n\",\"\"));\n+\n+        \/\/ Expected bit values of the 'external file attributes' CEN field in the ZIP above\n+        String expectedBits = \"1000111110100100\";\n+                            \/\/ ^^^^             file type: 1000 (regular file)\n+                            \/\/     ^            setuid: ON\n+                            \/\/      ^           setgid: ON\n+                            \/\/       ^          sticky: ON\n+                            \/\/        ^^^^^^^^^ rwxr--r--  (9 bits)\n+\n+        \/\/ Sanity check that 'external file attributes' has the expected value\n+        verifyExternalFileAttribute(zip, expectedBits);\n+\n+\n+        Path zipFile = Path.of(\"preserve-external-file-attrs.zip\");\n+        Files.write(zipFile, zip);\n+\n+        \/\/ Run the provided action on the ZipFileSystem\n+        try (FileSystem fs = FileSystems.newFileSystem(zipFile, ENV_POSIX)) {\n+            action.accept(fs);\n+        }\n+        \/\/ Running the action should not change the 'external file attributes' value\n+        verifyExternalFileAttribute(Files.readAllBytes(zipFile), expectedBits);\n+    }\n+\n+    \/**\n+     * Verify that the first 16 bits of the CEN field 'external file attributes' matches\n+     * a given bit string\n+     * @param zip the ZIP file to parse\n+     * @param expectedBits a string of '0' or '1' representing the expected bits\n+     *\/\n+    private void verifyExternalFileAttribute(byte[] zip, String expectedBits) {\n+        \/\/ Buffer to help parse the ZIP\n+        ByteBuffer buffer = ByteBuffer.wrap(zip).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Look up offset of first CEN header from the END header\n+        int cenOff = buffer.getInt(buffer.capacity() - ZipFile.ENDHDR + ZipFile.ENDOFF);\n+        \/\/ We're interested in the first 16 'unix' bits of the 32-bit 'external file attributes' field\n+        int externalFileAttr = (buffer.getInt(cenOff + ZipFile.CENATX) >> 16) & 0xFFFF;\n+\n+        \/\/ Verify that the expected bits are set\n+        assertEquals(expectedBits, Integer.toBinaryString(externalFileAttr),\n+                \"The 'external file attributes' field does not match the expected value:\");\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestPosix.java","additions":128,"deletions":33,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @bug 8012229 8300725 8279216\n+ * @bug 8012229 8300725 8279216 8323210\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/ColCvtAlphaDifferentSrcDst.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8181157 8202537 8234347 8236548 8261279\n+ * @bug 8181157 8202537 8234347 8236548 8261279 8322647\n@@ -28,1 +28,2 @@\n- * @summary Checks CLDR time zone names are generated correctly at runtime\n+ * @summary Checks CLDR time zone names are generated correctly at\n+ * either build or runtime\n@@ -48,2 +49,2 @@\n-    @DataProvider(name=\"noResourceTZs\")\n-    Object[][] data() {\n+    @DataProvider\n+    Object[][] sampleTZs() {\n@@ -177,0 +178,38 @@\n+\n+            \/\/ Short names derived from TZDB at build time\n+            {\"Europe\/Lisbon\",    Locale.US, \"Western European Standard Time\",\n+                        \"WET\",\n+                        \"Western European Summer Time\",\n+                        \"WEST\",\n+                        \"Western European Time\",\n+                        \"WET\"},\n+            {\"Atlantic\/Azores\",    Locale.US, \"Azores Standard Time\",\n+                        \"GMT-01:00\",\n+                        \"Azores Summer Time\",\n+                        \"GMT\",\n+                        \"Azores Time\",\n+                        \"GMT-01:00\"},\n+            {\"Australia\/Perth\",    Locale.US, \"Australian Western Standard Time\",\n+                        \"AWST\",\n+                        \"Australian Western Daylight Time\",\n+                        \"AWDT\",\n+                        \"Western Australia Time\",\n+                        \"AWT\"},\n+            {\"Africa\/Harare\",    Locale.US, \"Central Africa Time\",\n+                        \"CAT\",\n+                        \"Harare Daylight Time\",\n+                        \"CAT\",\n+                        \"Harare Time\",\n+                        \"CAT\"},\n+            {\"Europe\/Dublin\",    Locale.US, \"Greenwich Mean Time\",\n+                        \"GMT\",\n+                        \"Irish Standard Time\",\n+                        \"IST\",\n+                        \"Dublin Time\",\n+                        \"GMT\"},\n+            {\"Pacific\/Gambier\",    Locale.US, \"Gambier Time\",\n+                        \"GMT-09:00\",\n+                        \"Gambier Daylight Time\",\n+                        \"GMT-09:00\",\n+                        \"Gambier Time\",\n+                        \"GMT-09:00\"},\n@@ -181,1 +220,1 @@\n-    @Test(dataProvider=\"noResourceTZs\")\n+    @Test(dataProvider=\"sampleTZs\")\n@@ -200,1 +239,1 @@\n-            Arrays.stream(Locale.getAvailableLocales())\n+            Locale.availableLocales()\n@@ -204,1 +243,1 @@\n-                .flatMap(zs -> Arrays.stream(zs))\n+                .flatMap(Arrays::stream)\n@@ -206,4 +245,2 @@\n-                .flatMap(names -> Arrays.stream(names))\n-                .filter(name -> Objects.isNull(name) || name.isEmpty())\n-                .findAny()\n-                .isPresent(),\n+                .flatMap(Arrays::stream)\n+                .anyMatch(name -> Objects.isNull(name) || name.isEmpty()),\n","filename":"test\/jdk\/sun\/util\/resources\/cldr\/TimeZoneNamesTest.java","additions":49,"deletions":12,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8165944\n+ * @bug 8165944 8318971\n@@ -156,0 +156,78 @@\n+    \/**\n+     * Containing non-existent file in the file list\n+     * The final jar should not be created and correct error message should be caught.\n+     * IOException is triggered as expected.\n+     *\/\n+    @Test\n+    public void testNonExistentFileInput() throws IOException {\n+        touch(\"existingTestFile.txt\");\n+        onCompletion = () -> rm(\"existingTestFile.txt\");\n+        try {\n+            jar(\"cf test.jar existingTestFile.txt nonExistentTestFile.txt\");\n+            Assert.fail(\"jar tool unexpectedly completed successfully\");\n+        } catch (IOException e) {\n+            Assert.assertEquals(e.getMessage().trim(), \"nonExistentTestFile.txt : no such file or directory\");\n+            Assert.assertTrue(Files.notExists(Path.of(\"test.jar\")), \"Jar file should not be created.\");\n+        }\n+    }\n+\n+    \/**\n+     * With @File as a part of jar command line, where the File is containing one or more\n+     * non-existent files or directories\n+     * The final jar should not be created and correct error message should be caught.\n+     * IOException is triggered as expected.\n+     *\/\n+    @Test\n+    public void testNonExistentFileInputClassList() throws IOException {\n+        touch(\"existingTestFile.txt\");\n+        touch(\"classes.list\");\n+        Files.writeString(Path.of(\"classes.list\"), \"\"\"\n+                existingTestFile.txt\n+                nonExistentTestFile.txt\n+                nonExistentDirectory\n+                 \"\"\");\n+        onCompletion = () -> rm(\"existingTestFile.txt classes.list\");\n+        try {\n+            jar(\"cf test.jar @classes.list\");\n+            Assert.fail(\"jar tool unexpectedly completed successfully\");\n+        } catch (IOException e) {\n+            String msg = e.getMessage().trim();\n+            Assert.assertTrue(msg.contains(\"nonExistentTestFile.txt : no such file or directory\"));\n+            Assert.assertTrue(msg.trim().contains(\"nonExistentDirectory : no such file or directory\"));\n+            Assert.assertTrue(Files.notExists(Path.of(\"test.jar\")), \"Jar file should not be created.\");\n+        }\n+\n+    }\n+\n+    \/**\n+     * Create a jar file; then with @File as a part of jar command line, where the File is containing one or more\n+     * non-existent files or directories\n+     * The final jar should not be created and correct error message should be caught.\n+     * IOException is triggered as expected.\n+     *\/\n+    @Test\n+    public void testUpdateNonExistentFileInputClassList() throws IOException {\n+        touch(\"existingTestFileUpdate.txt\");\n+        touch(\"existingTestFileUpdate2.txt\");\n+        touch(\"classesUpdate.list\");\n+        Files.writeString(Path.of(\"classesUpdate.list\"), \"\"\"\n+                existingTestFileUpdate2.txt\n+                nonExistentTestFileUpdate.txt\n+                nonExistentDirectoryUpdate\n+                 \"\"\");\n+        onCompletion = () -> rm(\"existingTestFileUpdate.txt existingTestFileUpdate2.txt \" +\n+                \"classesUpdate.list testUpdate.jar\");\n+        try {\n+            jar(\"cf testUpdate.jar existingTestFileUpdate.txt\");\n+            Assert.assertTrue(Files.exists(Path.of(\"testUpdate.jar\")));\n+            jar(\"uf testUpdate.jar @classesUpdate.list\");\n+            Assert.fail(\"jar tool unexpectedly completed successfully\");\n+        } catch (IOException e) {\n+            String msg = e.getMessage().trim();\n+            Assert.assertFalse(msg.contains(\"existingTestFileUpdate.txt : no such file or directory\"));\n+            Assert.assertTrue(msg.contains(\"nonExistentTestFileUpdate.txt : no such file or directory\"));\n+            Assert.assertTrue(msg.trim().contains(\"nonExistentDirectoryUpdate : no such file or directory\"));\n+        }\n+\n+    }\n+\n","filename":"test\/jdk\/tools\/jar\/InputFilesTest.java","additions":80,"deletions":2,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.util.FileUtils;\n+\n+import static jdk.test.lib.process.ProcessTools.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * @test\n+ * @bug 8322809\n+ * @library \/test\/lib\n+ * @modules jdk.compiler jdk.jlink\n+ * @build jdk.test.lib.compiler.CompilerUtils\n+ *        jdk.test.lib.process.ProcessTools\n+ *        jdk.test.lib.util.FileUtils\n+ *        ModuleMainClassTest\n+ * @run junit ModuleMainClassTest\n+ *\/\n+\n+public class ModuleMainClassTest {\n+    private static final String JAVA_HOME = System.getProperty(\"java.home\");\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+\n+    private static final Path SRC_DIR = Path.of(TEST_SRC, \"src\");\n+    private static final Path MODS_DIR = Path.of(\"mods\");\n+    private static final Path JMODS_DIR = Path.of(\"jmods\");\n+\n+    private static final Path IMAGE = Path.of(\"image\");\n+\n+    \/\/ the module names are sorted by the plugin and so these names cover\n+    \/\/ the cases that are before and after the elements of `jdk.*` modules\n+    \/\/ with main classes\n+    private static String[] modules = new String[] {\"com.foo\", \"net.foo\"};\n+\n+    private static boolean hasJmods() {\n+        if (!Files.exists(Paths.get(JAVA_HOME, \"jmods\"))) {\n+            System.err.println(\"Test skipped. NO jmods directory\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @BeforeAll\n+    public static void compileAll() throws Throwable {\n+        if (!hasJmods()) return;\n+\n+        for (String mn : modules) {\n+            Path msrc = SRC_DIR.resolve(mn);\n+            assertTrue(CompilerUtils.compile(msrc, MODS_DIR,\n+                    \"--module-source-path\", SRC_DIR.toString(),\n+                    \"--add-exports\", \"java.base\/jdk.internal.module=\" + mn));\n+        }\n+\n+        if (Files.exists(IMAGE)) {\n+            FileUtils.deleteFileTreeUnchecked(IMAGE);\n+        }\n+\n+        \/\/ create JMOD files\n+        Files.createDirectories(JMODS_DIR);\n+        Stream.of(modules).forEach(mn ->\n+                assertTrue(jmod(\"create\",\n+                        \"--class-path\", MODS_DIR.resolve(mn).toString(),\n+                        \"--main-class\", mn + \".Main\",\n+                        JMODS_DIR.resolve(mn + \".jmod\").toString()) == 0)\n+        );\n+\n+        \/\/ the run-time image created will have 4 modules with main classes\n+        createImage(IMAGE, \"com.foo\");\n+    }\n+\n+    @Test\n+    public void testComFoo() throws Exception {\n+        if (!hasJmods()) return;\n+\n+        Path java = IMAGE.resolve(\"bin\").resolve(\"java\");\n+        assertTrue(executeProcess(java.toString(),\n+                \"-m\", \"com.foo\")\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .getExitValue() == 0);\n+    }\n+\n+    @Test\n+    public void testNetFoo() throws Exception {\n+        if (!hasJmods()) return;\n+\n+        Path java = IMAGE.resolve(\"bin\").resolve(\"java\");\n+        assertTrue(executeProcess(java.toString(),\n+                \"-m\", \"net.foo\")\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .getExitValue() == 0);\n+    }\n+\n+    static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n+        .orElseThrow(() -> new RuntimeException(\"jlink tool not found\"));\n+\n+    static final ToolProvider JMOD_TOOL = ToolProvider.findFirst(\"jmod\")\n+        .orElseThrow(() -> new RuntimeException(\"jmod tool not found\"));\n+\n+    private static void createImage(Path outputDir, String... modules) throws Throwable {\n+        assertTrue(JLINK_TOOL.run(System.out, System.out,\n+                \"--output\", outputDir.toString(),\n+                \"--add-modules\", Arrays.stream(modules).collect(Collectors.joining(\",\")),\n+                \"--module-path\", JMODS_DIR.toString()) == 0);\n+    }\n+\n+    private static int jmod(String... options) {\n+        System.out.println(\"jmod \" + Arrays.asList(options));\n+        return JMOD_TOOL.run(System.out, System.out, options);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/plugins\/SystemModuleDescriptors\/ModuleMainClassTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.foo;\n+\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleFinder;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Sanity test if SystemModules pre-resolved at link-time for com.foo\n+ * with main class is loaded properly.\n+ *\/\n+public class Main {\n+    public static void main(String... args) throws Exception {\n+        ModuleDescriptor md = Main.class.getModule().getDescriptor();\n+        System.out.println(md);\n+\n+        checkMainClass(\"com.foo\", \"com.foo.Main\");\n+        checkMainClass(\"net.foo\", \"net.foo.Main\");\n+        Stream.of(\"jdk.httpserver\", \"jdk.jfr\").forEach(mn ->\n+                ModuleFinder.ofSystem().find(mn).get().descriptor().mainClass()\n+                            .orElseThrow(() -> new RuntimeException(mn + \" no main class\"))\n+        );\n+    }\n+\n+    static void checkMainClass(String mn, String mainClass) {\n+        String cn = ModuleFinder.ofSystem().find(mn).get().descriptor().mainClass().get();\n+        if (!cn.equals(mainClass)) {\n+            throw new RuntimeException(\"Mismatched main class of module \" + mn + \": \" + cn + \" expected: \" + mainClass);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/plugins\/SystemModuleDescriptors\/src\/com.foo\/com\/foo\/Main.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module com.foo {\n+    requires jdk.httpserver;\n+    requires net.foo;\n+}\n","filename":"test\/jdk\/tools\/jlink\/plugins\/SystemModuleDescriptors\/src\/com.foo\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module net.foo {\n+    requires jdk.jfr;\n+}\n","filename":"test\/jdk\/tools\/jlink\/plugins\/SystemModuleDescriptors\/src\/net.foo\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package net.foo;\n+\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleFinder;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Sanity test if SystemModules pre-resolved at link-time for net.foo\n+ * with main class is loaded properly.\n+ *\/\n+public class Main {\n+    public static void main(String... args) throws Exception {\n+        ModuleDescriptor md = Main.class.getModule().getDescriptor();\n+        System.out.println(md);\n+\n+        checkMainClass(\"com.foo\", \"com.foo.Main\");\n+        checkMainClass(\"net.foo\", \"net.foo.Main\");\n+        Stream.of(\"jdk.httpserver\", \"jdk.jfr\").forEach(mn ->\n+                ModuleFinder.ofSystem().find(mn).get().descriptor().mainClass()\n+                        .orElseThrow(() -> new RuntimeException(mn + \" no main class\"))\n+        );\n+    }\n+\n+    static void checkMainClass(String mn, String mainClass) {\n+        String cn = ModuleFinder.ofSystem().find(mn).get().descriptor().mainClass().get();\n+        if (!cn.equals(mainClass)) {\n+            throw new RuntimeException(\"Mismatched main class of module \" + mn + \": \" + cn + \" expected: \" + mainClass);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/plugins\/SystemModuleDescriptors\/src\/net.foo\/net\/foo\/Main.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n- * @run testng\/timeout=900\/othervm JavadocHelperTest\n+ * @run testng\/timeout=900\/othervm -Xmx1024m JavadocHelperTest\n","filename":"test\/langtools\/jdk\/internal\/shellsupport\/doc\/JavadocHelperTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.io.IOError;\n@@ -36,0 +37,1 @@\n+import java.nio.file.InvalidPathException;\n@@ -38,1 +40,0 @@\n-import java.util.Arrays;\n@@ -41,0 +42,1 @@\n+import java.util.Optional;\n@@ -112,0 +114,6 @@\n+ *\n+ * Note\n+ * ====\n+ *\n+ * If any of these tests cannot find a valid Object.java file in the test\n+ * environment, they will throw jtreg.SkippedException.\n@@ -139,14 +147,1 @@\n-        Path p = Path.of(System.getProperty(\"test.src\", \".\")).toAbsolutePath();\n-        while (!Files.exists(p.resolve(\"TEST.ROOT\"))) {\n-            p = p.getParent();\n-            if (p == null) {\n-                throw new SkippedException(\"can't find TEST.ROOT\");\n-            }\n-        }\n-        out.println(\"Test suite root: \" + p);\n-        Path javaBase = p.resolve(\"..\/..\/src\/java.base\").normalize();\n-        if (!Files.exists(javaBase)) {\n-            throw new SkippedException(\"can't find java.base\");\n-        }\n-        out.println(\"java.base: \" + javaBase);\n-\n+        var javaBase = findJavaBase();\n@@ -268,14 +263,1 @@\n-        Path p = Path.of(System.getProperty(\"test.src\", \".\")).toAbsolutePath();\n-        while (!Files.exists(p.resolve(\"TEST.ROOT\"))) {\n-            p = p.getParent();\n-            if (p == null) {\n-                throw new SkippedException(\"can't find TEST.ROOT\");\n-            }\n-        }\n-        System.err.println(\"Test suite root: \" + p);\n-        Path javaBase = p.resolve(\"..\/..\/src\/java.base\").normalize();\n-        if (!Files.exists(javaBase)) {\n-            throw new SkippedException(\"can't find java.base\");\n-        }\n-        System.err.println(\"java.base: \" + javaBase);\n-\n+        var javaBase = findJavaBase();\n@@ -309,14 +291,1 @@\n-        Path p = Path.of(System.getProperty(\"test.src\", \".\")).toAbsolutePath();\n-        while (!Files.exists(p.resolve(\"TEST.ROOT\"))) {\n-            p = p.getParent();\n-            if (p == null) {\n-                throw new SkippedException(\"can't find TEST.ROOT\");\n-            }\n-        }\n-        System.err.println(\"Test suite root: \" + p);\n-        Path javaBase = p.resolve(\"..\/..\/src\/java.base\").normalize();\n-        if (!Files.exists(javaBase)) {\n-            throw new SkippedException(\"can't find java.base\");\n-        }\n-        System.err.println(\"java.base: \" + javaBase);\n-\n+        var javaBase = findJavaBase();\n@@ -421,4 +390,1 @@\n-     * Takes a path to the java.base module, finds the Object.java file in\n-     * there, creates a copy of that file _with the modified doc comment_\n-     * for Object.equals in the provided destination directory and returns\n-     * the path to that created copy.\n+     * Locates source of the java.base module.\n@@ -426,4 +392,5 @@\n-    private Path createPatchedJavaLangObject(Path src, Path dst, String newComment)\n-            throws IOException {\n-        if (!Files.isDirectory(src) || !Files.isDirectory(dst)) {\n-            throw new IllegalArgumentException();\n+    private Path findJavaBase() {\n+        String testSrc = System.getProperty(\"test.src\");\n+        if (testSrc == null) {\n+            \/\/ shouldn't happen\n+            throw new SkippedException(\"test.src is not set\");\n@@ -431,6 +398,5 @@\n-        var obj = Path.of(\"java\/lang\/Object.java\");\n-        List<Path> files;\n-        \/\/ ensure Object.java is found and unique\n-        try (var s = Files.find(src, Integer.MAX_VALUE,\n-                (p, attr) -> attr.isRegularFile() && p.endsWith(obj))) {\n-            files = s.limit(2).toList(); \/\/ 2 is enough to deduce non-uniqueness\n+        Path start;\n+        try {\n+            start = Path.of(testSrc).toAbsolutePath();\n+        } catch (InvalidPathException | IOError e) {\n+            throw new SkippedException(\"Couldn't make sense of '\" + testSrc + \"'\", e);\n@@ -438,2 +404,7 @@\n-        if (files.size() != 1) {\n-            throw new IllegalStateException(Arrays.toString(files.toArray()));\n+        Path p = start;\n+        while (!Files.exists(p.resolve(\"TEST.ROOT\"))) {\n+            p = p.getParent();\n+            if (p == null) {\n+                \/\/ shouldn't happen as jtreg won't even run a test without TEST.ROOT\n+                throw new SkippedException(\"Couldn't find TEST.ROOT above '\" + start + \"'\");\n+            }\n@@ -441,13 +412,38 @@\n-        var original = files.get(0);\n-        out.println(\"found \" + original.toAbsolutePath());\n-        var source = Files.readString(original);\n-        var region = findDocCommentRegion(original);\n-        var newSource = source.substring(0, region.start)\n-                + newComment\n-                + source.substring(region.end);\n-        \/\/ create intermediate directories in the destination first, otherwise\n-        \/\/ writeString will throw java.nio.file.NoSuchFileException\n-        var copy = dst.resolve(src.relativize(original));\n-        out.println(\"to be copied to \" + copy);\n-        if (Files.notExists(copy.getParent())) {\n-            Files.createDirectories(copy.getParent());\n+        Path javaBase = p.resolve(\"..\/..\/src\/java.base\").normalize();\n+        out.println(\"Source for java.base is found at: \" + javaBase);\n+        return javaBase;\n+    }\n+\n+    \/*\n+     * Finds java\/lang\/Object.java rooted at src, creates a copy of that file\n+     * _with the modified doc comment_ for Object.equals in dst, and returns\n+     * the path to that copy.\n+     *\/\n+    private Path createPatchedJavaLangObject(Path src, Path dst, String newComment) {\n+        var obj = Path.of(\"java\/lang\/Object.java\");\n+        try {\n+            Optional<Path> files;\n+            try (var s = Files.find(src, Integer.MAX_VALUE,\n+                    (p, attr) -> attr.isRegularFile() && p.endsWith(obj))) {\n+                files = s.findAny();\n+            }\n+            if (files.isEmpty()) {\n+                throw new SkippedException(\"Couldn't find '\" + obj + \"' at '\" + src + \"'\");\n+            }\n+            var original = files.get();\n+            out.println(\"Found '\" + obj + \"' at \" + original.toAbsolutePath());\n+            var source = Files.readString(original);\n+            var region = findDocCommentRegion(original);\n+            var newSource = source.substring(0, region.start)\n+                    + newComment\n+                    + source.substring(region.end);\n+            \/\/ create intermediate directories in the destination first, otherwise\n+            \/\/ writeString will throw java.nio.file.NoSuchFileException\n+            var copy = dst.resolve(src.relativize(original));\n+            out.println(\"To be copied to '\" + copy + \"'\");\n+            if (Files.notExists(copy.getParent())) {\n+                Files.createDirectories(copy.getParent());\n+            }\n+            return Files.writeString(copy, newSource, StandardOpenOption.CREATE);\n+        } catch (IOException e) {\n+            throw new SkippedException(\"Couldn't create patched '\" + obj + \"'\", e);\n@@ -455,1 +451,0 @@\n-        return Files.writeString(copy, newSource, StandardOpenOption.CREATE);\n@@ -467,1 +462,1 @@\n-            throw new AssertionError();\n+            throw new SkippedException(\"Couldn't parse '\" + src + \"'\");\n@@ -471,0 +466,3 @@\n+        if (pathToEqualsMethod == null) {\n+            throw new SkippedException(\"Couldn't find the equals method in '\" + src + \"'\");\n+        }\n@@ -473,2 +471,3 @@\n-        if (docCommentTree == null)\n-            throw new AssertionError(\"cannot find the doc comment for java.lang.Object#equals\");\n+        if (docCommentTree == null) {\n+            throw new SkippedException(\"Couldn't find documentation for the equals method at '\" + src + \"'\");\n+        }\n@@ -513,1 +512,1 @@\n-                var parameterType = params.get(0).getType();\n+                var parameterType = params.getFirst().getType();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMethodCommentAlgorithm\/TestMethodCommentsAlgorithm.java","additions":77,"deletions":78,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8169676 8175055\n+ * @bug 8169676 8175055 8323016\n@@ -154,0 +154,69 @@\n+    @Test\n+    public void testOptionNotFound_NoSuggestions() {\n+        var result = new JavadocTask(tb, Task.Mode.CMDLINE)\n+                .options(\"--not-a-path\")\n+                .run(Task.Expect.FAIL)\n+                .writeAll();\n+        checkFound(String.join(\"\\n\", result.getOutputLines(Task.OutputKind.DIRECT)),\n+                \"\"\"\n+                    error: invalid flag: --not-a-path\n+                    For more details on available options, use --help or --help-extra\"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testOptionNotFound_OneSuggestion() {\n+        var result = new JavadocTask(tb, Task.Mode.CMDLINE)\n+                .options(\"--middle-path\")\n+                .run(Task.Expect.FAIL)\n+                .writeAll();\n+        checkFound(String.join(\"\\n\", result.getOutputLines(Task.OutputKind.DIRECT)),\n+                \"\"\"\n+                    error: invalid flag: --middle-path\n+                    Did you mean: --module-path\n+                    For more details on available options, use --help or --help-extra\"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testOptionNotFound_TwoSuggestions() {\n+        var result = new JavadocTask(tb, Task.Mode.CMDLINE)\n+                .options(\"--sourcepath\")\n+                .run(Task.Expect.FAIL)\n+                .writeAll();\n+        checkFound(String.join(\"\\n\", result.getOutputLines(Task.OutputKind.DIRECT)),\n+                \"\"\"\n+                    error: invalid flag: --sourcepath\n+                    Did you mean one of: --source-path -sourcepath\n+                    For more details on available options, use --help or --help-extra\"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testOptionNotFound_ThreeSuggestions() {\n+        var result = new JavadocTask(tb, Task.Mode.CMDLINE)\n+                .options(\"--classpath\")\n+                .run(Task.Expect.FAIL)\n+                .writeAll();\n+        checkFound(String.join(\"\\n\", result.getOutputLines(Task.OutputKind.DIRECT)),\n+                \"\"\"\n+                    error: invalid flag: --classpath\n+                    Did you mean one of: --class-path -classpath -bootclasspath\n+                    For more details on available options, use --help or --help-extra\"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testOptionNotFound_DocletOption() {\n+        var result = new JavadocTask(tb, Task.Mode.CMDLINE)\n+                .options(\"-tiglet\")\n+                .run(Task.Expect.FAIL)\n+                .writeAll();\n+        checkFound(String.join(\"\\n\", result.getOutputLines(Task.OutputKind.DIRECT)),\n+                \"\"\"\n+                    error: invalid flag: -tiglet\n+                    Did you mean: -taglet\n+                    For more details on available options, use --help or --help-extra\"\"\"\n+        );\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/BadOptionsTest.java","additions":71,"deletions":2,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8144903 8177466 8191842 8211694 8213725 8239536 8257236 8252409 8294431\n+ * @bug 8144903 8177466 8191842 8211694 8213725 8239536 8257236 8252409 8294431 8322003 8322532\n@@ -624,0 +624,17 @@\n+    public void underscoreAsLambdaParameter() { \/\/JDK-8322532\n+        assertAnalyze(\"Func f = _ -> 0; int i;\",\n+                      \"Func f = _ -> 0;\",\n+                      \" int i;\", true);\n+    }\n+\n+    public void intersectionTypeAsTypeArgument() { \/\/JDK-8322003\n+        assertEval(\"interface Shape {}\");\n+        assertEval(\"record Square(int edge) implements Shape {}\");\n+        assertEval(\"record Circle(int radius) implements Shape {}\");\n+        assertEval(\"java.util.function.Consumer<Shape> printShape = System.out::println;\");\n+        assertEval(\"Square square = new Square(1);\");\n+        assertEval(\"Circle circle = new Circle(1);\");\n+        assertEval(\"var shapes = java.util.List.of(square, circle);\");\n+        assertEval(\"shapes.forEach(printShape);\");\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/VariablesTest.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-        subtypeNames.sort((s1, s2) -> s1.compareTo(s2));\n@@ -698,0 +697,34 @@\n+\n+    @Test\n+    public void testClientSwapsPermittedSubclassesOrder(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path foo = src.resolve(\"Foo.java\");\n+        Path fooUser = src.resolve(\"FooUser.java\");\n+\n+        tb.writeFile(foo,\n+                \"\"\"\n+                public sealed interface Foo {\n+                    record R1() implements Foo {}\n+                    record R2() implements Foo {}\n+                }\n+                \"\"\");\n+\n+        tb.writeFile(fooUser,\n+                \"\"\"\n+                public class FooUser {\n+                    \/\/ see that the order of arguments differ from the order of subclasses of Foo in the source above\n+                    \/\/ we need to check that the order of permitted subclasses of Foo in the class file corresponds to the\n+                    \/\/ original order in the source code\n+                    public void blah(Foo.R2 a, Foo.R1 b) {}\n+                }\n+                \"\"\");\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(fooUser, foo)\n+                .run();\n+        checkSealedClassFile(out, \"Foo.class\", List.of(\"Foo$R1\", \"Foo$R2\"));\n+    }\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedDiffConfigurationsTest.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -767,1 +767,1 @@\n-    public static OutputAnalyzer executeProcess(String... cmds) throws Throwable {\n+    public static OutputAnalyzer executeProcess(String... cmds) throws Exception {\n@@ -812,2 +812,1 @@\n-    public static OutputAnalyzer executeCommand(String... cmds)\n-            throws Throwable {\n+    public static OutputAnalyzer executeCommand(String... cmds) throws Exception {\n@@ -830,2 +829,1 @@\n-    public static OutputAnalyzer executeCommand(ProcessBuilder pb)\n-            throws Throwable {\n+    public static OutputAnalyzer executeCommand(ProcessBuilder pb) throws Exception {\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.vm.compiler;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@State(Scope.Thread)\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Warmup(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n-@Fork(value = 3)\n-public class ComputePI {\n-\n-  @Benchmark\n-  public double compute_pi_int_dbl() {\n-    double pi = 4.0;\n-    boolean sign = false;\n-\n-    for (int i = 3; i < 1000; i += 2) {\n-      if (sign) {\n-        pi += 4.0 \/ i;\n-      } else {\n-        pi -= 4.0 \/ i;\n-      }\n-      sign = !sign;\n-    }\n-    return pi;\n-  }\n-\n-  @Benchmark\n-  public double compute_pi_int_flt() {\n-    float pi = 4.0f;\n-    boolean sign = false;\n-\n-    for (int i = 3; i < 1000; i += 2) {\n-      if (sign) {\n-        pi += 4.0f \/ i;\n-      } else {\n-        pi -= 4.0f \/ i;\n-      }\n-      sign = !sign;\n-    }\n-    return pi;\n-  }\n-\n-  @Benchmark\n-  public double compute_pi_long_dbl() {\n-    double pi = 4.0;\n-    boolean sign = false;\n-\n-    for (long i = 3; i < 1000; i += 2) {\n-      if (sign) {\n-        pi += 4.0 \/ i;\n-      } else {\n-        pi -= 4.0 \/ i;\n-      }\n-      sign = !sign;\n-    }\n-    return pi;\n-  }\n-\n-  @Benchmark\n-  public double compute_pi_long_flt() {\n-    float pi = 4.0f;\n-    boolean sign = false;\n-\n-    for (long i = 3; i < 1000; i += 2) {\n-      if (sign) {\n-        pi += 4.0f \/ i;\n-      } else {\n-        pi -= 4.0f \/ i;\n-      }\n-      sign = !sign;\n-    }\n-    return pi;\n-  }\n-\n-  @Benchmark\n-  public double compute_pi_flt_dbl() {\n-    double pi = 4.0;\n-    boolean sign = false;\n-\n-    for (float i = 3.0f; i < 1000.0f; i += 2.0f) {\n-      if (sign) {\n-        pi += 4.0 \/ i;\n-      } else {\n-        pi -= 4.0 \/ i;\n-      }\n-      sign = !sign;\n-    }\n-    return pi;\n-  }\n-\n-  @Benchmark\n-  public double compute_pi_dbl_flt() {\n-    float pi = 4.0f;\n-    boolean sign = false;\n-\n-    for (float i = 3.0f; i < 1000.0f; i += 2.0f) {\n-      if (sign) {\n-        pi += 4.0f \/ i;\n-      } else {\n-        pi -= 4.0f \/ i;\n-      }\n-      sign = !sign;\n-    }\n-    return pi;\n-  }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/ComputePI.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"}]}