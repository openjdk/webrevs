{"files":[{"patch":"@@ -706,1 +706,1 @@\n-                false, success_flag, true);\n+                false, success_flag, nullptr, true);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  if (!heap->is_in(loc)) return;\n+  if (!heap->is_in_reserved(loc)) return;\n@@ -83,1 +83,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -102,1 +102,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -119,1 +119,1 @@\n-  bool loc_in_heap = (loc != nullptr && heap->is_in(loc));\n+  bool loc_in_heap = (loc != nullptr && heap->is_in_reserved(loc));\n@@ -172,1 +172,1 @@\n-void ShenandoahAsserts::assert_in_heap(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds(void* interior_loc, oop obj, const char *file, int line) {\n@@ -175,3 +175,3 @@\n-  if (!heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap failed\",\n-                  \"oop must point to a heap address\",\n+  if (!heap->is_in_reserved(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds failed\",\n+                  \"oop must be in heap bounds\",\n@@ -182,1 +182,1 @@\n-void ShenandoahAsserts::assert_in_heap_or_null(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char *file, int line) {\n@@ -185,3 +185,3 @@\n-  if (obj != nullptr && !heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_or_null failed\",\n-                  \"oop must point to a heap address\",\n+  if (obj != nullptr && !heap->is_in_reserved(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds_or_null failed\",\n+                  \"oop must be in heap bounds\",\n@@ -197,1 +197,1 @@\n-  if (!heap->is_in(obj)) {\n+  if (!heap->is_in_reserved(obj)) {\n@@ -199,1 +199,1 @@\n-                  \"oop must point to a heap address\",\n+                  \"oop must be in heap bounds\",\n@@ -216,0 +216,6 @@\n+  if (!heap->is_in(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                  \"Object should be in active region area\",\n+                  file, line);\n+  }\n+\n@@ -229,1 +235,1 @@\n-    if (!heap->is_in(fwd)) {\n+    if (!heap->is_in_reserved(fwd)) {\n@@ -231,1 +237,1 @@\n-                    \"Forwardee must point to a heap address\",\n+                    \"Forwardee must be in heap bounds\",\n@@ -242,0 +248,6 @@\n+    if (!heap->is_in(fwd)) {\n+      print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                    \"Forwardee should be in active region area\",\n+                    file, line);\n+    }\n+\n@@ -244,1 +256,1 @@\n-                    \"Non-trivial forwardee should in another region\",\n+                    \"Non-trivial forwardee should be in another region\",\n@@ -260,1 +272,1 @@\n-  if (java_lang_Class::is_instance(obj)) {\n+  if (Universe::is_fully_initialized() && (obj_klass == vmClasses::Class_klass())) {\n@@ -289,1 +301,3 @@\n-  if (alloc_size > ShenandoahHeapRegion::humongous_threshold_words()) {\n+  HeapWord* obj_end = cast_from_oop<HeapWord*>(obj) + alloc_size;\n+\n+  if (ShenandoahHeapRegion::requires_humongous(alloc_size)) {\n@@ -291,2 +305,2 @@\n-    size_t num_regions = ShenandoahHeapRegion::required_regions(alloc_size * HeapWordSize);\n-    for (size_t i = idx; i < idx + num_regions; i++) {\n+    size_t end_idx = heap->heap_region_index_containing(obj_end - 1);\n+    for (size_t i = idx; i < end_idx; i++) {\n@@ -305,0 +319,6 @@\n+  } else {\n+    if (obj_end > r->top()) {\n+      print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_correct_region failed\",\n+                    \"Object end should be within the active area of the region\",\n+                    file, line);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-  static void assert_in_heap(void* interior_loc, oop obj, const char* file, int line);\n-  static void assert_in_heap_or_null(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char* file, int line);\n@@ -81,4 +81,4 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap(interior_loc, obj, __FILE__, __LINE__)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap_or_null(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds_or_null(interior_loc, obj, __FILE__, __LINE__)\n@@ -186,2 +186,2 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  shenandoah_assert_in_heap_or_null(nullptr, p);\n+  shenandoah_assert_in_heap_bounds_or_null(nullptr, p);\n@@ -50,1 +50,1 @@\n-  assert(p == nullptr || _heap->is_in(p), \"Must be in the heap\");\n+  assert(p == nullptr || _heap->is_in_reserved(p), \"Must be in the heap\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -709,6 +709,0 @@\n-      \/\/ Verify before arming for concurrent processing.\n-      \/\/ Otherwise, verification can trigger stack processing.\n-      if (ShenandoahVerify) {\n-        heap->verifier()->verify_during_evacuation();\n-      }\n-\n@@ -839,4 +833,1 @@\n-        \/\/ Here we are asserting that an unmarked from-space object is 'correct'. There seems to be a legitimate\n-        \/\/ use-case for accessing from-space objects during concurrent class unloading. In all modes of Shenandoah,\n-        \/\/ concurrent class unloading only happens during a global collection.\n-        shenandoah_assert_correct(p, obj);\n+        \/\/ Note: The obj is dead here. Do not touch it, just clear.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -361,5 +361,0 @@\n-\n-    if(ShenandoahVerify) {\n-      heap->verifier()->verify_during_evacuation();\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1972,1 +1972,1 @@\n-  if (req.size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+  if (ShenandoahHeapRegion::requires_humongous(req.size())) {\n@@ -1982,2 +1982,1 @@\n-        assert(false, \"Trying to allocate TLAB larger than the humongous threshold: \" SIZE_FORMAT \" > \" SIZE_FORMAT,\n-               req.size(), ShenandoahHeapRegion::humongous_threshold_words());\n+        assert(false, \"Trying to allocate TLAB in humongous region: \" SIZE_FORMAT, req.size());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-  \/\/ Precondition: req.size() <= ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ Precondition: !ShenandoahHeapRegion::requires_humongous(req.size())\n@@ -320,1 +320,1 @@\n-  \/\/ Precondition: req.size() > ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ Precondition: ShenandoahHeapRegion::requires_humongous(req.size())\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -708,1 +709,1 @@\n-    if (wasted_bytes > 0 && req.actual_size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+    if (wasted_bytes > 0 && ShenandoahHeapRegion::requires_humongous(req.actual_size())) {\n@@ -782,0 +783,15 @@\n+bool ShenandoahHeap::is_in(const void* p) const {\n+  if (is_in_reserved(p)) {\n+    if (is_full_gc_move_in_progress()) {\n+      \/\/ Full GC move is running, we do not have a consistent region\n+      \/\/ information yet. But we know the pointer is in heap.\n+      return true;\n+    }\n+    \/\/ Now check if we point to a live section in active region.\n+    ShenandoahHeapRegion* r = heap_region_containing(p);\n+    return (r->is_active() && p < r->top());\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -2669,0 +2685,77 @@\n+HeapWord* ShenandoahHeap::allocate_loaded_archive_space(size_t size) {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ CDS wants a continuous memory range to load a bunch of objects.\n+  \/\/ This effectively bypasses normal allocation paths, and requires\n+  \/\/ a bit of massaging to unbreak GC invariants.\n+\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);\n+\n+  \/\/ Easy case: a single regular region, no further adjustments needed.\n+  if (!ShenandoahHeapRegion::requires_humongous(size)) {\n+    return allocate_memory(req);\n+  }\n+\n+  \/\/ Hard case: the requested size would cause a humongous allocation.\n+  \/\/ We need to make sure it looks like regular allocation to the rest of GC.\n+\n+  \/\/ CDS code would guarantee no objects straddle multiple regions, as long as\n+  \/\/ regions are as large as MIN_GC_REGION_ALIGNMENT. It is impractical at this\n+  \/\/ point to deal with case when Shenandoah runs with smaller regions.\n+  \/\/ TODO: This check can be dropped once MIN_GC_REGION_ALIGNMENT agrees more with Shenandoah.\n+  if (ShenandoahHeapRegion::region_size_bytes() < ArchiveHeapWriter::MIN_GC_REGION_ALIGNMENT) {\n+    return nullptr;\n+  }\n+\n+  HeapWord* mem = allocate_memory(req);\n+  size_t start_idx = heap_region_index_containing(mem);\n+  size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+\n+  \/\/ Flip humongous -> regular.\n+  {\n+    ShenandoahHeapLocker locker(lock(), false);\n+    for (size_t c = start_idx; c < start_idx + num_regions; c++) {\n+      get_region(c)->make_regular_bypass();\n+    }\n+  }\n+\n+  return mem;\n+#else\n+  assert(false, \"Archive heap loader should not be available, should not be here\");\n+  return nullptr;\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+}\n+\n+void ShenandoahHeap::complete_loaded_archive_space(MemRegion archive_space) {\n+  \/\/ Nothing to do here, except checking that heap looks fine.\n+#ifdef ASSERT\n+  HeapWord* start = archive_space.start();\n+  HeapWord* end = archive_space.end();\n+\n+  \/\/ No unclaimed space between the objects.\n+  \/\/ Objects are properly allocated in correct regions.\n+  HeapWord* cur = start;\n+  while (cur < end) {\n+    oop oop = cast_to_oop(cur);\n+    shenandoah_assert_in_correct_region(nullptr, oop);\n+    cur += oop->size();\n+  }\n+\n+  \/\/ No unclaimed tail at the end of archive space.\n+  assert(cur == end,\n+         \"Archive space should be fully used: \" PTR_FORMAT \" \" PTR_FORMAT,\n+         p2i(cur), p2i(end));\n+\n+  \/\/ Region bounds are good.\n+  ShenandoahHeapRegion* begin_reg = heap_region_containing(start);\n+  ShenandoahHeapRegion* end_reg = heap_region_containing(end);\n+  assert(begin_reg->is_regular(), \"Must be\");\n+  assert(end_reg->is_regular(), \"Must be\");\n+  assert(begin_reg->bottom() == start,\n+         \"Must agree: archive-space-start: \" PTR_FORMAT \", begin-region-bottom: \" PTR_FORMAT,\n+         p2i(start), p2i(begin_reg->bottom()));\n+  assert(end_reg->top() == end,\n+         \"Must agree: archive-space-end: \" PTR_FORMAT \", end-region-top: \" PTR_FORMAT,\n+         p2i(end), p2i(end_reg->top()));\n+#endif\n+}\n+\n@@ -2690,0 +2783,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":95,"deletions":1,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -601,1 +601,3 @@\n-  inline bool is_in(const void* p) const override;\n+  \/\/ Check the pointer is in active part of Java heap.\n+  \/\/ Use is_in_reserved to check if object is within heap bounds.\n+  bool is_in(const void* p) const override;\n@@ -657,0 +659,6 @@\n+\/\/ ---------- CDS archive support\n+\n+  bool can_load_archived_objects() const override { return UseCompressedOops && !ShenandoahCardBarrier; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n+  void complete_loaded_archive_space(MemRegion archive_space) override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -348,6 +348,0 @@\n-bool ShenandoahHeap::is_in(const void* p) const {\n-  HeapWord* heap_base = (HeapWord*) base();\n-  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n-  return p >= heap_base && p < last_region_end;\n-}\n-\n@@ -357,1 +351,1 @@\n-    assert(is_in(obj), \"Otherwise shouldn't return true below\");\n+    assert(is_in_reserved(obj), \"Otherwise shouldn't return true below\");\n@@ -369,1 +363,1 @@\n-  assert(is_in(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n+  assert(is_in_reserved(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n@@ -395,1 +389,1 @@\n-  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::YOUNG_GENERATION);\n+  return is_in_reserved(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::YOUNG_GENERATION);\n@@ -399,1 +393,1 @@\n-  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::OLD_GENERATION);\n+  return is_in_reserved(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::OLD_GENERATION);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-\n@@ -63,2 +62,0 @@\n-size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;\n-size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;\n@@ -147,2 +144,4 @@\n-  assert (ShenandoahHeap::heap()->is_full_gc_in_progress() || ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),\n-          \"only for full or degen GC\");\n+  assert (!Universe::is_fully_initialized() ||\n+          ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+          ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),\n+          \"Only for STW GC or when Universe is initializing (CDS)\");\n@@ -157,0 +156,8 @@\n+      if (_state == _humongous_start || _state == _humongous_cont) {\n+        \/\/ CDS allocates chunks of the heap to fill with regular objects. The allocator\n+        \/\/ will dutifully track any waste in the unused portion of the last region. Once\n+        \/\/ CDS has finished initializing the objects, it will convert these regions to\n+        \/\/ regular regions. The 'waste' in the last region is no longer wasted at this point,\n+        \/\/ so we must stop treating it as such.\n+        decrement_humongous_waste();\n+      }\n@@ -750,11 +757,1 @@\n-  guarantee(HumongousThresholdWords == 0, \"we should only set it once\");\n-  HumongousThresholdWords = RegionSizeWords * ShenandoahHumongousThreshold \/ 100;\n-  HumongousThresholdWords = align_down(HumongousThresholdWords, MinObjAlignment);\n-  assert (HumongousThresholdWords <= RegionSizeWords, \"sanity\");\n-\n-  guarantee(HumongousThresholdBytes == 0, \"we should only set it once\");\n-  HumongousThresholdBytes = HumongousThresholdWords * HeapWordSize;\n-  assert (HumongousThresholdBytes <= RegionSizeBytes, \"sanity\");\n-\n-  MaxTLABSizeWords = MIN2(RegionSizeWords, HumongousThresholdWords);\n-  MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);\n+  MaxTLABSizeWords = align_down(RegionSizeWords, MinObjAlignment);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -231,2 +231,0 @@\n-  static size_t HumongousThresholdBytes;\n-  static size_t HumongousThresholdWords;\n@@ -282,0 +280,4 @@\n+  inline static bool requires_humongous(size_t words) {\n+    return words > ShenandoahHeapRegion::RegionSizeWords;\n+  }\n+\n@@ -334,8 +336,0 @@\n-  inline static size_t humongous_threshold_bytes() {\n-    return ShenandoahHeapRegion::HumongousThresholdBytes;\n-  }\n-\n-  inline static size_t humongous_threshold_words() {\n-    return ShenandoahHeapRegion::HumongousThresholdWords;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  assert(ShenandoahHeap::heap()->is_in(addr),\n+  assert(ShenandoahHeap::heap()->is_in_reserved(addr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-  inline bool is_marked(oop) const;\n+  inline bool is_marked(oop obj) const;\n+  inline bool is_marked(HeapWord* raw_obj) const;\n@@ -66,0 +67,1 @@\n+  inline bool is_marked_strong(HeapWord* raw_obj) const;\n@@ -72,1 +74,1 @@\n-  inline bool allocated_after_mark_start(oop obj) const;\n+  inline bool allocated_after_mark_start(const oop obj) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked(cast_from_oop<HeapWord *>(obj));\n+  return is_marked(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked(raw_obj);\n@@ -46,1 +50,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+  return is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked_strong(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked_strong(raw_obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -112,0 +112,11 @@\n+inline oop reference_coop_decode_raw(narrowOop v) {\n+  return CompressedOops::is_null(v) ? nullptr : CompressedOops::decode_raw(v);\n+}\n+\n+inline oop reference_coop_decode_raw(oop v) {\n+  return v;\n+}\n+\n+\/\/ Raw referent, it can be dead. You cannot treat it as oop without additional safety\n+\/\/ checks, this is why it is HeapWord*. The decoding uses a special-case inlined\n+\/\/ CompressedOops::decode method that bypasses normal oop-ness checks.\n@@ -113,3 +124,3 @@\n-static oop reference_referent(oop reference) {\n-  T heap_oop = Atomic::load(reference_referent_addr<T>(reference));\n-  return CompressedOops::decode(heap_oop);\n+static HeapWord* reference_referent_raw(oop reference) {\n+  T raw_oop = Atomic::load(reference_referent_addr<T>(reference));\n+  return cast_from_oop<HeapWord*>(reference_coop_decode_raw(raw_oop));\n@@ -313,2 +324,2 @@\n-  const oop referent = reference_referent<T>(reference);\n-  if (referent == nullptr) {\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+  if (raw_referent == nullptr) {\n@@ -324,1 +335,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(raw_referent);\n@@ -326,1 +337,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(raw_referent);\n@@ -338,1 +349,1 @@\n-    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent<T>(reference)), \"only make inactive final refs with alive referents\");\n+    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent_raw<T>(reference)), \"only make inactive final refs with alive referents\");\n@@ -425,0 +436,7 @@\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+\n+#ifdef ASSERT\n+  assert(raw_referent == nullptr || ShenandoahHeap::heap()->marking_context()->is_marked(raw_referent),\n+         \"only drop references with alive referents\");\n+#endif\n+\n@@ -426,2 +444,0 @@\n-  oop referent = reference_referent<T>(reference);\n-  assert(referent == nullptr || heap->marking_context()->is_marked(referent), \"only drop references with alive referents\");\n@@ -436,1 +452,1 @@\n-  if (heap->mode()->is_generational() && heap->is_in_old(reference) && heap->is_in_young(referent)) {\n+  if (heap->mode()->is_generational() && heap->is_in_old(reference) && heap->is_in_young(raw_referent)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -59,7 +59,0 @@\n-class ShenandoahIgnoreReferenceDiscoverer : public ReferenceDiscoverer {\n-public:\n-  virtual bool discover_reference(oop obj, ReferenceType type) {\n-    return true;\n-  }\n-};\n-\n@@ -76,0 +69,1 @@\n+  ReferenceIterationMode _ref_mode;\n@@ -93,1 +87,7 @@\n-      set_ref_discoverer_internal(new ShenandoahIgnoreReferenceDiscoverer());\n+      \/\/ Unknown status for Reference.referent field. Do not touch it, it might be dead.\n+      \/\/ Normally, barriers would prevent us from seeing the dead referents, but verifier\n+      \/\/ runs with barriers disabled.\n+      _ref_mode = DO_FIELDS_EXCEPT_REFERENT;\n+    } else {\n+      \/\/ Otherwise do all fields.\n+      _ref_mode = DO_FIELDS;\n@@ -103,0 +103,4 @@\n+  ReferenceIterationMode reference_iteration_mode() override {\n+    return _ref_mode;\n+  }\n+\n@@ -144,2 +148,2 @@\n-    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in(obj),\n-              \"oop must be in heap\");\n+    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in_reserved(obj),\n+              \"oop must be in heap bounds\");\n@@ -204,2 +208,2 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in(fwd),\n-             \"Forwardee must be in heap\");\n+      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in_reserved(fwd),\n+             \"Forwardee must be in heap bounds\");\n@@ -222,0 +226,3 @@\n+      check(ShenandoahAsserts::_safe_oop, obj, fwd_reg->is_active(),\n+            \"Forwardee should be in active region\");\n+\n@@ -242,1 +249,1 @@\n-    if (java_lang_Class::is_instance(obj)) {\n+    if (obj_klass == vmClasses::Class_klass()) {\n@@ -811,8 +818,0 @@\n-      case _verify_gcstate_evacuation:\n-        enabled = true;\n-        expected = ShenandoahHeap::EVACUATION;\n-        if (!_heap->is_stw_gc_in_progress()) {\n-          \/\/ Only concurrent GC sets this.\n-          expected |= ShenandoahHeap::WEAK_ROOTS;\n-        }\n-        break;\n@@ -1103,28 +1102,0 @@\n-void ShenandoahVerifier::verify_during_evacuation() {\n-  verify_at_safepoint(\n-          \"During Evacuation\",\n-          _verify_remembered_disable, \/\/ do not verify remembered set\n-          _verify_forwarded_allow,    \/\/ some forwarded references are allowed\n-          _verify_marked_disable,     \/\/ walk only roots\n-          _verify_cset_disable,       \/\/ some cset references are not forwarded yet\n-          _verify_liveness_disable,   \/\/ liveness data might be already stale after pre-evacs\n-          _verify_regions_disable,    \/\/ trash regions not yet recycled\n-          _verify_size_disable,       \/\/ we don't know how much of promote-in-place work has been completed\n-          _verify_gcstate_evacuation  \/\/ evacuation is in progress\n-  );\n-}\n-\n-void ShenandoahVerifier::verify_after_evacuation() {\n-  verify_at_safepoint(\n-          \"After Evacuation\",\n-          _verify_remembered_disable,  \/\/ do not verify remembered set\n-          _verify_forwarded_allow,     \/\/ objects are still forwarded\n-          _verify_marked_complete,     \/\/ bitmaps might be stale, but alloc-after-mark should be well\n-          _verify_cset_forwarded,      \/\/ all cset refs are fully forwarded\n-          _verify_liveness_disable,    \/\/ no reliable liveness data anymore\n-          _verify_regions_notrash,     \/\/ trash regions have been recycled already\n-          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n-          _verify_gcstate_forwarded    \/\/ evacuation produced some forwarded objects\n-  );\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":20,"deletions":49,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -174,3 +174,0 @@\n-    \/\/ Evacuation is in progress, some objects are forwarded\n-    _verify_gcstate_evacuation,\n-\n@@ -219,2 +216,0 @@\n-  void verify_during_evacuation();\n-  void verify_after_evacuation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -133,7 +133,0 @@\n-  product(intx, ShenandoahHumongousThreshold, 100, EXPERIMENTAL,            \\\n-          \"Humongous objects are allocated in separate regions. \"           \\\n-          \"This setting defines how large the object should be to be \"      \\\n-          \"deemed humongous. Value is in  percents of heap region size. \"   \\\n-          \"This also caps the maximum TLAB size.\")                          \\\n-          range(1, 100)                                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2501,0 +2501,7 @@\n+\/\/ Available cpus of the host machine, Linux only.\n+\/\/ Used in container testing.\n+WB_ENTRY(jint, WB_HostCPUs(JNIEnv* env, jobject o))\n+  LINUX_ONLY(return os::Linux::active_processor_count();)\n+  return -1; \/\/ Not used\/implemented on other platforms\n+WB_END\n+\n@@ -2586,1 +2593,1 @@\n-      current_frame->print_value_on(&st, nullptr);\n+      current_frame->print_value_on(&st);\n@@ -2942,0 +2949,1 @@\n+  {CC\"hostCPUs\",                  CC\"()I\",            (void*)&WB_HostCPUs },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n- * @run main\/othervm\/timeout=300 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}